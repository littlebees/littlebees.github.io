<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leetcode 1857 - Largest Color Value in a Directed Graph | 記事本</title>
<meta name=keywords content="Counting,Memoization,Topological Sort,Graph,Dynamic Programming,Hash Table"><meta name=description content="動機
leetcode復健，原本以為只是複習topo sort&mldr;"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2024/04/leetcode-1857-largest-color-value-in-a-directed-graph/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2024/04/leetcode-1857-largest-color-value-in-a-directed-graph/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Leetcode 1857 - Largest Color Value in a Directed Graph"><meta property="og:description" content="動機
leetcode復健，原本以為只是複習topo sort&mldr;"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2024/04/leetcode-1857-largest-color-value-in-a-directed-graph/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-13T12:48:24+08:00"><meta property="article:modified_time" content="2024-04-13T12:48:24+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="Leetcode 1857 - Largest Color Value in a Directed Graph"><meta name=twitter:description content="動機
leetcode復健，原本以為只是複習topo sort&mldr;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Leetcode 1857 - Largest Color Value in a Directed Graph","item":"https://littlebees.github.io/2024/04/leetcode-1857-largest-color-value-in-a-directed-graph/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Leetcode 1857 - Largest Color Value in a Directed Graph","name":"Leetcode 1857 - Largest Color Value in a Directed Graph","description":"動機 leetcode復健，原本以為只是複習topo sort\u0026hellip;\n","keywords":["Counting","Memoization","Topological Sort","Graph","Dynamic Programming","Hash Table"],"articleBody":"動機 leetcode復健，原本以為只是複習topo sort…\nProblem There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1.\nYou are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj.\nA valid path in the graph is a sequence of nodes x1 -\u003e x2 -\u003e x3 -\u003e ... -\u003e xk such that there is a directed edge from xi to xi+1 for every 1 \u003c= i \u003c k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path.\nReturn the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.\nExample 1:\nInput: colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]Output: 3Explanation: The path 0 -\u003e 2 -\u003e 3 -\u003e 4 contains 3 nodes that are colored \"a\" (red in the above image).Example 2:\nInput: colors = \"a\", edges = [[0,0]]Output: -1Explanation: There is a cycle from 0 to 0. Constraints:\nn == colors.lengthm == edges.length1 \u003c= n \u003c= 1050 \u003c= m \u003c= 105colors consists of lowercase English letters.0 \u003c= aj, bj \u003c n ver1 TLE: 純topo 我們很懶，所以所有dfs需要的東西都往args裡面丟。\n如果是用一個大表表示有沒有被visited過需要多一個狀態是還在dfs中，但這裡是直接放到args裡面所以不用\nclass Solution: def dfs(self, graph, node, visited, colors): colors[self.color[node]] += 1 if node in visited or self.maxCnt == -1: #print(f'LOOP {node} {visited} {colors}') self.maxCnt = -1 elif not graph[node]: #print(f'GOAL {node} {visited} {colors} {colors.most_common(1)}') self.maxCnt = max(colors.most_common(1)[0][1], self.maxCnt) else: visited.add(node) #print(f'PATH {node} {visited} {colors}') [self.dfs(graph, k, visited, colors) for k in graph[node] if self.maxCnt != -1] visited.remove(node) colors[self.color[node]] -= 1 def largestPathValue(self, colors: str, edges: List[List[int]]) -\u003e int: self.maxCnt = 0 self.color = '' G = defaultdict(list) self.color = colors [G[k].append(v) for (k,v) in edges] # 1. list all nodes whose in-degree is 0 degree0 = set(range(len(colors))) - set(v for (k,v) in edges) #print(f'GGG {degree0} {G}') [self.dfs(G, k, set(), Counter()) for k in degree0 if self.maxCnt != -1] return self.maxCnt if degree0 else -1 sol 真的太久沒做LC了，沒想到這是最佳化問題，所以一定是窮舉，有可能是DP或是greedy。 但那這個結構有可以優化的地方嗎? 這是path，而path一定是建構在另一個path上!! 所以可以DP\n但該走的還是得走，所以還是topo sort\nDP什麼? 我們需要的是某條path最多的(max)顏色數，所有有兩個參數顏色與節點，但節點是哪個節點? 是path的開始還是path的終點?\n如果是我會看我想怎麼寫dp如果是top-down(可以直接用@cache)就要是path的開始，如果是bottom-up就要是path的終點。 而是要寫top-down還是bottom-up是看人，大部分兩個都會通，但根據資料的特性有得時候用另一個會有自然的好處，像是如果dp參數有長度就最好從bottom-up。 如果長度未知，像這題，就可以直接top-down，因為top-down會自動分解要處理的對象，而長度就不能這樣做。\n不過這個code的效率是超差的，但我只是來復健(python都要一直反覆查api才知道怎麼用…)，所以算了，而且code很短，可以容納在白板中\nclass Solution: @cache def dp(self, node, color): if node in self.visited: return float(\"inf\") ans = 1 if self.color[node] == color else 0 if self.graph[node]: self.visited.add(node) ans += max(self.dp(k, color) for k in self.graph[node]) self.visited.remove(node) return ans def largestPathValue(self, colors: str, edges: List[List[int]]) -\u003e int: self.colorSet = set(colors) self.graph = defaultdict(list) self.color = colors self.visited = set() [self.graph[k].append(v) for (k,v) in edges] ans = max(self.dp(k, c) for k in range(len(colors)) for c in self.colorSet) #[print(f'{k},{c} :: {self.dp(k,c)}') for k in range(len(colors)) for c in self.colorSet] return -1 if ans == float(\"inf\") else ans ","wordCount":"464","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2024-04-13T12:48:24+08:00","dateModified":"2024-04-13T12:48:24+08:00","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2024/04/leetcode-1857-largest-color-value-in-a-directed-graph/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Leetcode 1857 - Largest Color Value in a Directed Graph</h1><div class=post-meta><span title='2024-04-13 12:48:24 +0800 +0800'>April 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#ver1-tle-%e7%b4%94topo aria-label="ver1 TLE: 純topo">ver1 TLE: 純topo</a><ul><li><a href=#sol aria-label=sol>sol</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>leetcode復健，原本以為只是複習topo sort&mldr;</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>There is a <strong>directed graph</strong> of <code>n</code> colored nodes and <code>m</code> edges. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p><p>You are given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the <strong>color</strong> of the <code>i<sup>th</sup></code> node in this graph (<strong>0-indexed</strong>). You are also given a 2D array <code>edges</code> where <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> indicates that there is a <strong>directed edge</strong> from node <code>a<sub>j</sub></code> to node <code>b<sub>j</sub></code>.</p><p>A valid <strong>path</strong> in the graph is a sequence of nodes <code>x<sub>1</sub> -> x<sub>2</sub> -> x<sub>3</sub> -> ... -> x<sub>k</sub></code> such that there is a directed edge from <code>x<sub>i</sub></code> to <code>x<sub>i+1</sub></code> for every <code>1 <= i < k</code>. The <strong>color value</strong> of the path is the number of nodes that are colored the <strong>most frequently</strong> occurring color along that path.</p><p>Return <em>the <strong>largest color value</strong> of any valid path in the given graph, or </em><code>-1</code><em> if the graph contains a cycle</em>.</p><p> </p><p><strong class=example>Example 1:</strong></p><p><img alt src=https://assets.leetcode.com/uploads/2021/04/21/leet1.png style=width:400px;height:182px></p><pre><strong>Input:</strong> colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]<strong>Output:</strong> 3<strong>Explanation:</strong> The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored <code>"a" (red in the above image)</code>.</pre><p><strong class=example>Example 2:</strong></p><p><img alt src=https://assets.leetcode.com/uploads/2021/04/21/leet2.png style=width:85px;height:85px></p><pre><strong>Input:</strong> colors = "a", edges = [[0,0]]<strong>Output:</strong> -1<strong>Explanation:</strong> There is a cycle from 0 to 0.</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>n == colors.length</code></li><li><code>m == edges.length</code></li><li><code>1 <= n <= 10<sup>5</sup></code></li><li><code>0 <= m <= 10<sup>5</sup></code></li><li><code>colors</code> consists of lowercase English letters.</li><li><code>0 <= a<sub>j</sub>, b<sub>j</sub> < n</code></li></ul><h2 id=ver1-tle-純topo>ver1 TLE: 純topo<a hidden class=anchor aria-hidden=true href=#ver1-tle-純topo>#</a></h2><p>我們很懶，所以所有dfs需要的東西都往args裡面丟。</p><p>如果是用一個大表表示有沒有被visited過需要多一個狀態是還在dfs中，但這裡是直接放到args裡面所以不用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>graph</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>visited</span><span class=p>,</span> <span class=n>colors</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>colors</span><span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>color</span><span class=p>[</span><span class=n>node</span><span class=p>]]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>visited</span> <span class=ow>or</span> <span class=bp>self</span><span class=o>.</span><span class=n>maxCnt</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>#print(f&#39;LOOP {node} {visited} {colors}&#39;)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>maxCnt</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=ow>not</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=c1>#print(f&#39;GOAL {node} {visited} {colors} {colors.most_common(1)}&#39;)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>maxCnt</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>colors</span><span class=o>.</span><span class=n>most_common</span><span class=p>(</span><span class=mi>1</span><span class=p>)[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=bp>self</span><span class=o>.</span><span class=n>maxCnt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>#print(f&#39;PATH {node} {visited} {colors}&#39;)</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>dfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>visited</span><span class=p>,</span> <span class=n>colors</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>maxCnt</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>visited</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>colors</span><span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>color</span><span class=p>[</span><span class=n>node</span><span class=p>]]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>largestPathValue</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>colors</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>edges</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>maxCnt</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>color</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>G</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>color</span> <span class=o>=</span> <span class=n>colors</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=n>G</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=k>for</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># 1. list all nodes whose in-degree is 0</span>
</span></span><span class=line><span class=cl>        <span class=n>degree0</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>colors</span><span class=p>)))</span> <span class=o>-</span> <span class=nb>set</span><span class=p>(</span><span class=n>v</span> <span class=k>for</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>#print(f&#39;GGG {degree0} {G}&#39;)</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=nb>set</span><span class=p>(),</span> <span class=n>Counter</span><span class=p>())</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=n>degree0</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>maxCnt</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>maxCnt</span> <span class=k>if</span> <span class=n>degree0</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></div><h3 id=sol>sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h3><p>真的太久沒做LC了，沒想到這是最佳化問題，所以一定是窮舉，有可能是DP或是greedy。
但那這個結構有可以優化的地方嗎? 這是path，而path一定是建構在另一個path上!! 所以可以DP</p><p>但該走的還是得走，所以還是topo sort</p><p>DP什麼? 我們需要的是某條path最多的(max)顏色數，所有有兩個參數顏色與節點，但節點是哪個節點? 是path的開始還是path的終點?</p><p>如果是我會看我想怎麼寫dp如果是top-down(可以直接用@cache)就要是path的開始，如果是bottom-up就要是path的終點。
而是要寫top-down還是bottom-up是看人，大部分兩個都會通，但根據資料的特性有得時候用另一個會有自然的好處，像是如果dp參數有長度就最好從bottom-up。
如果長度未知，像這題，就可以直接top-down，因為top-down會自動分解要處理的對象，而長度就不能這樣做。</p><p>不過這個code的效率是超差的，但我只是來復健(python都要一直反覆查api才知道怎麼用&mldr;)，所以算了，而且code很短，可以容納在白板中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nd>@cache</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dp</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>color</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=s2>&#34;inf&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>ans</span> <span class=o>=</span> <span class=mi>1</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>color</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>==</span> <span class=n>color</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>ans</span> <span class=o>+=</span> <span class=nb>max</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>dp</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>color</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>visited</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ans</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>largestPathValue</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>colors</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>edges</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>colorSet</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>colors</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>graph</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>color</span> <span class=o>=</span> <span class=n>colors</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>graph</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=k>for</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>ans</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>dp</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>c</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>colors</span><span class=p>))</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span>  <span class=bp>self</span><span class=o>.</span><span class=n>colorSet</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>#[print(f&#39;{k},{c} :: {self.dp(k,c)}&#39;) for k in range(len(colors)) for c in  self.colorSet]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span> <span class=k>if</span> <span class=n>ans</span> <span class=o>==</span> <span class=nb>float</span><span class=p>(</span><span class=s2>&#34;inf&#34;</span><span class=p>)</span> <span class=k>else</span> <span class=n>ans</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/counting/>Counting</a></li><li><a href=https://littlebees.github.io/tags/memoization/>Memoization</a></li><li><a href=https://littlebees.github.io/tags/topological-sort/>Topological Sort</a></li><li><a href=https://littlebees.github.io/tags/graph/>Graph</a></li><li><a href=https://littlebees.github.io/tags/dynamic-programming/>Dynamic Programming</a></li><li><a href=https://littlebees.github.io/tags/hash-table/>Hash Table</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2024/02/todo-list/><span class=title>« Prev</span><br><span>TODO List</span>
</a><a class=next href=https://littlebees.github.io/2024/02/move-to-hugo/><span class=title>Next »</span><br><span>Move to Hugo</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>