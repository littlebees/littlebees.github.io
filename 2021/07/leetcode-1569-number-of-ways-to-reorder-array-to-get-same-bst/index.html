<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-1569 - Number of Ways to Reorder Array to Get Same BST | 記事本</title>
<meta name=keywords content="Binary Tree,Combinatorics,Memoization,Binary Search Tree,Union Find,Tree,Dynamic Programming,Divide and Conquer,Math,Array,CTCI-COMPLETE-LIST"><meta name=description content="動機
很有趣的問題，原來python有可以直接算combination的函數&mldr;"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/07/leetcode-1569-number-of-ways-to-reorder-array-to-get-same-bst/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-1569 - Number of Ways to Reorder Array to Get Same BST"><meta property="og:description" content="動機
很有趣的問題，原來python有可以直接算combination的函數&mldr;"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/07/leetcode-1569-number-of-ways-to-reorder-array-to-get-same-bst/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-27T22:07:54+00:00"><meta property="article:modified_time" content="2021-07-27T22:07:54+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-1569 - Number of Ways to Reorder Array to Get Same BST"><meta name=twitter:description content="動機
很有趣的問題，原來python有可以直接算combination的函數&mldr;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-1569 - Number of Ways to Reorder Array to Get Same BST","item":"https://littlebees.github.io/2021/07/leetcode-1569-number-of-ways-to-reorder-array-to-get-same-bst/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-1569 - Number of Ways to Reorder Array to Get Same BST","name":"leetcode-1569 - Number of Ways to Reorder Array to Get Same BST","description":"動機 很有趣的問題，原來python有可以直接算combination的函數\u0026hellip;\n","keywords":["Binary Tree","Combinatorics","Memoization","Binary Search Tree","Union Find","Tree","Dynamic Programming","Divide and Conquer","Math","Array","CTCI-COMPLETE-LIST"],"articleBody":"動機 很有趣的問題，原來python有可以直接算combination的函數…\nProblem Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.\nFor example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.\nReturn the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.\nSince the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: nums = [2,1,3]Output: 1Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.Example 2:\nInput: nums = [3,4,5,1,2]Output: 5Explanation: The following 5 arrays will yield the same BST: [3,1,2,4,5][3,1,4,2,5][3,1,4,5,2][3,4,1,2,5][3,4,1,5,2]Example 3:\nInput: nums = [1,2,3]Output: 0Explanation: There are no other orderings of nums that will yield the same BST.Example 4:\nInput: nums = [3,1,2,5,4,6]Output: 19Example 5:\nInput: nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18]Output: 216212978Explanation: The number of ways to reorder nums to get the same BST is 3216212999. Taking this number modulo 10^9 + 7 gives 216212978. Constraints:\n1 \u003c= nums.length \u003c= 10001 \u003c= nums[i] \u003c= nums.lengthAll integers in nums are distinct. Sol 這是BST，所以第一個是root，而比root小的就是在左，其他在右\n所以第一個位置不能動，其他的只要個子樹的相對位置不變就好，所以就是在去掉root的剩下格子中，有多少種安排左(右)子樹的方式再乘上左右子樹的組合數\nclass Solution: def numOfWays(self, nums: List[int]) -\u003e int: def f(nums): if len(nums) \u003c= 1: return 1 else: r = [n for n in nums[1:] if n \u003e nums[0]] l = [n for n in nums[1:] if n \u003c nums[0]] return comb(len(r)+len(l), len(r))*f(l)*f(r) return (f(nums)-1) % (10**9 + 7) ","wordCount":"307","inLanguage":"en","datePublished":"2021-07-27T22:07:54Z","dateModified":"2021-07-27T22:07:54Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/07/leetcode-1569-number-of-ways-to-reorder-array-to-get-same-bst/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-1569 - Number of Ways to Reorder Array to Get Same BST</h1><div class=post-meta><span title='2021-07-27 22:07:54 +0000 UTC'>July 27, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>很有趣的問題，原來python有可以直接算combination的函數&mldr;</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>Given an array <code>nums</code> that represents a permutation of integers from <code>1</code> to <code>n</code>. We are going to construct a binary search tree (BST) by inserting the elements of <code>nums</code> in order into an initially empty BST. Find the number of different ways to reorder <code>nums</code> so that the constructed BST is identical to that formed from the original array <code>nums</code>.</p><p>For example, given <code>nums = [2,1,3]</code>, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array <code>[2,3,1]</code> also yields the same BST but <code>[3,2,1]</code> yields a different BST.</p><p>Return <em>the number of ways to reorder</em> <code>nums</code> <em>such that the BST formed is identical to the original BST formed from</em> <code>nums</code>.</p><p>Since the answer may be very large, <strong>return it modulo </strong><code>10^9 + 7</code>.</p><p> </p><p><strong>Example 1:</strong></p><p><img alt src=https://assets.leetcode.com/uploads/2020/08/12/bb.png style=width:121px;height:101px></p><pre><strong>Input:</strong> nums = [2,1,3]<strong>Output:</strong> 1<strong>Explanation: </strong>We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.</pre><p><strong>Example 2:</strong></p><p><strong><img alt src=https://assets.leetcode.com/uploads/2020/08/12/ex1.png style=width:241px;height:161px></strong></p><pre><strong>Input:</strong> nums = [3,4,5,1,2]<strong>Output:</strong> 5<b>Explanation: </b>The following 5 arrays will yield the same BST: [3,1,2,4,5][3,1,4,2,5][3,1,4,5,2][3,4,1,2,5][3,4,1,5,2]</pre><p><strong>Example 3:</strong></p><p><strong><img alt src=https://assets.leetcode.com/uploads/2020/08/12/ex4.png style=width:121px;height:161px></strong></p><pre><strong>Input:</strong> nums = [1,2,3]<strong>Output:</strong> 0<strong>Explanation: </strong>There are no other orderings of nums that will yield the same BST.</pre><p><strong>Example 4:</strong></p><p><strong><img alt src=https://assets.leetcode.com/uploads/2020/08/12/abc.png style=width:241px;height:161px></strong></p><pre><strong>Input:</strong> nums = [3,1,2,5,4,6]<strong>Output:</strong> 19</pre><p><strong>Example 5:</strong></p><pre><strong>Input:</strong> nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18]<strong>Output:</strong> 216212978<strong>Explanation: </strong>The number of ways to reorder nums to get the same BST is 3216212999. Taking this number modulo 10^9 + 7 gives 216212978.</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= nums.length <= 1000</code></li><li><code>1 <= nums[i] <= nums.length</code></li><li>All integers in <code>nums</code> are <strong>distinct</strong>.</li></ul><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><p>這是BST，所以第一個是root，而比root小的就是在左，其他在右</p><p>所以第一個位置不能動，其他的只要個子樹的相對位置不變就好，所以就是在去掉root的剩下格子中，有多少種安排左(右)子樹的方式再乘上左右子樹的組合數</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>numOfWays</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>r</span> <span class=o>=</span> <span class=p>[</span><span class=n>n</span> <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span> <span class=k>if</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span> <span class=o>=</span> <span class=p>[</span><span class=n>n</span> <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span> <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>comb</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>r</span><span class=p>)</span><span class=o>+</span><span class=nb>len</span><span class=p>(</span><span class=n>l</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>r</span><span class=p>))</span><span class=o>*</span><span class=n>f</span><span class=p>(</span><span class=n>l</span><span class=p>)</span><span class=o>*</span><span class=n>f</span><span class=p>(</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=mi>10</span><span class=o>**</span><span class=mi>9</span> <span class=o>+</span> <span class=mi>7</span><span class=p>)</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/binary-tree/>Binary Tree</a></li><li><a href=https://littlebees.github.io/tags/combinatorics/>Combinatorics</a></li><li><a href=https://littlebees.github.io/tags/memoization/>Memoization</a></li><li><a href=https://littlebees.github.io/tags/binary-search-tree/>Binary Search Tree</a></li><li><a href=https://littlebees.github.io/tags/union-find/>Union Find</a></li><li><a href=https://littlebees.github.io/tags/tree/>Tree</a></li><li><a href=https://littlebees.github.io/tags/dynamic-programming/>Dynamic Programming</a></li><li><a href=https://littlebees.github.io/tags/divide-and-conquer/>Divide and Conquer</a></li><li><a href=https://littlebees.github.io/tags/math/>Math</a></li><li><a href=https://littlebees.github.io/tags/array/>Array</a></li><li><a href=https://littlebees.github.io/tags/ctci-complete-list/>CTCI-COMPLETE-LIST</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/07/leetcode-1679-max-number-of-k-sum-pairs/><span class=title>« Prev</span><br><span>leetcode-1679 - Max Number of K-Sum Pairs</span>
</a><a class=next href=https://littlebees.github.io/2021/07/leetcode-278-first-bad-version/><span class=title>Next »</span><br><span>leetcode-278 - First Bad Version</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>