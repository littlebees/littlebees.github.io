<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-310 - Minimum Height Trees | 記事本</title>
<meta name=keywords content="Topological Sort,Graph,Breadth-First Search,Depth-First Search,seanprashad"><meta name=description content="動機

第一次看到bfs這麼用
這樣叫topo sort嗎?
很漂亮的算法，真的很漂亮
"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/08/leetcode-310-minimum-height-trees/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-310 - Minimum Height Trees"><meta property="og:description" content="動機

第一次看到bfs這麼用
這樣叫topo sort嗎?
很漂亮的算法，真的很漂亮
"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/08/leetcode-310-minimum-height-trees/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-02T01:23:13+00:00"><meta property="article:modified_time" content="2021-08-02T01:23:13+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-310 - Minimum Height Trees"><meta name=twitter:description content="動機

第一次看到bfs這麼用
這樣叫topo sort嗎?
很漂亮的算法，真的很漂亮
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-310 - Minimum Height Trees","item":"https://littlebees.github.io/2021/08/leetcode-310-minimum-height-trees/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-310 - Minimum Height Trees","name":"leetcode-310 - Minimum Height Trees","description":"動機 第一次看到bfs這麼用 這樣叫topo sort嗎? 很漂亮的算法，真的很漂亮 ","keywords":["Topological Sort","Graph","Breadth-First Search","Depth-First Search","seanprashad"],"articleBody":"動機 第一次看到bfs這麼用 這樣叫topo sort嗎? 很漂亮的算法，真的很漂亮 Problem A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\nGiven a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h)) are called minimum height trees (MHTs).\nReturn a list of all MHTs' root labels. You can return the answer in any order.\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\nExample 1:\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]Output: [1]Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.Example 2:\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]Output: [3,4]Example 3:\nInput: n = 1, edges = []Output: [0]Example 4:\nInput: n = 2, edges = [[0,1]]Output: [0,1] Constraints:\n1 \u003c= n \u003c= 2 * 104edges.length == n - 10 \u003c= ai, bi \u003c nai != biAll the pairs (ai, bi) are distinct.The given input is guaranteed to be a tree and there will be no repeated edges. Sol 觀察會發現，其實我們要找的點都在中點上!!\n所以問題就是怎麼找中點\n不像linked list有起點終點，但我們有leaf\n這有點像two pointer，從兩邊去逼近，一直把leaf拿掉，直到剩下兩個以下的node\n要注意的是要用圈為單位，不能用node為單位，不然就會在還有leaf的狀態，因為兩個以下的node而退除loop\nclass Solution: def findMinHeightTrees(self, n: int, edges: List[List[int]]) -\u003e List[int]: if n \u003c= 2: return list(range(n)) else: gh = defaultdict(set) for (a,b) in edges: gh[a].add(b) gh[b].add(a) q = deque([[k for (k,v) in gh.items() if len(v) == 1]]) while len(gh) \u003e 2: rs = q.popleft() leafs = [] for r in rs: for x in gh[r]: # should be only one, but we cant use index on set gh[x].remove(r) if len(gh[x]) == 1: leafs.append(x) del gh[r] q.append(leafs) return list(gh.keys()) ","wordCount":"345","inLanguage":"en","datePublished":"2021-08-02T01:23:13Z","dateModified":"2021-08-02T01:23:13Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/08/leetcode-310-minimum-height-trees/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-310 - Minimum Height Trees</h1><div class=post-meta><span title='2021-08-02 01:23:13 +0000 UTC'>August 2, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><ol><li>第一次看到bfs這麼用</li><li>這樣叫topo sort嗎?</li><li>很漂亮的算法，真的很漂亮</li></ol><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>A tree is an undirected graph in which any two vertices are connected by <i>exactly</i> one path. In other words, any connected graph without simple cycles is a tree.</p><p>Given a tree of <code>n</code> nodes labelled from <code>0</code> to <code>n - 1</code>, and an array of <code>n - 1</code> <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an undirected edge between the two nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree, you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>)  are called <strong>minimum height trees</strong> (MHTs).</p><p>Return <em>a list of all <strong>MHTs'</strong> root labels</em>. You can return the answer in <strong>any order</strong>.</p><p>The <strong>height</strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p><p> </p><p><strong>Example 1:</strong></p><img alt src=https://assets.leetcode.com/uploads/2020/09/01/e1.jpg style=width:800px;height:213px><pre><strong>Input:</strong> n = 4, edges = [[1,0],[1,2],[1,3]]<strong>Output:</strong> [1]<strong>Explanation:</strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.</pre><p><strong>Example 2:</strong></p><img alt src=https://assets.leetcode.com/uploads/2020/09/01/e2.jpg style=width:800px;height:321px><pre><strong>Input:</strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]<strong>Output:</strong> [3,4]</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> n = 1, edges = []<strong>Output:</strong> [0]</pre><p><strong>Example 4:</strong></p><pre><strong>Input:</strong> n = 2, edges = [[0,1]]<strong>Output:</strong> [0,1]</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= n <= 2 * 10<sup>4</sup></code></li><li><code>edges.length == n - 1</code></li><li><code>0 <= a<sub>i</sub>, b<sub>i</sub> < n</code></li><li><code>a<sub>i</sub> != b<sub>i</sub></code></li><li>All the pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are distinct.</li><li>The given input is <strong>guaranteed</strong> to be a tree and there will be <strong>no repeated</strong> edges.</li></ul><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><p>觀察會發現，其實我們要找的點都在中點上!!</p><p>所以問題就是怎麼找中點</p><p>不像linked list有起點終點，但我們有leaf</p><p>這有點像two pointer，從兩邊去逼近，一直把leaf拿掉，直到剩下兩個以下的node</p><p>要注意的是要用圈為單位，不能用node為單位，不然就會在還有leaf的狀態，因為兩個以下的node而退除loop</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>findMinHeightTrees</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>edges</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]])</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>gh</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>set</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>gh</span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>gh</span><span class=p>[</span><span class=n>b</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>q</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([[</span><span class=n>k</span> <span class=k>for</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=n>gh</span><span class=o>.</span><span class=n>items</span><span class=p>()</span> <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>gh</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>rs</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=n>leafs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=n>rs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>gh</span><span class=p>[</span><span class=n>r</span><span class=p>]:</span> <span class=c1># should be only one, but we cant use index on set</span>
</span></span><span class=line><span class=cl>                        <span class=n>gh</span><span class=p>[</span><span class=n>x</span><span class=p>]</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>gh</span><span class=p>[</span><span class=n>x</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                            <span class=n>leafs</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>del</span> <span class=n>gh</span><span class=p>[</span><span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>leafs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>list</span><span class=p>(</span><span class=n>gh</span><span class=o>.</span><span class=n>keys</span><span class=p>())</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/topological-sort/>Topological Sort</a></li><li><a href=https://littlebees.github.io/tags/graph/>Graph</a></li><li><a href=https://littlebees.github.io/tags/breadth-first-search/>Breadth-First Search</a></li><li><a href=https://littlebees.github.io/tags/depth-first-search/>Depth-First Search</a></li><li><a href=https://littlebees.github.io/tags/seanprashad/>seanprashad</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/08/leetcode-665-non-decreasing-array/><span class=title>« Prev</span><br><span>leetcode-665 - Non-decreasing Array</span>
</a><a class=next href=https://littlebees.github.io/2021/08/leetcode-705-design-hashset/><span class=title>Next »</span><br><span>leetcode-705 - Design HashSet</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>