<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-208 - Implement Trie (Prefix Tree) | 記事本</title>
<meta name=keywords content="Trie,Design,String,Hash Table,Blind Curated 75,Top 100 Liked Questions,Top Interview Questions,seanprashad"><meta name=description content="動機
就是trie"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/01/leetcode-208-implement-trie-prefix-tree/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/01/leetcode-208-implement-trie-prefix-tree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-208 - Implement Trie (Prefix Tree)"><meta property="og:description" content="動機
就是trie"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/01/leetcode-208-implement-trie-prefix-tree/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-17T23:39:15+00:00"><meta property="article:modified_time" content="2021-01-17T23:39:15+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-208 - Implement Trie (Prefix Tree)"><meta name=twitter:description content="動機
就是trie"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-208 - Implement Trie (Prefix Tree)","item":"https://littlebees.github.io/2021/01/leetcode-208-implement-trie-prefix-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-208 - Implement Trie (Prefix Tree)","name":"leetcode-208 - Implement Trie (Prefix Tree)","description":"動機 就是trie\n","keywords":["Trie","Design","String","Hash Table","Blind Curated 75","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"articleBody":"動機 就是trie\nProblem A trie (pronounced as try) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\nTrie() Initializes the trie object.void insert(String word) Inserts the string word into the trie.boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. Example 1:\nInput[Trie, insert, search, search, startsWith, insert, search][[], [apple], [apple], [app], [app], [app], [app]]Output[null, null, true, false, true, null, true]ExplanationTrie trie = new Trie();trie.insert(apple);trie.search(apple); // return Truetrie.search(app); // return Falsetrie.startsWith(app); // return Truetrie.insert(app);trie.search(app); // return True Constraints:\n1 \u003c= word.length, prefix.length \u003c= 2000word and prefix consist only of lowercase English letters.At most 3 * 104 calls in total will be made to insert, search, and startsWith. Sol 每一個node有[flag :: bool, hash{char -\u003e Node}]\nflag是指到此是不是某個單字的終點\nclass Trie: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.t = [False, {}] def insert(self, w: str) -\u003e None: \"\"\" Inserts a word into the trie. \"\"\" tmp = self.t for c in w: if c not in tmp[1]: tmp[1][c] = [False, {}] tmp = tmp[1][c] tmp[0] = True def search(self, w: str) -\u003e bool: \"\"\" Returns if the word is in the trie. \"\"\" tmp = self.t for c in w: if c not in tmp[1]: return False tmp = tmp[1][c] return tmp[0] def startsWith(self, p: str) -\u003e bool: \"\"\" Returns if there is any word in the trie that starts with the given prefix. \"\"\" tmp = self.t for c in p: if c not in tmp[1]: return False tmp = tmp[1][c] return True 另外有C++版\nstruct Trie { unordered_map\u003cchar, struct Trie*\u003e nextLevel; bool end; ~Trie() { for (auto\u0026 kv : nextLevel) { delete kv.second; } } void insert(string s) { Trie* trie = this; for (auto\u0026 c : s) { if (trie-\u003enextLevel.find(c) == trie-\u003enextLevel.end()) { trie-\u003enextLevel[c] = new Trie(); } trie = trie-\u003enextLevel[c]; } trie-\u003eend = 1; } bool search(string s) { Trie* trie = this; for (auto\u0026 c : s) { if (trie-\u003enextLevel.find(c) != trie-\u003enextLevel.end()) { trie = trie-\u003enextLevel[c]; } else { return 0; } } return trie-\u003eend; } bool startsWith(string s) { Trie* trie = this; for (auto\u0026 c : s) { if (trie-\u003enextLevel.find(c) != trie-\u003enextLevel.end()) { trie = trie-\u003enextLevel[c]; } else { return 0; } } return 1; } }; ","wordCount":"420","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-01-17T23:39:15Z","dateModified":"2021-01-17T23:39:15Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/01/leetcode-208-implement-trie-prefix-tree/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-208 - Implement Trie (Prefix Tree)</h1><div class=post-meta><span title='2021-01-17 23:39:15 +0000 UTC'>January 17, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>就是trie</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>A <a href=https://en.wikipedia.org/wiki/Trie target=_blank><strong>trie</strong></a> (pronounced as try) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p><p>Implement the Trie class:</p><ul><li><code>Trie()</code> Initializes the trie object.</li><li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li><li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li><li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li></ul><p> </p><p><strong>Example 1:</strong></p><pre><strong>Input</strong>[Trie, insert, search, search, startsWith, insert, search][[], [apple], [apple], [app], [app], [app], [app]]<strong>Output</strong>[null, null, true, false, true, null, true]<strong>Explanation</strong>Trie trie = new Trie();trie.insert(apple);trie.search(apple);   // return Truetrie.search(app);     // return Falsetrie.startsWith(app); // return Truetrie.insert(app);trie.search(app);     // return True</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= word.length, prefix.length <= 2000</code></li><li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li><li>At most <code>3 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li></ul><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><p>每一個node有<code>[flag :: bool, hash{char -> Node}]</code></p><p>flag是指到此是不是某個單字的終點</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Trie</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Initialize your data structure here.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>,</span> <span class=p>{}]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>w</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Inserts a word into the trie.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>c</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>,</span> <span class=p>{}]</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>w</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Returns if the word is in the trie.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>c</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>startsWith</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>p</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Returns if there is any word in the trie that starts with the given prefix.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>p</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>c</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span></code></pre></div><p>另外有C++版</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Trie</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>Trie</span><span class=o>*&gt;</span> <span class=n>nextLevel</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>bool</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Trie</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>kv</span> <span class=p>:</span> <span class=n>nextLevel</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=n>kv</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span><span class=o>*</span> <span class=n>trie</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>c</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>==</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>[</span><span class=n>c</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Trie</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>trie</span> <span class=o>=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>[</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>trie</span><span class=o>-&gt;</span><span class=n>end</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span><span class=o>*</span> <span class=n>trie</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>c</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>!=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>trie</span> <span class=o>=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>[</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>startsWith</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span><span class=o>*</span> <span class=n>trie</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>c</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>!=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>trie</span> <span class=o>=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>[</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/trie/>Trie</a></li><li><a href=https://littlebees.github.io/tags/design/>Design</a></li><li><a href=https://littlebees.github.io/tags/string/>String</a></li><li><a href=https://littlebees.github.io/tags/hash-table/>Hash Table</a></li><li><a href=https://littlebees.github.io/tags/blind-curated-75/>Blind Curated 75</a></li><li><a href=https://littlebees.github.io/tags/top-100-liked-questions/>Top 100 Liked Questions</a></li><li><a href=https://littlebees.github.io/tags/top-interview-questions/>Top Interview Questions</a></li><li><a href=https://littlebees.github.io/tags/seanprashad/>Seanprashad</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/01/leetcode-179-largest-number/><span class=title>« Prev</span><br><span>leetcode-179 - Largest Number</span>
</a><a class=next href=https://littlebees.github.io/2021/01/leetcode-55-jump-game/><span class=title>Next »</span><br><span>leetcode-55 - Jump Game</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>