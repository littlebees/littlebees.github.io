<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-117 - Populating Next Right Pointers in Each Node II | 記事本</title>
<meta name=keywords content="Binary Tree,Breadth-First Search,Depth-First Search,Tree,seanprashad"><meta name=description content="動機
用已經建成的next去連，所以遞迴方式變得很有趣"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/08/leetcode-117-populating-next-right-pointers-in-each-node-ii/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/08/leetcode-117-populating-next-right-pointers-in-each-node-ii/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-117 - Populating Next Right Pointers in Each Node II"><meta property="og:description" content="動機
用已經建成的next去連，所以遞迴方式變得很有趣"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/08/leetcode-117-populating-next-right-pointers-in-each-node-ii/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-01T23:11:54+00:00"><meta property="article:modified_time" content="2021-08-01T23:11:54+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-117 - Populating Next Right Pointers in Each Node II"><meta name=twitter:description content="動機
用已經建成的next去連，所以遞迴方式變得很有趣"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-117 - Populating Next Right Pointers in Each Node II","item":"https://littlebees.github.io/2021/08/leetcode-117-populating-next-right-pointers-in-each-node-ii/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-117 - Populating Next Right Pointers in Each Node II","name":"leetcode-117 - Populating Next Right Pointers in Each Node II","description":"動機 用已經建成的next去連，所以遞迴方式變得很有趣\n","keywords":["Binary Tree","Breadth-First Search","Depth-First Search","Tree","seanprashad"],"articleBody":"動機 用已經建成的next去連，所以遞迴方式變得很有趣\nProblem Given a binary tree\nstruct Node { int val; Node *left; Node *right; Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nFollow up:\nYou may only use constant extra space.Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1:\nInput: root = [1,2,3,4,5,null,7]Output: [1,#,2,3,#,4,5,7,#]Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints:\nThe number of nodes in the given tree is less than 6000.-100 \u003c= node.val \u003c= 100 Sol 剛到這個root就先看左右node能不能連，之後要先遞迴右邊，因為終點在右邊，所以右邊的next要先建好\n之後就是看現在的next能不能建，如果需要另一邊的node就透過next去找\ndef getrightNext(r): if r: if r.left: #print(\"left\", r.left.val) return r.left elif r.right: #print(\"right\", r.right.val) return r.right else: #print(\"next\", r.next.val if r.next else None) return getrightNext(r.next) else: return None class Solution: def connect(self, r: 'Node',p=None) -\u003e 'Node': if r: if r.left and r.right: r.left.next = r.right if not r.next and p: #print(\"at\", r.val, p.val) r.next = getrightNext(p.next) self.connect(r.right,r) self.connect(r.left,r) return r ","wordCount":"212","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-08-01T23:11:54Z","dateModified":"2021-08-01T23:11:54Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/08/leetcode-117-populating-next-right-pointers-in-each-node-ii/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-117 - Populating Next Right Pointers in Each Node II</h1><div class=post-meta><span title='2021-08-01 23:11:54 +0000 UTC'>August 1, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>用已經建成的next去連，所以遞迴方式變得很有趣</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>Given a binary tree</p><pre>struct Node {  int val;  Node *left;  Node *right;  Node *next;}</pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p> </p><p><strong>Follow up:</strong></p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li></ul><p> </p><p><strong>Example 1:</strong></p><p><img alt src=https://assets.leetcode.com/uploads/2019/02/15/117_sample.png style=width:640px;height:218px></p><pre><strong>Input:</strong> root = [1,2,3,4,5,null,7]<strong>Output:</strong> [1,#,2,3,#,4,5,7,#]<strong>Explanation: </strong>Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.</pre><p> </p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the given tree is less than <code>6000</code>.</li><li><code>-100 <= node.val <= 100</code></li></ul><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><p>剛到這個root就先看左右node能不能連，之後要先遞迴<em>右邊</em>，因為終點在右邊，所以右邊的next要先建好</p><p>之後就是看現在的next能不能建，如果需要另一邊的node就透過next去找</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>getrightNext</span><span class=p>(</span><span class=n>r</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>r</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>r</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>#print(&#34;left&#34;, r.left.val)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>r</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>r</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>#print(&#34;right&#34;, r.right.val)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>r</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>#print(&#34;next&#34;, r.next.val if r.next else None)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>getrightNext</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>connect</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>r</span><span class=p>:</span> <span class=s1>&#39;Node&#39;</span><span class=p>,</span><span class=n>p</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=s1>&#39;Node&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>r</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>r</span><span class=o>.</span><span class=n>left</span> <span class=ow>and</span> <span class=n>r</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>r</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>r</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>r</span><span class=o>.</span><span class=n>next</span> <span class=ow>and</span> <span class=n>p</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1>#print(&#34;at&#34;, r.val, p.val)</span>
</span></span><span class=line><span class=cl>                <span class=n>r</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>getrightNext</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>right</span><span class=p>,</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>left</span><span class=p>,</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>r</span> 
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/binary-tree/>Binary Tree</a></li><li><a href=https://littlebees.github.io/tags/breadth-first-search/>Breadth-First Search</a></li><li><a href=https://littlebees.github.io/tags/depth-first-search/>Depth-First Search</a></li><li><a href=https://littlebees.github.io/tags/tree/>Tree</a></li><li><a href=https://littlebees.github.io/tags/seanprashad/>Seanprashad</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/08/leetcode-720-longest-word-in-dictionary/><span class=title>« Prev</span><br><span>leetcode-720 - Longest Word in Dictionary</span>
</a><a class=next href=https://littlebees.github.io/2021/08/leetcode-767-reorganize-string/><span class=title>Next »</span><br><span>leetcode-767 - Reorganize String</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>