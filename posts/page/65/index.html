<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 記事本</title>
<meta name=keywords content><meta name=description content="Posts - 記事本"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://littlebees.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://littlebees.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="寫下不然會忘記"><meta property="og:type" content="website"><meta property="og:url" content="https://littlebees.github.io/posts/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="寫下不然會忘記"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>leetcode的bash題目們</h2></header><div class=entry-content><p>動機 onlinejudge居然有bash的題目!! 這麼有趣的東西當然是解爆阿!!
抱怨 有的時候會出現
rbash: ./prog.sh: Permission denied 這個時候就是只能調整輸入像用pipe等等
題目 目前只有4題
192 193 194 195 192 cat words.txt | tr ' ' '\n' | sed '/^[[:space:]]*$/d' | sort | uniq -c | nawk '{print $1" "$2}' | sort -r -n -k 1 | nawk '{print $2" "$1}' bash做為一個奇怪的PL bash可以想成只有string的PL
那要怎麼表現array? 用delimiter區分，常見的是
space newline comma etc… 第一步: 多個array合成一條array 先把空白換成斷行 把多的斷行吃掉 故最後會變成 1 2 3 => 1 2 3 cat words.txt | tr ' ' '\n' | sed '/^[[:space:]]*$/d' 第二步: 計數 先排好，再計算重複的單字...</p></div><footer class=entry-footer><span title='2020-07-11 01:20:47 +0000 UTC'>July 11, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to leetcode的bash題目們" href=https://littlebees.github.io/2020/07/leetcode%E7%9A%84bash%E9%A1%8C%E7%9B%AE%E5%80%91/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>git筆記</h2></header><div class=entry-content><p>動機 git的指令很多，希望能用一種統一的觀點來看
commit as Node (folder) -> (stage :: node) -> (repo :: linked list) | \ / (stash :: pool of nodes) Linked List new node & use existing node git add 把folder中的file，加到node中 git stash 把還沒加到repo(linked list)的node放到node的暫存區 edit the last node git amend 修改最後一個node(HEAD) iterate nodes git filter-branch list.map ... git rebase newlist = list.each ...; list.append(newlist) 可以edit, squash(融合), drop, pick(保留) ptr to node git tag 單純的ptr git branch 替node加上新的ptr，只是這個ptr會在他被append一個新node時，把該ptr往後移動 所以可以把這個ptr當成"最新"或是"現在" append node(s) git commit 把目前的node加到目前HEAD的後面 就是list....</p></div><footer class=entry-footer><span title='2020-06-15 20:56:10 +0000 UTC'>June 15, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to git筆記" href=https://littlebees.github.io/2020/06/git%E7%AD%86%E8%A8%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>設定vscode的c++ format</h2></header><div class=entry-content><p>動機 工作的code的風格與自己平常打的code的風格差很多!! 如果有可以自動調的會很方便。
同時vscode的c/c++外掛，有ctags與cscope的功能，不用另外裝， 所以變成研究如何在vscode上自動調整format
作法 vscode自動調整format 把 setting 中的
Editor: Format On Paste Editor: Format On Save Editor: Format On Type 勾起來
如果覺得不好找，可以在setting上方的搜尋欄打上 format 去找
tab與空白混用 把 Editor: Detect Indentation 與 Editor: Insert Spaces 關掉 設定 clang-format-fallback 設定clang-format-fallback 把
{ BasedOnStyle: WebKit, IndentWidth: 4, TabWidth: 8, ColumnLimit: 80, AlignAfterOpenBracket: Align, AlignConsecutiveMacros: true, AlignTrailingComments: true, UseTab: ForContinuationAndIndentation, BraceWrapping: { AfterFunction: false }, SpaceBeforeParens: ControlStatements } 貼到C_Cpp: Clang_format_fallback Style去，用成一行
一些詭異的地方 TabSize & TabWidth 顯示tab時會依照TabSize的大小，所以如果要顯示得不會刺痛眼睛 要去改Editor:TabSize成8...</p></div><footer class=entry-footer><span title='2020-06-13 00:46:50 +0000 UTC'>June 13, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to 設定vscode的c++ format" href=https://littlebees.github.io/2020/06/%E8%A8%AD%E5%AE%9Avscode%E7%9A%84c-format/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>The Little MLer 筆記</h2></header><div class=entry-content><p>ch0: 執行環境 想用wsl來跑sml的話，poly/ml是不錯的選項
ch1: 定義type datatype num = ZERO | ONE_MORE of num datatype ‘a Slist = NIL of ‘a | SCONS of ‘a Slist ch2: 寫function datatype Abc = A | B of Abc | C of Abc fun only_B(A) = true | only_B(B(x)) = only_B(x) | only_B(C(x)) = false (only_B : Abc -> bool) datatype ‘a Xyz = X of ‘a | Y of ‘a Xyz | Z of ‘a Xyz fun is_xy(X(x)) = true | is_xy(Y(x)) = is_xy(x) | is_xy(Z(x)) = false (is_xy : ‘a Xyz -> bool) ch3: 在list上遞迴 fun rem_B(A) = A | rem_B(B(x)) = rem_B(x) | rem_B(C(x)) = C(rem_B(x)) fun C_in_fron_of_B(A) = A | C_in_fron_of_B(B(x)) = C(B(C_in_fron_of_B(x))) | C_in_fron_of_B(C(x)) = C(C_in_fron_of_B(x)) fun subst_B_C(x) = rem_B(C_in_fron_of_B(x)) (* OR *) fun subst_B_C(A) = A | subst_B_C(B(x)) = C(subst_B_C(x)) | subst_B_C(C(x)) = C(subst_B_C(x)) (* 都是走訪同一list故可以用同一種走訪，把兩個式子結合起來(map fusion) *) ch4: tuple & 多參數function (A,X,A) :: (Abc * Xyz * Abc) datatype Abc = A | B | C fun add_a(A) = (A,A) | add_a(B) = (B,A) | add_a = (C,A) (add_a : Abc -> (Abc * Abc)) 可以利用type variable來打少一點字...</p></div><footer class=entry-footer><span title='2020-05-24 23:07:10 +0000 UTC'>May 24, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to The Little MLer 筆記" href=https://littlebees.github.io/2020/05/the-little-mler-%E7%AD%86%E8%A8%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>little typer 後篇(8~16) 整理與筆記</h2></header><div class=entry-content><p>來證明啦
ch8 & ch9 & ch10 & ch11 現在說用type證明，但實際上怎麼做?
在claim寫下想證的東西，在define證出來
incr & + (claim incr (-> Nat Nat)) (define incr (λ (n) (iter-Nat n 1 (+ 1)))) (claim + (-> Nat Nat Nat)) (define + (λ (a b) (iter-Nat a b (λ (ret) (add1 ret))))) +1=add1 證對於任何整數，add1等於+1
(claim +1=add1 (Pi ((n Nat)) (= Nat (+ 1 n) (add1 n)))) 所以我們需要一個value的type是(= Nat (+ 1 n) (add1 n))) 先把1帶入+中，會發現根本就是(add1 n)
也就是兩邊都一樣，same!!
(define +1=add1 (λ (n) (same (+ 1 n)))) incr=add1 同樣的來試試incr=add1...</p></div><footer class=entry-footer><span title='2020-05-16 17:34:32 +0000 UTC'>May 16, 2020</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to little typer 後篇(8~16) 整理與筆記" href=https://littlebees.github.io/2020/05/little-typer-%E5%BE%8C%E7%AF%878~16-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>little typer 前篇(1~7) 整理與筆記</h2></header><div class=entry-content><p>介紹Pie怎麼用
ch1 & ch2 & ch3 所有東西都是expression 有人斷言expression有某種屬性或與其他expression有共通的特質是judgment Sentences get their meaning from those who understand them. The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them. 描述某一群expression的expression是Type 當type constructor在頂部就是type (Pair Nat Nat) constructor在頂部就是Value constructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體) eliminator會分解value取出構成value的資訊 當某一expression無法再被改寫時叫normal form 改寫expression叫evaluation expression因為有變數而無法繼續改寫叫neutral 只要長的一樣就是same (不是等於，之後會用same去證等於) total function對任何一個值都能產生對應的值 沒有遞迴 因為每個expression都一定要收斂 所以有其他東西來做類似的效果 evaluation & value 在dependent type中，evaluation得到的是expression 在一般PL(像lisp)中，evaluation得到的是value 在一般PL中，expression與value是不同類別的東西
ch4 & ch5 claim & define 在pie中要產生一個變數要先claim再define...</p></div><footer class=entry-footer><span title='2020-05-16 17:34:21 +0000 UTC'>May 16, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to little typer 前篇(1~7) 整理與筆記" href=https://littlebees.github.io/2020/05/little-typer-%E5%89%8D%E7%AF%871~7-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在不同context下的sync與async(與block&amp;non-block比較)</h2></header><div class=entry-content><p>caller: block & nonblock caller會等 => block caller不等 => nonblock (所以要自己時不是去確認好了沒，或是，callee通知)
return val: (general’s) sync & async 調用後會拿到 sync: 我們想要的資料 async: 類似raincheck的東西，也許馬上，也許要一段時間後，才會拿到我們想要的資料
要不要自己把copy到userspace的io做完: (NP’s) sync & async 前面4種都是最後要自己call system call拉資料，所以是sync，最後user與kernel的任務會同時完成
async io是user連什麼時候完成都不知道，等到kernel把資料copy好就會call callback
AJAX var httpRequest = httpRequest = new XMLHttpRequest(); httpRequest.onreadystatechange = function() { // 等狀態變成請求完成狀態 if (httpRequest.readyState === 4 && httpRequest.status == 200) { httpRequest.responseText } alert(`ERROR - server status code: ${httpRequest.status} xdr status: ${httpRequest.readyState}`); }; httpRequest.open('GET', '/api/get_something'); httpRequest....</p></div><footer class=entry-footer><span title='2020-05-04 23:58:14 +0000 UTC'>May 4, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to 在不同context下的sync與async(與block&amp;non-block比較)" href=https://littlebees.github.io/2020/05/%E5%9C%A8%E4%B8%8D%E5%90%8Ccontext%E4%B8%8B%E7%9A%84sync%E8%88%87async%E8%88%87blocknon-block%E6%AF%94%E8%BC%83/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>有趣與有用的es6特性</h2></header><div class=entry-content><p>下面是個人比較喜歡的es6的新特性
終於來了!! Template Literals `Fifteen is ${a + b} and not ${2 * a + b}.` Arrow Functions function Person() { this.age = 0; // var self = this; // 定義該 Arrow Functions 時的環境，是在 Person 物件中 setInterval(() => { // 所以 this 會正確指向 Person 物件 this.age++; //self.age++ }, 1000); } var p = new Person(); class syntax sugar class Animal { constructor(name) { this.name = name; } speak() { console.log(this.name + ' makes a noise....</p></div><footer class=entry-footer><span title='2020-05-04 23:54:10 +0000 UTC'>May 4, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to 有趣與有用的es6特性" href=https://littlebees.github.io/2020/05/%E6%9C%89%E8%B6%A3%E8%88%87%E6%9C%89%E7%94%A8%E7%9A%84es6%E7%89%B9%E6%80%A7/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>monad推導，主要是cont monad</h2></header><div class=entry-content><p>把參數藏起來 把acc藏起來看看
(define (sum l acc) (if (null? l) acc (sum (cdr l) (+ acc (car l))))) delay 要藏的變數 (define (sum1 l) (lambda (acc) (if (null? l) acc ((sum2 (cdr l)) (+ (car l) acc))))) 把lambda推到if的兩項 (define (sum2 l) (if (null? l) (lambda (acc) acc) (lambda (acc) ((sum2 (cdr l)) (+ (car l) acc))))) 抽出遞迴的part (define (sum3 l) (if (null? l) (lambda (acc) acc) (let ((m (sum3 (cdr l)))) (lambda (acc) (m (+ (car l) acc)))))) 把運算抽出來，並把delay的變數塞回去 (define (sum4....</p></div><footer class=entry-footer><span title='2020-05-04 23:53:58 +0000 UTC'>May 4, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to monad推導，主要是cont monad" href=https://littlebees.github.io/2020/05/monad%E6%8E%A8%E5%B0%8E%E4%B8%BB%E8%A6%81%E6%98%AFcont-monad/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JS一些概念的整理</h2></header><div class=entry-content><p>hoisting console.log(a) var a = 10 會變成類似(會說是類似，因為底層不一定是這樣做)
var a console.log(a) a = 10 可以把他
var a = '1' // A... var b = 2 // B ... var c 想像成這樣
function whatever(a,b,c) { // A ... // B ... }('1',1,undefined); 如果有let
var a = '1' function x() { // a ... let a = 2 } 先想像成
function whatever(a) { function x() { // a ... let a = 2 // b ....</p></div><footer class=entry-footer><span title='2020-04-21 23:35:12 +0000 UTC'>April 21, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</footer><a class=entry-link aria-label="post link to JS一些概念的整理" href=https://littlebees.github.io/2020/04/js%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E6%95%B4%E7%90%86/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://littlebees.github.io/posts/page/64/>«&nbsp;Prev&nbsp;64/66
</a><a class=next href=https://littlebees.github.io/posts/page/66/>Next&nbsp;66/66&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>