<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>共識、錯誤、時間、排序 | 記事本</title>
<meta name=keywords content="Distributed"><meta name=description content="動機
分散式系統最重要的就是在不同的錯誤情境下達成共識
之後追求performance
串起這一切的就是時間與與之對應的排序
下面就來簡單的整理一下"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2022/03/%E5%85%B1%E8%AD%98%E9%8C%AF%E8%AA%A4%E6%99%82%E9%96%93%E6%8E%92%E5%BA%8F/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2022/03/%E5%85%B1%E8%AD%98%E9%8C%AF%E8%AA%A4%E6%99%82%E9%96%93%E6%8E%92%E5%BA%8F/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="共識、錯誤、時間、排序"><meta property="og:description" content="動機
分散式系統最重要的就是在不同的錯誤情境下達成共識
之後追求performance
串起這一切的就是時間與與之對應的排序
下面就來簡單的整理一下"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2022/03/%E5%85%B1%E8%AD%98%E9%8C%AF%E8%AA%A4%E6%99%82%E9%96%93%E6%8E%92%E5%BA%8F/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-31T11:04:02+00:00"><meta property="article:modified_time" content="2022-03-31T11:04:02+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="共識、錯誤、時間、排序"><meta name=twitter:description content="動機
分散式系統最重要的就是在不同的錯誤情境下達成共識
之後追求performance
串起這一切的就是時間與與之對應的排序
下面就來簡單的整理一下"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"共識、錯誤、時間、排序","item":"https://littlebees.github.io/2022/03/%E5%85%B1%E8%AD%98%E9%8C%AF%E8%AA%A4%E6%99%82%E9%96%93%E6%8E%92%E5%BA%8F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"共識、錯誤、時間、排序","name":"共識、錯誤、時間、排序","description":"動機 分散式系統最重要的就是在不同的錯誤情境下達成共識 之後追求performance\n串起這一切的就是時間與與之對應的排序\n下面就來簡單的整理一下\n","keywords":["Distributed"],"articleBody":"動機 分散式系統最重要的就是在不同的錯誤情境下達成共識 之後追求performance\n串起這一切的就是時間與與之對應的排序\n下面就來簡單的整理一下\n錯誤 傳訊時可能遺失、out-of-order、重複 接收方可能當機導致不能回 (但recover會知道自己之前做了什麼)\n在上面的情況下，分成兩種錯誤\n拜占庭 在同一個情況(狀態)，出來的output可能不同 (可能是sender在搞，也有可能是在中間被改，換言之 資料損壞) 拜占庭中的叛徒 leader可以對不同人送不同的msg 不能直接用leader的msg，要參考其他人的 非拜占庭 在同一個情況(狀態)，出來的output都一樣 就算當機，也還是忠誠 共識 共識在不同的情況下有不同的目標\n拜占庭 (拜占庭將軍問題) 忠誠的人最後都要做相同的指令 如果leader忠誠，所有忠誠的人最後都要接受leader的命令 非拜占庭 過半數都同意 所有人都同意 解法 拜占庭的output可能不同所以分成\noral messages: 可以被偽造 signed messages: 不能被偽造簽名\u0026無法改內容(會被抓到)，同時能被任何人驗證 同時所有msg都會\n寄往正確的地方 知道sernder是誰 有辦法知道msg沒有寄成 拜占庭 + oral messages 前提: 至少$2m+1$個人忠誠 (m是叛徒數量)\nleader把msg丟給所有人 把收到的msg丟給自己與leader以外的人 (timeout當成retreat) 根據收集到的msg的多數($2m+1$個)做事 blockchain 在blockchain中，如果有人想做假\n要巨量的工作量 同時要成為最長鏈 (在fork的時候還會讓交易更慢) 拜占庭 + signed messages 前提: 至少$2$個人忠誠\n收到leader的msg，放到orders的set中，把該msg加上自己的sign再傳給其他人 收到其他msg，如果msg不同，放到orders的set中，把該msg加上自己的sign再傳給沒有在上面sign的人 都收完了，透過某個神祕choice函數從orders中選一個order (如果leader忠誠，應該只會有一個order) 非拜占庭 + 過半數都同意 (consensus) paxos\n非拜占庭 + 所有人都同意 (uniform consensus) 一般這裡都是看uniform consensus的特化問題\natomic commit\n所有人都要一起commit或是abort。\n只要有節點發生故障，atomic commit就一定會阻塞嗎？\n根源就在於Abort和Commit並不是對等的決策\n假設有一個節點宕機了，其它節點大可以選擇Abort決策（注意不能選擇Commit），從而讓整個事務Abort掉 在這個過程中，參與分佈式事務的所有節點（包括宕機的這個節點）對於“執行Commit還是Abort”也是達成了共識的（這個共識是Abort）\n同步與異步 \u0026 拜占庭與一般共識 拜占庭需要知道timeout，所以需要同步的時間 一般共識不用知道timeout是異步的\n2PC \u0026 3PC 發transation prepare問所有人行不行commit 都ok，發commit 有人不行，發abort 看起來很簡單，其實有細節 記得，分散式重要的是不能反悔這件事，在2PC有哪邊不能反悔?\n只要回了ok，就必須等到master回commit\n其他狀況都可以用發abort處理\n但這有可能master在發commit之前死亡，這樣所有人都要等\n所以有了3PC，與raft的prevote很像，在要大家prepare之前先問有沒有辦法回ok 因為這個不會回了ok這樣就算有人出事也沒差(fail early)\n因為prevote已經確認過了大家都ok，這樣如果有人出事都可以直接過。 有人在prevorte，回不能commit就不會到第二階段，就不能動\n最後就是看在什麼狀態下能回ok? server已經到了可以跑transation的狀態，同時沒有其他thread(transaction)可以改。 (因為這個會被persist，所以就算crash也沒事)\n3PC的優點： 最大優點就是降低了參與者的阻塞範圍，並且能夠在出現單點故障後繼續達成一致。\n3PC的缺點: 參與者接收到了PreCommit消息，然後網絡出現問題，參與者和協調者無法通信，這種情況下，參與者依然會執行事務的提交。\n時間、排序 我們怎麼意識到時間流逝?\n做了不同的指令 觀察的資料發生變化 有沒有我們無法意識到的時間? 也許有，但對於系統來說永遠有一個，現實時間\n所以時間是什麼? 不一致的證據(證明)\n而時間嚴格遞增，所以可以比較，就有了排序\n順序一致性 sort過後的所有指令，每個read都要與最近的write一樣 (全域的read/write序) 在process中的order要在sort過後的順序中保持 (process中的序) 下面是順序一致性的例子 A –\u003e w1(x) r3(x) –\u003e A // 這是舊的!! C –\u003e w2(x) r3(x) –\u003e C B –\u003e w1(x) r3(x) –\u003e B\n線性一致性 在順序一致性的基礎上加一個條件\n只要時間不overlay，指令之間的在時間上的order都要保持 (全域的時間序) 所以線性一致性可以確保read總是最新的，因此上面的例子不是線性一致\n因果一致性 先定義因果關係 (a -\u003e b，他是transitive，aka happen-before)\n在同一process，a在b之前執行 a做的write，b做read拿到 因果關係是一種偏序，也就是，不是所有東西都可以排序，像沒有因果關係的東西(async的指令)，就沒有排序也不知道怎麼排序；而現實時間是一種全序，都可以用時間點排序\n接著定義因果一致性，在某個process的所有指令與其他process的write，可以sort成\nread拿到的值必須是最近一次的write sort要依據因果關係 這邊的重點是在某個process，也就是我們是從process去看而已。 這有什麼結果?\n不同process可能看到的排序結果可能不同!!\n上圖表達了兩個進程的並發執行過程。它是滿足因果一致性的\n站在P1視角，有：\nA –\u003e w1(x) B –\u003e w2(x) r1(x) –\u003e B 站在P2視角，有：\nB –\u003e w2(x) A –\u003e w1(x) r2(x) –\u003e A\n這樣的好處是可以在其他機器死亡時堤供舊資料，反正只要滿足因果關係就好\nlamport clock \u0026 Strong Clock Condition lamport clock的定義是如果a與b有因果關係，a的clock必定小於b的clock (偏序)\n可以為每一個事件上一個數字，之後嚴格遞增，在synchronize時取最大的+1，就會拿到lamport clock。\n同時，clock之間的比較，只有在有因果關係才有意義。 像是兩個併發的指令，比較clock就沒意義。\n但這是可以實現全域排序的其中一種方法，因為clock隱含因果關係。 用clock排序後就有順序一致，如果同時符合時間序，就有線性一致。\n符合時間序叫Strong Clock Condition 因為lamport clock是系統中的時間，與現實(外界)的時間不同步，所以可能看到新的request拿到比較小的lamport clock\n不同步?\n任意兩個時鐘的運行速率有差異，它們的讀數會漂移得越來越遠 時鐘的運行速率跟真實時間的流逝速率可能有差異 gc pause \u0026 redlock \u0026 fence token: 外界的時間 lamport clock是系統中的時間 Strong Clock Condition是現實或是宇宙的時間\n還有其他時間嗎? 如果gc pause發生，變成自己的時間不準了，因為自己的時間與外界的時間不一致 但實際上時間早已流逝!!\n所以可以引入下一個時間，在redlock的辯論中叫fence token，其實就是storage的lamport clock\n同步時間 NTP可以同步時間，但還是有誤差(還有可能倒退!!)\n所以要把誤差也算在時間點中(spanner的truetime)\n最終一致性 這個一致性沒有保證任何東西，因為我們不確定會有什麼，只知道未來一定會有。\n線性一致性和順序一致性屬於safety property（安全性） 而最終一致性屬於liveness property（活性）\nsafety：它表示「壞事」永遠不會發生 liveness：它表示「好事」最終會發生\n通常來說，只有當safety和liveness這兩種屬性被同時考慮時，一個系統才能提供有意義的系統保證。 對於系統使用者來說，你必須針對數據不一致的可能性做好補償措施 (compensation)。 這也是最終一致性系統難用的地方\nRef 分布式领域最重要的一篇论文，到底讲了什么？ 基于Redis的分布式锁到底安全吗（上）？ 基于Redis的分布式锁到底安全吗（下）？ 条分缕析分布式：因果一致性和相对论时空 The Byzantine Generals Problem\n","wordCount":"261","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2022-03-31T11:04:02Z","dateModified":"2022-03-31T11:04:02Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2022/03/%E5%85%B1%E8%AD%98%E9%8C%AF%E8%AA%A4%E6%99%82%E9%96%93%E6%8E%92%E5%BA%8F/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">共識、錯誤、時間、排序</h1><div class=post-meta><span title='2022-03-31 11:04:02 +0000 UTC'>March 31, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e9%8c%af%e8%aa%a4 aria-label=錯誤>錯誤</a></li><li><a href=#%e5%85%b1%e8%ad%98 aria-label=共識>共識</a><ul><li><a href=#%e8%a7%a3%e6%b3%95 aria-label=解法>解法</a><ul><li><a href=#%e6%8b%9c%e5%8d%a0%e5%ba%ad--oral-messages aria-label="拜占庭 + oral messages">拜占庭 + oral messages</a><ul><li><a href=#blockchain aria-label=blockchain>blockchain</a></li></ul></li><li><a href=#%e6%8b%9c%e5%8d%a0%e5%ba%ad--signed-messages aria-label="拜占庭 + signed messages">拜占庭 + signed messages</a></li><li><a href=#%e9%9d%9e%e6%8b%9c%e5%8d%a0%e5%ba%ad--%e9%81%8e%e5%8d%8a%e6%95%b8%e9%83%bd%e5%90%8c%e6%84%8f-consensus aria-label="非拜占庭 + 過半數都同意 (consensus)">非拜占庭 + 過半數都同意 (consensus)</a></li><li><a href=#%e9%9d%9e%e6%8b%9c%e5%8d%a0%e5%ba%ad--%e6%89%80%e6%9c%89%e4%ba%ba%e9%83%bd%e5%90%8c%e6%84%8f-uniform-consensus aria-label="非拜占庭 + 所有人都同意 (uniform consensus)">非拜占庭 + 所有人都同意 (uniform consensus)</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e8%88%87%e7%95%b0%e6%ad%a5--%e6%8b%9c%e5%8d%a0%e5%ba%ad%e8%88%87%e4%b8%80%e8%88%ac%e5%85%b1%e8%ad%98 aria-label="同步與異步 & 拜占庭與一般共識">同步與異步 & 拜占庭與一般共識</a><ul><li><a href=#2pc--3pc aria-label="2PC & 3PC">2PC & 3PC</a></li></ul></li></ul></li></ul></li><li><a href=#%e6%99%82%e9%96%93%e6%8e%92%e5%ba%8f aria-label=時間、排序>時間、排序</a><ul><li><a href=#%e9%a0%86%e5%ba%8f%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=順序一致性>順序一致性</a></li><li><a href=#%e7%b7%9a%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=線性一致性>線性一致性</a></li><li><a href=#%e5%9b%a0%e6%9e%9c%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=因果一致性>因果一致性</a><ul><li><a href=#lamport-clock--strong-clock-condition aria-label="lamport clock & Strong Clock Condition">lamport clock & Strong Clock Condition</a><ul><li><a href=#gc-pause--redlock--fence-token-%e5%a4%96%e7%95%8c%e7%9a%84%e6%99%82%e9%96%93 aria-label="gc pause & redlock & fence token: 外界的時間">gc pause & redlock & fence token: 外界的時間</a></li></ul></li><li><a href=#%e5%90%8c%e6%ad%a5%e6%99%82%e9%96%93 aria-label=同步時間>同步時間</a></li></ul></li><li><a href=#%e6%9c%80%e7%b5%82%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=最終一致性>最終一致性</a></li></ul></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>分散式系統最重要的就是在不同的錯誤情境下達成共識
之後追求performance</p><p>串起這一切的就是時間與與之對應的排序</p><p>下面就來簡單的整理一下</p><h2 id=錯誤>錯誤<a hidden class=anchor aria-hidden=true href=#錯誤>#</a></h2><p>傳訊時可能遺失、out-of-order、重複
接收方可能當機導致不能回 (但recover會知道自己之前做了什麼)</p><p>在上面的情況下，分成兩種錯誤</p><ul><li>拜占庭<ul><li>在同一個情況(狀態)，出來的output可能不同 (可能是sender在搞，也有可能是在中間被改，換言之 資料損壞)<ul><li>拜占庭中的叛徒<ul><li>leader可以對不同人送不同的msg</li><li>不能直接用leader的msg，要參考其他人的</li></ul></li></ul></li></ul></li><li>非拜占庭<ul><li>在同一個情況(狀態)，出來的output都一樣<ul><li>就算當機，也還是忠誠</li></ul></li></ul></li></ul><h2 id=共識>共識<a hidden class=anchor aria-hidden=true href=#共識>#</a></h2><p>共識在不同的情況下有不同的目標</p><ul><li>拜占庭 (拜占庭將軍問題)<ul><li>忠誠的人最後都要做相同的指令</li><li>如果leader忠誠，所有忠誠的人最後都要接受leader的命令</li></ul></li><li>非拜占庭<ul><li>過半數都同意</li><li>所有人都同意</li></ul></li></ul><h3 id=解法>解法<a hidden class=anchor aria-hidden=true href=#解法>#</a></h3><p>拜占庭的output可能不同所以分成</p><ul><li>oral messages: 可以被偽造</li><li>signed messages: 不能被偽造簽名&無法改內容(會被抓到)，同時能被任何人驗證</li></ul><p>同時所有msg都會</p><ol><li>寄往正確的地方</li><li>知道sernder是誰</li><li>有辦法知道msg沒有寄成</li></ol><h4 id=拜占庭--oral-messages>拜占庭 + oral messages<a hidden class=anchor aria-hidden=true href=#拜占庭--oral-messages>#</a></h4><p>前提: 至少$2m+1$個人忠誠 (m是叛徒數量)</p><ol><li>leader把msg丟給所有人</li><li>把收到的msg丟給自己與leader以外的人 (timeout當成retreat)</li><li>根據收集到的msg的多數($2m+1$個)做事</li></ol><h5 id=blockchain>blockchain<a hidden class=anchor aria-hidden=true href=#blockchain>#</a></h5><p>在blockchain中，如果有人想做假</p><ol><li>要巨量的工作量</li><li>同時要成為最長鏈 (在fork的時候還會讓交易更慢)</li></ol><h4 id=拜占庭--signed-messages>拜占庭 + signed messages<a hidden class=anchor aria-hidden=true href=#拜占庭--signed-messages>#</a></h4><p>前提: 至少$2$個人忠誠</p><ol><li>收到leader的msg，放到<code>orders</code>的set中，把該msg加上自己的sign再傳給其他人</li><li>收到其他msg，如果msg不同，放到<code>orders</code>的set中，把該msg加上自己的sign再傳給沒有在上面sign的人</li><li>都收完了，透過某個神祕choice函數從orders中選一個order (如果leader忠誠，應該只會有一個order)</li></ol><h4 id=非拜占庭--過半數都同意-consensus>非拜占庭 + 過半數都同意 (consensus)<a hidden class=anchor aria-hidden=true href=#非拜占庭--過半數都同意-consensus>#</a></h4><p>paxos</p><h4 id=非拜占庭--所有人都同意-uniform-consensus>非拜占庭 + 所有人都同意 (uniform consensus)<a hidden class=anchor aria-hidden=true href=#非拜占庭--所有人都同意-uniform-consensus>#</a></h4><p>一般這裡都是看uniform consensus的特化問題</p><p><em>atomic commit</em></p><p>所有人都要一起commit或是abort。</p><p>只要有節點發生故障，atomic commit就一定會阻塞嗎？</p><p>根源就在於Abort和Commit並不是對等的決策</p><p>假設有一個節點宕機了，其它節點大可以選擇Abort決策（注意不能選擇Commit），從而讓整個事務Abort掉
在這個過程中，參與分佈式事務的所有節點（包括宕機的這個節點）對於“執行Commit還是Abort”也是達成了共識的（這個共識是Abort）</p><h4 id=同步與異步--拜占庭與一般共識>同步與異步 & 拜占庭與一般共識<a hidden class=anchor aria-hidden=true href=#同步與異步--拜占庭與一般共識>#</a></h4><p>拜占庭需要知道timeout，所以需要同步的時間
一般共識不用知道timeout是異步的</p><h5 id=2pc--3pc>2PC & 3PC<a hidden class=anchor aria-hidden=true href=#2pc--3pc>#</a></h5><ul><li>發transation</li><li>prepare問所有人行不行commit</li><li>都ok，發commit</li><li>有人不行，發abort</li></ul><p>看起來很簡單，其實有細節
記得，分散式重要的是不能反悔這件事，在2PC有哪邊不能反悔?</p><p><strong>只要回了ok，就必須等到master回commit</strong></p><p>其他狀況都可以用發abort處理</p><p>但這有可能master在發commit之前死亡，這樣所有人都要等</p><p>所以有了3PC，與raft的prevote很像，在要大家prepare之前先問有沒有辦法回ok
因為這個不會<strong>回了ok</strong>這樣就算有人出事也沒差(fail early)</p><p>因為prevote已經確認過了大家都ok，這樣如果有人出事都可以直接過。
有人在prevorte，回不能commit就不會到第二階段，就不能動</p><p>最後就是看在什麼狀態下能回ok?
server已經到了可以跑transation的狀態，同時沒有其他thread(transaction)可以改。
(因為這個會被persist，所以就算crash也沒事)</p><p>3PC的優點： 最大優點就是降低了參與者的阻塞範圍，並且能夠在出現單點故障後繼續達成一致。</p><p>3PC的缺點: 參與者接收到了PreCommit消息，然後網絡出現問題，參與者和協調者無法通信，這種情況下，參與者依然會執行事務的提交。</p><h2 id=時間排序>時間、排序<a hidden class=anchor aria-hidden=true href=#時間排序>#</a></h2><p>我們怎麼意識到時間流逝?</p><ol><li>做了不同的指令</li><li>觀察的資料發生變化</li></ol><p>有沒有我們無法意識到的時間?
也許有，但對於系統來說永遠有一個，現實時間</p><p>所以時間是什麼?
不一致的證據(證明)</p><p>而時間嚴格遞增，所以可以比較，就有了排序</p><h3 id=順序一致性>順序一致性<a hidden class=anchor aria-hidden=true href=#順序一致性>#</a></h3><ol><li>sort過後的所有指令，每個read都要與最近的write一樣 (全域的read/write序)</li><li>在process中的order要在sort過後的順序中保持 (process中的序)</li></ol><p><img loading=lazy src=https://i.imgur.com/0Alc7OF.png alt></p><p>下面是順序一致性的例子
A –> w1(x)
r3(x) –> A // 這是舊的!!
C –> w2(x)
r3(x) –> C
B –> w1(x)
r3(x) –> B</p><h3 id=線性一致性>線性一致性<a hidden class=anchor aria-hidden=true href=#線性一致性>#</a></h3><p>在順序一致性的基礎上加一個條件</p><ul><li>只要時間不overlay，指令之間的<strong>在時間上</strong>的order都要保持 (全域的時間序)</li></ul><p>所以線性一致性可以確保read總是最新的，因此上面的例子不是線性一致</p><h3 id=因果一致性>因果一致性<a hidden class=anchor aria-hidden=true href=#因果一致性>#</a></h3><p>先定義因果關係 (a -> b，他是transitive，aka happen-before)</p><ol><li>在同一process，a在b之前執行</li><li>a做的write，b做read拿到</li></ol><p>因果關係是一種偏序，也就是，不是所有東西都可以排序，像沒有因果關係的東西(async的指令)，就沒有排序也不知道怎麼排序；而現實時間是一種全序，都可以用時間點排序</p><p>接著定義因果一致性，在某個process的所有指令與其他process的write，可以sort成</p><ol><li>read拿到的值必須是最近一次的write</li><li>sort要依據因果關係</li></ol><p>這邊的重點是在某個process，也就是我們是從process去看而已。
這有什麼結果?</p><p>不同process可能看到的排序結果可能不同!!</p><p><img loading=lazy src=https://i.imgur.com/BNFqQz3.png alt></p><p>上圖表達了兩個進程的並發執行過程。它是滿足因果一致性的</p><p>站在P1視角，有：</p><p>A –> w1(x)
B –> w2(x)
r1(x) –> B
站在P2視角，有：</p><p>B –> w2(x)
A –> w1(x)
r2(x) –> A</p><p>這樣的好處是可以在其他機器死亡時堤供舊資料，反正只要滿足因果關係就好</p><h4 id=lamport-clock--strong-clock-condition>lamport clock & Strong Clock Condition<a hidden class=anchor aria-hidden=true href=#lamport-clock--strong-clock-condition>#</a></h4><p>lamport clock的定義是如果a與b有因果關係，a的clock必定小於b的clock (偏序)</p><p>可以為每一個事件上一個數字，之後嚴格遞增，在synchronize時取最大的+1，就會拿到lamport clock。</p><p>同時，clock之間的比較，只有在有因果關係才有意義。
像是兩個併發的指令，比較clock就沒意義。</p><p>但這是可以實現全域排序的其中一種方法，因為clock隱含因果關係。
用clock排序後就有順序一致，如果同時符合時間序，就有線性一致。</p><p>符合時間序叫Strong Clock Condition
因為lamport clock是系統中的時間，與現實(外界)的時間不同步，所以可能看到新的request拿到比較小的lamport clock</p><p>不同步?</p><ul><li>任意兩個時鐘的運行速率有差異，它們的讀數會漂移得越來越遠</li><li>時鐘的運行速率跟真實時間的流逝速率可能有差異</li></ul><h5 id=gc-pause--redlock--fence-token-外界的時間>gc pause & redlock & fence token: 外界的時間<a hidden class=anchor aria-hidden=true href=#gc-pause--redlock--fence-token-外界的時間>#</a></h5><p>lamport clock是系統中的時間
Strong Clock Condition是現實或是宇宙的時間</p><p>還有其他時間嗎?
如果gc pause發生，變成自己的時間不準了，因為自己的時間與外界的時間不一致
但實際上時間早已流逝!!</p><p>所以可以引入下一個時間，在redlock的辯論中叫fence token，其實就是storage的lamport clock</p><h4 id=同步時間>同步時間<a hidden class=anchor aria-hidden=true href=#同步時間>#</a></h4><p>NTP可以同步時間，但還是有誤差(還有可能倒退!!)</p><p>所以要把誤差也算在時間點中(spanner的truetime)</p><h3 id=最終一致性>最終一致性<a hidden class=anchor aria-hidden=true href=#最終一致性>#</a></h3><p>這個一致性沒有保證任何東西，因為我們不確定會有什麼，只知道未來一定會有。</p><p>線性一致性和順序一致性屬於safety property（安全性）
而最終一致性屬於liveness property（活性）</p><p>safety：它表示「壞事」永遠不會發生
liveness：它表示「好事」最終會發生</p><p>通常來說，只有當safety和liveness這兩種屬性被同時考慮時，一個系統才能提供有意義的系統保證。
對於系統使用者來說，你必須針對數據不一致的可能性做好補償措施 (compensation)。
這也是最終一致性系統難用的地方</p><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=http://zhangtielei.com/posts/blog-time-clock-ordering.html>分布式领域最重要的一篇论文，到底讲了什么？</a>
<a href=http://zhangtielei.com/posts/blog-redlock-reasoning.html>基于Redis的分布式锁到底安全吗（上）？</a>
<a href=http://zhangtielei.com/posts/blog-redlock-reasoning-part2.html>基于Redis的分布式锁到底安全吗（下）？</a>
<a href=http://zhangtielei.com/posts/blog-distributed-causal-consistency.html>条分缕析分布式：因果一致性和相对论时空</a>
<a href=https://lamport.azurewebsites.net/pubs/byz.pdf>The Byzantine Generals Problem</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/distributed/>Distributed</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2022/04/%E5%88%86%E6%95%A3%E5%BC%8F%E6%89%8B%E6%B3%95/><span class=title>« Prev</span><br><span>分散式手法</span>
</a><a class=next href=https://littlebees.github.io/2022/03/raft%E8%A3%9C%E9%81%BA/><span class=title>Next »</span><br><span>raft補遺</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>