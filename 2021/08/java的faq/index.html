<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>java的faq | 記事本</title>
<meta name=keywords content="Java"><meta name=description content="動機
就faq"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/08/java%E7%9A%84faq/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/08/java%E7%9A%84faq/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="java的faq"><meta property="og:description" content="動機
就faq"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/08/java%E7%9A%84faq/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-18T22:27:36+00:00"><meta property="article:modified_time" content="2021-08-18T22:27:36+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="java的faq"><meta name=twitter:description content="動機
就faq"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"java的faq","item":"https://littlebees.github.io/2021/08/java%E7%9A%84faq/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"java的faq","name":"java的faq","description":"動機 就faq\n","keywords":["Java"],"articleBody":"動機 就faq\nOO 物件導向的特徵 封裝 多型 繼承 Overload和Override差在 Overload是同class同名的method但有不同的signatrue Override child class把同名同signatrue的method蓋掉 equals()與== equals是比值 因為他是method可以被蓋所以可以比值 所以要一起改hashcode ==是比記憶體位置 這是operator不能override只能照設定的來 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ String str1 = \"通话\"; String str2 = \"重地\"; System.out.println(String.format(\"str1：%d | str2：%d\", str1.hashCode(),str2.hashCode())); System.out.println(str1.equals(str2)); Private, Public, Protected private: class scope protected: inherence scope public: whatever default (無修飾元): file(package) scope java type primitive byte int short short a; a+=1; a = (short) (a+1) char long float 1.1F double 1.1 boolean Object (有人叫他引用type) int與Integer差在 一個是primitive一個是Object 大小，使用方式都不一樣 String與StringBuffer差在 String不可改動，每次+都是生新的String StringBuffer可以改，像c的char[] Exception與Runtime Exception與Error差在 Exception會被宣告在method signatrue(throws) 一定要被catch，compiler會檢查 Runtime Exception就是一般的例外 丟了會stack trace back 沒人接就壞掉 Error是硬體出事了，當他出現時世界就毀滅了 ArrayList,Vector, LinkedList差在 LinkedList就是linkedlist，但是是雙向 ArrayList就是C++的vector Vector就是有synchronized的ArrayList 但現在都用Concurrent開頭的 HashMap和Hashtable差在 HashMap不是thread safe，能放null Hashtable有synchronized final, finally, finalize差在 final 這欄位不可變、不可繼承、不可override final的instant variable沒有default value finally不論有沒有例外，總是執行 就算try裡面有放return也會跑!! finalize被GC會被call的method 現在用cleaner!! compareTo() vs equals() in String compareTo就是一般比較的函數，ruby的\u003c=\u003e equals只有boolean interface default \u0026 static method default用在不用實做某些method的時候 (變得像abstrac class) 可以延伸到abstract class與interface的差異 abstract class不一定要實作所有abstract，interface要 abstract class的method可以access attribute，interface只有常數 static method就是跟著interface的method，Iface.method() Anonymous Inner Class 很像clousre，可以直接new interface接要override的method 所以也沒辦法直接extend，implements public class AnonymousInnerClass { public static void main(String[] args) { // Ex. Anonymous Inner Class new Thread() { @Override public void run() { // code... System.out.println(\"Anonymous Inner Class\"); } }.start(); } } Collection與Collections差在 Collection是interface，要實作add與remove與toarray Collections是對Collection操作的方法，像C++的algorithm List、Set、Map 是否繼承自 Collection 介面 List與Set是 Map不是，是AbstractMap sleep \u0026 wait sleep是thread睡覺，要時間到才會自己跑，不會放棄鎖 wait是針對monitor的工作，可以讓自己睡，或是收別人的signal，會放棄鎖 啟動一個線程是用 run() 還是 start() start之後會invoke run跑需要的code 當一個線程進入一個物件的一個 Synchronized 方法後，其它線程是否可以進入此物件的其他方法？ 要看是不是吃同一個obj 如果是一般method，就沒辦法進去 static method會吃class做為鎖，就可以進去 java的記憶體 for runtime stack heap method area const pool code static 1/0 \u0026 1/1.0 1/0: ArithmeticException 1/1.0: Infinite (沒有例外) constructor是否可被override? 不行，可以overload jvm怎麼載入class ClassLoader會根據繼承關係把class，讀進來會驗證、allocate mem、link、init static資料、生成物件讓jvm跑 從來沒有人說過Java的Class名字必須和其檔名相同。但public class的名字必須和檔名相同 // OtherThing.java class Something { private static void main(String[] something_to_do) { System.out.println(\"Do something ...\"); } } Math.round(-1.5) -1 Thread state start ready running blocked destroied 如何deepcopy Cloneable Serializable Inversion of Control 原本是Logic去控制資料 有些資料其實是一起的，所以可以根據我們這邊的需求去生 但也可以讓外面給 (Dependency Injection) 透過setter 透過interface (我們只call method) 透過constructor 再跑logic之前讓資料就定位 之後就是有一堆framework，想描述(變成像prolog那樣)給參數這行為就有了這個詞 這到最後可以不管程式實作了!! 它本身就是程式阿 Servlet cgi與servlet差在 cgi是每次req都fork一個process去處理，之後回到parent servlet是會初始化只後一直處理req，等server不要時再回收 AOP 有些與logic無關的code但要與logic放在一起的code(log)，Aspect 如果想分開就是要留callback的點，Joinpoint B+ tree 每一個node代表一個range，下面的ptr指到符合範圍的node design pattern 把object當成lambda就可以處理很多問題\n之後就是用\ninterface 繼承 包成object 去傳需要的邏輯 剩下就visitor是pattern match\ndesign pattern隨便筆記\n正規化 讓table好join\n把array轉90度 讓整個主鍵可以filter出所有欄目 (course ID, student ID去濾可以找出grade與student name，name要被割出去) 割出去的項目只能用主鍵去濾資料 note\nGC 每個obj都是一個node，所以每個都有\nindegree 當indegree為0就被回收 如果有loop就不會被回收 edge 從root做traversal，有走到就是ok 會產生記憶體斷片、物件多會跑很久(stop the world) 物件多會跑很久: 區分世代使用不同algo 產生記憶體斷片: 一次只用整條記憶體的一半，要換時就把剩下都copy去另一邊 ","wordCount":"320","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-08-18T22:27:36Z","dateModified":"2021-08-18T22:27:36Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/08/java%E7%9A%84faq/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">java的faq</h1><div class=post-meta><span title='2021-08-18 22:27:36 +0000 UTC'>August 18, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#oo aria-label=OO>OO</a></li><li><a href=#java aria-label=java>java</a></li><li><a href=#servlet aria-label=Servlet>Servlet</a></li><li><a href=#design-pattern aria-label="design pattern">design pattern</a></li><li><a href=#%e6%ad%a3%e8%a6%8f%e5%8c%96 aria-label=正規化>正規化</a></li><li><a href=#gc aria-label=GC>GC</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>就faq</p><h2 id=oo>OO<a hidden class=anchor aria-hidden=true href=#oo>#</a></h2><ol><li>物件導向的特徵</li></ol><ul><li>封裝</li><li>多型</li><li>繼承</li></ul><ol start=2><li>Overload和Override差在</li></ol><ul><li>Overload是同class同名的method但有不同的signatrue</li><li>Override child class把同名同signatrue的method蓋掉</li></ul><ol start=3><li>equals()與==</li></ol><ul><li>equals是比值<ul><li>因為他是method可以被蓋所以可以比值<ul><li>所以要一起改hashcode</li></ul></li></ul></li><li>==是比記憶體位置<ul><li>這是operator不能override只能照設定的來</li></ul></li><li>两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span><span class=w> </span><span class=n>str1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;通话&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>str2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;重地&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>String</span><span class=p>.</span><span class=na>format</span><span class=p>(</span><span class=s>&#34;str1：%d | str2：%d&#34;</span><span class=p>,</span><span class=w>  </span><span class=n>str1</span><span class=p>.</span><span class=na>hashCode</span><span class=p>(),</span><span class=n>str2</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>str1</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>str2</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><ol start=4><li>Private, Public, Protected</li></ol><ul><li>private: class scope</li><li>protected: inherence scope</li><li>public: whatever</li><li>default (無修飾元): file(package) scope</li></ul><h2 id=java>java<a hidden class=anchor aria-hidden=true href=#java>#</a></h2><ol><li>type</li></ol><ul><li>primitive<ul><li>byte</li><li>int</li><li>short<ul><li><code>short a; a+=1;</code><ul><li><code>a = (short) (a+1)</code></li></ul></li></ul></li><li>char</li><li>long</li><li>float<ul><li>1.1F</li></ul></li><li>double<ul><li>1.1</li></ul></li><li>boolean</li></ul></li><li>Object (有人叫他引用type)</li></ul><ol start=2><li>int與Integer差在</li></ol><ul><li>一個是primitive一個是Object<ul><li>大小，使用方式都不一樣</li></ul></li></ul><ol start=3><li>String與StringBuffer差在</li></ol><ul><li>String不可改動，每次+都是生新的String</li><li>StringBuffer可以改，像c的char[]</li></ul><ol start=4><li>Exception與Runtime Exception與Error差在</li></ol><ul><li>Exception會被宣告在method signatrue(throws)<ul><li>一定要被catch，compiler會檢查</li></ul></li><li>Runtime Exception就是一般的例外<ul><li>丟了會stack trace back</li><li>沒人接就壞掉</li></ul></li><li>Error是硬體出事了，當他出現時世界就毀滅了</li></ul><ol start=5><li>ArrayList,Vector, LinkedList差在</li></ol><ul><li>LinkedList就是linkedlist，但是是雙向</li><li>ArrayList就是C++的vector<ul><li>Vector就是有synchronized的ArrayList<ul><li>但現在都用Concurrent開頭的</li></ul></li></ul></li></ul><ol start=6><li>HashMap和Hashtable差在</li></ol><ul><li>HashMap不是thread safe，能放null</li><li>Hashtable有synchronized</li></ul><ol start=7><li>final, finally, finalize差在</li></ol><ul><li>final 這欄位不可變、不可繼承、不可override<ul><li>final的instant variable沒有default value</li></ul></li><li>finally不論有沒有例外，總是執行<ul><li><em>就算try裡面有放return也會跑!!</em></li></ul></li><li>finalize被GC會被call的method<ul><li>現在用cleaner!!</li></ul></li></ul><ol start=8><li>compareTo() vs equals() in String</li></ol><ul><li>compareTo就是一般比較的函數，ruby的<code>&lt;=></code></li><li>equals只有boolean</li></ul><ol start=9><li>interface default & static method</li></ol><ul><li>default用在不用實做某些method的時候 (變得像abstrac class)<ul><li>可以延伸到abstract class與interface的差異<ul><li>abstract class不一定要實作所有abstract，interface要</li><li>abstract class的method可以access attribute，interface只有常數</li></ul></li></ul></li><li>static method就是跟著interface的method，<code>Iface.method()</code></li></ul><ol start=10><li>Anonymous Inner Class</li></ol><ul><li>很像clousre，可以直接new interface接要override的method</li><li>所以也沒辦法直接extend，implements</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AnonymousInnerClass</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Ex. Anonymous Inner Class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// code...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Anonymous Inner Class&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol start=11><li>Collection與Collections差在</li></ol><ul><li>Collection是interface，要實作add與remove與toarray</li><li>Collections是對Collection操作的方法，像C++的algorithm</li></ul><ol start=12><li>List、Set、Map 是否繼承自 Collection 介面</li></ol><ul><li>List與Set是</li><li>Map不是，是AbstractMap</li></ul><ol start=13><li>sleep & wait</li></ol><ul><li>sleep是thread睡覺，要時間到才會自己跑，不會放棄鎖</li><li>wait是針對monitor的工作，可以讓自己睡，或是收別人的signal，會放棄鎖</li></ul><ol start=14><li>啟動一個線程是用 run() 還是 start()</li></ol><ul><li>start之後會invoke run跑需要的code</li></ul><ol start=15><li>當一個線程進入一個物件的一個 Synchronized 方法後，其它線程是否可以進入此物件的其他方法？</li></ol><ul><li>要看是不是吃同一個obj<ul><li>如果是一般method，就沒辦法進去</li><li>static method會吃class做為鎖，就可以進去</li></ul></li></ul><ol start=16><li>java的記憶體</li></ol><ul><li>for runtime<ul><li>stack</li><li>heap</li><li>method area<ul><li>const pool</li></ul></li></ul></li><li>code</li><li>static</li></ul><ol start=17><li>1/0 & 1/1.0</li></ol><ul><li>1/0: ArithmeticException</li><li>1/1.0: Infinite (沒有例外)</li></ul><ol start=18><li>constructor是否可被override?</li></ol><ul><li>不行，可以overload</li></ul><ol start=19><li>jvm怎麼載入class</li></ol><ul><li>ClassLoader會根據繼承關係把class，讀進來會驗證、allocate mem、link、init static資料、生成物件讓jvm跑</li></ul><ol start=20><li>從來沒有人說過Java的Class名字必須和其檔名相同。但public class的名字必須和檔名相同</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// OtherThing.java</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Something</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>something_to_do</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Do something ...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol start=21><li>Math.round(-1.5)</li></ol><ul><li>-1</li></ul><ol start=22><li>Thread state</li></ol><ul><li>start</li><li>ready</li><li>running</li><li>blocked</li><li>destroied</li></ul><ol start=23><li>如何deepcopy</li></ol><ul><li>Cloneable</li><li>Serializable</li></ul><ol start=24><li>Inversion of Control</li></ol><ul><li>原本是Logic去控制資料</li><li>有些資料其實是一起的，所以可以根據我們這邊的需求去生<ul><li>但也可以讓外面給 (Dependency Injection)<ul><li>透過setter</li><li>透過interface (我們只call method)</li><li>透過constructor</li><li>再跑logic之前讓資料就定位</li></ul></li><li>之後就是有一堆framework，想描述(變成像prolog那樣)給參數這行為就有了這個詞</li><li>這到最後可以不管程式實作了!! 它本身就是程式阿</li></ul></li></ul><h2 id=servlet>Servlet<a hidden class=anchor aria-hidden=true href=#servlet>#</a></h2><ol><li>cgi與servlet差在</li></ol><ul><li>cgi是每次req都fork一個process去處理，之後回到parent</li><li>servlet是會初始化只後一直處理req，等server不要時再回收</li></ul><ol start=2><li>AOP</li></ol><ul><li>有些與logic無關的code但要與logic放在一起的code(log)，Aspect</li><li>如果想分開就是要留callback的點，Joinpoint</li></ul><ol start=3><li>B+ tree</li></ol><ul><li>每一個node代表一個range，下面的ptr指到符合範圍的node</li></ul><h2 id=design-pattern>design pattern<a hidden class=anchor aria-hidden=true href=#design-pattern>#</a></h2><p>把object當成lambda就可以處理很多問題</p><p>之後就是用</p><ul><li>interface</li><li>繼承</li><li>包成object
去傳需要的邏輯</li></ul><p>剩下就visitor是pattern match</p><p><a href=https://littlebees.github.io/2020/7/design-pattern-note/>design pattern隨便筆記</a></p><h2 id=正規化>正規化<a hidden class=anchor aria-hidden=true href=#正規化>#</a></h2><p>讓table好join</p><ol><li>把array轉90度</li><li>讓整個主鍵可以filter出所有欄目 (course ID, student ID去濾可以找出grade與student name，name要被割出去)</li><li>割出去的項目只能用主鍵去濾資料</li></ol><p><a href=/2020/7/db-nf-note>note</a></p><h2 id=gc>GC<a hidden class=anchor aria-hidden=true href=#gc>#</a></h2><p>每個obj都是一個node，所以每個都有</p><ol><li>indegree</li></ol><ul><li>當indegree為0就被回收</li><li>如果有loop就不會被回收</li></ul><ol start=2><li>edge</li></ol><ul><li>從root做traversal，有走到就是ok</li><li>會產生記憶體斷片、物件多會跑很久(stop the world)<ul><li>物件多會跑很久: 區分世代使用不同algo</li><li>產生記憶體斷片: 一次只用整條記憶體的一半，要換時就把剩下都copy去另一邊</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/08/leetcode-1339-maximum-product-of-splitted-binary-tree/><span class=title>« Prev</span><br><span>leetcode-1339 - Maximum Product of Splitted Binary Tree</span>
</a><a class=next href=https://littlebees.github.io/2021/08/%E5%88%AAlinked-list%E7%9A%84%E5%A5%BD%E5%81%9A%E6%B3%95/><span class=title>Next »</span><br><span>刪linked list的好做法??</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>