<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>bpf使用筆記 | 記事本</title>
<meta name=keywords content="Performance"><meta name=description content="動機
systemtap看完後就是bpf了"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/07/bpf%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/07/bpf%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="bpf使用筆記"><meta property="og:description" content="動機
systemtap看完後就是bpf了"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/07/bpf%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-01T01:13:27+00:00"><meta property="article:modified_time" content="2021-07-01T01:13:27+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="bpf使用筆記"><meta name=twitter:description content="動機
systemtap看完後就是bpf了"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"bpf使用筆記","item":"https://littlebees.github.io/2021/07/bpf%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"bpf使用筆記","name":"bpf使用筆記","description":"動機 systemtap看完後就是bpf了\n","keywords":["Performance"],"articleBody":"動機 systemtap看完後就是bpf了\nebpf 放一台vm在kernel中當內線 跑verfier與自己的bytecode 所以會有自己的IR，過llvm轉成bytecode 詳細看BPF Internals (eBPF) 用處 trace, profile, observe, monitor 這裡就與systemtap很像 但是現在bpf的code其實不好上手 bpftrace整體與systemtap很像，但 不能透過probe去找對應的source code 沒有embed c, context var bcc是幫助開發者寫bpf的工具，但 現在在從bcc c/python轉移到libbpf 十分年輕，看commit時間，一年多一點點開始 但libbpf有 BPF CO-RE: bpf的目標，邊一次到處跑 BTF: 進化的DWARF，同時也有bpf的執行檔資訊 libbpf: 很像compiler+linker+bootstraper 生vmlinux.h: 不用裝linux-header了，也不用include了 配合BTF與bpf的ELF設定需要的object與load bpf程式 提供處理kernel版本差異的方法 extern Kconfig: extern u32 CONFIG_HZ __kconfig; struct flavors: 讓relocate時用本機的struct libbpf的寫法十分神奇 security, network 可以鎖syscall，在到network stack之前就過濾封包 bpf程式架構 map 類似mmap, kmap的map，大塊的可以與userspace溝通的記憶體，拿來放一些資料結構 helper bpf不放行直接碰kernel的變數，所以要用這個，當成syscall perf的ring buf bpf把資料傳回userspace的手段 bytecode probe+action how to use 我只想做monitor bcc提供的工具 bpftrace去跑script 我想開發bpf 看完前面兩個，再看libbpf bcc的工具 出事的60秒quick check uptime dmesg -T | tail vmstat 1 mpstat -P ALL 1 pidstat 1 iostat -xz 1 free -m sar -n DEV 1 sar -n TCP,ETCP 1 top 用bcc的工具 execsnoop: 看exec的syscal，會列ret ext4slower: 把file io太慢的proc列出來 biolatency: block io in hist gethostlatency: call getaddrinfo/gethostbyname的延遲，抓DNS延遲 runqlat: scheduler latency in hist biosnoop: 列proc使用block io的狀況，會列latency cachestat: 列cache成功與失敗的比率，每秒一筆 tcpconnect: 列用tcp connect的程式(不用煩惱netstat有沒有裝了) tcpaccept: 列用tcp accept的程式 profile: perf opensnoop: 看open的syscall，會列err 實際上的demo 完整工具列表 bcc github上的工具列表\nbpftrace probe[,probe,...] /filter/ { action; ... } probe用: systemtap用. filter是optional systemtap是用if自己做 probe: 括號是縮寫 BEGID, END dynamic tracing kernel space kprobe(k) kprobe:function_name[+offset] 會有args: arg0, arg1, … 如果arg都放在stack sarg0, sarg1, … kretprobe(kr) kretprobe:function_name retval kfunc \u0026 kretfunc kfunc:function \u0026 kretfunc:function 會有args: args-\u003ename kretfunc會多retval 可以用bpftrace -lv去看有什麼參數與函數 user space uprobe(u) uprobe:library_name:function_name[+offset] uprobe:library_name:address 會有args: arg0, arg1, … uretprobe(ur) uretprobe:library_name:function_name retval static tracing kernel space tracepoint(t) tracepoint:name user space usdt(U) usdt:binary_path:probe_name usdt:binary_path:[probe_namespace]:probe_name usdt:library_path:probe_name usdt:library_path:[probe_namespace]:probe_name else profile(p): perf的抽樣 profile:hz:rate 單位: hz, s, ms, us rate: 次數 software(s): perf的software事件 man perf_event_open software:event_name:count or software:event_name event cpu-clock(cpu) task-clock page-faults(faults) context-switches(cs) cpu-migrations minor-faults major-faults alignment-faults emulation-faults dummy bpf-output hardware(h): perf的hardware事件 man perf_event_open hardware:event_name:count or hardware:event_name event cpu-cycles(cycles) instructions cache-references cache-misses branch-instructions(branchs) branch-misses bus-cycles frontend-stalls backend-stalls ref-cycles interval(i): timer interval:ms:rate 單位: hz, s, ms, us rate: 次數 可以在某些probe用wildcard，k:vfs_* 還有看mem與probe的iterator在這裡 action buildin function printf signal … 直接看這裡 map function 語法真的很神奇 @name = map-function(val) 我是這樣想: @name = map-function(@name, val) map function會去讀map與val產生新的map count hist min, max 剩下這裡 buildin var pid, tid, uid, gid, cpid(child pid) kstack, ustack: kernel, user stack $1,$2…: bpftrace的參數 rand: 就是rand cpu, cgroup: cpu id, cgroup id comm: proc name func: function name probe: probe name nssec, elapsed: timestamp in ns, bpftrace的運行時間 controll structrue if (expr) {} else {} (expr) ? expr1 : expr2; unroll (expr) {} (loop) comment: //, /**/ var local: $name global: @name 這個其實就是map，拿來放置大物件的 buildin: name 沒有struct? 自己寫 include(同c) 生BTF cast(同c) data structrue array(hash) @associative_array_name[key_name, key_name2, ...] tuple $t = (expr1, expr2, ...) $t.1; $t.2; libbpf 參考資料在? 範例在兩個地方\nlibbpf-bootstrap bcc的libbpf-tools 有說明文\nBCC to libbpf conversion guide 雖說是BCC到libbpf，但裡面涵蓋寫libbpf需要注意的點 Tips and Tricks for Writing Linux BPF Applications with libbpf 誠如標題所示，就是tip與trick Building BPF applications with libbpf-bootstrap libbpf-bootstrap講解 主角，libbpf的code，在這裡\n建議從libbpf-bootstrap開始看，下面用examples/c/krpobe來看，看看每個用libbpf都會有的東西\n兩個code: userspace \u0026 bpf 現在程式分成userspace的kprobe.c與bpf的kprobe.bpf.c\nkprobe.c: 會做跑bpf的前置工作與等bpf完成 kprobe.bpf.c: 實際跑bpf probe的地方\nuserspace header有#include \"kprobe.skel.h\" libbpf生的header，裡面有與bpf溝通需要的東西與libbpf的API\nlibbpf_print_fn 與 bump_memlock_rlimit libbpf_print_fn就是printk之類的，可以在裡面設定需要多燒level才print\nbump_memlock_rlimit是設定bpf的mem用量\n載入到執行到移除 bootstrap_bpf__open 把bpf的code讀進來 拿到struct bootstrap_bpf 可以改裡面的參數 bootstrap_bpf__load 開始創map，把code丟到verifier bootstrap_bpf__attach 開始跑 之後就是看userspace要做什麼 bootstrap_bpf__destroy 把bpf停掉 bpf herder #include \"vmlinux.h\" /* all kernel types */ #include /* most used helpers: SEC, __always_inline, etc */ #include /* for BPF CO-RE helpers */ #include /* for getting kprobe arguments */ map struct { __uint(type, BPF_MAP_TYPE_HASH); __uint(max_entries, 8192); __type(key, pid_t); __type(value, u64); } exec_start SEC(\".maps\"); 有關的type在bpf.h 但struct要放什麼就要去找範例了 要加SEC(\".maps\") probe SEC(\"tp/sched/sched_process_exec\") int handle_exec(struct trace_event_raw_sched_process_exec *ctx) { //... return 0; } 在SEC放probe 不同probe的函數宣告方式不一樣，像kprobe要BPF_KPROBE(...)這macro 找範例去對，現在還沒看到像樣的文件 helper task = (struct task_struct *)bpf_get_current_task(); bpf_get_current_comm(\u0026e-\u003ecomm, sizeof(e-\u003ecomm)); bpf_probe_read_str(\u0026e-\u003efilename, sizeof(e-\u003efilename), (void *)ctx + fname_off); 這些helper都在bpf_helper_defs.h\nRef bpftrace Cheat Sheet bpftrace Reference Guide BPF binaries: BTF, CO-RE, and the future of BPF perf tools BPF Internals (eBPF) BPF Portability and CO-RE\n","wordCount":"547","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-07-01T01:13:27Z","dateModified":"2021-07-01T01:13:27Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/07/bpf%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">bpf使用筆記</h1><div class=post-meta><span title='2021-07-01 01:13:27 +0000 UTC'>July 1, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#ebpf aria-label=ebpf>ebpf</a></li><li><a href=#how-to-use aria-label="how to use">how to use</a></li><li><a href=#bcc%e7%9a%84%e5%b7%a5%e5%85%b7 aria-label=bcc的工具>bcc的工具</a><ul><li><a href=#%e5%ae%8c%e6%95%b4%e5%b7%a5%e5%85%b7%e5%88%97%e8%a1%a8 aria-label=完整工具列表>完整工具列表</a></li></ul></li><li><a href=#bpftrace aria-label=bpftrace>bpftrace</a></li><li><a href=#libbpf aria-label=libbpf>libbpf</a><ul><li><a href=#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99%e5%9c%a8 aria-label=參考資料在?>參考資料在?</a></li><li><a href=#%e5%85%a9%e5%80%8bcode-userspace--bpf aria-label="兩個code: userspace & bpf">兩個code: userspace & bpf</a></li><li><a href=#userspace aria-label=userspace>userspace</a><ul><li><a href=#header%e6%9c%89include-kprobeskelh aria-label='header有#include "kprobe.skel.h"'>header有#include "kprobe.skel.h"</a></li><li><a href=#libbpf_print_fn-%e8%88%87-bump_memlock_rlimit aria-label="libbpf_print_fn 與 bump_memlock_rlimit">libbpf_print_fn 與 bump_memlock_rlimit</a></li><li><a href=#%e8%bc%89%e5%85%a5%e5%88%b0%e5%9f%b7%e8%a1%8c%e5%88%b0%e7%a7%bb%e9%99%a4 aria-label=載入到執行到移除>載入到執行到移除</a></li></ul></li><li><a href=#bpf aria-label=bpf>bpf</a><ul><li><a href=#herder aria-label=herder>herder</a></li><li><a href=#map aria-label=map>map</a></li><li><a href=#probe aria-label=probe>probe</a></li><li><a href=#helper aria-label=helper>helper</a></li></ul></li></ul></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>systemtap看完後就是bpf了</p><h2 id=ebpf>ebpf<a hidden class=anchor aria-hidden=true href=#ebpf>#</a></h2><ul><li>放一台vm在kernel中當內線<ul><li>跑verfier與自己的bytecode</li><li>所以會有自己的IR，過llvm轉成bytecode</li><li>詳細看<a href=https://www.slideshare.net/brendangregg/bpf-internals-ebpf>BPF Internals (eBPF)</a></li></ul></li><li>用處<ul><li>trace, profile, observe, monitor<ul><li>這裡就與systemtap很像</li><li>但是現在bpf的code其實不好上手<ul><li>bpftrace整體與systemtap很像，但<ul><li>不能透過probe去找對應的source code</li><li>沒有embed c, context var</li></ul></li><li>bcc是幫助開發者寫bpf的工具，但<ul><li>現在在從bcc c/python轉移到libbpf<ul><li>十分年輕，看commit時間，一年多一點點開始</li><li>但libbpf有<ul><li>BPF CO-RE: bpf的目標，邊一次到處跑<ul><li>BTF: 進化的DWARF，同時也有bpf的執行檔資訊</li><li>libbpf: 很像compiler+linker+bootstraper<ul><li>生vmlinux.h: 不用裝linux-header了，也不用include了</li><li>配合BTF與bpf的ELF設定需要的object與load bpf程式</li><li>提供處理kernel版本差異的方法<ul><li>extern Kconfig: <code>extern u32 CONFIG_HZ __kconfig;</code></li><li>struct flavors: 讓relocate時用本機的struct</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>libbpf的寫法十分神奇</li></ul></li></ul></li></ul></li><li>security, network<ul><li>可以鎖syscall，在到network stack之前就過濾封包</li></ul></li></ul></li><li>bpf程式架構<ul><li>map<ul><li>類似mmap, kmap的map，大塊的可以與userspace溝通的記憶體，拿來放一些資料結構</li></ul></li><li>helper<ul><li>bpf不放行直接碰kernel的變數，所以要用這個，當成syscall</li></ul></li><li>perf的ring buf<ul><li>bpf把資料傳回userspace的手段</li></ul></li><li>bytecode</li><li>probe+action</li></ul></li></ul><h2 id=how-to-use>how to use<a hidden class=anchor aria-hidden=true href=#how-to-use>#</a></h2><ul><li>我只想做monitor<ul><li>bcc提供的工具</li><li>bpftrace去跑script</li></ul></li><li>我想開發bpf<ul><li>看完前面兩個，再看libbpf</li></ul></li></ul><h2 id=bcc的工具>bcc的工具<a hidden class=anchor aria-hidden=true href=#bcc的工具>#</a></h2><ul><li>出事的60秒quick check<ul><li>uptime</li><li>dmesg -T | tail</li><li>vmstat 1</li><li>mpstat -P ALL 1</li><li>pidstat 1</li><li>iostat -xz 1</li><li>free -m</li><li>sar -n DEV 1</li><li>sar -n TCP,ETCP 1</li><li>top</li></ul></li><li>用bcc的工具<ul><li>execsnoop: 看exec的syscal，會列ret</li><li>ext4slower: 把file io太慢的proc列出來</li><li>biolatency: block io in hist</li><li>gethostlatency: call getaddrinfo/gethostbyname的延遲，抓DNS延遲</li><li>runqlat: scheduler latency in hist</li><li>biosnoop: 列proc使用block io的狀況，會列latency</li><li>cachestat: 列cache成功與失敗的比率，每秒一筆</li><li>tcpconnect: 列用tcp connect的程式(不用煩惱netstat有沒有裝了)</li><li>tcpaccept: 列用tcp accept的程式</li><li>profile: perf</li><li>opensnoop: 看open的syscall，會列err</li><li>實際上的<a href=https://www.slideshare.net/brendangregg/velocity-2017-performance-analysis-superpowers-with-linux-ebpf>demo</a></li></ul></li></ul><h3 id=完整工具列表>完整工具列表<a hidden class=anchor aria-hidden=true href=#完整工具列表>#</a></h3><p><img loading=lazy src=http://www.brendangregg.com/blog/images/2019/bpf_performance_tools.png alt="bcc tracing tools"></p><p><a href=https://github.com/iovisor/bcc#tools>bcc github上的工具列表</a></p><h2 id=bpftrace>bpftrace<a hidden class=anchor aria-hidden=true href=#bpftrace>#</a></h2><ul><li><code>probe[,probe,...] /filter/ { action; ... }</code><ul><li>probe用<code>:</code><ul><li>systemtap用<code>.</code></li></ul></li><li>filter是optional<ul><li>systemtap是用if自己做</li></ul></li></ul></li><li>probe: 括號是縮寫<ul><li><code>BEGID</code>, <code>END</code></li><li>dynamic tracing<ul><li>kernel space<ul><li><code>kprobe(k)</code><ul><li><code>kprobe:function_name[+offset]</code><ul><li>會有args: <code>arg0</code>, <code>arg1</code>, &mldr;<ul><li>如果arg都放在stack<ul><li><code>sarg0</code>, <code>sarg1</code>, &mldr;</li></ul></li></ul></li></ul></li></ul></li><li><code>kretprobe(kr)</code><ul><li><code>kretprobe:function_name</code><ul><li><code>retval</code></li></ul></li></ul></li><li><code>kfunc</code> & <code>kretfunc</code><ul><li><code>kfunc:function</code> & <code>kretfunc:function</code></li><li>會有args: <code>args->name</code></li><li>kretfunc會多<code>retval</code></li><li>可以用<code>bpftrace -lv</code>去看有什麼參數與函數</li></ul></li></ul></li><li>user space<ul><li><code>uprobe(u)</code><ul><li><code>uprobe:library_name:function_name[+offset]</code></li><li><code>uprobe:library_name:address</code><ul><li>會有args: <code>arg0</code>, <code>arg1</code>, &mldr;</li></ul></li></ul></li><li><code>uretprobe(ur)</code><ul><li><code>uretprobe:library_name:function_name</code><ul><li><code>retval</code></li></ul></li></ul></li></ul></li></ul></li><li>static tracing<ul><li>kernel space<ul><li><code>tracepoint(t)</code><ul><li><code>tracepoint:name</code></li></ul></li></ul></li><li>user space<ul><li><code>usdt(U)</code><ul><li><code>usdt:binary_path:probe_name</code></li><li><code>usdt:binary_path:[probe_namespace]:probe_name</code></li><li><code>usdt:library_path:probe_name</code></li><li><code>usdt:library_path:[probe_namespace]:probe_name</code></li></ul></li></ul></li></ul></li><li>else<ul><li><code>profile(p)</code>: perf的抽樣<ul><li><code>profile:hz:rate</code><ul><li>單位: hz, s, ms, us</li><li>rate: 次數</li></ul></li></ul></li><li><code>software(s)</code>: perf的software事件 <code>man perf_event_open</code><ul><li><code>software:event_name:count</code> or <code>software:event_name</code></li><li>event<ul><li><code>cpu-clock(cpu)</code></li><li><code>task-clock</code></li><li><code>page-faults(faults)</code></li><li><code>context-switches(cs)</code></li><li><code>cpu-migrations</code></li><li><code>minor-faults</code></li><li><code>major-faults</code></li><li><code>alignment-faults</code></li><li><code>emulation-faults</code></li><li><code>dummy</code></li><li><code>bpf-output</code></li></ul></li></ul></li><li><code>hardware(h)</code>: perf的hardware事件 <code>man perf_event_open</code><ul><li><code>hardware:event_name:count</code> or <code>hardware:event_name</code></li><li>event<ul><li><code>cpu-cycles(cycles)</code></li><li><code>instructions</code></li><li><code>cache-references</code></li><li><code>cache-misses</code></li><li><code>branch-instructions(branchs)</code></li><li><code>branch-misses</code></li><li><code>bus-cycles</code></li><li><code>frontend-stalls</code></li><li><code>backend-stalls</code></li><li><code>ref-cycles</code></li></ul></li></ul></li><li><code>interval(i)</code>: timer<ul><li><code>interval:ms:rate</code><ul><li>單位: hz, s, ms, us</li><li>rate: 次數</li></ul></li></ul></li></ul></li><li>可以在某些probe用wildcard，<code>k:vfs_*</code></li><li>還有看mem與probe的iterator在<a href=https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md>這裡</a></li></ul></li><li>action<ul><li>buildin function<ul><li>printf</li><li>signal</li><li>&mldr;</li><li>直接看<a href=https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#1-builtins-1>這裡</a></li></ul></li><li>map function<ul><li>語法真的很神奇<ul><li><code>@name = map-function(val)</code><ul><li>我是這樣想: <code>@name = map-function(@name, val)</code><ul><li>map function會去讀map與val產生新的map</li></ul></li></ul></li></ul></li><li>count</li><li>hist</li><li>min, max</li><li>剩下<a href=https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#map-functions>這裡</a></li></ul></li><li>buildin var<ul><li>pid, tid, uid, gid, cpid(child pid)</li><li>kstack, ustack: kernel, user stack</li><li><code>$1</code>,<code>$2</code>&mldr;: bpftrace的參數</li><li>rand: 就是rand</li><li>cpu, cgroup: cpu id, cgroup id</li><li>comm: proc name</li><li>func: function name</li><li>probe: probe name</li><li>nssec, elapsed: timestamp in ns, bpftrace的運行時間</li></ul></li><li>controll structrue<ul><li><code>if (expr) {} else {}</code><ul><li><code>(expr) ? expr1 : expr2;</code></li></ul></li><li><code>unroll (expr) {}</code> (loop)</li><li>comment: <code>//</code>, <code>/**/</code></li></ul></li></ul></li><li>var<ul><li>local: <code>$name</code></li><li>global: <code>@name</code><ul><li>這個其實就是map，拿來放置大物件的</li></ul></li><li>buildin: <code>name</code></li><li>沒有struct?<ul><li>自己寫</li><li>include(同c)</li><li>生BTF</li></ul></li><li>cast(同c)</li></ul></li><li>data structrue<ul><li>array(hash)<ul><li><code>@associative_array_name[key_name, key_name2, ...]</code></li></ul></li><li>tuple<ul><li><code>$t = (expr1, expr2, ...)</code></li><li><code>$t.1; $t.2;</code></li></ul></li></ul></li></ul><h2 id=libbpf>libbpf<a hidden class=anchor aria-hidden=true href=#libbpf>#</a></h2><h3 id=參考資料在>參考資料在?<a hidden class=anchor aria-hidden=true href=#參考資料在>#</a></h3><p>範例在兩個地方</p><ol><li><a href=https://github.com/libbpf/libbpf-bootstrap>libbpf-bootstrap</a></li><li><a href=https://github.com/iovisor/bcc/tree/master/libbpf-tools>bcc的libbpf-tools</a></li></ol><p>有說明文</p><ul><li><a href=https://nakryiko.com/posts/bcc-to-libbpf-howto-guide>BCC to libbpf conversion guide</a><ul><li>雖說是BCC到libbpf，但裡面涵蓋寫libbpf需要注意的點</li></ul></li><li><a href=https://en.pingcap.com/blog/tips-and-tricks-for-writing-linux-bpf-applications-with-libbpf>Tips and Tricks for Writing Linux BPF Applications with libbpf</a><ul><li>誠如標題所示，就是tip與trick</li></ul></li><li><a href=https://nakryiko.com/posts/libbpf-bootstrap>Building BPF applications with libbpf-bootstrap</a><ul><li>libbpf-bootstrap講解</li></ul></li></ul><p>主角，libbpf的code，在<a href=https://github.com/libbpf/libbpf>這裡</a></p><p>建議從<a href=https://github.com/libbpf/libbpf-bootstrap>libbpf-bootstrap</a>開始看，下面用examples/c/krpobe來看，看看每個用libbpf都會有的東西</p><h3 id=兩個code-userspace--bpf>兩個code: userspace & bpf<a hidden class=anchor aria-hidden=true href=#兩個code-userspace--bpf>#</a></h3><p>現在程式分成userspace的<code>kprobe.c</code>與bpf的<code>kprobe.bpf.c</code></p><p><code>kprobe.c</code>: 會做跑bpf的前置工作與等bpf完成
<code>kprobe.bpf.c</code>: 實際跑bpf probe的地方</p><h3 id=userspace>userspace<a hidden class=anchor aria-hidden=true href=#userspace>#</a></h3><h4 id=header有include-kprobeskelh>header有<code>#include "kprobe.skel.h"</code><a hidden class=anchor aria-hidden=true href=#header有include-kprobeskelh>#</a></h4><p>libbpf生的header，裡面有與bpf溝通需要的東西與libbpf的API</p><h4 id=libbpf_print_fn-與-bump_memlock_rlimit>libbpf_print_fn 與 bump_memlock_rlimit<a hidden class=anchor aria-hidden=true href=#libbpf_print_fn-與-bump_memlock_rlimit>#</a></h4><p>libbpf_print_fn就是printk之類的，可以在裡面設定需要多燒level才print</p><p>bump_memlock_rlimit是設定bpf的mem用量</p><h4 id=載入到執行到移除>載入到執行到移除<a hidden class=anchor aria-hidden=true href=#載入到執行到移除>#</a></h4><ol><li>bootstrap_bpf__open</li></ol><ul><li>把bpf的code讀進來</li><li>拿到<code>struct bootstrap_bpf</code><ul><li>可以改裡面的參數</li></ul></li></ul><ol start=2><li>bootstrap_bpf__load</li></ol><ul><li>開始創map，把code丟到verifier</li></ul><ol start=3><li>bootstrap_bpf__attach</li></ol><ul><li>開始跑</li><li>之後就是看userspace要做什麼</li></ul><ol start=4><li>bootstrap_bpf__destroy</li></ol><ul><li>把bpf停掉</li></ul><h3 id=bpf>bpf<a hidden class=anchor aria-hidden=true href=#bpf>#</a></h3><h4 id=herder>herder<a hidden class=anchor aria-hidden=true href=#herder>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;vmlinux.h&#34;               /* all kernel types */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;bpf/bpf_helpers.h&gt;       /* most used helpers: SEC, __always_inline, etc */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;bpf/bpf_core_read.h&gt;     /* for BPF CO-RE helpers */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;bpf/bpf_tracing.h&gt;       /* for getting kprobe arguments */</span><span class=cp>
</span></span></span></code></pre></div><h4 id=map>map<a hidden class=anchor aria-hidden=true href=#map>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_HASH</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=mi>8192</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>__type</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=kt>pid_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>__type</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>u64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>exec_start</span> <span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>
</span></span></code></pre></div><ol><li>有關的type在<a href=https://github.com/libbpf/libbpf/blob/master/include/uapi/linux/bpf.h>bpf.h</a></li></ol><ul><li>但struct要放什麼就要去找範例了</li></ul><ol start=2><li>要加<code>SEC(".maps")</code></li></ol><h4 id=probe>probe<a hidden class=anchor aria-hidden=true href=#probe>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SEC</span><span class=p>(</span><span class=s>&#34;tp/sched/sched_process_exec&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>handle_exec</span><span class=p>(</span><span class=k>struct</span> <span class=nc>trace_event_raw_sched_process_exec</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>在<code>SEC</code>放probe</li><li>不同probe的函數宣告方式不一樣，像kprobe要<code>BPF_KPROBE(...)</code>這macro</li></ol><ul><li>找範例去對，現在還沒看到像樣的文件</li></ul><h4 id=helper>helper<a hidden class=anchor aria-hidden=true href=#helper>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>task</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>task_struct</span> <span class=o>*</span><span class=p>)</span><span class=n>bpf_get_current_task</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>bpf_get_current_comm</span><span class=p>(</span><span class=o>&amp;</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>comm</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>comm</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>bpf_probe_read_str</span><span class=p>(</span><span class=o>&amp;</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>filename</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>filename</span><span class=p>),</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>ctx</span> <span class=o>+</span> <span class=n>fname_off</span><span class=p>);</span>
</span></span></code></pre></div><p>這些helper都在<a href=https://github.com/libbpf/libbpf/blob/master/src/bpf_helper_defs.h>bpf_helper_defs.h</a></p><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=http://www.brendangregg.com/BPF/bpftrace-cheat-sheet.html>bpftrace Cheat Sheet</a>
<a href=https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md>bpftrace Reference Guide</a>
<a href=http://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html>BPF binaries: BTF, CO-RE, and the future of BPF perf tools</a>
<a href=https://www.slideshare.net/brendangregg/bpf-internals-ebpf>BPF Internals (eBPF)</a>
<a href=https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html>BPF Portability and CO-RE</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/performance/>Performance</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/07/gdb%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/><span class=title>« Prev</span><br><span>gdb使用筆記</span>
</a><a class=next href=https://littlebees.github.io/2021/06/flamegraph%E7%AD%86%E8%A8%98/><span class=title>Next »</span><br><span>flamegraph筆記</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>