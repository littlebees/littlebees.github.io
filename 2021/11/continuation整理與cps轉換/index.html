<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>continuation整理與CPS轉換 | 記事本</title>
<meta name=keywords content="Lisp"><meta name=description content="動機
整理continuation與CPS轉換"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/11/continuation%E6%95%B4%E7%90%86%E8%88%87cps%E8%BD%89%E6%8F%9B/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/11/continuation%E6%95%B4%E7%90%86%E8%88%87cps%E8%BD%89%E6%8F%9B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="continuation整理與CPS轉換"><meta property="og:description" content="動機
整理continuation與CPS轉換"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/11/continuation%E6%95%B4%E7%90%86%E8%88%87cps%E8%BD%89%E6%8F%9B/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-02T00:24:06+00:00"><meta property="article:modified_time" content="2021-11-02T00:24:06+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="continuation整理與CPS轉換"><meta name=twitter:description content="動機
整理continuation與CPS轉換"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"continuation整理與CPS轉換","item":"https://littlebees.github.io/2021/11/continuation%E6%95%B4%E7%90%86%E8%88%87cps%E8%BD%89%E6%8F%9B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"continuation整理與CPS轉換","name":"continuation整理與CPS轉換","description":"動機 整理continuation與CPS轉換\n","keywords":["Lisp"],"articleBody":"動機 整理continuation與CPS轉換\n用法 cont可以當成一種很強的return或是goto，但是可以當成函數用\n(let ((val (callcc (lambda (k) (k k))))) (set! cont k) (display k)) (cont 10) (cont 20) 只要調用cont就會回去當初執行callcc的那一行，所以可以用它來跳來跳去\n應用 dynamic-wind 類似prehook與posthook，只是有在裡面執行或是要到裡面，就一定會跑prehook與posthook\n下面是其中一種實作，stack放(prehook . afterhook)，之後就是對callcc動手腳，只要有人call就去跑整個stack\n(define *here* (list #f)) (define origin-callcc call-with-current-continuation) (define (call-with-current-continuation proc) (let ((here *here*)) (origin-callcc (lambda (cont) (proc (lambda results (reroot! here) ;; 包一層 (apply cont results))))))) (define (dynamic-wind before during after) (let ((here *here*)) (reroot! (cons (cons before after) here)) (call-with-values during (lambda results (reroot! here) (apply values results))))) (define (reroot! there) (if (not (eq? *here* there)) (begin (reroot! (cdr there)) (let ((before (caar there)) (after (cdar there))) (set-car! *here* (cons after before)) ;; reverse before after, so next time after will be invoke!! (set-cdr! *here* there) (set-car! there #f) (set-cdr! there '()) (set! *here* there) (before))))) exception 一個stack放fail時要跳回去那邊的cont\ndynamic-wind是確保，cont被call時一定會pop stack 從cont進去時會把stack建回去 (在exception不需要就是了)\n(define-syntax try (syntax-rules (catch) ((_ exp ... catch proc) ; =\u003e (let ((cc (current-continuation))) (cond ((procedure? cc) (dynamic-wind (lambda () (set! exception-stack (cons cc exception-stack))) (lambda () exp ...) (lambda () (set! exception-stack (cdr exception-stack))))) ((pair? cc) (proc (cadr cc)))))))) (define (throw exception-value) (let ((handler (car exception-stack))) (handler (list 'exception exception-value)))) (try (try (throw 'foo) catch (lambda (exn) (display \"got inner exception: \") (display exn) (newline) (throw 'bar))) catch (lambda (exn) (display \"got outer exception: \") (display exn) (newline))) non-determing computing 一個stack放fail時要跳回去那邊的cont\n(define (current-continuation) (call-with-current-continuation (lambda (cc) (cc cc)))) ; fail-stack : list[continuation] (define fail-stack '()) ; fail : -\u003e ... (define (fail) (if (not (pair? fail-stack)) (error \"back-tracking stack exhausted!\") (begin (let ((back-track-point (car fail-stack))) (set! fail-stack (cdr fail-stack)) (back-track-point back-track-point))))) ; amb : list[a] -\u003e a (define (amb choices) (let ((cc (current-continuation))) (cond ((null? choices) (fail)) ((pair? choices) (let ((choice (car choices))) (set! choices (cdr choices)) (set! fail-stack (cons cc fail-stack)) choice))))) (define (assert condition) (or condition (fail))) ; The following prints (4 3 5) (let ((a (amb (list 1 2 3 4 5 6 7))) (b (amb (list 1 2 3 4 5 6 7))) (c (amb (list 1 2 3 4 5 6 7)))) (assert (= (* c c) (+ (* a a) (* b b))))) generator 一個ptr指向目前generator停下來的位置，另外為了讓generator好看，所以把生generator的cont交給make-yield\n所以每次yield就會把val與cont丟回去\n(define (current-continuation) (call-with-current-continuation (lambda (cc) (cc cc)))) ; void : -\u003e void (define (void) (if #f #t)) ; tree-iterator : tree -\u003e generator (define (tree-iterator tree) (lambda (yield) (define (walk tree) (if (not (pair? tree)) (yield tree) (begin (walk (car tree)) (walk (cdr tree))))) (walk tree))) ; make-yield : continuation -\u003e (value -\u003e ...) (define (make-yield for-cc) (lambda (value) (let ((cc (current-continuation))) (if (procedure? cc) (for-cc (cons cc value)) (void))))) ; (for v in generator body) will execute body ; with v bound to successive values supplied ; by generator. (define-syntax for (syntax-rules (in) ((_ v in iterator body ...) ; =\u003e (let ((iterator-cont #f)) (letrec ((loop (lambda () (let ((cc (current-continuation))) (if (procedure? cc) (if iterator-cont (iterator-cont (void)) (iterator (make-yield cc))) (let ((it-cont (car cc)) (it-val (cdr cc))) (set! iterator-cont it-cont) (let ((v it-val)) body ...) (loop))))))) (loop)))))) (for v in (tree-iterator '(3 . ( ( 4 . 5 ) . 6 ) )) (display v) (newline)) thread 前面是把cont塞到stack，這裡放到queue去!!\n; thread-queue : list[continuation] (define thread-queue '()) ; halt : continuation (define halt #f) ; void : -\u003e void (define (void) (if #f #t)) ; current-continuation : -\u003e continuation (define (current-continuation) (call-with-current-continuation (lambda (cc) (cc cc)))) ; spawn : (-\u003e anything) -\u003e void (define (spawn thunk) (let ((cc (current-continuation))) (if (procedure? cc) (set! thread-queue (append thread-queue (list cc))) (begin (thunk) (quit))))) ; yield : value -\u003e void (define (yield) (let ((cc (current-continuation))) (if (and (procedure? cc) (pair? thread-queue)) (let ((next-thread (car thread-queue))) (set! thread-queue (append (cdr thread-queue) (list cc))) (next-thread 'resume)) (void)))) ; quit : -\u003e ... (define (quit) (if (pair? thread-queue) (let ((next-thread (car thread-queue))) (set! thread-queue (cdr thread-queue)) (next-thread 'resume)) (halt))) ; start-threads : -\u003e ... (define (start-threads) (let ((cc (current-continuation))) (if cc (begin (set! halt (lambda () (cc #f))) (if (null? thread-queue) (void) (begin (let ((next-thread (car thread-queue))) (set! thread-queue (cdr thread-queue)) (next-thread 'resume))))) (void)))) ;; Example cooperatively threaded program (define counter 10) (define (make-thread-thunk name) (letrec ((loop (lambda () (if (\u003c counter 0) (quit)) (display \"in thread \") (display name) (display \"; counter = \") (display counter) (newline) (set! counter (- counter 1)) (yield) (loop)))) loop)) (spawn (make-thread-thunk 'a)) (spawn (make-thread-thunk 'b)) (spawn (make-thread-thunk 'c)) (start-threads) cont monad monad就是消滅傳遞參數的過程，下面來複習cont monad\n先基本的cps\n(define (id x) x) (define (fib1 n k) (if (\u003c= n 1) (k 1) (fib1 (- n 1) (lambda (v1) (fib1 (- n 2) (lambda (v2) (k (+ v1 v2)))))))) (writeln (fib1 5 id)) 把k往裡面推\n(define (fib2 n) (if (\u003c= n 1) (lambda (k) (k 1)) (lambda (k) ((fib2 (- n 1)) (lambda (v1) ((fib2 (- n 2)) (lambda (v2) (k (+ v1 v2))))))))) (writeln ((fib2 5) id)) 包一包，這裡可以注意到其實monad指的就是(lambda (k) ...)，只要被這個包起來就是monad!!\n(define (return val) (lambda (k) (k val))) (define (bind m f) (lambda (k) ((m f) k))) (define (fib3 n) (if (\u003c= n 1) (return 1) (bind (fib3 (- n 1)) (lambda (v1) (bind (fib3 (- n 2)) (lambda (v2) (return (+ v1 v2)))))))) (writeln ((fib3 5) id)) callcc就是\n擷取現在的cont，塞進去lambda 讓原本的程式用原本的cont繼續跑 (define (callcc f) (lambda (k) ((f (lambda (val) (lambda (_) (k val)))) k))) 邏輯上的關聯: callcc的type是? cont吃一個值之後就跳走，所以她的return val是什麼type? 沒關西，先當成P -\u003e Q\ncallcc是什麼type? 吃一個func，接回去原本的運算，注意到因為這裡的return val與cont吃得一樣，所以用一樣的type F -\u003e P\nF是什麼type? 吃一個cont，回傳某個值 (P -\u003e Q) -\u003e ?\n某個值是什麼type? 這func要接回去原本的運算，所以是P\n整個是((P -\u003e Q) -\u003e P) -\u003e P\n這就是Peirce’s law，如果把Q帶成bottom(Absurd)，就可以得到排中律!!\nCPS conversion 在cont monad看到monad怎麼把cont藏起來 接著就是怎麼把這個k自己生出來，下面都用untyped lambda calculus\n說老實話，其實是為了這個才把這篇打出來的\n另外如果有人說，學遞迴要用trace實際執行過程，直接丟這個給他看，看他怎麼trace 或是說遞迴可以轉成loop，也是丟這個，看他怎麼轉\nnaive 先是base case，變數與lambda，這裡base case叫atomic 變數直接回傳，lambda要幫他開一個洞，把值傳回去\n(define (M expr) (match expr [`(λ (,var) ,expr) (define $k (gensym '$k)) `(λ (,var ,$k) ,(T expr $k))] [(? symbol?) expr])) 剩下就是apply，每個都要先轉沒問題，那這裡要放什麼? 可以先看看簡單的case: (f v)且都是變數 最保險就是每個都要轉(過M)，\n((λ (a) ((λ (b) (k (a b))) ;; !! v)) f) 等等，現在a會多一個cont\n((λ (a) ((λ (b) (a b k)) ;; good v)) f) (define (T expr k) (match expr [`(λ . ,_) `(,k ,(M expr))] [(? symbol?) `(,k ,(M expr))] [`(,F ,V) (define $f (gensym '$f)) (define $v (gensym '$v)) (T F `(λ (,$f) ,(T V `(λ (,$v) (,$f ,$v ,k)))))])) (T '(g a) 'halt) 變成\n((λ ($f1445) ((λ ($e1446) ($f1445 $e1446 halt)) a)) g) high-order 最保險的方式可以work，但output有點長，為什麼不直接apply進去?\n怎麼直接apply進去? 我們不是有現成的函數嗎\n重新看T的base case，這裡如果可以直接apply函數，就可以把那坨去掉 換言之，我們原本在k傳的是symbol，但現在是racket的function，最後回傳symbol 所以先把quote拿掉\n(define (T expr k) (match expr [`(λ . ,_) (k (M expr))] [(? symbol?) (k (M expr))] [`(,F ,V) (T F (λ (f) (T V (λ (v) `(,f ,v ,k)))))])) ;; !! 等等，這裡k是racket的lambdaㄟ 這裡要是quote，所以要把(f v)的拉到原本的k去\n(define (T expr k) (match expr [`(λ . ,_) (k (M expr))] [(? symbol?) (k (M expr))] [`(,F ,V) (define $ret (gensym `$ret)) (define cont `(λ (,$ret) ,(k $ret))) (T F (λ (f) (T V (λ (v) `(,f ,v ,cont)))))])) 回來看M，會看到lambda的k要改，改成racket的lambda，最後回傳symbol\n(define (M expr) (match expr [`(λ (,var) ,expr) (define $k (gensym '$k)) `(λ (,var ,$k) ,(T expr (λ (ret) `(,$k ,ret))))] [(? symbol?) expr])) (T '(g a) (λ (ans) `(halt ,ans))) 變成\n(g a (λ ($rv1) (halt $rv1))) 少很多，但能不能更好，那個lambda很多餘\n混合 多的lambda來自T的cont，但又不能直接去掉，有什麼辦法? 回去看怎麼用的，不覺得很怪嗎，明明是轉symbol卻要寫lambda，有沒有辦法變成最初的方式去call\n所以第一層可以先抄第一種T\n(define (T-symbol expr k-symbol) (match expr [`(λ . ,_) `(,k-symbol (M expr))] [(? symbol?) `(,k-symbol (M expr))] [`(,F ,V) ... ])) 但apply用第二種T\n(define (T-symbol expr k-symbol) (match expr [`(λ . ,_) `(,k-symbol ,(M expr))] [(? symbol?) `(,k-symbol ,(M expr))] [`(,F ,V) (T-func F (λ (f) (T-func V (λ (v) `(,f ,v ,k-symbol)))))])) 再抄第二種T\n(define (T-func expr k-func) (match expr [`(λ . ,_) (k-func (M expr))] [(? symbol?) (k-func (M expr))] [`(,F ,V) (define $ret (gensym `$ret)) (define cont `(λ (,$ret) ,(k-func $ret))) (T-func F (λ (f) (T-func V (λ (v) `(,f ,v ,cont)))))])) M要抄第一種，觀察兩個T的base case，會看到(M expr)，最後都是要被展開成symbol 所以選都是symbol的第一種\n(define (M expr) (match expr [`(λ (,var) ,expr) (define $k (gensym '$k)) `(λ (,var ,$k) ,(T-symbol expr $k))] [(? symbol?) expr])) (T-symbol '(g a) 'halt) 變成\n(g a halt) partition 這個是為了還原calling stack而產生的\n要還原calling stack需要知道誰是caller，與之後衍生的 所以回去看生出cont的部分(幫lambda多一格的部分)\n(define (T-func expr k-func) (match expr [`(λ . ,_) (k-func (M expr))] [(? symbol?) (k-func (M expr))] [`(,F ,V) (define $ret (gensym `$ret)) ;; 1 (define cont `(λ (,$ret) ,(k-func $ret))) (T-func F (λ (f) (T-func V (λ (v) `(,f ,v ,cont)))))])) (define (M expr) (match expr [`(λ (,var) ,expr) (define $k (gensym '$k)) ;; 2 `(λ (,var ,$k) ,(T-symbol expr $k))] [(? symbol?) expr])) 1是起點，也就是apply；2是中間。 所以把1的symbol標成user, 2是cont\n(define (T-func expr k-func) (match expr [`(λ . ,_) (k-func (M expr))] [(? symbol?) (k-func (M expr))] [`(,F ,V) (define $ret (genusym `$ret)) ;; 1 (define cont `(λ (,$ret) ,(k-func $ret))) (T-func F (λ (f) (T-func V (λ (v) `(,f ,v ,cont)))))])) (define (M expr) (match expr [`(λ (,var) ,expr) (define $k (genksym '$k)) ;; 2 `(λ (,var ,$k) ,(T-symbol expr $k))] [(? symbol?) expr])) 在ref中還有scheme的轉換，但其實就是多了不定數量參數列的處理\nTODO delimit cont 據說cooperative的thread加macro可以變成preemptive! Closure conversion: How to compile lambda\nRef Continuations by example: Exceptions, time-traveling search, generators, threads, and coroutines Appendix: An implementation of dynamic-wind 如何解释 Lisp 中 call/cc 的概念？ 用call/cc合成所有的控制流结构 How to compile with continuations\n","wordCount":"1419","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-11-02T00:24:06Z","dateModified":"2021-11-02T00:24:06Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/11/continuation%E6%95%B4%E7%90%86%E8%88%87cps%E8%BD%89%E6%8F%9B/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">continuation整理與CPS轉換</h1><div class=post-meta><span title='2021-11-02 00:24:06 +0000 UTC'>November 2, 2021</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e7%94%a8%e6%b3%95 aria-label=用法>用法</a></li><li><a href=#%e6%87%89%e7%94%a8 aria-label=應用>應用</a><ul><li><a href=#dynamic-wind aria-label=dynamic-wind>dynamic-wind</a></li><li><a href=#exception aria-label=exception>exception</a></li><li><a href=#non-determing-computing aria-label="non-determing computing">non-determing computing</a></li><li><a href=#generator aria-label=generator>generator</a></li><li><a href=#thread aria-label=thread>thread</a></li></ul></li><li><a href=#cont-monad aria-label="cont monad">cont monad</a></li><li><a href=#%e9%82%8f%e8%bc%af%e4%b8%8a%e7%9a%84%e9%97%9c%e8%81%af-callcc%e7%9a%84type%e6%98%af aria-label="邏輯上的關聯: callcc的type是?">邏輯上的關聯: callcc的type是?</a></li><li><a href=#cps-conversion aria-label="CPS conversion">CPS conversion</a><ul><li><a href=#naive aria-label=naive>naive</a></li><li><a href=#high-order aria-label=high-order>high-order</a></li><li><a href=#%e6%b7%b7%e5%90%88 aria-label=混合>混合</a></li><li><a href=#partition aria-label=partition>partition</a></li></ul></li><li><a href=#todo aria-label=TODO>TODO</a></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>整理continuation與CPS轉換</p><h2 id=用法>用法<a hidden class=anchor aria-hidden=true href=#用法>#</a></h2><p>cont可以當成一種很強的return或是goto，但是可以當成函數用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>val</span> <span class=p>(</span><span class=nf>callcc</span> <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>k</span><span class=p>)</span> <span class=p>(</span><span class=nf>k</span> <span class=nv>k</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>set! </span><span class=nv>cont</span> <span class=nv>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>display </span><span class=nv>k</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>cont</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>cont</span> <span class=mi>20</span><span class=p>)</span>
</span></span></code></pre></div><p>只要調用cont就會回去當初執行callcc的那一行，所以可以用它來跳來跳去</p><h2 id=應用>應用<a hidden class=anchor aria-hidden=true href=#應用>#</a></h2><h3 id=dynamic-wind>dynamic-wind<a hidden class=anchor aria-hidden=true href=#dynamic-wind>#</a></h3><p>類似prehook與posthook，只是有在裡面執行或是要到裡面，就一定會跑prehook與posthook</p><p>下面是其中一種實作，stack放<code>(prehook . afterhook)</code>，之後就是對callcc動手腳，只要有人call就去跑整個stack</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>*here*</span> <span class=p>(</span><span class=nb>list </span><span class=no>#f</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>origin-callcc</span> <span class=nv>call-with-current-continuation</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nb>call-with-current-continuation </span><span class=nv>proc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>here</span> <span class=nv>*here*</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>origin-callcc</span> <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>cont</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nf>proc</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>lambda </span><span class=nv>results</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=nf>reroot!</span> <span class=nv>here</span><span class=p>)</span> <span class=c1>;; 包一層</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=nb>apply </span><span class=nv>cont</span> <span class=nv>results</span><span class=p>)))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nb>dynamic-wind </span><span class=nv>before</span> <span class=nv>during</span> <span class=nv>after</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>here</span> <span class=nv>*here*</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>reroot!</span> <span class=p>(</span><span class=nb>cons </span><span class=p>(</span><span class=nb>cons </span><span class=nv>before</span> <span class=nv>after</span><span class=p>)</span> <span class=nv>here</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>call-with-values </span><span class=nv>during</span> <span class=p>(</span><span class=k>lambda </span><span class=nv>results</span>
</span></span><span class=line><span class=cl>                                    <span class=p>(</span><span class=nf>reroot!</span> <span class=nv>here</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                    <span class=p>(</span><span class=nb>apply </span><span class=nv>values</span> <span class=nv>results</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>reroot!</span> <span class=nv>there</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>not </span><span class=p>(</span><span class=nb>eq? </span><span class=nv>*here*</span> <span class=nv>there</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>begin</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nf>reroot!</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>there</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>before</span> <span class=p>(</span><span class=nb>caar </span><span class=nv>there</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                  <span class=p>(</span><span class=nf>after</span> <span class=p>(</span><span class=nb>cdar </span><span class=nv>there</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nb>set-car! </span><span class=nv>*here*</span> <span class=p>(</span><span class=nb>cons </span><span class=nv>after</span> <span class=nv>before</span><span class=p>))</span> <span class=c1>;; reverse before after, so next time after will be invoke!!</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nb>set-cdr! </span><span class=nv>*here*</span> <span class=nv>there</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nb>set-car! </span><span class=nv>there</span> <span class=no>#f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nb>set-cdr! </span><span class=nv>there</span> <span class=o>&#39;</span><span class=p>())</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>set! </span><span class=nv>*here*</span> <span class=nv>there</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nf>before</span><span class=p>)))))</span>
</span></span></code></pre></div><h3 id=exception>exception<a hidden class=anchor aria-hidden=true href=#exception>#</a></h3><p>一個stack放fail時要跳回去那邊的cont</p><p>dynamic-wind是確保，cont被call時一定會pop stack
從cont進去時會把stack建回去 (在exception不需要就是了)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax </span><span class=nv>try</span> 
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>syntax-rules </span><span class=p>(</span><span class=nf>catch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>((</span><span class=nf>_</span> <span class=nv>exp</span> <span class=o>...</span> <span class=nv>catch</span> <span class=nv>proc</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>     <span class=c1>; =&gt;</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>cc</span> <span class=p>(</span><span class=nf>current-continuation</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nf>cond</span>
</span></span><span class=line><span class=cl>         <span class=p>((</span><span class=nb>procedure? </span><span class=nv>cc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nb>dynamic-wind </span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=k>lambda </span><span class=p>()</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=k>set! </span><span class=nv>exception-stack</span> <span class=p>(</span><span class=nb>cons </span><span class=nv>cc</span> <span class=nv>exception-stack</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=k>lambda </span><span class=p>()</span>
</span></span><span class=line><span class=cl>             <span class=nv>exp</span> <span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=k>lambda </span><span class=p>()</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=k>set! </span><span class=nv>exception-stack</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>exception-stack</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>         
</span></span><span class=line><span class=cl>         <span class=p>((</span><span class=nb>pair? </span><span class=nv>cc</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nf>proc</span> <span class=p>(</span><span class=nb>cadr </span><span class=nv>cc</span><span class=p>))))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>throw</span> <span class=nv>exception-value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>handler</span> <span class=p>(</span><span class=nb>car </span><span class=nv>exception-stack</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>handler</span> <span class=p>(</span><span class=nb>list </span><span class=ss>&#39;exception</span> <span class=nv>exception-value</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>try</span> <span class=p>(</span><span class=nf>try</span> <span class=p>(</span><span class=nf>throw</span> <span class=ss>&#39;foo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=nv>catch</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>exn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>display </span><span class=s>&#34;got inner exception: &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>display </span><span class=nv>exn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nf>newline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nf>throw</span> <span class=ss>&#39;bar</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>     <span class=nv>catch</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>exn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nb>display </span><span class=s>&#34;got outer exception: &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nb>display </span><span class=nv>exn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nf>newline</span><span class=p>)))</span>
</span></span></code></pre></div><h3 id=non-determing-computing>non-determing computing<a hidden class=anchor aria-hidden=true href=#non-determing-computing>#</a></h3><p>一個stack放fail時要跳回去那邊的cont</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>current-continuation</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>call-with-current-continuation </span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>cc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=nf>cc</span> <span class=nv>cc</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; fail-stack : list[continuation]</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>fail-stack</span> <span class=o>&#39;</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; fail : -&gt; ...</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>fail</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>not </span><span class=p>(</span><span class=nb>pair? </span><span class=nv>fail-stack</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>error</span> <span class=s>&#34;back-tracking stack exhausted!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>begin</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>back-track-point</span> <span class=p>(</span><span class=nb>car </span><span class=nv>fail-stack</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>set! </span><span class=nv>fail-stack</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>fail-stack</span><span class=p>))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nf>back-track-point</span> <span class=nv>back-track-point</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; amb : list[a] -&gt; a</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>amb</span> <span class=nv>choices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>cc</span> <span class=p>(</span><span class=nf>current-continuation</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>cond</span>
</span></span><span class=line><span class=cl>      <span class=p>((</span><span class=nb>null? </span><span class=nv>choices</span><span class=p>)</span>      <span class=p>(</span><span class=nf>fail</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>((</span><span class=nb>pair? </span><span class=nv>choices</span><span class=p>)</span>      <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>choice</span> <span class=p>(</span><span class=nb>car </span><span class=nv>choices</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                              <span class=p>(</span><span class=k>set! </span><span class=nv>choices</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>choices</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                              <span class=p>(</span><span class=k>set! </span><span class=nv>fail-stack</span> <span class=p>(</span><span class=nb>cons </span><span class=nv>cc</span> <span class=nv>fail-stack</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                              <span class=nv>choice</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>assert</span> <span class=nv>condition</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>or </span><span class=nv>condition</span> <span class=p>(</span><span class=nf>fail</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; The following prints (4 3 5)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>a</span> <span class=p>(</span><span class=nf>amb</span> <span class=p>(</span><span class=nb>list </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span> <span class=mi>6</span> <span class=mi>7</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>b</span> <span class=p>(</span><span class=nf>amb</span> <span class=p>(</span><span class=nb>list </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span> <span class=mi>6</span> <span class=mi>7</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>c</span> <span class=p>(</span><span class=nf>amb</span> <span class=p>(</span><span class=nb>list </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span> <span class=mi>6</span> <span class=mi>7</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>assert</span> <span class=p>(</span><span class=nb>= </span><span class=p>(</span><span class=nb>* </span><span class=nv>c</span> <span class=nv>c</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=p>(</span><span class=nb>* </span><span class=nv>a</span> <span class=nv>a</span><span class=p>)</span> <span class=p>(</span><span class=nb>* </span><span class=nv>b</span> <span class=nv>b</span><span class=p>)))))</span>
</span></span></code></pre></div><h3 id=generator>generator<a hidden class=anchor aria-hidden=true href=#generator>#</a></h3><p>一個ptr指向目前generator停下來的位置，另外為了讓generator好看，所以把生generator的cont交給make-yield</p><p>所以每次yield就會把val與cont丟回去</p><pre tabindex=0><code>(define (current-continuation) 
  (call-with-current-continuation
   (lambda (cc)
     (cc cc))))

; void : -&gt; void
(define (void)
  (if #f #t))

; tree-iterator : tree -&gt; generator
(define (tree-iterator tree)
  (lambda (yield)
    (define (walk tree)
      (if (not (pair? tree))
          (yield tree)
          (begin
            (walk (car tree))
            (walk (cdr tree)))))
    
    (walk tree)))

; make-yield : continuation -&gt; (value -&gt; ...)
(define (make-yield for-cc)
  (lambda (value)
    (let ((cc (current-continuation)))
      (if (procedure? cc)
          (for-cc (cons cc value))
          (void)))))

; (for v in generator body) will execute body 
; with v bound to successive values supplied
; by generator.
(define-syntax for
  (syntax-rules (in)
    ((_ v in iterator body ...)
     ; =&gt; 
     (let ((iterator-cont #f))
       (letrec ((loop (lambda ()
                        (let ((cc (current-continuation)))
                          (if (procedure? cc)
                              (if iterator-cont
                                  (iterator-cont (void))
                                  (iterator (make-yield cc)))
                              (let ((it-cont (car cc))
                                    (it-val  (cdr cc)))
                                (set! iterator-cont it-cont)
                                (let ((v it-val))
                                  body ...)
                                (loop)))))))
         (loop))))))

(for v in (tree-iterator &#39;(3 . ( ( 4 . 5 ) . 6 ) )) 
  (display v)
  (newline))
</code></pre><h3 id=thread>thread<a hidden class=anchor aria-hidden=true href=#thread>#</a></h3><p>前面是把cont塞到stack，這裡放到queue去!!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=c1>; thread-queue : list[continuation]</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>thread-queue</span> <span class=o>&#39;</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; halt : continuation</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>halt</span> <span class=no>#f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; void : -&gt; void</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>void</span><span class=p>)</span> <span class=p>(</span><span class=k>if </span><span class=no>#f</span> <span class=no>#t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; current-continuation : -&gt; continuation</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>current-continuation</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>call-with-current-continuation</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>cc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=nf>cc</span> <span class=nv>cc</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; spawn : (-&gt; anything) -&gt; void</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>spawn</span> <span class=nv>thunk</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>cc</span> <span class=p>(</span><span class=nf>current-continuation</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>procedure? </span><span class=nv>cc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>set! </span><span class=nv>thread-queue</span> <span class=p>(</span><span class=nb>append </span><span class=nv>thread-queue</span> <span class=p>(</span><span class=nb>list </span><span class=nv>cc</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>begin </span><span class=p>(</span><span class=nf>thunk</span><span class=p>)</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nf>quit</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; yield : value -&gt; void</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>yield</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>cc</span> <span class=p>(</span><span class=nf>current-continuation</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=k>and </span><span class=p>(</span><span class=nb>procedure? </span><span class=nv>cc</span><span class=p>)</span> <span class=p>(</span><span class=nb>pair? </span><span class=nv>thread-queue</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>next-thread</span> <span class=p>(</span><span class=nb>car </span><span class=nv>thread-queue</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>set! </span><span class=nv>thread-queue</span> <span class=p>(</span><span class=nb>append </span><span class=p>(</span><span class=nb>cdr </span><span class=nv>thread-queue</span><span class=p>)</span> <span class=p>(</span><span class=nb>list </span><span class=nv>cc</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nf>next-thread</span> <span class=ss>&#39;resume</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>void</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; quit : -&gt; ...</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>quit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>pair? </span><span class=nv>thread-queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>next-thread</span> <span class=p>(</span><span class=nb>car </span><span class=nv>thread-queue</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>set! </span><span class=nv>thread-queue</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>thread-queue</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>next-thread</span> <span class=ss>&#39;resume</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>halt</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=c1>; start-threads : -&gt; ...</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>start-threads</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>cc</span> <span class=p>(</span><span class=nf>current-continuation</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=nv>cc</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>begin</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>set! </span><span class=nv>halt</span> <span class=p>(</span><span class=k>lambda </span><span class=p>()</span> <span class=p>(</span><span class=nf>cc</span> <span class=no>#f</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>null? </span><span class=nv>thread-queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nf>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nf>begin</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>next-thread</span> <span class=p>(</span><span class=nb>car </span><span class=nv>thread-queue</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                  <span class=p>(</span><span class=k>set! </span><span class=nv>thread-queue</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>thread-queue</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                  <span class=p>(</span><span class=nf>next-thread</span> <span class=ss>&#39;resume</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>void</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; Example cooperatively threaded program</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>counter</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>make-thread-thunk</span> <span class=nv>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>letrec </span><span class=p>((</span><span class=nf>loop</span> <span class=p>(</span><span class=k>lambda </span><span class=p>()</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&lt; </span><span class=nv>counter</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                       <span class=p>(</span><span class=nf>quit</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nb>display </span><span class=s>&#34;in thread &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nb>display </span><span class=nv>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nb>display </span><span class=s>&#34;; counter = &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nb>display </span><span class=nv>counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nf>newline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=k>set! </span><span class=nv>counter</span> <span class=p>(</span><span class=nb>- </span><span class=nv>counter</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nf>yield</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nf>loop</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>    <span class=nv>loop</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>spawn</span> <span class=p>(</span><span class=nf>make-thread-thunk</span> <span class=ss>&#39;a</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>spawn</span> <span class=p>(</span><span class=nf>make-thread-thunk</span> <span class=ss>&#39;b</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>spawn</span> <span class=p>(</span><span class=nf>make-thread-thunk</span> <span class=ss>&#39;c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>start-threads</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=cont-monad>cont monad<a hidden class=anchor aria-hidden=true href=#cont-monad>#</a></h2><p>monad就是消滅傳遞參數的過程，下面來複習cont monad</p><p>先基本的cps</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>id</span> <span class=nv>x</span><span class=p>)</span> <span class=nv>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>fib1</span> <span class=nv>n</span> <span class=nv>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&lt;= </span><span class=nv>n</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>k</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>fib1</span> <span class=p>(</span><span class=nb>- </span><span class=nv>n</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>v1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nf>fib1</span> <span class=p>(</span><span class=nb>- </span><span class=nv>n</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>v2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=nf>k</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>v1</span> <span class=nv>v2</span><span class=p>))))))))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>writeln</span> <span class=p>(</span><span class=nf>fib1</span> <span class=mi>5</span> <span class=nv>id</span><span class=p>))</span>
</span></span></code></pre></div><p>把k往裡面推</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>fib2</span> <span class=nv>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&lt;= </span><span class=nv>n</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>k</span><span class=p>)</span> <span class=p>(</span><span class=nf>k</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>((</span><span class=nf>fib2</span> <span class=p>(</span><span class=nb>- </span><span class=nv>n</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>v1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>((</span><span class=nf>fib2</span> <span class=p>(</span><span class=nb>- </span><span class=nv>n</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>v2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=p>(</span><span class=nf>k</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>v1</span> <span class=nv>v2</span><span class=p>)))))))))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>writeln</span> <span class=p>((</span><span class=nf>fib2</span> <span class=mi>5</span><span class=p>)</span> <span class=nv>id</span><span class=p>))</span>
</span></span></code></pre></div><p>包一包，這裡可以注意到其實monad指的就是<code>(lambda (k) ...)</code>，只要被這個包起來就是monad!!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>return</span> <span class=nv>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>k</span><span class=p>)</span> <span class=p>(</span><span class=nf>k</span> <span class=nv>val</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>bind</span> <span class=nv>m</span> <span class=nv>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>((</span><span class=nf>m</span> <span class=nv>f</span><span class=p>)</span> <span class=nv>k</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>fib3</span> <span class=nv>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&lt;= </span><span class=nv>n</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>return</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>bind</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nf>fib3</span> <span class=p>(</span><span class=nb>- </span><span class=nv>n</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>v1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nf>bind</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=nf>fib3</span> <span class=p>(</span><span class=nb>- </span><span class=nv>n</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>v2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=nf>return</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>v1</span> <span class=nv>v2</span><span class=p>))))))))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>writeln</span> <span class=p>((</span><span class=nf>fib3</span> <span class=mi>5</span><span class=p>)</span> <span class=nv>id</span><span class=p>))</span>
</span></span></code></pre></div><p>callcc就是</p><ol><li>擷取現在的cont，塞進去lambda</li><li>讓原本的程式用原本的cont繼續跑</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>callcc</span> <span class=nv>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>((</span><span class=nf>f</span> <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nf>k</span> <span class=nv>val</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>      <span class=nv>k</span><span class=p>)))</span>
</span></span></code></pre></div><h2 id=邏輯上的關聯-callcc的type是>邏輯上的關聯: callcc的type是?<a hidden class=anchor aria-hidden=true href=#邏輯上的關聯-callcc的type是>#</a></h2><p>cont吃一個值之後就跳走，所以她的return val是什麼type?
沒關西，先當成<code>P -> Q</code></p><p>callcc是什麼type?
吃一個func，接回去原本的運算，注意到因為這裡的return val與cont吃得一樣，所以用一樣的type
<code>F -> P</code></p><p>F是什麼type?
吃一個cont，回傳某個值
<code>(P -> Q) -> ?</code></p><p>某個值是什麼type?
這func要接回去原本的運算，所以是P</p><p>整個是<code>((P -> Q) -> P) -> P</code></p><p>這就是Peirce’s law，如果把Q帶成bottom(Absurd)，就可以得到排中律!!</p><h2 id=cps-conversion>CPS conversion<a hidden class=anchor aria-hidden=true href=#cps-conversion>#</a></h2><p>在cont monad看到monad怎麼把cont藏起來
接著就是怎麼把這個k自己生出來，下面都用untyped lambda calculus</p><p>說老實話，其實是為了這個才把這篇打出來的</p><p>另外如果有人說，學遞迴要用trace實際執行過程，直接丟這個給他看，看他怎麼trace
或是說遞迴可以轉成loop，也是丟這個，看他怎麼轉</p><h3 id=naive>naive<a hidden class=anchor aria-hidden=true href=#naive>#</a></h3><p>先是base case，變數與lambda，這裡base case叫atomic
變數直接回傳，lambda要幫他開一個洞，把值傳回去</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span><span class=p>)</span> <span class=o>,</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$k</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>&#39;</span><span class=ss>$k</span><span class=p>))</span>
</span></span><span class=line><span class=cl>     <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span> <span class=o>,</span><span class=n>$k</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>T</span> <span class=n>expr</span> <span class=n>$k</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>expr</span><span class=p>]))</span><span class=err>
</span></span></span></code></pre></div><p>剩下就是apply，每個都要先轉沒問題，那這裡要放什麼?
可以先看看簡單的case: <code>(f v)</code>且都是變數
最保險就是每個都要轉(過M)，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>((</span><span class=k>λ</span> <span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>((</span><span class=k>λ</span> <span class=p>(</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>k</span> <span class=p>(</span><span class=n>a</span> <span class=n>b</span><span class=p>)))</span> <span class=c1>;; !!</span>
</span></span><span class=line><span class=cl>      <span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></div><p>等等，現在a會多一個cont</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>((</span><span class=k>λ</span> <span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>((</span><span class=k>λ</span> <span class=p>(</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>a</span> <span class=n>b</span> <span class=n>k</span><span class=p>))</span> <span class=c1>;; good</span>
</span></span><span class=line><span class=cl>      <span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>T</span> <span class=n>expr</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=o>.</span> <span class=o>,</span><span class=k>_</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>k</span> <span class=o>,</span><span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>k</span> <span class=o>,</span><span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>F</span> <span class=o>,</span><span class=n>V</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$f</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>&#39;</span><span class=ss>$f</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$v</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>&#39;</span><span class=ss>$v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>T</span> <span class=n>F</span> <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>$f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=o>,</span><span class=p>(</span><span class=n>T</span> <span class=n>V</span> <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>$v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                       <span class=p>(</span><span class=o>,</span><span class=n>$f</span> <span class=o>,</span><span class=n>$v</span> <span class=o>,</span><span class=n>k</span><span class=p>)))))]))</span><span class=err>
</span></span></span></code></pre></div><pre tabindex=0><code>(T &#39;(g a) &#39;halt) 
</code></pre><p>變成</p><pre tabindex=0><code>((λ ($f1445) 
  ((λ ($e1446) 
    ($f1445 $e1446 halt)) a)) g) 
</code></pre><h3 id=high-order>high-order<a hidden class=anchor aria-hidden=true href=#high-order>#</a></h3><p>最保險的方式可以work，但output有點長，為什麼不直接apply進去?</p><p>怎麼直接apply進去?
我們不是有現成的函數嗎</p><p>重新看T的base case，這裡如果可以直接apply函數，就可以把那坨去掉
換言之，我們原本在k傳的是symbol，但現在是racket的function，最後回傳symbol
所以先把quote拿掉</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>T</span> <span class=n>expr</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=o>.</span> <span class=o>,</span><span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>k</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span> <span class=p>(</span><span class=n>k</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>F</span> <span class=o>,</span><span class=n>V</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>T</span> <span class=n>F</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>T</span> <span class=n>V</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                       <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>f</span> <span class=o>,</span><span class=n>v</span> <span class=o>,</span><span class=n>k</span><span class=p>)))))]))</span> <span class=c1>;; !!</span>
</span></span></code></pre></div><p>等等，這裡k是racket的lambdaㄟ
這裡要是quote，所以要把<code>(f v)</code>的拉到原本的k去</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>T</span> <span class=n>expr</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=o>.</span> <span class=o>,</span><span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>k</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span> <span class=p>(</span><span class=n>k</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>F</span> <span class=o>,</span><span class=n>V</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$ret</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>`</span><span class=ss>$ret</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>cont</span> <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>$ret</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>k</span> <span class=n>$ret</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>T</span> <span class=n>F</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>T</span> <span class=n>V</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                       <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>f</span> <span class=o>,</span><span class=n>v</span> <span class=o>,</span><span class=n>cont</span><span class=p>)))))]))</span><span class=err>
</span></span></span></code></pre></div><p>回來看M，會看到lambda的k要改，改成racket的lambda，最後回傳symbol</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span><span class=p>)</span> <span class=o>,</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$k</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>&#39;</span><span class=ss>$k</span><span class=p>))</span>
</span></span><span class=line><span class=cl>     <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span> <span class=o>,</span><span class=n>$k</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>T</span> <span class=n>expr</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>$k</span> <span class=o>,</span><span class=n>ret</span><span class=p>))))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>expr</span><span class=p>]))</span><span class=err>
</span></span></span></code></pre></div><pre tabindex=0><code>(T &#39;(g a) (λ (ans) `(halt ,ans)))
</code></pre><p>變成</p><pre tabindex=0><code>(g a (λ ($rv1) (halt $rv1))) 
</code></pre><p>少很多，但能不能更好，那個lambda很多餘</p><h3 id=混合>混合<a hidden class=anchor aria-hidden=true href=#混合>#</a></h3><p>多的lambda來自T的cont，但又不能直接去掉，有什麼辦法?
回去看怎麼用的，不覺得很怪嗎，明明是轉symbol卻要寫lambda，有沒有辦法變成最初的方式去call</p><p>所以第一層可以先抄第一種T</p><pre tabindex=0><code>(define (T-symbol expr k-symbol)
  (match expr
    [`(λ . ,_) `(,k-symbol (M expr))]
    [(? symbol?) `(,k-symbol (M expr))]
    [`(,F ,V)
      ... ]))
</code></pre><p>但apply用第二種T</p><pre tabindex=0><code>(define (T-symbol expr k-symbol)
  (match expr
    [`(λ . ,_) `(,k-symbol ,(M expr))]
    [(? symbol?) `(,k-symbol ,(M expr))]
    [`(,F ,V)
      (T-func F (λ (f)
              (T-func V (λ (v)
                       `(,f ,v ,k-symbol)))))]))
</code></pre><p>再抄第二種T</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>T-func</span> <span class=n>expr</span> <span class=n>k-func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=o>.</span> <span class=o>,</span><span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>k-func</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span> <span class=p>(</span><span class=n>k-func</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>F</span> <span class=o>,</span><span class=n>V</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$ret</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>`</span><span class=ss>$ret</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>cont</span> <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>$ret</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>k-func</span> <span class=n>$ret</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>T-func</span> <span class=n>F</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>T-func</span> <span class=n>V</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                       <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>f</span> <span class=o>,</span><span class=n>v</span> <span class=o>,</span><span class=n>cont</span><span class=p>)))))]))</span><span class=err>
</span></span></span></code></pre></div><p>M要抄第一種，觀察兩個T的base case，會看到<code>(M expr)</code>，最後都是要被展開成symbol
所以選都是symbol的第一種</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span><span class=p>)</span> <span class=o>,</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$k</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>&#39;</span><span class=ss>$k</span><span class=p>))</span>
</span></span><span class=line><span class=cl>     <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span> <span class=o>,</span><span class=n>$k</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>T-symbol</span> <span class=n>expr</span> <span class=n>$k</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>expr</span><span class=p>]))</span><span class=err>
</span></span></span></code></pre></div><pre tabindex=0><code>(T-symbol &#39;(g a) &#39;halt)
</code></pre><p>變成</p><pre tabindex=0><code>(g a halt)
</code></pre><h3 id=partition>partition<a hidden class=anchor aria-hidden=true href=#partition>#</a></h3><p>這個是為了還原calling stack而產生的</p><p>要還原calling stack需要知道誰是caller，與之後衍生的
所以回去看生出cont的部分(幫lambda多一格的部分)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>T-func</span> <span class=n>expr</span> <span class=n>k-func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=o>.</span> <span class=o>,</span><span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>k-func</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span> <span class=p>(</span><span class=n>k-func</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>F</span> <span class=o>,</span><span class=n>V</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$ret</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>`</span><span class=ss>$ret</span><span class=p>))</span> <span class=c1>;; 1</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>cont</span> <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>$ret</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>k-func</span> <span class=n>$ret</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>T-func</span> <span class=n>F</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>T-func</span> <span class=n>V</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                       <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>f</span> <span class=o>,</span><span class=n>v</span> <span class=o>,</span><span class=n>cont</span><span class=p>)))))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span><span class=p>)</span> <span class=o>,</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$k</span> <span class=p>(</span><span class=nb>gensym</span> <span class=o>&#39;</span><span class=ss>$k</span><span class=p>))</span> <span class=c1>;; 2</span>
</span></span><span class=line><span class=cl>     <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span> <span class=o>,</span><span class=n>$k</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>T-symbol</span> <span class=n>expr</span> <span class=n>$k</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>expr</span><span class=p>]))</span><span class=err>
</span></span></span></code></pre></div><p>1是起點，也就是apply；2是中間。
所以把1的symbol標成user, 2是cont</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>T-func</span> <span class=n>expr</span> <span class=n>k-func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=o>.</span> <span class=o>,</span><span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>k-func</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span> <span class=p>(</span><span class=n>k-func</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>F</span> <span class=o>,</span><span class=n>V</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$ret</span> <span class=p>(</span><span class=n>genusym</span> <span class=o>`</span><span class=ss>$ret</span><span class=p>))</span> <span class=c1>;; 1</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>cont</span> <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>$ret</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>k-func</span> <span class=n>$ret</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>T-func</span> <span class=n>F</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>T-func</span> <span class=n>V</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                       <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=n>f</span> <span class=o>,</span><span class=n>v</span> <span class=o>,</span><span class=n>cont</span><span class=p>)))))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>M</span> <span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span><span class=p>)</span> <span class=o>,</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>$k</span> <span class=p>(</span><span class=n>genksym</span> <span class=o>&#39;</span><span class=ss>$k</span><span class=p>))</span> <span class=c1>;; 2</span>
</span></span><span class=line><span class=cl>     <span class=o>`</span><span class=p>(</span><span class=ss>λ</span> <span class=p>(</span><span class=o>,</span><span class=n>var</span> <span class=o>,</span><span class=n>$k</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>T-symbol</span> <span class=n>expr</span> <span class=n>$k</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>?</span> <span class=nb>symbol?</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>expr</span><span class=p>]))</span><span class=err>
</span></span></span></code></pre></div><p>在ref中還有scheme的轉換，但其實就是多了不定數量參數列的處理</p><h2 id=todo>TODO<a hidden class=anchor aria-hidden=true href=#todo>#</a></h2><p>delimit cont
據說cooperative的thread加macro可以變成preemptive!
<a href=https://matt.might.net/articles/closure-conversion/>Closure conversion: How to compile lambda</a></p><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/>Continuations by example: Exceptions, time-traveling search, generators, threads, and coroutines</a>
<a href=https://www.cs.hmc.edu/~fleck/envision/scheme48/meeting/node7.html>Appendix: An implementation of dynamic-wind</a>
<a href=https://www.zhihu.com/question/21954238>如何解释 Lisp 中 call/cc 的概念？</a>
<a href=https://www.jianshu.com/p/e860f95cad51>用call/cc合成所有的控制流结构</a>
<a href=https://matt.might.net/articles/cps-conversion/>How to compile with continuations</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/lisp/>Lisp</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/11/ipv6%E7%AD%86%E8%A8%98/><span class=title>« Prev</span><br><span>ipv6筆記</span>
</a><a class=next href=https://littlebees.github.io/2021/10/%E6%9C%89%E7%94%A8%E7%9A%84%E9%80%A3%E7%B5%90/><span class=title>Next »</span><br><span>有用的連結</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>