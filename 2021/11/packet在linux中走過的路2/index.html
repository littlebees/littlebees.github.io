<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>packet在linux中走過的路2 | 記事本</title>
<meta name=keywords content="Network"><meta name=description content="動機
算是packet在linux中走過的路的延伸"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/11/packet%E5%9C%A8linux%E4%B8%AD%E8%B5%B0%E9%81%8E%E7%9A%84%E8%B7%AF2/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/11/packet%E5%9C%A8linux%E4%B8%AD%E8%B5%B0%E9%81%8E%E7%9A%84%E8%B7%AF2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="packet在linux中走過的路2"><meta property="og:description" content="動機
算是packet在linux中走過的路的延伸"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/11/packet%E5%9C%A8linux%E4%B8%AD%E8%B5%B0%E9%81%8E%E7%9A%84%E8%B7%AF2/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-04T23:38:50+00:00"><meta property="article:modified_time" content="2021-11-04T23:38:50+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="packet在linux中走過的路2"><meta name=twitter:description content="動機
算是packet在linux中走過的路的延伸"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"packet在linux中走過的路2","item":"https://littlebees.github.io/2021/11/packet%E5%9C%A8linux%E4%B8%AD%E8%B5%B0%E9%81%8E%E7%9A%84%E8%B7%AF2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"packet在linux中走過的路2","name":"packet在linux中走過的路2","description":"動機 算是packet在linux中走過的路的延伸\n","keywords":["Network"],"articleBody":"動機 算是packet在linux中走過的路的延伸\nin device init module_init =\u003e 當設備驅動編譯時，MODULE_DEVICE_TABLE會導出一個 PCI 設備 ID 列表，驅動據此識別它可以控制的設備，內核也會依據這個列表對不同設備加載相應驅動。\n通過 PCI ID 識別設備後，內核就會為它選擇合適的驅動。 probe()\n啟用 PCI 設備 請求（requesting）內存範圍和 IO 端口 設置 DMA 掩碼 註冊設備驅動支持的 ethtool 方法（後面介紹） 註冊所需的 watchdog（例如，e1000e 有一個檢測設備是否freeze的 watchdog） 其他和具體設備相關的事情，例如一些 workaround，或者特定硬件的非常規處理 創建、初始化和註冊一個 struct net_device_ops 類型變量，這個變量包含了用於設 備相關的回調函數，例如打開設備、發送數據到網絡、設置 MAC 地址等 創建、初始化和註冊一個更高層的 struct net_device 類型變量（一個變量就代表了 一個設備） 驅動的硬中斷處理函數做的事情很少，但軟中斷將會在和硬中斷相同的 CPU 上執行。 這就是為什麼給每個 CPU 一個特定的硬中斷非常重要：這個 CPU 不僅處理這個硬中斷，而且通過 NAPI 處理接下來的軟中斷來收包。\n可以設定cpu affinity，讓localty上升，Set the IRQ affinity for IRQ 8 to CPU 0 echo 1 \u003e /proc/irq/8/smp_affinity\ndevice bring up igb_open =\u003e\n分配 RX、TX 隊列內存 有些網卡支援Receive Side Scaling（RSS，接收端擴展）或者多隊列（ multiqueue） 打開 NAPI 功能 (一次收多一點) 在一個單獨的線程裡，調用驅動註冊的 poll 方法收包 驅動禁止網卡產生新的硬件中斷。這樣做是為了 NAPI 能夠在收包的時候不會被新的中 斷打擾 一旦沒有包需要收了(或是收滿了,weight滿了)，NAPI 關閉，網卡的硬中斷重新開啟 註冊中斷處理函數 /proc/softirqs MSI-X 因為每個 RX 隊列有獨 立的MSI-X 中斷，因此可以被不同的 CPU 處理（通過 irqbalance 方式，或者修改 /proc/irq/IRQ_NUMBER/smp_affinity） MSI legacy IRQ 打開（enable）硬中斷 “Interrupt Throttling”（也叫 “Interrupt Coalescing”）的硬件 特性相關，這個特性可以平滑傳送到 CPU 的中斷數量 Interrupt coalescing 中斷合併會將多個中斷事件放到一起，累積到一定閾值後才向 CPU 發起中斷請求。 這可以防止中斷風暴，提升吞吐，降低 CPU 使用量，但延遲也變大；中斷數量過多則相反。 ethtool -C eth0 adaptive-rx on: 自適應 RX IRQ 合併 cat /proc/interrupts 網絡設備子系統的初始化 (net_dev_init) struct softnet_data 變量初始化 需要註冊到這個 CPU 的 NAPI 變量列表 數據處理 backlog 處理權重 receive offload 變量列表 receive packet steering 設置 註冊SoftIRQ NET_TX_SOFTIRQ =\u003e net_tx_action NET_RX_SOFTIRQ =\u003e net_rx_action monitor ethtool -S cat /sys/class/net//statistics/ /proc/net/dev 所有顯示的項目都是由driver定義的，所以不同driver同樣item的意思可能不同 tuning 調整queue RX queue的數量 RX queue的大小 RX queue的權重 RX queue的hash (讓pkt到不同的queue) ntuple filtering 在NIC上做過濾，steer到指定的queue inet開始收資料 先irq(igb_msix_ring)去要求跑sortirq，之後會帶到對應的softirq net_rx_action 從包所在的內存開始處理，包是被設備通過 DMA 直接送到內存。\nsoftirq透過NAPI(igb_poll)去讀，讀完就會解綁（unmap）這些內存，讀取數據，將數據送到napi_gro_receive，之後到下一層(tap或是ip，如果中間有RPS，會先過RPS)。\n有趣的是這裡的NAPI的weight寫死成64\nmonitor: /proc/net/softnet_stat 沒有title，這要直接看kernel code， net/core/net-procfs.c 每一行代表一個 struct softnet_data 變量。因為每個 CPU 只有一個該變量，所以每行 其實代表一個 CPU 每列用空格隔開，數值用 16 進製表示 第一列 sd-\u003eprocessed，是處理的網絡幀的數量。如果你使用了 ethernet bonding， 那這個值會大於總的網絡幀的數量，因為 ethernet bonding 驅動有時會觸發網絡數據被 重新處理（re-processed） 第二列，sd-\u003edropped，是因為處理不過來而 drop 的網絡幀數量。後面會展開這一話題 第三列，sd-\u003etime_squeeze，前面介紹過了，由於 budget 或 time limit 用完而退出 net_rx_action 循環的次數 接下來的 5 列全是 0 第九列，sd-\u003ecpu_collision，是為了發送包而獲取鎖的時候有衝突的次數 第十列，sd-\u003ereceived_rps，是這個 CPU 被其他 CPU 喚醒去收包的次數 最後一列，flow_limit_count，是達到 flow limit 的次數。 flow limit 是 RPS 的特性， 後面會稍微介紹一下 tune: 調整 net_rx_action budget * net.core.netdev_budget=600\nGRO（Generic Receive Offloading） Large Receive Offloading (LRO) 是一個硬件優化，GRO 是 LRO 的一種軟件實現。\n如果用 tcpdump 抓包，有時會看到機器收到了看起來不現實的、非常大的包， 這很可能是你的系統開啟了 GRO。\ntcpdump 的抓包點（捕獲包的 tap ）在整個棧的更後面一些，在GRO 之後。 NIC(與linux的level2)到IP之間\ndev_gro_receive 完成，napi_skb_finish 就會被調用，之後就是走 netif_receive_skb 或者繼續將包送到協議棧，或者交給 RPS，後者會轉交給其他 CPU 處理。\nRPS (Receive Packet Steering) RPS （Receive Packet Steering，接收包控制，接收包引導）是 RSS 的一種軟件實現\n因為它是軟件實現的，這意味著 RPS 只能在 packet 通過 DMA 進入內存後，RPS 才能開始工 作。\nRPS 並不會減少 CPU 處理硬件中斷和 NAPI poll（軟中斷最重要的一部分）的時 間，但是可以在 packet 到達內存後，將 packet 分到其他 CPU，從其他 CPU 進入協議棧。\nRPS 的工作原理是對個 packet 做 hash，以此決定分到哪個 CPU 處理。然後 packet 放到每個 CPU 獨占的接收後備隊列（backlog）等待處理。這個 CPU 會觸發一個進程間中斷（ IPI，Inter-processor Interrupt）向對端 CPU。如果當時對端 CPU 沒有在處理 backlog 隊列收包，這個進程間中斷會 觸發它開始從 backlog 收包。 /proc/net/softnet_stat 其中有一列是記錄 softnet_data 變量（也即這個 CPU）收到了多少 IPI（received_rps 列）。\ntune: /sys/class/net/DEVICE_NAME/queues/QUEUE/rps_cpus\nRFS (Receive Flow Steering) RFS 将属于相同 flow 的包送到相同的 CPU 进行处理，可以提高缓存命中率。\necho 2048 \u003e /sys/class/net/eth0/queues/rx-0/rps_flow_cnt sysctl -w net.core.rps_sock_flow_entries=32768\naRFS (Hardware accelerated RFS) RFS 可以用硬件加速，網卡和內核協同工作，判斷哪個 flow 應該在哪個 CPU 上處理。 這個要開RFS與kernel要編CONFIG_RFS_ACCEL，ntuple也要開，最後配置 IRQ（硬中斷）中每個 RX 和 CPU 的對應關係\n到linux的level2 (协议栈) 從netif_receive_skb過來 先當成有RPS，pkt就會到cpu的backlog(enqueue_to_backlog)，之後NAPI的poller會去拉(process_backlog)，可以把cpu當成另一種網卡 另外有flow limit，避免cpu被打爆 最後做gro(napi_gro_complete)\n等到了cpu的backlog queue，NAPI poller就會去拉pkt backlog NAPI 變量和設備驅動 NAPI 變量的不同之處在於，它的 weight 是可以調節的，而設備 驅動是 hardcode 64。\nmonitor: 由於 input_pkt_queue 打滿或 flow limit 導致的丟包 * /proc/net/softnet_stat 裡面的 dropped tune: * RX packet timestamping * net.core.netdev_tstamp_prequeue=0 * 調cpu backlog: * net.core.netdev_max_backlog=3000 * 讓NAPI能一次拿更多pkt(wieght) * net.core.dev_weight=600 * 調flow limit的table size * net.core.flow_limit_table_len=8192 * 打開flow limit * /proc/sys/net/core/flow_limit_cpu_bitmap\n最後的最後，__netif_receive_skb_core把pkt送到抓包點（tap）或協議層\n到目前為止的流程 NIC -\u003e(DMA,irq) driver -\u003e(NAPI,sortirq) gro -\u003e RPS -\u003e(NAPI) tap/IP\n到IP ip_rcv之後就是netfilter(NF_HOOK)的prerouting，ip_rcv_finish(early_demux) 就可以往上走了!!\nearly_demux 如果這個優化打開了，但是並沒有命中緩存（例如，這是第一個包），這個包就會被送到內 核的路由子系統，在那裡將會計算出一個 dst_entry 並賦給相應的字段 所以應該能猜，沒開就是每次都去查?\ntune: 把early_demux關了(也許需要)\nnet.ipv4.ip_early_demux=0 如果是自己的pkt? ip_local_deliver處理，過netfilter，到ip_local_deliver_finish\nmonitor:\n/proc/net/snmp InReceives: ip_rcv收到多少pkt InHdrErrors: 多少ip header壞了 InAddrErrors: 多少pkt的addr是到不了的 ForwDatagrams: forwarded的ip pkt InUnknownProtos: 多少是protocol不明的 InDiscards: 多少pkt被丟了(也許是mem alloc失敗，也許是checksum error) InDelivers: 多少pkt成功往上送 InCsumErrors: 多少pkt是checksum error\n到udp udp_rcv\n這裡會看pkt與他的dst_entry(routing的結果)，送到socket的backlog tune:\nSocket receive queue memory net.core.rmem_max=8388608 net.core.rmem_default=8388608 或是用setsockopt帶 monitor: /proc/net/snmp /proc/net/udp /proc/net/snmp InDatagrams: 總共有多少udp pkt進入或流出 NoPorts: 總共有多少udp pkt的dport是沒有人在聽的 InErrors: 多少udp pkt有錯誤(也許是mem alloc失敗，也許是checksum error) OutDatagrams: 多少pkt成功往下送 RcvbufErrors: 有多少pkt是因為rcv buffer爆了而塞不進去 SndbufErrors: 有多少pkt是因為send buffer爆了而塞不進去 InCsumErrors: 多少pkt是checksum error\n/proc/net/udp sl: Kernel hash slot for the socket local_address: local addr rem_address: remote addr st: socket的狀態 tx_queue: tx queue的大小 rx_queue: rx queue的大小 tr, tm-\u003ewhen, retrnsmt: 這些應該retry與retransmit uid: 創這個socket的uid timeout: 應該是tcp的timeout inode: socket的inode ref: reference count pointer: socket的address drops: 這個socket的drop\nsocket sock_queue_rcv收pkt，sk_data_ready通知socket\nout socket sentto，會走到sock_sendmsg，之後看socket是AF_INET，走道inet_sendmsg 之後就是走到udp_sendmsg\nudp 拿dip,dport，處理unicast或mutilcast，之後就是routing??，生skb(ip_make_skb)，丟給udp_send_skb\n怎麼感覺有偷跑的感覺在??\nip ip_send_skb收到pkt，ip_local_out，netfilter(local_out)，routing(拿dst_entry)，ip_output，netfilter(post_routing)，ip_finish_output\nip_finish_output，通常是\nip_fragment，之後ip_finish_output2 直接ip_finish_output2 ip_finish_output2會去調arp(鄰居系統)\nPath MTU Discovery 此功能允許內核自動確定 路由的最大傳輸單元（ MTU ）。\n調用 setsockopt 帶 SOL_IP 和 IP_MTU_DISCOVER\nlinux level2 (TC) dev_queue_xmit，之後就是找TX queue的旅程(netdev_pick_tx)，拿到TX queue找對應的qdisc，之後到dev_hard_start_xmit，會去跑qdisc，再到sch_direct_xmit-\u003edev_hard_start_xmit\n任何無法發送的 skb 都重新入隊，將在 NET_TX softirq 中進行 發送。 __netif_schedule發tx的irq\nsortirq: net_tx_action completion queue: 待釋放 skb 隊列 output queue: 待發送 skb 隊列 之後到dev_hard_start_xmit 發送數據花費的總時間是下面二者之和 系統調用的系統時間(sys time) NET_TX 類型的 softirq 時間（softirq time） dev_hard_start_xmit dev_queue_xmit_nit: copy skb到tap(pcap) ops-\u003endo_start_xmit: 到device去 monitor: tc -s qdisc show dev eth1 bytes: driver總共傳了多少bytes pkt: driver總共傳了多少pkt dropped: qdisc drop多少pkt overlimits: 有多少pkt是因為這個qdisc的策略而被去掉的(queue爆了或是有pkt出queue時去清) requeues: 有多少pkt是重新入queue(像是driver丟不出去就會重新入queue) backlog: 現在queue多長\n你可以調整前面看到的__qdisc_run 循環的權重（上面看到的 quota 變量），這將導致 __netif_schedule 更多的被調用執行。結果將是當前 qdisc 將被更多的添加到當前 CPU 的 output_queue，最終會使發包所佔的時間變多。\ntune:\n調整__qdisc_run 處理權重 net.core.dev_weight=600 增加發送隊列長度 ifconfig eth0 txqueuelen 10000 Transmit Packet Steering (XPS) 發送數據包控制（XPS）是一項功能，允許系統管理員配置哪些 CPU 可以處理網卡的哪些發送 隊列。 XPS 的主要目的是避免處理髮送請求時的鎖競爭。使用 XPS 還可以減少緩存驅逐， 避免NUMA機器上的遠程 內存訪問等。\ntune: /sys/class/net/DEVICE_NAME/queues/QUEUE/xps_cpus\nNIC 到了driver的igb_xmit_frame_ring，再到igb_tx_map將 skb 數據映射到 RAM 的 DMA 區域\n完成傳送之後device送完pkt就會丟irq\n對於 igb 驅動程序（及其關聯設備），發送完成和數據包接收所觸發的 IRQ 是相同的。這意味著 對於 igb 驅動程序，NET_RX 既用於處理髮送完成，又用於處理數據包接收。 如果是這種情況，則 NET_RX softirq 會被用於 處理數據包接收和發送完成兩種情況。\n在NAPI做poll(igb_poll)時會去清已完成的pkt(igb_clean_tx_irq)\nDynamic Queue Limits (DQL) DQL 內部算法判斷何時數據已足夠多，達到此閾值後，DQL 將暫時禁用 TX Queue，從而對網絡系統產生背壓。當足夠的數據已發送完後，DQL 再自動重新啟用該隊列。\nmonitor: /sys/class/net//queues/tx-/byte_queue_limits/* hold_time: 類似tcp的timeout，如果queue一直滿到一定時間(以HZ為單位)就去縮小queue的最大長度 inflight: number of packets queued - number of packets completed limit_max: (寫死) DQL_MAX_LIMIT (1879048192 on my x86_64 system) limit_min: (寫死) 0 limit: 介於limit_min與limit_max之間，代表queue的最大長度\nRef [译] Linux 网络栈监控和调优：接收数据（2016） Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data Monitoring and Tuning the Linux Networking Stack: Receiving Data [译] Linux 网络栈监控和调优：发送数据（2017） Monitoring and Tuning the Linux Networking Stack: Sending Data linux网络实现分析(1)——数据包的接收（从网卡到协议栈） linux网络实现分析(3)——数据包的发送（IP层到链路层） The packet flow, from userspace to kernel driver in Linux network stack\n","wordCount":"805","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-11-04T23:38:50Z","dateModified":"2021-11-04T23:38:50Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/11/packet%E5%9C%A8linux%E4%B8%AD%E8%B5%B0%E9%81%8E%E7%9A%84%E8%B7%AF2/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">packet在linux中走過的路2</h1><div class=post-meta><span title='2021-11-04 23:38:50 +0000 UTC'>November 4, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#in aria-label=in>in</a><ul><li><a href=#device-init aria-label="device init">device init</a></li><li><a href=#device-bring-up aria-label="device bring up">device bring up</a></li><li><a href=#inet%e9%96%8b%e5%a7%8b%e6%94%b6%e8%b3%87%e6%96%99 aria-label=inet開始收資料>inet開始收資料</a><ul><li><a href=#grogeneric-receive-offloading aria-label="GRO（Generic Receive Offloading）">GRO（Generic Receive Offloading）</a></li><li><a href=#rps-receive-packet-steering aria-label="RPS (Receive Packet Steering)">RPS (Receive Packet Steering)</a><ul><li><a href=#rfs-receive-flow-steering aria-label="RFS (Receive Flow Steering)">RFS (Receive Flow Steering)</a><ul><li><a href=#arfs-hardware-accelerated-rfs aria-label="aRFS (Hardware accelerated RFS)">aRFS (Hardware accelerated RFS)</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%88%b0linux%e7%9a%84level2-%e5%8d%8f%e8%ae%ae%e6%a0%88 aria-label="到linux的level2 (协议栈)">到linux的level2 (协议栈)</a></li><li><a href=#%e5%88%b0%e7%9b%ae%e5%89%8d%e7%82%ba%e6%ad%a2%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=到目前為止的流程>到目前為止的流程</a></li><li><a href=#%e5%88%b0ip aria-label=到IP>到IP</a></li><li><a href=#%e5%88%b0udp aria-label=到udp>到udp</a></li><li><a href=#socket aria-label=socket>socket</a></li></ul></li><li><a href=#out aria-label=out>out</a></li><li><a href=#socket-1 aria-label=socket>socket</a></li><li><a href=#udp aria-label=udp>udp</a></li><li><a href=#ip aria-label=ip>ip</a><ul><li><a href=#path-mtu-discovery aria-label="Path MTU Discovery">Path MTU Discovery</a></li></ul></li><li><a href=#linux-level2-tc aria-label="linux level2 (TC)">linux level2 (TC)</a><ul><li><a href=#transmit-packet-steering-xps aria-label="Transmit Packet Steering (XPS)">Transmit Packet Steering (XPS)</a></li></ul></li><li><a href=#nic aria-label=NIC>NIC</a><ul><li><a href=#dynamic-queue-limits-dql aria-label="Dynamic Queue Limits (DQL)">Dynamic Queue Limits (DQL)</a></li></ul></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>算是<a href=/2021/09/path-of-packet-in-linux/>packet在linux中走過的路</a>的延伸</p><h2 id=in>in<a hidden class=anchor aria-hidden=true href=#in>#</a></h2><h3 id=device-init>device init<a hidden class=anchor aria-hidden=true href=#device-init>#</a></h3><p>module_init =>
當設備驅動編譯時，MODULE_DEVICE_TABLE會導出一個 PCI 設備 ID 列表，驅動據此識別它可以控制的設備，內核也會依據這個列表對不同設備加載相應驅動。</p><p>通過 PCI ID 識別設備後，內核就會為它選擇合適的驅動。
probe()</p><ol><li>啟用 PCI 設備</li><li>請求（requesting）內存範圍和 IO 端口</li><li>設置 DMA 掩碼</li><li>註冊設備驅動支持的 ethtool 方法（後面介紹）</li><li>註冊所需的 watchdog（例如，e1000e 有一個檢測設備是否freeze的 watchdog）</li><li>其他和具體設備相關的事情，例如一些 workaround，或者特定硬件的非常規處理</li><li>創建、初始化和註冊一個 struct net_device_ops 類型變量，這個變量包含了用於設 備相關的回調函數，例如打開設備、發送數據到網絡、設置 MAC 地址等</li><li>創建、初始化和註冊一個更高層的 struct net_device 類型變量（一個變量就代表了 一個設備）</li></ol><p>驅動的硬中斷處理函數做的事情很少，但軟中斷將會在和硬中斷相同的 CPU 上執行。
這就是為什麼給每個 CPU 一個特定的硬中斷非常重要：這個 CPU 不僅處理這個硬中斷，而且通過 NAPI 處理接下來的軟中斷來收包。</p><p>可以設定cpu affinity，讓localty上升，Set the IRQ affinity for IRQ 8 to CPU 0
<code>echo 1 > /proc/irq/8/smp_affinity</code></p><h3 id=device-bring-up>device bring up<a hidden class=anchor aria-hidden=true href=#device-bring-up>#</a></h3><p>igb_open =></p><ul><li>分配 RX、TX 隊列內存<ul><li>有些網卡支援Receive Side Scaling（RSS，接收端擴展）或者多隊列（ multiqueue）</li></ul></li><li>打開 NAPI 功能 (一次收多一點)<ul><li>在一個單獨的線程裡，調用驅動註冊的 poll 方法收包</li><li>驅動禁止網卡產生新的硬件中斷。這樣做是為了 NAPI 能夠在收包的時候不會被新的中 斷打擾</li><li>一旦沒有包需要收了(或是收滿了,weight滿了)，NAPI 關閉，網卡的硬中斷重新開啟</li></ul></li><li>註冊中斷處理函數<ul><li><code>/proc/softirqs</code></li><li>MSI-X<ul><li>因為每個 RX 隊列有獨 立的MSI-X 中斷，因此可以被不同的 CPU 處理（通過 irqbalance 方式，或者修改 /proc/irq/IRQ_NUMBER/smp_affinity）</li></ul></li><li>MSI</li><li>legacy IRQ</li></ul></li><li>打開（enable）硬中斷<ul><li>“Interrupt Throttling”（也叫 “Interrupt Coalescing”）的硬件 特性相關，這個特性可以平滑傳送到 CPU 的中斷數量</li><li>Interrupt coalescing 中斷合併會將多個中斷事件放到一起，累積到一定閾值後才向 CPU 發起中斷請求。<ul><li>這可以防止中斷風暴，提升吞吐，降低 CPU 使用量，但延遲也變大；中斷數量過多則相反。</li><li><code>ethtool -C eth0 adaptive-rx on</code>: 自適應 RX IRQ 合併</li></ul></li><li><code>cat /proc/interrupts</code></li></ul></li><li>網絡設備子系統的初始化 (net_dev_init)<ul><li>struct softnet_data 變量初始化<ul><li>需要註冊到這個 CPU 的 NAPI 變量列表</li><li>數據處理 backlog</li><li>處理權重</li><li>receive offload 變量列表</li><li>receive packet steering 設置</li></ul></li><li>註冊SoftIRQ<ul><li>NET_TX_SOFTIRQ => net_tx_action</li><li>NET_RX_SOFTIRQ => net_rx_action</li></ul></li></ul></li><li>monitor<ul><li><code>ethtool -S</code></li><li><code>cat /sys/class/net/&lt;NIC>/statistics/&lt;item></code></li><li><code>/proc/net/dev</code></li><li>所有顯示的項目都是由driver定義的，所以不同driver同樣item的意思可能不同</li></ul></li><li>tuning<ul><li>調整queue<ul><li>RX queue的數量</li><li>RX queue的大小</li><li>RX queue的權重</li><li>RX queue的hash (讓pkt到不同的queue)</li></ul></li><li>ntuple filtering<ul><li>在NIC上做過濾，steer到指定的queue</li></ul></li></ul></li></ul><h3 id=inet開始收資料>inet開始收資料<a hidden class=anchor aria-hidden=true href=#inet開始收資料>#</a></h3><p>先irq(igb_msix_ring)去要求跑sortirq，之後會帶到對應的softirq
<code>net_rx_action</code> 從包所在的內存開始處理，包是被設備通過 DMA 直接送到內存。</p><p>softirq透過NAPI(igb_poll)去讀，讀完就會解綁（unmap）這些內存，讀取數據，將數據送到napi_gro_receive，之後到下一層(tap或是ip，如果中間有RPS，會先過RPS)。</p><p>有趣的是這裡的NAPI的weight寫死成64</p><p>monitor:
<code>/proc/net/softnet_stat</code>
沒有title，這要直接看kernel code，<code> net/core/net-procfs.c</code>
每一行代表一個 struct softnet_data 變量。因為每個 CPU 只有一個該變量，所以每行 其實代表一個 CPU
每列用空格隔開，數值用 16 進製表示
第一列 sd->processed，是處理的網絡幀的數量。如果你使用了 ethernet bonding， 那這個值會大於總的網絡幀的數量，因為 ethernet bonding 驅動有時會觸發網絡數據被 重新處理（re-processed）
第二列，sd->dropped，是因為處理不過來而 drop 的網絡幀數量。後面會展開這一話題
第三列，sd->time_squeeze，前面介紹過了，由於 budget 或 time limit 用完而退出 net_rx_action 循環的次數
接下來的 5 列全是 0
第九列，sd->cpu_collision，是為了發送包而獲取鎖的時候有衝突的次數
第十列，sd->received_rps，是這個 CPU 被其他 CPU 喚醒去收包的次數
最後一列，flow_limit_count，是達到 flow limit 的次數。 flow limit 是 RPS 的特性， 後面會稍微介紹一下
tune: 調整 net_rx_action budget
* <code>net.core.netdev_budget=600</code></p><h4 id=grogeneric-receive-offloading>GRO（Generic Receive Offloading）<a hidden class=anchor aria-hidden=true href=#grogeneric-receive-offloading>#</a></h4><p>Large Receive Offloading (LRO) 是一個硬件優化，GRO 是 LRO 的一種軟件實現。</p><p>如果用 tcpdump 抓包，有時會看到機器收到了看起來不現實的、非常大的包， 這很可能是你的系統開啟了 GRO。</p><p>tcpdump 的抓包點（捕獲包的 tap ）在整個棧的更後面一些，在GRO 之後。
NIC(與linux的level2)到IP之間</p><p>dev_gro_receive 完成，napi_skb_finish 就會被調用，之後就是走
<code>netif_receive_skb</code> 或者繼續將包送到協議棧，或者交給 RPS，後者會轉交給其他 CPU 處理。</p><h4 id=rps-receive-packet-steering>RPS (Receive Packet Steering)<a hidden class=anchor aria-hidden=true href=#rps-receive-packet-steering>#</a></h4><p>RPS （Receive Packet Steering，接收包控制，接收包引導）是 RSS 的一種軟件實現</p><p>因為它是軟件實現的，這意味著 RPS 只能在 packet 通過 DMA 進入內存後，RPS 才能開始工 作。</p><p>RPS 並不會減少 CPU 處理硬件中斷和 NAPI poll（軟中斷最重要的一部分）的時 間，但是可以在 packet 到達內存後，將 packet 分到其他 CPU，從其他 CPU 進入協議棧。</p><p>RPS 的工作原理是對個 packet 做 hash，以此決定分到哪個 CPU 處理。然後 packet 放到每個 CPU 獨占的接收後備隊列（backlog）等待處理。這個 CPU 會觸發一個進程間中斷（ IPI，Inter-processor Interrupt）向對端 CPU。如果當時對端 CPU 沒有在處理 backlog 隊列收包，這個進程間中斷會 觸發它開始從 backlog 收包。 /proc/net/softnet_stat 其中有一列是記錄 softnet_data 變量（也即這個 CPU）收到了多少 IPI（received_rps 列）。</p><p>tune: <code>/sys/class/net/DEVICE_NAME/queues/QUEUE/rps_cpus</code></p><h5 id=rfs-receive-flow-steering>RFS (Receive Flow Steering)<a hidden class=anchor aria-hidden=true href=#rfs-receive-flow-steering>#</a></h5><p>RFS 将属于相同 flow 的包送到相同的 CPU 进行处理，可以提高缓存命中率。</p><p><code>echo 2048 > /sys/class/net/eth0/queues/rx-0/rps_flow_cnt</code>
<code>sysctl -w net.core.rps_sock_flow_entries=32768</code></p><h6 id=arfs-hardware-accelerated-rfs>aRFS (Hardware accelerated RFS)<a hidden class=anchor aria-hidden=true href=#arfs-hardware-accelerated-rfs>#</a></h6><p>RFS 可以用硬件加速，網卡和內核協同工作，判斷哪個 flow 應該在哪個 CPU 上處理。
這個要開RFS與kernel要編CONFIG_RFS_ACCEL，ntuple也要開，最後配置 IRQ（硬中斷）中每個 RX 和 CPU 的對應關係</p><h3 id=到linux的level2-协议栈>到linux的level2 (协议栈)<a hidden class=anchor aria-hidden=true href=#到linux的level2-协议栈>#</a></h3><p>從netif_receive_skb過來
先當成有RPS，pkt就會到cpu的backlog(enqueue_to_backlog)，之後NAPI的poller會去拉(process_backlog)，可以把cpu當成另一種網卡
另外有flow limit，避免cpu被打爆
最後做gro(napi_gro_complete)</p><p>等到了cpu的backlog queue，NAPI poller就會去拉pkt
backlog NAPI 變量和設備驅動 NAPI 變量的不同之處在於，它的 weight 是可以調節的，而設備 驅動是 hardcode 64。</p><p>monitor: 由於 input_pkt_queue 打滿或 flow limit 導致的丟包
* /proc/net/softnet_stat 裡面的 dropped
tune:
* RX packet timestamping
* net.core.netdev_tstamp_prequeue=0
* 調cpu backlog:
* net.core.netdev_max_backlog=3000
* 讓NAPI能一次拿更多pkt(wieght)
* net.core.dev_weight=600
* 調flow limit的table size
* net.core.flow_limit_table_len=8192
* 打開flow limit
* /proc/sys/net/core/flow_limit_cpu_bitmap</p><p>最後的最後，__netif_receive_skb_core把pkt送到抓包點（tap）或協議層</p><h3 id=到目前為止的流程>到目前為止的流程<a hidden class=anchor aria-hidden=true href=#到目前為止的流程>#</a></h3><p>NIC ->(DMA,irq) driver ->(NAPI,sortirq) gro -> RPS ->(NAPI) tap/IP</p><h3 id=到ip>到IP<a hidden class=anchor aria-hidden=true href=#到ip>#</a></h3><p>ip_rcv之後就是netfilter(NF_HOOK)的prerouting，ip_rcv_finish(early_demux)
就可以往上走了!!</p><p>early_demux
如果這個優化打開了，但是並沒有命中緩存（例如，這是第一個包），這個包就會被送到內 核的路由子系統，在那裡將會計算出一個 dst_entry 並賦給相應的字段
所以應該能猜，沒開就是每次都去查?</p><p>tune: 把early_demux關了(也許需要)</p><ul><li>net.ipv4.ip_early_demux=0</li></ul><p>如果是自己的pkt?
ip_local_deliver處理，過netfilter，到ip_local_deliver_finish</p><p>monitor:</p><ul><li><code>/proc/net/snmp</code></li></ul><p>InReceives: ip_rcv收到多少pkt
InHdrErrors: 多少ip header壞了
InAddrErrors: 多少pkt的addr是到不了的
ForwDatagrams: forwarded的ip pkt
InUnknownProtos: 多少是protocol不明的
InDiscards: 多少pkt被丟了(也許是mem alloc失敗，也許是checksum error)
InDelivers: 多少pkt成功往上送
InCsumErrors: 多少pkt是checksum error</p><h3 id=到udp>到udp<a hidden class=anchor aria-hidden=true href=#到udp>#</a></h3><p>udp_rcv</p><ul><li>這裡會看pkt與他的dst_entry(routing的結果)，送到socket的backlog</li></ul><p>tune:</p><ul><li>Socket receive queue memory<ul><li>net.core.rmem_max=8388608</li><li>net.core.rmem_default=8388608</li><li>或是用setsockopt帶
monitor:</li></ul></li><li>/proc/net/snmp</li><li>/proc/net/udp</li></ul><p>/proc/net/snmp
InDatagrams: 總共有多少udp pkt進入或流出
NoPorts: 總共有多少udp pkt的dport是沒有人在聽的
InErrors: 多少udp pkt有錯誤(也許是mem alloc失敗，也許是checksum error)
OutDatagrams: 多少pkt成功往下送
RcvbufErrors: 有多少pkt是因為rcv buffer爆了而塞不進去
SndbufErrors: 有多少pkt是因為send buffer爆了而塞不進去
InCsumErrors: 多少pkt是checksum error</p><p>/proc/net/udp
sl: Kernel hash slot for the socket
local_address: local addr
rem_address: remote addr
st: socket的狀態
tx_queue: tx queue的大小
rx_queue: rx queue的大小
tr, tm->when, retrnsmt: 這些應該retry與retransmit
uid: 創這個socket的uid
timeout: 應該是tcp的timeout
inode: socket的inode
ref: reference count
pointer: socket的address
drops: 這個socket的drop</p><h3 id=socket>socket<a hidden class=anchor aria-hidden=true href=#socket>#</a></h3><p>sock_queue_rcv收pkt，sk_data_ready通知socket</p><h2 id=out>out<a hidden class=anchor aria-hidden=true href=#out>#</a></h2><h2 id=socket-1>socket<a hidden class=anchor aria-hidden=true href=#socket-1>#</a></h2><p>sentto，會走到sock_sendmsg，之後看socket是AF_INET，走道inet_sendmsg
之後就是走到udp_sendmsg</p><h2 id=udp>udp<a hidden class=anchor aria-hidden=true href=#udp>#</a></h2><p>拿dip,dport，處理unicast或mutilcast，之後就是routing??，生skb(ip_make_skb)，丟給udp_send_skb</p><p>怎麼感覺有偷跑的感覺在??</p><h2 id=ip>ip<a hidden class=anchor aria-hidden=true href=#ip>#</a></h2><p>ip_send_skb收到pkt，ip_local_out，netfilter(local_out)，routing(拿dst_entry)，ip_output，netfilter(post_routing)，ip_finish_output</p><p>ip_finish_output，通常是</p><ol><li>ip_fragment，之後ip_finish_output2</li><li>直接ip_finish_output2</li></ol><p>ip_finish_output2會去調arp(鄰居系統)</p><h3 id=path-mtu-discovery>Path MTU Discovery<a hidden class=anchor aria-hidden=true href=#path-mtu-discovery>#</a></h3><p>此功能允許內核自動確定 路由的最大傳輸單元（ MTU ）。</p><p>調用 setsockopt 帶 SOL_IP 和 IP_MTU_DISCOVER</p><h2 id=linux-level2-tc>linux level2 (TC)<a hidden class=anchor aria-hidden=true href=#linux-level2-tc>#</a></h2><p>dev_queue_xmit，之後就是找TX queue的旅程(netdev_pick_tx)，拿到TX queue找對應的qdisc，之後到dev_hard_start_xmit，會去跑qdisc，再到sch_direct_xmit->dev_hard_start_xmit</p><p>任何無法發送的 skb 都重新入隊，將在 NET_TX softirq 中進行 發送。
__netif_schedule發tx的irq</p><ol><li>sortirq: net_tx_action<ul><li>completion queue: 待釋放 skb 隊列</li><li>output queue: 待發送 skb 隊列<ul><li>之後到dev_hard_start_xmit<ul><li>發送數據花費的總時間是下面二者之和<ul><li>系統調用的系統時間(sys time)</li><li>NET_TX 類型的 softirq 時間（softirq time）</li></ul></li></ul></li></ul></li></ul></li><li>dev_hard_start_xmit<ul><li>dev_queue_xmit_nit: copy skb到tap(pcap)</li><li>ops->ndo_start_xmit: 到device去</li></ul></li></ol><p>monitor: <code>tc -s qdisc show dev eth1</code>
bytes: driver總共傳了多少bytes
pkt: driver總共傳了多少pkt
dropped: qdisc drop多少pkt
overlimits: 有多少pkt是因為這個qdisc的策略而被去掉的(queue爆了或是有pkt出queue時去清)
requeues: 有多少pkt是重新入queue(像是driver丟不出去就會重新入queue)
backlog: 現在queue多長</p><p>你可以調整前面看到的__qdisc_run 循環的權重（上面看到的 quota 變量），這將導致 __netif_schedule 更多的被調用執行。結果將是當前 qdisc 將被更多的添加到當前 CPU 的 output_queue，最終會使發包所佔的時間變多。</p><p>tune:</p><ul><li>調整__qdisc_run 處理權重<ul><li><code>net.core.dev_weight=600</code></li></ul></li><li>增加發送隊列長度<ul><li>ifconfig eth0 txqueuelen 10000</li></ul></li></ul><h3 id=transmit-packet-steering-xps>Transmit Packet Steering (XPS)<a hidden class=anchor aria-hidden=true href=#transmit-packet-steering-xps>#</a></h3><p>發送數據包控制（XPS）是一項功能，允許系統管理員配置哪些 CPU 可以處理網卡的哪些發送 隊列。 XPS 的主要目的是避免處理髮送請求時的鎖競爭。使用 XPS 還可以減少緩存驅逐， 避免NUMA機器上的遠程 內存訪問等。</p><p>tune:
<code>/sys/class/net/DEVICE_NAME/queues/QUEUE/xps_cpus</code></p><h2 id=nic>NIC<a hidden class=anchor aria-hidden=true href=#nic>#</a></h2><p>到了driver的igb_xmit_frame_ring，再到igb_tx_map將 skb 數據映射到 RAM 的 DMA 區域</p><p>完成傳送之後device送完pkt就會丟irq</p><p>對於 igb 驅動程序（及其關聯設備），發送完成和數據包接收所觸發的 IRQ 是相同的。這意味著 對於 igb 驅動程序，NET_RX 既用於處理髮送完成，又用於處理數據包接收。
如果是這種情況，則 NET_RX softirq 會被用於 處理數據包接收和發送完成兩種情況。</p><p>在NAPI做poll(igb_poll)時會去清已完成的pkt(igb_clean_tx_irq)</p><h3 id=dynamic-queue-limits-dql>Dynamic Queue Limits (DQL)<a hidden class=anchor aria-hidden=true href=#dynamic-queue-limits-dql>#</a></h3><p>DQL 內部算法判斷何時數據已足夠多，達到此閾值後，DQL 將暫時禁用 TX Queue，從而對網絡系統產生背壓。當足夠的數據已發送完後，DQL 再自動重新啟用該隊列。</p><p>monitor:
<code>/sys/class/net/&lt;NIC>/queues/tx-&lt;QUEUE_ID>/byte_queue_limits/*</code>
hold_time: 類似tcp的timeout，如果queue一直滿到一定時間(以HZ為單位)就去縮小queue的最大長度
inflight: number of packets queued - number of packets completed
limit_max: (寫死) DQL_MAX_LIMIT (1879048192 on my x86_64 system)
limit_min: (寫死) 0
limit: 介於limit_min與limit_max之間，代表queue的最大長度</p><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=http://arthurchiao.art/blog/tuning-stack-rx-zh>[译] Linux 网络栈监控和调优：接收数据（2016）</a>
<a href=https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/>Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data</a>
<a href=https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#softirqs>Monitoring and Tuning the Linux Networking Stack: Receiving Data</a>
<a href=http://arthurchiao.art/blog/tuning-stack-tx-zh/>[译] Linux 网络栈监控和调优：发送数据（2017）</a>
<a href=https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/#general-advice-on-monitoring-and-tuning-the-linux-networking-stack>Monitoring and Tuning the Linux Networking Stack: Sending Data</a>
<a href="https://developer.aliyun.com/article/11018?spm=a2c6h.13262185.0.0.615e1fa4KJ9NN2">linux网络实现分析(1)——数据包的接收（从网卡到协议栈）</a>
<a href="https://developer.aliyun.com/article/26253?spm=a2c6h.13262185.0.0.615e1fa4KJ9NN2">linux网络实现分析(3)——数据包的发送（IP层到链路层）</a>
<a href=https://blog.louie.lu/2019/03/06/the-packet-flow-from-userspace-to-kernel-driver-in-linux-network-stack/>The packet flow, from userspace to kernel driver in Linux network stack</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/network/>Network</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/11/disappearing-pairs/><span class=title>« Prev</span><br><span>Disappearing-Pairs</span>
</a><a class=next href=https://littlebees.github.io/2021/11/netfilter%E7%9A%84conntrack/><span class=title>Next »</span><br><span>netfilter的conntrack</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>