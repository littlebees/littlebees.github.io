<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C/C++的FAQ | 記事本</title>
<meta name=keywords content="C/C++"><meta name=description content="動機
整理一些之前的問題"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2020/12/c/c-%E7%9A%84faq/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C/C++的FAQ"><meta property="og:description" content="動機
整理一些之前的問題"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2020/12/c/c-%E7%9A%84faq/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-20T03:53:12+00:00"><meta property="article:modified_time" content="2020-12-20T03:53:12+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="C/C++的FAQ"><meta name=twitter:description content="動機
整理一些之前的問題"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C/C++的FAQ","item":"https://littlebees.github.io/2020/12/c/c-%E7%9A%84faq/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C/C++的FAQ","name":"C\/C\u002b\u002b的FAQ","description":"動機 整理一些之前的問題\n","keywords":["C/C++"],"articleBody":"動機 整理一些之前的問題\nextern, static, global extern 的意思是去外面找，去其他的程式中找在哪 static 的意思是只在這個範圍存活\u0026可見，用這個方式來看file(global)、function、class(only for c++)的static變數，就會很一致了\n下面的三個code就是demo extern的用處\nextern之後，a就可以用了 但是對於有static的global變數，linker會找不到他\naaa.cpp\nint a = 10; int b = 100; static int c = 1000; void x(){a--;} void y(){b--;} aaa.hpp\nextern int b; void x(); void y(); bbb.cpp\n#include \"aaa.hpp\" #include int main() { //std::cout \u003c\u003c a; error std::cout \u003c\u003c b \u003c\u003c '\\n'; y(); std::cout \u003c\u003c \"after y: \" \u003c\u003c b \u003c\u003c '\\n'; b--; std::cout \u003c\u003c \"after b--: \" \u003c\u003c b \u003c\u003c '\\n'; extern int a; std::cout \u003c\u003c a; x(); std::cout \u003c\u003c \"after a: \" \u003c\u003c a \u003c\u003c '\\n'; a--; std::cout \u003c\u003c \"after a--: \" \u003c\u003c a \u003c\u003c '\\n'; // extern static int c; // linker fails, cant find c } extern “C” 在C++中函數可以overload，所以C++的函數其實編譯出來後名字會被加料，但 如果要include一些用c寫好的函數就會出事，名字會對不上，所以要用extern \"C\"\n用extern \"C\"就是說這段不要加料，照C的方式來\nuse C lib in C++ /* fromc.h */ #ifdef __cplusplus extern \"C\" int get10(); #else int get10(); #endif /* fromc.c */ int get10() {return 10;} // useclib.cpp #include #include \"fromc.h\" int main() { std::cout \u003c\u003c get10() \u003c\u003c '\\n'; } use C++ lib in C // fromcpp.hpp int get20_for_C(); // fromcpp.cpp int get20() {return 20;} extern \"C\" { int get20_for_C() {return get20();} } /* usecpplib.c */ #include #include \"fromcpp.hpp\" int main() { printf(\"%d\\n\", get20_for_C()); } static 為什麼放在.data 程式在記憶體中會有\nstack\u0026heap a. stack: 放local var與函數的call stack b. heap: 動態allocate的東西 bss: uninit的static data: 放 全域變數與常數 text: 程式碼 data 與 stack\u0026heap 的差別是?\ndata的資料只要程式還在跑，就不會消失 stack\u0026heap的資料隨時都有可能消失\n所以static 為什麼放在.data? 因為static隨時都要存活，所以不能放在stack\u0026heap，那就只能放在data\nabout C++ class friend struct A { void normal_method() {} friend void friend_method(A\u0026 me) {} }; int main() { A a; //原本的method call a.normal_method(); //不想放前面的method call，當然不一定是只能傳自己，這就是函數可以多個 friend_method(a); } virtual 有標virtual就是會在runtime時依據實際上的type去找method執行，如果沒有就是依據變數的type\n#include struct A { void x() {std::cout \u003c\u003c \"x\\n\";} virtual void y() {std::cout \u003c\u003c \"y\\n\";} }; struct B : public A { void x() {std::cout \u003c\u003c \"x2\\n\";} virtual void y() {std::cout \u003c\u003c \"y2\\n\";} }; int main() { A* a = new B(); a-\u003ex(); // x a-\u003ey(); // y2 ((B*)a)-\u003ex(); // x2 delete a; } 注意: constructor不能是virtual constructor本來就是從new時的type建立回去，所以不需要virtual 另一個說法是new物件時還沒有virtual的table，所以不能是virtual\n但destructor需要，因為如果像上面的code去刪一個parent指標，時沒有virtual，會從parent的destructor去跑，這就尷尬了\nobject slicing 就是從child轉到parent會讓child的東西不見，這就是slicing 但是，因為cpp有copy，事情可能會搞砸\n如果從child到parent是用copy的話，就不會根據原本的資料去找attribute與method，同時如果要轉回去也會出事(要記得用dynamic_casr轉啊)\nclass Base { protected: int m_value{}; public: Base(int value) : m_value{ value } {} virtual const char* getName() const { return \"Base\"; } int getValue() const { return m_value; } }; class Derived: public Base { public: Derived(int value) : Base{ value } {} virtual const char* getName() const { return \"Derived\"; } }; void printName(const Base base) // note: base passed by value, not reference { std::cout \u003c\u003c \"I am a \" \u003c\u003c base.getName() \u003c\u003c '\\n'; } int main() { Derived derived{ 5 }; std::cout \u003c\u003c \"derived is a \" \u003c\u003c derived.getName() \u003c\u003c \" and has value \" \u003c\u003c derived.getValue() \u003c\u003c '\\n'; Base \u0026ref{ derived }; // ok std::cout \u003c\u003c \"ref is a \" \u003c\u003c ref.getName() \u003c\u003c \" and has value \" \u003c\u003c ref.getValue() \u003c\u003c '\\n'; Base *ptr{ \u0026derived }; // ok std::cout \u003c\u003c \"ptr is a \" \u003c\u003c ptr-\u003egetName() \u003c\u003c \" and has value \" \u003c\u003c ptr-\u003egetValue() \u003c\u003c '\\n'; Base base{ derived }; // be sliced std::cout \u003c\u003c \"base is a \" \u003c\u003c base.getName() \u003c\u003c \" and has value \" \u003c\u003c base.getValue() \u003c\u003c '\\n'; printName(derived); // be sliced return 0; } the rule of five 如果定義了自己的\ndestructor copy constructor copy assignment 就要把其他的也一起定義完\n不過因為C++11有move，所以要多兩個\nmove constructor move assignment class rule_of_five { char* cstring; // raw pointer used as a handle to a dynamically-allocated memory block public: rule_of_five(const char* s = \"\") : cstring(nullptr) { if (s) { std::size_t n = std::strlen(s) + 1; cstring = new char[n]; // allocate std::memcpy(cstring, s, n); // populate } } ~rule_of_five() { delete[] cstring; // deallocate } rule_of_five(const rule_of_five\u0026 other) // copy constructor : rule_of_five(other.cstring) {} rule_of_five(rule_of_five\u0026\u0026 other) noexcept // move constructor : cstring(std::exchange(other.cstring, nullptr)) {} rule_of_five\u0026 operator=(const rule_of_five\u0026 other) // copy assignment { return *this = rule_of_five(other); } rule_of_five\u0026 operator=(rule_of_five\u0026\u0026 other) noexcept // move assignment { std::swap(cstring, other.cstring); return *this; } // alternatively, replace both assignment operators with // rule_of_five\u0026 operator=(rule_of_five other) noexcept // { // std::swap(cstring, other.cstring); // return *this; // } }; OS related Edge Trigger \u0026 Level Trigger Edge Trigger: 狀態變化時產生io事件 Level Trigger: 滿足條件時產生io事件 memory memory hierarchy register cache memory main memory HDD Direct Memory Access, DMA 讓device可以直接操作記憶體，像是device把資料copy到mem去 會導致cache不一致!! (因為直接改mem，但cache不知道) 寫入mem時要通知cache做invalidate 讀cache時，dma已經開始(拿到最新的) 或 dma關閉(不會被改) 不然cpu就要中斷自己去做 由cpu啟動dma，剩下的事情就是dma controller的工作 mutex \u0026 semaphore mutex 受益人數: 一人 誰能改變狀態(上鎖): a. 還沒上鎖: 所有人 b. 上鎖了: 上鎖的人 使用場域: 保護critical zone semaphore 受益人數: 看設定多少 誰能改變狀態(記數): 誰都ok 使用場域: 同步時的signal Big Endian \u0026 Little Endian 資料放進記憶體中的時\nBig-Endian(Network Order): 最高位的位元組會放在最低的記憶體位址上 Little-Endian: 最高位的位元組放在最高的記憶體位址上 記憶體的最高在右邊，但資料的最高在左手邊\nHigh -\u003e 12345678 \u003c- Low Low -\u003e a[0], a[1], a[2], a[4] \u003c- High #include #include #include typedef union { uint32_t l; unsigned char c[4]; } EndianTest; // 輸出位元組順序 void printBytes(uint32_t x) { EndianTest et; et.l = x; for (int i = 0; i \u003c 4; i++) { printf(\"0x%02X \", et.c[i]); } printf(\"n\"); } int main() { uint32_t x = 0x12345678; // big: 12, 34, 56, 78 // little: 78, 56, 34, 12 printf(\"0x%X 在記憶體中的儲存順序：\", x); printBytes(x); uint32_t n = htonl(x); printf(\"0x%X 在網路中的傳輸順序：\", x); printBytes(n); } how to IPC pipe(named pipe) popen message queue semophore signal shared memory socket file deadlock condition race condition: 輸出依據不受控制的事件出現順序或者出現時機 Critical section: access共享資源的code synchronization: 協調讓thread使用Critical section在時間上一致與統一 Cache coherence: 快取一致性 (為什麼放這邊?，可以看volatile)\n資源唯一(互斥) =\u003e a node in a graph 不會被搶(不可搶占) =\u003e node cant be removed 拿著並等別的資源(占有且等待) =\u003e an edge to other node 別人也在等我(循環等待) =\u003e cycle thread \u0026 process process: OS的資源分配單位，彼此不影響 thread: 程式的執行單位，互相影響 a. a kernel thread to a user thread: linux’s clone(child process, LWP) b. a kernel thread to many user threads c. many kernel threads to many user threads how to talk to kernel virtual filesystems(e.g. /proc, /sys, configfs, relayfs): kernel \u003c-\u003e user, exchange data netlink/UDP socket: kernel \u003c-\u003e user, exchange data mmap: kernel \u003c-\u003e user, exchange data syscall: user -\u003e kernel, invoke function ioctl: kernel \u003c-\u003e user, exchange data signal from kernel: kernel -\u003e user, invoke handler upcall: kernel -\u003e user, invoke a function ref\nvolatile 就是叫compiler每次都乖乖重新拿值，不然可能有神秘的優化把變數消滅掉\n用處\nregister 在multi-thread共用的變數 一個中斷服務子程序中會訪問到的非自動變量(Non-automatic variables) Can we use “const” and “volatile” in the same variable? extern const volatile unsigned int rt_clock; 用在監看reg的值的時候\nmalloc、calloc、realloc malloc: 就是allocate calloc: allocate + 初始值 realloc: resize但是不一定從原本的位置開始，所以會copy舊資料到新位置 pointer size 看記憶體是幾位元的\n64: 8 bytes 32: 4 bytes OO in C struct與透過method控制struct就是封裝 繼承要利用c的struct特性\n因為struct只是去算field的offset，所以只要\n同一個位置 同樣長度 就可以當成child class (484與golang很像) struct A { int a; }; struct B { int a; // extend int b; }; void getA(A* this) { printf(\"%d\\n\", this-\u003ea); } void getB(B* this) { printf(\"%d %d\\n\", this-\u003ea, this-\u003eb); } int main() { B y{30,20}; getA((A*)y); } 那多形? struct自己存實作的fucntion ptr\nmacro 一些工具 concat #define cons(a,b) a##b // cons(1,2) =\u003e 12 可變參數(預設參數)，如果有尾巴的逗號會被吃掉 (C99) #define foo(must, ...) _foo(must, (foo_args){.a = 8, .b = 3.14, __VA_ARGS__}); // foo('D', .b = 9, .a = 2); to_string #define STR(s) #s // STR(123) =\u003e \"123\" _Generic (C11, 就是泛型) #define foo(a, b) \\ _Generic((a), \\ int: func1, \\ double: _Generic((b), \\ int : func2, \\ double: func3 \\ ) \\ )(a, b) 使用時要注意 用括號 #define pow(a) (a) * (a) // pow(1+2) =\u003e (1+2) * (1+2) 如果有temp變數要加大括號，不然會汙染到原本的scope #define swap(a, b) { \\ int temp = a; \\ a = b; \\ b = temp; \\ } 幫數字標上type #define NUM (100*123*234UL) // 注意: 型別要放在數字後面!! // U for unsigned // L for long int or long float // F for float // default: double or int 如果要用macro在另一個macro要多一層讓macro先展開 #define A 2 #define CONS(a,b) a##b // CONS(A,A) =\u003e AA #define _CONS(a,b) a##b #define CONS_GOOD _CONS(a,b) // CONS_GOOD(A,A) =\u003e _CONS(2,2) =\u003e 22 useful macro \u0026 case study #include #define debug(fmt, ...) { \\ fprintf(stderr, \"(%s:%d) \"fmt\"\\n\", __FILE__, __LINE__, ##__VA_ARGS__); \\ } int main(void) { debug(\"%s %d\", \"Shit happen!\", 1); return 0; } #define hash_hash # ## # #define mkstr(a) # a #define in_between(a) mkstr(a) #define join(c, d) in_between(c hash_hash d) //join(x, y) //in_between(x hash_hash y) //in_between(x ## y) //mkstr(x ## y) default args: 在函數做設定\n#include #define f(...) def_f((f_args) {__VA_ARGS__}) typedef struct { int i; double j; } f_args; void real_f(int i, double j) { printf(\"%i %f\\n\",i,j); } void def_f(f_args args) { int i = args.i ? args.i : 10; double j = args.j ? args.j : 10.5; real_f(i,j); } int main() { f(3,8); f(.j=100.2, .i=4); f(2); f(.j=45.3); f(); f(12,); return 0; } default args: 在struct(macro展開時)做設定\n#include #define f(...) def_f((f_args){.i=10, .j=10.5, __VA_ARGS__}) typedef struct { int i; double j; } f_args; void real_f(int i, double j) { printf(\"%i %f\\n\",i,j); } void def_f(f_args x) { real_f(x.i,x.j); } int main() { //f(3,8); f(.j=100.2, .i=4); //f(2); f(.j=45.3); f(); //f(12,); return 0; } floating point 不要直接比較，要變成看相對誤差 abs((0.1+0.2)-0.3) \u003c epsilon 少用float做直接運算，轉成整數\n使用另外設計的Lib\n調整算式\n豐富的case\nISR __interrupt double compute_area(double radius) // 1. no args (這應該是上半部) { double area = PI * radius * radius; // 2. kernel space 用float?! printf(\"\\nArea = %f\"， area); // 3. 在中斷跑IO!? return area; // 4. irq沒有return，syscall有 } pitfall auto cast 有unsigned就會自動變成unsigned\nvoid foo(void) { unsigned int a = 6; int b = -20; (a+b \u003e 6) ? puts(\"\u003e 6\") : puts(\"\u003c= 6\"); // \u003e 6 } type size 只有char確定是1byte!!\n所以下面的code可能會出事，因為unsigned int不一定是4bytes\nunsigned int zero = 0; unsigned int compzero = 0xFFFF; /*1's complement of zero */ type size char 1 byte unsigned char 1 byte signed char 1 byte int 2 or 4 bytes unsigned int 2 or 4 bytes short 2 bytes unsigned short 2 bytes long 8 bytes or (4bytes for 32 bit OS) unsigned long 8 bytes p++ \u0026 ++p 就算有括號，p++的inc還是後做，++p的inc還是先做\nint a[5]={1,2,3,4,5}; int *p=a; *(p++)+=123; *(++p)+=123; //124 2 126 4 5 typedef #define dPS struct s * typedef struct s * tPS; dPS p1,p2; // =\u003e struct s * p1,p2; tPS p3,p4;// =\u003e struct s *p1,*p2; pointer \u0026 array type 先看array，再看pointer，有括號就先看括號\nint a[10]; // An array of 10 integers int *a[10]; // An array of 10 pointers to integers // int ((*a)[10]) int (*a)[10]; // A pointer to an array of 10 integers int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer const \u0026 pointer int const *a; // ptr的內容固定 int * const a; // 被指到的int固定 const int const * a; // 兩個都固定 計組 Pipeline instruction fetch instruction decode/fetch register instruction execute/ branch or jump memory access to mem write back to reg 因為現在是所有指令共用datapath，所以要pipeline reg讓stage去load需要的資料去完成每個階段的任務\nharzards Data Hazard LoadStore (RAW): 還沒寫完就被讀(拿到舊的值) StoreStore (WAW): 前面還沒寫完，後面已經寫進去了 StoreLoad (WAR): 來沒讀完就被寫(拿到未來的值) sol compiler 或是 cpu的 stall forwarding: 把需要的資訊丟到後面的pipeline reg，讓後面的stage先做事 Control Hazard if 的 bool還沒被算出來!! sol stall 分支預測(猜) Structural hazard 在pipeline上指令的需要同一個資源 sol stall 亂序執行 Network Programming server socket new socket() bind 填ip, port listen socket.start() accept (可以去看block-nonblock-sync-async補一下block與non-block的知識) loop -\u003e get socket read / write close client socket connect write / read close 傳struct 不能直接傳，大小頭、padding、type的size不一定會一樣，會可能會轉不回來\n轉成string 用htonl與ntohl，自己把int轉一轉 host order to network order long (integer, s是short integer) network order to host order long (integer, s是short integer) float就要自己設計格式，沒有htonl與ntohl可以用，不然就是去找序列化的lib，像protobuf\npipe pipefs create a file in pipefs, which is in mem return 2 fd, one for writing, another for reading how tcpdump works 透過libpcap的api生bpf 除此之外 bit trick lvalue, rvalue tmp Maximum subarray linked list binary search tree LRU cache ","wordCount":"1781","inLanguage":"en","datePublished":"2020-12-20T03:53:12Z","dateModified":"2020-12-20T03:53:12Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2020/12/c/c-%E7%9A%84faq/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C/C++的FAQ</h1><div class=post-meta><span title='2020-12-20 03:53:12 +0000 UTC'>December 20, 2020</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#extern-static-global aria-label="extern, static, global">extern, static, global</a><ul><li><a href=#extern-c aria-label="extern &ldquo;C&rdquo;">extern &ldquo;C&rdquo;</a><ul><li><a href=#use-c-lib-in-c aria-label="use C lib in C++">use C lib in C++</a></li><li><a href=#use-c-lib-in-c-1 aria-label="use C++ lib in C">use C++ lib in C</a></li></ul></li><li><a href=#static-%e7%82%ba%e4%bb%80%e9%ba%bc%e6%94%be%e5%9c%a8data aria-label="static 為什麼放在.data">static 為什麼放在.data</a></li></ul></li><li><a href=#about-c-class aria-label="about C++ class">about C++ class</a><ul><li><a href=#friend aria-label=friend>friend</a></li><li><a href=#virtual aria-label=virtual>virtual</a></li><li><a href=#object-slicing aria-label="object slicing">object slicing</a></li><li><a href=#the-rule-of-five aria-label="the rule of five">the rule of five</a></li></ul></li><li><a href=#os-related aria-label="OS related">OS related</a><ul><li><a href=#edge-trigger--level-trigger aria-label="Edge Trigger & Level Trigger">Edge Trigger & Level Trigger</a></li><li><a href=#memory aria-label=memory>memory</a></li><li><a href=#mutex--semaphore aria-label="mutex & semaphore">mutex & semaphore</a></li><li><a href=#big-endian--little-endian aria-label="Big Endian & Little Endian">Big Endian & Little Endian</a></li><li><a href=#how-to-ipc aria-label="how to IPC">how to IPC</a></li><li><a href=#deadlock-condition aria-label="deadlock condition">deadlock condition</a></li><li><a href=#thread--process aria-label="thread & process">thread & process</a></li><li><a href=#how-to-talk-to-kernel aria-label="how to talk to kernel">how to talk to kernel</a></li></ul></li><li><a href=#volatile aria-label=volatile>volatile</a><ul><li><a href=#can-we-use-const-and-volatile-in-the-same-variable aria-label="Can we use “const” and “volatile” in the same variable?">Can we use “const” and “volatile” in the same variable?</a></li></ul></li><li><a href=#malloccallocrealloc aria-label=malloc、calloc、realloc>malloc、calloc、realloc</a></li><li><a href=#pointer-size aria-label="pointer size">pointer size</a></li><li><a href=#oo-in-c aria-label="OO in C">OO in C</a></li><li><a href=#macro aria-label=macro>macro</a><ul><li><a href=#%e4%b8%80%e4%ba%9b%e5%b7%a5%e5%85%b7 aria-label=一些工具>一些工具</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%99%82%e8%a6%81%e6%b3%a8%e6%84%8f aria-label=使用時要注意>使用時要注意</a></li><li><a href=#useful-macro--case-study aria-label="useful macro & case study">useful macro & case study</a></li></ul></li><li><a href=#floating-point aria-label="floating point">floating point</a></li><li><a href=#isr aria-label=ISR>ISR</a></li><li><a href=#pitfall aria-label=pitfall>pitfall</a><ul><li><a href=#auto-cast aria-label="auto cast">auto cast</a></li><li><a href=#type-size aria-label="type size">type size</a></li><li><a href=#p--p aria-label="p++ & ++p">p++ & ++p</a></li><li><a href=#typedef aria-label=typedef>typedef</a></li><li><a href=#pointer--array-type aria-label="pointer & array type">pointer & array type</a></li><li><a href=#const--pointer aria-label="const & pointer">const & pointer</a></li></ul></li><li><a href=#%e8%a8%88%e7%b5%84 aria-label=計組>計組</a><ul><li><a href=#pipeline aria-label=Pipeline>Pipeline</a></li><li><a href=#harzards aria-label=harzards>harzards</a></li></ul></li><li><a href=#network-programming aria-label="Network Programming">Network Programming</a><ul><li><a href=#server aria-label=server>server</a></li><li><a href=#client aria-label=client>client</a></li><li><a href=#%e5%82%b3struct aria-label=傳struct>傳struct</a></li><li><a href=#pipe aria-label=pipe>pipe</a></li><li><a href=#how-tcpdump-works aria-label="how tcpdump works">how tcpdump works</a></li></ul></li><li><a href=#%e9%99%a4%e6%ad%a4%e4%b9%8b%e5%a4%96 aria-label=除此之外>除此之外</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>整理一些之前的問題</p><h2 id=extern-static-global>extern, static, global<a hidden class=anchor aria-hidden=true href=#extern-static-global>#</a></h2><p>extern 的意思是<strong>去外面找</strong>，去其他的程式中找在哪
static 的意思是<strong>只在這個範圍存活&可見</strong>，用這個方式來看file(global)、function、class(only for c++)的static變數，就會很一致了</p><p>下面的三個code就是demo extern的用處</p><p>extern之後，a就可以用了
但是對於有static的global變數，linker會找不到他</p><p>aaa.cpp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>1000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>x</span><span class=p>(){</span><span class=n>a</span><span class=o>--</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>y</span><span class=p>(){</span><span class=n>b</span><span class=o>--</span><span class=p>;}</span>
</span></span></code></pre></div><p>aaa.hpp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>x</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>y</span><span class=p>();</span>
</span></span></code></pre></div><p>bbb.cpp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;aaa.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//std::cout &lt;&lt; a; error
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>y</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;after y: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>b</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;after b--: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>extern</span> <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>x</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;after a: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;after a--: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// extern static int c; // linker fails, cant find c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=extern-c>extern &ldquo;C&rdquo;<a hidden class=anchor aria-hidden=true href=#extern-c>#</a></h3><p>在C++中函數可以overload，所以C++的函數其實編譯出來後名字會被加料，但
如果要include一些用c寫好的函數就會出事，名字會對不上，所以要用<code>extern "C"</code></p><p>用<code>extern "C"</code>就是說這段不要加料，照C的方式來</p><h4 id=use-c-lib-in-c>use C lib in C++<a hidden class=anchor aria-hidden=true href=#use-c-lib-in-c>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* fromc.h */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kt>int</span> <span class=nf>get10</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>get10</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* fromc.c */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get10</span><span class=p>()</span> <span class=p>{</span><span class=k>return</span> <span class=mi>10</span><span class=p>;}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// useclib.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;fromc.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get10</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=use-c-lib-in-c-1>use C++ lib in C<a hidden class=anchor aria-hidden=true href=#use-c-lib-in-c-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// fromcpp.hpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>get20_for_C</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fromcpp.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>get20</span><span class=p>()</span> <span class=p>{</span><span class=k>return</span> <span class=mi>20</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>get20_for_C</span><span class=p>()</span> <span class=p>{</span><span class=k>return</span> <span class=n>get20</span><span class=p>();}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* usecpplib.c */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;fromcpp.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>get20_for_C</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=static-為什麼放在data>static 為什麼放在.data<a hidden class=anchor aria-hidden=true href=#static-為什麼放在data>#</a></h3><p>程式在記憶體中會有</p><ol><li>stack&amp;heap
a. stack: 放local var與函數的call stack
b. heap: 動態allocate的東西</li><li>bss: uninit的static</li><li>data: 放 全域變數與常數</li><li>text: 程式碼</li></ol><p>data 與 stack&amp;heap 的差別是?</p><p>data的資料只要程式還在跑，就不會消失
stack&amp;heap的資料隨時都有可能消失</p><p>所以static 為什麼放在.data?
因為static隨時都要存活，所以不能放在stack&amp;heap，那就只能放在data</p><h2 id=about-c-class>about C++ class<a hidden class=anchor aria-hidden=true href=#about-c-class>#</a></h2><h3 id=friend>friend<a hidden class=anchor aria-hidden=true href=#friend>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>normal_method</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=kt>void</span> <span class=nf>friend_method</span><span class=p>(</span><span class=n>A</span><span class=o>&amp;</span> <span class=n>me</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//原本的method call
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>a</span><span class=p>.</span><span class=n>normal_method</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>//不想放前面的method call，當然不一定是只能傳自己，這就是函數可以多個
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>friend_method</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=virtual>virtual<a hidden class=anchor aria-hidden=true href=#virtual>#</a></h3><p>有標virtual就是會在runtime時依據<em>實際上的</em>type去找method執行，如果沒有就是依據變數的type</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>x</span><span class=p>()</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=k>virtual</span> <span class=kt>void</span> <span class=nf>y</span><span class=p>()</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;y</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span> <span class=o>:</span> <span class=k>public</span> <span class=n>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>x</span><span class=p>()</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;x2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=k>virtual</span> <span class=kt>void</span> <span class=nf>y</span><span class=p>()</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;y2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>A</span><span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=n>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>();</span> <span class=c1>// x
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>a</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>();</span> <span class=c1>// y2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>((</span><span class=n>B</span><span class=o>*</span><span class=p>)</span><span class=n>a</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>();</span> <span class=c1>// x2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=n>a</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意: <strong>constructor不能是virtual</strong>
constructor本來就是從new時的type建立回去，所以不需要virtual
另一個說法是new物件時還沒有virtual的table，所以不能是virtual</p><p>但destructor需要，因為如果像上面的code去刪一個parent指標，時沒有virtual，會從parent的destructor去跑，這就尷尬了</p><h3 id=object-slicing>object slicing<a hidden class=anchor aria-hidden=true href=#object-slicing>#</a></h3><p>就是從child轉到parent會讓child的東西不見，這就是slicing
但是，因為cpp有copy，事情可能會搞砸</p><p>如果從child到parent是用copy的話，就不會根據原本的資料去找attribute與method，同時如果要轉回去也會出事(要記得用dynamic_casr轉啊)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>m_value</span><span class=p>{};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_value</span><span class=p>{</span> <span class=n>value</span> <span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>getName</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;Base&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>getValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_value</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Derived</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=o>:</span> <span class=n>Base</span><span class=p>{</span> <span class=n>value</span> <span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>getName</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;Derived&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printName</span><span class=p>(</span><span class=k>const</span> <span class=n>Base</span> <span class=n>base</span><span class=p>)</span> <span class=c1>// note: base passed by value, not reference
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;I am a &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>base</span><span class=p>.</span><span class=n>getName</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Derived</span> <span class=n>derived</span><span class=p>{</span> <span class=mi>5</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;derived is a &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>derived</span><span class=p>.</span><span class=n>getName</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; and has value &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>derived</span><span class=p>.</span><span class=n>getValue</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>Base</span> <span class=o>&amp;</span><span class=n>ref</span><span class=p>{</span> <span class=n>derived</span> <span class=p>};</span> <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;ref is a &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ref</span><span class=p>.</span><span class=n>getName</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; and has value &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ref</span><span class=p>.</span><span class=n>getValue</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>Base</span> <span class=o>*</span><span class=n>ptr</span><span class=p>{</span> <span class=o>&amp;</span><span class=n>derived</span> <span class=p>};</span> <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;ptr is a &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>getName</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; and has value &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>getValue</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Base</span> <span class=n>base</span><span class=p>{</span> <span class=n>derived</span> <span class=p>};</span> <span class=c1>// be sliced
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;base is a &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>base</span><span class=p>.</span><span class=n>getName</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; and has value &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>base</span><span class=p>.</span><span class=n>getValue</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printName</span><span class=p>(</span><span class=n>derived</span><span class=p>);</span> <span class=c1>// be sliced
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=the-rule-of-five>the rule of five<a hidden class=anchor aria-hidden=true href=#the-rule-of-five>#</a></h3><p>如果定義了自己的</p><ol><li>destructor</li><li>copy constructor</li><li>copy assignment</li></ol><p>就要把其他的也一起定義完</p><p>不過因為C++11有move，所以要多兩個</p><ol><li>move constructor</li><li>move assignment</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>rule_of_five</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>cstring</span><span class=p>;</span> <span class=c1>// raw pointer used as a handle to a dynamically-allocated memory block
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>rule_of_five</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>s</span> <span class=o>=</span> <span class=s>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>cstring</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>cstring</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>      <span class=c1>// allocate
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>std</span><span class=o>::</span><span class=n>memcpy</span><span class=p>(</span><span class=n>cstring</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span> <span class=c1>// populate 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>rule_of_five</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>cstring</span><span class=p>;</span>  <span class=c1>// deallocate
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>rule_of_five</span><span class=p>(</span><span class=k>const</span> <span class=n>rule_of_five</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=c1>// copy constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>:</span> <span class=n>rule_of_five</span><span class=p>(</span><span class=n>other</span><span class=p>.</span><span class=n>cstring</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>rule_of_five</span><span class=p>(</span><span class=n>rule_of_five</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=k>noexcept</span> <span class=c1>// move constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>:</span> <span class=n>cstring</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>exchange</span><span class=p>(</span><span class=n>other</span><span class=p>.</span><span class=n>cstring</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>rule_of_five</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>rule_of_five</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=c1>// copy assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=n>rule_of_five</span><span class=p>(</span><span class=n>other</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>rule_of_five</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>rule_of_five</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=k>noexcept</span> <span class=c1>// move assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>cstring</span><span class=p>,</span> <span class=n>other</span><span class=p>.</span><span class=n>cstring</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>// alternatively, replace both assignment operators with 
</span></span></span><span class=line><span class=cl><span class=c1>//  rule_of_five&amp; operator=(rule_of_five other) noexcept
</span></span></span><span class=line><span class=cl><span class=c1>//  {
</span></span></span><span class=line><span class=cl><span class=c1>//      std::swap(cstring, other.cstring);
</span></span></span><span class=line><span class=cl><span class=c1>//      return *this;
</span></span></span><span class=line><span class=cl><span class=c1>//  }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h2 id=os-related>OS related<a hidden class=anchor aria-hidden=true href=#os-related>#</a></h2><h3 id=edge-trigger--level-trigger>Edge Trigger & Level Trigger<a hidden class=anchor aria-hidden=true href=#edge-trigger--level-trigger>#</a></h3><ul><li>Edge Trigger: 狀態變化時產生io事件</li><li>Level Trigger: 滿足條件時產生io事件</li></ul><h3 id=memory>memory<a hidden class=anchor aria-hidden=true href=#memory>#</a></h3><ul><li>memory hierarchy<ol><li>register</li><li>cache memory</li><li>main memory</li><li>HDD</li></ol></li><li>Direct Memory Access, DMA<ul><li>讓device可以直接操作記憶體，像是device把資料copy到mem去<ul><li>會導致cache不一致!! (因為直接改mem，但cache不知道)<ul><li>寫入mem時要通知cache做invalidate</li><li>讀cache時，dma已經開始(拿到最新的) 或 dma關閉(不會被改)</li></ul></li></ul></li><li>不然cpu就要中斷自己去做</li><li>由cpu啟動dma，剩下的事情就是dma controller的工作</li></ul></li></ul><h3 id=mutex--semaphore>mutex & semaphore<a hidden class=anchor aria-hidden=true href=#mutex--semaphore>#</a></h3><ul><li>mutex<ol><li>受益人數: 一人</li><li>誰能改變狀態(上鎖):
a. 還沒上鎖: 所有人
b. 上鎖了: 上鎖的人</li><li>使用場域: 保護critical zone</li></ol></li><li>semaphore<ol><li>受益人數: 看設定多少</li><li>誰能改變狀態(記數): 誰都ok</li><li>使用場域: 同步時的signal</li></ol></li></ul><h3 id=big-endian--little-endian>Big Endian & Little Endian<a hidden class=anchor aria-hidden=true href=#big-endian--little-endian>#</a></h3><p>資料放進記憶體中的時</p><ul><li>Big-Endian(Network Order): 最高位的位元組會放在最低的記憶體位址上</li><li>Little-Endian: 最高位的位元組放在最高的記憶體位址上</li></ul><p>記憶體的最高在右邊，但資料的最高在左手邊</p><pre tabindex=0><code>High -&gt; 12345678 &lt;- Low
Low -&gt; a[0], a[1], a[2], a[4] &lt;- High
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>c</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>EndianTest</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 輸出位元組順序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>printBytes</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>EndianTest</span> <span class=n>et</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>et</span><span class=p>.</span><span class=n>l</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;0x%02X &#34;</span><span class=p>,</span> <span class=n>et</span><span class=p>.</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;n&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>x</span> <span class=o>=</span> <span class=mh>0x12345678</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// big: 12, 34, 56, 78
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// little: 78, 56, 34, 12
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;0x%X 在記憶體中的儲存順序：&#34;</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printBytes</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>n</span> <span class=o>=</span> <span class=n>htonl</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;0x%X 在網路中的傳輸順序：&#34;</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printBytes</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=how-to-ipc>how to IPC<a hidden class=anchor aria-hidden=true href=#how-to-ipc>#</a></h3><ol><li>pipe(named pipe)</li><li>popen</li><li>message queue</li><li>semophore</li><li>signal</li><li>shared memory</li><li>socket</li><li>file</li></ol><h3 id=deadlock-condition>deadlock condition<a hidden class=anchor aria-hidden=true href=#deadlock-condition>#</a></h3><p>race condition: 輸出依據不受控制的事件出現順序或者出現時機
Critical section: access共享資源的code
synchronization: 協調讓thread使用Critical section在時間上一致與統一
Cache coherence: 快取一致性 (為什麼放這邊?，可以看volatile)</p><ol><li>資源唯一(互斥) => a node in a graph</li><li>不會被搶(不可搶占) => node cant be removed</li><li>拿著並等別的資源(占有且等待) => an edge to other node</li><li>別人也在等我(循環等待) => cycle</li></ol><h3 id=thread--process>thread & process<a hidden class=anchor aria-hidden=true href=#thread--process>#</a></h3><ul><li>process: OS的資源分配單位，彼此不影響</li><li>thread: 程式的執行單位，互相影響
a. a kernel thread to a user thread: linux&rsquo;s clone(child process, LWP)
b. a kernel thread to many user threads
c. many kernel threads to many user threads</li></ul><h3 id=how-to-talk-to-kernel>how to talk to kernel<a hidden class=anchor aria-hidden=true href=#how-to-talk-to-kernel>#</a></h3><ol><li>virtual filesystems(e.g. /proc, /sys, configfs, relayfs): kernel &lt;-> user, exchange data</li><li>netlink/UDP socket: kernel &lt;-> user, exchange data</li><li>mmap: kernel &lt;-> user, exchange data</li><li>syscall: user -> kernel, invoke function</li><li>ioctl: kernel &lt;-> user, exchange data</li><li>signal from kernel: kernel -> user, invoke handler</li><li>upcall: kernel -> user, invoke a function</li></ol><p><a href=https://wiki.tldp.org/kernel_user_space_howto>ref</a></p><h2 id=volatile>volatile<a hidden class=anchor aria-hidden=true href=#volatile>#</a></h2><p>就是叫compiler每次都乖乖重新拿值，不然可能有神秘的優化把變數消滅掉</p><p>用處</p><ol><li>register</li><li>在multi-thread共用的變數</li><li>一個中斷服務子程序中會訪問到的非自動變量(Non-automatic variables)</li></ol><h3 id=can-we-use-const-and-volatile-in-the-same-variable>Can we use “const” and “volatile” in the same variable?<a hidden class=anchor aria-hidden=true href=#can-we-use-const-and-volatile-in-the-same-variable>#</a></h3><p><code>extern const volatile unsigned int rt_clock;</code>
用在監看reg的值的時候</p><h2 id=malloccallocrealloc>malloc、calloc、realloc<a hidden class=anchor aria-hidden=true href=#malloccallocrealloc>#</a></h2><ul><li>malloc: 就是allocate</li><li>calloc: allocate + 初始值</li><li>realloc: resize但是不一定從原本的位置開始，所以會copy舊資料到新位置</li></ul><h2 id=pointer-size>pointer size<a hidden class=anchor aria-hidden=true href=#pointer-size>#</a></h2><p>看記憶體是幾位元的</p><ul><li>64: 8 bytes</li><li>32: 4 bytes</li></ul><h2 id=oo-in-c>OO in C<a hidden class=anchor aria-hidden=true href=#oo-in-c>#</a></h2><p>struct與透過method控制struct就是封裝
繼承要利用c的struct特性</p><p>因為struct只是去算field的offset，所以只要</p><ul><li>同一個位置</li><li>同樣長度
就可以當成child class (484與golang很像)</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// extend
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getA</span><span class=p>(</span><span class=n>A</span><span class=o>*</span> <span class=n>this</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>this</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getB</span><span class=p>(</span><span class=n>B</span><span class=o>*</span> <span class=n>this</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>this</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>,</span> <span class=n>this</span><span class=o>-&gt;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>B</span> <span class=n>y</span><span class=p>{</span><span class=mi>30</span><span class=p>,</span><span class=mi>20</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=nf>getA</span><span class=p>((</span><span class=n>A</span><span class=o>*</span><span class=p>)</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>那多形?
struct自己存實作的fucntion ptr</p><h2 id=macro>macro<a hidden class=anchor aria-hidden=true href=#macro>#</a></h2><h3 id=一些工具>一些工具<a hidden class=anchor aria-hidden=true href=#一些工具>#</a></h3><ol><li>concat</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define cons(a,b) a##b
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// cons(1,2) =&gt; 12
</span></span></span></code></pre></div><ol start=2><li>可變參數(預設參數)，如果有尾巴的逗號會被吃掉 (C99)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define foo(must, ...) _foo(must, (foo_args){.a = 8, .b = 3.14, __VA_ARGS__});
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// foo(&#39;D&#39;, .b = 9, .a = 2);
</span></span></span></code></pre></div><ol start=3><li>to_string</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define STR(s) #s
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// STR(123) =&gt; &#34;123&#34;
</span></span></span></code></pre></div><ol start=4><li>_Generic (C11, 就是泛型)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define foo(a, b)                \
</span></span></span><span class=line><span class=cl><span class=cp>    _Generic((a),                \
</span></span></span><span class=line><span class=cl><span class=cp>        int: func1,               \
</span></span></span><span class=line><span class=cl><span class=cp>        double: _Generic((b),    \
</span></span></span><span class=line><span class=cl><span class=cp>                    int : func2,  \
</span></span></span><span class=line><span class=cl><span class=cp>                    double: func3 \
</span></span></span><span class=line><span class=cl><span class=cp>                )                \
</span></span></span><span class=line><span class=cl><span class=cp>    )(a, b)
</span></span></span></code></pre></div><h3 id=使用時要注意>使用時要注意<a hidden class=anchor aria-hidden=true href=#使用時要注意>#</a></h3><ol><li>用括號</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define pow(a) (a) * (a)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// pow(1+2) =&gt; (1+2) * (1+2)
</span></span></span></code></pre></div><ol start=2><li>如果有temp變數要加大括號，不然會汙染到原本的scope</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define swap(a, b) { \
</span></span></span><span class=line><span class=cl><span class=cp>    int temp = a;    \
</span></span></span><span class=line><span class=cl><span class=cp>    a = b;           \
</span></span></span><span class=line><span class=cl><span class=cp>    b = temp;        \
</span></span></span><span class=line><span class=cl><span class=cp>}
</span></span></span></code></pre></div><ol start=3><li>幫數字標上type</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define NUM (100*123*234UL)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 注意: 型別要放在數字後面!!
</span></span></span><span class=line><span class=cl><span class=c1>// U for unsigned
</span></span></span><span class=line><span class=cl><span class=c1>// L for long int or long float
</span></span></span><span class=line><span class=cl><span class=c1>// F for float
</span></span></span><span class=line><span class=cl><span class=c1>// default: double or int
</span></span></span></code></pre></div><ol start=4><li>如果要用macro在另一個macro要多一層讓macro先展開</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define A 2
</span></span></span><span class=line><span class=cl><span class=cp>#define CONS(a,b) a##b
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// CONS(A,A) =&gt; AA
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define _CONS(a,b) a##b
</span></span></span><span class=line><span class=cl><span class=cp>#define CONS_GOOD _CONS(a,b)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// CONS_GOOD(A,A) =&gt; _CONS(2,2) =&gt; 22
</span></span></span></code></pre></div><h3 id=useful-macro--case-study>useful macro & case study<a hidden class=anchor aria-hidden=true href=#useful-macro--case-study>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define debug(fmt, ...) { \
</span></span></span><span class=line><span class=cl><span class=cp>    fprintf(stderr, &#34;(%s:%d) &#34;fmt&#34;\n&#34;, __FILE__, __LINE__, ##__VA_ARGS__); \
</span></span></span><span class=line><span class=cl><span class=cp>}
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>debug</span><span class=p>(</span><span class=s>&#34;%s %d&#34;</span><span class=p>,</span> <span class=s>&#34;Shit happen!&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define hash_hash # ## #
</span></span></span><span class=line><span class=cl><span class=cp>#define mkstr(a) # a
</span></span></span><span class=line><span class=cl><span class=cp>#define in_between(a) mkstr(a)
</span></span></span><span class=line><span class=cl><span class=cp>#define join(c, d) in_between(c hash_hash d)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>//join(x, y)
</span></span></span><span class=line><span class=cl><span class=c1>//in_between(x hash_hash y)
</span></span></span><span class=line><span class=cl><span class=c1>//in_between(x ## y)
</span></span></span><span class=line><span class=cl><span class=c1>//mkstr(x ## y)
</span></span></span></code></pre></div><p>default args: 在函數做設定</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define f(...) def_f((f_args) {__VA_ARGS__})
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>f_args</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>real_f</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>double</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%i %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>def_f</span><span class=p>(</span><span class=n>f_args</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>args</span><span class=p>.</span><span class=n>i</span> <span class=o>?</span> <span class=n>args</span><span class=p>.</span><span class=nl>i</span> <span class=p>:</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>j</span> <span class=o>=</span> <span class=n>args</span><span class=p>.</span><span class=n>j</span> <span class=o>?</span> <span class=n>args</span><span class=p>.</span><span class=nl>j</span> <span class=p>:</span> <span class=mf>10.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>real_f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>(.</span><span class=n>j</span><span class=o>=</span><span class=mf>100.2</span><span class=p>,</span> <span class=p>.</span><span class=n>i</span><span class=o>=</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>(.</span><span class=n>j</span><span class=o>=</span><span class=mf>45.3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>(</span><span class=mi>12</span><span class=p>,);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>default args: 在struct(macro展開時)做設定</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define f(...) def_f((f_args){.i=10, .j=10.5, __VA_ARGS__})
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>f_args</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>real_f</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>double</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%i %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>def_f</span><span class=p>(</span><span class=n>f_args</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>real_f</span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>i</span><span class=p>,</span><span class=n>x</span><span class=p>.</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//f(3,8);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>f</span><span class=p>(.</span><span class=n>j</span><span class=o>=</span><span class=mf>100.2</span><span class=p>,</span> <span class=p>.</span><span class=n>i</span><span class=o>=</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//f(2);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>f</span><span class=p>(.</span><span class=n>j</span><span class=o>=</span><span class=mf>45.3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//f(12,);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=floating-point>floating point<a hidden class=anchor aria-hidden=true href=#floating-point>#</a></h2><ol><li>不要直接比較，要變成看相對誤差</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>abs</span><span class=p>((</span><span class=mf>0.1</span><span class=o>+</span><span class=mf>0.2</span><span class=p>)</span><span class=o>-</span><span class=mf>0.3</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>epsilon</span>
</span></span></code></pre></div><ol start=2><li><p>少用float做直接運算，轉成整數</p></li><li><p>使用另外設計的Lib</p></li><li><p>調整算式</p></li></ol><p><a href=https://hackmd.io/@sysprog/c-floating-point>豐富的case</a></p><h2 id=isr>ISR<a hidden class=anchor aria-hidden=true href=#isr>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__interrupt</span> <span class=kt>double</span> <span class=nf>compute_area</span><span class=p>(</span><span class=kt>double</span> <span class=n>radius</span><span class=p>)</span> <span class=c1>// 1. no args (這應該是上半部)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>area</span> <span class=o>=</span> <span class=n>PI</span> <span class=o>*</span> <span class=n>radius</span> <span class=o>*</span> <span class=n>radius</span><span class=p>;</span> <span class=c1>// 2. kernel space 用float?!
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Area = %f&#34;</span><span class=err>，</span> <span class=n>area</span><span class=p>);</span> <span class=c1>// 3. 在中斷跑IO!?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>area</span><span class=p>;</span> <span class=c1>// 4. irq沒有return，syscall有
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=pitfall>pitfall<a hidden class=anchor aria-hidden=true href=#pitfall>#</a></h2><h3 id=auto-cast>auto cast<a hidden class=anchor aria-hidden=true href=#auto-cast>#</a></h3><p>有unsigned就會自動變成unsigned</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=o>-</span><span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>a</span><span class=o>+</span><span class=n>b</span> <span class=o>&gt;</span> <span class=mi>6</span><span class=p>)</span> <span class=o>?</span> <span class=n>puts</span><span class=p>(</span><span class=s>&#34;&gt; 6&#34;</span><span class=p>)</span> <span class=o>:</span> <span class=n>puts</span><span class=p>(</span><span class=s>&#34;&lt;= 6&#34;</span><span class=p>);</span> <span class=c1>// &gt; 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=type-size>type size<a hidden class=anchor aria-hidden=true href=#type-size>#</a></h3><p>只有char確定是1byte!!</p><p>所以下面的code可能會出事，因為<code>unsigned int</code>不一定是4bytes</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>zero</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>compzero</span> <span class=o>=</span> <span class=mh>0xFFFF</span><span class=p>;</span> <span class=cm>/*1&#39;s complement of zero */</span>
</span></span></code></pre></div><table><thead><tr><th>type</th><th>size</th></tr></thead><tbody><tr><td>char</td><td>1 byte</td></tr><tr><td>unsigned char</td><td>1 byte</td></tr><tr><td>signed char</td><td>1 byte</td></tr><tr><td>int</td><td>2 or 4 bytes</td></tr><tr><td>unsigned int</td><td>2 or 4 bytes</td></tr><tr><td>short</td><td>2 bytes</td></tr><tr><td>unsigned short</td><td>2 bytes</td></tr><tr><td>long</td><td>8 bytes or (4bytes for 32 bit OS)</td></tr><tr><td>unsigned long</td><td>8 bytes</td></tr></tbody></table><h3 id=p--p>p++ & ++p<a hidden class=anchor aria-hidden=true href=#p--p>#</a></h3><p>就算有括號，<code>p++</code>的inc還是後做，<code>++p</code>的inc還是先做</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=o>=</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=o>=</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>++</span><span class=p>)</span><span class=o>+=</span><span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=o>++</span><span class=n>p</span><span class=p>)</span><span class=o>+=</span><span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//124 2 126 4 5
</span></span></span></code></pre></div><h3 id=typedef>typedef<a hidden class=anchor aria-hidden=true href=#typedef>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define dPS struct s *
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>s</span> <span class=o>*</span> <span class=n>tPS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>dPS</span> <span class=n>p1</span><span class=p>,</span><span class=n>p2</span><span class=p>;</span> <span class=c1>// =&gt; struct s * p1,p2;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>tPS</span> <span class=n>p3</span><span class=p>,</span><span class=n>p4</span><span class=p>;</span><span class=c1>// =&gt; struct s *p1,*p2;
</span></span></span></code></pre></div><h3 id=pointer--array-type>pointer & array type<a hidden class=anchor aria-hidden=true href=#pointer--array-type>#</a></h3><p>先看array，再看pointer，有括號就先看括號</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// An array of 10 integers
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>a</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// An array of 10 pointers to integers
</span></span></span><span class=line><span class=cl><span class=c1>// int ((*a)[10])
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>a</span><span class=p>)[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// A pointer to an array of 10 integers
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>a</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span> <span class=c1>// A pointer to a function a that takes an integer argument and returns an integer
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>a</span><span class=p>[</span><span class=mi>10</span><span class=p>])(</span><span class=kt>int</span><span class=p>);</span> <span class=c1>// An array of 10 pointers to functions that take an integer argument and return an integer
</span></span></span></code></pre></div><h3 id=const--pointer>const & pointer<a hidden class=anchor aria-hidden=true href=#const--pointer>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=k>const</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span> <span class=c1>// ptr的內容固定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span> <span class=k>const</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// 被指到的int固定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=k>const</span> <span class=o>*</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// 兩個都固定
</span></span></span></code></pre></div><h2 id=計組>計組<a hidden class=anchor aria-hidden=true href=#計組>#</a></h2><h3 id=pipeline>Pipeline<a hidden class=anchor aria-hidden=true href=#pipeline>#</a></h3><ol><li>instruction fetch</li><li>instruction decode/fetch register</li><li>instruction execute/ branch or jump</li><li>memory access</li></ol><ul><li>to mem</li></ul><ol start=5><li>write back</li></ol><ul><li>to reg</li></ul><p>因為現在是所有指令共用datapath，所以要pipeline reg讓stage去load需要的資料去完成每個階段的任務</p><h3 id=harzards>harzards<a hidden class=anchor aria-hidden=true href=#harzards>#</a></h3><ul><li>Data Hazard<ul><li>LoadStore (RAW): 還沒寫完就被讀(拿到舊的值)</li><li>StoreStore (WAW): 前面還沒寫完，後面已經寫進去了</li><li>StoreLoad (WAR): 來沒讀完就被寫(拿到未來的值)</li><li>sol<ul><li>compiler 或是 cpu的 stall</li><li>forwarding: 把需要的資訊丟到後面的pipeline reg，讓後面的stage先做事</li></ul></li></ul></li><li>Control Hazard<ul><li>if 的 bool還沒被算出來!!</li><li>sol<ul><li>stall</li><li>分支預測(猜)</li></ul></li></ul></li><li>Structural hazard<ul><li>在pipeline上指令的需要同一個資源</li><li>sol<ul><li>stall</li><li>亂序執行</li></ul></li></ul></li></ul><h2 id=network-programming>Network Programming<a hidden class=anchor aria-hidden=true href=#network-programming>#</a></h2><h3 id=server>server<a hidden class=anchor aria-hidden=true href=#server>#</a></h3><ul><li>socket<ul><li><code>new socket()</code></li></ul></li><li>bind<ul><li>填ip, port</li></ul></li><li>listen<ul><li><code>socket.start()</code></li></ul></li><li>accept (可以去看<a href=/2020/5/block-nonblock-sync-async/>block-nonblock-sync-async</a>補一下block與non-block的知識)<ul><li>loop -> get socket</li><li>read / write</li><li>close</li></ul></li></ul><h3 id=client>client<a hidden class=anchor aria-hidden=true href=#client>#</a></h3><ul><li>socket</li><li>connect</li><li>write / read</li><li>close</li></ul><h3 id=傳struct>傳struct<a hidden class=anchor aria-hidden=true href=#傳struct>#</a></h3><p>不能直接傳，大小頭、padding、type的size不一定會一樣，會可能會轉不回來</p><ol><li>轉成string</li><li>用htonl與ntohl，自己把int轉一轉</li></ol><ul><li>host order to network order long (integer, s是short integer)</li><li>network order to host order long (integer, s是short integer)</li></ul><p>float就要自己設計格式，沒有htonl與ntohl可以用，不然就是去找序列化的lib，像protobuf</p><h3 id=pipe>pipe<a hidden class=anchor aria-hidden=true href=#pipe>#</a></h3><ul><li>pipefs</li><li>create a file in pipefs, which is in mem</li><li>return 2 fd, one for writing, another for reading</li></ul><h3 id=how-tcpdump-works>how tcpdump works<a hidden class=anchor aria-hidden=true href=#how-tcpdump-works>#</a></h3><ul><li>透過libpcap的api生bpf</li></ul><h2 id=除此之外>除此之外<a hidden class=anchor aria-hidden=true href=#除此之外>#</a></h2><ul><li><a href=/2021/07/bits-trick>bit trick</a></li><li><a href=/2020/12/cpp-value-category/>lvalue, rvalue</a></li><li><a href=/2020/12/cpp-tmp/>tmp</a></li><li><a href=/2020/12/mss/>Maximum subarray</a></li><li><a href=/2021/07/linked-list-faq>linked list</a></li><li><a href=/2021/07/bst-faq>binary search tree</a></li><li><a href=/2020/12/leetcode-146-460>LRU cache</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/c/c++/>C/C++</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2020/12/saddleback-search-algorithm/><span class=title>« Prev</span><br><span>saddleback search algorithm</span>
</a><a class=next href=https://littlebees.github.io/2020/12/c-template-meta-programming%E7%AD%86%E8%A8%98/><span class=title>Next »</span><br><span>C++ template meta-programming筆記</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>