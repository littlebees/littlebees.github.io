<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>top half & bottom half & workqueue & device範例集 | 記事本</title>
<meta name=keywords content="Linux"><meta name=description content="動機
上次看完Linux Kernel Development 3rd，想說來補一下
大概有個感覺"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/07/top-half-bottom-half-workqueue-device%E7%AF%84%E4%BE%8B%E9%9B%86/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="top half & bottom half & workqueue & device範例集"><meta property="og:description" content="動機
上次看完Linux Kernel Development 3rd，想說來補一下
大概有個感覺"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/07/top-half-bottom-half-workqueue-device%E7%AF%84%E4%BE%8B%E9%9B%86/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-15T00:27:55+00:00"><meta property="article:modified_time" content="2021-07-15T00:27:55+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="top half & bottom half & workqueue & device範例集"><meta name=twitter:description content="動機
上次看完Linux Kernel Development 3rd，想說來補一下
大概有個感覺"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"top half \u0026 bottom half \u0026 workqueue \u0026 device範例集","item":"https://littlebees.github.io/2021/07/top-half-bottom-half-workqueue-device%E7%AF%84%E4%BE%8B%E9%9B%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"top half \u0026 bottom half \u0026 workqueue \u0026 device範例集","name":"top half \u0026 bottom half \u0026 workqueue \u0026 device範例集","description":"動機 上次看完Linux Kernel Development 3rd，想說來補一下 大概有個感覺\n","keywords":["Linux"],"articleBody":"動機 上次看完Linux Kernel Development 3rd，想說來補一下 大概有個感覺\nsyscall 要直接改kernel，因為是寫死的與sortirq一樣 看這裡\ntop half #include #include #include #include #include #include #include /* interrupt handler */ /* IRQ of your network card to be shared */ #define SHARED_IRQ 19 static int irq = SHARED_IRQ; module_param(irq, int, S_IRUGO); /* default delay time in top half -- try 10 to get results */ static int delay = 0; module_param(delay, int, S_IRUGO); static atomic_t counter_bh, counter_th; struct my_dat { unsigned long jiffies; /* used for timestamp */ struct tasklet_struct tsk; /* used in dynamic tasklet solution */ struct work_struct work; /* used in dynamic workqueue solution */ } my_data; static struct my_dat static irqreturn_t my_interrupt (int irq, void *dev_id) { top_half_fun(); tasklet_schedule(\u0026t_name); return IRQ_HANDLED; } static int __init my_generic_init(void) { atomic_set(\u0026counter_bh, 0); atomic_set(\u0026counter_th, 0); /* use my_data for dev_id */ if (request_irq(irq, my_interrupt, IRQF_SHARED, \"my_int\", \u0026my_data)) return -1; printk(KERN_INFO \"successfully loaded\\n\"); return 0; } static void __exit my_generic_exit(void) { synchronize_irq(irq); free_irq(irq, \u0026my_data); printk(KERN_INFO \" counter_th = %d, counter_bh = %d\\n\", atomic_read(\u0026counter_th), atomic_read(\u0026counter_bh)); printk(KERN_INFO \"successfully unloaded\\n\"); } /* https://www.cs.otago.ac.nz/cosc440/labs/lab08.pdf */ bottom half (tasklet) #include #include #include #include #include typedef struct simp_t { int i; int j; } simp; static simp t_data; /* tasklet bottom half */ static void t_fun(unsignned long t_arg) { simp *datum = \u0026t_data; printk(KERN_INFO \"Entering t_fun, datum-\u003ei = %d, jiffies = %ld\\n\", datum-\u003ei, jiffies); printk(KERN_INFO \"Entering t_fun, datum-\u003ej = %d, jiffies = %ld\\n\", datum-\u003ej, jiffies); } DECLARE_TASKLET_OLD (t_name, t_fun); static int __init my_init(void) { printk(KERN_INFO \"\\nHello: my_init loaded at address 0x%p\\n\", my_init); t_data.i = 100; t_data.j = 200; printk(KERN_INFO \"scheduling my tasklet, jiffies = %ld\\n\", jiffies); tasklet_schedule(\u0026t_name); return 0; } static void __exit my_exit(void) { printk(KERN_INFO \"\\nHello: my_exit loaded at address 0x%p\\n\", my_exit); } module_init(my_init); module_exit(my_exit); /* https://www.cs.otago.ac.nz/cosc440/labs/lab08.pdf */ bottom half (workqueue) #include #include #include MODULE_LICENSE(\"GPL\"); static struct workqueue_struct *queue; static void work_func(struct work_struct *work) { printk(KERN_INFO \"worker\\n\"); } DECLARE_WORK(work, work_func); int init_module(void) { queue = create_singlethread_workqueue(\"myworkqueue\"); queue_work(queue, \u0026work); return 0; } void cleanup_module(void) { /* why is this needed? Why flush_workqueue doesn't work? (re-insmod panics) * http://stackoverflow.com/questions/37216038/whats-the-difference-between-flush-delayed-work-and-cancel-delayed-work-sync */ /*flush_workqueue(queue);*/ cancel_work_sync(\u0026work); destroy_workqueue(queue); } /* https://github.com/cirosantilli/linux-kernel-module-cheat/blob/ad077d3943f79c0f6481dab929970613c33c31a7/kernel_module/workqueue_cheat.c */ device driver major number是裝置的編號，像用ls -l去看tty都是4 minor number是看major number決定他有什麼意義\nblock 類似array\n#include #include #include #include #include #include #include #include #include #include #ifndef SECTOR_SIZE #define SECTOR_SIZE 512 #endif static int dev_major = 0; /* Just internal representation of the our block device * can hold any useful data */ struct block_dev { sector_t capacity; u8 *data; /* Data buffer to emulate real storage device */ struct blk_mq_tag_set tag_set; struct request_queue *queue; struct gendisk *gdisk; }; /* Device instance */ static struct block_dev *block_device = NULL; static int blockdev_open(struct block_device *dev, fmode_t mode) { printk(\"\u003e\u003e\u003e blockdev_open\\n\"); return 0; } static void blockdev_release(struct gendisk *gdisk, fmode_t mode) { printk(\"\u003e\u003e\u003e blockdev_release\\n\"); } int blockdev_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd, unsigned long arg) { printk(\"ioctl cmd 0x%08x\\n\", cmd); return -ENOTTY; } /* Set block device file I/O */ static struct block_device_operations blockdev_ops = { .owner = THIS_MODULE, .open = blockdev_open, .release = blockdev_release, .ioctl = blockdev_ioctl }; /* Serve requests */ static int do_request(struct request *rq, unsigned int *nr_bytes) { int ret = 0; struct bio_vec bvec; struct req_iterator iter; struct block_dev *dev = rq-\u003eq-\u003equeuedata; loff_t pos = blk_rq_pos(rq) \u003c\u003c SECTOR_SHIFT; loff_t dev_size = (loff_t)(dev-\u003ecapacity \u003c\u003c SECTOR_SHIFT); printk(KERN_WARNING \"sblkdev: request start from sector %lld pos = %lld dev_size = %lld\\n\", blk_rq_pos(rq), pos, dev_size); /* Iterate over all requests segments */ rq_for_each_segment(bvec, rq, iter) { unsigned long b_len = bvec.bv_len; /* Get pointer to the data */ void* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; /* Simple check that we are not out of the memory bounds */ if ((pos + b_len) \u003e dev_size) { b_len = (unsigned long)(dev_size - pos); } if (rq_data_dir(rq) == WRITE) { /* Copy data to the buffer in to required position */ memcpy(dev-\u003edata + pos, b_buf, b_len); } else { /* Read data from the buffer's position */ memcpy(b_buf, dev-\u003edata + pos, b_len); } /* Increment counters */ pos += b_len; *nr_bytes += b_len; } return ret; } /* queue callback function */ static blk_status_t queue_rq(struct blk_mq_hw_ctx *hctx, const struct blk_mq_queue_data* bd) { unsigned int nr_bytes = 0; blk_status_t status = BLK_STS_OK; struct request *rq = bd-\u003erq; /* Start request serving procedure */ blk_mq_start_request(rq); if (do_request(rq, \u0026nr_bytes) != 0) { status = BLK_STS_IOERR; } /* Notify kernel about processed nr_bytes */ if (blk_update_request(rq, status, nr_bytes)) { /* Shouldn't fail */ BUG(); } /* Stop request serving procedure */ __blk_mq_end_request(rq, status); return status; } static struct blk_mq_ops mq_ops = { .queue_rq = queue_rq, }; static int __init myblock_driver_init(void) { /* Register new block device and get device major number */ dev_major = register_blkdev(dev_major, \"testblk\"); block_device = kmalloc(sizeof (struct block_dev), GFP_KERNEL); if (block_device == NULL) { printk(\"Failed to allocate struct block_dev\\n\"); unregister_blkdev(dev_major, \"testblk\"); return -ENOMEM; } /* Set some random capacity of the device */ block_device-\u003ecapacity = (112 * PAGE_SIZE) \u003e\u003e 9; /* nsectors * SECTOR_SIZE; */ /* Allocate corresponding data buffer */ block_device-\u003edata = kmalloc(block_device-\u003ecapacity \u003c\u003c 9, GFP_KERNEL); if (block_device-\u003edata == NULL) { printk(\"Failed to allocate device IO buffer\\n\"); unregister_blkdev(dev_major, \"testblk\"); kfree(block_device); return -ENOMEM; } printk(\"Initializing queue\\n\"); block_device-\u003equeue = blk_mq_init_sq_queue(\u0026block_device-\u003etag_set, \u0026mq_ops, 128, BLK_MQ_F_SHOULD_MERGE); if (block_device-\u003equeue == NULL) { printk(\"Failed to allocate device queue\\n\"); kfree(block_device-\u003edata); unregister_blkdev(dev_major, \"testblk\"); kfree(block_device); return -ENOMEM; } /* Set driver's structure as user data of the queue */ block_device-\u003equeue-\u003equeuedata = block_device; /* Allocate new disk */ block_device-\u003egdisk = alloc_disk(1); /* Set all required flags and data */ block_device-\u003egdisk-\u003eflags = GENHD_FL_NO_PART_SCAN; block_device-\u003egdisk-\u003emajor = dev_major; block_device-\u003egdisk-\u003efirst_minor = 0; block_device-\u003egdisk-\u003efops = \u0026blockdev_ops; block_device-\u003egdisk-\u003equeue = block_device-\u003equeue; block_device-\u003egdisk-\u003eprivate_data = block_device; /* Set device name as it will be represented in /dev */ strncpy(block_device-\u003egdisk-\u003edisk_name, \"blockdev\\0\", 9); printk(\"Adding disk %s\\n\", block_device-\u003egdisk-\u003edisk_name); /* Set device capacity */ set_capacity(block_device-\u003egdisk, block_device-\u003ecapacity); /* Notify kernel about new disk device */ add_disk(block_device-\u003egdisk); return 0; } static void __exit myblock_driver_exit(void) { /* Don't forget to cleanup everything */ if (block_device-\u003egdisk) { del_gendisk(block_device-\u003egdisk); put_disk(block_device-\u003egdisk); } if (block_device-\u003equeue) { blk_cleanup_queue(block_device-\u003equeue); } kfree(block_device-\u003edata); unregister_blkdev(dev_major, \"testblk\"); kfree(block_device); } module_init(myblock_driver_init); module_exit(myblock_driver_exit); MODULE_LICENSE(\"GPL\"); char stream of chars\n#include #include #include #include #include #include #include #define MAX_DEV 2 static int mychardev_open(struct inode *inode, struct file *file); static int mychardev_release(struct inode *inode, struct file *file); static long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg); static ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset); static ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset); static const struct file_operations mychardev_fops = { .owner = THIS_MODULE, .open = mychardev_open, .release = mychardev_release, .unlocked_ioctl = mychardev_ioctl, .read = mychardev_read, .write = mychardev_write }; struct mychar_device_data { struct cdev cdev; }; static int dev_major = 0; static struct class *mychardev_class = NULL; static struct mychar_device_data mychardev_data[MAX_DEV]; static int mychardev_uevent(struct device *dev, struct kobj_uevent_env *env) { add_uevent_var(env, \"DEVMODE=%#o\", 0666); return 0; } static int __init mychardev_init(void) { int err, i; dev_t dev; err = alloc_chrdev_region(\u0026dev, 0, MAX_DEV, \"mychardev\"); dev_major = MAJOR(dev); mychardev_class = class_create(THIS_MODULE, \"mychardev\"); mychardev_class-\u003edev_uevent = mychardev_uevent; for (i = 0; i \u003c MAX_DEV; i++) { cdev_init(\u0026mychardev_data[i].cdev, \u0026mychardev_fops); mychardev_data[i].cdev.owner = THIS_MODULE; cdev_add(\u0026mychardev_data[i].cdev, MKDEV(dev_major, i), 1); device_create(mychardev_class, NULL, MKDEV(dev_major, i), NULL, \"mychardev-%d\", i); } return 0; } static void __exit mychardev_exit(void) { int i; for (i = 0; i \u003c MAX_DEV; i++) { device_destroy(mychardev_class, MKDEV(dev_major, i)); } class_unregister(mychardev_class); class_destroy(mychardev_class); unregister_chrdev_region(MKDEV(dev_major, 0), MINORMASK); } static int mychardev_open(struct inode *inode, struct file *file) { printk(\"MYCHARDEV: Device open\\n\"); return 0; } static int mychardev_release(struct inode *inode, struct file *file) { printk(\"MYCHARDEV: Device close\\n\"); return 0; } static long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg) { printk(\"MYCHARDEV: Device ioctl\\n\"); return 0; } static ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset) { uint8_t *data = \"Hello from the kernel world!\\n\"; size_t datalen = strlen(data); printk(\"Reading device: %d\\n\", MINOR(file-\u003ef_path.dentry-\u003ed_inode-\u003ei_rdev)); if (count \u003e datalen) { count = datalen; } if (copy_to_user(buf, data, count)) { return -EFAULT; } return count; } static ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset) { size_t maxdatalen = 30, ncopied; uint8_t databuf[maxdatalen]; printk(\"Writing device: %d\\n\", MINOR(file-\u003ef_path.dentry-\u003ed_inode-\u003ei_rdev)); if (count \u003c maxdatalen) { maxdatalen = count; } ncopied = copy_from_user(databuf, buf, maxdatalen); if (ncopied == 0) { printk(\"Copied %zd bytes from the user\\n\", maxdatalen); } else { printk(\"Could't copy %zd bytes from the user\\n\", ncopied); } databuf[maxdatalen] = 0; printk(\"Data from the user: %s\\n\", databuf); return count; } MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"Oleg Kutkov \"); module_init(mychardev_init); module_exit(mychardev_exit); /* https://olegkutkov.me/2018/03/14/simple-linux-character-device-driver/ */ ","wordCount":"1398","inLanguage":"en","datePublished":"2021-07-15T00:27:55Z","dateModified":"2021-07-15T00:27:55Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/07/top-half-bottom-half-workqueue-device%E7%AF%84%E4%BE%8B%E9%9B%86/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">top half & bottom half & workqueue & device範例集</h1><div class=post-meta><span title='2021-07-15 00:27:55 +0000 UTC'>July 15, 2021</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#syscall aria-label=syscall>syscall</a></li><li><a href=#top-half aria-label="top half">top half</a></li><li><a href=#bottom-half-tasklet aria-label="bottom half (tasklet)">bottom half (tasklet)</a></li><li><a href=#bottom-half-workqueue aria-label="bottom half (workqueue)">bottom half (workqueue)</a></li><li><a href=#device-driver aria-label="device driver">device driver</a><ul><li><a href=#block aria-label=block>block</a></li><li><a href=#char aria-label=char>char</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>上次看完<a href=/2021/06/Linux-Kernel-Development-3rd-note>Linux Kernel Development 3rd</a>，想說來補一下
大概有個感覺</p><h2 id=syscall>syscall<a hidden class=anchor aria-hidden=true href=#syscall>#</a></h2><p>要直接改kernel，因為是寫死的與sortirq一樣
看<a href=https://hackmd.io/@combo-tw/Linux-%E8%AE%80%E6%9B%B8%E6%9C%83/%2F%40combo-tw%2FBJPoAcqQS>這裡</a></p><h2 id=top-half>top half<a hidden class=anchor aria-hidden=true href=#top-half>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/module.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/init.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/interrupt.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/delay.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/workqueue.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/kthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/slab.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* interrupt handler */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* IRQ of your network card to be shared */</span>
</span></span><span class=line><span class=cl><span class=cp>#define SHARED_IRQ 19
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=kt>int</span> <span class=n>irq</span> <span class=o>=</span> <span class=n>SHARED_IRQ</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>module_param</span><span class=p>(</span><span class=n>irq</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* default delay time in top half -- try 10 to get results */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>delay</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>module_param</span><span class=p>(</span><span class=n>delay</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>atomic_t</span> <span class=n>counter_bh</span><span class=p>,</span> <span class=n>counter_th</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>my_dat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>jiffies</span><span class=p>;</span> <span class=cm>/* used for timestamp */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>tasklet_struct</span> <span class=n>tsk</span><span class=p>;</span> <span class=cm>/* used in dynamic tasklet solution */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>work_struct</span> <span class=n>work</span><span class=p>;</span> <span class=cm>/* used in dynamic workqueue solution */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>my_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=nc>my_dat</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>irqreturn_t</span> <span class=nf>my_interrupt</span> <span class=p>(</span><span class=kt>int</span> <span class=n>irq</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>dev_id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>top_half_fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>tasklet_schedule</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>IRQ_HANDLED</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>my_generic_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>atomic_set</span><span class=p>(</span><span class=o>&amp;</span><span class=n>counter_bh</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>atomic_set</span><span class=p>(</span><span class=o>&amp;</span><span class=n>counter_th</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* use my_data for dev_id */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>request_irq</span><span class=p>(</span><span class=n>irq</span><span class=p>,</span> <span class=n>my_interrupt</span><span class=p>,</span> <span class=n>IRQF_SHARED</span><span class=p>,</span> <span class=s>&#34;my_int&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>my_data</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34;successfully loaded</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=n>__exit</span> <span class=nf>my_generic_exit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>synchronize_irq</span><span class=p>(</span><span class=n>irq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free_irq</span><span class=p>(</span><span class=n>irq</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>my_data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34; counter_th = %d, counter_bh = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>atomic_read</span><span class=p>(</span><span class=o>&amp;</span><span class=n>counter_th</span><span class=p>),</span> <span class=n>atomic_read</span><span class=p>(</span><span class=o>&amp;</span><span class=n>counter_bh</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34;successfully unloaded</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* https://www.cs.otago.ac.nz/cosc440/labs/lab08.pdf */</span>
</span></span></code></pre></div><h2 id=bottom-half-tasklet>bottom half (tasklet)<a hidden class=anchor aria-hidden=true href=#bottom-half-tasklet>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/module.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/sched.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/interrupt.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/slab.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/init.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>simp_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>simp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>simp</span> <span class=n>t_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* tasklet bottom half */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>t_fun</span><span class=p>(</span><span class=n>unsignned</span> <span class=kt>long</span> <span class=n>t_arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>simp</span> <span class=o>*</span><span class=n>datum</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>t_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34;Entering t_fun, datum-&gt;i = %d, jiffies = %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>datum</span><span class=o>-&gt;</span><span class=n>i</span><span class=p>,</span> <span class=n>jiffies</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34;Entering t_fun, datum-&gt;j = %d, jiffies = %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>datum</span><span class=o>-&gt;</span><span class=n>j</span><span class=p>,</span> <span class=n>jiffies</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DECLARE_TASKLET_OLD</span> <span class=p>(</span><span class=n>t_name</span><span class=p>,</span> <span class=n>t_fun</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>my_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>Hello: my_init loaded at address 0x%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>my_init</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>t_data</span><span class=p>.</span><span class=n>i</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t_data</span><span class=p>.</span><span class=n>j</span> <span class=o>=</span> <span class=mi>200</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34;scheduling my tasklet, jiffies = %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>jiffies</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>tasklet_schedule</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=n>__exit</span> <span class=nf>my_exit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>Hello: my_exit loaded at address 0x%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>my_exit</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>module_init</span><span class=p>(</span><span class=n>my_init</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>module_exit</span><span class=p>(</span><span class=n>my_exit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* https://www.cs.otago.ac.nz/cosc440/labs/lab08.pdf */</span>
</span></span></code></pre></div><h2 id=bottom-half-workqueue>bottom half (workqueue)<a hidden class=anchor aria-hidden=true href=#bottom-half-workqueue>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/kernel.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/module.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/workqueue.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>MODULE_LICENSE</span><span class=p>(</span><span class=s>&#34;GPL&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=nc>workqueue_struct</span> <span class=o>*</span><span class=n>queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>work_func</span><span class=p>(</span><span class=k>struct</span> <span class=nc>work_struct</span> <span class=o>*</span><span class=n>work</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&#34;worker</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DECLARE_WORK</span><span class=p>(</span><span class=n>work</span><span class=p>,</span> <span class=n>work_func</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>init_module</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>queue</span> <span class=o>=</span> <span class=n>create_singlethread_workqueue</span><span class=p>(</span><span class=s>&#34;myworkqueue&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>queue_work</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>work</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanup_module</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* why is this needed? Why flush_workqueue doesn&#39;t work? (re-insmod panics)
</span></span></span><span class=line><span class=cl><span class=cm>	 * http://stackoverflow.com/questions/37216038/whats-the-difference-between-flush-delayed-work-and-cancel-delayed-work-sync */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/*flush_workqueue(queue);*/</span>
</span></span><span class=line><span class=cl>	<span class=n>cancel_work_sync</span><span class=p>(</span><span class=o>&amp;</span><span class=n>work</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>destroy_workqueue</span><span class=p>(</span><span class=n>queue</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* https://github.com/cirosantilli/linux-kernel-module-cheat/blob/ad077d3943f79c0f6481dab929970613c33c31a7/kernel_module/workqueue_cheat.c */</span>
</span></span></code></pre></div><h2 id=device-driver>device driver<a hidden class=anchor aria-hidden=true href=#device-driver>#</a></h2><p>major number是裝置的編號，像用<code>ls -l</code>去看tty都是4
minor number是看major number決定他有什麼意義</p><h3 id=block>block<a hidden class=anchor aria-hidden=true href=#block>#</a></h3><p>類似array</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/init.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/module.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/slab.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/vmalloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/fs.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/genhd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/blkdev.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/buffer_head.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/blk-mq.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/hdreg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef SECTOR_SIZE
</span></span></span><span class=line><span class=cl><span class=cp>#define SECTOR_SIZE 512
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>dev_major</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Just internal representation of the our block device
</span></span></span><span class=line><span class=cl><span class=cm> * can hold any useful data */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>block_dev</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sector_t</span> <span class=n>capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u8</span> <span class=o>*</span><span class=n>data</span><span class=p>;</span>   <span class=cm>/* Data buffer to emulate real storage device */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>blk_mq_tag_set</span> <span class=n>tag_set</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>request_queue</span> <span class=o>*</span><span class=n>queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>gendisk</span> <span class=o>*</span><span class=n>gdisk</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Device instance */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=nc>block_dev</span> <span class=o>*</span><span class=n>block_device</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>blockdev_open</span><span class=p>(</span><span class=k>struct</span> <span class=nc>block_device</span> <span class=o>*</span><span class=n>dev</span><span class=p>,</span> <span class=n>fmode_t</span> <span class=n>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;&gt;&gt;&gt; blockdev_open</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>blockdev_release</span><span class=p>(</span><span class=k>struct</span> <span class=nc>gendisk</span> <span class=o>*</span><span class=n>gdisk</span><span class=p>,</span> <span class=n>fmode_t</span> <span class=n>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;&gt;&gt;&gt; blockdev_release</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>blockdev_ioctl</span><span class=p>(</span><span class=k>struct</span> <span class=nc>block_device</span> <span class=o>*</span><span class=n>bdev</span><span class=p>,</span> <span class=n>fmode_t</span> <span class=n>mode</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;ioctl cmd 0x%08x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=n>ENOTTY</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Set block device file I/O */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=nc>block_device_operations</span> <span class=n>blockdev_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>THIS_MODULE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>open</span> <span class=o>=</span> <span class=n>blockdev_open</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>release</span> <span class=o>=</span> <span class=n>blockdev_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>ioctl</span> <span class=o>=</span> <span class=n>blockdev_ioctl</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Serve requests */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>do_request</span><span class=p>(</span><span class=k>struct</span> <span class=nc>request</span> <span class=o>*</span><span class=n>rq</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>nr_bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>bio_vec</span> <span class=n>bvec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>req_iterator</span> <span class=n>iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>block_dev</span> <span class=o>*</span><span class=n>dev</span> <span class=o>=</span> <span class=n>rq</span><span class=o>-&gt;</span><span class=n>q</span><span class=o>-&gt;</span><span class=n>queuedata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>loff_t</span> <span class=n>pos</span> <span class=o>=</span> <span class=n>blk_rq_pos</span><span class=p>(</span><span class=n>rq</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>SECTOR_SHIFT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>loff_t</span> <span class=n>dev_size</span> <span class=o>=</span> <span class=p>(</span><span class=n>loff_t</span><span class=p>)(</span><span class=n>dev</span><span class=o>-&gt;</span><span class=n>capacity</span> <span class=o>&lt;&lt;</span> <span class=n>SECTOR_SHIFT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_WARNING</span> <span class=s>&#34;sblkdev: request start from sector %lld  pos = %lld  dev_size = %lld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>blk_rq_pos</span><span class=p>(</span><span class=n>rq</span><span class=p>),</span> <span class=n>pos</span><span class=p>,</span> <span class=n>dev_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Iterate over all requests segments */</span>
</span></span><span class=line><span class=cl>    <span class=n>rq_for_each_segment</span><span class=p>(</span><span class=n>bvec</span><span class=p>,</span> <span class=n>rq</span><span class=p>,</span> <span class=n>iter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>b_len</span> <span class=o>=</span> <span class=n>bvec</span><span class=p>.</span><span class=n>bv_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Get pointer to the data */</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span><span class=o>*</span> <span class=n>b_buf</span> <span class=o>=</span> <span class=n>page_address</span><span class=p>(</span><span class=n>bvec</span><span class=p>.</span><span class=n>bv_page</span><span class=p>)</span> <span class=o>+</span> <span class=n>bvec</span><span class=p>.</span><span class=n>bv_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Simple check that we are not out of the memory bounds */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>pos</span> <span class=o>+</span> <span class=n>b_len</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>dev_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>b_len</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=n>dev_size</span> <span class=o>-</span> <span class=n>pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>rq_data_dir</span><span class=p>(</span><span class=n>rq</span><span class=p>)</span> <span class=o>==</span> <span class=n>WRITE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* Copy data to the buffer in to required position */</span>
</span></span><span class=line><span class=cl>            <span class=n>memcpy</span><span class=p>(</span><span class=n>dev</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>pos</span><span class=p>,</span> <span class=n>b_buf</span><span class=p>,</span> <span class=n>b_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* Read data from the buffer&#39;s position */</span>
</span></span><span class=line><span class=cl>            <span class=n>memcpy</span><span class=p>(</span><span class=n>b_buf</span><span class=p>,</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>pos</span><span class=p>,</span> <span class=n>b_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Increment counters */</span>
</span></span><span class=line><span class=cl>        <span class=n>pos</span> <span class=o>+=</span> <span class=n>b_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>nr_bytes</span> <span class=o>+=</span> <span class=n>b_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* queue callback function */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>blk_status_t</span> <span class=nf>queue_rq</span><span class=p>(</span><span class=k>struct</span> <span class=nc>blk_mq_hw_ctx</span> <span class=o>*</span><span class=n>hctx</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=nc>blk_mq_queue_data</span><span class=o>*</span> <span class=n>bd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>nr_bytes</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>blk_status_t</span> <span class=n>status</span> <span class=o>=</span> <span class=n>BLK_STS_OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>request</span> <span class=o>*</span><span class=n>rq</span> <span class=o>=</span> <span class=n>bd</span><span class=o>-&gt;</span><span class=n>rq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Start request serving procedure */</span>
</span></span><span class=line><span class=cl>    <span class=n>blk_mq_start_request</span><span class=p>(</span><span class=n>rq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>do_request</span><span class=p>(</span><span class=n>rq</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>nr_bytes</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>status</span> <span class=o>=</span> <span class=n>BLK_STS_IOERR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Notify kernel about processed nr_bytes */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>blk_update_request</span><span class=p>(</span><span class=n>rq</span><span class=p>,</span> <span class=n>status</span><span class=p>,</span> <span class=n>nr_bytes</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Shouldn&#39;t fail */</span>
</span></span><span class=line><span class=cl>        <span class=n>BUG</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Stop request serving procedure */</span>
</span></span><span class=line><span class=cl>    <span class=n>__blk_mq_end_request</span><span class=p>(</span><span class=n>rq</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=nc>blk_mq_ops</span> <span class=n>mq_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>queue_rq</span> <span class=o>=</span> <span class=n>queue_rq</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>myblock_driver_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Register new block device and get device major number */</span>
</span></span><span class=line><span class=cl>    <span class=n>dev_major</span> <span class=o>=</span> <span class=n>register_blkdev</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=s>&#34;testblk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span> <span class=o>=</span> <span class=n>kmalloc</span><span class=p>(</span><span class=k>sizeof</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>block_dev</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>block_device</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Failed to allocate struct block_dev</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>unregister_blkdev</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=s>&#34;testblk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Set some random capacity of the device */</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>capacity</span> <span class=o>=</span> <span class=p>(</span><span class=mi>112</span> <span class=o>*</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>9</span><span class=p>;</span> <span class=cm>/* nsectors * SECTOR_SIZE; */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Allocate corresponding data buffer */</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>kmalloc</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>capacity</span> <span class=o>&lt;&lt;</span> <span class=mi>9</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Failed to allocate device IO buffer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>unregister_blkdev</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=s>&#34;testblk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>kfree</span><span class=p>(</span><span class=n>block_device</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Initializing queue</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>queue</span> <span class=o>=</span> <span class=n>blk_mq_init_sq_queue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>tag_set</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mq_ops</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=n>BLK_MQ_F_SHOULD_MERGE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>queue</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Failed to allocate device queue</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>kfree</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>unregister_blkdev</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=s>&#34;testblk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>kfree</span><span class=p>(</span><span class=n>block_device</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Set driver&#39;s structure as user data of the queue */</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>queuedata</span> <span class=o>=</span> <span class=n>block_device</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Allocate new disk */</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span> <span class=o>=</span> <span class=n>alloc_disk</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Set all required flags and data */</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>GENHD_FL_NO_PART_SCAN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=o>-&gt;</span><span class=n>major</span> <span class=o>=</span> <span class=n>dev_major</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=o>-&gt;</span><span class=n>first_minor</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=o>-&gt;</span><span class=n>fops</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>blockdev_ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=o>-&gt;</span><span class=n>queue</span> <span class=o>=</span> <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=o>-&gt;</span><span class=n>private_data</span> <span class=o>=</span> <span class=n>block_device</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Set device name as it will be represented in /dev */</span>
</span></span><span class=line><span class=cl>    <span class=n>strncpy</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=o>-&gt;</span><span class=n>disk_name</span><span class=p>,</span> <span class=s>&#34;blockdev</span><span class=se>\0</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>9</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Adding disk %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=o>-&gt;</span><span class=n>disk_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Set device capacity */</span>
</span></span><span class=line><span class=cl>    <span class=n>set_capacity</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=p>,</span> <span class=n>block_device</span><span class=o>-&gt;</span><span class=n>capacity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Notify kernel about new disk device */</span>
</span></span><span class=line><span class=cl>    <span class=n>add_disk</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=n>__exit</span> <span class=nf>myblock_driver_exit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Don&#39;t forget to cleanup everything */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>del_gendisk</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>put_disk</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>gdisk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>queue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>blk_cleanup_queue</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>queue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>kfree</span><span class=p>(</span><span class=n>block_device</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>unregister_blkdev</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=s>&#34;testblk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kfree</span><span class=p>(</span><span class=n>block_device</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>module_init</span><span class=p>(</span><span class=n>myblock_driver_init</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>module_exit</span><span class=p>(</span><span class=n>myblock_driver_exit</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>MODULE_LICENSE</span><span class=p>(</span><span class=s>&#34;GPL&#34;</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=char>char<a hidden class=anchor aria-hidden=true href=#char>#</a></h3><p>stream of chars</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/init.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/module.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/cdev.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/device.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/kernel.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/uaccess.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/fs.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_DEV 2
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>mychardev_open</span><span class=p>(</span><span class=k>struct</span> <span class=nc>inode</span> <span class=o>*</span><span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>mychardev_release</span><span class=p>(</span><span class=k>struct</span> <span class=nc>inode</span> <span class=o>*</span><span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>long</span> <span class=nf>mychardev_ioctl</span><span class=p>(</span><span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>ssize_t</span> <span class=nf>mychardev_read</span><span class=p>(</span><span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=n>loff_t</span> <span class=o>*</span><span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>ssize_t</span> <span class=nf>mychardev_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=n>loff_t</span> <span class=o>*</span><span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=nc>file_operations</span> <span class=n>mychardev_fops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>owner</span>      <span class=o>=</span> <span class=n>THIS_MODULE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>open</span>       <span class=o>=</span> <span class=n>mychardev_open</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>release</span>    <span class=o>=</span> <span class=n>mychardev_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>unlocked_ioctl</span> <span class=o>=</span> <span class=n>mychardev_ioctl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>read</span>       <span class=o>=</span> <span class=n>mychardev_read</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>write</span>       <span class=o>=</span> <span class=n>mychardev_write</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>mychar_device_data</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>cdev</span> <span class=n>cdev</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>dev_major</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=nc>class</span> <span class=o>*</span><span class=n>mychardev_class</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=nc>mychar_device_data</span> <span class=n>mychardev_data</span><span class=p>[</span><span class=n>MAX_DEV</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>mychardev_uevent</span><span class=p>(</span><span class=k>struct</span> <span class=nc>device</span> <span class=o>*</span><span class=n>dev</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>kobj_uevent_env</span> <span class=o>*</span><span class=n>env</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>add_uevent_var</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=s>&#34;DEVMODE=%#o&#34;</span><span class=p>,</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>mychardev_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>err</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>dev_t</span> <span class=n>dev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>err</span> <span class=o>=</span> <span class=n>alloc_chrdev_region</span><span class=p>(</span><span class=o>&amp;</span><span class=n>dev</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>MAX_DEV</span><span class=p>,</span> <span class=s>&#34;mychardev&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dev_major</span> <span class=o>=</span> <span class=n>MAJOR</span><span class=p>(</span><span class=n>dev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mychardev_class</span> <span class=o>=</span> <span class=n>class_create</span><span class=p>(</span><span class=n>THIS_MODULE</span><span class=p>,</span> <span class=s>&#34;mychardev&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mychardev_class</span><span class=o>-&gt;</span><span class=n>dev_uevent</span> <span class=o>=</span> <span class=n>mychardev_uevent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAX_DEV</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cdev_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mychardev_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>cdev</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mychardev_fops</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mychardev_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>cdev</span><span class=p>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>THIS_MODULE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>cdev_add</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mychardev_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>cdev</span><span class=p>,</span> <span class=n>MKDEV</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=n>i</span><span class=p>),</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>device_create</span><span class=p>(</span><span class=n>mychardev_class</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>MKDEV</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=n>i</span><span class=p>),</span> <span class=nb>NULL</span><span class=p>,</span> <span class=s>&#34;mychardev-%d&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=n>__exit</span> <span class=nf>mychardev_exit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAX_DEV</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>device_destroy</span><span class=p>(</span><span class=n>mychardev_class</span><span class=p>,</span> <span class=n>MKDEV</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>class_unregister</span><span class=p>(</span><span class=n>mychardev_class</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>class_destroy</span><span class=p>(</span><span class=n>mychardev_class</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>unregister_chrdev_region</span><span class=p>(</span><span class=n>MKDEV</span><span class=p>(</span><span class=n>dev_major</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=n>MINORMASK</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>mychardev_open</span><span class=p>(</span><span class=k>struct</span> <span class=nc>inode</span> <span class=o>*</span><span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;MYCHARDEV: Device open</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>mychardev_release</span><span class=p>(</span><span class=k>struct</span> <span class=nc>inode</span> <span class=o>*</span><span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;MYCHARDEV: Device close</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>long</span> <span class=nf>mychardev_ioctl</span><span class=p>(</span><span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;MYCHARDEV: Device ioctl</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>ssize_t</span> <span class=nf>mychardev_read</span><span class=p>(</span><span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=n>loff_t</span> <span class=o>*</span><span class=n>offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=s>&#34;Hello from the kernel world!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>datalen</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Reading device: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MINOR</span><span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_path</span><span class=p>.</span><span class=n>dentry</span><span class=o>-&gt;</span><span class=n>d_inode</span><span class=o>-&gt;</span><span class=n>i_rdev</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&gt;</span> <span class=n>datalen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>=</span> <span class=n>datalen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>count</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>ssize_t</span> <span class=nf>mychardev_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=n>loff_t</span> <span class=o>*</span><span class=n>offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>maxdatalen</span> <span class=o>=</span> <span class=mi>30</span><span class=p>,</span> <span class=n>ncopied</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>databuf</span><span class=p>[</span><span class=n>maxdatalen</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Writing device: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MINOR</span><span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_path</span><span class=p>.</span><span class=n>dentry</span><span class=o>-&gt;</span><span class=n>d_inode</span><span class=o>-&gt;</span><span class=n>i_rdev</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&lt;</span> <span class=n>maxdatalen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>maxdatalen</span> <span class=o>=</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ncopied</span> <span class=o>=</span> <span class=n>copy_from_user</span><span class=p>(</span><span class=n>databuf</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>maxdatalen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ncopied</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Copied %zd bytes from the user</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>maxdatalen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Could&#39;t copy %zd bytes from the user</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ncopied</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>databuf</span><span class=p>[</span><span class=n>maxdatalen</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;Data from the user: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>databuf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MODULE_LICENSE</span><span class=p>(</span><span class=s>&#34;GPL&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>MODULE_AUTHOR</span><span class=p>(</span><span class=s>&#34;Oleg Kutkov &lt;elenbert@gmail.com&gt;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>module_init</span><span class=p>(</span><span class=n>mychardev_init</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>module_exit</span><span class=p>(</span><span class=n>mychardev_exit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* https://olegkutkov.me/2018/03/14/simple-linux-character-device-driver/ */</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/07/leetcode-15-3sum/><span class=title>« Prev</span><br><span>leetcode-15 - 3Sum</span>
</a><a class=next href=https://littlebees.github.io/2021/07/leetcode-141-linked-list-cycle/><span class=title>Next »</span><br><span>leetcode-141 - Linked List Cycle</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>