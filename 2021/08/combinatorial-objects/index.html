<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>combinatorial-objects | 記事本</title>
<meta name=keywords content><meta name=description content="動機
寫給自己的leetcode筆記"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/08/combinatorial-objects/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/08/combinatorial-objects/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="combinatorial-objects"><meta property="og:description" content="動機
寫給自己的leetcode筆記"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/08/combinatorial-objects/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-03T20:25:09+00:00"><meta property="article:modified_time" content="2021-08-03T20:25:09+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="combinatorial-objects"><meta name=twitter:description content="動機
寫給自己的leetcode筆記"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"combinatorial-objects","item":"https://littlebees.github.io/2021/08/combinatorial-objects/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"combinatorial-objects","name":"combinatorial-objects","description":"動機 寫給自己的leetcode筆記\n","keywords":[],"articleBody":"動機 寫給自己的leetcode筆記\n搜尋與走訪 一個是找有沒有，一個是記下所有符合條件的東西\n但本質都一樣，都要讓狀態變化，去看對不對，而走訪就是把資料拆分成一定單位\n怎麼拆分就是依據需要的狀態(題目需求)與本身是什麼資料結構(List, Tree, Graph)\n搜尋範圍 讓搜尋範圍合理的改變(把不需要的劃掉，或是保留可能性)\n太小變大 太大變小 用完後變小 並保持住需要的屬性(order, 大小, 回文, 題目定的規則) 拆分的方式 List traversal 頭到尾 (可以看成時間，見188) greedy (看class schedule 3) 選大 (結果最大) 選小 (保留可能性) 找出限制，以此sort，而這個限制就是構成搜尋範圍的要素 從中點走(一半) binary search divide and conquer 從中點往外擴 兩邊左右走 two pointer sublist \u0026 range sliding window prefix sum 有序 sort heap 多list合一 trie merge pointer as each list mutual recursion 把DP想成一個list(或是說做完動作後的狀態)，之後開始merge 188. Best Time to Buy and Sell Stock IV tree 根與子樹 DFS 前中後序 (greedy) threading DP \u0026 記憶法 DP想成stream Binary search tree 大小 數字範圍 BFS level by level BFS DFS with other pointer 左到右、右到左 DFS Line sweeping graph 起點終點 DFS BFS 外到內，內到外 BFS math \u0026 bit operation xor even \u0026 odd random 平均的出現 bit 與 bit之間是獨立的，如果不是當成list用就是一起用bit operation 為了保持條件操作，進而平攤操作 1172. Dinner Plate Stacks 綜合技 用別的資料結構描述其他變數 class schedule 3 把資料encode在同一個資料結構上以合併走訪 Sort Items by Groups Respecting Dependencies Prefix and Suffix Search ","wordCount":"139","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-08-03T20:25:09Z","dateModified":"2021-08-03T20:25:09Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/08/combinatorial-objects/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">combinatorial-objects</h1><div class=post-meta><span title='2021-08-03 20:25:09 +0000 UTC'>August 3, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e6%90%9c%e5%b0%8b%e8%88%87%e8%b5%b0%e8%a8%aa aria-label=搜尋與走訪>搜尋與走訪</a></li><li><a href=#%e6%90%9c%e5%b0%8b%e7%af%84%e5%9c%8d aria-label=搜尋範圍>搜尋範圍</a></li><li><a href=#%e6%8b%86%e5%88%86%e7%9a%84%e6%96%b9%e5%bc%8f aria-label=拆分的方式>拆分的方式</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>寫給自己的leetcode筆記</p><h2 id=搜尋與走訪>搜尋與走訪<a hidden class=anchor aria-hidden=true href=#搜尋與走訪>#</a></h2><p>一個是找有沒有，一個是記下所有符合條件的東西</p><p>但本質都一樣，都要讓狀態變化，去看對不對，而走訪就是把資料拆分成一定單位</p><p>怎麼拆分就是依據需要的狀態(題目需求)與本身是什麼資料結構(List, Tree, Graph)</p><h2 id=搜尋範圍>搜尋範圍<a hidden class=anchor aria-hidden=true href=#搜尋範圍>#</a></h2><p>讓搜尋範圍合理的改變(把不需要的劃掉，或是保留可能性)</p><ul><li>太小變大</li><li>太大變小</li><li>用完後變小
並<em>保持</em>住需要的屬性(order, 大小, 回文, 題目定的規則)</li></ul><h2 id=拆分的方式>拆分的方式<a hidden class=anchor aria-hidden=true href=#拆分的方式>#</a></h2><p><img loading=lazy src=https://i.imgur.com/OzEteVz.png alt></p><ul><li>List<ul><li>traversal<ul><li>頭到尾 (可以看成時間，見188)<ul><li>greedy (看class schedule 3)<ul><li>選大 (結果最大)</li><li>選小 (保留可能性)<ul><li>找出限制，以此sort，而這個限制就是構成搜尋範圍的要素</li></ul></li></ul></li></ul></li><li>從中點走(一半)<ul><li>binary search</li><li>divide and conquer<ul><li>從中點往外擴</li></ul></li></ul></li><li>兩邊左右走<ul><li>two pointer</li></ul></li><li>sublist & range<ul><li>sliding window</li><li>prefix sum</li></ul></li><li>有序<ul><li>sort</li><li>heap</li></ul></li></ul></li><li>多list合一<ul><li>trie</li><li>merge</li><li>pointer as each list</li><li>mutual recursion<ul><li>把DP想成一個list(或是說做完動作後的狀態)，之後開始merge</li><li><code>188. Best Time to Buy and Sell Stock IV</code></li></ul></li></ul></li></ul></li><li>tree<ul><li>根與子樹<ul><li>DFS<ul><li>前中後序 (greedy)<ul><li>threading</li></ul></li><li>DP & 記憶法<ul><li>DP想成stream</li></ul></li><li>Binary search tree<ul><li>大小</li><li>數字範圍</li></ul></li></ul></li><li>BFS</li></ul></li><li>level by level<ul><li>BFS</li><li>DFS with other pointer</li></ul></li><li>左到右、右到左<ul><li>DFS</li><li>Line sweeping</li></ul></li></ul></li><li>graph<ul><li>起點終點<ul><li>DFS</li><li>BFS</li></ul></li><li>外到內，內到外<ul><li>BFS</li></ul></li></ul></li><li>math & bit operation<ul><li>xor</li><li>even & odd</li><li>random<ul><li>平均的出現</li></ul></li><li>bit 與 bit之間是獨立的，如果不是當成list用就是一起用bit operation</li><li>為了保持條件操作，進而平攤操作<ul><li><code>1172. Dinner Plate Stacks</code></li></ul></li></ul></li><li>綜合技<ul><li>用別的資料結構描述其他變數<ul><li>class schedule 3</li></ul></li><li>把資料encode在同一個資料結構上以合併走訪<ul><li>Sort Items by Groups Respecting Dependencies</li><li>Prefix and Suffix Search</li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/08/leetcode-995-minimum-number-of-k-consecutive-bit-flips/><span class=title>« Prev</span><br><span>leetcode-995 - Minimum Number of K Consecutive Bit Flips</span>
</a><a class=next href=https://littlebees.github.io/2021/08/%E6%9C%80%E7%9F%AD%E8%B7%9D%E9%9B%A2%E6%BC%94%E7%AE%97%E6%B3%95%E7%B0%A1%E5%96%AE%E7%AD%86%E8%A8%98/><span class=title>Next »</span><br><span>最短距離演算法簡單筆記</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>