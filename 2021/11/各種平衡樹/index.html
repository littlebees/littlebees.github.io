<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>各種平衡樹 | 記事本</title>
<meta name=keywords content><meta name=description content="動機
補完以前的記憶，下面會介紹

經典款: red-black tree

但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種


rotation base: splay tree
merge/split base: treap
"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/11/%E5%90%84%E7%A8%AE%E5%B9%B3%E8%A1%A1%E6%A8%B9/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/11/%E5%90%84%E7%A8%AE%E5%B9%B3%E8%A1%A1%E6%A8%B9/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="各種平衡樹"><meta property="og:description" content="動機
補完以前的記憶，下面會介紹

經典款: red-black tree

但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種


rotation base: splay tree
merge/split base: treap
"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/11/%E5%90%84%E7%A8%AE%E5%B9%B3%E8%A1%A1%E6%A8%B9/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-17T21:51:31+00:00"><meta property="article:modified_time" content="2021-11-17T21:51:31+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="各種平衡樹"><meta name=twitter:description content="動機
補完以前的記憶，下面會介紹

經典款: red-black tree

但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種


rotation base: splay tree
merge/split base: treap
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"各種平衡樹","item":"https://littlebees.github.io/2021/11/%E5%90%84%E7%A8%AE%E5%B9%B3%E8%A1%A1%E6%A8%B9/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"各種平衡樹","name":"各種平衡樹","description":"動機 補完以前的記憶，下面會介紹\n經典款: red-black tree 但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種 rotation base: splay tree merge/split base: treap ","keywords":[],"articleBody":"動機 補完以前的記憶，下面會介紹\n經典款: red-black tree 但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種 rotation base: splay tree merge/split base: treap red-black tree 只要符合下面兩個限制的tree就是red-black tree\n紅的不會和紅的接在一起 雙紅矛盾 從根到任意leaf的路徑長度都一樣長 黑高矛盾 (不等高) insert (雙紅矛盾) insert如何不破壞兩個條件?\n黑高矛盾: 每次都插入紅的 雙紅矛盾:\n插入點是root，child有紅 把root換成黑 插入點是child (parent是黑的，並假設插在左邊) 左的child是紅的: 直接右旋 右的child是紅的: 左旋再右旋 插右邊的case? 這是對稱的，所以不列了\n可以注意到，第2個case的所有case的結果都會是\n根是紅的 像這種/\\形狀 剛剛提到左旋與右旋，來完成再平衡，但是haskell可以直接build資料，所以…\nblacken Nil = Nil blacken (Node _ value left right) = Node Black value left right insert x root = blacken $ insert' root where insert' Nil = Node Red x Nil Nil insert' root@(Node color y left right) | x \u003c y = balance color y (insert' left) right | x \u003e y = balance color y left (insert' right) | otherwise = root -- left-right balance Black z (Node Red x a (Node Red y b c)) d = Node Red y (Node Black x a b) (Node Black z c d) -- left-left balance Black z (Node Red y (Node Red x a b) c) d = Node Red y (Node Black x a b) (Node Black z c d) -- right-left balance Black x a (Node Red y b (Node Red z c d)) = Node Red y (Node Black x a b) (Node Black z c d) -- right-right balance Black x a (Node Red z (Node Red y b c) d) = Node Red y (Node Black x a b) (Node Black z c d) balance color value left right = Node color value left right delete (黑高矛盾) delete就是BST的delete\n在leaf: 換成nil 只有一個child: 把唯一個child拉上去 兩個child: 右child最小的換上來，再把它刪掉 所以現在重點是換下去的那個點怎麼刪\n刪的是\n紅的: 沒事 黑的: 數量可能不對 (黑高矛盾) (把紅的看成收束下面的兩個child成一條長度，因為兩邊的長度一樣) (紅的可以輕易變成黑的，但黑的不行直接變成紅的) 要刪的是黑的，所以可以從parent與neighbor的顏色生出4種case\nroot: red root: black neighbor: red impossible 左旋，原本的parent變紅 neighbor: black 原本的parent變黑，neighbor變紅 neighbor變紅 neighbor變紅，不會觸發雙紅矛盾? 有可能，如果兩個child都是黑的就沒事，其中一個是紅的就要處理了\n只有右邊是紅、兩個紅: 左旋 (把長度補回去)，把紅的標成黑 只有左邊是紅: 先左旋，轉成一條就可以用前面的方法了 isBlack (Node Red _ _ _) = False isBlack _ = True balL color y (left, True) right = (Node color y left right, True) balL color y (left, False) right = balL' color y left right balL' color1 p n (Node color2 s sl sr) -- neighbor: red, root: black | color2 == Red = balL Black s (balL' Red p n sl) sr -- neighbor: black, root: black OR red | isBlack sl \u0026\u0026 isBlack sr = (Node Black p n (Node Red s sl sr), color1 == Red) -- 只有右邊是紅、兩個紅 | not (isBlack sr) = (Node color1 s (Node Black p n sl) (blacken sr), True) -- 只有左邊是紅 | otherwise = let (Node Red x sll slr) = sl in balL' color1 p n (Node Black x sll (Node Red s slr sr)) 把剩下的列完\nfindMin (Node _ x Nil _) = x findMin (Node _ _ left _) = findMin left balR color y left (right, True) = (Node color y left right, True) balR color y left (right, False) = balR' color y left right balR' color1 p (Node color2 s sl sr) n | color2 == Red = balR Black s sl (balR' Red p sr n) | isBlack sl \u0026\u0026 isBlack sr = (Node Black p (Node Red s sl sr) n, color1 == Red) | not (isBlack sl) = (Node color1 s (blacken sl) (Node Black p sr n), True) | otherwise = let (Node Red x srl srr) = sr in balR' color1 p (Node Black x (Node Red s sl srl) srr) n delete x t = fst $ delete' x t where delete' x Nil = (Nil, True) delete' x root@(Node color y left right) | x \u003c y = balL color y (delete' x left) right | x \u003e y = balR color y left (delete' x right) | otherwise = deleteRoot root deleteRoot (Node color _ Nil Nil) = (Nil, color == Red) deleteRoot (Node _ _ left Nil) = (blacken left, True) deleteRoot (Node _ _ Nil right) = (blacken right, True) deleteRoot (Node color _ left right) = let m = findMin right in balR color m left (delete' m right) Ref 有人能讲清楚《Algorithms》中左倾红黑树（LLRB）删除操作的每一行代码吗？\nsplay tree 利用特別的旋轉(splay)，把最近存取的點轉到root，達成所有操作均攤log n\n如果只有父節點，也就是父節點是root，就直接rotate 但如果有祖父節點時要做下面兩個case的旋轉\nQ: 為什麼這個rotate這麼特別，如果說只是轉上去，其實不用管祖父節點? A: 這樣才能確保出來的深度是最小的\nP.S.: C++的rotate很複雜，因為一次只能assign一次，所以狀態一直變，但是利用平行賦值就好很多\n每次改node，都要確認被改過的node的left, right, parent都是對的!!\nclass Node: def __init__(self, key:int = 0, parent = None, left = None, right = None): self.key, self.parent, self.left, self.right = key, paretn, left, right def left_rotate(self): oldroot, newroot = self, self.left newroot.parent, oldroot.parent = oldroot.parent, newroot newroot.right, oldroot.left = oldroot, newroot.right if newroot.left: newroot.left.parent = oldroot if newroot.parent: if newroot.parent.left is oldroot: newroot.parent.left = newroot else: newroot.parent.right = newroot def right_rotate(self): oldroot, newroot = self, self.right newroot.parent, oldroot.parent = oldroot.parent, newroot newroot.left, oldroot.right = oldroot, newroot.right if newroot.right: newroot.right.parent = oldroot if newroot.parent: if newroot.parent.left is oldroot: newroot.parent.left = newroot else: newroot.parent.right = newroot def is_left(self, other): return self.left is other def splay(self): while self.parent: parent, grand_parent = self.parent, self.parent.parent if grand_parent: if grand_parent.is_left(self.parent): if left_child: grand_parent.left_rotation() parent.left_rotation() else: parent.right_rotation() grand_parent.left_rotation() else: if not left_child: # is right child grand_parent.right_rotation() parent.right_rotation() else: parent.left_rotation() grand_parent.right_rotation() else: # zig if parent.left is self: parent.left_rotate() else: parent.right_rotate() def find(self, key: int) -\u003e Node: ret = None if self.key == key: ret = self elif self.right and self.key \u003c key: ret = self.right.find(key) elif self.left and self.key \u003e key: ret = self.left.find(key) return ret def find_min(self): return self.left.find_min() if self.left else self.key insert與BST差不多，但是最後要splay!!\ndef insert(root: Node, key: int): ## WTF prev: Node, now: Node = None, root while now: prev, now = now, now.right if now.key \u003c key else now.left now = Node(key, prev) if prev.key \u003c now.key: prev.right = now else: prev.left = now now.splay() 基本就是BST的remove，但要先把target splay，再做BST的remove\ndef remove(root, key): ## WTF target: Node = root.find(key) def take_place(a, b): if b: b.parent = a.parent if a.parent: if a.parent.left is a: a.parent.left = b else: a.parent.right = b if target: target.splay() if not target.left: take_place(target, target.right) elif not target.right: take_place(target, target.left) else: miniumum = target.right.find_min() if miniumum.parent is not target: take_place(miniumum, miniumum.right) miniumum.right = target.right miniumum.right.parent = miniumum take_place(target, miniumum) miniumum.left = target.left del target Ref\ntreap 每個點都有\nkey: BST的val pri: heap的比較數字 所以叫tree + heap = treap 在維持heap的前提下(意思是heap先滿足)，滿足BST的需求\n同時treap有以下性質\n給定 n 個節點的 key、pri 的大小關係，那麼這棵 treap 的形狀唯一。 給定 n 個節點的 key，在 n 個節點的 pri 都隨機的前提下（也就是 treap 的形狀隨 機），任一個選定的節點的期望深度為 O(log n)。 所以根據第2點，我們pri要是random\nclass Node: def __init__(self, key: int = 0, left = None, right = None): self.left, self.right = left, right self.key, self.pri = key, random() def inspect(self) -\u003e [int]: ret = [self.key] ret += self.left.inspect() if self.left else [] ret += self.right.inspect() if self.right else [] return ret def size(self) -\u003e int: ret = 1 ret += self.left.size() if self.left else 0 ret += self.right.size() if self.right else 0 return ret 有rotate的寫法，但很複雜，同時有merge/split的寫法，好寫很多，所以做merge/split\nsplit: 把一顆樹根据數字分成左右兩顆treap\nroot key比較小就跟左邊、比較大就跟右邊，剩下的(另一側)拿去遞迴，繼續割 merge: 依據pri與key合併兩棵treap 同時限制左邊的treap的所有key都小於右邊的treap 只要是合併split後的treap就可以滿足這個限制 merge/split互為反函數 def split(root: Node, key: int) -\u003e [Node, Node]: if not root: return [None, None] elif root.key \u003c= key: # 保留 root.left # 繼續分 root.right，之後接上新的treap l, r = split(root.right, key) root.right = l return [root, r] else: l, r = split(root.left, key) root.left = r return [l, root] def merge(l: Node, r: Node) -\u003e Node: if not l or not r: return l or r elif l.pri \u003e r.pri: l.right = merge(l.right, r) return l # 讓pri大的當root else: r.left = merge(l, r.left) return r # 讓pri大的當root insert:\n基本上就是BST insert，但是還有pri!! 所以可以先看pri，如果比較大就插這裡 (用split生左右tree!!) def insert(root: Node, target: Node): if not root: return target elif target.pri \u003e root.pri: target.left, target.right = split(root, target.key) return target else: # usual BST insert if root.key \u003c= target.key: return insert(root.right, target) else: return insert(root.left, target) remove:\n遠比BST的remove簡單!! 遇到要刪的，直接merge原有的左右tree!! def remove(root: Node, key: int) -\u003e Node: if not root: return None elif root.key == key: return merge(root.left, root.right) else: if root.key \u003c= key: root.right = remove(root.right, key) else: root.left = remove(root.left, key) return root 這個是set的union，作法就是用最大pri的treap作主軸，一直split右邊的treap，之後就是繼續unite被split出來的treap\ndef unite(l: Node, r: Node) -\u003e Node: if not l or not r: return l or r elif l.pri \u003c r.pri: return unite(r, l) else: r_left, r_right = split(r, l.key) l.left = unite(l.left, r_left) l.right = unite(l.right, r_right) return l Ref\n","wordCount":"1278","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-11-17T21:51:31Z","dateModified":"2021-11-17T21:51:31Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/11/%E5%90%84%E7%A8%AE%E5%B9%B3%E8%A1%A1%E6%A8%B9/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">各種平衡樹</h1><div class=post-meta><span title='2021-11-17 21:51:31 +0000 UTC'>November 17, 2021</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#red-black-tree aria-label="red-black tree">red-black tree</a><ul><li><a href=#insert-%e9%9b%99%e7%b4%85%e7%9f%9b%e7%9b%be aria-label="insert (雙紅矛盾)">insert (雙紅矛盾)</a></li><li><a href=#delete-%e9%bb%91%e9%ab%98%e7%9f%9b%e7%9b%be aria-label="delete (黑高矛盾)">delete (黑高矛盾)</a></li></ul></li><li><a href=#splay-tree aria-label="splay tree">splay tree</a></li><li><a href=#treap aria-label=treap>treap</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>補完以前的記憶，下面會介紹</p><ul><li>經典款: red-black tree<ul><li>但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種</li></ul></li><li>rotation base: splay tree</li><li>merge/split base: treap</li></ul><h2 id=red-black-tree>red-black tree<a hidden class=anchor aria-hidden=true href=#red-black-tree>#</a></h2><p>只要符合下面兩個限制的tree就是red-black tree</p><ol><li>紅的不會和紅的接在一起</li></ol><ul><li>雙紅矛盾</li></ul><ol start=2><li>從根到任意leaf的路徑長度都一樣長</li></ol><ul><li>黑高矛盾 (不等高)</li></ul><h3 id=insert-雙紅矛盾>insert (雙紅矛盾)<a hidden class=anchor aria-hidden=true href=#insert-雙紅矛盾>#</a></h3><p>insert如何不破壞兩個條件?</p><p>黑高矛盾: 每次都插入紅的
雙紅矛盾:</p><ol><li>插入點是root，child有紅</li></ol><ul><li>把root換成黑</li></ul><ol start=2><li>插入點是child (parent是黑的，並假設插在左邊)</li><li>左的child是紅的: 直接右旋</li><li>右的child是紅的: 左旋再右旋</li></ol><p>插右邊的case?
這是對稱的，所以不列了</p><p>可以注意到，第2個case的所有case的結果都會是</p><ol><li>根是紅的</li><li>像這種<code>/\</code>形狀</li></ol><p><img loading=lazy src=https://pic1.zhimg.com/v2-cb9e8a9f60f4065144c52a9be72234dc_r.jpg alt>
<img loading=lazy src=https://pic3.zhimg.com/v2-de40532609af882c6358ea09bd5ecc22_r.jpg alt>
<img loading=lazy src=https://pic2.zhimg.com/v2-c990cd7c23620c85ff9805ee56f4a201_r.jpg alt>
<img loading=lazy src=https://pic3.zhimg.com/v2-e2325b649e5faac6ba3c888787a10caa_r.jpg alt></p><p>剛剛提到左旋與右旋，來完成再平衡，但是haskell可以直接build資料，所以&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>blacken</span> <span class=kt>Nil</span> <span class=ow>=</span> <span class=kt>Nil</span>
</span></span><span class=line><span class=cl><span class=nf>blacken</span> <span class=p>(</span><span class=kt>Node</span> <span class=kr>_</span> <span class=n>value</span> <span class=n>left</span> <span class=n>right</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Node</span> <span class=kt>Black</span> <span class=n>value</span> <span class=n>left</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>insert</span> <span class=n>x</span> <span class=n>root</span> <span class=ow>=</span> <span class=n>blacken</span> <span class=o>$</span> <span class=n>insert&#39;</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>  <span class=kr>where</span> <span class=n>insert&#39;</span> <span class=kt>Nil</span> <span class=ow>=</span> <span class=kt>Node</span> <span class=kt>Red</span> <span class=n>x</span> <span class=kt>Nil</span> <span class=kt>Nil</span>
</span></span><span class=line><span class=cl>        <span class=n>insert&#39;</span> <span class=n>root</span><span class=o>@</span><span class=p>(</span><span class=kt>Node</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=n>right</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span> <span class=ow>=</span> <span class=n>balance</span> <span class=n>color</span> <span class=n>y</span> <span class=p>(</span><span class=n>insert&#39;</span> <span class=n>left</span><span class=p>)</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>y</span> <span class=ow>=</span> <span class=n>balance</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=p>(</span><span class=n>insert&#39;</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>otherwise</span> <span class=ow>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>-- left-right</span>
</span></span><span class=line><span class=cl><span class=nf>balance</span> <span class=kt>Black</span> <span class=n>z</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>x</span> <span class=n>a</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>y</span> <span class=n>b</span> <span class=n>c</span><span class=p>))</span> <span class=n>d</span> <span class=ow>=</span> <span class=kt>Node</span> <span class=kt>Red</span> <span class=n>y</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>x</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>z</span> <span class=n>c</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>-- left-left</span>
</span></span><span class=line><span class=cl><span class=nf>balance</span> <span class=kt>Black</span> <span class=n>z</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>y</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>x</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=n>c</span><span class=p>)</span> <span class=n>d</span> <span class=ow>=</span> <span class=kt>Node</span> <span class=kt>Red</span> <span class=n>y</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>x</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>z</span> <span class=n>c</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>-- right-left</span>
</span></span><span class=line><span class=cl><span class=nf>balance</span> <span class=kt>Black</span> <span class=n>x</span> <span class=n>a</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>y</span> <span class=n>b</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>z</span> <span class=n>c</span> <span class=n>d</span><span class=p>))</span> <span class=ow>=</span> <span class=kt>Node</span> <span class=kt>Red</span> <span class=n>y</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>x</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>z</span> <span class=n>c</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>-- right-right</span>
</span></span><span class=line><span class=cl><span class=nf>balance</span> <span class=kt>Black</span> <span class=n>x</span> <span class=n>a</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>z</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>y</span> <span class=n>b</span> <span class=n>c</span><span class=p>)</span> <span class=n>d</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Node</span> <span class=kt>Red</span> <span class=n>y</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>x</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>z</span> <span class=n>c</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>balance</span> <span class=n>color</span> <span class=n>value</span> <span class=n>left</span> <span class=n>right</span> <span class=ow>=</span> <span class=kt>Node</span> <span class=n>color</span> <span class=n>value</span> <span class=n>left</span> <span class=n>right</span>
</span></span></code></pre></div><h3 id=delete-黑高矛盾>delete (黑高矛盾)<a hidden class=anchor aria-hidden=true href=#delete-黑高矛盾>#</a></h3><p>delete就是BST的delete</p><ol><li>在leaf: 換成nil</li><li>只有一個child: 把唯一個child拉上去</li><li>兩個child: 右child最小的換上來，再把它刪掉</li></ol><p>所以現在重點是換下去的那個點怎麼刪</p><p>刪的是</p><ul><li>紅的: 沒事</li><li>黑的: 數量可能不對 (黑高矛盾)</li></ul><p>(把紅的看成收束下面的兩個child成一條長度，因為兩邊的長度一樣)
(紅的可以輕易變成黑的，但黑的不行直接變成紅的)
要刪的是黑的，所以可以從parent與neighbor的顏色生出4種case</p><table><thead><tr><th></th><th>root: red</th><th>root: black</th></tr></thead><tbody><tr><td>neighbor: red</td><td>impossible</td><td>左旋，原本的parent變紅</td></tr><tr><td>neighbor: black</td><td>原本的parent變黑，neighbor變紅</td><td>neighbor變紅</td></tr></tbody></table><p><img loading=lazy src=https://pic2.zhimg.com/v2-fb3bb75b2e6f353e44528b43609efee5_r.jpg alt>
<img loading=lazy src=https://pic2.zhimg.com/v2-ccf3fea6c6cbb80c2b904235c5fbbcbd_r.jpg alt>
<img loading=lazy src=https://pic1.zhimg.com/v2-f826dea8b4f0e345be66d464ecaf5164_r.jpg alt></p><p>neighbor變紅，不會觸發雙紅矛盾?
有可能，如果兩個child都是黑的就沒事，其中一個是紅的就要處理了</p><p>只有右邊是紅、兩個紅: 左旋 (把長度補回去)，把紅的標成黑
<img loading=lazy src=https://pic4.zhimg.com/v2-957fb3741696f17f26f3181d8d57f157_r.jpg alt>
只有左邊是紅: 先左旋，轉成一條就可以用前面的方法了
<img loading=lazy src=https://pic1.zhimg.com/80/v2-fcb10adc72ba0130efeafb4300221458_720w.jpg alt></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>isBlack</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=kr>_</span> <span class=kr>_</span> <span class=kr>_</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>False</span>
</span></span><span class=line><span class=cl><span class=nf>isBlack</span> <span class=kr>_</span> <span class=ow>=</span> <span class=kt>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>balL</span> <span class=n>color</span> <span class=n>y</span> <span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=kt>True</span><span class=p>)</span> <span class=n>right</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>Node</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=n>right</span><span class=p>,</span> <span class=kt>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>balL</span> <span class=n>color</span> <span class=n>y</span> <span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=kt>False</span><span class=p>)</span> <span class=n>right</span> <span class=ow>=</span> <span class=n>balL&#39;</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>balL&#39;</span> <span class=n>color1</span> <span class=n>p</span> <span class=n>n</span> <span class=p>(</span><span class=kt>Node</span> <span class=n>color2</span> <span class=n>s</span> <span class=n>sl</span> <span class=n>sr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>-- neighbor: red, root: black </span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>color2</span> <span class=o>==</span> <span class=kt>Red</span> <span class=ow>=</span> <span class=n>balL</span> <span class=kt>Black</span> <span class=n>s</span> <span class=p>(</span><span class=n>balL&#39;</span> <span class=kt>Red</span> <span class=n>p</span> <span class=n>n</span> <span class=n>sl</span><span class=p>)</span> <span class=n>sr</span>
</span></span><span class=line><span class=cl>    <span class=c1>-- neighbor: black, root: black OR red</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>isBlack</span> <span class=n>sl</span> <span class=o>&amp;&amp;</span> <span class=n>isBlack</span> <span class=n>sr</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>p</span> <span class=n>n</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>s</span> <span class=n>sl</span> <span class=n>sr</span><span class=p>),</span> <span class=n>color1</span> <span class=o>==</span> <span class=kt>Red</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>-- 只有右邊是紅、兩個紅</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>not</span> <span class=p>(</span><span class=n>isBlack</span> <span class=n>sr</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>Node</span> <span class=n>color1</span> <span class=n>s</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>p</span> <span class=n>n</span> <span class=n>sl</span><span class=p>)</span> <span class=p>(</span><span class=n>blacken</span> <span class=n>sr</span><span class=p>),</span> <span class=kt>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>-- 只有左邊是紅</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>otherwise</span> <span class=ow>=</span> <span class=kr>let</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>x</span> <span class=n>sll</span> <span class=n>slr</span><span class=p>)</span> <span class=ow>=</span> <span class=n>sl</span> <span class=kr>in</span> <span class=n>balL&#39;</span> <span class=n>color1</span> <span class=n>p</span> <span class=n>n</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>x</span> <span class=n>sll</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>s</span> <span class=n>slr</span> <span class=n>sr</span><span class=p>))</span>
</span></span></code></pre></div><p>把剩下的列完</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>findMin</span> <span class=p>(</span><span class=kt>Node</span> <span class=kr>_</span> <span class=n>x</span> <span class=kt>Nil</span> <span class=kr>_</span><span class=p>)</span> <span class=ow>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl><span class=nf>findMin</span> <span class=p>(</span><span class=kt>Node</span> <span class=kr>_</span> <span class=kr>_</span> <span class=n>left</span> <span class=kr>_</span><span class=p>)</span> <span class=ow>=</span> <span class=n>findMin</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>balR</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=p>(</span><span class=n>right</span><span class=p>,</span> <span class=kt>True</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>Node</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=n>right</span><span class=p>,</span> <span class=kt>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>balR</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=p>(</span><span class=n>right</span><span class=p>,</span> <span class=kt>False</span><span class=p>)</span> <span class=ow>=</span> <span class=n>balR&#39;</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>balR&#39;</span> <span class=n>color1</span> <span class=n>p</span> <span class=p>(</span><span class=kt>Node</span> <span class=n>color2</span> <span class=n>s</span> <span class=n>sl</span> <span class=n>sr</span><span class=p>)</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>color2</span> <span class=o>==</span> <span class=kt>Red</span> <span class=ow>=</span> <span class=n>balR</span> <span class=kt>Black</span> <span class=n>s</span> <span class=n>sl</span> <span class=p>(</span><span class=n>balR&#39;</span> <span class=kt>Red</span> <span class=n>p</span> <span class=n>sr</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>isBlack</span> <span class=n>sl</span> <span class=o>&amp;&amp;</span> <span class=n>isBlack</span> <span class=n>sr</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>p</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>s</span> <span class=n>sl</span> <span class=n>sr</span><span class=p>)</span> <span class=n>n</span><span class=p>,</span> <span class=n>color1</span> <span class=o>==</span> <span class=kt>Red</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>not</span> <span class=p>(</span><span class=n>isBlack</span> <span class=n>sl</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>Node</span> <span class=n>color1</span> <span class=n>s</span> <span class=p>(</span><span class=n>blacken</span> <span class=n>sl</span><span class=p>)</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>p</span> <span class=n>sr</span> <span class=n>n</span><span class=p>),</span> <span class=kt>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>otherwise</span> <span class=ow>=</span> <span class=kr>let</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>x</span> <span class=n>srl</span> <span class=n>srr</span><span class=p>)</span> <span class=ow>=</span> <span class=n>sr</span> <span class=kr>in</span> <span class=n>balR&#39;</span> <span class=n>color1</span> <span class=n>p</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Black</span> <span class=n>x</span> <span class=p>(</span><span class=kt>Node</span> <span class=kt>Red</span> <span class=n>s</span> <span class=n>sl</span> <span class=n>srl</span><span class=p>)</span> <span class=n>srr</span><span class=p>)</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>delete</span> <span class=n>x</span> <span class=n>t</span> <span class=ow>=</span> <span class=n>fst</span> <span class=o>$</span> <span class=n>delete&#39;</span> <span class=n>x</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=kr>where</span> <span class=n>delete&#39;</span> <span class=n>x</span> <span class=kt>Nil</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>Nil</span><span class=p>,</span> <span class=kt>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>delete&#39;</span> <span class=n>x</span> <span class=n>root</span><span class=o>@</span><span class=p>(</span><span class=kt>Node</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span> <span class=ow>=</span> <span class=n>balL</span> <span class=n>color</span> <span class=n>y</span> <span class=p>(</span><span class=n>delete&#39;</span> <span class=n>x</span> <span class=n>left</span><span class=p>)</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>y</span> <span class=ow>=</span> <span class=n>balR</span> <span class=n>color</span> <span class=n>y</span> <span class=n>left</span> <span class=p>(</span><span class=n>delete&#39;</span> <span class=n>x</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>otherwise</span> <span class=ow>=</span> <span class=n>deleteRoot</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>        <span class=n>deleteRoot</span> <span class=p>(</span><span class=kt>Node</span> <span class=n>color</span> <span class=kr>_</span> <span class=kt>Nil</span> <span class=kt>Nil</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>Nil</span><span class=p>,</span> <span class=n>color</span> <span class=o>==</span> <span class=kt>Red</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>deleteRoot</span> <span class=p>(</span><span class=kt>Node</span> <span class=kr>_</span> <span class=kr>_</span> <span class=n>left</span> <span class=kt>Nil</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=n>blacken</span> <span class=n>left</span><span class=p>,</span> <span class=kt>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>deleteRoot</span> <span class=p>(</span><span class=kt>Node</span> <span class=kr>_</span> <span class=kr>_</span> <span class=kt>Nil</span> <span class=n>right</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=n>blacken</span> <span class=n>right</span><span class=p>,</span> <span class=kt>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>deleteRoot</span> <span class=p>(</span><span class=kt>Node</span> <span class=n>color</span> <span class=kr>_</span> <span class=n>left</span> <span class=n>right</span><span class=p>)</span> <span class=ow>=</span> <span class=kr>let</span> <span class=n>m</span> <span class=ow>=</span> <span class=n>findMin</span> <span class=n>right</span> <span class=kr>in</span> <span class=n>balR</span> <span class=n>color</span> <span class=n>m</span> <span class=n>left</span> <span class=p>(</span><span class=n>delete&#39;</span> <span class=n>m</span> <span class=n>right</span><span class=p>)</span>
</span></span></code></pre></div><p><a href=https://zhuanlan.zhihu.com/p/77616103>Ref</a>
<a href=https://www.zhihu.com/question/340879955/answer/792754042>有人能讲清楚《Algorithms》中左倾红黑树（LLRB）删除操作的每一行代码吗？</a></p><h2 id=splay-tree>splay tree<a hidden class=anchor aria-hidden=true href=#splay-tree>#</a></h2><p>利用特別的旋轉(splay)，把最近存取的點轉到root，達成所有操作均攤log n</p><p>如果只有父節點，也就是父節點是root，就直接rotate
但如果有祖父節點時要做下面兩個case的旋轉</p><p><img loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/f/fd/Zigzig.gif alt>
<img loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/6/6f/Zigzag.gif alt></p><p>Q: 為什麼這個rotate這麼特別，如果說只是轉上去，其實不用管祖父節點?
A: 這樣才能確保出來的深度是最小的</p><p>P.S.: C++的rotate很複雜，因為一次只能assign一次，所以狀態一直變，但是利用平行賦值就好很多</p><p>每次改node，都要確認被改過的node的left, right, parent都是對的!!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span><span class=nb>int</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>parent</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span> <span class=n>left</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>key</span><span class=p>,</span> <span class=n>paretn</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>left_rotate</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>oldroot</span><span class=p>,</span> <span class=n>newroot</span> <span class=o>=</span> <span class=bp>self</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=p>,</span> <span class=n>oldroot</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>oldroot</span><span class=o>.</span><span class=n>parent</span><span class=p>,</span> <span class=n>newroot</span>
</span></span><span class=line><span class=cl>    <span class=n>newroot</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>oldroot</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>oldroot</span><span class=p>,</span> <span class=n>newroot</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>newroot</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>newroot</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>oldroot</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>left</span> <span class=ow>is</span> <span class=n>oldroot</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>newroot</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>newroot</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>right_rotate</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>oldroot</span><span class=p>,</span> <span class=n>newroot</span> <span class=o>=</span> <span class=bp>self</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=p>,</span> <span class=n>oldroot</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>oldroot</span><span class=o>.</span><span class=n>parent</span><span class=p>,</span> <span class=n>newroot</span>
</span></span><span class=line><span class=cl>    <span class=n>newroot</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>oldroot</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>oldroot</span><span class=p>,</span> <span class=n>newroot</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>newroot</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>newroot</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>oldroot</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>left</span> <span class=ow>is</span> <span class=n>oldroot</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>newroot</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>newroot</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>newroot</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>is_left</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=ow>is</span> <span class=n>other</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>splay</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>parent</span><span class=p>,</span> <span class=n>grand_parent</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>parent</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>grand_parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>grand_parent</span><span class=o>.</span><span class=n>is_left</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>):</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=n>left_child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>grand_parent</span><span class=o>.</span><span class=n>left_rotation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span><span class=o>.</span><span class=n>left_rotation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span><span class=o>.</span><span class=n>right_rotation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>grand_parent</span><span class=o>.</span><span class=n>left_rotation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=ow>not</span> <span class=n>left_child</span><span class=p>:</span> <span class=c1># is right child</span>
</span></span><span class=line><span class=cl>            <span class=n>grand_parent</span><span class=o>.</span><span class=n>right_rotation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span><span class=o>.</span><span class=n>right_rotation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span><span class=o>.</span><span class=n>left_rotation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>grand_parent</span><span class=o>.</span><span class=n>right_rotation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># zig</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>parent</span><span class=o>.</span><span class=n>left</span> <span class=ow>is</span> <span class=bp>self</span><span class=p>:</span>
</span></span><span class=line><span class=cl>          <span class=n>parent</span><span class=o>.</span><span class=n>left_rotate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>          <span class=n>parent</span><span class=o>.</span><span class=n>right_rotate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ret</span> <span class=o>=</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ret</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>key</span> <span class=o>&gt;</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ret</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>find_min</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>find_min</span><span class=p>()</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=k>else</span> <span class=bp>self</span><span class=o>.</span><span class=n>key</span>
</span></span></code></pre></div><p>insert與BST差不多，但是最後要splay!!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=n>root</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c1>## WTF</span>
</span></span><span class=line><span class=cl>  <span class=n>prev</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>now</span><span class=p>:</span> <span class=n>Node</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=n>now</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>prev</span><span class=p>,</span> <span class=n>now</span> <span class=o>=</span> <span class=n>now</span><span class=p>,</span> <span class=n>now</span><span class=o>.</span><span class=n>right</span> <span class=k>if</span> <span class=n>now</span><span class=o>.</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>key</span> <span class=k>else</span> <span class=n>now</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>now</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>prev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>prev</span><span class=o>.</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>now</span><span class=o>.</span><span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>prev</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>now</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>prev</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>now</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>now</span><span class=o>.</span><span class=n>splay</span><span class=p>()</span>
</span></span></code></pre></div><p>基本就是BST的remove，但要先把target splay，再做BST的remove</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>remove</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>## WTF</span>
</span></span><span class=line><span class=cl>    <span class=n>target</span><span class=p>:</span> <span class=n>Node</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>take_place</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>b</span><span class=p>:</span>
</span></span><span class=line><span class=cl>          <span class=n>b</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=n>parent</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>a</span><span class=o>.</span><span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=n>a</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>left</span> <span class=ow>is</span> <span class=n>a</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>a</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>          <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>a</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>target</span><span class=o>.</span><span class=n>splay</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>target</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>take_place</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>target</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=ow>not</span> <span class=n>target</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>take_place</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>target</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>miniumum</span> <span class=o>=</span> <span class=n>target</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>find_min</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>miniumum</span><span class=o>.</span><span class=n>parent</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>take_place</span><span class=p>(</span><span class=n>miniumum</span><span class=p>,</span> <span class=n>miniumum</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>miniumum</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>target</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>                <span class=n>miniumum</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>miniumum</span>
</span></span><span class=line><span class=cl>            <span class=n>take_place</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>miniumum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>miniumum</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>target</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=k>del</span> <span class=n>target</span>
</span></span></code></pre></div><p><a href=https://en.wikipedia.org/wiki/Splay_tree>Ref</a></p><h2 id=treap>treap<a hidden class=anchor aria-hidden=true href=#treap>#</a></h2><p>每個點都有</p><ul><li>key: BST的val</li><li>pri: heap的比較數字
所以叫tree + heap = treap</li></ul><p>在維持heap的前提下(意思是heap先滿足)，滿足BST的需求</p><p>同時treap有以下性質</p><ol><li>給定 n 個節點的 key、pri 的大小關係，那麼這棵 treap 的形狀唯一。</li><li>給定 n 個節點的 key，在 n 個節點的 pri 都隨機的前提下（也就是 treap 的形狀隨
機），任一個選定的節點的期望深度為 O(log n)。</li></ol><p>所以根據第2點，我們pri要是random</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>left</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>left</span><span class=p>,</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>pri</span> <span class=o>=</span> <span class=n>key</span><span class=p>,</span> <span class=n>random</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>inspect</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>+=</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>inspect</span><span class=p>()</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=k>else</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>+=</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>inspect</span><span class=p>()</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=k>else</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>size</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>+=</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>size</span><span class=p>()</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>+=</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>size</span><span class=p>()</span> <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div><p>有rotate的寫法，但很複雜，同時有merge/split的寫法，好寫很多，所以做merge/split</p><p>split: 把一顆樹根据數字分成左右兩顆treap</p><ul><li>root key比較小就跟左邊、比較大就跟右邊，剩下的(另一側)拿去遞迴，繼續割
merge: 依據pri與key合併兩棵treap</li><li>同時限制左邊的treap的所有key都小於右邊的treap<ul><li>只要是合併split後的treap就可以滿足這個限制</li><li>merge/split互為反函數</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>split</span><span class=p>(</span><span class=n>root</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>[</span><span class=n>Node</span><span class=p>,</span> <span class=n>Node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>root</span><span class=o>.</span><span class=n>key</span> <span class=o>&lt;=</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 保留 root.left</span>
</span></span><span class=line><span class=cl>    <span class=c1># 繼續分 root.right，之後接上新的treap</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span><span class=p>,</span> <span class=n>r</span> <span class=o>=</span> <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>l</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>root</span><span class=p>,</span> <span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span><span class=p>,</span> <span class=n>r</span> <span class=o>=</span> <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>l</span><span class=p>,</span> <span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>l</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>r</span><span class=p>:</span> <span class=n>Node</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>l</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>r</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>l</span> <span class=ow>or</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>l</span><span class=o>.</span><span class=n>pri</span> <span class=o>&gt;</span> <span class=n>r</span><span class=o>.</span><span class=n>pri</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>merge</span><span class=p>(</span><span class=n>l</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>l</span> <span class=c1># 讓pri大的當root</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>merge</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r</span> <span class=c1># 讓pri大的當root</span>
</span></span></code></pre></div><p>insert:</p><ul><li>基本上就是BST insert，但是還有pri!!</li><li>所以可以先看pri，如果比較大就插這裡 (用split生左右tree!!)</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=n>root</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>target</span><span class=p>:</span> <span class=n>Node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>target</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>target</span><span class=o>.</span><span class=n>pri</span> <span class=o>&gt;</span> <span class=n>root</span><span class=o>.</span><span class=n>pri</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>target</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>target</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>target</span><span class=o>.</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>target</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># usual BST insert</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span><span class=o>.</span><span class=n>key</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=o>.</span><span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>target</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>target</span><span class=p>)</span>
</span></span></code></pre></div><p>remove:</p><ul><li>遠比BST的remove簡單!!</li><li>遇到要刪的，直接merge原有的左右tree!!</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>remove</span><span class=p>(</span><span class=n>root</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>root</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span><span class=o>.</span><span class=n>key</span> <span class=o>&lt;=</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>       <span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>remove</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>remove</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>root</span>
</span></span></code></pre></div><p>這個是set的union，作法就是用最大pri的treap作主軸，一直split右邊的treap，之後就是繼續unite被split出來的treap</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>unite</span><span class=p>(</span><span class=n>l</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>r</span><span class=p>:</span> <span class=n>Node</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>l</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>r</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>l</span> <span class=ow>or</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>l</span><span class=o>.</span><span class=n>pri</span> <span class=o>&lt;</span> <span class=n>r</span><span class=o>.</span><span class=n>pri</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>unite</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>r_left</span><span class=p>,</span> <span class=n>r_right</span> <span class=o>=</span> <span class=n>split</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=o>.</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>unite</span><span class=p>(</span><span class=n>l</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>r_left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>unite</span><span class=p>(</span><span class=n>l</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>r_right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>l</span>
</span></span></code></pre></div><p><a href=https://cp-algorithms.com/data_structures/treap.html>Ref</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/11/%E5%88%86%E5%A1%8A%E6%80%9D%E6%83%B3/><span class=title>« Prev</span><br><span>分塊思想</span>
</a><a class=next href=https://littlebees.github.io/2021/11/polygon-concavity-index/><span class=title>Next »</span><br><span>Polygon Concavity Index</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>