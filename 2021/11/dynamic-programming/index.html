<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dynamic programming | 記事本</title>
<meta name=keywords content><meta name=description content="動機
寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞
只要懂遞迴就可以做dp了
對了，遞迴的函式預設有@cache，做記憶法"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/11/dynamic-programming/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/11/dynamic-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Dynamic programming"><meta property="og:description" content="動機
寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞
只要懂遞迴就可以做dp了
對了，遞迴的函式預設有@cache，做記憶法"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/11/dynamic-programming/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-21T17:20:35+00:00"><meta property="article:modified_time" content="2021-11-21T17:20:35+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="Dynamic programming"><meta name=twitter:description content="動機
寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞
只要懂遞迴就可以做dp了
對了，遞迴的函式預設有@cache，做記憶法"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Dynamic programming","item":"https://littlebees.github.io/2021/11/dynamic-programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dynamic programming","name":"Dynamic programming","description":"動機 寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞 只要懂遞迴就可以做dp了\n對了，遞迴的函式預設有@cache，做記憶法\n","keywords":[],"articleBody":"動機 寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞 只要懂遞迴就可以做dp了\n對了，遞迴的函式預設有@cache，做記憶法\nDP概述 Dynamic programming = planning over time\n這裡的time要理解成順序，我們是在每個時間點上做決策，所以通常會需要資料有sort過或是本身有一定的順序\n這些順序就是其他講解DP的資料會看提到的階段\nDP 與 backtracking Weighted interval scheduling: 每個job有weight挑job不重疊，並讓wieght最大\n假設有job都已開始時間排序好，同時有一個函數(prev)可以給出前一個離最近的job\n那就可以給出一個dp，就是看要不要這份job f(i)表示選到i時的最大wieght總和\n@cache def f(i): if i == 0: return jobs[i] else: return max(f(i-1), jobs[i]+f(prev[i])) subset: 求subset 每一個都可以選或不選\ndef subset(arr): if not arr: return [[]] else: sub = subset(arr[1:]) return sub+[s + [arr[0]] for s in sub] 可以看出dp與backtracking都是選與不選!! 那兩者差在哪裡?\nbacktrack需要之前的所有資料 dp可以利用有結合律函數(min, max, sum…)把之前的所有資料用一筆代表\n不只一種DP Weighted interval scheduling也可以這樣看\n定義f(i,time)為在選第i樣工作，從time之前都有空\ndef f(i, time): if i == 0: return jobs[i] elif end[i] \u003e time: return f(i-1) else: return max(f(i-1, time), jobs[i]+f(i-1, start[i])) dp其實主要牽涉到怎麼設定狀態，像是把時間放進來，就會變成不同的dp 但前面利用前處理，讓找下一個job的速度上去，進而減少一個維度(參數)\nDP 與 greedy Greedy 不行就 DP\n當 Greedy 不對就代表 「這個問題不能只由這個子問題轉移」 換句話說，Greedy 就是可以證明只有一個轉移來源的 DP\n可以順便看列舉為什麼慢? 因為除了現在確定的參數外，還要繼續往後看才能確定答案\n貪心就是只看當下，就ok了 DP是除了現在還要加上以前的資料\n證明greedy 因為貪心就是只看當下，所以會需要證明這做法是對的\n反證法：如果交換方案中任意兩個元素/相鄰的兩個元素後，答案不會變得更好，那麼可以推定目前的解已經是最優解了。 歸納法：先算得出邊界情況（例如 ）的最優解 ，然後再證明：對於每個 ， 都可以由 推導出結果。 常見題型\n「我們將 XXX 按照某某順序排序，然後按某種順序（例如從小到大）選擇。」。 離線，先處理後選擇 「我們每次都取 XXX 中最大/小的東西，並更新 XXX。」 （有時「XXX 中最大/小的東西」可以優化，比如用優先隊列維護） 在線，邊處理邊選擇 解法 排序解法 用排序法常見的情況是輸入一個包含幾個（一般一到兩個）權值的數組，通過排序然後遍歷模擬計算的方法求出最優值。 後悔解法 思路是無論當前的選項是否最優都接受，然後進行比較，如果選擇之後不是最優了，則反悔，捨棄掉這個選項；否則，正式接受。如此往復。 DP 與 DAG DP的狀態可以看成graph上的點\n同時這個graph不會有環，所以是DAG\n這樣DP其實就是求DAG的最長/短距離\nrecursion \u0026 iteration iteration其實是recursion的特例\niteration，是直接從base case直接往上做，對應到bottom-up\nrecursion與iteration差在recursion要記憶當初誰call的context(用stack) 之後從頭往下，到底(base case)就照著stack往回走，這就是top-down\n如果遞迴call的當下沒有其他要做的事，其實這個遞迴就是iteration\n有context: sum(arr[1:])處理完還要與arr[0]的相加\ndef sum(arr): if not arr: return 0 else: return arr[0]+sum(arr[1:]) 沒context: sum(arr[1:],acc+arr[0])做完就沒有其他事了\ndef sum(arr,acc=0): if not arr: return acc else: return sum(arr[1:],acc+arr[0]) 所以上面那個版本其實就是iteration，不過需要tail-recursion elimiation優化才有iteration的實際效能\ntop-down \u0026 bottom-up top-down \u0026 bottom-up 不等價 Leetcode 718 如果用top-down，因為要追蹤每個range的長度，所以變成n^3 但是用bottom-up，長度自然是對的，所以變成n^2\nLeetcode 546 只能用top-down去做，因為很難確定base case與怎麼從base case長上去 反倒是top-down的分解，就很好做\n技巧 狀態壓縮 其實就是把應該用set或array表示的狀態用bitmask表示\n因為是bitmask，所以是整數，是整數就能dp\n刷表法 省mem，locality變好\nDP優化 (我不會，這個只會出現在競程) 太可怕了，就把資料列一列就好 分治、DP 進階 Aliens 優化 進階DP，DP優化\n寫的小技巧 產生新值時固定寫法 有的是f[n + x] = combine(f[n], ....) 有的是f[n] = combine(f[n - x], ....) 最好固定寫法，個人是喜歡 f[n] = combine(f[n - x], ....) 因為dp一定是由小的更新大的 bottom-up或是改寫時可以畫圖輔助 狀態怎麼到起點 (參數怎麼變化) 在table上是取什麼點 (方向) 從終點開始思考怎麼到起點 (top-down開始做) 除非bottom-up很明顯，或是top-down在這題是個悲劇 設計方式 dp就是由參數(遞迴的模型的組合)、對應的動作構成、定義回傳值，只能在求最佳化問題(有結合律的函數)使用\n遞迴的模型 線性 (1D) f(i) = combine(f(j) for j in range(i)) 區間 (2D) 列舉中點 f(i,j) = combine(combine2(f(i,k), f(k,j)) for k in range(i,j)) 控制左右 f(i,j) = combine(f(i-1,j), f(i,j-1)) 分塊 f(i,j) = combine(f(i,a), f(a,b), f(b,j)) for (a,b) in ... 點 (2D) 上、左、左上 f(i,j) = combine(f(i-1,j), f(i,j-1), f(i-1,j-1)) 樹 子樹 f(root) = combine(f(child) for child in root.children) set(狀態壓縮) f(state) = combine(f(next(state))) 上面是可能的遞迴方式，除了遞迴外，還有其他需要的訊息，像是座標、成本等等\n需要遞迴的，加上其他需要的訊息，就是dp的狀態\n動作 這就是看題目了，像是edit distance就有delete、replace、insert 動作會影響到\n子問題怎麼組合 參數怎麼變化 有什麼參數 定義回傳值 (成本) dp回來的值一定是可以與其他dp組合在一起的值，像\n最大最小 總和 長度 … 通常我們會知道怎麼算最終答案的成本，但是dp時會需要計算當下狀態成本的方式，也就是需要把成本計算分散到每一層 這個吃狀態怎麼設計 以及 觀察 範例可以看Optimal binary search trees的depth怎麼處理的\n多看看其他人怎麼做 設計dp有的時候要自己加維度，就如同前面看到的dp不只一種，端看設計與實作\n所以其實寫dp最重要的是觀察與想像，所以多做題\n特別的DP 背包 01背包:\n選到i，剩下space個空間\ndef f(i,space): if space \u003c 0: return float('-inf') elif i \u003c 0: return 0 else: return max(f(i-1,space), price[i]+f(i-1, space-cost[i])) # !! 無限背包:\ndef f(i,space): if space \u003c 0: return float('-inf') elif i \u003c 0: return 0 else: return max(f(i-1,space), price[i]+f(i, space-cost[i])) # !! 滾動 \u0026 從頭或從尾 注意到i都是只有i-1，所以可以用滾動，但要改寫成bottom-up\n01背包:\n這裡與原本top-down的差不多，從i往前推\ndp = [0] * W for p,w in items: for nowW in reversed(range(w, W+1)): dp[nowW] = max(dp[nowW], p+dp[nowW-w]) 無限背包:\n這裡就與top-down完全不同了!!\ntop-down還是，從i往前推，但是可以在i停留，達成無限的效果 bottom-up為了要無限，所以必須每個合法的空間都要加一次，同時還要包含前面的影響\ndp一定是小的先算好，所以一定從前面取，而現在我們想取的值是已經改變過的值，所以要從最小的空間開始往上推\n01背包是不想取到已經改變過的值，所以要從最大的空間往下推\n這裡也彰顯了從頭與從尾的不同!!\n能不能拿到已經改變過的值?\n從頭: 能 從尾: 不能 dp = [0] * W for p,w in items: for nowW in range(w, W+1): dp[nowW] = max(dp[nowW], p+dp[nowW-w]) 有環的DP 做離散化，每個點做一次 把環的長度變成兩倍 mutual recursion Leetcode 188\n最多賣k次，買完才能賣，求最大收益\nsell[i][k] = 第i天，剩k次，做賣的最大收益 buy[i][k] = 第i天，剩k次，做買的最大收益 def sell(i,k): if k \u003c= 0 or i \u003c 0: return 0 else: return max(sell(i-1,k), price[i]+buy(i-1,k-1)) def buy(i,k): if k \u003c= 0 or i \u003c 0: return float('-inf') else: return max(buy(i-1,k), -price[i]+sell(i-1,k-1)) 為什麼要兩個? buy有自己的收益，sell也有自己的收益 彼此又互相組成對方的收益\n範例 來自演算法課本的dp範例\nAlgorithm Design(AD): 真的難，但有點東西 Introduction to Algorithm(CLRS): 厚到不能墊泡麵與當枕頭 Algorithms(DPV): 很薄，很精闢 The Algorithm Design Manual(TADM): 就是課本，但可以根據問題屬性去查對應的解法\nedit distance replace: (i-1,j-1) delete: (i,j-1) insert: (i-1,j) insert多一個字，又馬上比對，所以與delete相反 def f(s1,s2): if not s1 and not s2: return 0 elif s1[0] == s2[0]: return f(s1[1:], s2[1:]) else: return 1+min(f(s1[1:], s2[1:]), f(s1, s2[1:]), f(s1[1:], s2)) Longest common subsequence \u0026 Longest increasing subsequence Longest Increasing Subsequence\nMaximum Subarray Sum (AD) Maximum Subarray Sum\nTraveling Salesman Problem 給定一系列城市和每對城市之間的距離，求訪問每一座城市一次並回到起始城市的最短迴路\ncities是還可以去的點，1011，還有2, 1, 0可以去 i是目前的位置\ndef f(cities, i): if cities == 0: return 0 else: return min([f(cities ^ (1 \u003c\u003c i), j) + weight[i][j] for j in edges[i] if (1 \u003c\u003c j) \u0026 cities) != 0], float('inf')) Hamiltonian Path 有沒有一條每一點剛好經過一次的路線，起點和終點可以不相同\nN是有幾個地點(len(graph.V()))\nremains是還可以去的點，1011，還有2, 1, 0可以去 i是目前的位置\ndef f(remains, i): if remains == 0: return True else: return any(f(remains ^ (1 \u003c\u003c i), j) for j in edges[i] if (1 \u003c\u003c j) \u0026 remains) != 0) Shortest paths (DPV) path本身就是一段接一段的，也就是說它本身就是遞迴\n可以回去，所謂的relaxtion，其實就是在原有的基礎上衍伸一段可以到的edge 這就是list!!\n如果求最短，就是min，是具有結合律的函數，可以dp\n所以可以列舉起、終點、中間點，一直更新最短長度\nRod cutting (CLRS) 給一條木頭，與長度對應到的價格，求最大收益\ndef f(size): if size == 0: return 0 else: return max(f(size-sub)+price for sub,price in size2price.items() if size-sub \u003e= 0) Matrix-chain multiplication (CLRS, DPV) 有一排matrix要乘，求計算成本最小\n成本: (a X b) * (b X c) = (a X c) 的 成本是 b\ndef f(i,j): if j-i \u003c= 1: # 不會有一個matrix相乘 return float('inf') else: return min(f(i,k)+f(k+1,j)+cost(k,k+1) for k in range(i+1, j-1)) Optimal binary search trees (CLRS) 給key與出現的頻率，組成一個搜尋成本最小的BST\n成本: sum(freq[i]*depth)\n一個是tree，所以要分左右 一個是範圍，所以有i,j\n再來是計算成本，所以先把depth傳進去\ndef f(i,j,dep): if j-i == 0: return 0 else: return min(f(i,k,dep+1)+f(k+1,j,dep+1)+freq[key[k]] * dep for k in range(i,j-1)) 有沒有辦法把depth消滅掉? 看成橫的 先看tree\ni i-1 i+1 i-2 i+2 再看當時遞迴的範圍\n[i-2~i+2] [i-2~i-1] [i+1~i+2] [i-2] [i+2] 以i+2來說，由上往下看被加了3次，只看遞迴時的範圍，會發現剛好都i+2出現了3次 所以可以把depth去掉，變成每一次就把整個遞迴範圍的freq加總就好\ndef f(i,j): if j-i == 0: return 0 else: return min(f(i,k)+f(k+1,j)+sum(freq[i:j]) for k in range(i,j-1)) Minimum Length Triangulation (TADM) 有一堆點，構成一個多邊形，把多邊形切成三角形，讓成本最小\n成本: 所有三角形邊長的總和\ndef dist(p1, p2): return sqrt((p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])) def cost(points, i, j, k): return dist(points[i], points[j]) + dist(points[j], points[k]) + dist(points[k], points[i]) def f(i,j): if j-i \u003c= 2: return float('inf') elif j-i == 3: return cost(i,i+1,j) else: return min(f(i,k) + cost(i,k,j) + f(k,j) for k in range(i,j)) Independent sets in trees (DPV) Independent set就是裡面的點沒有edge互連，求最多點的set\n就是選了root就不能選children，但可以加上grand-children\nf(root) = max(sum(f(children)), 1+sum(grand-children)) Maximum Rectangle Problem (AD) 給個matrix，求從中框出的長方形的內部數字總和\n先做row的prefix sum 再根據前面的prefix sum，做每個column的prefix sum\n之後就是用排容: f(i,j,n,m) = area(i,j) - area(i-n,j) - area(i,j-m) + area(i-n, j-m)\nSegmented least squares (AD) 有一堆點，要用最少的線去fit這些點\n定義回傳值: cost\n定義cost: 每個點的e + 常數*幾根線\n用到Optimal binary search trees把depth分散到每一層去做的技巧\ndef error(i,j): # Check 6. DYNAMIC PROGRAMMING I page 30 pass def f(i): if i == 0: return 0 else: return min(error(k,i) + 常數 + f(k-1) for k in range(i)) Find the longest path in a matrix with given constraints 這裡要注意的是沒有去重的東西，所以開始dfs時要從終點開始走\ndef path(i,j): ret = float('-inf') if 0 \u003c= i \u003c n and 0 \u003c= j \u003c m: if (i,j) == (n-1,m-1): ret = 0 else: dirs = [(i-1,j),(i,j-1),(i+1,j),(i,j+1)] ret = max(ret, *[path(x,y) for (x,y) in dirs]) return ret for i in reversed(range(n)): for j in reversed(range(m)): path(i,j) Assembly Line Scheduling dag最長路徑\n# t :: time to switch another line # a :: time of each station # e :: cost on starting line # x :: cost on goal def f(i,j): if j == 0: return e[i] + a[i][j] ret = min(f(i,j-1), t[int(not i)][j-1]+f(int(not i), j-1)) if j == len(t[0]): # at goal ret += x[i] return ret Optimal Strategy for a Game 一開始先用一個me表示對面在做決策 有點像買股票的那一提\ndef f(i,j,me): if i\u003ej: return 0 elif i==j: return arr[i] if me else 0 else: if me: # ???? return max(arr[i]+f(i+1,j,not me), arr[j]+f(i,j-1,not me)) else: # ???? Q: 看別人的分數幹嘛 A: 雖然說我們的結果與他們有關，但是他的分數與我們無關\n下面的也是類似的\ndef x(i,j): if i\u003ej: return 0 elif i == j: return arr[i] else: return max(arr[i]-y(i+1,j), arr[j]-y(i,j-1)) def y(i,j): if i\u003ej: return 0 elif i == j: return arr[i] else: return max(arr[i]-x(i+1,j), arr[j]-x(i,j-1)) 選下一輪能選的時候分數最少的case (關注要建構的目標)\ndef f(i,j): if i\u003ej: return 0 elif i == j: return arr[i] else: return max(arr[i]+min(f(i+2, j), f(i+1,j-1)), arr[j]+min(f(i,j-2), f(i+1,j-1))) Partition problem def f(i,cnt): if i == 0: return arr[i] == cnt else: return f(i-1,cnt-arr[i]) or f(i-1,cnt) return f(len(arr)-1, sum(arr)//2) if sum(arr) % 2 == 0 else False Partition a set into two subsets such that the difference of subset sums is minimum 這個會變成backtrack\ndef f(i, cnt): if i == 0: return abs((sum(arr) - cnt) - cnt) else: return min(f(i - 1, cnt+arr[i - 1]), f(i - 1, cnt)) 原因是f想直接算差值，但是差值一定要等到最後，把所有路都走過 可以對其中一個維度做離散化\ndef f(i, cnt): if i == 0: return cnt == 0 else: return f(i-1, cnt) or f(i-1,cnt-arr[i]) for n in reversed(range(sum(arr)//2)): if f(len(arr)-1, n): print(sum(arr)-2*n) 題外話: functional DP 函数式的动态规划\nRef Greedy \u0026 DQ \u0026 DP 夜深人静写算法（二）- 动态规划入门 6. DYNAMIC PROGRAMMING I 背包 DP\n","wordCount":"1210","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-11-21T17:20:35Z","dateModified":"2021-11-21T17:20:35Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/11/dynamic-programming/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Dynamic programming</h1><div class=post-meta><span title='2021-11-21 17:20:35 +0000 UTC'>November 21, 2021</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#dp%e6%a6%82%e8%bf%b0 aria-label=DP概述>DP概述</a><ul><li><a href=#dp-%e8%88%87-backtracking aria-label="DP 與 backtracking">DP 與 backtracking</a></li><li><a href=#%e4%b8%8d%e5%8f%aa%e4%b8%80%e7%a8%aedp aria-label=不只一種DP>不只一種DP</a></li><li><a href=#dp-%e8%88%87-greedy aria-label="DP 與 greedy">DP 與 greedy</a><ul><li><a href=#%e8%ad%89%e6%98%8egreedy aria-label=證明greedy>證明greedy</a></li></ul></li><li><a href=#dp-%e8%88%87-dag aria-label="DP 與 DAG">DP 與 DAG</a></li><li><a href=#recursion--iteration aria-label="recursion & iteration">recursion & iteration</a></li><li><a href=#top-down--bottom-up aria-label="top-down & bottom-up">top-down & bottom-up</a></li><li><a href=#top-down--bottom-up-%e4%b8%8d%e7%ad%89%e5%83%b9 aria-label="top-down & bottom-up 不等價">top-down & bottom-up 不等價</a><ul><li><a href=#leetcode-718 aria-label="Leetcode 718">Leetcode 718</a></li><li><a href=#leetcode-546 aria-label="Leetcode 546">Leetcode 546</a></li></ul></li></ul></li><li><a href=#%e6%8a%80%e5%b7%a7 aria-label=技巧>技巧</a><ul><li><a href=#%e7%8b%80%e6%85%8b%e5%a3%93%e7%b8%ae aria-label=狀態壓縮>狀態壓縮</a></li><li><a href=#%e5%88%b7%e8%a1%a8%e6%b3%95 aria-label=刷表法>刷表法</a></li><li><a href=#dp%e5%84%aa%e5%8c%96-%e6%88%91%e4%b8%8d%e6%9c%83%e9%80%99%e5%80%8b%e5%8f%aa%e6%9c%83%e5%87%ba%e7%8f%be%e5%9c%a8%e7%ab%b6%e7%a8%8b aria-label="DP優化 (我不會，這個只會出現在競程)">DP優化 (我不會，這個只會出現在競程)</a></li><li><a href=#%e5%af%ab%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7 aria-label=寫的小技巧>寫的小技巧</a></li></ul></li><li><a href=#%e8%a8%ad%e8%a8%88%e6%96%b9%e5%bc%8f aria-label=設計方式>設計方式</a><ul><li><a href=#%e9%81%9e%e8%bf%b4%e7%9a%84%e6%a8%a1%e5%9e%8b aria-label=遞迴的模型>遞迴的模型</a></li><li><a href=#%e5%8b%95%e4%bd%9c aria-label=動作>動作</a></li><li><a href=#%e5%ae%9a%e7%be%a9%e5%9b%9e%e5%82%b3%e5%80%bc-%e6%88%90%e6%9c%ac aria-label="定義回傳值 (成本)">定義回傳值 (成本)</a></li><li><a href=#%e5%a4%9a%e7%9c%8b%e7%9c%8b%e5%85%b6%e4%bb%96%e4%ba%ba%e6%80%8e%e9%ba%bc%e5%81%9a aria-label=多看看其他人怎麼做>多看看其他人怎麼做</a></li></ul></li><li><a href=#%e7%89%b9%e5%88%a5%e7%9a%84dp aria-label=特別的DP>特別的DP</a><ul><li><a href=#%e8%83%8c%e5%8c%85 aria-label=背包>背包</a><ul><li><a href=#%e6%bb%be%e5%8b%95--%e5%be%9e%e9%a0%ad%e6%88%96%e5%be%9e%e5%b0%be aria-label="滾動 & 從頭或從尾">滾動 & 從頭或從尾</a></li></ul></li><li><a href=#%e6%9c%89%e7%92%b0%e7%9a%84dp aria-label=有環的DP>有環的DP</a></li><li><a href=#mutual-recursion aria-label="mutual recursion">mutual recursion</a></li></ul></li><li><a href=#%e7%af%84%e4%be%8b aria-label=範例>範例</a><ul><li><a href=#edit-distance aria-label="edit distance">edit distance</a></li><li><a href=#longest-common-subsequence--longest-increasing-subsequence aria-label="Longest common subsequence & Longest increasing subsequence">Longest common subsequence & Longest increasing subsequence</a></li><li><a href=#maximum-subarray-sum-ad aria-label="Maximum Subarray Sum (AD)">Maximum Subarray Sum (AD)</a></li><li><a href=#traveling-salesman-problem aria-label="Traveling Salesman Problem">Traveling Salesman Problem</a></li><li><a href=#hamiltonian-path aria-label="Hamiltonian Path">Hamiltonian Path</a></li><li><a href=#shortest-paths-dpv aria-label="Shortest paths (DPV)">Shortest paths (DPV)</a></li><li><a href=#rod-cutting-clrs aria-label="Rod cutting (CLRS)">Rod cutting (CLRS)</a></li><li><a href=#matrix-chain-multiplication-clrs-dpv aria-label="Matrix-chain multiplication (CLRS, DPV)">Matrix-chain multiplication (CLRS, DPV)</a></li><li><a href=#optimal-binary-search-trees-clrs aria-label="Optimal binary search trees (CLRS)">Optimal binary search trees (CLRS)</a></li><li><a href=#minimum-length-triangulation-tadm aria-label="Minimum Length Triangulation (TADM)">Minimum Length Triangulation (TADM)</a></li><li><a href=#independent-sets-in-trees-dpv aria-label="Independent sets in trees (DPV)">Independent sets in trees (DPV)</a></li><li><a href=#maximum-rectangle-problem-ad aria-label="Maximum Rectangle Problem (AD)">Maximum Rectangle Problem (AD)</a></li><li><a href=#segmented-least-squares-ad aria-label="Segmented least squares (AD)">Segmented least squares (AD)</a></li><li><a href=#find-the-longest-path-in-a-matrix-with-given-constraintshttpswwwgeeksforgeeksorgfind-the-longest-path-in-a-matrix-with-given-constraints aria-label="Find the longest path in a matrix with given constraints">Find the longest path in a matrix with given constraints</a></li><li><a href=#assembly-line-schedulinghttpswwwgeeksforgeeksorgassembly-line-scheduling-dp-34 aria-label="Assembly Line Scheduling">Assembly Line Scheduling</a></li><li><a href=#optimal-strategy-for-a-gamehttpswwwgeeksforgeeksorgoptimal-strategy-for-a-game-dp-31 aria-label="Optimal Strategy for a Game">Optimal Strategy for a Game</a></li><li><a href=#partition-problemhttpswwwgeeksforgeeksorgpartition-problem-dp-18 aria-label="Partition problem">Partition problem</a></li><li><a href=#partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimumhttpswwwgeeksforgeeksorgpartition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum aria-label="Partition a set into two subsets such that the difference of subset sums is minimum">Partition a set into two subsets such that the difference of subset sums is minimum</a></li></ul></li><li><a href=#%e9%a1%8c%e5%a4%96%e8%a9%b1-functional-dp aria-label="題外話: functional DP">題外話: functional DP</a></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞
只要懂遞迴就可以做dp了</p><p>對了，遞迴的函式預設有<code>@cache</code>，做記憶法</p><h2 id=dp概述>DP概述<a hidden class=anchor aria-hidden=true href=#dp概述>#</a></h2><p>Dynamic programming = planning over time</p><p>這裡的time要理解成順序，我們是在每個時間點上做決策，所以通常會需要資料有sort過或是本身有一定的順序</p><p>這些順序就是其他講解DP的資料會看提到的階段</p><h3 id=dp-與-backtracking>DP 與 backtracking<a hidden class=anchor aria-hidden=true href=#dp-與-backtracking>#</a></h3><p>Weighted interval scheduling: 每個job有weight挑job不重疊，並讓wieght最大</p><p>假設有job都已開始時間排序好，同時有一個函數(prev)可以給出前一個離最近的job</p><p>那就可以給出一個dp，就是看要不要這份job
f(i)表示選到i時的最大wieght總和</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@cache</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>jobs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=n>jobs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>prev</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span>
</span></span></code></pre></div><p>subset: 求subset
每一個都可以選或不選</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>subset</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>arr</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[[]]</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>sub</span> <span class=o>=</span> <span class=n>subset</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sub</span><span class=o>+</span><span class=p>[</span><span class=n>s</span> <span class=o>+</span> <span class=p>[</span><span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>sub</span><span class=p>]</span>
</span></span></code></pre></div><p>可以看出dp與backtracking都是選與不選!!
那兩者差在哪裡?</p><p>backtrack需要之前的<em>所有</em>資料
dp可以利用有結合律函數(min, max, sum&mldr;)把之前的所有資料用一筆代表</p><h3 id=不只一種dp>不只一種DP<a hidden class=anchor aria-hidden=true href=#不只一種dp>#</a></h3><p>Weighted interval scheduling也可以這樣看</p><p>定義f(i,time)為在選第i樣工作，從time之前都有空</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>time</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>jobs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>end</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>time</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>time</span><span class=p>),</span> <span class=n>jobs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>start</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span>
</span></span></code></pre></div><p>dp其實主要牽涉到怎麼設定狀態，像是把時間放進來，就會變成不同的dp
但前面利用前處理，讓找下一個job的速度上去，進而減少一個維度(參數)</p><h3 id=dp-與-greedy>DP 與 greedy<a hidden class=anchor aria-hidden=true href=#dp-與-greedy>#</a></h3><blockquote><p>Greedy 不行就 DP</p></blockquote><p>當 Greedy 不對就代表
「這個問題不能只由這個子問題轉移」
換句話說，Greedy 就是可以證明只有一個轉移來源的 DP</p><p>可以順便看<em>列舉為什麼慢?</em>
因為除了現在確定的參數外，還要繼續往後看才能確定答案</p><p>貪心就是只看當下，就ok了
DP是除了現在還要加上以前的資料</p><h4 id=證明greedy>證明greedy<a hidden class=anchor aria-hidden=true href=#證明greedy>#</a></h4><p>因為貪心就是只看當下，所以會需要證明這做法是對的</p><ul><li>反證法：如果交換方案中任意兩個元素/相鄰的兩個元素後，答案不會變得更好，那麼可以推定目前的解已經是最優解了。</li><li>歸納法：先算得出邊界情況（例如 ）的最優解 ，然後再證明：對於每個 ， 都可以由 推導出結果。</li></ul><p>常見題型</p><ul><li>「我們將 XXX 按照某某順序排序，然後按某種順序（例如從小到大）選擇。」。<ul><li>離線，先處理後選擇</li></ul></li><li>「我們每次都取 XXX 中最大/小的東西，並更新 XXX。」<ul><li>（有時「XXX 中最大/小的東西」可以優化，比如用優先隊列維護）</li><li>在線，邊處理邊選擇
解法</li></ul></li><li>排序解法<ul><li>用排序法常見的情況是輸入一個包含幾個（一般一到兩個）權值的數組，通過排序然後遍歷模擬計算的方法求出最優值。</li></ul></li><li>後悔解法<ul><li>思路是無論當前的選項是否最優都接受，然後進行比較，如果選擇之後不是最優了，則反悔，捨棄掉這個選項；否則，正式接受。如此往復。</li></ul></li></ul><h3 id=dp-與-dag>DP 與 DAG<a hidden class=anchor aria-hidden=true href=#dp-與-dag>#</a></h3><p>DP的狀態可以看成graph上的點</p><p>同時這個graph不會有環，所以是DAG</p><p>這樣DP其實就是求DAG的最長/短距離</p><h3 id=recursion--iteration>recursion & iteration<a hidden class=anchor aria-hidden=true href=#recursion--iteration>#</a></h3><p>iteration其實是recursion的特例</p><p>iteration，是直接從base case直接往上做，對應到bottom-up</p><p>recursion與iteration差在recursion要記憶當初誰call的context(用stack)
之後從頭往下，到底(base case)就照著stack往回走，這就是top-down</p><p>如果遞迴call的當下沒有其他要做的事，其實這個遞迴就是iteration</p><p>有context: <code>sum(arr[1:])</code>處理完還要與<code>arr[0]</code>的相加</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>arr</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>+</span><span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span></code></pre></div><p>沒context: <code>sum(arr[1:],acc+arr[0])</code>做完就沒有其他事了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=n>acc</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>arr</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>acc</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span><span class=n>acc</span><span class=o>+</span><span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span></code></pre></div><p>所以上面那個版本其實就是iteration，不過需要tail-recursion elimiation優化才有iteration的實際效能</p><h3 id=top-down--bottom-up>top-down & bottom-up<a hidden class=anchor aria-hidden=true href=#top-down--bottom-up>#</a></h3><p><img loading=lazy src=https://i.imgur.com/Z69f3Dq.png alt></p><h3 id=top-down--bottom-up-不等價>top-down & bottom-up 不等價<a hidden class=anchor aria-hidden=true href=#top-down--bottom-up-不等價>#</a></h3><h4 id=leetcode-718>Leetcode 718<a hidden class=anchor aria-hidden=true href=#leetcode-718>#</a></h4><p>如果用top-down，因為要追蹤每個range的長度，所以變成n^3
但是用bottom-up，長度自然是對的，所以變成n^2</p><h4 id=leetcode-546>Leetcode 546<a hidden class=anchor aria-hidden=true href=#leetcode-546>#</a></h4><p>只能用top-down去做，因為很難確定base case與怎麼從base case長上去
反倒是top-down的分解，就很好做</p><h2 id=技巧>技巧<a hidden class=anchor aria-hidden=true href=#技巧>#</a></h2><h3 id=狀態壓縮>狀態壓縮<a hidden class=anchor aria-hidden=true href=#狀態壓縮>#</a></h3><p>其實就是把應該用set或array表示的狀態用bitmask表示</p><p>因為是bitmask，所以是整數，是整數就能dp</p><h3 id=刷表法>刷表法<a hidden class=anchor aria-hidden=true href=#刷表法>#</a></h3><p><img loading=lazy src=https://i.imgur.com/xaCytTo.png alt>
<img loading=lazy src=https://i.imgur.com/WN4Rm2n.png alt></p><p>省mem，locality變好</p><h3 id=dp優化-我不會這個只會出現在競程>DP優化 (我不會，這個只會出現在競程)<a hidden class=anchor aria-hidden=true href=#dp優化-我不會這個只會出現在競程>#</a></h3><p>太可怕了，就把資料列一列就好
<a href=https://tioj.ck.tp.edu.tw/uploads/attachment/5/27/5.pdf>分治、DP 進階</a>
<a href=https://tioj.ck.tp.edu.tw/uploads/attachment/5/51/10.pdf>Aliens 優化</a>
<a href=https://slides.com/justinlai2003/dp-dp>進階DP，DP優化</a></p><h3 id=寫的小技巧>寫的小技巧<a hidden class=anchor aria-hidden=true href=#寫的小技巧>#</a></h3><ul><li>產生新值時固定寫法<ul><li>有的是<code>f[n + x] = combine(f[n], ....)</code></li><li>有的是<code>f[n] = combine(f[n - x], ....)</code></li><li>最好固定寫法，個人是喜歡<ul><li><code>f[n] = combine(f[n - x], ....)</code></li><li>因為dp一定是由小的更新大的</li></ul></li></ul></li><li>bottom-up或是改寫時可以畫圖輔助<ul><li>狀態怎麼到起點 (參數怎麼變化)</li><li>在table上是取什麼點 (方向)</li></ul></li><li>從終點開始思考怎麼到起點 (top-down開始做)<ul><li>除非bottom-up很明顯，或是top-down在這題是個悲劇</li></ul></li></ul><h2 id=設計方式>設計方式<a hidden class=anchor aria-hidden=true href=#設計方式>#</a></h2><p>dp就是由參數(遞迴的模型的組合)、對應的動作構成、定義回傳值，只能在求最佳化問題(有結合律的函數)使用</p><h3 id=遞迴的模型>遞迴的模型<a hidden class=anchor aria-hidden=true href=#遞迴的模型>#</a></h3><ul><li>線性 (1D)<ul><li><code>f(i) = combine(f(j) for j in range(i))</code></li></ul></li><li>區間 (2D)<ul><li>列舉中點<ul><li><code>f(i,j) = combine(combine2(f(i,k), f(k,j)) for k in range(i,j))</code></li></ul></li><li>控制左右<ul><li><code>f(i,j) = combine(f(i-1,j), f(i,j-1))</code></li></ul></li><li>分塊<ul><li><code>f(i,j) = combine(f(i,a), f(a,b), f(b,j)) for (a,b) in ...</code></li></ul></li></ul></li><li>點 (2D)<ul><li>上、左、左上<ul><li><code>f(i,j) = combine(f(i-1,j), f(i,j-1), f(i-1,j-1))</code></li></ul></li></ul></li><li>樹<ul><li>子樹<ul><li><code>f(root) = combine(f(child) for child in root.children)</code></li></ul></li></ul></li><li>set(狀態壓縮)<ul><li><code>f(state) = combine(f(next(state)))</code></li></ul></li></ul><p>上面是可能的遞迴方式，除了遞迴外，還有其他需要的訊息，像是座標、成本等等</p><p>需要遞迴的，加上其他需要的訊息，就是dp的狀態</p><h3 id=動作>動作<a hidden class=anchor aria-hidden=true href=#動作>#</a></h3><p>這就是看題目了，像是edit distance就有delete、replace、insert
動作會影響到</p><ul><li>子問題怎麼組合</li><li>參數怎麼變化</li><li>有什麼參數</li></ul><h3 id=定義回傳值-成本>定義回傳值 (成本)<a hidden class=anchor aria-hidden=true href=#定義回傳值-成本>#</a></h3><p>dp回來的值一定是可以與其他dp組合在一起的值，像</p><ul><li>最大最小</li><li>總和</li><li>長度</li><li>&mldr;</li></ul><p>通常我們會知道怎麼算最終答案的成本，但是dp時會需要計算當下狀態成本的方式，也就是需要把<em>成本計算分散到每一層</em>
這個吃狀態怎麼設計 以及 觀察
範例可以看Optimal binary search trees的depth怎麼處理的</p><h3 id=多看看其他人怎麼做>多看看其他人怎麼做<a hidden class=anchor aria-hidden=true href=#多看看其他人怎麼做>#</a></h3><p>設計dp有的時候要自己加維度，就如同前面看到的dp不只一種，端看設計與實作</p><p>所以其實寫dp最重要的是觀察與想像，所以多做題</p><h2 id=特別的dp>特別的DP<a hidden class=anchor aria-hidden=true href=#特別的dp>#</a></h2><h3 id=背包>背包<a hidden class=anchor aria-hidden=true href=#背包>#</a></h3><p>01背包:</p><p>選到i，剩下space個空間</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>space</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>space</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>space</span><span class=p>),</span> <span class=n>price</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>space</span><span class=o>-</span><span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span> <span class=c1># !!</span>
</span></span></code></pre></div><p>無限背包:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>space</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>space</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>space</span><span class=p>),</span> <span class=n>price</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>space</span><span class=o>-</span><span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span> <span class=c1># !!</span>
</span></span></code></pre></div><h4 id=滾動--從頭或從尾>滾動 & 從頭或從尾<a hidden class=anchor aria-hidden=true href=#滾動--從頭或從尾>#</a></h4><p>注意到i都是只有i-1，所以可以用滾動，但要改寫成bottom-up</p><p>01背包:</p><p>這裡與原本top-down的差不多，從i往前推</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>W</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>p</span><span class=p>,</span><span class=n>w</span> <span class=ow>in</span> <span class=n>items</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>nowW</span> <span class=ow>in</span> <span class=nb>reversed</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>W</span><span class=o>+</span><span class=mi>1</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=n>nowW</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>nowW</span><span class=p>],</span> <span class=n>p</span><span class=o>+</span><span class=n>dp</span><span class=p>[</span><span class=n>nowW</span><span class=o>-</span><span class=n>w</span><span class=p>])</span>
</span></span></code></pre></div><p>無限背包:</p><p>這裡就與top-down完全不同了!!</p><p>top-down還是，從i往前推，但是可以在i停留，達成無限的效果
bottom-up為了要無限，所以必須每個合法的空間都要加一次，同時還要包含前面的影響</p><p>dp一定是小的先算好，所以一定從前面取，而現在我們想取的值是已經改變過的值，所以要從最小的空間開始往上推</p><p>01背包是不想取到已經改變過的值，所以要從最大的空間往下推</p><p>這裡也彰顯了從頭與從尾的不同!!</p><p>能不能拿到已經改變過的值?</p><ul><li>從頭: 能</li><li>從尾: 不能</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>W</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>p</span><span class=p>,</span><span class=n>w</span> <span class=ow>in</span> <span class=n>items</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>nowW</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>W</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=n>nowW</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>nowW</span><span class=p>],</span> <span class=n>p</span><span class=o>+</span><span class=n>dp</span><span class=p>[</span><span class=n>nowW</span><span class=o>-</span><span class=n>w</span><span class=p>])</span>
</span></span></code></pre></div><h3 id=有環的dp>有環的DP<a hidden class=anchor aria-hidden=true href=#有環的dp>#</a></h3><ol><li>做離散化，每個點做一次</li><li>把環的長度變成兩倍</li></ol><h3 id=mutual-recursion>mutual recursion<a hidden class=anchor aria-hidden=true href=#mutual-recursion>#</a></h3><p>Leetcode 188</p><p>最多賣k次，買完才能賣，求最大收益</p><pre tabindex=0><code>sell[i][k] = 第i天，剩k次，做賣的最大收益
buy[i][k] = 第i天，剩k次，做買的最大收益
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>sell</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>sell</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>k</span><span class=p>),</span> <span class=n>price</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=n>buy</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>buy</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>buy</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>k</span><span class=p>),</span> <span class=o>-</span><span class=n>price</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=n>sell</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></div><p>為什麼要兩個?
buy有自己的收益，sell也有自己的收益
彼此又互相組成對方的收益</p><h2 id=範例>範例<a hidden class=anchor aria-hidden=true href=#範例>#</a></h2><p>來自演算法課本的dp範例</p><p>Algorithm Design(AD): 真的難，但有點東西
Introduction to Algorithm(CLRS): 厚到不能墊泡麵與當枕頭
Algorithms(DPV): 很薄，很精闢
The Algorithm Design Manual(TADM): 就是課本，但可以根據問題屬性去查對應的解法</p><h3 id=edit-distance>edit distance<a hidden class=anchor aria-hidden=true href=#edit-distance>#</a></h3><ul><li>replace: (i-1,j-1)</li><li>delete: (i,j-1)</li><li>insert: (i-1,j)<ul><li>insert多一個字，又馬上比對，所以與delete相反</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span><span class=n>s2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>s1</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>s2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>s1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>s2</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>f</span><span class=p>(</span><span class=n>s1</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>s2</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=o>+</span><span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>s1</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>s2</span><span class=p>[</span><span class=mi>1</span><span class=p>:]),</span> <span class=n>f</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span> <span class=n>s2</span><span class=p>[</span><span class=mi>1</span><span class=p>:]),</span> <span class=n>f</span><span class=p>(</span><span class=n>s1</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>s2</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=longest-common-subsequence--longest-increasing-subsequence>Longest common subsequence & Longest increasing subsequence<a hidden class=anchor aria-hidden=true href=#longest-common-subsequence--longest-increasing-subsequence>#</a></h3><p><a href=/2020/12/lis/>Longest Increasing Subsequence</a></p><h3 id=maximum-subarray-sum-ad>Maximum Subarray Sum (AD)<a hidden class=anchor aria-hidden=true href=#maximum-subarray-sum-ad>#</a></h3><p><a href=/2020/12/mss/>Maximum Subarray Sum</a></p><h3 id=traveling-salesman-problem>Traveling Salesman Problem<a hidden class=anchor aria-hidden=true href=#traveling-salesman-problem>#</a></h3><p>給定一系列城市和每對城市之間的距離，求訪問每一座城市一次並回到起始城市的最短迴路</p><p>cities是還可以去的點，<code>1011</code>，還有2, 1, 0可以去
i是目前的位置</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>cities</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>cities</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>([</span><span class=n>f</span><span class=p>(</span><span class=n>cities</span> <span class=o>^</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>),</span> <span class=n>j</span><span class=p>)</span> <span class=o>+</span> <span class=n>weight</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>if</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>cities</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>],</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=hamiltonian-path>Hamiltonian Path<a hidden class=anchor aria-hidden=true href=#hamiltonian-path>#</a></h3><p>有沒有一條每一點剛好經過一次的路線，起點和終點可以不相同</p><p>N是有幾個地點(<code>len(graph.V())</code>)</p><p>remains是還可以去的點，<code>1011</code>，還有2, 1, 0可以去
i是目前的位置</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>remains</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>remains</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>any</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>remains</span> <span class=o>^</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>),</span> <span class=n>j</span><span class=p>)</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>if</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>remains</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=shortest-paths-dpv>Shortest paths (DPV)<a hidden class=anchor aria-hidden=true href=#shortest-paths-dpv>#</a></h3><p>path本身就是一段接一段的，也就是說它本身就是遞迴</p><p>可以回去，所謂的relaxtion，其實就是在原有的基礎上衍伸一段可以到的edge
這就是list!!</p><p>如果求最短，就是min，是具有結合律的函數，可以dp</p><p>所以可以列舉起、終點、中間點，一直更新最短長度</p><h3 id=rod-cutting-clrs>Rod cutting (CLRS)<a hidden class=anchor aria-hidden=true href=#rod-cutting-clrs>#</a></h3><p>給一條木頭，與長度對應到的價格，求最大收益</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>size</span><span class=o>-</span><span class=n>sub</span><span class=p>)</span><span class=o>+</span><span class=n>price</span> <span class=k>for</span> <span class=n>sub</span><span class=p>,</span><span class=n>price</span> <span class=ow>in</span> <span class=n>size2price</span><span class=o>.</span><span class=n>items</span><span class=p>()</span> <span class=k>if</span> <span class=n>size</span><span class=o>-</span><span class=n>sub</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=matrix-chain-multiplication-clrs-dpv>Matrix-chain multiplication (CLRS, DPV)<a hidden class=anchor aria-hidden=true href=#matrix-chain-multiplication-clrs-dpv>#</a></h3><p>有一排matrix要乘，求計算成本最小</p><p>成本: <code>(a X b) * (b X c) = (a X c)</code> 的 成本是 b</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>j</span><span class=o>-</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span> <span class=c1># 不會有一個matrix相乘</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>k</span><span class=p>)</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>)</span><span class=o>+</span><span class=n>cost</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=optimal-binary-search-trees-clrs>Optimal binary search trees (CLRS)<a hidden class=anchor aria-hidden=true href=#optimal-binary-search-trees-clrs>#</a></h3><p>給key與出現的頻率，組成一個搜尋成本最小的BST</p><p>成本: <code>sum(freq[i]*depth)</code></p><p>一個是tree，所以要分左右
一個是範圍，所以有i,j</p><p>再來是計算成本，所以先把depth傳進去</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=n>dep</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>j</span><span class=o>-</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>k</span><span class=p>,</span><span class=n>dep</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=n>dep</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=n>freq</span><span class=p>[</span><span class=n>key</span><span class=p>[</span><span class=n>k</span><span class=p>]]</span> <span class=o>*</span> <span class=n>dep</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></div><p>有沒有辦法把depth消滅掉?
看成橫的
先看tree</p><pre tabindex=0><code>      i
   i-1 i+1
i-2        i+2
</code></pre><p>再看當時遞迴的範圍</p><pre tabindex=0><code>              [i-2~i+2]
     [i-2~i-1]         [i+1~i+2]
[i-2]                           [i+2]
</code></pre><p>以i+2來說，由上往下看被加了3次，只看遞迴時的範圍，會發現剛好都i+2出現了3次
所以可以把depth去掉，變成每一次就把整個遞迴範圍的freq加總就好</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>j</span><span class=o>-</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>k</span><span class=p>)</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>)</span><span class=o>+</span><span class=nb>sum</span><span class=p>(</span><span class=n>freq</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>j</span><span class=p>])</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=minimum-length-triangulation-tadm>Minimum Length Triangulation (TADM)<a hidden class=anchor aria-hidden=true href=#minimum-length-triangulation-tadm>#</a></h3><p>有一堆點，構成一個多邊形，把多邊形切成三角形，讓成本最小</p><p>成本: 所有三角形邊長的總和</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dist</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sqrt</span><span class=p>((</span><span class=n>p1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>p2</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>*</span><span class=p>(</span><span class=n>p1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>p2</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>+</span> <span class=p>(</span><span class=n>p1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>p2</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span><span class=o>*</span><span class=p>(</span><span class=n>p1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>p2</span><span class=p>[</span><span class=mi>1</span><span class=p>]))</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>cost</span><span class=p>(</span><span class=n>points</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dist</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>+</span> <span class=n>dist</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>points</span><span class=p>[</span><span class=n>k</span><span class=p>])</span> <span class=o>+</span> <span class=n>dist</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>k</span><span class=p>],</span> <span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>j</span><span class=o>-</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=n>j</span><span class=o>-</span><span class=n>i</span> <span class=o>==</span> <span class=mi>3</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cost</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>k</span><span class=p>)</span> <span class=o>+</span> <span class=n>cost</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>k</span><span class=p>,</span><span class=n>j</span><span class=p>)</span> <span class=o>+</span> <span class=n>f</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>j</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=independent-sets-in-trees-dpv>Independent sets in trees (DPV)<a hidden class=anchor aria-hidden=true href=#independent-sets-in-trees-dpv>#</a></h3><p>Independent set就是裡面的點沒有edge互連，求最多點的set</p><p>就是選了root就不能選children，但可以加上grand-children</p><pre tabindex=0><code>f(root) = max(sum(f(children)), 1+sum(grand-children))
</code></pre><h3 id=maximum-rectangle-problem-ad>Maximum Rectangle Problem (AD)<a hidden class=anchor aria-hidden=true href=#maximum-rectangle-problem-ad>#</a></h3><p>給個matrix，求從中框出的長方形的內部數字總和</p><p>先做row的prefix sum
再根據前面的prefix sum，做每個column的prefix sum</p><p>之後就是用排容: <code>f(i,j,n,m) = area(i,j) - area(i-n,j) - area(i,j-m) + area(i-n, j-m)</code></p><h3 id=segmented-least-squares-ad>Segmented least squares (AD)<a hidden class=anchor aria-hidden=true href=#segmented-least-squares-ad>#</a></h3><p>有一堆點，要用最少的線去fit這些點</p><p>定義回傳值: cost</p><p>定義cost: 每個點的e + 常數*幾根線</p><p>用到Optimal binary search trees把depth分散到每一層去做的技巧</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>error</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c1># Check 6. DYNAMIC PROGRAMMING I page 30</span>
</span></span><span class=line><span class=cl>  <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>error</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>i</span><span class=p>)</span> <span class=o>+</span> <span class=n>常數</span> <span class=o>+</span> <span class=n>f</span><span class=p>(</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=find-the-longest-path-in-a-matrix-with-given-constraintshttpswwwgeeksforgeeksorgfind-the-longest-path-in-a-matrix-with-given-constraints><a href=https://www.geeksforgeeks.org/find-the-longest-path-in-a-matrix-with-given-constraints/>Find the longest path in a matrix with given constraints</a><a hidden class=anchor aria-hidden=true href=#find-the-longest-path-in-a-matrix-with-given-constraintshttpswwwgeeksforgeeksorgfind-the-longest-path-in-a-matrix-with-given-constraints>#</a></h3><p>這裡要注意的是沒有去重的東西，所以開始dfs時要從終點開始走</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>path</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>m</span><span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dirs</span> <span class=o>=</span> <span class=p>[(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>),(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>),(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>),(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=o>*</span><span class=p>[</span><span class=n>path</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span> <span class=k>for</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span> <span class=ow>in</span> <span class=n>dirs</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>reversed</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>reversed</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>m</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=assembly-line-schedulinghttpswwwgeeksforgeeksorgassembly-line-scheduling-dp-34><a href=https://www.geeksforgeeks.org/assembly-line-scheduling-dp-34/>Assembly Line Scheduling</a><a hidden class=anchor aria-hidden=true href=#assembly-line-schedulinghttpswwwgeeksforgeeksorgassembly-line-scheduling-dp-34>#</a></h3><p>dag最長路徑</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># t :: time to switch another line</span>
</span></span><span class=line><span class=cl><span class=c1># a :: time of each station</span>
</span></span><span class=line><span class=cl><span class=c1># e :: cost on starting line</span>
</span></span><span class=line><span class=cl><span class=c1># x :: cost on goal</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>j</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>e</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=n>t</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=ow>not</span> <span class=n>i</span><span class=p>)][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=ow>not</span> <span class=n>i</span><span class=p>),</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>j</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span> <span class=c1># at goal</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div><h3 id=optimal-strategy-for-a-gamehttpswwwgeeksforgeeksorgoptimal-strategy-for-a-game-dp-31><a href=https://www.geeksforgeeks.org/optimal-strategy-for-a-game-dp-31/>Optimal Strategy for a Game</a><a hidden class=anchor aria-hidden=true href=#optimal-strategy-for-a-gamehttpswwwgeeksforgeeksorgoptimal-strategy-for-a-game-dp-31>#</a></h3><p>一開始先用一個me表示對面在做決策
有點像買股票的那一提</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=n>me</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span><span class=o>&gt;</span><span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>i</span><span class=o>==</span><span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>if</span> <span class=n>me</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>me</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># ????</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=ow>not</span> <span class=n>me</span><span class=p>),</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=ow>not</span> <span class=n>me</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># ????</span>
</span></span></code></pre></div><p>Q: 看別人的分數幹嘛
A: 雖然說我們的結果與他們有關，但是他的分數與我們無關</p><p>下面的也是類似的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>x</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span><span class=o>&gt;</span><span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>i</span> <span class=o>==</span> <span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-</span><span class=n>y</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>),</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>-</span><span class=n>y</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>y</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span><span class=o>&gt;</span><span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>i</span> <span class=o>==</span> <span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-</span><span class=n>x</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>),</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>-</span><span class=n>x</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></div><p>選下一輪能選的時候分數最少的case (關注要建構的目標)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span><span class=o>&gt;</span><span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>i</span> <span class=o>==</span> <span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>,</span> <span class=n>j</span><span class=p>),</span> <span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>)),</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>+</span><span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>2</span><span class=p>),</span> <span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>)))</span>
</span></span></code></pre></div><h3 id=partition-problemhttpswwwgeeksforgeeksorgpartition-problem-dp-18><a href=https://www.geeksforgeeks.org/partition-problem-dp-18/>Partition problem</a><a hidden class=anchor aria-hidden=true href=#partition-problemhttpswwwgeeksforgeeksorgpartition-problem-dp-18>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>cnt</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>cnt</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>cnt</span><span class=o>-</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=ow>or</span> <span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>cnt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>f</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>//</span><span class=mi>2</span><span class=p>)</span> <span class=k>if</span> <span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=kc>False</span>
</span></span></code></pre></div><h3 id=partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimumhttpswwwgeeksforgeeksorgpartition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum><a href=https://www.geeksforgeeks.org/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/>Partition a set into two subsets such that the difference of subset sums is minimum</a><a hidden class=anchor aria-hidden=true href=#partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimumhttpswwwgeeksforgeeksorgpartition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum>#</a></h3><p>這個會變成backtrack</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>cnt</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>abs</span><span class=p>((</span><span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=n>cnt</span><span class=p>)</span> <span class=o>-</span> <span class=n>cnt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>cnt</span><span class=o>+</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]),</span> <span class=n>f</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>cnt</span><span class=p>))</span>
</span></span></code></pre></div><p>原因是f想直接算差值，但是差值一定要等到最後，把所有路都走過
可以對其中一個維度做離散化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>cnt</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cnt</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>cnt</span><span class=p>)</span> <span class=ow>or</span> <span class=n>f</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>cnt</span><span class=o>-</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=nb>reversed</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>//</span><span class=mi>2</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>f</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>2</span><span class=o>*</span><span class=n>n</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=題外話-functional-dp>題外話: functional DP<a hidden class=anchor aria-hidden=true href=#題外話-functional-dp>#</a></h2><p><a href=https://zhuanlan.zhihu.com/p/104238120>函数式的动态规划</a></p><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://slides.com/fhvirus/greedy-dq-dp>Greedy & DQ & DP</a>
<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NjU1MzIxNg==&mid=2247483846&idx=1&sn=7691121f35968b55b2474681d16ebb24&chksm=ce485d29f93fd43fe8b8645c5b6a77e2fbab86be395e16d87ba6e1470c3afa065df7712e7e3e&token=1626063786&lang=zh_CN#rd">夜深人静写算法（二）- 动态规划入门</a>
<a href=https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/06DynamicProgrammingI.pdf>6. DYNAMIC PROGRAMMING I</a>
<a href=https://oi-wiki.org/dp/knapsack/>背包 DP</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/11/%E6%BC%94%E7%AE%97%E6%B3%95%E6%9C%83%E7%94%A8%E5%88%B0%E7%9A%84%E6%A6%82%E5%BF%B5/><span class=title>« Prev</span><br><span>演算法會用到的概念</span>
</a><a class=next href=https://littlebees.github.io/2021/11/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%9C%96%E8%AB%96%E6%8A%80%E5%B7%A7%E9%80%B2%E9%9A%8E%E5%9C%96%E8%AB%96/><span class=title>Next »</span><br><span>神奇的圖論技巧(進階圖論)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>