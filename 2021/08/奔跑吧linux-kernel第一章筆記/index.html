<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>奔跑吧linux kernel第一章筆記 | 記事本</title>
<meta name=keywords content="Linux"><meta name=description content="動機
這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/08/%E5%A5%94%E8%B7%91%E5%90%A7linux-kernel%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/08/%E5%A5%94%E8%B7%91%E5%90%A7linux-kernel%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AD%86%E8%A8%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="奔跑吧linux kernel第一章筆記"><meta property="og:description" content="動機
這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/08/%E5%A5%94%E8%B7%91%E5%90%A7linux-kernel%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-12T15:39:00+00:00"><meta property="article:modified_time" content="2021-08-12T15:39:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="奔跑吧linux kernel第一章筆記"><meta name=twitter:description content="動機
這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"奔跑吧linux kernel第一章筆記","item":"https://littlebees.github.io/2021/08/%E5%A5%94%E8%B7%91%E5%90%A7linux-kernel%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"奔跑吧linux kernel第一章筆記","name":"奔跑吧linux kernel第一章筆記","description":"動機 這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧\n","keywords":["Linux"],"articleBody":"動機 這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧\ncpu risc \u0026 cisc cisc有micro operation!! big, little endian union { int a; char b; } x; x.a = 1; return (x.b == 1); // true for little-endian 執行過程 課本款: IF \u003e ID \u003e EX \u003e MEM \u003e WB x86 from L1 cache IF+branch predition ID translate into micro operation(uops) dispatch (out-of-order exec) rename (int, float) scheduler EXE commit results (in-order) WB (by LSQ) to L1 cache arm from L1 cache IF+branch predition ID (可以多路，cortex-A9是2路) rename (reg) dispatch (out-of-order exec, 可以多路，這裡是4路) EXE WB (by LSU(LSQ in x86)) to L1 cache unit LSQ: 處理memory consistency \u0026 cache coherence memory consistency (Read/write的順序是不是對的) strict consistency sequential consistency weak consistency 有資料指令與同步指令(mem barrier) mem barrier in arm data mem barrier: 前面的讀寫操作都完成才會commit DMM後面的結果 data sync barrier: 前面的讀寫操作都完成才會執行DSB後面的指令 instraction sync barrier: flush pipeline或是buffer後才開始拿ISB後面的指令 cache coherence (cache中的資料有效嗎) MESI protocal cache與mem一致 E: 獨佔態(只有我有這資料且與mem一樣) S: 共用態(多人有這資料且與mem一樣) 不一致 I: 無效態 M: 修改態 (只有我有這資料) 監聽protocal (另一種叫directory protocal) 在4個動作做state transfer 讀寫mem 讀寫cache superscalar arch: 一次發射多條指令 reg rename: 消滅WAR, WAW 當某cmd出事時不會影響到後面的指令 cache 結構 set: 同一index的cache line(想成有很多張表) line: len(mx[i]) (不包含tag, cache line大小一般來說是32Bytes) way: matrix(表) tag: cache line的MD5 index, offset: mx[index][offset] map 方式 direct mapping 只有一張表，所以很容易與其他index相同的資料撞 cache thrashing addr: tag[31:6], index[5:4], line[3:2], …[1:0]` line是mx[i][j]的j，index就是i set mapping 多張表，讓同index撞的機率變小 從哪個addr取cache index VIVT virtual index, virtual tag cache alias 一個實體addr可以map到多個cache line 當假addr換了，就要clear或invalidate cache VIPT virtual index, physical tag 可以同時查TLB與跑MMU 不用怕當假addr換了，就要clear或invalidate cache 但還是可能有cache alias PIPT physical index, physical tag 從virtual addr到physical addr的過程 cpu -\u003e MMU -\u003e cache -\u003e 查page table 在aarch64 virtual addr(VA): ttbx[64:63], ...[62:48], L0index[47:39], L1index[38:30], L2index[29:21], L3index[20:12], VA[11:0] ttbx有兩個register(ttbx0,ttbx1)分別是高位與低位的page table的base addr 之後就是用index去每一層table去換下一層的addr page size: 64KB, 16KB, 4KB physical addr(PA): ...[64:63], ...[62:48], PA(from table)[47:12], PA(from virtual addr)[11:0] cache與linux kernel的關係是 kernel大部分資料結構都是與cache line對齊的 不然會橫跨兩條以上的cache line需要invalidate時會把另一個也一起劃掉 cache evict策略 random fifo lru 多process與TLB關係? 多process會讓VA常常需要去換PA，這很慢 所以有TLB去cache，以page為單位 如果process很大，可以適時把page size拉大，讓TLB不容易爆cache ","wordCount":"276","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-08-12T15:39:00Z","dateModified":"2021-08-12T15:39:00Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/08/%E5%A5%94%E8%B7%91%E5%90%A7linux-kernel%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">奔跑吧linux kernel第一章筆記</h1><div class=post-meta><span title='2021-08-12 15:39:00 +0000 UTC'>August 12, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#cpu aria-label=cpu>cpu</a></li><li><a href=#cache aria-label=cache>cache</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧</p><h2 id=cpu>cpu<a hidden class=anchor aria-hidden=true href=#cpu>#</a></h2><ul><li>risc & cisc<ul><li>cisc有micro operation!!</li></ul></li><li>big, little endian</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x</span><span class=p>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>b</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// true for little-endian
</span></span></span></code></pre></div><ul><li>執行過程<ul><li>課本款: IF > ID > EX > MEM > WB</li><li>x86<ul><li>from L1 cache</li><li>IF+branch predition</li><li>ID</li><li>translate into micro operation(uops)</li><li>dispatch (out-of-order exec)</li><li>rename (int, float)</li><li>scheduler</li><li>EXE</li><li>commit results (in-order)</li><li>WB (by LSQ)</li><li>to L1 cache</li></ul></li><li>arm<ul><li>from L1 cache</li><li>IF+branch predition</li><li>ID (可以多路，cortex-A9是2路)</li><li>rename (reg)</li><li>dispatch (out-of-order exec, 可以多路，這裡是4路)</li><li>EXE</li><li>WB (by LSU(LSQ in x86))</li><li>to L1 cache</li></ul></li></ul></li><li>unit<ul><li>LSQ: 處理memory consistency & cache coherence<ul><li>memory consistency (Read/write的順序是不是對的)<ul><li>strict consistency</li><li>sequential consistency</li><li>weak consistency<ul><li>有資料指令與同步指令(mem barrier)<ul><li>mem barrier in arm<ul><li>data mem barrier: 前面的讀寫操作都完成才會commit DMM後面的結果</li><li>data sync barrier: 前面的讀寫操作都完成才會執行DSB後面的指令</li><li>instraction sync barrier: flush pipeline或是buffer後才開始拿ISB後面的指令</li></ul></li></ul></li></ul></li></ul></li><li>cache coherence (cache中的資料有效嗎)<ul><li>MESI protocal<ul><li>cache與mem一致<ul><li>E: 獨佔態(只有我有這資料且與mem一樣)</li><li>S: 共用態(多人有這資料且與mem一樣)</li></ul></li><li>不一致<ul><li>I: 無效態</li><li>M: 修改態 (只有我有這資料)</li></ul></li><li>監聽protocal (另一種叫directory protocal)</li><li>在4個動作做state transfer<ul><li>讀寫mem</li><li>讀寫cache</li></ul></li></ul></li></ul></li></ul></li><li>superscalar arch: 一次發射多條指令</li><li>reg rename:<ol><li>消滅WAR, WAW</li><li>當某cmd出事時不會影響到後面的指令</li></ol></li></ul></li></ul><h2 id=cache>cache<a hidden class=anchor aria-hidden=true href=#cache>#</a></h2><ul><li>結構<ul><li>set: 同一index的cache line(想成有很多張表)</li><li>line: <code>len(mx[i])</code> (不包含tag, cache line大小一般來說是32Bytes)</li><li>way: matrix(表)</li><li>tag: cache line的MD5</li><li>index, offset: <code>mx[index][offset]</code></li></ul></li><li>map 方式<ul><li>direct mapping<ul><li>只有一張表，所以很容易與其他index相同的資料撞<ul><li>cache thrashing</li><li>addr: tag[31:6], index[5:4], line[3:2], &mldr;[1:0]`<ul><li>line是<code>mx[i][j]</code>的j，index就是i</li></ul></li></ul></li></ul></li><li>set mapping<ul><li>多張表，讓同index撞的機率變小
<img loading=lazy src=https://en.wikipedia.org/wiki/File:Cache,associative-fill-both.png alt></li></ul></li></ul></li><li>從哪個addr取cache index<ul><li>VIVT<ul><li>virtual index, virtual tag<ul><li>cache alias<ul><li>一個實體addr可以map到多個cache line</li><li>當假addr換了，就要clear或invalidate cache</li></ul></li></ul></li></ul></li><li>VIPT<ul><li>virtual index, physical tag<ul><li>可以同時查TLB與跑MMU<ul><li>不用怕當假addr換了，就要clear或invalidate cache</li></ul></li><li>但還是可能有cache alias</li></ul></li></ul></li><li>PIPT<ul><li>physical index, physical tag</li></ul></li></ul></li><li>從virtual addr到physical addr的過程<ul><li>cpu -> MMU -> cache -> 查page table</li><li>在aarch64<ul><li>virtual addr(VA): <code>ttbx[64:63], ...[62:48], L0index[47:39], L1index[38:30], L2index[29:21], L3index[20:12], VA[11:0]</code><ul><li>ttbx有兩個register(ttbx0,ttbx1)分別是高位與低位的page table的base addr</li><li>之後就是用index去每一層table去換下一層的addr<ul><li>page size: 64KB, 16KB, 4KB</li></ul></li></ul></li><li>physical addr(PA): <code>...[64:63], ...[62:48], PA(from table)[47:12], PA(from virtual addr)[11:0]</code></li></ul></li></ul></li><li>cache與linux kernel的關係是<ul><li>kernel大部分資料結構都是與cache line對齊的<ul><li>不然會橫跨兩條以上的cache line需要invalidate時會把另一個也一起劃掉</li></ul></li></ul></li><li>cache evict策略<ul><li>random</li><li>fifo</li><li>lru</li></ul></li><li>多process與TLB關係?<ul><li>多process會讓VA常常需要去換PA，這很慢</li><li>所以有TLB去cache，以page為單位<ul><li>如果process很大，可以適時把page size拉大，讓TLB不容易爆cache</li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/08/leetcode-386-lexicographical-numbers/><span class=title>« Prev</span><br><span>leetcode-386 - Lexicographical Numbers</span>
</a><a class=next href=https://littlebees.github.io/2021/08/leetcode-954-array-of-doubled-pairs/><span class=title>Next »</span><br><span>leetcode-954 - Array of Doubled Pairs</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>