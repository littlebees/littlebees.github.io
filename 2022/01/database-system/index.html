<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>database system | 記事本</title>
<meta name=keywords content="DB"><meta name=description content="動機
我之前學的DB根本就是假的
這是來自nthu的DB課程，有slide但沒有prjects
難道之後要跑CMU 15-445嗎?
不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2022/01/database-system/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="database system"><meta property="og:description" content="動機
我之前學的DB根本就是假的
這是來自nthu的DB課程，有slide但沒有prjects
難道之後要跑CMU 15-445嗎?
不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2022/01/database-system/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-17T16:28:53+00:00"><meta property="article:modified_time" content="2022-01-17T16:28:53+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="database system"><meta name=twitter:description content="動機
我之前學的DB根本就是假的
這是來自nthu的DB課程，有slide但沒有prjects
難道之後要跑CMU 15-445嗎?
不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"database system","item":"https://littlebees.github.io/2022/01/database-system/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"database system","name":"database system","description":"動機 我之前學的DB根本就是假的 這是來自nthu的DB課程，有slide但沒有prjects\n難道之後要跑CMU 15-445嗎? 不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分\n","keywords":["DB"],"articleBody":"動機 我之前學的DB根本就是假的 這是來自nthu的DB課程，有slide但沒有prjects\n難道之後要跑CMU 15-445嗎? 不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分\nWhy not file systems? query可以組合 以tx為單位 ACID!! 有辦法recover 讓recover的資料一致 query怎麼處理? SELECT p.id, p.text FROM posts AS p, users AS u WHERE u.id = p.authorId AND u.name='Bob' AND p.text ILIKE '%db%'; Query Optimization: plan EXPLAIN EXPLAIN ANALYZE -- show plan tree SELECT * FROM users WHERE id\u003c5 AND name ILIKE '%User%' ORDER BY id DESC LIMIT 2; filter, zip, select (where, join, select) FROM posts AS p, users AS u WHERE u.id = p.authorId AND u.name=‘Bob’ AND p.text ILIKE ‘%db%’ SELECT p.id, p.text Handling “Big” Data when deleting NO ACTION (default): user not deleted, error raised CASCADE: user and all referencing posts deleted Query Optimization: index index 一個mapping function 加速 equality 或是 range selections equality hashing function key到一堆有關的值 其他hash function的issue去看資料結構 range selections B-Tree 最後map到一堆有關的值 每一個node就是放起點的list how to lock? Lock Crabbing Protocol Input: field values or ranges search key Primary index vs. secondary index index中有沒有Primary key Output: rids (record的id) 因為是根據field建tree或hash，所以如果有改row，就要更新index Faster reads at the cost of slower writes inverted index concurency 說好的ACID Atomicity: all or nothing 通常只有這個 Consistent: db的整體狀態是對的 Isolation: 這才是我印象中的atomic 要自己來 Duration: 資料庫內的資料不會因為斷電，系統崩潰而損失資料。 總的來說，tx根本就是一般function (但會rollback)\n怎麼出事 Dirty Read: 有人讀還沒commit的欄位 如果之後這個欄位被rollback… 可能好: 最後有被commited 不好: 被rollback，之前看的資料就沒效了 Non Repeatable read: (在tx中) 讀同個row兩次的結果不一樣 (race condition) row為單位的race condition Phantom Read: (在tx中) 同個query拿到的rows不一樣 (race condition) table為單位的race condition (在條件上race condition) Serialization Anomaly: 因為tx commit的順序不同導致最後結果inconsistence reorder Isolation Read Uncommitted: 沒有任何保證 Read Committed: 寫完的不會變了 (mem consistency) 可以用read lock與write lock來保證 鎖在tx的執行啟動與完成 (mutual exclusion) Repeatable Read: (就是名字寫的) 可以用read lock與write lock來保證 鎖在有用到的所有row Serialisable: tx跑起來與serial一樣 dependency (mem barrier) 工具 lock Pessimistic (Exclusive): mutex Optimistic (Shared): read/write lock 或是 seq lock snapshot: row versioning(MVCC): 就是row的持久化，每一個tx的更新對row來說都是一個版本的更新 Two Phase Locking: 先把lock全部拿完，開跑 到最後再把lock還回去 Ref How does a database server handle thousands of concurrent requests? On Concurrency Control in Databases\nDB Architecture Server and infrastructures (jdbc, sql, tx, and utils) Transaction Concurrency 2PC lock protocol 要用就先拿lock，用完馬上unlock strict 2PC lock protocol 一次拿完所有需要的lock，tx完成後unlock Multiple-Granularity Locks: allows users to set locks on objects that contain other objects Recovery 定義Failure Transaction hangs System hangs/crashes Assumptions Contents in nonvolatile storage are not corrupted No Byzantine failure (zombies) Other types of failure will be dealt with in other ways Log 就是紀錄做過的動作 紀錄在? cache failure時可能會消失 log file failure後依然存在 只要有就是真的做過!! 動作有? 操作 實際上的操作 with tx id 改值、table等等 mark tx 開始、commit rollback 目的是? Recovery: Rollback未完成/已完成的tx 未完成的tx: 在log file Rollback: 把tx取消掉 動作 從尾開始 undo對到tx id的item 直到遇到tx id的start Checkpoint 幫log分界，不然每次都跑整條其實很慢 Checkpoint之前的commit可以不用管!! Quiescent Checkpointing 動作 關tx 等現在正在跑的tx好 (可能很久) flush all buffer 把checkpoint寫到log cache，再到log file 開tx Nonquiescent Checkpointing 動作 關tx 在checkpoint的log中記錄現在正在跑的tx的tx id flush all buffer 把checkpoint寫到log cache，再到log file 開tx 怎麼Recovery Undo-only Recovery Log有 commit flush改完的block 塞commit log到buffer 塞到log file rollback flush改完的block 塞commit log到buffer 塞到log file 動作 從尾到頭，看每個item 紀錄commit、rollback的tx id 做完的 實際上的操作 tx id有看過? 沒事 沒看過? undo UNDO-REDO recovery 1 Log有 commit flush改完的block 塞commit log到buffer 塞到log file rollback flush改完的block 塞commit log到buffer 塞到log file 動作 UNDO (消除uncommit的影響) 從尾到頭，看每個item 紀錄commit、rollback的tx id 做完的 實際上的操作 tx id有看過? 沒事 沒看過? undo REDO (讓commit保證存在) 從頭到尾，看每個item 在commit list的item redo 動作重複做沒關係嗎? 都是set value，沒差，反正順序對 idempotent UNDO-REDO recovery 2 Log有 commit flush改完的block 塞commit log到buffer 塞到log file rollback flush改完的block 塞commit log到buffer 塞到log file 動作 UNDO (消除uncommit的影響) 從尾到頭，看每個item 紀錄commit、rollback的tx id 做完的 實際上的操作 tx id有看過? 沒事 沒看過? undo REDO (讓commit保證存在) 從頭到尾，看每個item 在commit list的item redo 動作重複做沒關係嗎? 都是set value，沒差，反正順序對 idempotent Redo-Only Recovery steal tx中改過的block可能在commit完成前就被swap出去!! 如果沒有steal 只要redo就好 因為會到log file的state與HDD的一定一致 Repeating history Early Lock Release meta-structrue的lock會提早釋放 (但block不釋放lock) 不然要操作其他block時無法concurrent 變成要等meta-struct 變成block與meta的更新會不一致!! Logical Operations 不能根據當時的state做直接的undo state可能被其他tx變了，雖然block有lock，但meta沒有!! 這也代表undo不是idempotent undo也是屬於一般的動作了 也要記到log Rollback Logical Operations (soft delete) 卡在中間? 把剩下的直接undo 跑完了? 先拿要拿的所有lock 再undo Recovery by Repeating History REDO (重建現場) 從最近的checkpoint，開始重作所有動作 UNDO (消去未完成tx的影響) 看REDO-UNDO recovery Logical OPs怎麼處理? 卡在中間? 把剩下的直接undo 跑完了? skip (soft delete) 原本現在連undo都要log，所以有另一個名字 Compensation Logs Physiological logging (op reorder你敢信) 把一些OPs集中成一個Logical Operation 可以省log大小 但原本執行上的dependency沒了 不能直接REDO REDO-UNDO Recovery in Physiological logging REDO (重建現場) 跳過已經redo過的Physiological logging how? skip, in ARIES algorithm UNDO (消去未完成tx的影響) 把Physiological logging當成一個op去undo Query engine 把SQL compile 成 AST (relational algebra) relational algebra 做plan(選tree的樣子，做cost estimation) cost estimation\n定義cost\nnumber of block accesses: 掃到多少block B(p) 有多少record被output: R(p) 在p table中的f field的值域大小: V(p,f) index的成本: SearchCost(p,f) 跑跑看\nR(student)=10000 B(student)=1000 B(dept)= 500 selectivity(s-id=5\u0026major-id=4)=0.01 Left: (1000+10000*500)*10ms = 13.9 hours Right: (1000+100000.01500)*10ms = 8.4 mins estimate this cost\n值域很大，不可能1對1的去看 分區!! 怎麼算、怎麼實作 skip (見 Query Optimization) Generate trees\nNot finding the best tree Avoiding bad trees!! consider left-skew candidate trees only 在join時，大部分都是走訪右邊 Goal ↓B(root) reduced to ↓R(c1) Pushing Select ops down 越早select越好 Greedy Join ordering 只要確保每次join是最小，最後就是最小 (DP) Selinger-Style Optimizer Deterministic Query Planning Algorithm\n從from拉table\n跑where\n再跑select\ngroup by, having? 一直return回去\n用scan去爬每一個node的record Pipelined Scanning call一次給一筆 Materialized Scanning batch處理，放到temp file，一次回傳 丟給上一層做下一步處理 Storage engine 怎麼被存的? (實作OS的hdd與mem管理)\nDatabase: directory Table: file Record: bytes 怎麼與HDD互動? (實作可以跑query的file system)\nBlockId Immutable Identifies a specific logical block A file name + logical block number BlockId blk = new BlockId(\"std.tbl\", 23); Page Holds the contents of a block Backed by an I/O buffer in OS Not tied to a specific block Read/write/append an entire block a time Set values are not flushed until write() 怎麼增加從disk拉的速度? 兩個方向 low-level block API Pros 可以直接控制phy層資料的位置 不用管OS的任何限制 Cons 實作十份複雜 沒有portability file system Pros 簡單易用 Cons 無法控制phy層資料的位置 無法控制page filesystem的實作可能把db的正確性破壞掉 只能一直flush 怎麼與mem互動? (實作block的cache)\ncache什麼? user data (DBs, including catalogs) logs (meta-writes) No Virtual Memory!! bad page replacement algorithms OS可能換到不想要的page uncontrolled delayed writes Swapping 無法控制 (should be direct I/O!!) 需要swap的page資訊(meta data) Self-Managed Page Controlled swapping Supports meta-writes Cache Pages Access Pattern Random block reads and writes Concurrent access to multiple blocks Predictable access to certain blocks how to cache? buffer pool: a pool of pages Caching multiple blocks Implement swapping Pool Size 要夠大 (至少所有正在用到的page都要放到pool) 不然會Deadlock detect deadlock 看pin有沒有timeout deal with deadlock 抓一個犧牲者 把他的block全部unpin 之後在慢慢pin回來 如果是一個人pin爆了pool? 只能死亡 (丟例外) 利用Predictable access block Pinning Blocks: 不會被swap出去 流程 pin block 在某個page read 完成就unpin block A block can be pinned multiple times Pinning Pages: Hit cache成功 Swapping page dirty要swap回去 很多page? replacement strategies Waiting 所有人都pin了，所以要等 Buffers = page + page的meta data 例子 現在做pin(60); pin(70); Buffer Replacement Strategies Naïve 只要unpin的就好 hit rate低 buffers are not evenly utilized FIFO 挑read in時間最早的 Assumption: the older blocks are less likely to be used in the future counter: catalog blocks!! LRU 找最早unpin的 Assumption: blocks that are not used in the near past will unlikely be used in the near future Clock 很像Naïve，但是從上次replace的地方開始找 Caching Logs Log用在 ACID的C與I，Write-Ahead-Logging (WAL) commit時 log在tx中做的動作到buffer 要commit時，先把buffer倒到log file 倒完再寫一個完成commit(COMMIT log)的log到log file swap page時 把buffer flush掉 rollback 誰要rollback? 沒有COMMIT log的tx 3 possibilities for each action on disk With log and block 用log去undo，把block改好 With log, but without block 用log去undo，把block改好 Without log and block 不用管 Assumption of WAL each block-write either succeeds or fails entirely on a disk, despite power failure 需要Pool嗎? 不用 log是single buffer Always appends Always sequential backward reads record怎麼存? (linux的fs只有char與block，但現在我們有datatype)\n所有record(a table)都要在同一個file?\nHomogeneous 有利於single-table queries Heterogeneous 有利於需要join的queries 一筆record(row)的所有部分都要在同一個block?\nSpanned 沒有空間浪費 record大小不用受制於block大小 Unspanned 只要讀一個block就是一筆record 所有部分都要緊貼著彼此嗎?\nRow-oriented store Row-by-row Column-oriented store 存成好幾個array Pros \u0026 Cons 欄位(datatype)要固定大小嗎?\nFixed-Length Variable-Length 內部block怎麼處理 the record’s length changes delete a record soft delete 刪掉的空間沒辦法用 把space空出來 cannot random access a record in a page =\u003e no position information page layout header放 record總數 free space的終點 指到record的mapping table 改大小的話 要重新找連續的free space 碎片化 VACUUM command 怎麼管理free space (怎麼知道哪裡有free space)\nChaining Meta-Pages Meta-File 每個record的大小? 其他與db有關的訊息放在哪?\ncatalog tables Table metadata table的資訊 (大小、長度…) View metadata view的訊息 (creater,…) Index metadata 每個欄位的index in mem Statistical metadata 關於table的統計資訊，可以在plan時使用 Group Communication 分散式計算\nDB Workloads Operational workloads OLTP (On-line Transaction Processing) 跑tx多，執行時間短 Analytic workloads Online (OLAP) or offline 資料分析 Cloud DB SAE high Scalability\n可水平擴展來拉throughput S through partitioning Partition your hot tables horizontally vertically 要處理 分散的 metadata manager query processor (record, plan) transactions Distributed S2PL 看 分散式那一份筆記 的 怎麼commit那一部分 high Availability\n不能死，除了網路、硬體問題外 A through replication Replicate all tables across servers Replication Eager 在ㄌtx commit之前，每台都要完成 strong consistency, slow tx Lazy local先寫，之後再非同步的同步到另一台去 eventual consistency, fast tx Who Writes? Master/Slave write只有某一台處理 read由其他台負責 Multi-Master write每一台都可以負責 Elasticity\n能根據machine與workload去動態調整data分布 Re-Partitioning Data chunking 使用者指定 系統生成 (consistent hashing) Master server for load monitoring Migrate Migration with Determinism 做一個空的replica 在兩個db上跑同一個tx，只拉用到的data (Foreground Pushing) 剩下就是非同步的推 (Background Pushing) Migration vs. Crabbing Client served by any node running faster Migration delay imperceptible 我同時serve，我同時migrate SAE + 完整的retional DB基本上不可能 Workarounds No expressive model 在應用層處理(dirty work) No flexible queries 多發幾個query或是繼續在應用層處理(dirty work) No tx and ACID 在應用層處理 Ref nthu-datalab/db\n","wordCount":"1269","inLanguage":"en","datePublished":"2022-01-17T16:28:53Z","dateModified":"2022-01-17T16:28:53Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2022/01/database-system/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">database system</h1><div class=post-meta><span title='2022-01-17 16:28:53 +0000 UTC'>January 17, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#why-not-file-systems aria-label="Why not file systems?">Why not file systems?</a></li><li><a href=#query%e6%80%8e%e9%ba%bc%e8%99%95%e7%90%86 aria-label=query怎麼處理?>query怎麼處理?</a><ul><li><a href=#query-optimization-plan aria-label="Query Optimization: plan">Query Optimization: plan</a><ul><li><a href=#explain aria-label=EXPLAIN>EXPLAIN</a></li></ul></li><li><a href=#filter-zip-select-where-join-select aria-label="filter, zip, select (where, join, select)">filter, zip, select (where, join, select)</a></li><li><a href=#handling-big-data aria-label="Handling “Big” Data">Handling “Big” Data</a></li><li><a href=#when-deleting aria-label="when deleting">when deleting</a></li><li><a href=#query-optimization-index aria-label="Query Optimization: index">Query Optimization: index</a><ul><li><a href=#inverted-index aria-label="inverted index">inverted index</a></li></ul></li><li><a href=#concurency aria-label=concurency>concurency</a><ul><li><a href=#%e8%aa%aa%e5%a5%bd%e7%9a%84acid aria-label=說好的ACID>說好的ACID</a></li><li><a href=#%e6%80%8e%e9%ba%bc%e5%87%ba%e4%ba%8b aria-label=怎麼出事>怎麼出事</a></li><li><a href=#isolation aria-label=Isolation>Isolation</a></li><li><a href=#%e5%b7%a5%e5%85%b7 aria-label=工具>工具</a></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></li></ul></li><li><a href=#db-architecture aria-label="DB Architecture">DB Architecture</a><ul><li><a href=#server-and-infrastructures-jdbc-sql-tx-and-utils aria-label="Server and infrastructures (jdbc, sql, tx, and utils)">Server and infrastructures (jdbc, sql, tx, and utils)</a></li><li><a href=#query-engine aria-label="Query engine">Query engine</a></li><li><a href=#storage-engine aria-label="Storage engine">Storage engine</a></li></ul></li><li><a href=#group-communication aria-label="Group Communication">Group Communication</a></li><li><a href=#db-workloads aria-label="DB Workloads">DB Workloads</a></li><li><a href=#cloud-db aria-label="Cloud DB">Cloud DB</a><ul><li><a href=#sae aria-label=SAE>SAE</a></li><li><a href=#sae--%e5%ae%8c%e6%95%b4%e7%9a%84retional-db%e5%9f%ba%e6%9c%ac%e4%b8%8a%e4%b8%8d%e5%8f%af%e8%83%bd aria-label="SAE + 完整的retional DB基本上不可能">SAE + 完整的retional DB基本上不可能</a></li></ul></li><li><a href=#ref-1 aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>我之前學的DB根本就是假的
這是來自nthu的DB課程，有slide但沒有prjects</p><p>難道之後要跑CMU 15-445嗎?
不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分</p><h2 id=why-not-file-systems>Why not file systems?<a hidden class=anchor aria-hidden=true href=#why-not-file-systems>#</a></h2><ul><li>query可以組合</li><li>以tx為單位<ul><li>ACID!!</li></ul></li><li>有辦法recover<ul><li>讓recover的資料一致</li></ul></li></ul><h2 id=query怎麼處理>query怎麼處理?<a hidden class=anchor aria-hidden=true href=#query怎麼處理>#</a></h2><pre tabindex=0><code class="language-sql=" data-lang="sql=">SELECT p.id, p.text
FROM posts AS p, users AS u
WHERE u.id = p.authorId
AND u.name=&#39;Bob&#39;
AND p.text ILIKE &#39;%db%&#39;;
</code></pre><h3 id=query-optimization-plan>Query Optimization: plan<a hidden class=anchor aria-hidden=true href=#query-optimization-plan>#</a></h3><p><img loading=lazy src=https://i.imgur.com/CDg7Nvt.png alt></p><h4 id=explain>EXPLAIN<a hidden class=anchor aria-hidden=true href=#explain>#</a></h4><pre tabindex=0><code class="language-sql=" data-lang="sql=">EXPLAIN ANALYZE -- show plan tree
SELECT * 
FROM users 
WHERE id&lt;5 AND name ILIKE &#39;%User%&#39;
ORDER BY id DESC
LIMIT 2;
</code></pre><h3 id=filter-zip-select-where-join-select>filter, zip, select (where, join, select)<a hidden class=anchor aria-hidden=true href=#filter-zip-select-where-join-select>#</a></h3><ol><li><p>FROM posts AS p, users AS u
<img loading=lazy src=https://i.imgur.com/g47PF4u.png alt></p></li><li><p>WHERE u.id = p.authorId AND u.name=&lsquo;Bob&rsquo; AND p.text ILIKE &lsquo;%db%&rsquo;
<img loading=lazy src=https://i.imgur.com/ZTReEKR.png alt></p></li><li><p>SELECT p.id, p.text
<img loading=lazy src=https://i.imgur.com/U6opZ8y.png alt></p></li></ol><h3 id=handling-big-data>Handling “Big” Data<a hidden class=anchor aria-hidden=true href=#handling-big-data>#</a></h3><p><img loading=lazy src=https://i.imgur.com/pE53j9J.png alt></p><h3 id=when-deleting>when deleting<a hidden class=anchor aria-hidden=true href=#when-deleting>#</a></h3><ul><li>NO ACTION (default): user not deleted, error raised</li><li>CASCADE: user and all referencing posts deleted</li></ul><h3 id=query-optimization-index>Query Optimization: index<a hidden class=anchor aria-hidden=true href=#query-optimization-index>#</a></h3><p><img loading=lazy src=https://i.imgur.com/XA9qi26.png alt></p><ul><li>index<ul><li>一個mapping function<ul><li>加速 equality 或是 range selections<ul><li>equality<ul><li>hashing function<ul><li>key到一堆有關的值</li><li>其他hash function的issue去看資料結構</li></ul></li></ul></li><li>range selections<ul><li>B-Tree<ul><li><img loading=lazy src=https://i.imgur.com/nluejlo.png alt></li><li>最後map到一堆有關的值</li><li>每一個node就是放起點的list</li><li>how to lock?<ul><li>Lock Crabbing Protocol<ul><li><img loading=lazy src=https://i.imgur.com/4eHta9c.png alt></li><li><img loading=lazy src=https://i.imgur.com/w5FggKV.png alt></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>Input: field values or ranges<ul><li>search key<ul><li>Primary index vs. secondary index<ul><li>index中有沒有Primary key</li></ul></li></ul></li></ul></li><li>Output: rids (record的id)</li></ul></li><li>因為是根據field建tree或hash，所以如果有改row，就要更新index<ul><li>Faster reads at the cost of slower writes</li></ul></li></ul></li></ul><h4 id=inverted-index>inverted index<a hidden class=anchor aria-hidden=true href=#inverted-index>#</a></h4><p><img loading=lazy src=https://i.imgur.com/HTDWwkW.png alt></p><h3 id=concurency>concurency<a hidden class=anchor aria-hidden=true href=#concurency>#</a></h3><h4 id=說好的acid>說好的ACID<a hidden class=anchor aria-hidden=true href=#說好的acid>#</a></h4><ul><li>Atomicity: all or nothing<ul><li>通常只有這個</li></ul></li><li>Consistent: db的整體狀態是對的</li><li>Isolation: 這才是我印象中的atomic<ul><li>要自己來</li></ul></li><li>Duration: 資料庫內的資料不會因為斷電，系統崩潰而損失資料。</li></ul><p>總的來說，tx根本就是一般function (但會rollback)</p><h4 id=怎麼出事>怎麼出事<a hidden class=anchor aria-hidden=true href=#怎麼出事>#</a></h4><ul><li>Dirty Read: 有人讀還沒commit的欄位<ul><li>如果之後這個欄位被rollback&mldr;</li><li>可能好: 最後有被commited</li><li>不好: 被rollback，之前看的資料就沒效了</li><li><img loading=lazy src=https://i.imgur.com/Ss5tf6y.png alt></li></ul></li><li>Non Repeatable read: (在tx中) 讀<strong>同個row</strong>兩次的結果不一樣 (race condition)<ul><li>row為單位的race condition</li><li><img loading=lazy src=https://i.imgur.com/ON6xWUk.png alt></li></ul></li><li>Phantom Read: (在tx中) <strong>同個query</strong>拿到的rows不一樣 (race condition)<ul><li>table為單位的race condition (在條件上race condition)</li><li><img loading=lazy src=https://i.imgur.com/bvXn98W.png alt></li></ul></li><li>Serialization Anomaly: 因為tx commit的順序不同導致最後結果inconsistence<ul><li>reorder</li></ul></li></ul><h4 id=isolation>Isolation<a hidden class=anchor aria-hidden=true href=#isolation>#</a></h4><ul><li>Read Uncommitted: 沒有任何保證</li><li>Read Committed: 寫完的不會變了 (mem consistency)<ul><li>可以用read lock與write lock來保證<ul><li>鎖在tx的執行啟動與完成 (mutual exclusion)</li></ul></li></ul></li><li>Repeatable Read: (就是名字寫的)<ul><li>可以用read lock與write lock來保證<ul><li>鎖在有用到的所有row</li></ul></li></ul></li><li>Serialisable: tx跑起來與serial一樣<ul><li>dependency (mem barrier)</li></ul></li></ul><h4 id=工具>工具<a hidden class=anchor aria-hidden=true href=#工具>#</a></h4><ul><li>lock<ul><li>Pessimistic (Exclusive): mutex</li><li>Optimistic (Shared): read/write lock 或是 seq lock</li></ul></li><li>snapshot:</li><li>row versioning(MVCC): 就是row的持久化，每一個tx的更新對row來說都是一個版本的更新</li><li>Two Phase Locking:<ul><li>先把lock全部拿完，開跑</li><li>到最後再把lock還回去</li><li><img loading=lazy src=https://i.imgur.com/zO8T2iL.png alt></li></ul></li></ul><p><img loading=lazy src=https://miro.medium.com/max/583/1*IkJmNJ-pJxSe7Mt_gvHUiw.png alt>
<img loading=lazy src=https://i.imgur.com/sOpIPr7.png alt></p><h4 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h4><p><a href=https://medium.com/how-the-web-works/how-does-a-database-server-handle-thousands-of-concurrent-requests-d54352310183>How does a database server handle thousands of concurrent requests?</a>
<a href=https://www.gojek.io/blog/on-concurrency-control-in-databases>On Concurrency Control in Databases</a></p><h2 id=db-architecture>DB Architecture<a hidden class=anchor aria-hidden=true href=#db-architecture>#</a></h2><p><img loading=lazy src=https://i.imgur.com/WEINwhN.png alt></p><h3 id=server-and-infrastructures-jdbc-sql-tx-and-utils>Server and infrastructures (jdbc, sql, tx, and utils)<a hidden class=anchor aria-hidden=true href=#server-and-infrastructures-jdbc-sql-tx-and-utils>#</a></h3><ul><li>Transaction<ul><li>Concurrency<ul><li>2PC lock protocol<ul><li>要用就先拿lock，用完馬上unlock</li></ul></li><li>strict 2PC lock protocol<ul><li>一次拿完所有需要的lock，tx完成後unlock</li></ul></li><li>Multiple-Granularity Locks: allows users to set locks on objects that contain other objects<ul><li><img loading=lazy src=https://i.imgur.com/EkH0aWl.png alt></li><li><img loading=lazy src=https://i.imgur.com/UyBuBJD.png alt></li><li><img loading=lazy src=https://i.imgur.com/Fg0vdh2.png alt></li><li><img loading=lazy src=https://i.imgur.com/HgBAYPv.png alt></li></ul></li></ul></li><li>Recovery<ul><li>定義Failure<ul><li>Transaction hangs</li><li>System hangs/crashes</li><li>Assumptions<ul><li>Contents in nonvolatile storage are not corrupted</li><li>No Byzantine failure (zombies)</li><li>Other types of failure will be dealt with in other ways</li></ul></li></ul></li><li>Log<ul><li>就是紀錄做過的動作<ul><li>紀錄在?<ul><li>cache<ul><li>failure時可能會消失</li></ul></li><li>log file<ul><li>failure後依然存在<ul><li>只要有就是真的做過!!</li></ul></li></ul></li></ul></li><li>動作有?<ul><li>操作<ul><li>實際上的操作 with tx id<ul><li>改值、table等等</li></ul></li><li>mark<ul><li>tx 開始、commit</li><li>rollback</li></ul></li></ul></li></ul></li><li>目的是?<ul><li>Recovery: Rollback未完成/已完成的tx<ul><li>未完成的tx: 在log file</li></ul></li><li>Rollback: 把tx取消掉<ul><li>動作<ul><li>從尾開始</li><li>undo對到tx id的item</li><li>直到遇到tx id的start</li></ul></li></ul></li></ul></li></ul></li><li>Checkpoint<ul><li>幫log分界，不然每次都跑整條其實很慢<ul><li>Checkpoint之前的commit可以不用管!!</li></ul></li><li>Quiescent Checkpointing<ul><li>動作<ul><li>關tx</li><li>等現在正在跑的tx好 (可能很久)</li><li>flush all buffer</li><li>把checkpoint寫到log cache，再到log file</li><li>開tx</li></ul></li><li><img loading=lazy src=https://i.imgur.com/hNqR3yN.png alt></li></ul></li><li>Nonquiescent Checkpointing<ul><li>動作<ul><li>關tx</li><li>在checkpoint的log中記錄現在正在跑的tx的tx id</li><li>flush all buffer</li><li>把checkpoint寫到log cache，再到log file</li><li>開tx</li></ul></li><li><img loading=lazy src=https://i.imgur.com/36BgK56.png alt></li></ul></li></ul></li></ul></li><li>怎麼Recovery<ul><li>Undo-only Recovery<ul><li>Log有<ul><li>commit<ul><li>flush改完的block</li><li>塞commit log到buffer</li><li>塞到log file</li></ul></li><li>rollback<ul><li>flush改完的block</li><li>塞commit log到buffer</li><li>塞到log file</li></ul></li></ul></li><li>動作<ul><li>從尾到頭，看每個item<ul><li>紀錄commit、rollback的tx id<ul><li>做完的</li></ul></li><li>實際上的操作<ul><li>tx id有看過?<ul><li>沒事</li></ul></li><li>沒看過?<ul><li>undo</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>UNDO-REDO recovery 1<ul><li>Log有<ul><li>commit<ul><li><del>flush改完的block</del></li><li>塞commit log到buffer</li><li>塞到log file</li></ul></li><li>rollback<ul><li>flush改完的block</li><li>塞commit log到buffer</li><li>塞到log file</li></ul></li></ul></li><li>動作<ul><li>UNDO (消除uncommit的影響)<ul><li>從尾到頭，看每個item<ul><li>紀錄commit、rollback的tx id<ul><li>做完的</li></ul></li><li>實際上的操作<ul><li>tx id有看過?<ul><li>沒事</li></ul></li><li>沒看過?<ul><li>undo</li></ul></li></ul></li></ul></li></ul></li><li>REDO (讓commit保證存在)<ul><li>從頭到尾，看每個item<ul><li>在commit list的item<ul><li>redo</li></ul></li></ul></li></ul></li><li>動作重複做沒關係嗎?<ul><li>都是set value，沒差，反正順序對<ul><li>idempotent</li></ul></li></ul></li></ul></li></ul></li><li>UNDO-REDO recovery 2<ul><li>Log有<ul><li>commit<ul><li><del>flush改完的block</del></li><li>塞commit log到buffer</li><li>塞到log file</li></ul></li><li>rollback<ul><li><del>flush改完的block</del></li><li>塞commit log到buffer</li><li>塞到log file</li></ul></li></ul></li><li>動作<ul><li>UNDO (消除uncommit的影響)<ul><li>從尾到頭，看每個item<ul><li>紀錄commit、<del>rollback</del>的tx id<ul><li>做完的</li></ul></li><li>實際上的操作<ul><li>tx id有看過?<ul><li>沒事</li></ul></li><li>沒看過?<ul><li>undo</li></ul></li></ul></li></ul></li></ul></li><li>REDO (讓commit保證存在)<ul><li>從頭到尾，看每個item<ul><li>在commit list的item<ul><li>redo</li></ul></li></ul></li></ul></li><li>動作重複做沒關係嗎?<ul><li>都是set value，沒差，反正順序對<ul><li>idempotent</li></ul></li></ul></li></ul></li></ul></li><li>Redo-Only Recovery<ul><li>steal<ul><li>tx中改過的block可能在commit完成前就被swap出去!!</li></ul></li><li>如果沒有steal<ul><li>只要redo就好<ul><li>因為會到log file的state與HDD的一定一致</li></ul></li></ul></li></ul></li><li>Repeating history<ul><li>Early Lock Release<ul><li>meta-structrue的lock會提早釋放 (但block不釋放lock)<ul><li>不然要操作其他block時無法concurrent<ul><li>變成要等meta-struct</li></ul></li></ul></li><li>變成block與meta的更新會不一致!!<ul><li>Logical Operations<ul><li>不能根據當時的state做<strong>直接的</strong>undo<ul><li>state可能被其他tx變了，雖然block有lock，但meta沒有!!</li><li>這也代表undo不是idempotent<ul><li>undo也是屬於一般的動作了<ul><li>也要記到log</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>Rollback Logical Operations (soft delete)<ul><li><img loading=lazy src=https://i.imgur.com/nJh9ETm.png alt><ul><li>卡在中間?<ul><li>把剩下的直接undo</li></ul></li><li>跑完了?<ul><li>先拿要拿的所有lock</li><li>再undo</li></ul></li></ul></li></ul></li><li>Recovery by Repeating History<ul><li>REDO (重建現場)<ul><li>從最近的checkpoint，開始重作所有動作</li></ul></li><li>UNDO (消去未完成tx的影響)<ul><li>看REDO-UNDO recovery</li><li>Logical OPs怎麼處理?<ul><li>卡在中間?<ul><li>把剩下的直接undo</li></ul></li><li>跑完了?<ul><li>skip (soft delete)</li></ul></li></ul></li></ul></li><li>原本現在連undo都要log，所以有另一個名字<ul><li>Compensation Logs</li></ul></li></ul></li></ul></li></ul></li><li>Physiological logging (op reorder你敢信)<ul><li>把一些OPs集中成一個Logical Operation<ul><li>可以省log大小</li><li>但原本執行上的dependency沒了<ul><li>不能直接REDO</li></ul></li></ul></li><li>REDO-UNDO Recovery in Physiological logging<ul><li>REDO (重建現場)<ul><li>跳過已經redo過的Physiological logging<ul><li>how?<ul><li>skip, in ARIES algorithm</li></ul></li></ul></li></ul></li><li>UNDO (消去未完成tx的影響)<ul><li>把Physiological logging當成一個op去undo</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id=query-engine>Query engine<a hidden class=anchor aria-hidden=true href=#query-engine>#</a></h3><ul><li>把SQL compile 成 AST (relational algebra)<ul><li>relational algebra<ul><li><img loading=lazy src=https://i.imgur.com/4oj4Gbq.png alt></li></ul></li></ul></li><li>做plan(選tree的樣子，做cost estimation)<ul><li><p>cost estimation</p><ul><li><p>定義cost</p><ul><li>number of block accesses: 掃到多少block <code>B(p)</code><ul><li>有多少record被output: <code>R(p)</code></li><li>在p table中的f field的值域大小: <code>V(p,f)</code></li><li>index的成本: <code>SearchCost(p,f)</code></li><li><img loading=lazy src=https://i.imgur.com/KmJK7kU.png alt></li></ul></li></ul></li><li><p>跑跑看</p><ul><li><img loading=lazy src=https://i.imgur.com/AOgFaH1.png alt><ul><li>R(student)=10000</li><li>B(student)=1000</li><li>B(dept)= 500</li><li>selectivity(s-id=5&amp;major-id=4)=0.01</li></ul></li><li>Left: (1000+10000*500)*10ms = 13.9 hours</li><li>Right: (1000+10000<em>0.01</em>500)*10ms = 8.4 mins</li></ul></li><li><p>estimate this cost</p><ul><li><img loading=lazy src=https://i.imgur.com/GYoGsqk.png alt></li><li>值域很大，不可能1對1的去看<ul><li>分區!!</li><li><img loading=lazy src=https://i.imgur.com/N5zSMAq.png alt><ul><li>怎麼算、怎麼實作 skip (見 Query Optimization)</li></ul></li></ul></li></ul></li></ul></li><li><p>Generate trees</p><ul><li>Not finding the best tree<ul><li>Avoiding bad trees!!</li></ul></li><li>consider <strong>left-skew</strong> candidate trees only<ul><li>在join時，大部分都是走訪右邊</li></ul></li><li><img loading=lazy src=https://i.imgur.com/9ivnTbB.png alt><ul><li>Goal <code>↓B(root)</code> reduced to <code>↓R(c1)</code><ul><li>Pushing Select ops down<ul><li>越早select越好</li><li><img loading=lazy src=https://i.imgur.com/lyrRQQU.png alt></li></ul></li><li>Greedy Join ordering<ul><li><img loading=lazy src=https://i.imgur.com/A3kg4Gv.png alt></li><li>只要確保每次join是最小，最後就是最小 (DP)<ul><li>Selinger-Style Optimizer<ul><li><img loading=lazy src=https://i.imgur.com/AlUqst3.png alt></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>Deterministic Query Planning Algorithm</p><ul><li><p>從from拉table</p></li><li><p>跑where</p></li><li><p>再跑select</p><ul><li>group by, having?<ul><li><img loading=lazy src=https://i.imgur.com/zOeeblT.png alt></li></ul></li></ul></li><li><p>一直return回去</p></li></ul></li></ul></li><li>用scan去爬每一個node的record<ul><li>Pipelined Scanning<ul><li>call一次給一筆</li></ul></li><li>Materialized Scanning<ul><li>batch處理，放到temp file，一次回傳</li></ul></li></ul></li><li>丟給上一層做下一步處理</li></ul><h3 id=storage-engine>Storage engine<a hidden class=anchor aria-hidden=true href=#storage-engine>#</a></h3><ul><li><p>怎麼被存的? (實作OS的hdd與mem管理)</p><ul><li>Database: directory</li><li>Table: file</li><li>Record: bytes</li></ul></li><li><p>怎麼與HDD互動? (實作可以跑query的file system)</p><ul><li><img loading=lazy src=https://i.imgur.com/anX7t7g.png alt></li><li><img loading=lazy src=https://i.imgur.com/TcJAGO3.png alt><ul><li>BlockId<ul><li>Immutable</li><li>Identifies a specific logical block<ul><li>A file name + logical block number</li><li><code>BlockId blk = new BlockId("std.tbl", 23);</code></li></ul></li></ul></li><li>Page<ul><li>Holds the contents of a block<ul><li>Backed by an I/O buffer in OS</li></ul></li><li>Not tied to a specific block</li><li>Read/write/append an entire block a time<ul><li>Set values are not flushed until write()</li></ul></li></ul></li></ul></li><li>怎麼增加從disk拉的速度? 兩個方向<ul><li>low-level block API<ul><li>Pros<ul><li>可以直接控制phy層資料的位置</li><li>不用管OS的任何限制</li></ul></li><li>Cons<ul><li>實作十份複雜</li><li>沒有portability</li></ul></li></ul></li><li>file system<ul><li>Pros<ul><li>簡單易用</li></ul></li><li>Cons<ul><li>無法控制phy層資料的位置</li><li>無法控制page</li><li>filesystem的實作可能把db的正確性破壞掉<ul><li>只能一直flush</li></ul></li></ul></li></ul></li><li><img loading=lazy src=https://i.imgur.com/j1KeQFa.png alt></li></ul></li></ul></li><li><p>怎麼與mem互動? (實作block的cache)</p><ul><li><img loading=lazy src=https://i.imgur.com/klXUHQl.png alt><ul><li>cache什麼?<ul><li>user data (DBs, including catalogs)</li><li>logs (meta-writes)</li></ul></li></ul></li><li>No Virtual Memory!!<ul><li>bad page replacement algorithms<ul><li>OS可能換到不想要的page</li></ul></li><li>uncontrolled delayed writes<ul><li>Swapping 無法控制 (should be direct I/O!!)</li><li>需要swap的page資訊(meta data)</li></ul></li></ul></li><li>Self-Managed Page<ul><li>Controlled swapping</li><li>Supports meta-writes</li></ul></li><li>Cache Pages<ul><li>Access Pattern<ul><li>Random block reads and writes</li><li>Concurrent access to multiple blocks</li><li>Predictable access to certain blocks</li></ul></li><li>how to cache?<ul><li>buffer pool: a pool of pages<ul><li>Caching multiple blocks</li><li>Implement swapping</li><li>Pool Size<ul><li>要夠大 (至少所有正在用到的page都要放到pool)<ul><li>不然會Deadlock<ul><li>detect deadlock<ul><li>看pin有沒有timeout</li></ul></li><li>deal with deadlock<ul><li>抓一個犧牲者<ul><li>把他的block全部unpin</li><li>之後在慢慢pin回來</li></ul></li></ul></li><li>如果是一個人pin爆了pool?<ul><li>只能死亡 (丟例外)</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>利用Predictable access block<ul><li>Pinning Blocks: 不會被swap出去<ul><li>流程<ul><li>pin block 在某個page</li><li>read</li><li>完成就unpin block</li></ul></li><li>A block can be pinned multiple times</li></ul></li><li>Pinning Pages:<ul><li>Hit<ul><li>cache成功</li></ul></li><li>Swapping<ul><li>page dirty要swap回去</li><li>很多page? replacement strategies</li></ul></li><li>Waiting<ul><li>所有人都pin了，所以要等</li></ul></li></ul></li><li>Buffers = page + page的meta data</li></ul></li><li>例子<ul><li><img loading=lazy src=https://i.imgur.com/PVaHTWC.png alt></li><li><img loading=lazy src=https://i.imgur.com/PdBYAen.png alt></li><li><img loading=lazy src=https://i.imgur.com/bIdRdwW.png alt></li><li>現在做<code>pin(60); pin(70);</code></li></ul></li><li>Buffer Replacement Strategies<ul><li>Naïve<ul><li>只要unpin的就好<ul><li><img loading=lazy src=https://i.imgur.com/yzzkicp.png alt></li></ul></li><li>hit rate低<ul><li>buffers are not evenly utilized</li></ul></li></ul></li><li>FIFO<ul><li>挑read in時間最早的<ul><li><img loading=lazy src=https://i.imgur.com/wthUnck.png alt></li></ul></li><li>Assumption: the older blocks are less likely to be used in the future<ul><li>counter: catalog blocks!!</li></ul></li></ul></li><li>LRU<ul><li>找最早unpin的<ul><li><img loading=lazy src=https://i.imgur.com/qfIB7z9.png alt></li></ul></li><li>Assumption: blocks that are not used in the near past will unlikely be used in the near future</li></ul></li><li>Clock<ul><li>很像Naïve，但是從上次replace的地方開始找<ul><li><img loading=lazy src=https://i.imgur.com/QyeuPMY.png alt></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>Caching Logs<ul><li>Log用在<ul><li>ACID的C與I，Write-Ahead-Logging (WAL)<ul><li>commit時<ul><li>log在tx中做的動作到buffer</li><li>要commit時，先把buffer倒到log file</li><li>倒完再寫一個完成commit(COMMIT log)的log到log file</li></ul></li><li>swap page時<ul><li>把buffer flush掉</li></ul></li><li>rollback<ul><li>誰要rollback?<ul><li>沒有COMMIT log的tx</li></ul></li><li>3 possibilities for each action on disk<ul><li>With log and block<ul><li>用log去undo，把block改好</li></ul></li><li>With log, but without block<ul><li>用log去undo，把block改好</li></ul></li><li>Without log and block<ul><li>不用管</li></ul></li></ul></li></ul></li><li>Assumption of WAL<ul><li>each block-write either succeeds or fails <strong>entirely</strong> on a disk, despite power failure</li></ul></li></ul></li></ul></li><li>需要Pool嗎?<ul><li>不用<ul><li>log是single buffer</li><li>Always appends</li><li>Always sequential backward reads</li></ul></li></ul></li></ul></li></ul></li><li><p>record怎麼存? (linux的fs只有char與block，但現在我們有datatype)</p><ul><li><p>所有record(a table)都要在同一個file?</p><ul><li>Homogeneous<ul><li>有利於single-table queries</li></ul></li><li>Heterogeneous<ul><li>有利於需要join的queries</li></ul></li></ul></li><li><p>一筆record(row)的所有部分都要在同一個block?</p><ul><li>Spanned<ul><li><img loading=lazy src=https://i.imgur.com/Tum3DS6.png alt></li><li>沒有空間浪費</li><li>record大小不用受制於block大小</li></ul></li><li>Unspanned<ul><li><img loading=lazy src=https://i.imgur.com/EATTwFV.png alt></li><li>只要讀一個block就是一筆record</li></ul></li></ul></li><li><p>所有部分都要緊貼著彼此嗎?</p><ul><li>Row-oriented store<ul><li>Row-by-row</li><li><img loading=lazy src=https://i.imgur.com/J0lc3O9.png alt></li></ul></li><li>Column-oriented store<ul><li>存成好幾個array</li><li><img loading=lazy src=https://i.imgur.com/wXFU8E6.png alt></li></ul></li><li>Pros & Cons<ul><li><img loading=lazy src=https://i.imgur.com/vNCySWN.png alt></li></ul></li></ul></li><li><p>欄位(datatype)要固定大小嗎?</p><ul><li>Fixed-Length</li><li>Variable-Length<ul><li><img loading=lazy src=https://i.imgur.com/Bdih5TW.png alt></li><li><img loading=lazy src=https://i.imgur.com/l79xWNt.png alt></li><li><img loading=lazy src=https://i.imgur.com/miTtFQh.png alt></li><li>內部block怎麼處理<ul><li>the record’s length changes<ul><li><img loading=lazy src=https://i.imgur.com/7YFSOFT.png alt></li></ul></li><li>delete a record<ul><li>soft delete<ul><li><img loading=lazy src=https://i.imgur.com/jodMuMC.png alt></li><li>刪掉的空間沒辦法用</li></ul></li><li>把space空出來<ul><li><img loading=lazy src=https://i.imgur.com/2bRP2K4.png alt></li></ul></li></ul></li><li>cannot random access a record in a page => no position information<ul><li>page layout<ul><li>header放<ul><li>record總數</li><li>free space的終點</li><li>指到record的mapping table</li></ul></li><li><img loading=lazy src=https://i.imgur.com/TfpWg5K.png alt></li><li>改大小的話<ul><li>要重新找連續的free space</li><li>碎片化<ul><li>VACUUM command</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>怎麼管理free space (怎麼知道哪裡有free space)</p><ul><li>Chaining<ul><li><img loading=lazy src=https://i.imgur.com/73yKFdP.png alt></li></ul></li><li>Meta-Pages<ul><li><img loading=lazy src=https://i.imgur.com/hxVq7dc.png alt></li></ul></li><li>Meta-File<ul><li><img loading=lazy src=https://i.imgur.com/E592ci3.png alt></li></ul></li></ul></li></ul></li><li><p>每個record的大小? 其他與db有關的訊息放在哪?</p><ul><li>catalog tables<ul><li>Table metadata<ul><li>table的資訊 (大小、長度&mldr;)</li></ul></li><li>View metadata<ul><li>view的訊息 (creater,&mldr;)</li></ul></li><li>Index metadata<ul><li>每個欄位的index</li></ul></li></ul></li><li>in mem<ul><li>Statistical metadata<ul><li>關於table的統計資訊，可以在plan時使用</li></ul></li></ul></li></ul></li></ul><h2 id=group-communication>Group Communication<a hidden class=anchor aria-hidden=true href=#group-communication>#</a></h2><p><a href=/2022/01/Distributed-computing/>分散式計算</a></p><h2 id=db-workloads>DB Workloads<a hidden class=anchor aria-hidden=true href=#db-workloads>#</a></h2><ul><li>Operational workloads<ul><li>OLTP (On-line Transaction Processing)</li><li>跑tx多，執行時間短</li></ul></li><li>Analytic workloads<ul><li>Online (OLAP) or offline</li><li>資料分析</li></ul></li></ul><p><img loading=lazy src=https://i.imgur.com/hAL8cX1.png alt>
<img loading=lazy src=https://i.imgur.com/KACy2im.png alt></p><h2 id=cloud-db>Cloud DB<a hidden class=anchor aria-hidden=true href=#cloud-db>#</a></h2><h3 id=sae>SAE<a hidden class=anchor aria-hidden=true href=#sae>#</a></h3><ul><li><p>high Scalability</p><ul><li>可水平擴展來拉throughput<ul><li>S through partitioning<ul><li>Partition your hot tables<ul><li><img loading=lazy src=https://i.imgur.com/ckxSnBV.png alt><ul><li>horizontally</li><li>vertically</li></ul></li><li>要處理<ul><li><img loading=lazy src=https://i.imgur.com/0gEMkqy.png alt></li><li>分散的<ul><li>metadata manager</li><li>query processor (record, plan)</li><li>transactions<ul><li>Distributed S2PL<ul><li>看 分散式那一份筆記 的 怎麼commit那一部分</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>high Availability</p><ul><li>不能死，除了網路、硬體問題外<ul><li>A through replication<ul><li>Replicate all tables across servers<ul><li><img loading=lazy src=https://i.imgur.com/DdbNPlg.png alt></li><li>Replication<ul><li>Eager<ul><li>在ㄌtx commit之前，每台都要完成<ul><li>strong consistency, slow tx</li></ul></li><li><img loading=lazy src=https://i.imgur.com/8KvaJxa.png alt></li></ul></li><li>Lazy<ul><li>local先寫，之後再非同步的同步到另一台去<ul><li>eventual consistency, fast tx</li></ul></li><li><img loading=lazy src=https://i.imgur.com/Iakgc26.png alt></li></ul></li></ul></li><li>Who Writes?<ul><li>Master/Slave<ul><li>write只有某一台處理</li><li>read由其他台負責</li></ul></li><li>Multi-Master<ul><li>write每一台都可以負責</li></ul></li></ul></li><li><img loading=lazy src=https://i.imgur.com/zVZPzYg.png alt></li></ul></li></ul></li></ul></li></ul></li><li><p>Elasticity</p><ul><li>能根據machine與workload去動態調整data分布<ul><li>Re-Partitioning<ul><li>Data chunking<ul><li>使用者指定</li><li>系統生成 (consistent hashing)<ul><li>Master server for load monitoring</li></ul></li></ul></li></ul></li><li>Migrate<ul><li>Migration with Determinism<ul><li>做一個空的replica</li><li>在兩個db上跑同一個tx，只拉用到的data (Foreground Pushing)<ul><li><img loading=lazy src=https://i.imgur.com/O4cilIy.png alt></li></ul></li><li>剩下就是非同步的推 (Background Pushing)<ul><li><img loading=lazy src=https://i.imgur.com/2bkTMSL.png alt></li></ul></li></ul></li><li>Migration vs. Crabbing<ul><li>Client served by any node running faster</li><li>Migration delay imperceptible</li><li>我同時serve，我同時migrate</li><li><img loading=lazy src=https://i.imgur.com/pZ94hQP.png alt></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id=sae--完整的retional-db基本上不可能>SAE + 完整的retional DB基本上不可能<a hidden class=anchor aria-hidden=true href=#sae--完整的retional-db基本上不可能>#</a></h3><ul><li>Workarounds<ul><li>No expressive model<ul><li>在應用層處理(dirty work)</li></ul></li><li>No flexible queries<ul><li>多發幾個query或是繼續在應用層處理(dirty work)</li></ul></li><li>No tx and ACID<ul><li>在應用層處理</li></ul></li></ul></li></ul><h2 id=ref-1>Ref<a hidden class=anchor aria-hidden=true href=#ref-1>#</a></h2><p><a href=https://github.com/nthu-datalab/db/tree/master/slides>nthu-datalab/db</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/db/>DB</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2022/01/%E9%9B%BB%E8%85%A6%E5%BE%9E0%E9%96%8B%E5%A7%8B/><span class=title>« Prev</span><br><span>電腦從0開始</span>
</a><a class=next href=https://littlebees.github.io/2022/01/distributed-computing/><span class=title>Next »</span><br><span>Distributed computing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>