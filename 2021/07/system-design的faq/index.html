<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>system-design的faq | 記事本</title>
<meta name=keywords content="System Design"><meta name=description content="動機
之前面試莫名其妙被system design電到翻過去，
之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。
目前發現這個，看完發現，原來我之前只有準備一半啊
system design的面試其實有一定的程序要走，不是單純的QA
這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的
所以這篇，是要補完這點。"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/07/system-design%E7%9A%84faq/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/07/system-design%E7%9A%84faq/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="system-design的faq"><meta property="og:description" content="動機
之前面試莫名其妙被system design電到翻過去，
之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。
目前發現這個，看完發現，原來我之前只有準備一半啊
system design的面試其實有一定的程序要走，不是單純的QA
這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的
所以這篇，是要補完這點。"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/07/system-design%E7%9A%84faq/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-04T02:45:06+00:00"><meta property="article:modified_time" content="2021-07-04T02:45:06+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="system-design的faq"><meta name=twitter:description content="動機
之前面試莫名其妙被system design電到翻過去，
之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。
目前發現這個，看完發現，原來我之前只有準備一半啊
system design的面試其實有一定的程序要走，不是單純的QA
這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的
所以這篇，是要補完這點。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"system-design的faq","item":"https://littlebees.github.io/2021/07/system-design%E7%9A%84faq/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"system-design的faq","name":"system-design的faq","description":"動機 之前面試莫名其妙被system design電到翻過去， 之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。\n目前發現這個，看完發現，原來我之前只有準備一半啊\nsystem design的面試其實有一定的程序要走，不是單純的QA 這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的\n所以這篇，是要補完這點。\n","keywords":["System Design"],"articleBody":"動機 之前面試莫名其妙被system design電到翻過去， 之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。\n目前發現這個，看完發現，原來我之前只有準備一半啊\nsystem design的面試其實有一定的程序要走，不是單純的QA 這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的\n所以這篇，是要補完這點。\n過程 需求 功能 output 格式 Input的量 每秒多少資料 每秒多少request throughput Queries Per Second, QPS 預期希望處理多少資料 latency 限制 有什麼機器，spec core RAM CAP CA 一致性(總是能拿到最新的) + 可用性(拿得到資料) 單一DB AP \u0026 CP 分區容錯性(能不能分區，只有一部份是好的) 有P就是兩個case -總是拿到*資料，但是可能是舊的: AP 可能拿不到資料，但是一定是新的: CP 最終一致性 算需要多少資源 Daily Active User \u0026 QPS \u0026 storage \u0026 幾台機器 creation QPS reading QPS storage for a day \u0026 many years(10years) 需求+spec不能超過物理限制 spec ram ssd/hdd network(RTT) cores 需求 throughput(qps) input latency 常見物理限制的平均值 ram 250us ssd 1000us compress 3us network same data center 500us CA\u003c-\u003eNetherlands 150000us 1us = 10^-6secs 1ns = 10^-9secs 1ms = 10^-3secs 畫架構(API -\u003e prog) \u003c-\u003e 加強 (loop) CDN, DNS message queue concurreny/parallel design Load Balancer 分配方式: random, 最少負載 layer 4 or layer 7 cache write around write through write back multi-server 多master or master-slave 容錯轉移(failover) or 複寫(Replication) auto scale container orchestration platform 讀寫分離 total = R+W，分配R與W的數量 DB schema 反正規化 design one to one one to many many to many multi-server 依功能分成多DB (federative database) 把資料分散到多DB (sharding) SQL/noSQL SQL: 強一致性, transaction, 複雜結構(join,index) SQL: 最終一致性, 高throughput, 巨量資料 需要多少機器 要想辦法讓需求在物理限制之中\n用這裡的快取做例子，來算一下\n這裡是設計快取，所以記憶體的速度是物理限制\n之後，需求給qps與input總量，求大概幾台幾core多少ram的機器\n# 從會算的開始，要幾台 host = total_input/ram # 每個core每秒要處理多少req req_per_core_per_sec = qps/(host*core) # 頻率就是時間的倒數 latency = 1/req_per_core_per_sec = (host*core)/qps # 展開host latency = (total_input*core)/(ram*qps) # 把給定的數字分出來 latency = (total_input/qps) * (core/ram) # 因為是物理限制，所以求出來的數字，不能超過latency latency \u003c= (total_input/qps) * (core/ram) # 因此，要不是core變多，就是ram變小 # 台數可以透過 host = total_input/ram 算 上面推導完來帶數字\nqps: 10m total_input: 30tb 這裡有個小訣竅，在算時把單位換成統一的比較好用，看要消的單位來看要換成或不會換 像，與大小有關都是gb，時間都是sec\n查表會發現，從mem讀1MB要250us(10^-6 secs)\n先換算，250*10^-6\n250*10^-6 \u003c= (30*1000)/10*10^6 * (core/ram) # 化簡 1 \u003c= 12 * (core/ram) # 4cores ram \u003c= 12*core = 48 所以4cores，一台最多只能48gb 8cores，一台最多只能96gb\n照原本這裡第一次給的spec，4cores與72gb會爆，但是4cores與32gb不會爆\n那總共要幾台，以4cores與32gb來看，要30*1000gb/32gb=940台\n要在設計之前要知道 Daily Active User read的頻率 =\u003e read的total_input write的頻率 =\u003e write的total_input user產生的資料大小 (post, short url) 有可能是根據自己設計的去算(short url) latency for read \u0026 write Consistency or Availability read-heavy or write-heavy or half-half 之後要求出，下面的東西才能繼續做設計\nread QPS write QPS storage comsumption 如果需要求需要多少台機器 latency \u003c= (total_input/qps) * (core/ram) 配合 host = total_input/ram\n例子 這裡 這裡2\n一些技巧\nAPI設計 放api_dev_key 做bandwidth controll Implement online / offline online: 一來算一筆 offline: 預先生成資料 (short url的碼) Sharding 的 hash key foreign key primary key+timestamp(create time) primary key+counter (zookeeper) 要多長 (short url) 要放多久*每天產生多少 \u003c= (possible chars)^長度 有長度就可以算storage interviewBit Sharding a Database Can we have a fixed number of shards? map to shard function: H % S number of shards is S a numeric hash H When adding a new machine, need to relocate each and every key extremely expensive and highly undesirable Consistent Hashing 把shard列序 將data或user map 到 其中一個shard 如果出事或是加新機器 把資料往下一台移(因為已經有順序了) Highly Available Database Master Slave Multi Master peer to peer Consistent Hashing Read and Write consistency 設有P份copy 要讀或寫，就對所有shard發req，拿到一定數量的ack才成功 R是回傳read成功的次數，W是回傳write成功的次數 要維持C(總是拿到最新的write) W + R \u003e P W = P: 強C(每台都要回) R = 1: for fast read W \u003c P: 最終一致 W = 1: for fast write 要處理data conflict 先寫先贏 留標記 Highly Consistent Database 為了C與處理單點錯誤 資料要write到多台DB 如果每一台都write很費時，只要寫到一定數量就好 需要master追蹤寫到哪些機器 master只有一台? 單點錯誤 多一台做standby ","wordCount":"455","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-07-04T02:45:06Z","dateModified":"2021-07-04T02:45:06Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/07/system-design%E7%9A%84faq/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">system-design的faq</h1><div class=post-meta><span title='2021-07-04 02:45:06 +0000 UTC'>July 4, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e9%81%8e%e7%a8%8b aria-label=過程>過程</a></li><li><a href=#%e9%9c%80%e8%a6%81%e5%a4%9a%e5%b0%91%e6%a9%9f%e5%99%a8 aria-label=需要多少機器>需要多少機器</a></li><li><a href=#%e8%a6%81%e5%9c%a8%e8%a8%ad%e8%a8%88%e4%b9%8b%e5%89%8d%e8%a6%81%e7%9f%a5%e9%81%93 aria-label=要在設計之前要知道>要在設計之前要知道</a></li><li><a href=#%e4%be%8b%e5%ad%90 aria-label=例子>例子</a></li><li><a href=#interviewbit aria-label=interviewBit>interviewBit</a><ul><li><a href=#sharding-a-databasehttpswwwinterviewbitcomproblemssharding-a-database aria-label="Sharding a Database">Sharding a Database</a></li><li><a href=#highly-available-databasehttpswwwinterviewbitcomproblemshighly-available-database aria-label="Highly Available Database">Highly Available Database</a></li><li><a href=#highly-consistent-databasehttpswwwinterviewbitcomproblemshighly-consistent-database aria-label="Highly Consistent Database">Highly Consistent Database</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>之前面試莫名其妙被system design電到翻過去，
之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。</p><p>目前發現<a href=https://www.jyt0532.com/2017/03/27/system-design/>這個</a>，看完發現，原來我之前只有準備一半啊</p><p>system design的面試其實有一定的程序要走，不是單純的QA
這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的</p><p>所以這篇，是要補完這點。</p><h2 id=過程>過程<a hidden class=anchor aria-hidden=true href=#過程>#</a></h2><ol><li>需求</li></ol><ul><li>功能</li><li>output<ul><li>格式</li></ul></li><li>Input的量<ul><li>每秒多少資料</li><li>每秒多少request</li></ul></li><li>throughput<ul><li>Queries Per Second, QPS</li><li>預期希望處理多少資料</li></ul></li><li>latency</li></ul><ol start=2><li>限制</li></ol><ul><li>有什麼機器，spec<ul><li>core</li><li>RAM</li></ul></li><li>CAP<ul><li>CA<ul><li>一致性(總是能拿到最新的) + 可用性(拿得到資料)</li><li>單一DB</li></ul></li><li>AP & CP<ul><li>分區容錯性(能不能分區，只有一部份是好的)</li><li>有P就是兩個case<ul><li>-總是拿到*資料，但是可能是舊的: AP</li><li>可能拿不到資料，但是<em>一定是新的</em>: CP</li></ul></li></ul></li><li>最終一致性</li></ul></li></ul><ol start=3><li>算需要多少資源</li></ol><ul><li>Daily Active User & QPS & storage & 幾台機器<ul><li>creation QPS</li><li>reading QPS</li><li>storage for a day & many years(10years)</li></ul></li><li>需求+spec不能超過物理限制<ul><li>spec<ul><li>ram</li><li>ssd/hdd</li><li>network(RTT)</li><li>cores</li></ul></li><li>需求<ul><li>throughput(qps)</li><li>input</li><li>latency</li></ul></li></ul></li><li>常見物理限制的平均值<ul><li>ram<ul><li>250us</li></ul></li><li>ssd<ul><li>1000us</li></ul></li><li>compress<ul><li>3us</li></ul></li><li>network<ul><li>same data center<ul><li>500us</li></ul></li><li>CA&lt;->Netherlands<ul><li>150000us</li></ul></li></ul></li><li>1us = 10^-6secs</li><li>1ns = 10^-9secs</li><li>1ms = 10^-3secs</li></ul></li></ul><ol start=4><li>畫架構(API -> prog) &lt;-> 加強 (loop)</li></ol><ul><li>CDN, DNS</li><li>message queue</li><li>concurreny/parallel design</li><li>Load Balancer<ul><li>分配方式: random, 最少負載</li><li>layer 4 or layer 7</li></ul></li><li>cache<ul><li>write around</li><li>write through</li><li>write back</li></ul></li><li>multi-server<ul><li>多master or master-slave<ul><li>容錯轉移(failover) or 複寫(Replication)</li></ul></li><li>auto scale<ul><li>container orchestration platform</li></ul></li><li>讀寫分離<ul><li>total = R+W，分配R與W的數量</li></ul></li></ul></li><li>DB<ul><li>schema<ul><li>反正規化</li><li>design<ul><li>one to one</li><li>one to many</li><li>many to many</li></ul></li></ul></li><li>multi-server<ul><li>依功能分成多DB (federative database)</li><li>把資料分散到多DB (sharding)</li></ul></li><li>SQL/noSQL<ul><li>SQL: 強一致性, transaction, 複雜結構(join,index)</li><li>SQL: 最終一致性, 高throughput, 巨量資料</li></ul></li></ul></li></ul><h2 id=需要多少機器>需要多少機器<a hidden class=anchor aria-hidden=true href=#需要多少機器>#</a></h2><p>要想辦法讓需求在物理限制之中</p><p>用<a href=https://www.jyt0532.com/2017/03/27/system-design/>這裡</a>的快取做例子，來算一下</p><p>這裡是設計快取，所以記憶體的速度是物理限制</p><p>之後，需求給qps與input總量，求大概幾台幾core多少ram的機器</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 從會算的開始，要幾台</span>
</span></span><span class=line><span class=cl><span class=n>host</span> <span class=o>=</span> <span class=n>total_input</span><span class=o>/</span><span class=n>ram</span>
</span></span><span class=line><span class=cl><span class=c1># 每個core每秒要處理多少req</span>
</span></span><span class=line><span class=cl><span class=n>req_per_core_per_sec</span> <span class=o>=</span> <span class=n>qps</span><span class=o>/</span><span class=p>(</span><span class=n>host</span><span class=o>*</span><span class=n>core</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 頻率就是時間的倒數</span>
</span></span><span class=line><span class=cl><span class=n>latency</span> <span class=o>=</span> <span class=mi>1</span><span class=o>/</span><span class=n>req_per_core_per_sec</span> <span class=o>=</span> <span class=p>(</span><span class=n>host</span><span class=o>*</span><span class=n>core</span><span class=p>)</span><span class=o>/</span><span class=n>qps</span>
</span></span><span class=line><span class=cl><span class=c1># 展開host</span>
</span></span><span class=line><span class=cl><span class=n>latency</span> <span class=o>=</span> <span class=p>(</span><span class=n>total_input</span><span class=o>*</span><span class=n>core</span><span class=p>)</span><span class=o>/</span><span class=p>(</span><span class=n>ram</span><span class=o>*</span><span class=n>qps</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 把給定的數字分出來</span>
</span></span><span class=line><span class=cl><span class=n>latency</span> <span class=o>=</span> <span class=p>(</span><span class=n>total_input</span><span class=o>/</span><span class=n>qps</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>core</span><span class=o>/</span><span class=n>ram</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 因為是物理限制，所以求出來的數字，不能超過latency</span>
</span></span><span class=line><span class=cl><span class=n>latency</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=n>total_input</span><span class=o>/</span><span class=n>qps</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>core</span><span class=o>/</span><span class=n>ram</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 因此，要不是core變多，就是ram變小</span>
</span></span><span class=line><span class=cl><span class=c1># 台數可以透過 host = total_input/ram 算</span>
</span></span></code></pre></div><p>上面推導完來帶數字</p><ul><li>qps: 10m</li><li>total_input: 30tb</li></ul><p>這裡有個小訣竅，在算時把單位換成統一的比較好用，看要消的單位來看要換成或不會換
像，與大小有關都是gb，時間都是sec</p><p>查<a href=https://gist.github.com/jboner/2841832>表</a>會發現，從mem讀1MB要250us(10^-6 secs)</p><p>先換算，<code>250*10^-6</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=mi>250</span><span class=o>*</span><span class=mi>10</span><span class=o>^-</span><span class=mi>6</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=mi>30</span><span class=o>*</span><span class=mi>1000</span><span class=p>)</span><span class=o>/</span><span class=mi>10</span><span class=o>*</span><span class=mi>10</span><span class=o>^</span><span class=mi>6</span> <span class=o>*</span> <span class=p>(</span><span class=n>core</span><span class=o>/</span><span class=n>ram</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 化簡</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=o>&lt;=</span> <span class=mi>12</span> <span class=o>*</span> <span class=p>(</span><span class=n>core</span><span class=o>/</span><span class=n>ram</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 4cores</span>
</span></span><span class=line><span class=cl><span class=n>ram</span> <span class=o>&lt;=</span> <span class=mi>12</span><span class=o>*</span><span class=n>core</span> <span class=o>=</span> <span class=mi>48</span>
</span></span></code></pre></div><p>所以4cores，一台最多只能48gb
8cores，一台最多只能96gb</p><p>照原本<a href=https://www.jyt0532.com/2017/03/27/system-design/>這裡</a>第一次給的spec，4cores與72gb會爆，但是4cores與32gb不會爆</p><p>那總共要幾台，以4cores與32gb來看，要<code>30*1000gb/32gb=940</code>台</p><h2 id=要在設計之前要知道>要在設計之前要知道<a hidden class=anchor aria-hidden=true href=#要在設計之前要知道>#</a></h2><ul><li>Daily Active User<ul><li>read的頻率 => read的total_input</li><li>write的頻率 => write的total_input</li></ul></li><li>user產生的資料大小 (post, short url)<ul><li>有可能是根據自己設計的去算(short url)</li></ul></li><li>latency for read & write</li><li>Consistency or Availability</li><li>read-heavy or write-heavy or half-half</li></ul><p>之後要求出，下面的東西才能繼續做設計</p><ul><li>read QPS</li><li>write QPS</li><li>storage comsumption</li></ul><p>如果需要求需要多少台機器
<code>latency &lt;= (total_input/qps) * (core/ram)</code>
配合
<code>host = total_input/ram</code></p><h2 id=例子>例子<a hidden class=anchor aria-hidden=true href=#例子>#</a></h2><p><a href=https://www.jyt0532.com/2019/12/05/design-tiny-url/>這裡</a>
<a href=https://www.jyt0532.com/2020/02/11/design-instagram/>這裡2</a></p><p>一些技巧</p><ul><li>API設計<ul><li>放api_dev_key<ul><li>做bandwidth controll</li></ul></li></ul></li><li>Implement<ul><li>online / offline<ul><li>online: 一來算一筆</li><li>offline: 預先生成資料 (short url的碼)</li></ul></li><li>Sharding 的 hash key<ul><li>foreign key</li><li>primary key+timestamp(create time)</li><li>primary key+counter (zookeeper)</li></ul></li><li>要多長 (short url)<ul><li>要放多久*每天產生多少 &lt;= (possible chars)^長度</li><li>有長度就可以算storage</li></ul></li></ul></li></ul><h2 id=interviewbit>interviewBit<a hidden class=anchor aria-hidden=true href=#interviewbit>#</a></h2><h3 id=sharding-a-databasehttpswwwinterviewbitcomproblemssharding-a-database><a href=https://www.interviewbit.com/problems/sharding-a-database/>Sharding a Database</a><a hidden class=anchor aria-hidden=true href=#sharding-a-databasehttpswwwinterviewbitcomproblemssharding-a-database>#</a></h3><ul><li>Can we have a fixed number of shards?</li><li>map to shard function: <code>H % S</code><ul><li>number of shards is S</li><li>a numeric hash H</li><li>When adding a new machine,<ul><li>need to relocate each and every key</li><li>extremely expensive and highly undesirable</li></ul></li></ul></li><li>Consistent Hashing<ul><li>把shard列序</li><li>將data或user map 到 其中一個shard</li><li>如果出事或是加新機器<ul><li>把資料往下一台移(因為已經有順序了)</li></ul></li></ul></li></ul><h3 id=highly-available-databasehttpswwwinterviewbitcomproblemshighly-available-database><a href=https://www.interviewbit.com/problems/highly-available-database/>Highly Available Database</a><a hidden class=anchor aria-hidden=true href=#highly-available-databasehttpswwwinterviewbitcomproblemshighly-available-database>#</a></h3><ul><li>Master Slave</li><li>Multi Master</li><li>peer to peer<ul><li>Consistent Hashing<ul><li>Read and Write consistency<ul><li>設有P份copy</li><li>要讀或寫，就對所有shard發req，拿到一定數量的ack才成功<ul><li>R是回傳read成功的次數，W是回傳write成功的次數</li></ul></li><li>要維持C(總是拿到最新的write)<ul><li><code>W + R > P</code><ul><li><code>W = P</code>: 強C(每台都要回)<ul><li><code>R = 1</code>: for fast read</li></ul></li><li><code>W &lt; P</code>: 最終一致<ul><li><code>W = 1</code>: for fast write</li><li>要處理data conflict<ul><li>先寫先贏</li><li>留標記</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id=highly-consistent-databasehttpswwwinterviewbitcomproblemshighly-consistent-database><a href=https://www.interviewbit.com/problems/highly-consistent-database/>Highly Consistent Database</a><a hidden class=anchor aria-hidden=true href=#highly-consistent-databasehttpswwwinterviewbitcomproblemshighly-consistent-database>#</a></h3><ul><li>為了C與處理單點錯誤<ul><li>資料要write到多台DB</li></ul></li><li>如果每一台都write很費時，只要寫到一定數量就好<ul><li>需要master追蹤寫到哪些機器</li></ul></li><li>master只有一台? 單點錯誤<ul><li>多一台做standby</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/system-design/>System Design</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/07/leetcode-concurrency/><span class=title>« Prev</span><br><span>leetcode-Concurrency</span>
</a><a class=next href=https://littlebees.github.io/2021/07/linking%E7%9A%84%E7%A8%AE%E9%A1%9E/><span class=title>Next »</span><br><span>linking的種類</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>