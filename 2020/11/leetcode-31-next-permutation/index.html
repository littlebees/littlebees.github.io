<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-31 - Next Permutation | 記事本</title>
<meta name=keywords content="Two Pointers,Array,60 questions to solve,Top 100 Liked Questions"><meta name=description content="動機
這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2020/11/leetcode-31-next-permutation/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2020/11/leetcode-31-next-permutation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-31 - Next Permutation"><meta property="og:description" content="動機
這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2020/11/leetcode-31-next-permutation/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-02T01:13:58+00:00"><meta property="article:modified_time" content="2020-11-02T01:13:58+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-31 - Next Permutation"><meta name=twitter:description content="動機
這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-31 - Next Permutation","item":"https://littlebees.github.io/2020/11/leetcode-31-next-permutation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-31 - Next Permutation","name":"leetcode-31 - Next Permutation","description":"動機 這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難\n","keywords":["Two Pointers","Array","60 questions to solve","Top 100 Liked Questions"],"articleBody":"動機 這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難\nProblem Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\nThe replacement must be in place and use only constant extra memory.\nExample 1:\nInput: nums = [1,2,3]Output: [1,3,2]Example 2:\nInput: nums = [3,2,1]Output: [1,2,3]Example 3:\nInput: nums = [1,1,5]Output: [1,5,1]Example 4:\nInput: nums = [1]Output: [1] Constraints:\n1 \u003c= nums.length \u003c= 1000 \u003c= nums[i] \u003c= 100 原理 1 2 3 最後要變成 3 2 1 觀察3 2 1的大小，都是 前一個大於等於下一個 (字典序最大)\n那麼如果再加一個數字像0 3 2 1就會破壞這個規則， 所以要重新往 前一個大於等於下一個 這個條件靠近。\n因為我們要的是下一個字典序的排列(與現在排列差異最小)， 所以下一個排列的第一個要從現有的部分挑一個最小的來換，讓第一位差異最小， 我們可以從中挑一個大於那個數字的最小數來交換\n延續上面例子會變成1 3 2 0\n接著是原本的範圍如何讓他的字典序最小? reverse!!\n所以下一個排序是1 0 2 3\ndef findStartOfRevOrder(arr): i = len(arr)-1 # start from the last index while i \u003e 0 and arr[i-1] \u003e= arr[i]: i -= 1 return i if i \u003e 0 else -1 def reverse_in_place(alist,left,right): #condition for termination while left\u003cright: #swapping temp = alist[left] alist[left] = alist[right] alist[right] = temp #updating pointers left += 1 right -= 1 class Solution: def nextPermutation(self, arr: List[int]) -\u003e None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" i = findStartOfRevOrder(arr)-1 j = len(arr)-1 if i \u003e= 0: while j \u003e= 0 and arr[i] \u003e= arr[j]: # keep the small ones in last j -= 1 if j \u003e= 0: # swap arr[i], arr[j] = [arr[j],arr[i]] #arr[i+1:] = arr[i+1:][::-1] # keep big digit as the last reverse_in_place(arr,i+1,len(arr)-1) else: reverse_in_place(arr,0,len(arr)-1) 556 把數字當成排列\ndef findStartOfRevOrder(arr): i = len(arr)-1 # start from the last index while i \u003e 0 and arr[i-1] \u003e= arr[i]: i -= 1 return i if i \u003e 0 else -1 def f(arr): i = findStartOfRevOrder(arr)-1 if i \u003e= 0: j = len(arr)-1 while j \u003e= 0 and arr[i] \u003e= arr[j]: # keep the small ones in last j -= 1 if j \u003e= 0: # swap arr[i], arr[j] = [arr[j],arr[i]] arr[i+1:] = arr[i+1:][::-1] # keep big digit as the last i = findStartOfRevOrder(arr)-1 return arr else: return False class Solution: def nextGreaterElement(self, n: int) -\u003e int: arr = [int(c) for c in str(n)] ret = f(arr) if ret: ret = [str(n) for n in ret] ret = int(''.join(ret)) if ret \u003e= 2147483647: ret = -1 else: ret = -1 return ret ","wordCount":"375","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2020-11-02T01:13:58Z","dateModified":"2020-11-02T01:13:58Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2020/11/leetcode-31-next-permutation/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-31 - Next Permutation</h1><div class=post-meta><span title='2020-11-02 01:13:58 +0000 UTC'>November 2, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a></li><li><a href=#556 aria-label=556>556</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).</p><p>The replacement must be <strong><a href=http://en.wikipedia.org/wiki/In-place_algorithm target=_blank>in place</a></strong> and use only constant extra memory.</p><p> </p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> nums = [1,2,3]<strong>Output:</strong> [1,3,2]</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> nums = [3,2,1]<strong>Output:</strong> [1,2,3]</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> nums = [1,1,5]<strong>Output:</strong> [1,5,1]</pre><p><strong>Example 4:</strong></p><pre><strong>Input:</strong> nums = [1]<strong>Output:</strong> [1]</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= nums.length <= 100</code></li><li><code>0 <= nums[i] <= 100</code></li></ul><h2 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h2><p><code>1 2 3</code> 最後要變成 <code>3 2 1</code>
觀察<code>3 2 1</code>的大小，都是 <strong>前一個大於等於下一個</strong> (字典序最大)</p><p>那麼如果再加一個數字像<code>0 3 2 1</code>就會破壞這個規則，
所以要重新往 <strong>前一個大於等於下一個</strong> 這個條件靠近。</p><p>因為我們要的是下一個字典序的排列(與現在排列差異最小)，
所以下一個排列的第一個要從現有的部分挑一個最小的來換，讓第一位差異最小，
我們可以從中挑一個<strong>大於那個數字的最小數</strong>來交換</p><p>延續上面例子會變成<code>1 3 2 0</code></p><p>接著是原本的範圍如何讓他的字典序最小?
reverse!!</p><p>所以下一個排序是<code>1 0 2 3</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>findStartOfRevOrder</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span> <span class=c1># start from the last index</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span> <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>reverse_in_place</span><span class=p>(</span><span class=n>alist</span><span class=p>,</span><span class=n>left</span><span class=p>,</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#condition for termination</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span><span class=o>&lt;</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       <span class=c1>#swapping</span>
</span></span><span class=line><span class=cl>       <span class=n>temp</span> <span class=o>=</span> <span class=n>alist</span><span class=p>[</span><span class=n>left</span><span class=p>]</span>
</span></span><span class=line><span class=cl>       <span class=n>alist</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>=</span> <span class=n>alist</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>       <span class=n>alist</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       <span class=c1>#updating pointers</span>
</span></span><span class=line><span class=cl>       <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>       <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>nextPermutation</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>arr</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Do not return anything, modify nums in-place instead.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>findStartOfRevOrder</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span> <span class=c1># keep the small ones in last</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># swap</span>
</span></span><span class=line><span class=cl>                <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>],</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>                <span class=c1>#arr[i+1:] = arr[i+1:][::-1] # keep big digit as the last</span>
</span></span><span class=line><span class=cl>                <span class=n>reverse_in_place</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>reverse_in_place</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=556>556<a hidden class=anchor aria-hidden=true href=#556>#</a></h2><p>把數字當成排列</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>findStartOfRevOrder</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span> <span class=c1># start from the last index</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span> <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>findStartOfRevOrder</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span> <span class=c1># keep the small ones in last</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># swap</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>],</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:][::</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=c1># keep big digit as the last</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>=</span> <span class=n>findStartOfRevOrder</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>nextGreaterElement</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=nb>str</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>ret</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=p>[</span><span class=nb>str</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>ret</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>ret</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>ret</span> <span class=o>&gt;=</span> <span class=mi>2147483647</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/two-pointers/>Two Pointers</a></li><li><a href=https://littlebees.github.io/tags/array/>Array</a></li><li><a href=https://littlebees.github.io/tags/60-questions-to-solve/>60 Questions to Solve</a></li><li><a href=https://littlebees.github.io/tags/top-100-liked-questions/>Top 100 Liked Questions</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2020/11/leetcode-43-multiply-strings/><span class=title>« Prev</span><br><span>leetcode-43 - Multiply Strings</span>
</a><a class=next href=https://littlebees.github.io/2020/10/%E5%90%84%E7%A8%AEmake/><span class=title>Next »</span><br><span>各種make</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>