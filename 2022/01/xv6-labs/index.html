<!DOCTYPE html>
<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="AEpTGuQAkxnTOlmfF4INDna3S660LxrkyZ4BQzVbRSw">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"littlebees.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="動機  What I can not create I do not understand.  6.s081是個了解unix與c語言的超讚課程 有許多符合自修性質  有實作 有test 有解答可以參考  這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記 lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6 labs">
<meta property="og:url" content="https://littlebees.github.io/2022/01/xv6-labs/index.html">
<meta property="og:site_name" content="記事本">
<meta property="og:description" content="動機  What I can not create I do not understand.  6.s081是個了解unix與c語言的超讚課程 有許多符合自修性質  有實作 有test 有解答可以參考  這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記 lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://i.imgur.com/dKztkKG.png">
<meta property="og:image" content="https://www.researchgate.net/publication/320174686/figure/download/fig5/AS:613873052815377@1523370149442/Netfilter-hooks-and-packet-flow-https-doiorg-101371-journalpone0182375g005.png">
<meta property="og:image" content="https://i.imgur.com/uF59eie.png">
<meta property="og:image" content="https://i.imgur.com/sZBLA3r.png">
<meta property="og:image" content="https://i.imgur.com/wtcbDS1.png">
<meta property="og:image" content="https://i.imgur.com/tbYvEDJ.png">
<meta property="og:image" content="https://i.imgur.com/wtcbDS1.png">
<meta property="og:image" content="https://i.imgur.com/yBoV986.png">
<meta property="og:image" content="https://i.imgur.com/RcwxOmm.png">
<meta property="og:image" content="https://i.imgur.com/pczpVz4.png">
<meta property="og:image" content="https://i.imgur.com/RcwxOmm.png">
<meta property="og:image" content="https://i.imgur.com/clKOaC4.png">
<meta property="og:image" content="https://i.imgur.com/sAWGPwO.png">
<meta property="og:image" content="https://i.imgur.com/nok1IuY.png">
<meta property="article:published_time" content="2022-01-21T03:27:50.000Z">
<meta property="article:modified_time" content="2022-03-17T03:03:01.285Z">
<meta property="article:author" content="zhengcf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.imgur.com/dKztkKG.png">

<link rel="canonical" href="https://littlebees.github.io/2022/01/xv6-labs/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-tw'
  };
</script>

  <title>xv6 labs | 記事本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">記事本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">寫下來，不然會忘</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="https://littlebees.github.io/2022/01/xv6-labs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhengcf">
      <meta itemprop="description" content="想到什麼就寫什麼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="記事本">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          xv6 labs
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 11:27:50" itemprop="dateCreated datePublished" datetime="2022-01-21T11:27:50+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-17 11:03:01" itemprop="dateModified" datetime="2022-03-17T11:03:01+08:00">2022-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/System/" itemprop="url" rel="index"><span itemprop="name">System</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Small-project/" itemprop="url" rel="index"><span itemprop="name">Small project</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/System/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="動機-667">動機</h2>
<blockquote>
<p>What I can not create I do not understand.</p>
</blockquote>
<p>6.s081是個了解unix與c語言的超讚課程</p>
<p>有許多符合自修性質</p>
<ul>
<li>有實作</li>
<li>有test</li>
<li>有解答可以參考</li>
</ul>
<p>這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記<br>
lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多</p>
<span id="more"></span>
<h2 id="裝環境">裝環境</h2>
<p>我是在win11 WSL2的ubuntu 20.04跑</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu gcc-riscv64-unknown-elf</span><br></pre></td></tr></table></figure>
<p>需要參考的話，我的lab code在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdHRsZWJlZXMveHY2LWxhYnM=">這<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="怎麼在lab使用gdb">怎麼在lab使用gdb</h2>
<ol>
<li>在<code>~/.gdbinit</code>加<code>add-auto-load-safe-path ~/xv6-labs/.gdbinit</code></li>
<li>跑<code>make qemu-gdb</code></li>
<li>在另一個視窗跑<code>gdb-multiarch</code></li>
</ol>
<h2 id="如何debug">如何debug</h2>
<ol>
<li>在panic打上breakpoint</li>
<li>利用make產生的xxx.asm，可以用addr去對，找到哪一行出事了(<code>addr2line -e kernel/kernel pc-value</code>)</li>
<li>qemu的Ctrl-a x是關閉，Ctrl-a c是類似gdb可以info mem看pagetable</li>
<li>一點一點的寫，可以用panic去停下cpu看狀態對不對</li>
<li>在沒有動過的地方掛了、一開始就動不了
<ul>
<li>可能理由
<ul>
<li>mem不知道寫到哪了
<ul>
<li>腦袋要清楚mem到底要怎麼寫
<ul>
<li>這個是va, pa, pte?</li>
<li>這裡是page, stack的終點還是起點?</li>
<li>資料往哪邊長?
<ul>
<li>stack是高往低</li>
<li>一般資料是低往高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>concurrent沒處理好
<ul>
<li>deadlock
<ul>
<li>這個去trace中間用到的function應該可以看到一些東西
<ul>
<li>有人跟你用一樣的lock</li>
</ul>
</li>
<li>拿lock的順序對嗎</li>
</ul>
</li>
<li>沒有用lock包好
<ul>
<li>思考有哪些資料是要一起動的，思考在lock結束後有什麼性質要有
<ul>
<li>reference counter</li>
<li>freelist</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="ch1-3">ch1</h2>
<p>在riscv中，CPU == hart</p>
<h3 id="fd">fd</h3>
<p>因為綁定0,1成stdin, stdout<br>
所以會需要close，之後再開新的file完成redirect<br>
因為fd是從小的開始分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dup做soft copy，所以下面的file會是hello world</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>這裡想完成的事就是dynamic scope或是<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3JlZ2hlbmRlcnNob3R0LmNvbS8yMDEzLzA0L3BhcmFtZXRlcnMtaW4tcmFja2V0Lmh0bWwjOn46dGV4dD1SYWNrZXQlMjBwYXJhbWV0ZXJzJTIwbGV0JTIweW91JTIwbWFuYWdlJTIwc3RhdGVmdWwlMjBnbG9iYWwlMjB2YXJpYWJsZXMsaG93JTIwSSUyMG1hcCUyMHBhcmFtZXRlcnMlMjB0byUyMGElMjBjb25maWd1cmF0aW9uJTIwZmlsZS4=">Parameterize<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="pipe-2">pipe</h3>
<p>pipe會產生一個file(in mem)，之後開2個fd，下面是redirect stdin到pipe</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這等於就是把ref裡面的東西暴露給user阿<br>
(因為綁定0,1成stdin, stdout)</p>
<h4 id="trace-pipe">trace: pipe</h4>
<ul>
<li>pipe是由兩個file控制的ring buffer</li>
<li>由寫到哪(nwrite)與讀到哪(nread)控制sleep與wakeup</li>
</ul>
<p>alloc pipe</p>
<ul>
<li>sys_pipe
<ul>
<li>alloc 兩個struct file</li>
<li>pipealloc設定兩個file
<ul>
<li>kalloc一塊page，作為struct pipe</li>
<li>讓file能指到struct pipe</li>
</ul>
</li>
<li>把fd寫回去
<ul>
<li>copyout留到pagetable那章談</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>write/read syscall</p>
<ul>
<li>sys_write/sys_write
<ul>
<li>filewrite/fileread根據struct file的type跑到pipe去
<ul>
<li>piperead
<ul>
<li>空了 AND 對面還想要寫
<ul>
<li><code>pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen</code></li>
<li>先去睡覺</li>
</ul>
</li>
<li>開始寫到addr (increase nread)
<ul>
<li>注意到這是個ring buffer!!</li>
</ul>
</li>
<li>都好了就wakeup對面 (用nwrite去認)
<ul>
<li>sleeplock留到lock那章談</li>
</ul>
</li>
</ul>
</li>
<li>pipewrite
<ul>
<li>對面不想要讀
<ul>
<li>return</li>
</ul>
</li>
<li>如果
<ul>
<li>滿了
<ul>
<li><code>pi-&gt;nwrite == pi-&gt;nread + PIPESIZE</code></li>
<li>wakeup對面 (用nread去認)</li>
<li>先去睡覺</li>
</ul>
</li>
<li>沒滿
<ul>
<li>從addr讀到struct pipe中 (increase nwrite)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>close syscall</p>
<ul>
<li>sys_close
<ul>
<li>pipeclose
<ul>
<li>根據fd來看是不是用來寫的</li>
<li>之後關對應的狀態</li>
<li>wakeup另外一邊</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Lab-Utilities">Lab Utilities</h3>
<h4 id="sleep">sleep</h4>
<p>練手用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;sleep: 2 args\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pingpong">pingpong</h4>
<p>這裡開始寫簡單的pipe</p>
<p>從前面的trace可以看出，pipe只有三個狀態下會換手</p>
<ol>
<li>read/write完成</li>
<li>空了/滿了</li>
<li>close</li>
</ol>
<p>所以寫pipe時要記得把所有read/write該關的都關一關</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeR</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123; close(p[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeW</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123; close(p[<span class="number">1</span>]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p2c[<span class="number">2</span>], c2p[<span class="number">2</span>];</span><br><span class="line">  pipe(p2c), pipe(c2p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork()) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    closeR(p2c);</span><br><span class="line">    closeW(c2p);</span><br><span class="line">    write(p2c[<span class="number">1</span>], &amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    read(c2p[<span class="number">0</span>], &amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">    closeW(p2c);</span><br><span class="line">    closeR(c2p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    closeW(p2c);</span><br><span class="line">    closeR(c2p);</span><br><span class="line">    read(p2c[<span class="number">0</span>], &amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">    write(c2p[<span class="number">1</span>], &amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    closeR(p2c);</span><br><span class="line">    closeW(c2p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="find">find</h4>
<p>主要是練怎麼用file stat，以及認識到c處理string是多麼麻煩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getFilename</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *start = path;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">  path += len;</span><br><span class="line">  <span class="keyword">for</span>(;path != start &amp;&amp; *path != <span class="string">&#x27;/&#x27;</span>;path--) ;</span><br><span class="line">  <span class="keyword">if</span> (*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSubstring</span><span class="params">(<span class="keyword">char</span>* s1, <span class="keyword">char</span>* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">strlen</span>(s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A loop to slide pat[] one by one */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - M; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">            <span class="keyword">if</span> (s2[i + j] != s1[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == M)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isNotDots</span><span class="params">(<span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line">  <span class="keyword">return</span> len &gt;= <span class="number">3</span> || (len == <span class="number">2</span> &amp;&amp; name[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; name[<span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span>) || (len == <span class="number">1</span> &amp;&amp; name[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> *pat, <span class="keyword">int</span> has)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_FILE:</span><br><span class="line">    <span class="keyword">if</span> (has)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">char</span>* filename = getFilename(buf);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isNotDots(filename)) &#123;</span><br><span class="line">        find(buf, pat, has || isSubstring(pat, filename));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  find(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xargs">xargs</h4>
<p>因為我從沒用過xargs所以一開始寫根本不知道這要幹嘛</p>
<p>xargs就是讀stdout，用空格或斷行當成分隔，去invoke指令</p>
<p>不過這裡在讀的時候要一直loop，就算你知道test data基本上一次就讀的完</p>
<p>可以順便說說虛假喚醒的原因</p>
<ul>
<li>喚醒會把所有proc設定成可以跑(runnable)</li>
<li><em>scheduler</em>只會挑出一個proc跑</li>
<li>如果這個proc做一下改變，就直接被切走…
<ul>
<li>但其他proc還是runnable!!</li>
<li>這樣其他proc還是被wakeup的!!</li>
</ul>
</li>
</ul>
<p>虛假喚醒是來自preemptive schedule，所以只能在每次wakeup時確認需要的前提有沒有對，才繼續跑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>*</span></span><br><span class="line"><span class="function"><span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *os;</span><br><span class="line"></span><br><span class="line">  os = s;</span><br><span class="line">  <span class="keyword">while</span>(n-- &gt; <span class="number">0</span> &amp;&amp; (*s++ = *t++) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)</span><br><span class="line">    *s++ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10</span>][<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">char</span> *cmd[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;argc;i++)</span><br><span class="line">     <span class="built_in">strncpy</span>(buf[i<span class="number">-1</span>], argv[i], <span class="built_in">strlen</span>(argv[i]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (read(<span class="number">0</span>, tmp, <span class="number">32</span>) &gt; <span class="number">0</span>) &#123; <span class="comment">// 虛假喚醒!!</span></span><br><span class="line">    <span class="keyword">char</span> *start = tmp;</span><br><span class="line">    <span class="keyword">int</span> end = argc<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="built_in">strlen</span>(tmp),i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">      <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27; &#x27;</span> || tmp[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf[end++], start);</span><br><span class="line">        start = tmp+i+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;end;i++)</span><br><span class="line">      cmd[i] = (<span class="keyword">char</span>*)&amp;(buf[i]);</span><br><span class="line">    <span class="keyword">if</span> (fork())</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      exec(buf[<span class="number">0</span>], cmd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="primes">primes</h4>
<p>全部裡面最有趣的，也是考驗會不會用pipe</p>
<p>這裡的做法是，每個stage(go)</p>
<ul>
<li>取第一個數字作為這邊的質數</li>
<li>剩下塞到新的pipe，產生下一個stage</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	write(p[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">int</span> state = read(p[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (state &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endWrite</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">	close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endRead</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">	close(p[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// WARN: get a item one time!!</span></span><br><span class="line">	<span class="keyword">int</span> b = get(p);</span><br><span class="line">	<span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, b);</span><br><span class="line">		<span class="keyword">int</span> n = get(p);</span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> pp[<span class="number">2</span>];</span><br><span class="line">			pipe(pp);</span><br><span class="line">			<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">				endWrite(pp);</span><br><span class="line">				go(pp);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				endRead(pp);</span><br><span class="line">				<span class="keyword">for</span>(;n &gt; <span class="number">0</span>;n=get(p))</span><br><span class="line">					<span class="keyword">if</span> (n % b != <span class="number">0</span>)</span><br><span class="line">						put(pp,n);</span><br><span class="line">				endWrite(pp);</span><br><span class="line">				wait(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	endRead(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">	pipe(p);</span><br><span class="line">	<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">		endWrite(p);</span><br><span class="line">		go(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		endRead(p);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">2</span>;n&lt;<span class="number">36</span>;n++)</span><br><span class="line">			put(p,n);</span><br><span class="line">		endWrite(p);</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ch2-3">ch2</h2>
<h3 id="Isolation-2">Isolation</h3>
<p>隔離是由下面兩個東西提供保證的</p>
<ul>
<li>硬體
<ul>
<li>執行模式</li>
</ul>
</li>
<li>OS
<ul>
<li>process (使用不同的stack)</li>
<li>其他 (cgroup, 權限管理…)</li>
</ul>
</li>
</ul>
<p>先看執行模式</p>
<h4 id="執行模式">執行模式</h4>
<p>RISC-V 有三種模式，CPU 可以執行指令：</p>
<ul>
<li>機器模式</li>
<li>監督者（supervisor）模式
<ul>
<li>CPU 被允許執行特權指令：例如，啟用和禁用中斷，讀寫保存頁表地址的寄存器等</li>
</ul>
</li>
<li>用戶模式</li>
</ul>
<p>CPU提供了一個特殊的指令(ecall)，可以將 CPU 從用戶模式切換到監督模式，並在內核指定的入口處進入內核。</p>
<p>一個關鍵的設計問題是操作系統的哪一部分應該在監督者模式下運行。</p>
<ul>
<li>宏內核
<ul>
<li>整個操作系統駐留在內核中，這樣所有系統調用的實現都在監督者模式下運行</li>
</ul>
</li>
<li>微內核
<ul>
<li>減少在監督者模式下運行的操作系統代碼量，而在用戶模式下執行操作系統的大部分代碼</li>
</ul>
</li>
</ul>
<h4 id="process">process</h4>
<p>process 就是 一台電腦</p>
<ul>
<li>硬體
<ul>
<li>kernel syscall</li>
</ul>
</li>
<li>CPU
<ul>
<li>concurrent mechnism
<ul>
<li>process state</li>
</ul>
</li>
</ul>
</li>
<li>mem
<ul>
<li>page table
<ul>
<li>stack
<ul>
<li>kernel stack (kstack)</li>
<li>user stack</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>透過assign不同的pagetable讓process只能看到與使用一部份的mem，這樣就算把自己的搞壞也沒關係</p>
<h5 id="process的mem-layout">process的mem layout</h5>
<p><img src="https://i.imgur.com/dKztkKG.png" alt=""></p>
<p>xv6 只使用 39 位中的 38 位。因此，最大地址是 2^38-1 = 0x3fffffffff，也就是 MAXVA</p>
<p>在地址空間的頂端，xv6 保留了一頁，用於 trampoline 和映射進程trapframe 的頁，以便切換到內核</p>
<h3 id="trace-init">trace: init</h3>
<p>在kernel load完後會call init去setup shell<br>
這裡主要是看怎麼從kernel mode變成user mode</p>
<ol>
<li>loader 将 xv6 内核加载到物理地址 0x80000000 的内存中
<ul>
<li>0x80000000 而不是 0x0，是因为地址范围 0x0-0x80000000 包含 I/O 设备。</li>
</ul>
</li>
<li>_entry处的指令设置了一个栈(stack0)，这样xv6就可以运行C代码
<ul>
<li>注意
<ul>
<li>stack0被宣告在start.c</li>
<li>riscv的stack是往下長的!!
<ul>
<li>所以，entry.S做的事用一句話來說
<ul>
<li><code>sp = stack0+PGSIZE</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>跑到start
<ul>
<li>這裡是machine mode
<ul>
<li>設定切hyperviser mode</li>
<li>關中斷</li>
<li>關paging</li>
<li>設定pc成main</li>
<li>設定timer的東西 (timerinit)</li>
<li>用mret跳去main，同時切成hyperviser mode</li>
</ul>
</li>
</ul>
</li>
<li>跑main
<ul>
<li>設定各種設定</li>
<li>最後跑userinit，跑kernel的第一個程式</li>
</ul>
</li>
<li>在main跑userinit，就會去帶init
<ul>
<li>alloc proc之後設定一些基本訊息</li>
<li>把跑init的binary (<code>exec(&quot;/init&quot;)</code>)，copy到proc的記憶體中
<ul>
<li>binary的asm在user的initcode.S
<ul>
<li>就是透過a7去打exec</li>
<li>exec會把記憶體換掉，所以變成init
<ul>
<li>init(init.c)做兩件事
<ul>
<li>fork: 開sh</li>
<li>main: 一直wait，zombie或是shell之類的proc</li>
</ul>
</li>
</ul>
</li>
<li>同時之後init跑完就會變成user mode
<ul>
<li>為什麼會變成user mode??
<ul>
<li>看到exec
<ul>
<li>先讀elf</li>
<li><em>用uvmalloc設定pagetable</em>
<ul>
<li>uvmalloc設定PTE時會代PTE_U (usermode記憶體)</li>
</ul>
</li>
</ul>
</li>
<li>之後到syscall的流程 (usertrapret)
<ul>
<li>設定user mode</li>
<li>設定user pagetable</li>
<li>userret做ctx switch+trap的switch</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="trace-syscall">trace: syscall</h3>
<h4 id="user-mode的syscall">user mode的syscall</h4>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3VzeXMucGw=">usys.pl<i class="fa fa-external-link-alt"></i></span>
<ul>
<li>include syscall.h拿syscall編號</li>
<li>會產生一段設定a7的asm</li>
<li>這就是syscall</li>
</ul>
</li>
</ul>
<h4 id="kernel-mode的syscall">kernel mode的syscall</h4>
<ul>
<li>syscall.h
<ul>
<li>這裡有所有syscall的編號</li>
</ul>
</li>
<li>usys.pl的ecall觸發trap，切到kernel mode
<ul>
<li>trap之後會提，反正會到usertrap</li>
<li>看mstatus，之後跑syscall</li>
<li>根據num，跑對應的syscal</li>
<li>return code寫到a0，之後透過剩下的trap流程
<ul>
<li>回到usertrap</li>
<li>跑usertrapret(切pagetable與user mode)，userret</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="user的參數怎麼pass到syscall的">user的參數怎麼pass到syscall的?</h4>
<p>以argint為例</p>
<ul>
<li>call argraw
<ul>
<li>argraw直接拿trapframe的value</li>
<li>在此如果是addr也是這樣拿到addr
<ul>
<li>但是之後要處理pagetable的copyin, copyout接手去複製資料</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Lab-System-calls">Lab System calls</h3>
<h4 id="trace">trace</h4>
<p>就是在proc上設定mask，之後只要syscall時就看mask決定要不要print</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_trace</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_trace]   sys_trace,</span><br><span class="line">    [SYS_sysinfo]   sys_sysinfo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* syscallnames[<span class="number">24</span>] = &#123;</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">  <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">  <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">  <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">  <span class="string">&quot;open&quot;</span>,</span><br><span class="line">  <span class="string">&quot;write&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">  <span class="string">&quot;link&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">  <span class="string">&quot;close&quot;</span>,</span><br><span class="line">  <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sysinfo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;tracemask)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallnames[num], p-&gt;trapframe-&gt;a0); <span class="comment">// </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sysinfo">sysinfo</h4>
<p>這裡的重點是</p>
<ul>
<li>數freemem</li>
<li>數unused procs</li>
</ul>
<p>數unused procs就是從proc表去數</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAllocedProcsCount</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(struct proc *p = proc; p &lt; &amp;proc[NPROC]; p++)</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">      ret++;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>數freemem從freelist去數(幸好是用page去分不然會很麻煩)<br>
4096是page的大小(PGSIZE)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFreeMemAmount</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(struct run* ptr = kmem.freelist; ptr; ptr=ptr-&gt;next)</span><br><span class="line">    ret += <span class="number">4096</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的問題是怎麼copy struct過去<br>
所以我們需要copy addr過去user space的struct</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 infoAddr; <span class="comment">// user pointer to struct stat</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;infoAddr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span> =</span> &#123;</span><br><span class="line">    .freemem = getFreeMemAmount(),</span><br><span class="line">    .nproc = getAllocedProcsCount(),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, infoAddr, (<span class="keyword">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="ch4-5">ch4&amp;5</h2>
<h3 id="trap">trap</h3>
<p>trap有3種</p>
<ul>
<li>from user mode (syscall)</li>
<li>from device (device interrupt)</li>
<li>from cpu (exception)</li>
</ul>
<p>trap通常的順序是</p>
<ul>
<li>trap 迫使控制權轉移到內核</li>
<li>內核保存寄存器和其他狀態，以便恢復執行</li>
<li>內核執行適當的處理程序代碼（例如，系統調用實現或設備驅動程序）</li>
<li>內核恢復保存的狀態，並從 trap 中返回</li>
<li>代碼從原來的地方恢復。</li>
</ul>
<p>Xv6 trap 處理分為四個階段</p>
<ul>
<li>RISC-V CPU 採取的硬件行為</li>
<li>為內核 C 代碼準備的彙編入口</li>
<li>處理 trap 的 C 處理程序</li>
<li>系統調用或設備驅動服務</li>
</ul>
<h3 id="RISC-V-trap-mechinism">RISC-V trap mechinism</h3>
<p>重要的reg</p>
<p>stvec：內核在這裡寫下 trap 處理程序的地址；RISC-V 到這裡來處理 trap。<br>
sepc：當 trap 發生時，RISC-V 會將程序計數器保存在這裡（因為 PC 會被 stvec 覆蓋）。<br>
sret: 從 trap 中返回<br>
scause：RISC -V 在這裡放了一個數字，描述了 trap 的原因。<br>
sscratch：內核在這裡放置了一個值，這個值會方便 trap 恢復/儲存用戶上下文。<br>
sstatus: 類似attr，SIE 位控制設備中斷是否被啟用，SPP 位表示 trap 是來自用戶模式還是監督者模式，並控制sret 返回到什麼模式</p>
<p>RISC-V 硬件對所有的 trap 類型（除定時器中斷外）進行以下操作</p>
<ul>
<li>如果該 trap 是設備中斷，且 sstatus SIE 位為 1
<ul>
<li>通過清除 SIE 來禁用中斷</li>
<li>複製 pc 到 sepc</li>
<li>將當前模式(用戶或監督者)保存在 sstatus 的 SPP 位</li>
<li>在 scause 設置該次 trap 的原因</li>
<li>將模式轉換為監督者</li>
<li>將 stvec 複製到 pc</li>
<li>執行新的 pc</li>
</ul>
</li>
</ul>
<p>CPU 不會切換到內核頁表，不會切換到內核中的棧，也不會保存 <strong>pc</strong> 以外的任何寄存器!!<br>
內核軟件必須執行這些任務!!</p>
<h3 id="trace-trap-from-user-space">trace: trap from user space</h3>
<ul>
<li>
<p>從proc的trampoline開始</p>
<ul>
<li>跑uservec (kernel mode，因為是中斷)
<ul>
<li>保存狀態到trapframe
<ul>
<li>trapframe可以
<ul>
<li>保存所有用户寄存器</li>
<li>指向当前进程的内核栈</li>
<li>当前 CPU 的 hartid</li>
<li>usertrap 的地址和内核页表的地址的指针</li>
</ul>
</li>
</ul>
</li>
<li>換kernel pagetable (透過設定satp)</li>
<li>跳usertrap (kernel mode)
<ul>
<li>設定stvec成kernelvec</li>
<li>保存pc</li>
<li>syscall或是device interrupt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>usertrap完到usertrapret (kernel mode)</p>
<ul>
<li>設定成stvec，要到uservec</li>
<li>把kernel資訊寫到trapframe</li>
<li>設定pc (trap的重點!!!)</li>
<li>設定user pagetable</li>
<li>設定user mode</li>
<li>跳到userret (user mode)
<ul>
<li>把trapframe載回去</li>
<li>return 到原本的位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="trace-exec-syscall">trace: exec syscall</h4>
<ul>
<li>用戶代碼將 exec 的參數放在寄存器 a0 和 a1 中，並將系統調用號放在 a7 中</li>
<li>系統調用號與函數指針表 syscalls 數組(kernel/syscall.c:108)中的項匹配 (from trapframe的a7)</li>
<li>ecall 指令進入內核，執行uservec、usertrap，然後執行 syscall</li>
<li>當系統調用函數返回時，syscall 將其返回值記錄在 p-&gt;trapframe-&gt;a0 中</li>
</ul>
<h5 id="如果有pointer">如果有pointer?</h5>
<p>透過kernel function去load<br>
使用 fetchstr 從用戶空間中檢索字符串文件名參數，fetchstr 調用 copyinstr 來做這些困難的工作</p>
<h3 id="trap-from-kernel-space">trap from kernel space</h3>
<p>kernel的trap因為在kernel所以不用換pagetable、stvec<br>
同時因為大家都有自己的kstack，所以可以把registrer存在stack上</p>
<ul>
<li>kernelvec
<ul>
<li>保存狀態到kstack</li>
<li>跳到kerneltrap (會回來kernelvec)
<ul>
<li>保存pc, sstatus, scause
<ul>
<li>pc很正常，但sstatus,scause!?
<ul>
<li>如果是timer interupt會yield</li>
<li>等回來，會需要原本的sstatus,scause</li>
</ul>
</li>
</ul>
</li>
<li>做該做的事
<ul>
<li>timer的preemptive切換在這裡實現</li>
</ul>
</li>
<li>回復sstatus,scause之後return</li>
</ul>
</li>
<li>從kstack回復狀態</li>
</ul>
</li>
</ul>
<h3 id="trap-from-device">trap from device</h3>
<p>許多設備驅動程序在兩個 context 中執行代碼：<br>
上半部分(top half)在進程的內核線程中運行<br>
下半部分(bottom half)在中斷時執行</p>
<p>上半部分是通過系統調用，如希望執行 I/O 的read 和 write。<br>
這段代碼可能會要求硬件開始一個操作（比如要求磁盤讀取一個塊）；然後代碼等待操作完成。<br>
最終設備完成操作並引發一個中斷。<br>
驅動程序的中斷處理程序，作為下半部分，推算出什麼操作已經完成，如果合適的話，喚醒一個等待該操作的進程，並告訴硬件執行下一個操作。</p>
<h4 id="trace-Console-input">trace: Console input</h4>
<p>UART 硬件在軟件看來是一組內存映射的控制寄存器 (不用port操作啦)</p>
<p>當 UART 接收到一個字節的輸入時，就產生一個接收中斷，當 UART 每次完成發送一個字節的輸出時產生一個傳輸完成(transmit complete)中斷(kernel/uart.c:53)。</p>
<p>trap 處理程序調用 devintr(kernel/trap.c:177)，它查看 RISC-V 的 scause 寄存器，發現中斷來自一個外部設備。<br>
然後它向一個叫做 PLIC的硬件單元詢問哪個設備中斷了(kernel/trap.c:186)。<br>
如果是 UART，devintr 調用 uartintr。</p>
<p>uartintr (kernel/uart.c:180) 從 UART 硬件中讀取在等待的輸入字符，並將它們交給consoleintr (kernel/console.c:138)；<br>
它不會等待輸入字符，因為以後的輸入會引發一個新的中斷。<br>
consoleintr 的工作是將中輸入字符積累 cons.buf 中，直到有一行字符</p>
<p>一旦被喚醒，consoleread 將會注意到 cons.buf 中的完整行，並將其將其複製到用戶空間，並返回（通過系統調用）到用戶空間。</p>
<h4 id="trace-Console-output">trace: Console output</h4>
<p>write 系統調用最終會到達 uartputc(kernel/uart.c:87)。<br>
設備驅動維護了一個輸出緩衝區(uart_tx_buf)，uartputc 將每個字符追加到緩衝區調用 uartstart 來啟動設備發送(如果還沒有的話)，然後返回</p>
<p>每次 UART 發送完成一個字節，它都會產生一個中斷。<br>
uartintr 調用 uartstart，uartintr檢查設備是否真的發送完畢，並將下一個緩衝輸出字符交給設備，每當 UART 發送完一個字節，就會產生一個中斷</p>
<h3 id="Timer-interrupts">Timer interrupts</h3>
<p>RISC-V 要求在機器模式下處理定時器中斷，而不是監督者模式。<br>
因此，xv6 對定時器中斷的處理與上面談到的 trap 機製完全分離了。</p>
<p>所以都在start中設定</p>
<ul>
<li>對 CLINT 硬件（core-local interruptor）進行編程，使其每隔一定時間產生一次中斷</li>
<li>設置一個類似於 trapframe 的 scratch 區域，幫助定時器中斷處理程序保存寄存器和 CLINT 寄存器的地址
<ul>
<li>所以前面trap要保留scratch的內容</li>
</ul>
</li>
<li>將 mtvec 設置為 timervec，啟用定時器中斷
<ul>
<li>中斷之後由clockintr處理 (tick++)</li>
</ul>
</li>
</ul>
<h4 id="interrupt還是要處理concurent">interrupt還是要處理concurent</h4>
<p>內核代碼需要注意它可能會被暫停（由於定時器中斷），然後在不同的 CPU 上恢復</p>
<h3 id="等等，一直發trap">等等，一直發trap?</h3>
<p>UART 驅動器通過讀取 UART 控制寄存器，一次檢索一個字節的數據<br>
這種模式被稱為編程 I/O，因為軟件在驅動數據移動。</p>
<p>程序化 I/O 簡單，但速度太慢，無法在高數據速率下使用。</p>
<p>需要高速移動大量數據的設備通常使用直接內存訪問（DMA）<br>
DMA 設備硬件直接將傳入數據寫入 RAM，並從 RAM 中讀取傳出數據</p>
<p>當設備在不可預知的時間需要關注時，中斷是很有用的，而且不會太頻繁。<br>
但中斷對 CPU的開銷很大。<br>
因此，高速設備，如網絡和磁盤控制器，使用了減少對中斷需求的技巧。</p>
<p>其中一個技巧是對整批傳入或傳出的請求提出一個單一的中斷。<br>
另一個技巧是讓驅動程序完全禁用中斷，並定期檢查設備是否需要關注。<br>
這種技術稱為輪詢（polling）。<br>
如果設備執行操作的速度非常快，輪詢是有意義的<br>
但如果設備大部分時間處於空閒狀態，則會浪費 CPU 時間<br>
一些驅動程序會根據當前設備的負載情況，在輪詢和中斷之間動態切換</p>
<h3 id="Lab-Traps">Lab Traps</h3>
<h4 id="backtrace">backtrace</h4>
<p>defs.h加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>            <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接著hint有提到sp與fp，所以就直接用吧<br>
但這裡用struct讓code好看一點</p>
<p>注意到riscv是小頭，所以mem addr小的會被放到struct最前面<br>
這段我是加在printf.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stk_frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> * prev_frame_plus_16;</span><br><span class="line">  uint64 ret_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint64</span></span><br><span class="line"><span class="function"><span class="title">r_fp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span></span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">riscv是小頭</span></span><br><span class="line"><span class="comment">所以addr越小，在c struct會被往上面放</span></span><br><span class="line"><span class="comment">stack是往下長 (addr-8)</span></span><br><span class="line"><span class="comment">所以寫struct要把下面的往struct的上面放 (stack倒著放)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stk_frame</span>* <span class="title">now</span> =</span> (struct stk_frame*)(r_fp()<span class="number">-16</span>);</span><br><span class="line">  uint64 start = PGROUNDDOWN(now-&gt;ret_addr);</span><br><span class="line">  <span class="keyword">for</span> (struct stk_frame* now = (struct stk_frame*)(r_fp()<span class="number">-16</span>); now-&gt;ret_addr &gt; start; now=now-&gt;prev_frame_plus_16<span class="number">-16</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, now-&gt;ret_addr);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>最後就直接call</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sleep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="fp-sp">fp &amp; sp</h5>
<p><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAyMC9sZWMvbC1yaXNjdi1zbGlkZXMucGRm">from hint<i class="fa fa-external-link-alt"></i></span><br>
sp就是目前stack的top<br>
fp就是保存caller訊息的addr</p>
<p>caller reg: caller要存，換言之，在call完function後可能會被破壞掉<br>
callee reg: callee要還原，換言之，在call完function後他們的值還是對的</p>
<h4 id="alarm">alarm</h4>
<p>如果timer動了就call一下callback，透過兩個syscall，sigalarm與sigreturn<br>
但要怎麼到callback去，是要在kernel mode跑??</p>
<p>timer interupt最後會回到user mode，所以只要讓他不要回到原本的位置就好!!<br>
這手法我們看過了，usertrapret與usertrap與kerneltrap都是透過改pc完成的</p>
<p>所以我們也改pc到callback，但是執行時的狀態怎麼辦，要怎麼回去原本的狀態?<br>
再多一個trapframe存原本的trapframe，在alarmreturn把原本的frame設回去</p>
<p>sysproc.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;acc = <span class="number">0</span>;</span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;trapframe2, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;p-&gt;cnt) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;p-&gt;cb) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trap.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;cnt) &#123;</span><br><span class="line">      <span class="keyword">if</span> (++p-&gt;acc == p-&gt;cnt) &#123;</span><br><span class="line">        memmove(p-&gt;trapframe2, p-&gt;trapframe, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;cb;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="Lab-network-driver">Lab network driver</h3>
<p>在2019的版本是要實現stack與driver的，所以很累，但2020就不用實現stack</p>
<h4 id="driver">driver</h4>
<p>driver的重點是怎麼與device溝通</p>
<p>iface都是用ring buffer去存資料</p>
<p>xx_ring就是device的buffer的狀態，然後他們是array<br>
那是要取哪一個??<br>
write: 取E1000_TDT，這是接下去dirver要寫的位置<br>
read: 取E1000_RDT，這是iface已經讀完的位置</p>
<p>xx_mbuf是ring buffer對應到的memory</p>
<p>所以<br>
write: 把<code>tx_ring[regs[E1000_TDT]]</code>的狀態設定好，把addr指向第一個位置<br>
read: 先拉<code>regs[E1000_TDT]+1</code>的mbuf，之後用新的mbuf蓋掉原本的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123; <span class="keyword">return</span> (i+<span class="number">1</span>) % len; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_transmit</span><span class="params">(struct mbuf *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">int</span> i = regs[E1000_TDT], ret;</span><br><span class="line">  <span class="keyword">if</span> ((tx_ring[i].status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;not ready for trasmit&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// free previous mbuf</span></span><br><span class="line">    <span class="keyword">if</span> (tx_mbufs[i])</span><br><span class="line">      mbuffree(tx_mbufs[i]);</span><br><span class="line">    tx_ring[i].addr = (uint64)m-&gt;head;</span><br><span class="line">    tx_ring[i].length = m-&gt;len;</span><br><span class="line">    tx_ring[i].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line">    tx_mbufs[i] = m;</span><br><span class="line">    regs[E1000_TDT] = inc(i, TX_RING_SIZE);</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate mbuf for iface</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_recv</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = inc(regs[E1000_RDT], RX_RING_SIZE);rx_ring[i].status &amp; E1000_RXD_STAT_DD;i = inc(regs[E1000_RDT], RX_RING_SIZE)) &#123;</span><br><span class="line">    acquire(&amp;e1000_lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">pkt</span> =</span> *(rx_mbufs+i);</span><br><span class="line">    mbufput(pkt, rx_ring[i].length);</span><br><span class="line">    rx_mbufs[i] = mbufalloc(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 從哪邊塞</span></span><br><span class="line">    rx_ring[i].addr = (uint64)rx_mbufs[i]-&gt;head;</span><br><span class="line">    rx_ring[i].status = <span class="number">0</span>;</span><br><span class="line">    regs[E1000_RDT] = i;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    net_rx(pkt);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="network-stack">network stack</h4>
<p>雖然說不用實現一個network stack，但我們可以trace看看</p>
<h5 id="rx">rx</h5>
<ul>
<li>net_rx
<ul>
<li>拉eth_header</li>
<li>判斷type決定要去哪
<ul>
<li>ntohs去轉數字</li>
</ul>
</li>
</ul>
</li>
<li>net_rx_ip
<ul>
<li>拉ip_header</li>
<li>各種判斷與check
<ul>
<li>cksum</li>
<li>routing
<ul>
<li>這裡只有看是不是給我們，不是就丟了</li>
</ul>
</li>
</ul>
</li>
<li>算udp長度</li>
<li>送去udp</li>
</ul>
</li>
<li>net_rx_udp
<ul>
<li>拉udp_header</li>
<li>各種判斷與check</li>
<li>把sip, sport, dport抓出來，送到sockrecvudp</li>
</ul>
</li>
<li>sockrecvudp
<ul>
<li>找到對的socket</li>
<li>把pkt塞到socket的queue</li>
</ul>
</li>
</ul>
<h5 id="tx">tx</h5>
<ul>
<li>sockwrite
<ul>
<li>alloc mbuf</li>
<li>copy data</li>
<li>送到net_tx_udp</li>
</ul>
</li>
<li>net_tx_udp
<ul>
<li>把sip, sport, dport轉成network order</li>
<li>設定udp header，並加在mbuf上</li>
<li>送到net_tx_ip</li>
</ul>
</li>
<li>net_tx_ip
<ul>
<li>與net_tx_udp很像，轉資料，加在mbuf上</li>
<li>送到net_tx_eth</li>
</ul>
</li>
<li>不存在的routing
<ul>
<li>一般來說從ip到eth或是eth到ip之間要過routing</li>
<li>決定要繼續往上還是直接轉出去
<ul>
<li>以linux的netfilter為例</li>
<li><img src="https://www.researchgate.net/publication/320174686/figure/download/fig5/AS:613873052815377@1523370149442/Netfilter-hooks-and-packet-flow-https-doiorg-101371-journalpone0182375g005.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>net_tx_eth
<ul>
<li>塞ethaddr，加在mbuf上
<ul>
<li>這裡是直接boardcast，所以迴避了arp</li>
</ul>
</li>
<li>call e1000_transmit</li>
</ul>
</li>
</ul>
<h2 id="ch3-3">ch3</h2>
<p>來了，最難的部分，撐過去就會有全新的方式看待c了!!</p>
<p>為什麼會難?</p>
<ol>
<li>很難debug，一個是要知道結構，也要只到這個數字對應到什麼，還有concurrent要處理</li>
<li>都是uint64</li>
<li>之後會在va, pte, pa一直轉來轉去</li>
</ol>
<h3 id="kernel-mem-layout">kernel mem layout</h3>
<p><img src="https://i.imgur.com/uF59eie.png" alt=""></p>
<ul>
<li>当内核通过高地址映射使用 stack 时，它们也可以通过直接映射的地址被内核访问
<ul>
<li>内核使用“直接映射”RAM 和内存映射设备寄存器，也就是在虚拟地址上映射硬件资源，这些地址与物理地址相等。
<ul>
<li>例如，内核本身在虚拟地址空间和物理内存中的位置都是KERNBASE=0x80000000。直接映射简化了读/写物理内存的内核代码。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="pagetable">pagetable</h3>
<p>page table就是把virtual address(va)，丟到table換出physical address(pa)<br>
<img src="https://i.imgur.com/sZBLA3r.png" alt=""></p>
<p>硬體上是分成3層，也因為多了一層抽象，所以可以多點attr<br>
<img src="https://i.imgur.com/wtcbDS1.png" alt=""></p>
<p>像後面就是看page有沒有PTE_V(Page Table Entry, PTE)，決定這個page是不是free</p>
<p>要告訴硬件使用頁表，內核必須將根頁表頁的物理地址寫入 satp 寄存器中</p>
<p>pte, pagetable都是存在pa中!!</p>
<h3 id="如何map-如何把va換成pa">如何map &amp; 如何把va換成pa</h3>
<p>pagetable就是hashtable，所以要先知道key,value到底要什麼?</p>
<p>key: va，在程式中跑的數字；pte，可以換出pagetable或是pa的數字，可以把pte當成page開頭的pa(見walk)<br>
value: pa，真實mem的addr</p>
<h3 id="trace-free-mem怎麼產生的">trace: free mem怎麼產生的</h3>
<p>把kernel的memory layout打開來<br>
<img src="https://i.imgur.com/tbYvEDJ.png" alt=""></p>
<p>中間的free memory就是我們需要的東西</p>
<p>接著就是怎麼讓free memory可以被分配，要先切塊</p>
<ul>
<li>kinit
<ul>
<li>freerange
<ul>
<li>從end到PHYSTOP跑kfree
<ul>
<li>kfree就是加linked list</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="如何把va換成pa-walk">如何把va換成pa: walk</h4>
<p>就是模擬在table跳的過程，一層一層換pte，到最後就可以用kalloc拿pa，利用pa設定對應的pte<br>
之後回傳對應的pa</p>
<p>那怎麼從va拿pte?<br>
再看回去這張圖<br>
<img src="https://i.imgur.com/wtcbDS1.png" alt=""></p>
<p>注意到va最右手邊就是12個offset，之後看到pte的右手邊是10位flag，所以轉成pte就是把12位拿掉再把10位補回去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br></pre></td></tr></table></figure>
<p>剩下就是walk三層table了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="function"><span class="keyword">pte_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">walk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, <span class="keyword">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="keyword">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="keyword">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何map-mappages">如何map: mappages</h4>
<p>mappages就是walk很多次，一次一個page</p>
<p>如果完成map就可以用c的*做操作!!<br>
十分神奇，前面還是當成數字操作，之後就可以直接dereference</p>
<h3 id="trace-怎麼做mem-alloc">trace: 怎麼做mem alloc</h3>
<p>mem alloc，就是</p>
<ol>
<li>kalloc拿一塊page，拿到一個pa</li>
<li>mappages在pagetable中設定va到pa</li>
</ol>
<h3 id="trace-怎麼free-mem-pagetable">trace: 怎麼free mem/pagetable</h3>
<p>free mem就是</p>
<ol>
<li>uvmunmap
<ul>
<li>會walk拉出pa</li>
<li>檢查有沒有被map過(有PTE_V)</li>
<li>如果有要free，就kfree</li>
</ul>
</li>
</ol>
<p>free pagetable比較麻煩</p>
<ul>
<li>uvmfree
<ul>
<li>uvmunmap把所有pa去掉</li>
<li>walkfree把pte去掉</li>
</ul>
</li>
</ul>
<h4 id="trace-how-to-create-kernel-page-table">trace: how to create kernel page table</h4>
<ul>
<li>kvminit設定<code>kernel_pagetable</code>
<ul>
<li>跑kvmmake會生出kernel pagetable
<ul>
<li>先kalloc一塊放pagetable</li>
<li>之後照layout設定</li>
</ul>
</li>
</ul>
</li>
<li>kvminithart
<ul>
<li>設定satp</li>
</ul>
</li>
<li>how to access a page table:
<ul>
<li>pagetable_t，它實際上是一個指向 RISC-V 根頁表頁的指針 (pa)</li>
</ul>
</li>
</ul>
<h3 id="process-mem-layout">process mem layout</h3>
<p><img src="https://i.imgur.com/yBoV986.png" alt=""><br>
當一個進程要求 xv6 提供更多的用戶內存時，xv6 首先使用 kalloc 來分配物理頁，然後將指向新物理頁的 PTE 添加到進程的頁表中。</p>
<p>xv6 使用 PTE_V 來清除不使用的 PTE</p>
<p>trampoline是負責跳到hypervisor mode的code<br>
trapframe是在跳之前保存process狀態的地方</p>
<h4 id="trace-sbrk">trace: sbrk</h4>
<p>回傳目前的終點(sz)，之後算與原本size的差，之後調用uvmalloc 或 uvmdealloc縮放自己的大小</p>
<h4 id="trace-exec">trace: exec</h4>
<ol>
<li>open binary exe (namei)</li>
<li>parse ELF</li>
<li>從proc_pagetable分配一個page，之後用uvmalloc為剩下的proc配置page</li>
</ol>
<p>exec配出來的mem layout可以看process mem layout的圖</p>
<h3 id="Before-labs">Before labs</h3>
<p>在做lab之前先看看要怎麼為某個va做map，會做兩件事</p>
<ol>
<li>拿一塊page</li>
<li>把va指(map)過去
<ul>
<li>這裡的va不一定是剛好在page的起點上!!</li>
<li>記得，所有mem都要以page為單位</li>
</ul>
</li>
</ol>
<p>故要先介紹兩個macro，因為之後很常用到</p>
<ul>
<li>PGROUNDUP: page的終點
<ul>
<li>usage: exec在alloc elf的執行檔後要alloc stack，就是先取PGROUNDUP，之後stack從PGROUNDUP開始alloc</li>
</ul>
</li>
<li>PGROUNDDOWN: page的起點
<ul>
<li>usage: mappages在一開始就先對傳進來的va做PGROUNDDOWN，之後才開始alloc</li>
</ul>
</li>
</ul>
<h3 id="Lab-Page-tables">Lab Page tables</h3>
<h4 id="vmprint">vmprint</h4>
<p>小試身手，抄freewalk，走過每個pte即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint_dfs</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*pagetable &lt; MAXVA)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; pte &lt; MAXVA)&#123;</span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dep;j++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..%d: ptr %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">        vmprint_dfs((<span class="keyword">pagetable_t</span>)child, dep+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  vmprint_dfs(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="new-copyin-copyinstr">new copyin, copyinstr</h4>
<p>現在想把user mode的資料加到kernel mode的表，這樣就不用copy來copy去</p>
<p>先要有產生kernel pagetable的函數，並在struct proc中多加一個kernel pagetable</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kpgtinit</span><span class="params">(<span class="keyword">pagetable_t</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(t, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(t, UART0, PGSIZE, UART0, PTE_R | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kpgtinit: uart0\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(t, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kpgtinit: virtio0\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(t, CLINT, <span class="number">0x10000</span>, CLINT, PTE_R | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kpgtinit: clint\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(t, PLIC, <span class="number">0x400000</span>, PLIC, PTE_R | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kpgtinit: plic\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(t, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kpgtinit: kernel base\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(t, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kpgtinit: kernel data\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(t, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kpgtinit: trampoline\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">switchPGT</span><span class="params">(<span class="keyword">pagetable_t</span> t)</span> </span>&#123;</span><br><span class="line">  w_satp(MAKE_SATP(t));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因為每個process都有kernel table，所以可以把kstack分到每個kernel pagetable去，把procinit的kstack拿掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc*</span></span><br><span class="line"><span class="function"><span class="title">allocproc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  p-&gt;kpagetable = (<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  kpgtinit(p-&gt;kpagetable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  uint64 va = KSTACK(<span class="number">0</span>);</span><br><span class="line">  mappages(p-&gt;kpagetable, va, PGSIZE, (uint64)pa, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以現在每個process都有一個kernel pagetable，需要的時候會把user mode pagetable的map到在kernel pagetable也map一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">includeInto</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">pagetable_t</span> kpagetable, uint64 oldsz, uint64 newsz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte_from, *pte_to;</span><br><span class="line">  uint64 a, pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span> (a = oldsz; a &lt; newsz; a += PGSIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pte_from = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;includeInto: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((pte_to = walk(kpagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;includeInto: walk fails&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte_from);</span><br><span class="line">    flags = (PTE_FLAGS(*pte_from) &amp; (~PTE_U));</span><br><span class="line">    *pte_to = PA2PTE(pa) | flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要的時候? 就是程式在kernel mode中時動到或是需要user mode的資料時</p>
<ul>
<li>userinit</li>
<li>growproc
<ul>
<li>這裡要看kernel的layout，PILC上面的其實不能用，因為已經被map了</li>
</ul>
</li>
<li>fork</li>
<li>exec</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">userinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  includeInto(p-&gt;pagetable, p-&gt;kpagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">growproc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (PGROUNDUP(sz + n) &gt;= PLIC)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    includeInto(p-&gt;pagetable, p-&gt;kpagetable, sz-n, sz);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  includeInto(np-&gt;pagetable, np-&gt;kpagetable, <span class="number">0</span>, np-&gt;sz);</span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>freeproc也把kernel pagetable也free掉，但是不能把kernel的項目的pa給free掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freewalk_keepleaf</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V)) &#123;</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        freewalk_keepleaf((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">proc_freekpt</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V))&#123;</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        proc_freekpt((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;proc free kpt: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freeproc</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kstack)</span><br><span class="line">  &#123;</span><br><span class="line">    uvmunmap(p-&gt;kpagetable, p-&gt;kstack, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable)</span><br><span class="line">    freewalk_keepleaf(p-&gt;kpagetable);</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最後就可以切到新的copyin, copyinstr了</p>
<h3 id="Lab-Lazy-allocation">Lab Lazy allocation</h3>
<p>在sbrk不分配mem</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">   <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">     growproc(n);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     myproc()-&gt;sz += n;</span><br><span class="line">  <span class="keyword">return</span> addr; <span class="comment">// !!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在page fault時做分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_lazy</span><span class="params">(uint64 addr)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">int</span> stkOverFlow = (addr &lt; p-&gt;trapframe-&gt;sp);</span><br><span class="line">  <span class="comment">// page-faults on a virtual memory address higher than any allocated with sbrk()</span></span><br><span class="line">  <span class="comment">// this should be &gt;= not &gt; !!!</span></span><br><span class="line">  <span class="keyword">int</span> addrOutOfBound = (addr &gt;= p-&gt;sz);</span><br><span class="line">  <span class="keyword">void</span> *mem;</span><br><span class="line">  <span class="keyword">if</span> (stkOverFlow)</span><br><span class="line">    ;<span class="comment">//printf(&quot;lazy: stack overflow\n&quot;);</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(addrOutOfBound)</span><br><span class="line">    ;<span class="comment">//printf(&quot;lazy: addr over of bound\n&quot;);</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">    ;<span class="comment">//printf(&quot;out of pa\n&quot;);</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(addr), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) &lt; <span class="number">0</span>)<span class="comment">// ???</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (do_lazy(r_stval()) &lt; <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下要在走訪pte時忽略沒有PTE_V的page，這邊就看hint就知道要改哪</p>
<h3 id="Lab-Copy-on-write">Lab Copy on-write</h3>
<p>這裡會牽涉到reference counter，導致要處理concurrent!!<br>
如果沒有處理好，連怎麼出事的都不知道</p>
<p>先refcnt，代表有多少process有map到這個page</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">refcnt</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint counter[(PHYSTOP - KERNBASE) / PGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">refcnt</span> <span class="title">refcnt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refcnt_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  acquire(&amp;refcnt.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refcnt_unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  release(&amp;refcnt.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refcnt_create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  initlock(&amp;refcnt.lock, <span class="string">&quot;refcnt&quot;</span>);</span><br><span class="line">  refcnt_lock();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,goal=(PHYSTOP - KERNBASE) / PGSIZE;i&lt;goal;i++)</span><br><span class="line">    refcnt.counter[i] = <span class="number">0</span>;</span><br><span class="line">  refcnt_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">refcnt_index</span><span class="params">(uint64 pa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (pa - KERNBASE) / PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refcnt_set</span><span class="params">(uint64 pa, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  refcnt.counter[refcnt_index(pa)] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">uint</span></span><br><span class="line"><span class="function"><span class="title">refcnt_get</span><span class="params">(uint64 pa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> refcnt.counter[refcnt_index(pa)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">refcnt_incr</span><span class="params">(uint64 pa)</span></span>&#123;</span><br><span class="line">  refcnt.counter[refcnt_index(pa)]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">refcnt_desc</span><span class="params">(uint64 pa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (refcnt.counter[refcnt_index(pa)] &gt; <span class="number">0</span>)</span><br><span class="line">    refcnt.counter[refcnt_index(pa)]--;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    panic(<span class="string">&quot;wtf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之後page要會fork<br>
兩個case</p>
<ol>
<li>refcnt大於1: 產生新的page，原本的page的refcnt減1</li>
<li>refcnt等於1: 直接拿去用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">page_fork</span><span class="params">(uint64 va)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="keyword">pagetable_t</span> pgt = myproc()-&gt;pagetable;</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="keyword">pte_t</span> * pte = walk(pgt, va, <span class="number">0</span>);</span><br><span class="line">  uint64 pa = PTE2PA(*pte);</span><br><span class="line">  uint flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span> ((*pte) &amp; PTE_COW) &#123;</span><br><span class="line">    refcnt_lock(); <span class="comment">// MUST BE DONE TOGETHER!!</span></span><br><span class="line">    <span class="keyword">if</span> (refcnt_get(pa) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">void</span> *mem = kalloc_cow();</span><br><span class="line">      <span class="keyword">if</span> (mem != <span class="number">0</span>) &#123;</span><br><span class="line">        memmove(mem, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">        <span class="keyword">if</span>(mappages(pgt, va, PGSIZE, (uint64)mem, (flags &amp; (~PTE_COW)) | PTE_W) != <span class="number">0</span>)</span><br><span class="line">          ret = <span class="number">-1</span>, kfree(mem);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ret = <span class="number">0</span>, refcnt_desc(pa);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        ret = <span class="number">-3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      ret = <span class="number">0</span>, *pte = (*pte &amp; ~PTE_COW) | PTE_W;</span><br><span class="line">    refcnt_unlock();</span><br><span class="line">  &#125; <span class="keyword">else</span> </span><br><span class="line">    ret = <span class="number">-2</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>與之相對，kfree只有在refcnt小於等於1時才free，其他都是decrease refcnt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  refcnt_lock(); <span class="comment">//premise: counter == 0  &lt;=&gt; this page is in freelist</span></span><br><span class="line">  <span class="keyword">if</span> (refcnt_get((uint64)pa) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">    refcnt_set((uint64)pa, <span class="number">0</span>);</span><br><span class="line">    r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    refcnt_desc((uint64)pa);</span><br><span class="line">  refcnt_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，從kernel mode複製到user mode也要fork page<br>
如果都指向同一個page要分開</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 從copy變成map</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pte = ((*pte) &amp; (~PTE_W)) | PTE_COW;</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, (flags &amp; (~PTE_W)) | PTE_COW) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      refcnt_lock();</span><br><span class="line">      refcnt_incr(pa);</span><br><span class="line">      refcnt_unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果都指向同一個page要分開</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte &amp;&amp; (*pte &amp; PTE_COW))</span><br><span class="line">      <span class="keyword">if</span> (page_fork(va0) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之後把剩下的線串完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((r_scause() == <span class="number">15</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (page_fork(r_stval()))</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊有一個要注意的點<br>
refcnt是跟著page走，所以<em>直到page與refcnt設定好之前任何人都不該動refcnt</em><br>
這導致kalloc與kalloc_cow的產生，因為refcnt會鎖，但是做page_fork時會動到兩個page，所以kalloc_cow不鎖，交給page_fork鎖</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    refcnt_lock();</span><br><span class="line">    refcnt_incr((uint64)r);</span><br><span class="line">    refcnt_unlock();</span><br><span class="line">    <span class="comment">//printf(&quot;init: %p %d\n&quot;, r, refcnt_get((uint64)r));</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc_cow</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    refcnt_set((uint64)r, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;init: %p %d\n&quot;, r, refcnt_get((uint64)r));</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最後就像，lazy alloc做的一樣，要處理走訪pte時忽略沒有PTE_V的page</p>
<p>lock心得<br>
0. 上鎖</p>
<ol>
<li>先存狀態</li>
<li>都用同一個狀態延伸</li>
<li>把所有動作用同一個鎖包 (這會導致在不同branch要一直release)</li>
<li>確保假設被打破時可以馬上停下程式 (ex: panic(“wtf”))</li>
</ol>
<h3 id="Lab-mmap">Lab mmap</h3>
<p>現在user可以自己設定自己的addr了!!</p>
<p>Q: 這樣怎麼區分user設定的資料與程式設定的(原本活在pagetable中的)資料?<br>
A: 多一個vma去trace</p>
<p>Q: 怎麼分配位置?<br>
A: 這隨便，這裡從TRAPFRAME之後開始</p>
<p>Q: 如果alloc很多塊，卻只free其中幾塊，我們還有方法再利用那些mem嗎?<br>
A: 這要做compact，但我懶，沒做test會過</p>
<p>先加vma，與sbrk很像，用vma_end紀錄最後的位置<br>
記住，riscv是往addr小的地方開始填資料</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">  uint64 va_end;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">int</span> prot;</span><br><span class="line">  <span class="keyword">int</span> flag;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VMA_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VMA_BASE (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> <span class="title">vma</span>[<span class="title">VMA_SIZE</span>];</span></span><br><span class="line">    uint64 vma_end;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之後要可以alloc vma，與get vma</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct entry* <span class="title">allocvma</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">ret</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;VMA_SIZE;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].size == <span class="number">0</span>) &#123;</span><br><span class="line">      ret = &amp;(p-&gt;vma[i]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct entry* <span class="title">getvma</span><span class="params">(uint64 addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;VMA_SIZE;i++)</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].size &gt; <span class="number">0</span> &amp;&amp; p-&gt;vma[i].va_end &gt; addr &amp;&amp; addr &gt;= p-&gt;vma[i].va_end-p-&gt;vma[i].size)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">return</span> i &lt; VMA_SIZE ? &amp;(p-&gt;vma[i]) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把mmap, munmap加進去<br>
這裡做lazy，只有在read/write才map與讀檔案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_mmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span></span><br><span class="line">  uint64 ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> size, prot, flags, fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">int</span> goodargs = (argint(<span class="number">1</span>, &amp;size) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(goodargs || (!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED)))</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">vma</span> =</span> allocvma();</span><br><span class="line">  <span class="keyword">if</span> (vma) &#123;</span><br><span class="line">    <span class="keyword">int</span> pte_prot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (prot &amp; PROT_READ)</span><br><span class="line">      pte_prot |= PTE_R;</span><br><span class="line">    <span class="keyword">if</span> (prot &amp; PROT_WRITE)</span><br><span class="line">      pte_prot |= PTE_W;</span><br><span class="line">    filedup(f);</span><br><span class="line">    vma-&gt;va_end = p-&gt;vma_end; <span class="comment">// start在小 end在大 mmap回傳的addr是小的!!</span></span><br><span class="line">    ret = vma-&gt;va_end-size;</span><br><span class="line">    vma-&gt;size = size;</span><br><span class="line">    vma-&gt;f = f;</span><br><span class="line">    vma-&gt;prot = pte_prot;</span><br><span class="line">    vma-&gt;flag = flags;</span><br><span class="line">    p-&gt;vma_end -= size;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">do_mummap</span><span class="params">(uint64 addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">vma</span> =</span> getvma(addr);</span><br><span class="line">  <span class="keyword">if</span> (!vma || addr + len &gt; vma-&gt;va_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//printf(&quot;??: %d start:%p va:%p va_end:%p end:%p\n&quot;, vma-&gt;size, vma-&gt;va_end-vma-&gt;size, addr, addr+len, vma-&gt;va_end);</span></span><br><span class="line">  <span class="keyword">for</span> (uint64 va=addr,end=addr+len;va &lt; end;va+=PGSIZE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (walkaddr(p-&gt;pagetable, va)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vma-&gt;flag &amp; MAP_SHARED)</span><br><span class="line">          filewrite(vma-&gt;f, va, PGSIZE);</span><br><span class="line">        uvmunmap(p-&gt;pagetable, va, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr == vma-&gt;va_end-vma-&gt;size &amp;&amp; addr+len == vma-&gt;va_end) &#123;</span><br><span class="line">    vma-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//fileclose(vma-&gt;f);</span></span><br><span class="line">    vma-&gt;f-&gt;ref--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vma-&gt;size -= len;</span><br><span class="line">    <span class="keyword">if</span> (addr+len == vma-&gt;va_end)</span><br><span class="line">      vma-&gt;va_end -= len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_munmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> do_mummap(addr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在page fault才map與讀檔案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_mmap</span><span class="params">(uint64 addr)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 base = PGROUNDDOWN(addr);</span><br><span class="line">  <span class="keyword">void</span> *mem;</span><br><span class="line">  <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;out of pa\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    struct entry* vma = getvma(addr);</span><br><span class="line">    <span class="keyword">if</span> (vma) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span> (mappages(p-&gt;pagetable, base, PGSIZE, (uint64)mem, vma-&gt;prot|PTE_U|PTE_X) &lt; <span class="number">0</span>)</span><br><span class="line">        kfree(mem), <span class="built_in">printf</span>(<span class="string">&quot;map fail\n&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ilock(vma-&gt;f-&gt;ip);</span><br><span class="line">        <span class="keyword">int</span> offset = base - (vma-&gt;va_end-vma-&gt;size);</span><br><span class="line">        readi(vma-&gt;f-&gt;ip, <span class="number">1</span>, base, offset, PGSIZE);</span><br><span class="line">        iunlock(vma-&gt;f-&gt;ip);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//printf(&quot;vma no found\n&quot;);</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (do_mmap(r_stval()) &lt; <span class="number">0</span>)</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下就是初始化與在fork時vma用到的file要記得refcnt要遞增</p>
<h3 id="Linux-crash-tool">Linux crash tool</h3>
<p>經過前面lab的洗禮，相信大家也對va,pa,pte的關係有深刻的了解<br>
這樣可以來看看，在linux中怎麼改mem</p>
<ol>
<li>crash tool: 可以分析kerneldump看ctx與kernel的struct</li>
<li>/dev/mem: <em>整個</em>mem的視圖，就是ch3第一張圖的所有東西都會在這裡看到</li>
</ol>
<p>下面借用<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQHN5c3Byb2cvbGludXgtbWVtLWRldmljZQ==">這裡<i class="fa fa-external-link-alt"></i></span>的內容來看看這兩個怎麼一起用<br>
先預設/dev/mem可以寫，pagetable沒有任何限制</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL3VuaXhfY29tbWFuZHMvY3Jhc2guaHRt">這裡<i class="fa fa-external-link-alt"></i></span>可以看crash的指令</p>
<ul>
<li>vtop: show va的訊息</li>
<li>wr: 改寫 mem</li>
<li>set: 把mem view改成該pid的process的view</li>
<li>ps: 就是ps</li>
</ul>
<h4 id="改pte的map">改pte的map</h4>
<p>兩個process，兩個page，兩個addr(0x34000000, 0x34004000)</p>
<p>之後在crash中改pte指到的地方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立一個分頁 P1 映射到保留記憶體</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0x34000000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 P1 的内容</span></span><br><span class="line">    *addr = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address at: %p   content is: 0x%lx\n&quot;</span>, addr, addr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待分頁交換</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address at: %p   content is: 0x%lx\n&quot;</span>, addr, addr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(addr, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立分頁 P2 映射到保留的記憶體</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0x34004000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 P2 的内容</span></span><br><span class="line">    *addr = <span class="number">0x8877665544332211</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address at: %p   content is: 0x%lx\n&quot;</span>, addr, addr[<span class="number">0</span>]);  </span><br><span class="line">    <span class="comment">// 等待分頁交換</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address at: %p   content is: 0x%lx\n&quot;</span>, addr, addr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(addr, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接著要找pte，找對面對到的pa</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; ps | grep master                                                                                                                                                                [8/287]</span><br><span class="line">  32334  32333   6  ffff93d0ed35c680  IN   0.0    4512   1384  master</span><br><span class="line">crash&gt; set 32334</span><br><span class="line">    PID: 32334</span><br><span class="line">COMMAND: &quot;master&quot;</span><br><span class="line">   TASK: ffff93d0ed35c680  [THREAD_INFO: ffff93d0ed35c680]</span><br><span class="line">    CPU: 6</span><br><span class="line">  STATE: TASK_INTERRUPTIBLE</span><br><span class="line">crash&gt; vtop 0x7f8f3ba6a000</span><br><span class="line">VIRTUAL     PHYSICAL</span><br><span class="line">7f8f3ba6a000  2c0000000 &lt;= va 與 pa</span><br><span class="line"></span><br><span class="line">   PGD: 2ae2f87f8 =&gt; 80000002af219067</span><br><span class="line">   PUD: 2af2191e0 =&gt; 2a9d3c067</span><br><span class="line">   PMD: 2a9d3cee8 =&gt; 2ac34b067</span><br><span class="line">   PTE: 2ac34b350 =&gt; 80000002c0000267 &lt;= pte 與 對到的pa</span><br><span class="line">  PAGE: 2c0000000</span><br><span class="line"></span><br><span class="line">      PTE         PHYSICAL   FLAGS</span><br><span class="line">80000002c0000267  2c0000000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)</span><br><span class="line"></span><br><span class="line">      VMA           START       END     FLAGS FILE</span><br><span class="line">ffff93d0e894e000 7f8f3ba6a000 7f8f3ba6b000 d0444fb /dev/mem</span><br><span class="line"></span><br><span class="line">crash&gt; wr -64 -p 2ac34b350 80000002c0004267 &lt;= pte 與 對面對到的pa</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; ps | grep slave</span><br><span class="line">  32348  32347   1  ffff93d0ed359780  IN   0.0    4512   1416  slave</span><br><span class="line">crash&gt; set 32348</span><br><span class="line">    PID: 32348</span><br><span class="line">COMMAND: &quot;slave&quot;</span><br><span class="line">   TASK: ffff93d0ed359780  [THREAD_INFO: ffff93d0ed359780]</span><br><span class="line">    CPU: 1</span><br><span class="line">  STATE: TASK_INTERRUPTIBLE</span><br><span class="line">crash&gt; vtop 0x7f269fba3000</span><br><span class="line">VIRTUAL     PHYSICAL</span><br><span class="line">7f269fba3000  2c0004000</span><br><span class="line"></span><br><span class="line">   PGD: 2ae2ca7f0 =&gt; 80000002ac354067</span><br><span class="line">   PUD: 2ac3544d0 =&gt; 2b45f6067</span><br><span class="line">   PMD: 2b45f67e8 =&gt; 2ac7db067</span><br><span class="line">   PTE: 2ac7dbd18 =&gt; 80000002c0004267</span><br><span class="line">  PAGE: 2c0004000</span><br><span class="line">  </span><br><span class="line">      PTE         PHYSICAL   FLAGS</span><br><span class="line">80000002c0004267  2c0004000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)</span><br><span class="line"></span><br><span class="line">      VMA           START       END     FLAGS FILE</span><br><span class="line">ffff93d0eea18820 7f269fba3000 7f269fba4000 d0444fb /dev/mem</span><br><span class="line"></span><br><span class="line">crash&gt; wr -64 -p 2ac7dbd18 80000002c0000267</span><br></pre></td></tr></table></figure>
<h4 id="改pa的值">改pa的值</h4>
<p>先給個程式，印出va(不然無法知道pa)，之後直接改pa的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名映射一段記憶體空間</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改內容</span></span><br><span class="line">    <span class="built_in">strcpy</span>(addr, <span class="string">&quot;浙江溫州皮鞋濕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只是範例，所以直接顯示 address 實際操作時需要手工 hack 記憶體位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address at: %p   content is: %s\n&quot;</span>, addr, addr);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address at: %p   content is: %s\n&quot;</span>, addr, addr);</span><br><span class="line"></span><br><span class="line">    munmap(addr, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用crash找pa</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; ps | grep test</span><br><span class="line">  11608  11607   1  ffff93d0ed378000  IN   0.0    4512   1408  test</span><br><span class="line">  </span><br><span class="line">crash&gt; set 11608</span><br><span class="line">    PID: 11608</span><br><span class="line">COMMAND: &quot;test&quot;</span><br><span class="line">   TASK: ffff93d0ed378000  [THREAD_INFO: ffff93d0ed378000]</span><br><span class="line">    CPU: 1</span><br><span class="line">  STATE: TASK_INTERRUPTIBLE</span><br><span class="line">  </span><br><span class="line">crash&gt; vtop 0x7f7d88693000</span><br><span class="line">VIRTUAL     PHYSICAL</span><br><span class="line">7f7d88693000  1f83ed000</span><br><span class="line"></span><br><span class="line">   PGD: 2a73ee7f0 =&gt; 8000000220a30067</span><br><span class="line">   PUD: 220a30fb0 =&gt; 2ae1f4067</span><br><span class="line">   PMD: 2ae1f4218 =&gt; 2b0c7e067</span><br><span class="line">   PTE: 2b0c7e498 =&gt; 80000001f83ed867</span><br><span class="line">  PAGE: 1f83ed000</span><br><span class="line"></span><br><span class="line">      PTE         PHYSICAL   FLAGS</span><br><span class="line">80000001f83ed867  1f83ed000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)</span><br><span class="line"></span><br><span class="line">      VMA           START       END     FLAGS FILE</span><br><span class="line">ffff93d0ec033450 7f7d88693000 7f7d88694000 80000fb dev/zero</span><br><span class="line"></span><br><span class="line">      PAGE        PHYSICAL      MAPPING       INDEX CNT FLAGS</span><br><span class="line">ffffd377c7e0fb40 1f83ed000 ffff93d0f01a9290        0  2 17ffffc0040038 uptodate,dirty,lru,swapbacked</span><br></pre></td></tr></table></figure>
<p>現在我們知道0x1f83ed000就是我們要的位置!!<br>
就改吧 mmap到pa去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> off = <span class="number">0x1f83ed000</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, off);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(addr, <span class="string">&quot;下雨進水不會胖&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    munmap(addr, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小結">小結</h4>
<p>這裡的例子很簡單，但是很可怕，基本上只要知道pa就什麼都擋不住了<br>
同時如果知道struct的大小與偏移量，基本上就是可以操作任何東西了</p>
<p>像是在task_struct遊走，改常數等等…<br>
可以看上面的文章與<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMDQwVzE5LUNQRjBWblV2d0ZTS2lYdw==">這裡<i class="fa fa-external-link-alt"></i></span>都有一些使用範例</p>
<h3 id="Heap-Coruption">Heap Coruption</h3>
<p>剛好提到記憶體，可以看看關於記憶體的問題，下面內容主要處自<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3JlbmVlMDkxOC93aW5kYmctaGVhcC1jb3JydXB0aW9uLWFuYWx5emUtNTFmYTQzYTViMzgz">這裡<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>在第一次的dump，backtrace沒有印出正確的行號
<ul>
<li>文中提到懷疑是Heap Coruption的理由是
<ul>
<li>崩潰是發生在存取非法位址</li>
<li>這個行號所在的程式碼單純到沒辦法找到造成問題的部分在哪</li>
</ul>
</li>
<li>可以猜猜看why
<ul>
<li>亂序執行
<ul>
<li>concurrent，但明顯不是</li>
</ul>
</li>
<li>之前在不對的地方沒有停下來
<ul>
<li>可以試試把array超過length的地方print出來: print的出來!!</li>
<li>如果這是迴圈中出事就還好，但如果出了loop…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二次dump用了大招，上heap保護
<ul>
<li>這與xv6的stack的guard page一樣，出錯直接panic</li>
<li>這樣就可以直接看到對的地方，index出界，在8爆了
<ol>
<li>不是在5爆?
<ul>
<li>為了好分配mem，所以會對齊</li>
</ul>
</li>
<li>回頭來看c的type到底是什麼?
<ul>
<li>一次要跳幾格
<ul>
<li>char是1</li>
<li>uint64是8</li>
<li>etc</li>
</ul>
</li>
<li>所以c其實就是一直幫忙算這個addr一次跳幾格
<ul>
<li>出事由下面的cpu噴</li>
<li>linux有辦法這樣做嗎?
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzg4ODY5ODg=">定位Memory Corruption的思路<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="ch6-3">ch6</h2>
<p>當我們說鎖保護數據時，我們真正的意思是鎖保護了一些適用於數據的不變式(invariant）集合</p>
<p>你可以把鎖看成是把並發的臨界區串行化(serializing)的一種工具，使它們同時只運行一個，從而保護 invariant（假設臨界區是獨立的）。</p>
<p>正確地使用鎖可以保證一次只能有一個 CPU 對關鍵部分的數據結構進行操作，所以當數據結構的 invariant 不成立時，沒有 CPU 會執行數據結構操作</p>
<p>如果一個穿過內核的代碼路徑必須同時持有多個鎖，那麼所有的代碼路徑以相同的順序獲取這些鎖是很重要的<br>
* 有時鎖的身份並不是事先知道的，也許是因為必須持有一個鎖才能發現接下來要獲取的鎖的身份</p>
<p>CPU 的 ordering 規則稱為內存模型!!<br>
(目前看過最精練的解釋)</p>
<h3 id="自旋锁">自旋锁</h3>
<ol>
<li>關中斷</li>
<li>atomic cas while looping =&gt; lock</li>
<li>mem barrier =&gt; mem barrier</li>
</ol>
<p>一個中斷處理程序使用了自旋鎖，CPU 決不能在啟用中斷的情況下持有該鎖。<br>
Xv6 比較保守：當一個 CPU 獲取任何鎖時，xv6 總是禁用該 CPU 上的中斷。</p>
<p>xv6 在 CPU 沒有持有自旋鎖時重新啟用中斷；它必須做一點記錄來應對嵌套的臨界區。</p>
<p>這個spinlock可以recursive!!<br>
因為有紀錄cpu id所以可以處理這一段</p>
<h4 id="trace-spinlock">trace: spinlock</h4>
<p>我們把debug有關的部分skip掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>acquire對數字做test_and_set，不成功就一直轉</p>
<ul>
<li>這裡要用riscv提供的指令去換，不然被reorder就出事了</li>
<li>因為原本有設定cpuid的部分，導致還需要memory barrier
<ul>
<li>但這裡就先跳掉</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">acquire</span><span class="params">(struct spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  push_off();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>release就是acquire反著做</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">release</span><span class="params">(struct spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="睡眠锁">睡眠锁</h3>
<p>擴展自旋锁，多了sleep</p>
<ol>
<li>上spinlock</li>
<li>直到拿到鎖之前，一直sleep
<ul>
<li>處理虛假喚醒</li>
</ul>
</li>
</ol>
<p>這裡是把sleep多傳一個lock，保證sleep後lock會被釋放<br>
pthread也是，但是叫condition var</p>
<h4 id="trace-sleeplock">trace: sleeplock</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span> <span class="comment">// spinlock protecting this sleep lock</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>acquire與release其實很簡單，用spinlock保護locked<br>
如果只有保護locked能用atomic?</p>
<p>答案是不行，因為還要保護成功sleep</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">acquiresleep</span><span class="params">(struct sleeplock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">releasesleep</span><span class="params">(struct sleeplock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>為了可以在有lock當狀態下sleep，變成sleep要解上面lock，之後再鎖自己的lock<br>
可以看到這邊lock涵蓋的範圍有overlay</p>
<p>如果有用過pthread的cond var就會看到一樣的東西!!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">(<span class="keyword">void</span> *chan, struct spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用什麼鎖">用什麼鎖</h3>
<p>因為睡眠鎖會使中斷處於啟用狀態，所以不能在中斷處理程序中使用睡眠鎖</p>
<p>自旋鎖最適合短的臨界區，因為等待它們會浪費 CPU 時間<br>
睡眠鎖對長時間的操作很有效</p>
<h3 id="Lab-Lock">Lab Lock</h3>
<h4 id="Memory-allocator">Memory allocator</h4>
<p>把freelist放到各個cpu中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以kalloc要從自己的list中找，如果沒有就去偷<br>
kfree就直接塞回自己的list</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> i = cpuid();</span><br><span class="line">  acquire(&amp;cpus[i].lock);</span><br><span class="line">  <span class="keyword">if</span> (!cpus[i].freelist) &#123;</span><br><span class="line">    r = steal_page(i);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r = cpus[i].freelist;</span><br><span class="line">    cpus[i].freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;cpus[i].lock);</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">int</span> i = cpuid();</span><br><span class="line">  acquire(&amp;cpus[i].lock);</span><br><span class="line">  r-&gt;next = cpus[i].freelist;</span><br><span class="line">  cpus[i].freelist = r;</span><br><span class="line">  release(&amp;cpus[i].lock);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偷就是走訪其他cpu看有沒有free的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">steal_page</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// interrupt should be disabled</span></span><br><span class="line">  <span class="keyword">void</span> *ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=((i+<span class="number">1</span>)%NCPU); !ret &amp;&amp; j!=i; j=((j+<span class="number">1</span>)%NCPU)) &#123;</span><br><span class="line">    acquire(&amp;cpus[j].lock);</span><br><span class="line">    <span class="keyword">if</span> (cpus[j].freelist) &#123;</span><br><span class="line">      ret = cpus[j].freelist;</span><br><span class="line">      cpus[j].freelist = cpus[j].freelist-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;cpus[j].lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Buffer-cache">Buffer cache</h4>
<p>其實可以用前面的想法，把list打散</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TBL_SIZE 7</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> <span class="title">tbl</span>[<span class="title">TBL_SIZE</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_buf</span><span class="params">(struct buf* head, struct buf* b)</span> </span>&#123;</span><br><span class="line">  b-&gt;next = head-&gt;next, b-&gt;prev = head;</span><br><span class="line">  head-&gt;next-&gt;prev = b, head-&gt;next = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿不到就去偷</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">bget(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="comment">//acquire(&amp;bcache.lock);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">int</span> i = tbl_index(dev, blockno);</span><br><span class="line">  acquire(&amp;tbl[i].lock);</span><br><span class="line">  <span class="comment">// check cache</span></span><br><span class="line">  <span class="keyword">for</span>(b = tbl[i].head.next; b != &amp;tbl[i].head; b = b-&gt;next)</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">        b-&gt;refcnt++;</span><br><span class="line">        release(&amp;tbl[i].lock);</span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// steal free buf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=i, cnt=<span class="number">0</span>;cnt &lt; TBL_SIZE;j=((j+<span class="number">1</span>)%TBL_SIZE),cnt++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != j)</span><br><span class="line">      acquire(&amp;tbl[j].lock);</span><br><span class="line">    <span class="keyword">for</span>(b = tbl[j].head.next; b != &amp;tbl[j].head; b = b-&gt;next)&#123;</span><br><span class="line">      <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>)&#123;</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">        b-&gt;tbl_index = i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span> =</span> b-&gt;prev, *next = b-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">          prev-&gt;next = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          tbl[j].head.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">          next-&gt;prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        insert_buf(&amp;tbl[i].head, b);</span><br><span class="line">        <span class="keyword">if</span> (i != j)</span><br><span class="line">          release(&amp;tbl[j].lock);</span><br><span class="line">        release(&amp;tbl[i].lock);</span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != j)</span><br><span class="line">      release(&amp;tbl[j].lock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tbl[i].lock);</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的就是把bcache改成用到對的list</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tbl_index;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="ch7-3">ch7</h2>
<p>xv6 的sleep 和 wakeup 機制會進行切換<br>
這會發生在進程等待設備或管道 I/O<br>
等待子進程退出<br>
在 sleep 系統調用中等待</p>
<p>xv6 週期性地強制切換，以應對長時間的計算進程。</p>
<p>首先，如何從一個進程切換到另一個進程？<br>
第二，如何對用戶進程透明的強制切換？ (用定時器中斷來驅動上下文切換)<br>
第三，許多 CPU 可能會在進程間並發切換，需要設計一個鎖來避免競爭。<br>
第四，當進程退出時，必須釋放進程的內存和其他資源，但它自己不能做到這一切，因為它不能釋放自己的內核棧，同時又在使用內核棧。<br>
第五，多核機器的每個內核必須記住它正在執行的進程，這樣系統調用就會修改相應進程的內核狀態。<br>
最後，sleep 和 wakeup 允許一個進程放棄 CPU，並睡眠等待事件，並允許另一個進程喚醒第一個進程。</p>
<p>需要注意一些競爭可能會使喚醒丟失!!</p>
<h3 id="coperative-thread-sleep-wakeup-ctx-switch-scheduler">coperative thread: sleep, wakeup, ctx switch, scheduler</h3>
<p><img src="https://i.imgur.com/RcwxOmm.png" alt=""></p>
<h4 id="ctx-switch">ctx switch</h4>
<p>xv6 調度器在每個 CPU 上有一個專門的線程(保存的寄存器和棧)，因為調度器在舊進程的內核棧上執行是不安全的</p>
<p>棧指針和 pc 被保存和恢復，意味著 CPU 將切換棧和正在執行的代碼</p>
<p>Swtch(kernel/swtch.S:3)只保存 callee-saved 寄存器，caller-saved 寄存器由調用的 C<br>
代碼保存在堆棧上(如果需要)</p>
<p><img src="https://i.imgur.com/pczpVz4.png" alt=""></p>
<p>它不保存 pc。<br>
當swtch 返回時，它返回到被恢復的 ra 寄存器所指向的指令，也就是新線程之前調用 swtch的指令。<br>
此外，它還會在新線程的棧上返回。</p>
<h4 id="scheduler">scheduler</h4>
<p>其實就是在沒有process在跑的時候選一個跑</p>
<ol>
<li>main會call，scheduler</li>
<li>之後scheduler挑一個proc (RR)</li>
<li>ctx switch
<ul>
<li>到ctx switch時還沒release lock!!
<ul>
<li>對於上下文切換來說，有必要打破這個約定，因為 p-&gt;lock 保護了進程的狀態和 context 字段上的不變式(invariant)，而這些不變式在 swtch 中執行時為 false。</li>
</ul>
</li>
<li>都是與mycpu換ctx!!
<ul>
<li>所以可以看成mycpu()-&gt;context就是正在跑的cpu的state，也是proc的state(不是RUNNABLE之類的，是執行的狀態)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="p-lock">p-&gt;lock??</h5>
<p>可以這樣理解調度代碼結構，它執行一組關於進程的不變式，並且每當這些不變式為False 時，就持有 p-&gt;lock。</p>
<p>一個不變式是，</p>
<ul>
<li>如果一個進程正在運行，定時器中斷的 yield 必須能夠安全地切換進程；
<ul>
<li>這意味著 CPU 寄存器必須持有進程的寄存器值（即 swtch 沒有將它們移到上下文中）</li>
<li>並且 c-&gt;proc 必須指向該進程。<br>
另一個不變式是，</li>
</ul>
</li>
<li>如果一個進程是RUNNABLE 的，那麼對於一個空閒的 CPU 調度器來說，運行它必須是安全的
<ul>
<li>這意味著
<ul>
<li>（1）p-&gt;context 必須擁有進程的寄存器（i.e., 它們實際上並不在真實的寄存器中）</li>
<li>（2）沒有 CPU 在進程的內核棧上執行</li>
<li>（3）也沒有 CPU 的 c-&gt;proc 指向進程
<ul>
<li>請注意，當 p-&gt;lock被持有時，這些屬性往往不為真。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>維護上述不變式的原因：xv6 經常在一個線程中獲取 p-&gt;lock，然後在另一個線程中釋放</p>
<p>直到成功轉移state之前都要hold lock</p>
<h5 id="mycpu-and-myproc">mycpu and myproc</h5>
<p>Xv6 為每個 CPU 維護了一個 cpu 結構體(kernel/proc.h:22)，它記錄了當前在該 CPU 上<br>
運行的進程(如果有的話)，為 CPU 的調度線程保存的寄存器，以及管理中斷禁用所需的嵌套<br>
自旋鎖的計數。</p>
<p>Xv6 確保每個 CPU 的 hartid 在內核中被存儲在該 CPU 的 tp 寄存器中</p>
<p>Usertrapret 將 tp 寄存器保存在 trampoline 頁中，因為用戶進程可能會修改 tp 寄存器</p>
<p>當從用戶空間進入內核時，uservec 會恢復保存的 tp(kernel/trampoline.S:70)。編譯器保證永遠不使用 tp 寄存器。</p>
<p>如果 RISC-V 允許 xv6 直接讀取當前的 hartid 會更方便</p>
<p>cpuid 和 mycpu 的返回值很容易錯：<br>
如果定時器中斷，導致線程讓出 CPU，然後轉移到不同的 CPU 上，之前返回的值將不再正確。<br>
為了避免這個問題，xv6 要求調用者禁用中斷，只有在使用完返回的 cpu 結構後才啟用中斷</p>
<p>myproc(kernel/proc.c:68)函數返回當前 CPU 上運行的進程的 proc 指針。<br>
myproc 禁用中斷，調用 mycpu，從 cpu 中獲取當前進程指針(c-&gt;proc)，然後啟用中斷。</p>
<p>myproc不用lock防嗎??<br>
當下指到的proc是對的</p>
<h4 id="Sleep">Sleep</h4>
<p>為了確保進入sleep前的state改變不會被打斷 (eg: semaphore的P)</p>
<p>sleep會先hold proc的lock，才去</p>
<ol>
<li>release 前一個lock</li>
<li>改proc狀態
<ul>
<li>p-&gt;chan = chan;</li>
<li>p-&gt;state = SLEEPING;</li>
</ul>
</li>
<li>sched</li>
</ol>
<p>這邊會看到一個有趣的事，與scheduler一樣，p-&gt;lock沒有release!!</p>
<h4 id="wakeup">wakeup</h4>
<p>把<strong>所有</strong>聽在同一個lock(semaphore)的proc的state設定成runnable</p>
<h5 id="虛假喚醒">虛假喚醒</h5>
<p>wakeup會把<strong>所有</strong>proc，叫醒，但<strong>只有一個</strong>proc可以拿到lock</p>
<p>所以對其他proc而言，這是虛假喚醒!!</p>
<h5 id="exit-wait">exit &amp; wait</h5>
<p>exit: 把file close，把proc設定成ZOMBIE，sched<br>
wait: 掃child proc，看有沒有ZOMBIE，有就設定成UNUSED；沒有就sleep</p>
<p>父進程和子進程的 wait 和 exit，以及 exit 和 exit 之間可能出現競爭和死鎖的情況</p>
<p>此 xv6 的所有鎖都必須遵守相同的鎖順序（父進程的鎖，然後是子進程的鎖），以避免死鎖</p>
<h3 id="preemptive-thread">preemptive thread</h3>
<p>time interrupt時做sched</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">    <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">        yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="trace-trapframe-context">trace: trapframe &amp; context</h3>
<p>看回來這張圖<br>
<img src="https://i.imgur.com/RcwxOmm.png" alt=""></p>
<p>sched都是在kernel mode發生，所以不用換pagetable</p>
<p>sched是換手，也就是我已經做了差不多了，所以會主動call函數，之後只要回來我這邊就好，<br>
但是換回來函數的執行環境(callee-save)會壞掉，所以要存；<br>
用於計算用的參數就，沒有用(做了差不多了，或是說已經存在stack上了(會call函數c會處理))，就不用管</p>
<p>trap是中斷，所以之後要在原本的地方跑(還沒做完)，因此要保留原本的pc，不然沒辦法接回去；<br>
同時要保留caller-save，trap可以看成call函數，但沒有c的幫忙，所以這要自己存；<br>
剩下是ctx switch，所以callee-save也要存</p>
<h3 id="trace-exit-wait">trace: exit &amp; wait</h3>
<ul>
<li>
<p>exit:</p>
<ul>
<li>把opend file關一關</li>
<li>把parent設定成init</li>
<li>把自己state設定成ZOMBIE</li>
</ul>
</li>
<li>
<p>wait</p>
<ul>
<li>掃過整個proc，找符合下面兩個條件的proc
<ul>
<li>parent是caller的proc</li>
<li>state是ZOMBIE</li>
</ul>
</li>
<li>找到就
<ul>
<li>acquire child的lock (wait!!)</li>
<li>拉proc的return值(xstate)</li>
<li>freeproc</li>
</ul>
</li>
<li>沒找到
<ol>
<li>state不是ZOMBIE
<ul>
<li>parent sleep</li>
</ul>
</li>
<li>沒有proc認caller做parent
<ul>
<li>報錯</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>這裡就可以回答一個經典問題，為什麼要有ZOMBIE?<br>
因為把proc回收分成</p>
<ol>
<li>關file: exit</li>
<li>free mem: wait</li>
</ol>
<p>而在wait可以拿到proc的return值(所以不能free mem)<br>
但我們需要一個方式表示proc準備好被回收，所以有ZOMBIE</p>
<p>但為什麼叫ZOMBIE?<br>
這我真的不懂，不能叫EXITED嗎?</p>
<h3 id="Lab-Multithreading">Lab Multithreading</h3>
<h4 id="ph">ph</h4>
<p>練手用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> table_locks[NBUCKET];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value, struct entry **p, struct entry *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_lock(table_locks+i);</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(table_locks+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="barrier-2">barrier</h4>
<p>這個就有趣了</p>
<p>一開始會想只要一個出去把counter設成0就好，但這樣while的部分就會出事，可能有人出不來</p>
<p>這樣我們挑最後一個去reset計數器，但這樣也會有問題，如果說最後一個一直被hang住，之後中間有跑比較快的進來，這樣就不是barrier</p>
<p>所以鎖要保護兩個條件</p>
<ol>
<li>進來時要確認上一輪的不在這裡了</li>
<li>人數到了就能release，最後一個要去reset計數器</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> no_one_here = <span class="number">1</span>, in_room = <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  <span class="keyword">while</span> (!no_one_here)</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line"></span><br><span class="line">  bstate.nthread++, in_room++;</span><br><span class="line">  <span class="keyword">while</span> (bstate.nthread != nthread)</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  <span class="keyword">if</span> (in_room-- == nthread)</span><br><span class="line">    no_one_here = <span class="number">0</span>, bstate.round++;</span><br><span class="line">  <span class="keyword">if</span> (in_room == <span class="number">0</span>)</span><br><span class="line">    no_one_here = <span class="number">1</span>, bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="uthread">uthread</h4>
<p>這題就去抄context與swtch就好</p>
<p>但重點是，</p>
<ol>
<li>要怎麼到thread的function去?</li>
</ol>
<p>trap是改pc，因為我們不會再回來trap中<br>
但thread可以多次來回，所以需要一個自動回到對的位置的機制，ra</p>
<ol start="2">
<li>thread的記憶體要放在哪?<br>
回想當初init怎麼做，讓之後的c可以跑?<br>
從stack0放一個PGSIZE，指到sp</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_create</span><span class="params">(<span class="keyword">void</span> (*func)())</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  t-&gt;ctx.ra = (uint64)func; <span class="comment">// HERE</span></span><br><span class="line">  t-&gt;ctx.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ch8-3">ch8</h2>
<p><img src="https://i.imgur.com/clKOaC4.png" alt=""></p>
<ul>
<li>
<p>磁盤層在 virtio 磁盤上讀寫塊</p>
</li>
<li>
<p>緩存層(bio.c)緩存磁盤塊，並同步訪問它們，確保一個塊只能同時被內核中的一個進程訪問</p>
<ul>
<li>buffer 緩存是一個由 buffer 組成的雙端鍊錶</li>
<li>bget根據devid、sector找buffer</li>
<li>bread/bwrite讀寫buffer</li>
<li>brelse釋放sleep lock
<ul>
<li>bread拿鎖</li>
</ul>
</li>
</ul>
</li>
<li>
<p>日誌層(log.c)允許上層通過事務更新多個磁盤塊，並確保在崩潰時，磁盤塊是原子更新的（即全部更新或不更新）</p>
<ul>
<li>日誌由一個 header 塊組成，後面是一連串的更新塊副本（日誌塊）。
<ul>
<li>header 塊包含一個扇區號數組，
<ul>
<li>每個扇區號都對應一個日誌塊，header 還包含日誌塊的數量</li>
</ul>
</li>
</ul>
</li>
<li>日誌系統可以將多個系統調用的寫操作累積到一個事務中
<ul>
<li>一次提交可能涉及多個完整系統調用的寫入</li>
<li>為了避免一個系統調用被分裂到不同的事務中，只有在沒有文件系統相關的系統調用正在進行時，日誌系統才會提交</li>
</ul>
</li>
<li>Xv6 在磁盤上劃出固定的空間來存放日誌。在一個事務中，系統調用所寫的塊總數必須 適應這個空間的大小
<ul>
<li>系統調用寫入的日誌大小必須小於日誌空間的大小
<ul>
<li>Xv6 的 write 系統調用將大的寫操作分解成多個小的寫操作，以適應在日誌空間的大小</li>
<li>unlink 不會引起問題，因為 xv6 文件系統只使用一個位圖塊</li>
</ul>
</li>
<li>日誌系統只會在確定了系統調用的寫操作可以適應剩餘日誌空間之後，才會開始執行該系統調用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>inode 層(fs.c)將一個文件都表示為一個 inode，每個文件包含一個唯一的 i-number 和一些存放文件數據的塊</p>
<ul>
<li>balloc 申請一個新的磁盤塊: iterate bitmap</li>
<li>bfree 釋放一個塊: clear flag on block</li>
<li>磁盤上的inode
<ul>
<li>文件的大小和數據塊號的列表</li>
<li>磁盤上的 inode 被放置磁盤的一個連續區域
<ul>
<li>每一個 inode 的大小都是一樣的
<ul>
<li>所以，給定一個數字 n，很容易找到磁盤上的第 n 個 inode</li>
</ul>
</li>
<li>dinode定義了磁盤上的 inode
<ul>
<li>包含一個 size 和一個塊號數組</li>
<li><img src="https://i.imgur.com/sAWGPwO.png" alt="">
<ul>
<li>開始的 NDIRECT 個數據塊放置在數組中的前NDIRECT 個條目中，這些塊被稱為直接塊</li>
<li>接下來的 NINDIRECT 個數據塊並沒有放置在inode 中，而是被存放在叫做間接塊的數據塊中</li>
</ul>
</li>
<li>Bmap 返回 inode ip 的第 bn 個數據塊的磁盤塊號。如果 ip 沒有第 bn 個的數據塊，bmap 就會分配一個 (mmap!!)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>mem中的inode
<ul>
<li>了磁盤上 inode 的副本以及內核中需要的其他信息</li>
<li>結構體 inode (kernel/file.h:17)是磁盤 dinode 的拷貝
<ul>
<li>ref 字段為指向 inode 的指針的數量，如果引用數量減少到零，內核就會從內存中丟棄這個 inode</li>
<li>iget 和 iput 函數引用和釋放 inode，並修改引用計數</li>
<li>四種鎖
<ul>
<li>icache.lock 保證了一個 inode 在緩 存只有一個副本，以及緩存 inode 的 ref 字段計數正確</li>
<li>每個內存中的 inode 都有一個包含 sleep-lock 的鎖字段，它保證了可以獨占訪問 inode 的其他字段（如文件長度）以及 inode 的文件或目錄內容塊的</li>
<li>一個 inode 的 ref 如果大於 0，則會使系統將該 inode 保留在緩存 中，而不會重用該 inode</li>
<li>每個 inode 都包含一個 nlink 字段(在磁盤上，緩存時會復 製到內存中)，該字段統計鏈接該 inode 的目錄項的數量；如果一個 inode 的鏈接數大於零， xv6 不會釋放它</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>目錄層(fs.c)將實現了一種特殊的 inode，被稱為目錄，其包含一個目錄項序列，每個目錄項由文件名稱和 i-number 組成</p>
<ul>
<li>函數 dirlookup 在一個目錄中搜索一個帶有給定名稱的條目</li>
<li>函數 dirlink 會在當前目錄 dp 中創建一個新的目錄項</li>
<li>查找路徑名會對每一個節點調用一次 dirlookup</li>
<li>Namex首先確定路徑解析從哪裡開始
<ul>
<li>如果路徑以斜線開頭，則從根目錄開始解析</li>
<li>否則，從當前目錄開始解析。</li>
</ul>
</li>
<li>然後它使用 skipelem 來遍歷路徑中的每個元素</li>
</ul>
</li>
<li>
<p>file(file.c)</p>
<ul>
<li>系統中所有打開的文件都保存在一個全局文件表中，即 ftable
<ul>
<li>文件表的功能有:
<ul>
<li>分配文件(filealloc)</li>
<li>創建重複引用(fileup)</li>
<li>釋放引用(fileclose)</li>
<li>讀寫數據(fileeread和filewrite)。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/nok1IuY.png" alt=""></p>
<p>superblock，<br>
它包含了文件系統的元數據（以塊為單位的文件系統大小、數據塊的數量、inode 的數量和日誌中的塊數）</p>
<p>位圖塊(bitmap)，記錄哪些數據塊在使用</p>
<h3 id="balloc與kalloc與malloc的差別">balloc與kalloc與malloc的差別</h3>
<p>kalloc: 直接丟一個page<br>
malloc: 從現有的mem拉一段va出來，如果沒空間了就sbrk加大<br>
* sbrk: growproc -&gt; uvmalloc -&gt; kalloc -&gt; mappages<br>
* mappages: 把從kalloc拿到的page與加到pagetable<br>
balloc: 與kalloc很像，就是直接丟一個block出來<br>
* 但要處理log!!<br>
* 去trace誰是空的<br>
* mem用list(或AVL)<br>
* disk用bitmap</p>
<h3 id="trace-how-to-read-write-a-file">trace: how to read/write a file</h3>
<ul>
<li>fileread
<ul>
<li>readi
<ul>
<li>bread拿buf，bmap算偏移(在hdd上的addr)</li>
<li>copyout</li>
</ul>
</li>
</ul>
</li>
<li>filewrite
<ul>
<li>begin_op
<ul>
<li>writei
<ul>
<li>bread拿buf，bmap算偏移(在hdd上的addr)</li>
<li>copyin</li>
<li>log_write
<ul>
<li>記錄到log</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>end_op
<ul>
<li>commit
<ul>
<li>write_log
<ul>
<li>寫buf到disk</li>
</ul>
</li>
<li>write_head
<ul>
<li>commit log</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Lab-File-system">Lab File system</h3>
<h4 id="big-file">big file</h4>
<p>就是在block再放一個table，之後再多做一次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint</span></span><br><span class="line"><span class="function"><span class="title">bmap</span><span class="params">(struct inode *ip, uint bn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bn &lt; BLOCKS) &#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">	@@ <span class="number">-400</span>,<span class="number">6</span> +<span class="number">401</span>,<span class="number">30</span> @@ bmap(struct inode *ip, uint bn)</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= BLOCKS;</span><br><span class="line">  <span class="keyword">if</span> (bn &lt; NINDIRECT) &#123; </span><br><span class="line">    <span class="comment">// double indirect</span></span><br><span class="line">    <span class="keyword">int</span> i = bn/BLOCKS, j = bn%BLOCKS;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[i] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// query addr from int[]&#x27;s data</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[j] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">itrunc</span><span class="params">(struct inode *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; BLOCKS; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint *b;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp2</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)(bp-&gt;data); <span class="comment">// int[]</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BLOCKS; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">        bp2 = bread(ip-&gt;dev, a[i]);</span><br><span class="line">        b = (uint*)(bp2-&gt;data);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BLOCKS; j++)</span><br><span class="line">          <span class="keyword">if</span>(b[j])</span><br><span class="line">            bfree(ip-&gt;dev, b[j]);</span><br><span class="line">        brelse(bp2);</span><br><span class="line">        bfree(ip-&gt;dev, a[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="symbol-link">symbol link</h4>
<p>一個有path的檔案</p>
<p>syscall要先生出檔案，把path寫進去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_symlink</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, target, MAXPATH)) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  begin_op();</span><br><span class="line">  ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, r = <span class="number">0</span>, n1 = <span class="number">0</span>, off = <span class="number">0</span>;i &lt; n &amp;&amp; r == n1; i += r)&#123;</span><br><span class="line">    n1 = n - i;</span><br><span class="line">    <span class="keyword">if</span> ((r = writei(ip, <span class="number">0</span>, (uint64)target + i, off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">      off += r;</span><br><span class="line">  &#125;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open要能處理symbol link，與原本的檔案<br>
如果遇到其他symbol link還要繼續follow</p>
<p>抄原本的open，加symbol link的處理，最後遞迴</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">real_open</span><span class="params">(<span class="keyword">char</span> path[MAXPATH], <span class="keyword">int</span> omode, <span class="keyword">int</span> follow)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(omode &amp; O_NOFOLLOW)) &#123;</span><br><span class="line">      <span class="keyword">char</span> target[MAXPATH];</span><br><span class="line">      <span class="keyword">if</span> (follow &gt; FOLLOW_DEPS || readi(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> real_open(target, omode, follow+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line">  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_open</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> path[MAXPATH];</span><br><span class="line">  <span class="keyword">int</span> omode;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  begin_op();</span><br><span class="line">  uint64 ret = real_open(path, omode, <span class="number">0</span>);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ref-150">Ref</h2>
<p>可以在google找到很多其他人的做法，都值得參考</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL2NvbHVtbi9jXzEyOTQyODI5MTkwODc5NjQxNjA=">MIT6.S081 操作系统工程中文翻译<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BsZWFzZXdoeS94djYtYm9vay0yMDIwLUNoaW5lc2U=">xv6-book-2020-Chinese<i class="fa fa-external-link-alt"></i></span></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/craft-small-os/" rel="prev" title="電腦從0開始">
      <i class="fa fa-chevron-left"></i> 電腦從0開始
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/css-ctx/" rel="next" title="css的context">
      css的context <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8B%95%E6%A9%9F-667"><span class="nav-number">1.</span> <span class="nav-text">動機</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%9D%E7%92%B0%E5%A2%83"><span class="nav-number">2.</span> <span class="nav-text">裝環境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E9%BA%BC%E5%9C%A8lab%E4%BD%BF%E7%94%A8gdb"><span class="nav-number">3.</span> <span class="nav-text">怎麼在lab使用gdb</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95debug"><span class="nav-number">4.</span> <span class="nav-text">如何debug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ch1-3"><span class="nav-number">5.</span> <span class="nav-text">ch1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fd"><span class="nav-number">5.1.</span> <span class="nav-text">fd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipe-2"><span class="nav-number">5.2.</span> <span class="nav-text">pipe</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-pipe"><span class="nav-number">5.2.1.</span> <span class="nav-text">trace: pipe</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-Utilities"><span class="nav-number">5.3.</span> <span class="nav-text">Lab Utilities</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep"><span class="nav-number">5.3.1.</span> <span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pingpong"><span class="nav-number">5.3.2.</span> <span class="nav-text">pingpong</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find"><span class="nav-number">5.3.3.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xargs"><span class="nav-number">5.3.4.</span> <span class="nav-text">xargs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#primes"><span class="nav-number">5.3.5.</span> <span class="nav-text">primes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ch2-3"><span class="nav-number">6.</span> <span class="nav-text">ch2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Isolation-2"><span class="nav-number">6.1.</span> <span class="nav-text">Isolation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%B7%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.1.</span> <span class="nav-text">執行模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#process"><span class="nav-number">6.1.2.</span> <span class="nav-text">process</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#process%E7%9A%84mem-layout"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">process的mem layout</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-init"><span class="nav-number">6.2.</span> <span class="nav-text">trace: init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-syscall"><span class="nav-number">6.3.</span> <span class="nav-text">trace: syscall</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#user-mode%E7%9A%84syscall"><span class="nav-number">6.3.1.</span> <span class="nav-text">user mode的syscall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kernel-mode%E7%9A%84syscall"><span class="nav-number">6.3.2.</span> <span class="nav-text">kernel mode的syscall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#user%E7%9A%84%E5%8F%83%E6%95%B8%E6%80%8E%E9%BA%BCpass%E5%88%B0syscall%E7%9A%84"><span class="nav-number">6.3.3.</span> <span class="nav-text">user的參數怎麼pass到syscall的?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-System-calls"><span class="nav-number">6.4.</span> <span class="nav-text">Lab System calls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trace"><span class="nav-number">6.4.1.</span> <span class="nav-text">trace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sysinfo"><span class="nav-number">6.4.2.</span> <span class="nav-text">sysinfo</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ch4-5"><span class="nav-number">7.</span> <span class="nav-text">ch4&amp;5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#trap"><span class="nav-number">7.1.</span> <span class="nav-text">trap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RISC-V-trap-mechinism"><span class="nav-number">7.2.</span> <span class="nav-text">RISC-V trap mechinism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-trap-from-user-space"><span class="nav-number">7.3.</span> <span class="nav-text">trace: trap from user space</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-exec-syscall"><span class="nav-number">7.3.1.</span> <span class="nav-text">trace: exec syscall</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89pointer"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">如果有pointer?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trap-from-kernel-space"><span class="nav-number">7.4.</span> <span class="nav-text">trap from kernel space</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trap-from-device"><span class="nav-number">7.5.</span> <span class="nav-text">trap from device</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-Console-input"><span class="nav-number">7.5.1.</span> <span class="nav-text">trace: Console input</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-Console-output"><span class="nav-number">7.5.2.</span> <span class="nav-text">trace: Console output</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer-interrupts"><span class="nav-number">7.6.</span> <span class="nav-text">Timer interrupts</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#interrupt%E9%82%84%E6%98%AF%E8%A6%81%E8%99%95%E7%90%86concurent"><span class="nav-number">7.6.1.</span> <span class="nav-text">interrupt還是要處理concurent</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E7%AD%89%EF%BC%8C%E4%B8%80%E7%9B%B4%E7%99%BCtrap"><span class="nav-number">7.7.</span> <span class="nav-text">等等，一直發trap?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-Traps"><span class="nav-number">7.8.</span> <span class="nav-text">Lab Traps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#backtrace"><span class="nav-number">7.8.1.</span> <span class="nav-text">backtrace</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#fp-sp"><span class="nav-number">7.8.1.1.</span> <span class="nav-text">fp &amp; sp</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alarm"><span class="nav-number">7.8.2.</span> <span class="nav-text">alarm</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-network-driver"><span class="nav-number">7.9.</span> <span class="nav-text">Lab network driver</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#driver"><span class="nav-number">7.9.1.</span> <span class="nav-text">driver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#network-stack"><span class="nav-number">7.9.2.</span> <span class="nav-text">network stack</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#rx"><span class="nav-number">7.9.2.1.</span> <span class="nav-text">rx</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tx"><span class="nav-number">7.9.2.2.</span> <span class="nav-text">tx</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ch3-3"><span class="nav-number">8.</span> <span class="nav-text">ch3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kernel-mem-layout"><span class="nav-number">8.1.</span> <span class="nav-text">kernel mem layout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pagetable"><span class="nav-number">8.2.</span> <span class="nav-text">pagetable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95map-%E5%A6%82%E4%BD%95%E6%8A%8Ava%E6%8F%9B%E6%88%90pa"><span class="nav-number">8.3.</span> <span class="nav-text">如何map &amp; 如何把va換成pa</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-free-mem%E6%80%8E%E9%BA%BC%E7%94%A2%E7%94%9F%E7%9A%84"><span class="nav-number">8.4.</span> <span class="nav-text">trace: free mem怎麼產生的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8A%8Ava%E6%8F%9B%E6%88%90pa-walk"><span class="nav-number">8.4.1.</span> <span class="nav-text">如何把va換成pa: walk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95map-mappages"><span class="nav-number">8.4.2.</span> <span class="nav-text">如何map: mappages</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-%E6%80%8E%E9%BA%BC%E5%81%9Amem-alloc"><span class="nav-number">8.5.</span> <span class="nav-text">trace: 怎麼做mem alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-%E6%80%8E%E9%BA%BCfree-mem-pagetable"><span class="nav-number">8.6.</span> <span class="nav-text">trace: 怎麼free mem&#x2F;pagetable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-how-to-create-kernel-page-table"><span class="nav-number">8.6.1.</span> <span class="nav-text">trace: how to create kernel page table</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process-mem-layout"><span class="nav-number">8.7.</span> <span class="nav-text">process mem layout</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-sbrk"><span class="nav-number">8.7.1.</span> <span class="nav-text">trace: sbrk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-exec"><span class="nav-number">8.7.2.</span> <span class="nav-text">trace: exec</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Before-labs"><span class="nav-number">8.8.</span> <span class="nav-text">Before labs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-Page-tables"><span class="nav-number">8.9.</span> <span class="nav-text">Lab Page tables</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vmprint"><span class="nav-number">8.9.1.</span> <span class="nav-text">vmprint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-copyin-copyinstr"><span class="nav-number">8.9.2.</span> <span class="nav-text">new copyin, copyinstr</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-Lazy-allocation"><span class="nav-number">8.10.</span> <span class="nav-text">Lab Lazy allocation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-Copy-on-write"><span class="nav-number">8.11.</span> <span class="nav-text">Lab Copy on-write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-mmap"><span class="nav-number">8.12.</span> <span class="nav-text">Lab mmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-crash-tool"><span class="nav-number">8.13.</span> <span class="nav-text">Linux crash tool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9pte%E7%9A%84map"><span class="nav-number">8.13.1.</span> <span class="nav-text">改pte的map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9pa%E7%9A%84%E5%80%BC"><span class="nav-number">8.13.2.</span> <span class="nav-text">改pa的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%B5%90"><span class="nav-number">8.13.3.</span> <span class="nav-text">小結</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Heap-Coruption"><span class="nav-number">8.14.</span> <span class="nav-text">Heap Coruption</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ch6-3"><span class="nav-number">9.</span> <span class="nav-text">ch6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">9.1.</span> <span class="nav-text">自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-spinlock"><span class="nav-number">9.1.1.</span> <span class="nav-text">trace: spinlock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0%E9%94%81"><span class="nav-number">9.2.</span> <span class="nav-text">睡眠锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-sleeplock"><span class="nav-number">9.2.1.</span> <span class="nav-text">trace: sleeplock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BB%80%E9%BA%BC%E9%8E%96"><span class="nav-number">9.3.</span> <span class="nav-text">用什麼鎖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-Lock"><span class="nav-number">9.4.</span> <span class="nav-text">Lab Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Memory-allocator"><span class="nav-number">9.4.1.</span> <span class="nav-text">Memory allocator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer-cache"><span class="nav-number">9.4.2.</span> <span class="nav-text">Buffer cache</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ch7-3"><span class="nav-number">10.</span> <span class="nav-text">ch7</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#coperative-thread-sleep-wakeup-ctx-switch-scheduler"><span class="nav-number">10.1.</span> <span class="nav-text">coperative thread: sleep, wakeup, ctx switch, scheduler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ctx-switch"><span class="nav-number">10.1.1.</span> <span class="nav-text">ctx switch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scheduler"><span class="nav-number">10.1.2.</span> <span class="nav-text">scheduler</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#p-lock"><span class="nav-number">10.1.2.1.</span> <span class="nav-text">p-&gt;lock??</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mycpu-and-myproc"><span class="nav-number">10.1.2.2.</span> <span class="nav-text">mycpu and myproc</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sleep"><span class="nav-number">10.1.3.</span> <span class="nav-text">Sleep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wakeup"><span class="nav-number">10.1.4.</span> <span class="nav-text">wakeup</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9B%E5%81%87%E5%96%9A%E9%86%92"><span class="nav-number">10.1.4.1.</span> <span class="nav-text">虛假喚醒</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exit-wait"><span class="nav-number">10.1.4.2.</span> <span class="nav-text">exit &amp; wait</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#preemptive-thread"><span class="nav-number">10.2.</span> <span class="nav-text">preemptive thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-trapframe-context"><span class="nav-number">10.3.</span> <span class="nav-text">trace: trapframe &amp; context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-exit-wait"><span class="nav-number">10.4.</span> <span class="nav-text">trace: exit &amp; wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-Multithreading"><span class="nav-number">10.5.</span> <span class="nav-text">Lab Multithreading</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ph"><span class="nav-number">10.5.1.</span> <span class="nav-text">ph</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#barrier-2"><span class="nav-number">10.5.2.</span> <span class="nav-text">barrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uthread"><span class="nav-number">10.5.3.</span> <span class="nav-text">uthread</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ch8-3"><span class="nav-number">11.</span> <span class="nav-text">ch8</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#balloc%E8%88%87kalloc%E8%88%87malloc%E7%9A%84%E5%B7%AE%E5%88%A5"><span class="nav-number">11.1.</span> <span class="nav-text">balloc與kalloc與malloc的差別</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-how-to-read-write-a-file"><span class="nav-number">11.2.</span> <span class="nav-text">trace: how to read&#x2F;write a file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-File-system"><span class="nav-number">11.3.</span> <span class="nav-text">Lab File system</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#big-file"><span class="nav-number">11.3.1.</span> <span class="nav-text">big file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#symbol-link"><span class="nav-number">11.3.2.</span> <span class="nav-text">symbol link</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ref-150"><span class="nav-number">12.</span> <span class="nav-text">Ref</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhengcf</p>
  <div class="site-description" itemprop="description">想到什麼就寫什麼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">690</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">79</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhengcf</span>
</div>
  <div class="powered-by">Powered by <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly9tdXNlLnRoZW1lLW5leHQub3Jn">NexT.Muse</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 1000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://littlebees.github.io/2022/01/xv6-labs/',]
      });
      });
  </script>

</body>
</html>
