<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>little typer 前篇(1~7) 整理與筆記 | 記事本</title>
<meta name=keywords content="Lisp"><meta name=description content="介紹Pie怎麼用
ch1 & ch2 & ch3 所有東西都是expression 有人斷言expression有某種屬性或與其他expression有共通的特質是judgment Sentences get their meaning from those who understand them. The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them. 描述某一群expression的expression是Type 當type constructor在頂部就是type (Pair Nat Nat) constructor在頂部就是Value constructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體) eliminator會分解value取出構成value的資訊 當某一expression無法再被改寫時叫normal form 改寫expression叫evaluation expression因為有變數而無法繼續改寫叫neutral 只要長的一樣就是same (不是等於，之後會用same去證等於) total function對任何一個值都能產生對應的值 沒有遞迴 因為每個expression都一定要收斂 所以有其他東西來做類似的效果 evaluation & value 在dependent type中，evaluation得到的是expression 在一般PL(像lisp)中，evaluation得到的是value 在一般PL中，expression與value是不同類別的東西
ch4 & ch5 claim & define 在pie中要產生一個變數要先claim再define"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2020/05/little-typer-%E5%89%8D%E7%AF%871~7-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2020/05/little-typer-%E5%89%8D%E7%AF%871~7-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="little typer 前篇(1~7) 整理與筆記"><meta property="og:description" content="介紹Pie怎麼用
ch1 & ch2 & ch3 所有東西都是expression 有人斷言expression有某種屬性或與其他expression有共通的特質是judgment Sentences get their meaning from those who understand them. The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them. 描述某一群expression的expression是Type 當type constructor在頂部就是type (Pair Nat Nat) constructor在頂部就是Value constructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體) eliminator會分解value取出構成value的資訊 當某一expression無法再被改寫時叫normal form 改寫expression叫evaluation expression因為有變數而無法繼續改寫叫neutral 只要長的一樣就是same (不是等於，之後會用same去證等於) total function對任何一個值都能產生對應的值 沒有遞迴 因為每個expression都一定要收斂 所以有其他東西來做類似的效果 evaluation & value 在dependent type中，evaluation得到的是expression 在一般PL(像lisp)中，evaluation得到的是value 在一般PL中，expression與value是不同類別的東西
ch4 & ch5 claim & define 在pie中要產生一個變數要先claim再define"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2020/05/little-typer-%E5%89%8D%E7%AF%871~7-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-16T17:34:21+00:00"><meta property="article:modified_time" content="2020-05-16T17:34:21+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="little typer 前篇(1~7) 整理與筆記"><meta name=twitter:description content="介紹Pie怎麼用
ch1 & ch2 & ch3 所有東西都是expression 有人斷言expression有某種屬性或與其他expression有共通的特質是judgment Sentences get their meaning from those who understand them. The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them. 描述某一群expression的expression是Type 當type constructor在頂部就是type (Pair Nat Nat) constructor在頂部就是Value constructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體) eliminator會分解value取出構成value的資訊 當某一expression無法再被改寫時叫normal form 改寫expression叫evaluation expression因為有變數而無法繼續改寫叫neutral 只要長的一樣就是same (不是等於，之後會用same去證等於) total function對任何一個值都能產生對應的值 沒有遞迴 因為每個expression都一定要收斂 所以有其他東西來做類似的效果 evaluation & value 在dependent type中，evaluation得到的是expression 在一般PL(像lisp)中，evaluation得到的是value 在一般PL中，expression與value是不同類別的東西
ch4 & ch5 claim & define 在pie中要產生一個變數要先claim再define"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"little typer 前篇(1~7) 整理與筆記","item":"https://littlebees.github.io/2020/05/little-typer-%E5%89%8D%E7%AF%871~7-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"little typer 前篇(1~7) 整理與筆記","name":"little typer 前篇(1~7) 整理與筆記","description":"介紹Pie怎麼用\nch1 \u0026amp; ch2 \u0026amp; ch3 所有東西都是expression 有人斷言expression有某種屬性或與其他expression有共通的特質是judgment Sentences get their meaning from those who understand them. The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them. 描述某一群expression的expression是Type 當type constructor在頂部就是type (Pair Nat Nat) constructor在頂部就是Value constructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體) eliminator會分解value取出構成value的資訊 當某一expression無法再被改寫時叫normal form 改寫expression叫evaluation expression因為有變數而無法繼續改寫叫neutral 只要長的一樣就是same (不是等於，之後會用same去證等於) total function對任何一個值都能產生對應的值 沒有遞迴 因為每個expression都一定要收斂 所以有其他東西來做類似的效果 evaluation \u0026amp; value 在dependent type中，evaluation得到的是expression 在一般PL(像lisp)中，evaluation得到的是value 在一般PL中，expression與value是不同類別的東西\nch4 \u0026amp; ch5 claim \u0026amp; define 在pie中要產生一個變數要先claim再define","keywords":["Lisp"],"articleBody":"介紹Pie怎麼用\nch1 \u0026 ch2 \u0026 ch3 所有東西都是expression 有人斷言expression有某種屬性或與其他expression有共通的特質是judgment Sentences get their meaning from those who understand them. The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them. 描述某一群expression的expression是Type 當type constructor在頂部就是type (Pair Nat Nat) constructor在頂部就是Value constructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體) eliminator會分解value取出構成value的資訊 當某一expression無法再被改寫時叫normal form 改寫expression叫evaluation expression因為有變數而無法繼續改寫叫neutral 只要長的一樣就是same (不是等於，之後會用same去證等於) total function對任何一個值都能產生對應的值 沒有遞迴 因為每個expression都一定要收斂 所以有其他東西來做類似的效果 evaluation \u0026 value 在dependent type中，evaluation得到的是expression 在一般PL(像lisp)中，evaluation得到的是value 在一般PL中，expression與value是不同類別的東西\nch4 \u0026 ch5 claim \u0026 define 在pie中要產生一個變數要先claim再define\n(claim one Nat) (define one (add1 0)) 函數的部分用(-\u003e arg1 arg2 ... ret)宣告 函數或是需要type作為參數用(Pi ((arg1 type1) (arg2 type2) ...)) ...)宣告\nlen ;; 原本 (define (len l) (if (null? l) 0 (add1 (len (cdr l))))) ;; now (claim len (Pi ((T U)) ;; U是Universe，意指所有的type(但不包含自己) (-\u003e (List T) Nat))) (define len (λ (T l) ;; Pie的lambda會自己curry (rec-List l 0 (λ (car_L cdr_L ret) ;; rec-{type}會把做遞迴的參數分解，以及把ret塞回來，可以想成backtrace的部分 (add1 ret))))) 還有其他老朋友，但就先跳過\nch6 \u0026 ch7 vector與list很像，但有長度在type中\nfirst (claim first (Pi ((T U) (n Nat)) (-\u003e (Vec T n) T))) (define first (λ (T n v) (head v))) 這個傳空的就會出事\n可以改宣告，限制只吃只少有一個的vec\n(claim first (Pi ((T U) (n Nat)) (-\u003e (Vec T (add1 n)) T))) (define first (λ (T n v) (head v))) last 原本rec-List或rec-Nat都是回傳type不變的值，但現在vec有長度，所以會變!!\n對此我們要ind-Nat，意思是對整數做歸納法 ind-Nat多了一個東西是motive，函數，會吃一個正在做歸納法的值，回傳應該有的type\n而motive也於ind-Nat其他部位有關係\n(claim last (Pi ((T U) (n Nat)) (-\u003e (Vec T (add1 n)) T))) (define last (λ (T n v) (ind-Nat n (λ (x) (-\u003e (Vec T (add1 x)) T)) (λ (v1) (head v1)) (λ (n-1 ret) ;; 有沒有覺得與rec-Nat有點像 (λ (v) (ret (tail v))))))) (claim last-motive (-\u003e U Nat U)) (define last-motive (λ (T) (λ (n) (-\u003e (Vec T (add1 x)) T)))) ;; 把last的Pi的參數拿掉剩下就是我們要的 (claim last-base (Pi ((T U)) (last-motive T 1))) ;; 原本應該是0，但已經限制要大於1 (claim last-step (Pi ((T U) (n Nat)) (-\u003e (last-motive T n) ;; 吃舊的值(n-1,或是叫他回傳值) (last-motive T (add1 n))))) ;; 丟新的值 (define last-base (λ (T v) (head v))) (define last-step (λ (T) (λ (n-1 ret) (λ (v) (ret (tail v)))))) (define last (λ (T v) (ind-Nat v (last-motive T) (last-base T) (last-step T)))) 到這裡基本的Pie已經說完了，剛剛last有寫兩個版本，重要的是理解ind-Nat的motive與motive是怎麼與其他ind-Nat的部位有關係的\n","wordCount":"314","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2020-05-16T17:34:21Z","dateModified":"2020-05-16T17:34:21Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2020/05/little-typer-%E5%89%8D%E7%AF%871~7-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">little typer 前篇(1~7) 整理與筆記</h1><div class=post-meta><span title='2020-05-16 17:34:21 +0000 UTC'>May 16, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#ch1--ch2--ch3 aria-label="ch1 & ch2 & ch3">ch1 & ch2 & ch3</a><ul><li><a href=#evaluation--value aria-label="evaluation & value">evaluation & value</a></li></ul></li><li><a href=#ch4--ch5 aria-label="ch4 & ch5">ch4 & ch5</a><ul><li><a href=#claim--define aria-label="claim & define">claim & define</a></li><li><a href=#len aria-label=len>len</a></li></ul></li><li><a href=#ch6--ch7 aria-label="ch6 & ch7">ch6 & ch7</a><ul><li><a href=#first aria-label=first>first</a></li><li><a href=#last aria-label=last>last</a></li></ul></li></ul></div></details></div><div class=post-content><p>介紹Pie怎麼用</p><h2 id=ch1--ch2--ch3>ch1 & ch2 & ch3<a hidden class=anchor aria-hidden=true href=#ch1--ch2--ch3>#</a></h2><ul><li>所有東西都是<em>expression</em><ul><li>有人斷言expression有某種屬性或與其他expression有共通的特質是<em>judgment</em><ul><li>Sentences get their meaning from those who understand them.</li><li>The sentences capture thoughts that we have, and thoughts are more important than the words we use to express them.</li></ul></li><li>描述某一群expression的expression是<em>Type</em><ul><li>當type constructor在頂部就是type (Pair Nat Nat)</li></ul></li><li>constructor在頂部就是<em>Value</em><ul><li><em>constructor</em>會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體)</li><li><em>eliminator</em>會分解value取出構成value的資訊</li></ul></li><li>當某一expression無法再被改寫時叫<em>normal form</em><ul><li>改寫expression叫<em>evaluation</em></li></ul></li><li>expression因為有變數而無法繼續改寫叫<em>neutral</em></li></ul></li><li>只要長的一樣就是<em>same</em> (不是等於，之後會用same去證等於)</li><li><em>total function</em>對任何一個值都能產生對應的值</li><li><strong>沒有遞迴</strong><ul><li>因為每個expression都一定要收斂</li><li>所以有其他東西來做類似的效果</li></ul></li></ul><h3 id=evaluation--value>evaluation & value<a hidden class=anchor aria-hidden=true href=#evaluation--value>#</a></h3><p>在dependent type中，evaluation得到的是expression
在一般PL(像lisp)中，evaluation得到的是value
在一般PL中，expression與value是不同類別的東西</p><p><img loading=lazy src=https://i.imgur.com/Dy6c2TF.png alt></p><h2 id=ch4--ch5>ch4 & ch5<a hidden class=anchor aria-hidden=true href=#ch4--ch5>#</a></h2><h3 id=claim--define>claim & define<a hidden class=anchor aria-hidden=true href=#claim--define>#</a></h3><p>在pie中要產生一個變數要先claim再define</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=p>(</span><span class=nv>claim</span> <span class=nv>one</span>
</span></span><span class=line><span class=cl>    <span class=nv>Nat</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nv>one</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>add1</span> <span class=mi>0</span><span class=p>))</span>
</span></span></code></pre></div><p>函數的部分用<code>(-> arg1 arg2 ... ret)</code>宣告
函數或是需要type作為參數用<code>(Pi ((arg1 type1) (arg2 type2) ...)) ...)</code>宣告</p><h3 id=len>len<a hidden class=anchor aria-hidden=true href=#len>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=c1>;; 原本</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=p>(</span><span class=nv>len</span> <span class=nv>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nv>null?</span> <span class=nv>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=mi>0</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>add1</span> <span class=p>(</span><span class=nv>len</span> <span class=p>(</span><span class=nf>cdr</span> <span class=nv>l</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; now</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>claim</span> <span class=nv>len</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>Pi</span> <span class=p>((</span><span class=no>T</span> <span class=nv>U</span><span class=p>))</span> <span class=c1>;; U是Universe，意指所有的type(但不包含自己)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>-&gt;</span> <span class=p>(</span><span class=nv>List</span> <span class=no>T</span><span class=p>)</span> <span class=nv>Nat</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nv>len</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=no>T</span> <span class=nv>l</span><span class=p>)</span> <span class=c1>;; Pie的lambda會自己curry</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>rec-List</span> <span class=nv>l</span>
</span></span><span class=line><span class=cl>      <span class=mi>0</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=nv>car_L</span> <span class=nv>cdr_L</span> <span class=nv>ret</span><span class=p>)</span> <span class=c1>;; rec-{type}會把做遞迴的參數分解，以及把ret塞回來，可以想成backtrace的部分</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nv>add1</span> <span class=nv>ret</span><span class=p>)))))</span>
</span></span></code></pre></div><p>還有其他老朋友，但就先跳過</p><h2 id=ch6--ch7>ch6 & ch7<a hidden class=anchor aria-hidden=true href=#ch6--ch7>#</a></h2><p>vector與list很像，但有長度在type中</p><h3 id=first>first<a hidden class=anchor aria-hidden=true href=#first>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=p>(</span><span class=nv>claim</span> <span class=nf>first</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>Pi</span> <span class=p>((</span><span class=no>T</span> <span class=nv>U</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nv>n</span> <span class=nv>Nat</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>-&gt;</span> <span class=p>(</span><span class=nv>Vec</span> <span class=no>T</span> <span class=nv>n</span><span class=p>)</span> <span class=no>T</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nf>first</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=no>T</span> <span class=nv>n</span> <span class=nv>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>head</span> <span class=nv>v</span><span class=p>)))</span>
</span></span></code></pre></div><p>這個傳空的就會出事</p><p>可以改宣告，限制只吃只少有一個的vec</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=p>(</span><span class=nv>claim</span> <span class=nf>first</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>Pi</span> <span class=p>((</span><span class=no>T</span> <span class=nv>U</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nv>n</span> <span class=nv>Nat</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>-&gt;</span> <span class=p>(</span><span class=nv>Vec</span> <span class=no>T</span> <span class=p>(</span><span class=nv>add1</span> <span class=nv>n</span><span class=p>))</span> <span class=no>T</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nf>first</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=no>T</span> <span class=nv>n</span> <span class=nv>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>head</span> <span class=nv>v</span><span class=p>)))</span>
</span></span></code></pre></div><h3 id=last>last<a hidden class=anchor aria-hidden=true href=#last>#</a></h3><p>原本rec-List或rec-Nat都是回傳type<em>不變</em>的值，但現在vec有長度，所以會變!!</p><p>對此我們要ind-Nat，意思是對整數做歸納法
ind-Nat多了一個東西是motive，函數，會吃一個正在做歸納法的值，回傳應該有的type</p><p>而motive也於ind-Nat其他部位有關係</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=p>(</span><span class=nv>claim</span> <span class=nf>last</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>Pi</span> <span class=p>((</span><span class=no>T</span> <span class=nv>U</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nv>n</span> <span class=nv>Nat</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>-&gt;</span> <span class=p>(</span><span class=nv>Vec</span> <span class=no>T</span> <span class=p>(</span><span class=nv>add1</span> <span class=nv>n</span><span class=p>))</span> <span class=no>T</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nf>last</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=no>T</span> <span class=nv>n</span> <span class=nv>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>ind-Nat</span> <span class=nv>n</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nv>-&gt;</span> <span class=p>(</span><span class=nv>Vec</span> <span class=no>T</span> <span class=p>(</span><span class=nv>add1</span> <span class=nv>x</span><span class=p>))</span> <span class=no>T</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=nv>v1</span><span class=p>)</span> <span class=p>(</span><span class=nv>head</span> <span class=nv>v1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=nv>n-1</span> <span class=nv>ret</span><span class=p>)</span> <span class=c1>;; 有沒有覺得與rec-Nat有點像</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=nv>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nv>ret</span> <span class=p>(</span><span class=nv>tail</span> <span class=nv>v</span><span class=p>)))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>claim</span> <span class=nv>last-motive</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>-&gt;</span> <span class=nv>U</span> <span class=nv>Nat</span> <span class=nv>U</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nv>last-motive</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=no>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=nv>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>-&gt;</span> <span class=p>(</span><span class=nv>Vec</span> <span class=no>T</span> <span class=p>(</span><span class=nv>add1</span> <span class=nv>x</span><span class=p>))</span> <span class=no>T</span><span class=p>))))</span> <span class=c1>;; 把last的Pi的參數拿掉剩下就是我們要的</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>claim</span> <span class=nv>last-base</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>Pi</span> <span class=p>((</span><span class=no>T</span> <span class=nv>U</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>last-motive</span> <span class=no>T</span> <span class=mi>1</span><span class=p>)))</span> <span class=c1>;; 原本應該是0，但已經限制要大於1</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>claim</span> <span class=nv>last-step</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>Pi</span> <span class=p>((</span><span class=no>T</span> <span class=nv>U</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nv>n</span> <span class=nv>Nat</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>-&gt;</span> <span class=p>(</span><span class=nv>last-motive</span> <span class=no>T</span> <span class=nv>n</span><span class=p>)</span> <span class=c1>;; 吃舊的值(n-1,或是叫他回傳值)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nv>last-motive</span> <span class=no>T</span> <span class=p>(</span><span class=nv>add1</span> <span class=nv>n</span><span class=p>)))))</span> <span class=c1>;; 丟新的值</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nv>last-base</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=no>T</span> <span class=nv>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>head</span> <span class=nv>v</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nv>last-step</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=no>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=nv>n-1</span> <span class=nv>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=nv>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nv>ret</span> <span class=p>(</span><span class=nv>tail</span> <span class=nv>v</span><span class=p>))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>define</span> <span class=nf>last</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>λ</span> <span class=p>(</span><span class=no>T</span> <span class=nv>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>ind-Nat</span> <span class=nv>v</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>last-motive</span> <span class=no>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>last-base</span> <span class=no>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>last-step</span> <span class=no>T</span><span class=p>))))</span>
</span></span></code></pre></div><p>到這裡基本的Pie已經說完了，剛剛last有寫兩個版本，重要的是理解ind-Nat的motive與motive是怎麼與其他ind-Nat的部位有關係的</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/lisp/>Lisp</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2020/05/little-typer-%E5%BE%8C%E7%AF%878~16-%E6%95%B4%E7%90%86%E8%88%87%E7%AD%86%E8%A8%98/><span class=title>« Prev</span><br><span>little typer 後篇(8~16) 整理與筆記</span>
</a><a class=next href=https://littlebees.github.io/2020/05/%E5%9C%A8%E4%B8%8D%E5%90%8Ccontext%E4%B8%8B%E7%9A%84sync%E8%88%87async%E8%88%87blocknon-block%E6%AF%94%E8%BC%83/><span class=title>Next »</span><br><span>在不同context下的sync與async(與block&amp;non-block比較)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>