<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>competitive programming的tips | 記事本</title>
<meta name=keywords content><meta name=description content="動機
現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/07/competitive-programming%E7%9A%84tips/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/07/competitive-programming%E7%9A%84tips/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="competitive programming的tips"><meta property="og:description" content="動機
現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/07/competitive-programming%E7%9A%84tips/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-09T03:16:23+00:00"><meta property="article:modified_time" content="2021-07-09T03:16:23+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="competitive programming的tips"><meta name=twitter:description content="動機
現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"competitive programming的tips","item":"https://littlebees.github.io/2021/07/competitive-programming%E7%9A%84tips/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"competitive programming的tips","name":"competitive programming的tips","description":"動機 現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下\n","keywords":[],"articleBody":"動機 現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下\nC++ stdin 一般(空白分隔) int n; while (n \u003c\u003c cin) {} 一整行 string name; while (getline (cin,name)) {} 其他(有分隔號) string name; while (getline (cin,name,',')) {} file open 基本都是fstream，但如果只是要讀或寫可以直接用ifstream或ofstream\nstring name; ifstream fs; fs.open(\"test.txt\"); while (getline(fs,name)) {} read 同stdin(cin)\nmap, unorder_map (set與其實是一樣的東西) map就是自平衡二元搜尋樹，好像是rbtree，所以這個會替key排序 unorder_map自然就是hash table了\niterate(C++11): for (auto\u0026 kv : a_map) { kv.first,kv.second; } iterate: for (map::iterator it = a_map.begin(); it != a_map.end(); it++) { it-\u003efirst,it-\u003esecond; } string operation cast string-\u003eint // C++11 #include int n = stoi(\"123\"); double nn = stod(\"1.23\"); // C++98 #include int i; double d; // string -\u003e integer std::istringstream ( \"123\" ) \u003e\u003e i; // string -\u003e double std::istringstream ( \"1.23\" ) \u003e\u003e d; int-\u003estring: // C++11 #include string n = to_string(123); string nn = to_string(1.23); // C++98 #include std::ostringstream ss1,ss2; ss1 \u003c\u003c 123; ss2 \u003c\u003c 1.23; cout \u003c\u003c ss1.str() \u003c\u003c ',' \u003c\u003c ss2.str(); common operations substr: str.substr(start, len) length: str.length() reverse: string reversed(str.rbegin(), str.rend()); or std::reverse(copy.begin(), copy.end()); split(string -\u003e vector) 用find找pos再substr，之後erase 如果只有char用stringstream會好打一點 // for string delimiter vector\u003cstring\u003e split (string s, string delimiter) { size_t pos_start = 0, pos_end, delim_len = delimiter.length(); string token; vector\u003cstring\u003e res; while ((pos_end = s.find (delimiter, pos_start)) != string::npos) { token = s.substr (pos_start, pos_end - pos_start); pos_start = pos_end + delim_len; res.push_back (token); } res.push_back (s.substr (pos_start)); return res; } vector operation pop, push_back slice: std::vector(v1.begin(), v1.begin()+ len); (創一個新的) length: vec.size() iterate: for (auto\u0026 item : vec) {} reverse: vector reversed(vec.rbegin(), vec.rend()); or std::reverse(copy.begin(), copy.end()); map(C++11): std::transform(nums.begin(), nums.end(), nums.begin(), [](int num) {return std::pow(num, 2);}); filter(C++11): std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int num) {return num \u0026 1;}); reduce(C++11): #include std::accumulate(vector.begin(), vector.end(), decltype(vector)::value_type(0)); union find unordered_map\u003cint,int\u003e fd; vector\u003cint\u003e rank; int find(int i) { while (i != fd[i]) fd[i] = fd[fd[i]], i = fd[i]; return i; } void union(int i,int j) { int a = find(i), b = find(j); if (a != b) { if (rank[i] \u003e rank[j]) fd[j] = i, rank[i]++; else fd[i] = j, rank[j]++; } } trie struct Trie { unordered_map\u003cchar, struct Trie*\u003e nextLevel; bool end; ~Trie() { for (auto\u0026 kv : nextLevel) { delete kv.second; } } void insert(string s) { Trie* trie = this; for (auto\u0026 c : s) { if (trie-\u003enextLevel.find(c) == trie-\u003enextLevel.end()) { trie-\u003enextLevel[c] = new Trie(); } trie = trie-\u003enextLevel[c]; } trie-\u003eend = 1; } bool search(string s) { Trie* trie = this; for (auto\u0026 c : s) { if (trie-\u003enextLevel.find(c) != trie-\u003enextLevel.end()) { trie = trie-\u003enextLevel[c]; } else { return 0; } } return trie-\u003eend; } bool startsWith(string s) { Trie* trie = this; for (auto\u0026 c : s) { if (trie-\u003enextLevel.find(c) != trie-\u003enextLevel.end()) { trie = trie-\u003enextLevel[c]; } else { return 0; } } return 1; } }; Python stdin 要記得rstrip，不然會有newline\nimport sys for line in sys.stdin: line.rstrip('\\n') print(line) 這裡有分隔號的讀嗎? 其實有但很少用，而且要在open file時指定，不如用split，還比較快 python的split不用自己刻\nfile with open(\"file.txt\",'wr',encoding='utf8', newline='\\r\\n') as file_in: lines = [] for line in file_in: lines.append(line) file_in.write('write some str') dict operations iterate for (k,v) in dd.items(): # keys, values print(k,v) string operation str -\u003e int or float: int(\"123\") float(\"1.23\") numder -\u003e str: str(123) reverse: str[::-1] or ''.join(reservsed(str)) split: str.split(',') slice: str[start:end:step] str[2:0:-1] [start, end) start包含，end不包含 list operation append, pop join: ','.join(arr) slice: 同str iterate for item in mylist: # range(0,len(mylist)) print(item) list comprehension: [n+1 for n in mylist if n % 2 is 0] map: list(map(lambda x: x+1, mylist)) filter: list(filter(lambda x: x % 2 is 0, mylist)) reduce: from functools import reduce reduce(lambda acc,x: acc+x, a, 10) deque operation q = deque() q.append(x) q.appendleft(x) q.pop() q.popleft() union find fd = { n:n for n in range(1,11)} rank = [ 0 for n in range(1,11)] # how many ansestors does this item have? def find(fd,i): while fd[i] != i: fd[i] = fd[fd[i]] # path compression, 往祖先設定 i = fd[i] return i def union(fd,rank,i,j): a = fd[i] b = fd[j] if a != b: if rank[i] \u003e rank[j]: # 子孫越多tree越平 fd[j] = i rank[i] += 1 else: fd[i] = j rank[j] += 1 trie trie = [{},False] def addString(trie, s): for c in s: if c not in trie[0]: trie[0][c] = [{}, False] trie = trie[0][c] trie[1] = True def find(trie, s): for c in s: if c in trie[0]: trie = trie[0][c] else: return False return trie[1] dp tips 可以用functools.cache\n@functools.cache def fib(n): if n \u003c 2: return 1 else: return fib(n-1)+fin(n-2) 如果有重複走的問題要自己處理\ndef cache_computing(f,is_computing=None): mem = {} @functools.wraps(f) def wrapper(*args,**kwds): if args not in mem: mem[args] = is_computing mem[args] = f(*args,**kwds) return mem[args] return wrapper Algo經典手法與題目recap prefix sum 用法 算區間和 和 從a~b的總和 如果有負數，可以代表偏離原點多遠 一般來說，通常第一個會是0代表沒有加任何東西的狀態 所以index從1開始，代表從arr[0]~arr[i-1] static (index -\u003e sum) list(accumulate(nums, initial=0)) LC209 因為arr只有正數 可以用sliding window，去收縮大小 可以用prefix sum，在prefix sum做binary search 我們會先列舉起點到終點 所以prefix sum也是從起點去往後找終點 TODO: LC209與LC525為什麼一個是從後面一個從前面 in fly (sum -\u003e count or [index]) LC560 基本款 LC525 與LC209不同這裡是每加一個都會產生變化 所以可以用in fly一邊建prefix sum，再找有沒有符合的 注意同一個sum我們只要最前面的 Monotonic stack 用法 根據關注點不同有不同的看法 排序，留下最後的字典序 (stk是重點) 1 3 7 2 1 2 可以看成2把3,7吃了，只留下該範圍最小的，這也是字典序的由來 內容物: 節點 區塊 夾出區間，中間是最大或是最小 (被pop的資料是重點) while stk and stk[-1] \u003c= n 7 3 2 ..left.. 1 ..right.. 2 right的所有數字都會小於1 left的所有數字都會等於1 1是這個區間(去頭尾)最大的，含頭尾的區間中的最小的 while stk and stk[-1] \u003e= n 1 2 3 ..left.. 7 ..right.. 2 right的所有數字都會大於7 left的所有數字都會等於7 7是這個區間最小的，含頭尾的區間中的最大的 這樣就可以用stk[-2]與n，做出一個閉區間 記得處理沒有stk的case 在需要保持原本的順序、字典序、前面的資料會被後面的蓋掉時就可以老慮用用看 夾出區間 LC84 經典 小的柱子會被大的蓋掉，只取小的 用成圖: 1,1,1,...1, 2,3,4, 10 很明顯就是monotonic stack 取pop出的柱子去乘左右兩邊構成的區間長度 LC1130 如果要最小一定是找最小的數字，之後是左右兩邊最小的 化成圖: a .left. min .right. b 有什麼辦法可以保證min一定是a~b之間最小的? monotonic stack while stk and stk[-1] \u003c= n 最後乘的時候要確認哪邊是小的!! LC1793 就是LC84 不過要在對的區間時才能更新答案 這裡可以與LC402比 402是控制pop TODO: 這樣stack的性質會是對的嗎? 1793是控制更新答案 LC1856 區間中最小、又要連續 化成圖: 7 3 2 ..left.. 1 ..right.. 2 之後用prefix sum加速加總 LC907 區間中最小，monotonic stack 化成圖: 1 2 3 ..left.. 7 ..right.. 2 LC42 只要被兩個柱子夾起來的部份而已!! 排序 LC402 如果只是移除多的字以完成最小字典序不難就mono stack 但是有限制次數，所以不能一直pop LC316 同樣是移除字完成最小字典序 但與LC402不同的是，這次是不能放入同樣的字 注意到，這次條件是打在最外面 只要重複就連stack都不pop 但402是還可以放數字到stack LC768 這題把stack的sort具體化，這話怎麼說 前面提過小的會把大的吃掉，所以現在紀錄的是範圍最小 但這題最後要留下範圍最大的item LC901 就是LC768 要記下區間最大值 不過這題還要區間長度 LC581 可以用LC768去生chunk，之後把頭尾去掉，把所有長度加起來 TODO: 但可以不用那麼麻煩 下一個最大 LC503 這是monotonic stack的經典展現 求下一個最大 觸發pop的數字就是下一個最大 circular? nums兩倍長就好 LC739 求下一個最大之間的距離 所以stack放index 這裡會遇到一個有趣的case [1, 2, 2]要怎麼處理? 加等號: 會讓後面的2被吃掉 不加: 2留著 怎麼叫更溫暖? 大於，所以不加等號 難 LC456 這要認真推 先暴力 原本1\u003c2\u003c3 會從3開始找，之後2再來1 會從最大的開始找!! 但現在 1\u003c3\u003c2 這要從哪裡開始找? 先從大的開始，所以是2 但怎麼確認3 (難的地方!!) 從後面開始看 這樣會有 1 1 1 2 3 3 3 之後是大小，2要大於3，最好會自動清 monotonic stack 清出來的就是可能的2，而我們挑最大的 要等號嗎? 不用!! 保留可能性 所以要做的是 從後往前，塞stack (3的候補) 出現大的數字，清stack (2的候補) 剩下只要比對是不是符合132 class Solution: def find132pattern(self, nums: List[int]) -\u003e bool: stk = [] mid = float('-inf') for n in reversed(nums): if n \u003c mid and stk: return True while stk and stk[-1] \u003c n: mid = max(mid,stk.pop()) stk += n, return False LC862 區間總和，但是 有負數 大於等於目標 算區間和，prefix sum 所以就一直記prefix sum，從最小的開始算和(queue) 如果sum太大怎麼辦 所以要清 (stack，這不單調，只是要清總和太大的項目) binary search bsearch不一定要排序才能用 bsearch最好用左閉右開 注意mid會不會重複 用法\n找目標 猜數字 逼近 (LC4) 題目 LC162 右邊的點要在答案中 也就是重合時會等於的值 往大的方向走 就算沒有sort也可以用!! LC4 有sort也不一定看的出來可以用bsearch 這裡重點是長度 每次把小的區段丟掉 LC1011 猜每天要在多少重量 但範圍是重點 太大會很慢 每一個貨物當成最重的重量，去算平均 LC33 確認兩件事 哪一塊是遞增的 目標在這一塊嗎 另外 如果長度是2，mid會輪迴!! LC153 對rotate的長度做bsearch LC327 prefix sum + 不等式 用lower bound與upper bound找index sliding window 基本 用閉區間做 列舉終點\na = 0 win = [] for b in range(len(fs)): update_win() while a \u003c= b and when_win_is_illegal(): shrink_win() update_ret() return ret 列舉起點\nb = 0 win = [] for a in range(len(fs)): while b \u003c len(fs) and when_win_is_legal(): update_ret() expand_win() shrink_win() return ret atMost\ndef atmost(bound): ret = i = 0 for j,n in enumerate(nums): update_win() while i \u003c= j and when_win_is_illegal(): shrink_win() ret += j-i+1 return ret 題目 LC220 這裡index的abs用sliding window處理 數字用不等式推論 之後會看到lower bound LC995 這裡的重點是處理flip flip的問題 現在是什麼bit 範圍到哪 範圍就想到index 所以要有方法追蹤有flip的index 並在超出範圍時刷掉 queue做sliding window LC713 用sliding window找最靠近k的window 但接著就是怎麼算現在的window有多少組合? 魔法: right-left + 1 class Solution: def totalFruit(self, fs: List[int]) -\u003e int: win = Counter() a = 0 ret = 0 for b in range(len(fs)): win[fs[b]] += 1 while a \u003c= b and len(win) \u003e 2: win[fs[a]] -= 1 win += Counter() a += 1 ret = max(ret, b-a+1) return ret LC395 長度是至少k 所以不好當sliding window的條件 需要別的條件 字母只有26個 限制最多多少字母可以出現在window中!! LC424 怎麼找出有多少非法字 總長度 = 最多的字 + 其他字 LC992 新招式: atMost 小於等於limit有多少組合 LC1234 window中的東西可以亂生 外面不超標的話就可以用window把string給平衡掉 LC1248 可以用atMost 也可以之前的魔法 right-left+1是以此點為終點的組合數 之後就是在奇數到期時加到答案中 monotonic queue LC239 明顯是sliding window 但要最大值 monotonic stack 還要顧index deque 兩個結合就是monotonic queue two pointer linked list vs array LC148 只能用merge sort 因為不能隨機跳位置 LC19 這是list，一旦過了就回不去 但可以像找中點，讓兩個ptr之間保持距離 這裡是固定距離，中點是找兩倍 LC61 \u0026 LC189 先談rotate array 一個是Cyclic replace (不好做) 另一個是 reverse整條 reverse 0~k 與 reverse k~end 再談rotate list 延續reverse的解法 第一次reverse是把後面的拉到前面 第二次reverse是把順序用成對的 但這裡是list，所以可以直接把list分成兩個 接上去就好 index,ptr as list LC283 一個ptr做為0的list的終點 另一個ptr是還沒看過的item的list的起點 LC26 同LC283 一個終點一個起點，一直換 LC905 類似LC283 但一個從array的頭，一個從尾塞 LC75 類似LC905 但要記得從後面換的部分還是屬於沒看過的部分，所以還要再看一次 LC86 把list分一半 兩個list指向list的終點 Linked list需要確保每次新增node時不會loop 要記得把next設成None LC143 類似LC86 classic LC142 判圈 一個走一倍，一個走兩倍 只要相遇就是圈 圈的起點 慢走的長度是 起點到圈起點 + 某個數字*圈長度 快走的長度是 起點到圈起點 + 某個數字*圈長度 兩個相減就會看到現在長度其實是 圈長度的整數倍 也就是說，不管從哪裡都可以算是圈的起點 所以只要從起點走遇到另一個ptr就是圈的起點 LC15 3sum 從頭開始走剩下的部分做2sum LC18 nSum 延伸3sum，直到只剩下2sum之前 都是當成3sum處理 LC876 Linked List中點 一個走一倍，一個走兩倍 另一個到終點，現在的就是中點 根據跳出來的條件可以看長度是奇數還是偶數 因node.next跳出來，偶數 因node.next.next跳出來，奇數 LC287 有很多解法 bsearch (猜數字) 注意到資料都是在index的範圍內 可以用判圈 可以把資料換到對應的index上 另外該資料也會是0~i之間最大的 見chunk那一題 misc LC986 merge interval可以 把兩個interval看頭尾，挑最靠近裡面的部分 在最小中挑最大 在最大中挑最小 如果新interval的頭大於尾，這新interval就是非法的 每次都丟尾最小的 LC844 上stack 直接從尾開始比，之後統計刪的次數，有counter時跳掉 為什麼是尾開始 delete往前刪 所以前面不會確定 但後面不會被影響 有點像moore voting LC763 所有char都要在同一區 一次一次紀錄每個char最後出線的index 什麼時候才切成一區? 當下的位置就是最後的位置時 可以看chunk與LC287作對比 LC42 對於每個柱子，就是看 左右都比自己高 挑矮的，算差距 因為每次都只看最矮的 所以可以像2sum去縮 heap python原本只有heapq，十分不好用 但是可以搭配已經sort好的list去用他的heappop與heappush LC352 可以用SordtedList好用超多，遠比C++的set或是map好用 divide and conquer LC327 右邊index一定大於左邊 針對每個左邊index找右邊符合需求的區間 LC493 TODO: 要看裡面怎麼用bit，感覺與divide and conquer有一點關係 Dynamic programming TODO 刷表法 \u0026 填表法差別 用途 此點的狀態，像palindromic 到目前為止的總和，一般的dp都是以此為目標去求 from start or end LC198 dp可以從 起點開始算 要先把整個長度算好 這是環狀 長度兩倍 終點算回去 簡單很多!! max(self.ns[i] + self.dp(i-2), self.dp(i-1)) 任何dp都建議從終點算回去 bottom-up 與 top-down LC718 如果用top-down 除了要看字有沒有一樣 還要追蹤長度!! 因為要連續 f(i,j,l) max(ret, f(i-1,j,0), f(i,j-1,0)) ret = f(i-1,j-1,k+1) if s[i] == s[j] else k 這是n^3 用bottom-up dp[i][j] = dp[i-1][j-1]+1 if if s[i] == s[j] else 0 這是n^2 因為是長度所以比起top-down少很多東西 LC546 真的什麼都想不到的話就是dp去模擬 要什麼項目(參數、狀態定義) 怎麼轉換 f(i,j,k) i,j是範圍 k是與j同顏色的盒子數量 所以這裡就兩個case 直接把所有盒子用掉，算分數 抓中點，去增加k的數量 [dp(i,x,k+1)+dp(x+1,j-1,0) for x in range(i,j) if boxes[x] == boxes[j]] classic LC72 edit dist replace: (i-1,j-1) delete: (i,j-1) insert\" (i-1,j) insert多一個字，又馬上比對，所以與delete相反 LC647 palindromic s[i] == s[j] and ispalid(i+1,j-1) 這題其實做從中心展開會比較好 都是n^2，還比較簡單 LC516 palindromic 不用在失敗時結束，要把字刪掉 max(dp(i+1,j),dp(i,j-1)) 剩下就是原本的dp LC322 coin 有兩種 一個是從背包抄來的 f(total, i) 一個是完全不用: f(total, i-1) 一個是一直try: f(total-arr[i]*n, i) 這是n^2 另一個是用total做狀態 f(total) 每個都try: min([f(total-n) for n in arr]) 這個是n LC139 word break 這不是教科書會出現的dp經典 但是處理leetcode的字串列舉常常用到 f(s) 對bank的每個字比開頭 f(s[len(w):]) 題外話 bank的處理還有一個是用bfs配把字碼調 像*bc、a*b、ab* 處理換字能不能換成另一個字的問題 再題外話 像是倒水問題這種狀態變化固定的都可以用bfs找最短路徑 但要把狀態定義好!! LC152 LIS 這題是LIS的進化版 原本是 lis(i) max(arr[i], arr[i]+lis(i)) 但負數也有可能會是選項!! 所以要同時計min與max，不能像原版只用max LC354 LIS 這題是二維LIS 但要處理第一維同數字的問題 第一維increasing排序 第二維decreasing排序 LC64 棋盤 就是看能往哪走 f(i,j) grid[i][j]+min(f(i-1,j), f(i,j-1)) 建議都是用終點去推 TODO: 有一題就是一定要用終點推 如果用起點走就是dfs LC338 奇偶 偶: 2n 奇: 2n+1 可以直接用!! LC96 BST與range BST就是左邊小、右邊大 所以有range BST是tree 常用的dfs 在range上列舉中點，算組合數 hard LC87 這種有明確標示動作與做reduction對象的都很簡單 但這題要注意swap的string可能還沒被比完!! 要用cache_computing LC396 把函數列出來 找規律 (所以難，有緣就找的到) f(n) = f(n-1) - sum + len(arr)*arr[n-1] LC312 如果用平常的作法 f(i,j)是i~j的最大分數就會變成兩邊 十分痛苦 要看成 這區域的氣球都爆完的分數有多少 列舉要爆的氣球 max( nums[left] * nums[i] * nums[right] + dp(left, i) + dp(i, right) for i in range(left+1, right) ) LC926 分成ones與zeros就可以看出要用prefix sum 如果要用dp，就要看怎麼建構合法的答案 最後一位如果是1，可以直接接上去 如果是0，不是把前面的1換成0，就是把自己這一位換成1 LC600 f(i)i位數的合法組合數 (沒有連續1) 以5為例 10 111 ~ 10 000: f(3) 0 1111 ~ 0 0000: f(4) 11 111 ~ 11 000非法 01 111 ~ 01 000會被包含 f(i) = f(i-1)+f(i-2) 所以剩下就是從最高位往下加f(k) 同時看有沒有連續1出現!! LC44 其實就是用string比對處理(edit dist) 但要注意最後pat只剩下star的狀態!! LC188 能用到mutual recursion!! 定義buy(i,k)andsell(i,k) 分別定義 buy(i,k): 在i時還有k次購買機會的購買的最大收益 buy(i-1,k) sell(i-k,k-1)-arr[i] sell(i,k): 在i時還有k次購買機會的賣出的最大收益 sell(i-1,k) buy(i-k,k)+arr[i] 另外也可以用挑區段，去接來看 如果當成lis去看，之後跑k次 分成歷史上的最大(global)與當前的最大(local) 之後就是用lis更新local 之後更新global local = max(global[i], local + prices[i] - prices[i-1]) global[i] = max(global[i-1], local) 另外。LC122 最高到最低的總和就是各個區段的總和 所以就是在increasing時把所有差額加起來 LC376 這題對我有因緣 因為是用自己的dp過的 先過整條array看是increasing還是decreasing 之後根據方向，跑lis 因為有兩個方向，所以可以定義mutual recursion arr[i-1] \u003e arr[i] up[i] = down[i-1]+1 down[i] = down[i-1] arr[i-1] \u003c arr[i] up[i] = up[i-1] down[i] = up[i-1]+1 arr[i-1] == arr[i] up[i] = up[i-1] down[i] = down[i-1] line sweap 把起終點分開，[start, -height], [end, height] 根據位置與高度排序 之後一個一個走 把高度塞到heap中 (line sweap) 負的就塞 正的就去刪 之後就是用heap去確認當前高度，去調整答案 elegant sol 這裡是收集一些原本用dp但是有超級優雅的解 LC828 from lee215 AXXXAXXA 看中間的A到左右兩邊的A隔3與2個字元(4與3個洞) 所以只包含中間A的組合是12 所以只要針對所有字元中間的洞算組合數就好!! LC1569 這是BST，有左右兩邊 而我們有第一個點，root 可以分左右兩邊 算組合數: comb(len(right)+len(left), len(right))*f(right)*f(left) LC678 把所有星號當成左括號，去計數，如果左括號太少，就直接False 把所有星號當成右括號，去計數，全部跑完，看有沒有被扣完 ","wordCount":"1753","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-07-09T03:16:23Z","dateModified":"2021-07-09T03:16:23Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/07/competitive-programming%E7%9A%84tips/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">competitive programming的tips</h1><div class=post-meta><span title='2021-07-09 03:16:23 +0000 UTC'>July 9, 2021</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#c aria-label=C++>C++</a><ul><li><a href=#stdin aria-label=stdin>stdin</a><ul><li><a href=#%e4%b8%80%e8%88%ac%e7%a9%ba%e7%99%bd%e5%88%86%e9%9a%94 aria-label=一般(空白分隔)>一般(空白分隔)</a></li><li><a href=#%e4%b8%80%e6%95%b4%e8%a1%8c aria-label=一整行>一整行</a></li><li><a href=#%e5%85%b6%e4%bb%96%e6%9c%89%e5%88%86%e9%9a%94%e8%99%9f aria-label=其他(有分隔號)>其他(有分隔號)</a></li></ul></li><li><a href=#file aria-label=file>file</a><ul><li><a href=#open aria-label=open>open</a></li><li><a href=#read aria-label=read>read</a></li></ul></li><li><a href=#map-unorder_map-set%e8%88%87%e5%85%b6%e5%af%a6%e6%98%af%e4%b8%80%e6%a8%a3%e7%9a%84%e6%9d%b1%e8%a5%bf aria-label="map, unorder_map (set與其實是一樣的東西)">map, unorder_map (set與其實是一樣的東西)</a></li><li><a href=#string-operation aria-label="string operation">string operation</a><ul><li><a href=#cast aria-label=cast>cast</a></li><li><a href=#common-operations aria-label="common operations">common operations</a></li></ul></li><li><a href=#vector-operation aria-label="vector operation">vector operation</a></li><li><a href=#union-find aria-label="union find">union find</a></li><li><a href=#trie aria-label=trie>trie</a></li></ul></li><li><a href=#python aria-label=Python>Python</a><ul><li><a href=#stdin-1 aria-label=stdin>stdin</a></li><li><a href=#file-1 aria-label=file>file</a></li><li><a href=#dict-operations aria-label="dict operations">dict operations</a></li><li><a href=#string-operation-1 aria-label="string operation">string operation</a></li><li><a href=#list-operation aria-label="list operation">list operation</a></li><li><a href=#deque-operation aria-label="deque operation">deque operation</a></li><li><a href=#union-find-1 aria-label="union find">union find</a></li><li><a href=#trie-1 aria-label=trie>trie</a></li><li><a href=#dp-tips aria-label="dp tips">dp tips</a></li></ul></li><li><a href=#algo%e7%b6%93%e5%85%b8%e6%89%8b%e6%b3%95%e8%88%87%e9%a1%8c%e7%9b%aerecap aria-label=Algo經典手法與題目recap>Algo經典手法與題目recap</a><ul><li><a href=#prefix-sum aria-label="prefix sum">prefix sum</a><ul><li><a href=#%e7%94%a8%e6%b3%95 aria-label=用法>用法</a></li><li><a href=#static-index---sum aria-label="static (index -> sum)">static (index -> sum)</a></li><li><a href=#in-fly-sum---count-or-index aria-label="in fly (sum -> count or [index])">in fly (sum -> count or [index])</a></li></ul></li><li><a href=#monotonic-stack aria-label="Monotonic stack">Monotonic stack</a><ul><li><a href=#%e7%94%a8%e6%b3%95-1 aria-label=用法>用法</a></li><li><a href=#%e5%a4%be%e5%87%ba%e5%8d%80%e9%96%93 aria-label=夾出區間>夾出區間</a></li><li><a href=#%e6%8e%92%e5%ba%8f aria-label=排序>排序</a></li><li><a href=#%e4%b8%8b%e4%b8%80%e5%80%8b%e6%9c%80%e5%a4%a7 aria-label=下一個最大>下一個最大</a></li><li><a href=#%e9%9b%a3 aria-label=難>難</a></li></ul></li><li><a href=#binary-search aria-label="binary search">binary search</a><ul><li><a href=#%e9%a1%8c%e7%9b%ae aria-label=題目>題目</a></li></ul></li><li><a href=#sliding-window aria-label="sliding window">sliding window</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac aria-label=基本>基本</a></li><li><a href=#%e9%a1%8c%e7%9b%ae-1 aria-label=題目>題目</a></li><li><a href=#monotonic-queue aria-label="monotonic queue">monotonic queue</a></li></ul></li><li><a href=#two-pointer aria-label="two pointer">two pointer</a><ul><li><a href=#linked-list-vs-array aria-label="linked list vs array">linked list vs array</a></li><li><a href=#indexptr-as-list aria-label="index,ptr as list">index,ptr as list</a></li><li><a href=#classic aria-label=classic>classic</a></li><li><a href=#misc aria-label=misc>misc</a></li></ul></li><li><a href=#heap aria-label=heap>heap</a></li><li><a href=#divide-and-conquer aria-label="divide and conquer">divide and conquer</a></li><li><a href=#dynamic-programming aria-label="Dynamic programming">Dynamic programming</a><ul><li><a href=#todo aria-label=TODO>TODO</a></li><li><a href=#%e7%94%a8%e9%80%94 aria-label=用途>用途</a></li><li><a href=#from-start-or-end aria-label="from start or end">from start or end</a></li><li><a href=#bottom-up-%e8%88%87-top-down aria-label="bottom-up 與 top-down">bottom-up 與 top-down</a></li><li><a href=#classic-1 aria-label=classic>classic</a></li><li><a href=#hard aria-label=hard>hard</a></li></ul></li><li><a href=#line-sweap aria-label="line sweap">line sweap</a><ul><li><a href=#elegant-sol aria-label="elegant sol">elegant sol</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>現在習慣寫LC，都已經忘了怎麼用c++或是python來讀stdin，所以來整理一下</p><h2 id=c>C++<a hidden class=anchor aria-hidden=true href=#c>#</a></h2><h3 id=stdin>stdin<a hidden class=anchor aria-hidden=true href=#stdin>#</a></h3><h4 id=一般空白分隔>一般(空白分隔)<a hidden class=anchor aria-hidden=true href=#一般空白分隔>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=n>cin</span><span class=p>)</span> <span class=p>{}</span>
</span></span></code></pre></div><h4 id=一整行>一整行<a hidden class=anchor aria-hidden=true href=#一整行>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>getline</span> <span class=p>(</span><span class=n>cin</span><span class=p>,</span><span class=n>name</span><span class=p>))</span> <span class=p>{}</span>
</span></span></code></pre></div><h4 id=其他有分隔號>其他(有分隔號)<a hidden class=anchor aria-hidden=true href=#其他有分隔號>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>getline</span> <span class=p>(</span><span class=n>cin</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=sc>&#39;,&#39;</span><span class=p>))</span> <span class=p>{}</span>
</span></span></code></pre></div><h3 id=file>file<a hidden class=anchor aria-hidden=true href=#file>#</a></h3><h4 id=open>open<a hidden class=anchor aria-hidden=true href=#open>#</a></h4><p>基本都是fstream，但如果只是要讀或寫可以直接用ifstream或ofstream</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ifstream</span> <span class=n>fs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>fs</span><span class=p>.</span><span class=n>open</span><span class=p>(</span><span class=s>&#34;test.txt&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>getline</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span><span class=n>name</span><span class=p>))</span> <span class=p>{}</span>
</span></span></code></pre></div><h4 id=read>read<a hidden class=anchor aria-hidden=true href=#read>#</a></h4><p>同stdin(cin)</p><h3 id=map-unorder_map-set與其實是一樣的東西>map, unorder_map (set與其實是一樣的東西)<a hidden class=anchor aria-hidden=true href=#map-unorder_map-set與其實是一樣的東西>#</a></h3><p>map就是自平衡二元搜尋樹，好像是rbtree，所以這個會替key排序
unorder_map自然就是hash table了</p><ul><li>iterate(C++11): <code>for (auto& kv : a_map) { kv.first,kv.second; }</code></li><li>iterate: <code>for (map&lt;string, int>::iterator it = a_map.begin(); it != a_map.end(); it++) { it->first,it->second; }</code></li></ul><h3 id=string-operation>string operation<a hidden class=anchor aria-hidden=true href=#string-operation>#</a></h3><h4 id=cast>cast<a hidden class=anchor aria-hidden=true href=#cast>#</a></h4><ul><li>string->int</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// C++11
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>stoi</span><span class=p>(</span><span class=s>&#34;123&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>nn</span> <span class=o>=</span> <span class=n>stod</span><span class=p>(</span><span class=s>&#34;1.23&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C++98
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;sstream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// string -&gt; integer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>istringstream</span> <span class=p>(</span> <span class=s>&#34;123&#34;</span> <span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// string -&gt; double 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>istringstream</span> <span class=p>(</span> <span class=s>&#34;1.23&#34;</span> <span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>d</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>int->string:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// C++11
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>string</span> <span class=n>n</span> <span class=o>=</span> <span class=n>to_string</span><span class=p>(</span><span class=mi>123</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>nn</span> <span class=o>=</span> <span class=n>to_string</span><span class=p>(</span><span class=mf>1.23</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C++98
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;sstream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>std</span><span class=o>::</span><span class=n>ostringstream</span> <span class=n>ss1</span><span class=p>,</span><span class=n>ss2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ss1</span> <span class=o>&lt;&lt;</span> <span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ss2</span> <span class=o>&lt;&lt;</span> <span class=mf>1.23</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>ss1</span><span class=p>.</span><span class=n>str</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;,&#39;</span> <span class=o>&lt;&lt;</span> <span class=n>ss2</span><span class=p>.</span><span class=n>str</span><span class=p>();</span>
</span></span></code></pre></div><h4 id=common-operations>common operations<a hidden class=anchor aria-hidden=true href=#common-operations>#</a></h4><ul><li>substr: <code>str.substr(start, len)</code></li><li>length: <code>str.length()</code></li><li>reverse: <code>string reversed(str.rbegin(), str.rend());</code> or <code>std::reverse(copy.begin(), copy.end());</code></li><li>split(string -> vector<string>)<ul><li>用find找pos再substr，之後erase</li><li>如果只有char用stringstream會好打一點</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// for string delimiter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>split</span> <span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>,</span> <span class=n>string</span> <span class=n>delimiter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>pos_start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>pos_end</span><span class=p>,</span> <span class=n>delim_len</span> <span class=o>=</span> <span class=n>delimiter</span><span class=p>.</span><span class=n>length</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>token</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>pos_end</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>find</span> <span class=p>(</span><span class=n>delimiter</span><span class=p>,</span> <span class=n>pos_start</span><span class=p>))</span> <span class=o>!=</span> <span class=n>string</span><span class=o>::</span><span class=n>npos</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>token</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>substr</span> <span class=p>(</span><span class=n>pos_start</span><span class=p>,</span> <span class=n>pos_end</span> <span class=o>-</span> <span class=n>pos_start</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pos_start</span> <span class=o>=</span> <span class=n>pos_end</span> <span class=o>+</span> <span class=n>delim_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span><span class=p>.</span><span class=n>push_back</span> <span class=p>(</span><span class=n>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>res</span><span class=p>.</span><span class=n>push_back</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>substr</span> <span class=p>(</span><span class=n>pos_start</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=vector-operation>vector operation<a hidden class=anchor aria-hidden=true href=#vector-operation>#</a></h3><ul><li>pop, push_back</li><li>slice: <code>std::vector&lt;int>(v1.begin(), v1.begin()+ len);</code> (創一個新的)</li><li>length: <code>vec.size()</code></li><li>iterate: <code>for (auto& item : vec) {}</code></li><li>reverse: <code>vector&lt;int> reversed(vec.rbegin(), vec.rend());</code> or <code>std::reverse(copy.begin(), copy.end());</code></li><li>map(C++11): <code>std::transform(nums.begin(), nums.end(), nums.begin(), [](int num) {return std::pow(num, 2);});</code></li><li>filter(C++11): <code>std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int num) {return num & 1;});</code></li><li>reduce(C++11): <code>#include &lt;numeric> std::accumulate(vector.begin(), vector.end(), decltype(vector)::value_type(0));</code></li></ul><h3 id=union-find>union find<a hidden class=anchor aria-hidden=true href=#union-find>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>rank</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>fd</span><span class=p>[</span><span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]],</span> <span class=n>i</span> <span class=o>=</span> <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>union</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span><span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>b</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>!=</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>rank</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=n>fd</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>,</span> <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span><span class=p>,</span> <span class=n>rank</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=trie>trie<a hidden class=anchor aria-hidden=true href=#trie>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Trie</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>Trie</span><span class=o>*&gt;</span> <span class=n>nextLevel</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>bool</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Trie</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>kv</span> <span class=p>:</span> <span class=n>nextLevel</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=n>kv</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span><span class=o>*</span> <span class=n>trie</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>c</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>==</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>[</span><span class=n>c</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Trie</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>trie</span> <span class=o>=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>[</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>trie</span><span class=o>-&gt;</span><span class=n>end</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span><span class=o>*</span> <span class=n>trie</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>c</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>!=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>trie</span> <span class=o>=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>[</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>startsWith</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span><span class=o>*</span> <span class=n>trie</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>c</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>!=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>trie</span> <span class=o>=</span> <span class=n>trie</span><span class=o>-&gt;</span><span class=n>nextLevel</span><span class=p>[</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=python>Python<a hidden class=anchor aria-hidden=true href=#python>#</a></h2><h3 id=stdin-1>stdin<a hidden class=anchor aria-hidden=true href=#stdin-1>#</a></h3><p>要記得rstrip，不然會有newline</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>sys</span><span class=o>.</span><span class=n>stdin</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>line</span><span class=o>.</span><span class=n>rstrip</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>line</span><span class=p>)</span>
</span></span></code></pre></div><p>這裡有分隔號的讀嗎?
其實有但很少用，而且要在open file時指定，不如用split，還比較快
python的split不用自己刻</p><h3 id=file-1>file<a hidden class=anchor aria-hidden=true href=#file-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;file.txt&#34;</span><span class=p>,</span><span class=s1>&#39;wr&#39;</span><span class=p>,</span><span class=n>encoding</span><span class=o>=</span><span class=s1>&#39;utf8&#39;</span><span class=p>,</span> <span class=n>newline</span><span class=o>=</span><span class=s1>&#39;</span><span class=se>\r\n</span><span class=s1>&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>file_in</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>lines</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>file_in</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>lines</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>line</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>file_in</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>&#39;write some str&#39;</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=dict-operations>dict operations<a hidden class=anchor aria-hidden=true href=#dict-operations>#</a></h3><ul><li>iterate</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=n>dd</span><span class=o>.</span><span class=n>items</span><span class=p>():</span> <span class=c1># keys, values</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>v</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=string-operation-1>string operation<a hidden class=anchor aria-hidden=true href=#string-operation-1>#</a></h3><ul><li>str -> int or float: <code>int("123") float("1.23")</code></li><li>numder -> str: <code>str(123)</code></li><li>reverse: <code>str[::-1]</code> or <code>''.join(reservsed(str))</code></li><li>split: <code>str.split(',')</code></li><li>slice: <code>str[start:end:step]</code> <code>str[2:0:-1]</code><ul><li><code>[start, end)</code> start包含，end不包含</li></ul></li></ul><h3 id=list-operation>list operation<a hidden class=anchor aria-hidden=true href=#list-operation>#</a></h3><ul><li>append, pop</li><li>join: <code>','.join(arr)</code></li><li>slice: 同str</li><li>iterate</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>mylist</span><span class=p>:</span> <span class=c1># range(0,len(mylist))</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span></code></pre></div><ul><li>list comprehension: <code>[n+1 for n in mylist if n % 2 is 0]</code></li><li>map: <code>list(map(lambda x: x+1, mylist))</code></li><li>filter: <code>list(filter(lambda x: x % 2 is 0, mylist))</code></li><li>reduce:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl><span class=n>reduce</span><span class=p>(</span><span class=k>lambda</span> <span class=n>acc</span><span class=p>,</span><span class=n>x</span><span class=p>:</span> <span class=n>acc</span><span class=o>+</span><span class=n>x</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=deque-operation>deque operation<a hidden class=anchor aria-hidden=true href=#deque-operation>#</a></h3><pre tabindex=0><code>q = deque()
q.append(x)
q.appendleft(x)
q.pop()
q.popleft()
</code></pre><h3 id=union-find-1>union find<a hidden class=anchor aria-hidden=true href=#union-find-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fd</span> <span class=o>=</span> <span class=p>{</span> <span class=n>n</span><span class=p>:</span><span class=n>n</span> <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>11</span><span class=p>)}</span>
</span></span><span class=line><span class=cl><span class=n>rank</span> <span class=o>=</span> <span class=p>[</span> <span class=mi>0</span> <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>11</span><span class=p>)]</span> <span class=c1># how many ansestors does this item have?</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>fd</span><span class=p>[</span><span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span> <span class=c1># path compression, 往祖先設定</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span> <span class=o>=</span> <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span><span class=n>rank</span><span class=p>,</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>a</span> <span class=o>=</span> <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=n>b</span> <span class=o>=</span> <span class=n>fd</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>a</span> <span class=o>!=</span> <span class=n>b</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>rank</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span> <span class=c1># 子孫越多tree越平</span>
</span></span><span class=line><span class=cl>      <span class=n>fd</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>      <span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>fd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>      <span class=n>rank</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span></code></pre></div><h3 id=trie-1>trie<a hidden class=anchor aria-hidden=true href=#trie-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>trie</span> <span class=o>=</span> <span class=p>[{},</span><span class=kc>False</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>addString</span><span class=p>(</span><span class=n>trie</span><span class=p>,</span> <span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>s</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>c</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>trie</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=n>trie</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>c</span><span class=p>]</span> <span class=o>=</span> <span class=p>[{},</span> <span class=kc>False</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>trie</span> <span class=o>=</span> <span class=n>trie</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>c</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=n>trie</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=n>trie</span><span class=p>,</span> <span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>s</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>trie</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=n>trie</span> <span class=o>=</span> <span class=n>trie</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>c</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>trie</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div><h3 id=dp-tips>dp tips<a hidden class=anchor aria-hidden=true href=#dp-tips>#</a></h3><p>可以用<code>functools.cache</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@functools.cache</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fib</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fib</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=n>fin</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><p>如果有重複走的問題要自己處理</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>cache_computing</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=n>is_computing</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>mem</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nd>@functools.wraps</span><span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span><span class=o>**</span><span class=n>kwds</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>args</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>mem</span><span class=p>:</span>
</span></span><span class=line><span class=cl>          <span class=n>mem</span><span class=p>[</span><span class=n>args</span><span class=p>]</span> <span class=o>=</span> <span class=n>is_computing</span>
</span></span><span class=line><span class=cl>          <span class=n>mem</span><span class=p>[</span><span class=n>args</span><span class=p>]</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span><span class=o>**</span><span class=n>kwds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>mem</span><span class=p>[</span><span class=n>args</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>wrapper</span>
</span></span></code></pre></div><h2 id=algo經典手法與題目recap>Algo經典手法與題目recap<a hidden class=anchor aria-hidden=true href=#algo經典手法與題目recap>#</a></h2><h3 id=prefix-sum>prefix sum<a hidden class=anchor aria-hidden=true href=#prefix-sum>#</a></h3><h4 id=用法>用法<a hidden class=anchor aria-hidden=true href=#用法>#</a></h4><ul><li>算區間和<ul><li>和<ul><li>從a~b的總和</li><li>如果有負數，可以代表偏離原點多遠</li></ul></li><li>一般來說，通常第一個會是0代表沒有加任何東西的狀態</li><li>所以index從1開始，代表從<code>arr[0]~arr[i-1]</code></li></ul></li></ul><h4 id=static-index---sum>static (index -> sum)<a hidden class=anchor aria-hidden=true href=#static-index---sum>#</a></h4><ul><li><code>list(accumulate(nums, initial=0))</code></li><li>LC209<ul><li>因為arr只有正數<ul><li>可以用sliding window，去收縮大小</li><li>可以用prefix sum，在prefix sum做binary search<ul><li>我們會先列舉起點到終點</li><li>所以prefix sum也是從起點去往後找終點</li><li>TODO: LC209與LC525為什麼一個是從後面一個從前面</li></ul></li></ul></li></ul></li></ul><h4 id=in-fly-sum---count-or-index>in fly (sum -> count or [index])<a hidden class=anchor aria-hidden=true href=#in-fly-sum---count-or-index>#</a></h4><ul><li>LC560<ul><li>基本款</li></ul></li><li>LC525<ul><li>與LC209不同這裡是每加一個都會產生變化</li><li>所以可以用in fly一邊建prefix sum，再找有沒有符合的</li><li>注意同一個sum我們只要<em>最前面</em>的</li></ul></li></ul><h3 id=monotonic-stack>Monotonic stack<a hidden class=anchor aria-hidden=true href=#monotonic-stack>#</a></h3><h4 id=用法-1>用法<a hidden class=anchor aria-hidden=true href=#用法-1>#</a></h4><ul><li>根據關注點不同有不同的看法<ul><li>排序，留下最後的字典序 (stk是重點)<ul><li><code>1 3 7 2</code></li><li><code>1 2</code><ul><li>可以看成<code>2</code>把3,7吃了，只留下該範圍最小的，這也是字典序的由來</li></ul></li><li>內容物:<ul><li>節點</li><li>區塊</li></ul></li></ul></li><li>夾出區間，中間是最大或是最小 (被pop的資料是重點)<ul><li><code>while stk and stk[-1] &lt;= n</code><ul><li><code>7 3 2 ..left.. 1 ..right.. 2</code><ul><li>right的所有數字都會小於1</li><li>left的所有數字都會等於1</li><li>1是這個區間(去頭尾)<strong>最大的</strong>，含頭尾的區間中的<strong>最小的</strong></li></ul></li></ul></li><li><code>while stk and stk[-1] >= n</code><ul><li><code>1 2 3 ..left.. 7 ..right.. 2</code><ul><li>right的所有數字都會大於7</li><li>left的所有數字都會等於7</li><li>7是這個區間<strong>最小的</strong>，含頭尾的區間中的<strong>最大的</strong></li></ul></li></ul></li><li>這樣就可以用<code>stk[-2]</code>與<code>n</code>，做出一個閉區間</li><li>記得處理沒有stk的case</li></ul></li></ul></li><li>在需要保持原本的順序、字典序、前面的資料會被後面的蓋掉時就可以老慮用用看</li></ul><h4 id=夾出區間>夾出區間<a hidden class=anchor aria-hidden=true href=#夾出區間>#</a></h4><ul><li>LC84<ul><li>經典</li><li>小的柱子會被大的蓋掉，只取小的<ul><li>用成圖: <code>1,1,1,...1, 2,3,4, 10</code></li></ul></li><li>很明顯就是monotonic stack<ul><li>取pop出的柱子去乘左右兩邊構成的區間長度</li></ul></li></ul></li><li>LC1130<ul><li>如果要最小一定是找最小的數字，之後是左右兩邊最小的<ul><li>化成圖: <code>a .left. min .right. b</code></li><li>有什麼辦法可以保證min一定是a~b之間最小的?<ul><li>monotonic stack<ul><li><code>while stk and stk[-1] &lt;= n</code></li></ul></li></ul></li><li>最後乘的時候要確認哪邊是小的!!</li></ul></li></ul></li><li>LC1793<ul><li>就是LC84</li><li>不過要在對的區間時才能更新答案<ul><li>這裡可以與LC402比<ul><li>402是控制pop<ul><li>TODO: 這樣stack的性質會是對的嗎?</li></ul></li><li>1793是控制更新答案</li></ul></li></ul></li></ul></li><li>LC1856<ul><li>區間中最小、又要連續<ul><li>化成圖: <code>7 3 2 ..left.. 1 ..right.. 2</code></li></ul></li><li>之後用prefix sum加速加總</li></ul></li><li>LC907<ul><li>區間中最小，monotonic stack<ul><li>化成圖: <code>1 2 3 ..left.. 7 ..right.. 2</code></li></ul></li></ul></li><li>LC42<ul><li>只要被兩個柱子夾起來的部份而已!!</li></ul></li></ul><h4 id=排序>排序<a hidden class=anchor aria-hidden=true href=#排序>#</a></h4><ul><li>LC402<ul><li>如果只是移除多的字以完成最小字典序不難就mono stack</li><li>但是有限制次數，所以不能一直pop</li></ul></li><li>LC316<ul><li>同樣是移除字完成最小字典序</li><li>但與LC402不同的是，這次是不能放入同樣的字<ul><li>注意到，這次條件是打在最外面</li><li>只要重複就連stack都不pop<ul><li>但402是還可以放數字到stack</li></ul></li></ul></li></ul></li><li>LC768<ul><li>這題把stack的sort具體化，這話怎麼說</li><li>前面提過小的會把大的吃掉，所以現在紀錄的是範圍最小</li><li>但這題最後要留下範圍最大的item</li></ul></li><li>LC901<ul><li>就是LC768</li><li>要記下區間最大值</li><li>不過這題還要區間長度</li></ul></li><li>LC581<ul><li>可以用LC768去生chunk，之後把頭尾去掉，把所有長度加起來</li><li>TODO: 但可以不用那麼麻煩</li></ul></li></ul><h4 id=下一個最大>下一個最大<a hidden class=anchor aria-hidden=true href=#下一個最大>#</a></h4><ul><li>LC503<ul><li>這是monotonic stack的經典展現</li><li>求下一個最大<ul><li>觸發pop的數字就是下一個最大</li></ul></li><li>circular?<ul><li>nums兩倍長就好</li></ul></li></ul></li><li>LC739<ul><li>求下一個最大之間的距離<ul><li>所以stack放index</li></ul></li><li>這裡會遇到一個有趣的case<ul><li><code>[1, 2, 2]</code>要怎麼處理?<ul><li>加等號: 會讓後面的2被吃掉</li><li>不加: 2留著</li></ul></li><li>怎麼叫更溫暖?<ul><li>大於，所以不加等號</li></ul></li></ul></li></ul></li></ul><h4 id=難>難<a hidden class=anchor aria-hidden=true href=#難>#</a></h4><ul><li>LC456<ul><li>這要認真推</li><li>先暴力<ul><li>原本<code>1&lt;2&lt;3</code></li><li>會從3開始找，之後2再來1</li><li>會從最大的開始找!!</li></ul></li><li>但現在<ul><li><code>1&lt;3&lt;2</code></li><li>這要從哪裡開始找?</li><li>先從大的開始，所以是2<ul><li>但怎麼確認3</li><li>(難的地方!!)<ul><li>從<em>後面</em>開始看</li><li>這樣會有<ul><li><code>1 1 1 2 3 3 3</code></li></ul></li></ul></li><li>之後是大小，2要大於3，最好會自動清<ul><li>monotonic stack</li><li>清出來的就是可能的2，而我們挑最大的</li><li>要等號嗎?<ul><li>不用!!</li><li>保留可能性</li></ul></li></ul></li></ul></li></ul></li><li>所以要做的是<ul><li>從後往前，塞stack (3的候補)</li><li>出現大的數字，清stack (2的候補)</li><li>剩下只要比對是不是符合132</li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find132pattern</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>stk</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=nb>reversed</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=n>mid</span> <span class=ow>and</span> <span class=n>stk</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>stk</span> <span class=ow>and</span> <span class=n>stk</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>mid</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>mid</span><span class=p>,</span><span class=n>stk</span><span class=o>.</span><span class=n>pop</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=n>stk</span> <span class=o>+=</span> <span class=n>n</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span></code></pre></div><ul><li>LC862<ul><li>區間總和，但是<ul><li>有負數</li><li>大於等於目標</li></ul></li><li>算區間和，prefix sum<ul><li>所以就一直記prefix sum，從最小的開始算和(queue)</li><li>如果sum太大怎麼辦<ul><li>所以要清 (stack，這不單調，只是要清總和太大的項目)</li></ul></li></ul></li></ul></li></ul><h3 id=binary-search>binary search<a hidden class=anchor aria-hidden=true href=#binary-search>#</a></h3><p>bsearch不一定要排序才能用
bsearch最好用左閉右開
注意mid會不會重複
用法</p><ul><li>找目標</li><li>猜數字</li><li>逼近 (LC4)</li></ul><h4 id=題目>題目<a hidden class=anchor aria-hidden=true href=#題目>#</a></h4><ul><li>LC162<ul><li>右邊的點要在答案中<ul><li>也就是重合時會等於的值</li></ul></li><li>往大的方向走<ul><li>就算沒有sort也可以用!!</li></ul></li></ul></li><li>LC4<ul><li>有sort也不一定看的出來可以用bsearch</li><li>這裡重點是長度<ul><li>每次把小的區段丟掉</li></ul></li></ul></li><li>LC1011<ul><li>猜每天要在多少重量</li><li>但範圍是重點<ul><li>太大會很慢</li><li>每一個貨物當成最重的重量，去算平均</li></ul></li></ul></li><li>LC33<ul><li>確認兩件事<ul><li>哪一塊是遞增的</li><li>目標在這一塊嗎</li></ul></li><li>另外<ul><li>如果長度是2，mid會輪迴!!</li></ul></li></ul></li><li>LC153<ul><li>對rotate的長度做bsearch</li></ul></li><li>LC327<ul><li>prefix sum + 不等式<ul><li>用lower bound與upper bound找index</li></ul></li></ul></li></ul><h3 id=sliding-window>sliding window<a hidden class=anchor aria-hidden=true href=#sliding-window>#</a></h3><h4 id=基本>基本<a hidden class=anchor aria-hidden=true href=#基本>#</a></h4><p>用<em>閉區間</em>做
列舉終點</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>win</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>b</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>fs</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=n>update_win</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>a</span> <span class=o>&lt;=</span> <span class=n>b</span> <span class=ow>and</span> <span class=n>when_win_is_illegal</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>shrink_win</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>update_ret</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div><p>列舉起點</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>win</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>a</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>fs</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>b</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>fs</span><span class=p>)</span> <span class=ow>and</span> <span class=n>when_win_is_legal</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>update_ret</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>expand_win</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>shrink_win</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div><p>atMost</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>atmost</span><span class=p>(</span><span class=n>bound</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span><span class=p>,</span><span class=n>n</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>update_win</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>j</span> <span class=ow>and</span> <span class=n>when_win_is_illegal</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>shrink_win</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=n>j</span><span class=o>-</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div><h4 id=題目-1>題目<a hidden class=anchor aria-hidden=true href=#題目-1>#</a></h4><ul><li>LC220<ul><li>這裡index的abs用sliding window處理</li><li>數字用不等式推論<ul><li>之後會看到lower bound</li></ul></li></ul></li><li>LC995<ul><li>這裡的重點是處理flip<ul><li>flip的問題<ul><li>現在是什麼bit</li><li>範圍到哪</li></ul></li><li>範圍就想到index<ul><li>所以要有方法追蹤有flip的index</li><li>並在超出範圍時刷掉<ul><li><em>queue做sliding window</em></li></ul></li></ul></li></ul></li></ul></li><li>LC713<ul><li>用sliding window找最靠近k的window</li><li>但接著就是怎麼算現在的window有多少組合?<ul><li>魔法: <code>right-left + 1</code></li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>totalFruit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>fs</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>win</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>b</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>fs</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>            <span class=n>win</span><span class=p>[</span><span class=n>fs</span><span class=p>[</span><span class=n>b</span><span class=p>]]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>a</span> <span class=o>&lt;=</span> <span class=n>b</span> <span class=ow>and</span> <span class=nb>len</span><span class=p>(</span><span class=n>win</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>win</span><span class=p>[</span><span class=n>fs</span><span class=p>[</span><span class=n>a</span><span class=p>]]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=n>win</span> <span class=o>+=</span> <span class=n>Counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=n>a</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=n>b</span><span class=o>-</span><span class=n>a</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div><ul><li>LC395<ul><li>長度是至少k<ul><li>所以不好當sliding window的條件</li><li>需要別的條件</li></ul></li><li>字母只有26個<ul><li><em>限制最多多少字母可以出現在window中!!</em></li></ul></li></ul></li><li>LC424<ul><li>怎麼找出有多少非法字<ul><li><em>總長度 = 最多的字 + 其他字</em></li></ul></li></ul></li><li>LC992<ul><li>新招式: atMost<ul><li>小於等於limit有多少組合</li></ul></li></ul></li><li>LC1234<ul><li>window中的東西可以亂生<ul><li>外面不超標的話就可以用window把string給平衡掉</li></ul></li></ul></li><li>LC1248<ul><li>可以用atMost</li><li>也可以之前的魔法<ul><li><code>right-left+1</code>是以此點為終點的組合數</li><li>之後就是在奇數到期時加到答案中</li></ul></li></ul></li></ul><h4 id=monotonic-queue>monotonic queue<a hidden class=anchor aria-hidden=true href=#monotonic-queue>#</a></h4><ul><li>LC239<ul><li>明顯是sliding window</li><li>但要最大值<ul><li>monotonic stack</li></ul></li><li>還要顧index<ul><li>deque</li></ul></li><li>兩個結合就是monotonic queue</li></ul></li></ul><h3 id=two-pointer>two pointer<a hidden class=anchor aria-hidden=true href=#two-pointer>#</a></h3><h4 id=linked-list-vs-array>linked list vs array<a hidden class=anchor aria-hidden=true href=#linked-list-vs-array>#</a></h4><ul><li>LC148<ul><li>只能用merge sort</li><li>因為不能隨機跳位置</li></ul></li><li>LC19<ul><li>這是list，一旦過了就回不去</li><li>但可以像找中點，讓兩個ptr之間保持距離</li><li>這裡是固定距離，中點是找兩倍</li></ul></li><li>LC61 & LC189<ul><li>先談rotate array<ul><li>一個是Cyclic replace (不好做)</li><li>另一個是<ul><li>reverse整條</li><li>reverse 0~k 與 reverse k~end</li></ul></li></ul></li><li>再談rotate list<ul><li>延續reverse的解法</li><li>第一次reverse是把後面的拉到前面</li><li>第二次reverse是把順序用成對的</li><li>但這裡是list，所以可以直接把list分成兩個</li><li>接上去就好</li></ul></li></ul></li></ul><h4 id=indexptr-as-list>index,ptr as list<a hidden class=anchor aria-hidden=true href=#indexptr-as-list>#</a></h4><ul><li>LC283<ul><li>一個ptr做為0的list的<em>終點</em></li><li>另一個ptr是還沒看過的item的list的<em>起點</em></li></ul></li><li>LC26<ul><li>同LC283</li><li>一個終點一個起點，一直換</li></ul></li><li>LC905<ul><li>類似LC283</li><li>但一個從array的頭，一個從尾塞</li></ul></li><li>LC75<ul><li>類似LC905</li><li>但要記得從後面換的部分還是屬於沒看過的部分，所以還要再看一次</li></ul></li><li>LC86<ul><li>把list分一半</li><li>兩個list指向list的<em>終點</em><ul><li>Linked list需要確保每次新增node時不會loop<ul><li>要記得把next設成None</li></ul></li></ul></li></ul></li><li>LC143<ul><li>類似LC86</li></ul></li></ul><h4 id=classic>classic<a hidden class=anchor aria-hidden=true href=#classic>#</a></h4><ul><li>LC142<ul><li>判圈<ul><li>一個走一倍，一個走兩倍</li><li>只要相遇就是圈</li></ul></li><li>圈的起點<ul><li>慢走的長度是<ul><li>起點到圈起點 + 某個數字*圈長度</li></ul></li><li>快走的長度是<ul><li>起點到圈起點 + 某個數字*圈長度</li></ul></li><li>兩個相減就會看到現在長度其實是<ul><li>圈長度的<em>整數倍</em></li><li>也就是說，不管從哪裡都可以算是圈的起點</li></ul></li><li>所以只要從起點走遇到另一個ptr就是圈的起點</li></ul></li></ul></li><li>LC15<ul><li>3sum<ul><li>從頭開始走剩下的部分做2sum</li></ul></li></ul></li><li>LC18<ul><li>nSum<ul><li>延伸3sum，直到只剩下2sum之前</li><li>都是當成3sum處理</li></ul></li></ul></li><li>LC876<ul><li>Linked List中點<ul><li>一個走一倍，一個走兩倍</li><li>另一個到終點，現在的就是中點<ul><li>根據跳出來的條件可以看長度是奇數還是偶數<ul><li>因<code>node.next</code>跳出來，偶數</li><li>因<code>node.next.next</code>跳出來，奇數</li></ul></li></ul></li></ul></li></ul></li><li>LC287<ul><li>有很多解法<ul><li>bsearch (猜數字)</li><li>注意到<em>資料都是在index的範圍</em>內<ul><li>可以用判圈</li><li>可以把資料換到對應的index上<ul><li>另外該資料也會是0~i之間最大的<ul><li>見chunk那一題</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id=misc>misc<a hidden class=anchor aria-hidden=true href=#misc>#</a></h4><ul><li>LC986<ul><li>merge interval可以</li><li>把兩個interval看頭尾，挑最靠近裡面的部分<ul><li>在最小中挑最大</li><li>在最大中挑最小</li><li>如果新interval的頭大於尾，這新interval就是非法的</li><li>每次都丟尾最小的</li></ul></li></ul></li><li>LC844<ul><li>上stack</li><li>直接從尾開始比，之後統計刪的次數，有counter時跳掉<ul><li>為什麼是尾開始<ul><li>delete往前刪</li><li>所以前面不會確定</li><li>但後面不會被影響</li></ul></li><li>有點像moore voting</li></ul></li></ul></li><li>LC763<ul><li>所有char都要在同一區</li><li>一次一次紀錄每個char最後出線的index</li><li>什麼時候才切成一區?<ul><li>當下的位置就是最後的位置時<ul><li>可以看chunk與LC287作對比</li></ul></li></ul></li></ul></li><li>LC42<ul><li>對於每個柱子，就是看<ul><li>左右都比自己高</li><li>挑矮的，算差距</li></ul></li><li>因為每次都只看最矮的<ul><li>所以可以像2sum去縮</li></ul></li></ul></li></ul><h3 id=heap>heap<a hidden class=anchor aria-hidden=true href=#heap>#</a></h3><ul><li>python原本只有heapq，十分不好用<ul><li>但是可以搭配已經sort好的list去用他的heappop與heappush<ul><li>LC352</li></ul></li></ul></li><li>可以用SordtedList好用超多，遠比C++的set或是map好用</li></ul><h3 id=divide-and-conquer>divide and conquer<a hidden class=anchor aria-hidden=true href=#divide-and-conquer>#</a></h3><ul><li>LC327<ul><li>右邊index一定大於左邊</li><li>針對每個左邊index找右邊符合需求的區間</li></ul></li><li>LC493<ul><li>TODO: 要看裡面怎麼用bit，感覺與divide and conquer有一點關係</li></ul></li></ul><h3 id=dynamic-programming>Dynamic programming<a hidden class=anchor aria-hidden=true href=#dynamic-programming>#</a></h3><h4 id=todo>TODO<a hidden class=anchor aria-hidden=true href=#todo>#</a></h4><ul><li>刷表法 & 填表法差別</li></ul><h4 id=用途>用途<a hidden class=anchor aria-hidden=true href=#用途>#</a></h4><ul><li>此點的狀態，像palindromic</li><li>到目前為止的總和，一般的dp都是以此為目標去求</li></ul><h4 id=from-start-or-end>from start or end<a hidden class=anchor aria-hidden=true href=#from-start-or-end>#</a></h4><ul><li>LC198<ul><li>dp可以從<ul><li>起點開始算<ul><li>要先把整個長度算好<ul><li>這是環狀<ul><li>長度兩倍</li></ul></li></ul></li></ul></li><li>終點算回去<ul><li>簡單很多!!<ul><li><code>max(self.ns[i] + self.dp(i-2), self.dp(i-1))</code></li></ul></li></ul></li></ul></li></ul></li><li>任何dp都建議從終點算回去</li></ul><h4 id=bottom-up-與-top-down>bottom-up 與 top-down<a hidden class=anchor aria-hidden=true href=#bottom-up-與-top-down>#</a></h4><ul><li>LC718<ul><li>如果用top-down<ul><li>除了要看字有沒有一樣</li><li>還要追蹤長度!!<ul><li>因為要連續</li><li><code>f(i,j,l)</code><ul><li><code>max(ret, f(i-1,j,0), f(i,j-1,0))</code><ul><li><code>ret = f(i-1,j-1,k+1) if s[i] == s[j] else k</code></li></ul></li></ul></li><li>這是n^3</li></ul></li></ul></li><li>用bottom-up<ul><li><code>dp[i][j] = dp[i-1][j-1]+1 if if s[i] == s[j] else 0</code></li><li>這是n^2</li><li>因為是長度所以比起top-down少很多東西</li></ul></li></ul></li><li>LC546<ul><li>真的什麼都想不到的話就是dp去模擬<ul><li>要什麼項目(參數、狀態定義)</li><li>怎麼轉換</li></ul></li><li><code>f(i,j,k)</code><ul><li>i,j是範圍</li><li>k是與j同顏色的盒子數量<ul><li>所以這裡就兩個case<ul><li>直接把所有盒子用掉，算分數</li><li>抓中點，去增加k的數量<ul><li><code>[dp(i,x,k+1)+dp(x+1,j-1,0) for x in range(i,j) if boxes[x] == boxes[j]]</code></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id=classic-1>classic<a hidden class=anchor aria-hidden=true href=#classic-1>#</a></h4><ul><li>LC72<ul><li>edit dist<ul><li>replace: <code>(i-1,j-1)</code></li><li>delete: <code>(i,j-1)</code></li><li>insert" <code>(i-1,j)</code><ul><li>insert多一個字，又馬上比對，所以與delete相反</li></ul></li></ul></li></ul></li><li>LC647<ul><li>palindromic<ul><li><code>s[i] == s[j] and ispalid(i+1,j-1)</code></li></ul></li><li>這題其實做從中心展開會比較好<ul><li>都是n^2，還比較簡單</li></ul></li></ul></li><li>LC516<ul><li>palindromic<ul><li>不用在失敗時結束，要把字刪掉<ul><li><code>max(dp(i+1,j),dp(i,j-1))</code></li></ul></li><li>剩下就是原本的dp</li></ul></li></ul></li><li>LC322<ul><li>coin<ul><li>有兩種<ul><li>一個是從背包抄來的<ul><li><code>f(total, i)</code><ul><li>一個是完全不用: <code>f(total, i-1)</code></li><li>一個是一直try: <code>f(total-arr[i]*n, i)</code></li></ul></li><li>這是n^2</li></ul></li><li>另一個是用total做狀態<ul><li><code>f(total)</code><ul><li>每個都try: <code>min([f(total-n) for n in arr])</code></li></ul></li><li>這個是n</li></ul></li></ul></li></ul></li></ul></li><li>LC139<ul><li>word break<ul><li>這不是教科書會出現的dp經典<ul><li>但是處理leetcode的字串列舉常常用到</li></ul></li><li><code>f(s)</code><ul><li>對bank的每個字比開頭<ul><li><code>f(s[len(w):])</code></li></ul></li><li>題外話<ul><li>bank的處理還有一個是用bfs配把字碼調<ul><li>像<code>*bc</code>、<code>a*b</code>、<code>ab*</code></li><li>處理換字能不能換成另一個字的問題<ul><li>再題外話<ul><li>像是倒水問題這種狀態變化固定的都可以用bfs找最短路徑<ul><li>但要把狀態定義好!!</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>LC152<ul><li>LIS<ul><li>這題是LIS的進化版<ul><li>原本是<ul><li><code>lis(i)</code><ul><li><code>max(arr[i], arr[i]+lis(i))</code></li></ul></li></ul></li><li>但負數也有可能會是選項!!<ul><li>所以要同時計min與max，不能像原版只用max</li></ul></li></ul></li></ul></li></ul></li><li>LC354<ul><li>LIS<ul><li>這題是二維LIS<ul><li>但要處理第一維同數字的問題<ul><li>第一維increasing排序</li><li>第二維decreasing排序</li></ul></li></ul></li></ul></li></ul></li><li>LC64<ul><li>棋盤<ul><li>就是看能往哪走<ul><li><code>f(i,j)</code><ul><li><code>grid[i][j]+min(f(i-1,j), f(i,j-1))</code></li></ul></li><li>建議都是用終點去推<ul><li>TODO: 有一題就是一定要用終點推</li></ul></li><li>如果用起點走就是dfs</li></ul></li></ul></li></ul></li><li>LC338<ul><li>奇偶<ul><li>偶: <code>2n</code></li><li>奇: <code>2n+1</code></li></ul></li><li>可以直接用!!</li></ul></li><li>LC96<ul><li>BST與range<ul><li>BST就是左邊小、右邊大<ul><li>所以有range</li></ul></li><li>BST是tree<ul><li>常用的dfs</li></ul></li></ul></li><li>在range上列舉中點，算組合數</li></ul></li></ul><h4 id=hard>hard<a hidden class=anchor aria-hidden=true href=#hard>#</a></h4><ul><li>LC87<ul><li>這種有明確標示動作與做reduction對象的都很簡單</li><li>但這題要注意swap的string可能還沒被比完!!<ul><li>要用<code>cache_computing</code></li></ul></li></ul></li><li>LC396<ul><li>把函數列出來<ul><li>找規律 (所以難，有緣就找的到)<ul><li><code>f(n) = f(n-1) - sum + len(arr)*arr[n-1]</code></li></ul></li></ul></li></ul></li><li>LC312<ul><li>如果用平常的作法<ul><li><code>f(i,j)</code>是i~j的最大分數就會變成兩邊<ul><li>十分痛苦</li></ul></li><li>要看成<ul><li>這區域的氣球都爆完的分數有多少<ul><li>列舉要爆的氣球<ul><li><code>max( nums[left] * nums[i] * nums[right] + dp(left, i) + dp(i, right) for i in range(left+1, right) )</code></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>LC926<ul><li>分成ones與zeros就可以看出要用prefix sum</li><li>如果要用dp，就要看怎麼建構合法的答案<ul><li>最後一位如果是1，可以直接接上去</li><li>如果是0，不是把前面的1換成0，就是把自己這一位換成1</li></ul></li></ul></li><li>LC600<ul><li><code>f(i)</code>i位數的合法組合數 (沒有連續1)<ul><li>以5為例<ul><li><code>10 111 ~ 10 000</code>: <code>f(3)</code></li><li><code>0 1111 ~ 0 0000</code>: <code>f(4)</code><ul><li><code>11 111 ~ 11 000</code>非法</li><li><code>01 111 ~ 01 000</code>會被包含</li></ul></li><li><code>f(i) = f(i-1)+f(i-2)</code></li></ul></li><li>所以剩下就是從最高位往下加<code>f(k)</code></li><li>同時看有沒有連續1出現!!</li></ul></li></ul></li><li>LC44<ul><li>其實就是用string比對處理(edit dist)</li><li>但要注意最後pat只剩下star的狀態!!</li></ul></li><li>LC188<ul><li>能用到mutual recursion!!</li><li>定義<code>buy(i,k)</code>and<code>sell(i,k)</code><ul><li>分別定義<ul><li><code>buy(i,k)</code>: 在i時還有k次購買機會的購買的最大收益<ul><li><code>buy(i-1,k)</code></li><li><code>sell(i-k,k-1)-arr[i]</code></li></ul></li><li><code>sell(i,k)</code>: 在i時還有k次購買機會的賣出的最大收益<ul><li><code>sell(i-1,k)</code></li><li><code>buy(i-k,k)+arr[i]</code></li></ul></li></ul></li></ul></li><li>另外也可以用挑區段，去接來看</li><li>如果當成lis去看，之後跑k次<ul><li>分成歷史上的最大(global)與當前的最大(local)</li><li>之後就是用lis更新local</li><li>之後更新global<ul><li><code>local = max(global[i], local + prices[i] - prices[i-1])</code></li><li><code>global[i] = max(global[i-1], local)</code></li></ul></li></ul></li><li>另外。LC122<ul><li>最高到最低的總和就是各個區段的總和</li><li>所以就是在increasing時把所有差額加起來</li></ul></li></ul></li><li>LC376<ul><li>這題對我有因緣</li><li>因為是用自己的dp過的<ul><li>先過整條array看是increasing還是decreasing</li><li>之後根據方向，跑lis</li></ul></li><li>因為有兩個方向，所以可以定義mutual recursion<ul><li><code>arr[i-1] > arr[i]</code><ul><li><code>up[i] = down[i-1]+1</code></li><li><code>down[i] = down[i-1]</code></li></ul></li><li><code>arr[i-1] &lt; arr[i]</code><ul><li><code>up[i] = up[i-1]</code></li><li><code>down[i] = up[i-1]+1</code></li></ul></li><li><code>arr[i-1] == arr[i]</code><ul><li><code>up[i] = up[i-1]</code></li><li><code>down[i] = down[i-1]</code></li></ul></li></ul></li></ul></li></ul><h3 id=line-sweap>line sweap<a hidden class=anchor aria-hidden=true href=#line-sweap>#</a></h3><ul><li>把起終點分開，<code>[start, -height], [end, height]</code></li><li>根據位置與高度排序</li><li>之後一個一個走<ul><li>把高度塞到heap中 (line sweap)<ul><li>負的就塞</li><li>正的就去刪</li></ul></li><li>之後就是用heap去確認當前高度，去調整答案</li></ul></li></ul><h4 id=elegant-sol>elegant sol<a hidden class=anchor aria-hidden=true href=#elegant-sol>#</a></h4><ul><li>這裡是收集一些原本用dp但是有超級優雅的解</li><li>LC828<ul><li>from lee215</li><li><code>AXXXAXXA</code><ul><li>看中間的A到左右兩邊的A隔3與2個字元(4與3個洞)</li><li>所以只包含中間A的組合是12</li></ul></li><li>所以只要針對所有字元中間的洞算組合數就好!!</li></ul></li><li>LC1569<ul><li>這是BST，有左右兩邊</li><li>而我們有第一個點，root</li><li>可以分左右兩邊</li><li>算組合數: <code>comb(len(right)+len(left), len(right))*f(right)*f(left)</code></li></ul></li><li>LC678<ul><li>把所有星號當成左括號，去計數，如果左括號太少，就直接False</li><li>把所有星號當成右括號，去計數，全部跑完，看有沒有被扣完</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/07/linked-list%E7%9A%84faq/><span class=title>« Prev</span><br><span>linked-list的faq</span>
</a><a class=next href=https://littlebees.github.io/2021/07/a-little-java-a-few-patterns%E7%AD%86%E8%A8%98/><span class=title>Next »</span><br><span>A little java, a few patterns筆記</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>