<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-621 - Task Scheduler | 記事本</title>
<meta name=keywords content="Counting,Heap (Priority Queue),Sorting,Greedy,Hash Table,Array,seanprashad,Top 100 Liked Questions"><meta name=description content="動機
以為要算所有組合數&mldr;"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/07/leetcode-621-task-scheduler/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/07/leetcode-621-task-scheduler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-621 - Task Scheduler"><meta property="og:description" content="動機
以為要算所有組合數&mldr;"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/07/leetcode-621-task-scheduler/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-24T16:02:28+00:00"><meta property="article:modified_time" content="2021-07-24T16:02:28+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-621 - Task Scheduler"><meta name=twitter:description content="動機
以為要算所有組合數&mldr;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-621 - Task Scheduler","item":"https://littlebees.github.io/2021/07/leetcode-621-task-scheduler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-621 - Task Scheduler","name":"leetcode-621 - Task Scheduler","description":"動機 以為要算所有組合數\u0026hellip;\n","keywords":["Counting","Heap (Priority Queue)","Sorting","Greedy","Hash Table","Array","seanprashad","Top 100 Liked Questions"],"articleBody":"動機 以為要算所有組合數…\nProblem Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\nHowever, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\nExample 1:\nInput: tasks = [A,A,A,B,B,B], n = 2Output: 8Explanation: A -\u003e B -\u003e idle -\u003e A -\u003e B -\u003e idle -\u003e A -\u003e BThere is at least 2 units of time between any two same tasks.Example 2:\nInput: tasks = [A,A,A,B,B,B], n = 0Output: 6Explanation: On this case any permutation of size 6 would work since n = 0.[A,A,A,B,B,B][A,B,A,B,A,B][B,B,B,A,A,A]...And so on.Example 3:\nInput: tasks = [A,A,A,A,A,A,B,C,D,E,F,G], n = 2Output: 16Explanation: One possible solution isA -\u003e B -\u003e C -\u003e A -\u003e D -\u003e E -\u003e A -\u003e F -\u003e G -\u003e A -\u003e idle -\u003e idle -\u003e A -\u003e idle -\u003e idle -\u003e A Constraints:\n1 \u003c= task.length \u003c= 104tasks[i] is upper-case English letter.The integer n is in the range [0, 100]. Sol: queue 就是直接塞到queue，queue的大小就是n，一直從最多任務的開始挑\nclass Solution: def leastInterval(self, tasks: List[str], n: int) -\u003e int: q = deque() inQ = set() count = {} times = len(tasks) ret = 0 for (k,v) in dict(Counter(tasks)).items(): if v in count: count[v].add(k) else: count[v] = set([k]) while count: #print(count) nextTask = None index = None for k in sorted(count.keys(),reverse=True): for key in count[k]: if key not in inQ: nextTask = key break if nextTask: index = k break if nextTask: count[index].remove(nextTask) if not count[index]: del count[index] if index-1 \u003e 0: if index-1 not in count: count[index-1] = set() count[index-1].add(nextTask) q.append(nextTask) inQ.add(nextTask) else: q.append('idle') if len(q) \u003e n: task = q.popleft() if task != 'idle': inQ.remove(task) #print(q,heap) ret += 1 return ret Sol 先統計task的個數，找task最多出現幾次(mx)，這樣就會分出總共有幾組，因為最多的task一定會留到最後一組卻塞不滿，這樣就會有mx-1組\nmx = 3 A__ A__ A 接著算一組可以塞多少個，每一組都有一個最多的task，所以剩下的n個空格，不管有沒有都要留，因此每一組可以塞n+1個\nmx = 3 n = 2 A _ _ A _ _ A 最後就是塞不滿的總數有多少，就是看最多的task有幾種\nmx = 3 n = 2 rest = 1 A _ _ A _ _ A =\u003e (mx-1) * (n+1) + rest 但要注意，如果任務總數比算出來的數字少，最少就是要任務總數的時間\n但我們只是要求時間長度，所以我們假設最多的task加上多的格子(要等的時間，所以我們可以塞別的task)可以塞完其他task，如果塞不完?\n就一定要整條跑完，因為n沒得塞\n最後就是\n(n+1): 要等的時間+最多的task一個 (mx-1): 最多的task的task數量減一，成為(n+1)的個數 rest: 最多的task的總數，最後一定會剩下最多的task等著去做\nclass Solution: def leastInterval(self, tasks: List[str], n: int) -\u003e int: # 假設最後剩下來的task是最多的task，如果其他task多到漫出來，就是全跑 ts = Counter(tasks) mx = ts.most_common(1)[0][1] # task數 rest = Counter(ts.values())[mx] # 最多task的task的數量 return max(len(tasks), (n+1)*(mx-1)+rest) ","wordCount":"435","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-07-24T16:02:28Z","dateModified":"2021-07-24T16:02:28Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/07/leetcode-621-task-scheduler/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-621 - Task Scheduler</h1><div class=post-meta><span title='2021-07-24 16:02:28 +0000 UTC'>July 24, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol-queue aria-label="Sol: queue">Sol: queue</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>以為要算所有組合數&mldr;</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>Given a characters array <code>tasks</code>, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.</p><p>However, there is a non-negative integer <code>n</code> that represents the cooldown period between two <b>same tasks</b> (the same letter in the array), that is that there must be at least <code>n</code> units of time between any two same tasks.</p><p>Return <em>the least number of units of times that the CPU will take to finish all the given tasks</em>.</p><p> </p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> tasks = [A,A,A,B,B,B], n = 2<strong>Output:</strong> 8<strong>Explanation:</strong> A -> B -> idle -> A -> B -> idle -> A -> BThere is at least 2 units of time between any two same tasks.</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> tasks = [A,A,A,B,B,B], n = 0<strong>Output:</strong> 6<strong>Explanation:</strong> On this case any permutation of size 6 would work since n = 0.[A,A,A,B,B,B][A,B,A,B,A,B][B,B,B,A,A,A]...And so on.</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> tasks = [A,A,A,A,A,A,B,C,D,E,F,G], n = 2<strong>Output:</strong> 16<strong>Explanation:</strong> One possible solution isA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= task.length <= 10<sup>4</sup></code></li><li><code>tasks[i]</code> is upper-case English letter.</li><li>The integer <code>n</code> is in the range <code>[0, 100]</code>.</li></ul><h2 id=sol-queue>Sol: queue<a hidden class=anchor aria-hidden=true href=#sol-queue>#</a></h2><p>就是直接塞到queue，queue的大小就是n，一直從最多任務的開始挑</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>leastInterval</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tasks</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>],</span> <span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>q</span> <span class=o>=</span> <span class=n>deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>inQ</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=n>times</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>dict</span><span class=p>(</span><span class=n>Counter</span><span class=p>(</span><span class=n>tasks</span><span class=p>))</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>count</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>count</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=nb>set</span><span class=p>([</span><span class=n>k</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>#print(count)</span>
</span></span><span class=line><span class=cl>            <span class=n>nextTask</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>            <span class=n>index</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>count</span><span class=o>.</span><span class=n>keys</span><span class=p>(),</span><span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>key</span> <span class=ow>in</span> <span class=n>count</span><span class=p>[</span><span class=n>k</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>key</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>inQ</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>nextTask</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>nextTask</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>index</span> <span class=o>=</span> <span class=n>k</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nextTask</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>count</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>nextTask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=ow>not</span> <span class=n>count</span><span class=p>[</span><span class=n>index</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=k>del</span> <span class=n>count</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>index</span><span class=o>-</span><span class=mi>1</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>index</span><span class=o>-</span><span class=mi>1</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>count</span><span class=p>[</span><span class=n>index</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=n>count</span><span class=p>[</span><span class=n>index</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>nextTask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nextTask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>inQ</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>nextTask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;idle&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>q</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>task</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>task</span> <span class=o>!=</span> <span class=s1>&#39;idle&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>inQ</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>#print(q,heap)</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><p>先統計task的個數，找task最多出現幾次(mx)，這樣就會分出總共有幾組，因為最多的task一定會留到最後一組卻塞不滿，這樣就會有<code>mx-1</code>組</p><pre tabindex=0><code>mx = 3
A__ A__ A
</code></pre><p>接著算一組可以塞多少個，每一組都有一個最多的task，所以剩下的n個空格，不管有沒有都要留，因此每一組可以塞<code>n+1</code>個</p><pre tabindex=0><code>mx = 3
n = 2
A _ _ A _ _ A
</code></pre><p>最後就是塞不滿的總數有多少，就是看最多的task有幾種</p><pre tabindex=0><code>mx = 3
n = 2
rest = 1
A _ _ A _ _ A
=&gt;
(mx-1) * (n+1) + rest
</code></pre><p>但要注意，如果任務總數比算出來的數字少，最少就是要任務總數的時間</p><p>但我們只是要求時間長度，所以我們假設<em>最多的task加上多的格子(要等的時間，所以我們可以塞別的task)可以塞完其他task</em>，如果塞不完?</p><p>就一定要整條跑完，因為n沒得塞</p><p>最後就是</p><p><code>(n+1)</code>: 要等的時間+最多的task一個
<code>(mx-1)</code>: 最多的task的task數量減一，成為<code>(n+1)</code>的個數
<code>rest</code>: 最多的task的總數，最後一定會剩下最多的task等著去做</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>leastInterval</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tasks</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>],</span> <span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 假設最後剩下來的task是最多的task，如果其他task多到漫出來，就是全跑</span>
</span></span><span class=line><span class=cl>        <span class=n>ts</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=n>tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>mx</span> <span class=o>=</span> <span class=n>ts</span><span class=o>.</span><span class=n>most_common</span><span class=p>(</span><span class=mi>1</span><span class=p>)[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=c1># task數</span>
</span></span><span class=line><span class=cl>        <span class=n>rest</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=n>ts</span><span class=o>.</span><span class=n>values</span><span class=p>())[</span><span class=n>mx</span><span class=p>]</span> <span class=c1># 最多task的task的數量</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>tasks</span><span class=p>),</span> <span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>mx</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=n>rest</span><span class=p>)</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/counting/>Counting</a></li><li><a href=https://littlebees.github.io/tags/heap-priority-queue/>Heap (Priority Queue)</a></li><li><a href=https://littlebees.github.io/tags/sorting/>Sorting</a></li><li><a href=https://littlebees.github.io/tags/greedy/>Greedy</a></li><li><a href=https://littlebees.github.io/tags/hash-table/>Hash Table</a></li><li><a href=https://littlebees.github.io/tags/array/>Array</a></li><li><a href=https://littlebees.github.io/tags/seanprashad/>Seanprashad</a></li><li><a href=https://littlebees.github.io/tags/top-100-liked-questions/>Top 100 Liked Questions</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/07/leetcode-114-flatten-binary-tree-to-linked-list/><span class=title>« Prev</span><br><span>leetcode-114 - Flatten Binary Tree to Linked List</span>
</a><a class=next href=https://littlebees.github.io/2021/07/leetcode-199-binary-tree-right-side-view/><span class=title>Next »</span><br><span>leetcode-199 - Binary Tree Right Side View</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>