<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-211 - Design Add and Search Words Data Structure | 記事本</title>
<meta name=keywords content="Trie,Design,Depth-First Search,String,Blind Curated 75"><meta name=description content="動機
原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!
重點是這樣居然比較快!! (in Py)"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/01/leetcode-211-design-add-and-search-words-data-structure/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/01/leetcode-211-design-add-and-search-words-data-structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-211 - Design Add and Search Words Data Structure"><meta property="og:description" content="動機
原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!
重點是這樣居然比較快!! (in Py)"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/01/leetcode-211-design-add-and-search-words-data-structure/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-30T00:35:42+00:00"><meta property="article:modified_time" content="2021-01-30T00:35:42+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-211 - Design Add and Search Words Data Structure"><meta name=twitter:description content="動機
原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!
重點是這樣居然比較快!! (in Py)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-211 - Design Add and Search Words Data Structure","item":"https://littlebees.github.io/2021/01/leetcode-211-design-add-and-search-words-data-structure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-211 - Design Add and Search Words Data Structure","name":"leetcode-211 - Design Add and Search Words Data Structure","description":"動機 原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!\n重點是這樣居然比較快!! (in Py)\n","keywords":["Trie","Design","Depth-First Search","String","Blind Curated 75"],"articleBody":"動機 原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!\n重點是這樣居然比較快!! (in Py)\nProblem Design a data structure that supports adding new words and finding if a string matches any previously added string.\nImplement the WordDictionary class:\nWordDictionary() Initializes the object.void addWord(word) Adds word to the data structure, it can be matched later.bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter. Example:\nInput[WordDictionary,addWord,addWord,addWord,search,search,search,search][[],[bad],[dad],[mad],[pad],[bad],[.ad],[b..]]Output[null,null,null,null,false,true,true,true]ExplanationWordDictionary wordDictionary = new WordDictionary();wordDictionary.addWord(bad);wordDictionary.addWord(dad);wordDictionary.addWord(mad);wordDictionary.search(pad); // return FalsewordDictionary.search(bad); // return TruewordDictionary.search(.ad); // return TruewordDictionary.search(b..); // return True Constraints:\n1 \u003c= word.length \u003c= 500word in addWord consists lower-case English letters.word in search consist of '.' or lower-case English letters.At most 50000 calls will be made to addWord and search. Sol 用trie與dfs\ndef dfs(word,trie): tmp = trie for i in range(len(word)): if word[i] == \".\": for k in tmp[1].keys(): if dfs(word[i+1:],tmp[1][k]): return True return False elif word[i] in tmp[1]: tmp = tmp[1][word[i]] else: return False return tmp[0] class WordDictionary: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.trie = [False, {}] def addWord(self, word: str) -\u003e None: tmp = self.trie for c in word: if c not in tmp[1]: tmp[1][c] = [False, {}] tmp = tmp[1][c] tmp[0] = True def search(self, word: str) -\u003e bool: return dfs(word,self.trie) case study 把同長度的單字放在一起，之後就直接比\n這樣在python居然比較快!?\nclass WordDictionary: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.d = defaultdict(set) def addWord(self, word: str) -\u003e None: self.d[len(word)].add(word) def search(self, word: str) -\u003e bool: s = self.d[len(word)] if '.' not in word: return word in s def match(a, b): for i in range(len(a)): if a[i] != '.' and a[i] != b[i]: # word not match return False return True for w in s: if match(word, w): return True return False ","wordCount":"290","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-01-30T00:35:42Z","dateModified":"2021-01-30T00:35:42Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/01/leetcode-211-design-add-and-search-words-data-structure/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-211 - Design Add and Search Words Data Structure</h1><div class=post-meta><span title='2021-01-30 00:35:42 +0000 UTC'>January 30, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li><li><a href=#case-study aria-label="case study">case study</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>原本就直接用trie，但看了別的解答才發現可以看長度來區分再直接比!!</p><p>重點是這樣居然比較快!! (in Py)</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p><p>Implement the <code>WordDictionary</code> class:</p><ul><li><code>WordDictionary()</code> Initializes the object.</li><li><code>void addWord(word)</code> Adds <code>word</code> to the data structure, it can be matched later.</li><li><code>bool search(word)</code> Returns <code>true</code> if there is any string in the data structure that matches <code>word</code> or <code>false</code> otherwise. <code>word</code> may contain dots <code>'.'</code> where dots can be matched with any letter.</li></ul><p> </p><p><strong>Example:</strong></p><pre><strong>Input</strong>[WordDictionary,addWord,addWord,addWord,search,search,search,search][[],[bad],[dad],[mad],[pad],[bad],[.ad],[b..]]<strong>Output</strong>[null,null,null,null,false,true,true,true]<strong>Explanation</strong>WordDictionary wordDictionary = new WordDictionary();wordDictionary.addWord(bad);wordDictionary.addWord(dad);wordDictionary.addWord(mad);wordDictionary.search(pad); // return FalsewordDictionary.search(bad); // return TruewordDictionary.search(.ad); // return TruewordDictionary.search(b..); // return True</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= word.length <= 500</code></li><li><code>word</code> in <code>addWord</code> consists lower-case English letters.</li><li><code>word</code> in <code>search</code> consist of  <code>'.'</code> or lower-case English letters.</li><li>At most <code>50000</code> calls will be made to <code>addWord</code> and <code>search</code>.</li></ul><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><p>用trie與dfs</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=n>trie</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>tmp</span> <span class=o>=</span> <span class=n>trie</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>word</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>word</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;.&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>dfs</span><span class=p>(</span><span class=n>word</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:],</span><span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>k</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>word</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=ow>in</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>word</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>WordDictionary</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Initialize your data structure here.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>trie</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>,</span> <span class=p>{}]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>addWord</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>word</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>trie</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>word</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>c</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>,</span> <span class=p>{}]</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>word</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dfs</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=bp>self</span><span class=o>.</span><span class=n>trie</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=case-study>case study<a hidden class=anchor aria-hidden=true href=#case-study>#</a></h2><p>把同長度的單字放在一起，之後就直接比</p><p>這樣在python居然比較快!?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>WordDictionary</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Initialize your data structure here.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>d</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>set</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>addWord</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>word</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>d</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>word</span><span class=p>)]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>word</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>word</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>d</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>word</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=s1>&#39;.&#39;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>word</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>word</span> <span class=ow>in</span> <span class=n>s</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>match</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>a</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=s1>&#39;.&#39;</span> <span class=ow>and</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># word not match</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=n>s</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=k>match</span><span class=p>(</span><span class=n>word</span><span class=p>,</span> <span class=n>w</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/trie/>Trie</a></li><li><a href=https://littlebees.github.io/tags/design/>Design</a></li><li><a href=https://littlebees.github.io/tags/depth-first-search/>Depth-First Search</a></li><li><a href=https://littlebees.github.io/tags/string/>String</a></li><li><a href=https://littlebees.github.io/tags/blind-curated-75/>Blind Curated 75</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/01/leetcode-324-wiggle-sort-ii/><span class=title>« Prev</span><br><span>leetcode-324 - Wiggle Sort II</span>
</a><a class=next href=https://littlebees.github.io/2021/01/leetcode-373-find-k-pairs-with-smallest-sums/><span class=title>Next »</span><br><span>leetcode-373 - Find K Pairs with Smallest Sums</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>