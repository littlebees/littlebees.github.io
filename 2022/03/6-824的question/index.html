<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>6-824的question | 記事本</title>
<meta name=keywords content="Distributed"><meta name=description content="動機
當成複習"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2022/03/6-824%E7%9A%84question/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2022/03/6-824%E7%9A%84question/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="6-824的question"><meta property="og:description" content="動機
當成複習"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2022/03/6-824%E7%9A%84question/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-17T11:02:41+00:00"><meta property="article:modified_time" content="2022-03-17T11:02:41+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="6-824的question"><meta name=twitter:description content="動機
當成複習"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"6-824的question","item":"https://littlebees.github.io/2022/03/6-824%E7%9A%84question/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"6-824的question","name":"6-824的question","description":"動機 當成複習\n","keywords":["Distributed"],"articleBody":"動機 當成複習\nGFS Describe a sequence of events that would result in a client reading stale data from the Google File System.\n就是這張圖 只要一個secondary沒有寫到，primary只會回fail，之後client retry，就有了這個畫面。\nVM FT How does VM FT handle network partitions? That is, is it possible that if the primary and the backup end up in different network partitions that the backup will become a primary too and the system will run with two primaries?\nTest-and-Set，有搶到就當leader，沒搶到就自己放棄\nraft Suppose we have the scenario shown in the Raft paper’s Figure 7: a cluster of seven servers, with the log contents shown. The first server crashes (the one at the top of the figure), and cannot be contacted. A leader election ensues. For each of the servers marked (a), (d), and (f), could that server be elected? If yes, which servers would vote for it? If no, what specific Raft mechanism(s) would prevent it from being elected?\n上requestVote的code\nfunc (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) { rf.Lock() lastIdx := rf.getLastLogIdxX() lastTerm := rf.getLogTermX(lastIdx) if args.Term \u003c rf.Term { reply.VoteGranted = false } else { if args.Term \u003e rf.Term { rf.setFollowerX(args.Term, -1) } if rf.VoteFor != -1 \u0026\u0026 rf.VoteFor != args.Id || !(lastTerm \u003c args.AtTerm || lastTerm == args.AtTerm \u0026\u0026 lastIdx \u003c= args.AtIndex) { reply.VoteGranted = false } else { reply.VoteGranted = true //DPrintf(\"(%v) [RequestVote] accept1 args:%v log:%v\", rf.Me, args, rf.Log) rf.setFollowerX(args.Term, args.Id) rf.resetElectionTimer() } } reply.Term = rf.Term rf.Unlock() } 省略，term與投過的case，重點是 !(lastTerm \u003c args.AtTerm || lastTerm == args.AtTerm \u0026\u0026 lastIdx \u003c= args.AtIndex)\n看最後一個log的term 最後一個log的term一樣就比長度 a會拿到b, e, f的票，所以可以成為leader d任何票都拿的到，所以可以成為leader f最後一個log的term比任何人都小，不可能成為leader\nCould a received InstallSnapshot RPC cause the state machine to go backwards in time? That is, could step 8 in Figure 13 cause the state machine to be reset so that it reflects fewer executed operations? If yes, explain how this could happen. If no, explain why it can’t happen.\n根據Log Matching，entry的index與term不會變 根據Leader Completeness，被commit的entry之後都會在log中 根據State Machine Safety，被apply之後就不會被apply別的entry\n也就是說，commit過的log等於state machine\n因為installSnapshot是只trim commit過的log，所以reset state machine沒差\nZookeeper One use of Zookeeper is as a fault-tolerant lock service (see the section “Simple locks” on page 6). Why isn’t possible for two clients to acquire the same lock? In particular, how does Zookeeper decide if a client has failed and it can give the client’s locks to other clients?\n就flock 用EPHEMERAL創個檔案，exist就是有人上鎖。 其他要等的就是上watch，之後就算lock holder出事zookeeper也會自己清這個檔案(鎖)，其他人透過watch知道unlock\nChain Replication Suppose Chain Replication replied to update requests from the head, as soon as the next chain server said it received the forwarded update, instead of responding from the tail. Explain how that could cause Chain Replication to produce results that are not linearizable.\n這個就與raft沒有等到過半就commit一樣 如果不是最後一個好了才reply，有可能中間出事之後後面的server就會少這筆write\nDistributed Transactions 6.033 Book. Read just these parts of Chapter 9: 9.1.5, 9.1.6, 9.5.2, 9.5.3, 9.6.3. The last two sections (on two-phase locking and distributed two-phase commit) are the most important. The Question: describe a situation where Two-Phase Locking yields higher performance than Simple Locking.\nSimple Locking: 先全拿lock，再跑，之後全放 Two-Phase Locking: 一個一個拿，等跑完，再一個一個放\nA: read x, write y B: read y\nsimple會變成B要等A做完才能跑(或是A等B) 2PL可以是先read x(A), read y(B), write y(A)\nSpanner Spanner Suppose a Spanner server’s TT.now() returns correct information, but the uncertainty is large. For example, suppose the absolute time is 10:15:30, and TT.now() returns the interval [10:15:20,10:15:40]. That interval is correct in that it contains the absolute time, but the error bound is 10 seconds. See Section 3 for an explanation TT.now(). What bad effect will a large error bound have on Spanner’s operation? Give a specific example.\nr/w commit要等到他的timestamp結束，所以誤差越大r/w commit要等越久\nFrangipani Suppose a server modifies an i-node, appends the modification to its log, then another server modifies the same i-node, and then the first server crashes. The recovery system will see the i-node modification in the crashed server’s log, but should not apply that log entry to the i-node, because that would un-do the second server’s change. How does Frangipani avoid or cope with this situation?\n有人需要某個檔案是被已經crash的server改過的會怎樣?\nFrangipani的client在改file之前會把op送到Petal的log，所有crash有兩個case\n有log 沒log 有log就讓要求lock的server去replay 沒有log就直接上\nreplay就帶來現在問的問題，如果多台(其中有crash的)改到同一個file怎麼辦? 怎麼處理衝突?\n檔案(inode)有版本號，所有op都有版本號+1，這樣只要op的版本號小於inode的，就不用管\nCOPS The last sentence in Section 4.3 says a client clears its context after a put, replacing the context with just the put. The text observes “This put depends on all previous key-version pairs and thus is nearer than them.” Why does clearing the context and replacing it with just the put make sense? You might think that the client’s subsequent puts would need to carry along the dependency information about previous gets. What entity ultimately uses the context information, and why does it not need the information about gets before the last put?\n回想raft的snahpshot的問題，為什麼snapshot不會讓state machine後退? 因為snapshot的都是commited的log\n在這裡log就是context，也就是執行過的指令(所以有遞移性)。 一旦執行完成就是commited，所以可以刪掉(因為狀態被改變了，前面的也沒用了)\n那為什麼讀的指令要保留? 讓後面的讀可以知道前面的讀已經發生，確保順序 (可以配合SUNDR的question一起看)\nFaRM Suppose there are two FaRM transactions that both increment the same object. They start at the same time and see the same initial value for the object. One transaction completely finishes committing (see Section 4 and Figure 4). Then the second transaction starts to commit. There are no failures. What is the evidence that FaRM will use to realize that it must abort the second transaction? At what point in the Section 4 / Figure 4 protocol will FaRM realize that it must abort?\nFaRM是樂觀鎖，所以它會讓其他人做事，出事(FaRM透過檢查確認出事)再retry 悲觀鎖是先讓對方等\nFaRM前面有兩個檢查階段\nLOCK VALIDATE 都會檢查lock與資料的版本號 LOCK可以當成是檢查寫過的 VALIDATE是有讀到的\n這題是在同一個變數做++，所以在LOCK會被abort\nMemcache at Facebook Section 3.3 implies that a client that writes data does not delete the corresponding key from the Gutter servers, even though the client does try to delete the key from the ordinary Memcached servers (Figure 1). Explain why it would be a bad idea for writing clients to delete keys from Gutter servers.\ngutter是備援選手，在主server出事時接手 同時cache的目的是不要讓大量traffic打爆backend\n所以回答問題，為什麼不用invalidate gutter? gutter的key的過期時間很短，取代invalidate，雖然說會有一點stale data，但這樣可以確保backend不會被打爆\nSUNDR In the simple straw-man, both fetch and modify operations are placed in the log and signed. Suppose an alternate design that only signs and logs modify operations. Does this allow a malicious server to break fetch-modify consistency or fork consistency? Why or why not?\n可以回去想為什麼raft的read要過raft的共識 如果沒有過共識，read可能拿到缺了某些write的state\nSpark What applications can Spark support well that MapReduce/Hadoop cannot support?\n密集運算或是需要反覆r/w的場合\nBitcoin Try to buy something with Bitcoin. It may help to cooperate with some 6.824 class-mates, and it may help to start a few days early. If you decide to give up, that’s OK. Briefly describe your experience.\n沒$，跳過\nBlockstack Why is it important that Blockstack names be unique, human-readable, and decentralized? Why is providing all three properties hard?\n因為name是識別user的方法，也是資安的開始，所以重要\nunique: 不能重複 human-readable: 方便使用 decentralized: 解釋權不被壟斷\nhuman-readable + decentralized: 自己的筆記 human-readable + unique: email unique + decentralized: public key\ncentralized很像root folder，在裡面可以human-readable與unique 一但decentralized就很容易撞名\n","wordCount":"1027","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2022-03-17T11:02:41Z","dateModified":"2022-03-17T11:02:41Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2022/03/6-824%E7%9A%84question/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">6-824的question</h1><div class=post-meta><span title='2022-03-17 11:02:41 +0000 UTC'>March 17, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#gfs aria-label=GFS>GFS</a></li><li><a href=#vm-ft aria-label="VM FT">VM FT</a></li><li><a href=#raft aria-label=raft>raft</a></li><li><a href=#zookeeper aria-label=Zookeeper>Zookeeper</a></li><li><a href=#chain-replication aria-label="Chain Replication">Chain Replication</a></li><li><a href=#distributed-transactions aria-label="Distributed Transactions">Distributed Transactions</a></li><li><a href=#spanner aria-label=Spanner>Spanner</a></li><li><a href=#frangipani aria-label=Frangipani>Frangipani</a></li><li><a href=#cops aria-label=COPS>COPS</a></li><li><a href=#farm aria-label=FaRM>FaRM</a></li><li><a href=#memcache-at-facebook aria-label="Memcache at Facebook">Memcache at Facebook</a></li><li><a href=#sundr aria-label=SUNDR>SUNDR</a></li><li><a href=#spark aria-label=Spark>Spark</a></li><li><a href=#bitcoin aria-label=Bitcoin>Bitcoin</a></li><li><a href=#blockstack aria-label=Blockstack>Blockstack</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>當成複習</p><h2 id=gfs>GFS<a hidden class=anchor aria-hidden=true href=#gfs>#</a></h2><blockquote><p>Describe a sequence of events that would result in a client reading stale data from the Google File System.</p></blockquote><p>就是這張圖
<img loading=lazy src=https://i.imgur.com/mGJAKRl.png alt></p><p>只要一個secondary沒有寫到，primary只會回fail，之後client retry，就有了這個畫面。</p><h2 id=vm-ft>VM FT<a hidden class=anchor aria-hidden=true href=#vm-ft>#</a></h2><blockquote><p>How does VM FT handle network partitions?
That is, is it possible that if the primary and the backup end up in different network partitions that the backup will become a primary too and the system will run with two primaries?</p></blockquote><p>Test-and-Set，有搶到就當leader，沒搶到就自己放棄</p><h2 id=raft>raft<a hidden class=anchor aria-hidden=true href=#raft>#</a></h2><blockquote><p>Suppose we have the scenario shown in the Raft paper&rsquo;s Figure 7: a cluster of seven servers, with the log contents shown.
The first server crashes (the one at the top of the figure), and cannot be contacted.
A leader election ensues.
For each of the servers marked (a), (d), and (f), could that server be elected?
If yes, which servers would vote for it?
If no, what specific Raft mechanism(s) would prevent it from being elected?</p></blockquote><p>上requestVote的code</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>RequestVote</span><span class=p>(</span><span class=nx>args</span> <span class=o>*</span><span class=nx>RequestVoteArgs</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=nx>RequestVoteReply</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>lastIdx</span> <span class=o>:=</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>getLastLogIdxX</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>lastTerm</span> <span class=o>:=</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>getLogTermX</span><span class=p>(</span><span class=nx>lastIdx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&lt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>Term</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>reply</span><span class=p>.</span><span class=nx>VoteGranted</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&gt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>Term</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nf>setFollowerX</span><span class=p>(</span><span class=nx>args</span><span class=p>.</span><span class=nx>Term</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>VoteFor</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>VoteFor</span> <span class=o>!=</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Id</span> <span class=o>||</span> <span class=p>!(</span><span class=nx>lastTerm</span> <span class=p>&lt;</span> <span class=nx>args</span><span class=p>.</span><span class=nx>AtTerm</span> <span class=o>||</span> <span class=nx>lastTerm</span> <span class=o>==</span> <span class=nx>args</span><span class=p>.</span><span class=nx>AtTerm</span> <span class=o>&amp;&amp;</span> <span class=nx>lastIdx</span> <span class=o>&lt;=</span> <span class=nx>args</span><span class=p>.</span><span class=nx>AtIndex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>reply</span><span class=p>.</span><span class=nx>VoteGranted</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>reply</span><span class=p>.</span><span class=nx>VoteGranted</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>			<span class=c1>//DPrintf(&#34;(%v) [RequestVote] accept1 args:%v log:%v&#34;, rf.Me, args, rf.Log)
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>rf</span><span class=p>.</span><span class=nf>setFollowerX</span><span class=p>(</span><span class=nx>args</span><span class=p>.</span><span class=nx>Term</span><span class=p>,</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nf>resetElectionTimer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>Term</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>省略，term與投過的case，重點是
<code>!(lastTerm &lt; args.AtTerm || lastTerm == args.AtTerm && lastIdx &lt;= args.AtIndex)</code></p><ol><li>看最後一個log的term</li><li>最後一個log的term一樣就比長度</li></ol><p>a會拿到b, e, f的票，所以可以成為leader
d任何票都拿的到，所以可以成為leader
f最後一個log的term比任何人都小，不可能成為leader</p><blockquote><p>Could a received InstallSnapshot RPC cause the state machine to go backwards in time?
That is, could step 8 in Figure 13 cause the state machine to be reset so that it reflects fewer executed operations?
If yes, explain how this could happen. If no, explain why it can&rsquo;t happen.</p></blockquote><p>根據Log Matching，entry的index與term不會變
根據Leader Completeness，被commit的entry之後都會在log中
根據State Machine Safety，被apply之後就不會被apply別的entry</p><p>也就是說，commit過的log等於state machine</p><p>因為installSnapshot是只trim commit過的log，所以reset state machine沒差</p><h2 id=zookeeper>Zookeeper<a hidden class=anchor aria-hidden=true href=#zookeeper>#</a></h2><blockquote><p>One use of Zookeeper is as a fault-tolerant lock service (see the section &ldquo;Simple locks&rdquo; on page 6).
Why isn&rsquo;t possible for two clients to acquire the same lock?
In particular, how does Zookeeper decide if a client has failed and it can give the client&rsquo;s locks to other clients?</p></blockquote><p>就flock
用EPHEMERAL創個檔案，exist就是有人上鎖。
其他要等的就是上watch，之後就算lock holder出事zookeeper也會自己清這個檔案(鎖)，其他人透過watch知道unlock</p><h2 id=chain-replication>Chain Replication<a hidden class=anchor aria-hidden=true href=#chain-replication>#</a></h2><blockquote><p>Suppose Chain Replication replied to update requests from the head, as soon as the next chain server said it received the forwarded update, instead of responding from the tail.
Explain how that could cause Chain Replication to produce results that are not linearizable.</p></blockquote><p>這個就與raft沒有等到過半就commit一樣
如果不是最後一個好了才reply，有可能中間出事之後後面的server就會少這筆write</p><h2 id=distributed-transactions>Distributed Transactions<a hidden class=anchor aria-hidden=true href=#distributed-transactions>#</a></h2><blockquote><p>6.033 Book.
Read just these parts of Chapter 9: 9.1.5, 9.1.6, 9.5.2, 9.5.3, 9.6.3.
The last two sections (on two-phase locking and distributed two-phase commit) are the most important.
The Question: describe a situation where Two-Phase Locking yields higher performance than Simple Locking.</p></blockquote><p>Simple Locking: 先全拿lock，再跑，之後全放
Two-Phase Locking: 一個一個拿，等跑完，再一個一個放</p><p>A: read x, write y
B: read y</p><p>simple會變成B要等A做完才能跑(或是A等B)
2PL可以是先read x(A), read y(B), write y(A)</p><h2 id=spanner>Spanner<a hidden class=anchor aria-hidden=true href=#spanner>#</a></h2><blockquote><p>Spanner Suppose a Spanner server&rsquo;s TT.now() returns correct information, but the uncertainty is large.
For example, suppose the absolute time is 10:15:30, and TT.now() returns the interval [10:15:20,10:15:40].
That interval is correct in that it contains the absolute time, but the error bound is 10 seconds.
See Section 3 for an explanation TT.now().
What bad effect will a large error bound have on Spanner&rsquo;s operation?
Give a specific example.</p></blockquote><p>r/w commit要等到他的timestamp結束，所以誤差越大r/w commit要等越久</p><h2 id=frangipani>Frangipani<a hidden class=anchor aria-hidden=true href=#frangipani>#</a></h2><blockquote><p>Suppose a server modifies an i-node, appends the modification to its log, then another server modifies the same i-node, and then the first server crashes.
The recovery system will see the i-node modification in the crashed server&rsquo;s log, but should not apply that log entry to the i-node, because that would un-do the second server&rsquo;s change.
How does Frangipani avoid or cope with this situation?</p></blockquote><p>有人需要某個檔案是被已經crash的server改過的會怎樣?</p><p>Frangipani的client在改file之前會把op送到Petal的log，所有crash有兩個case</p><ol><li>有log</li><li>沒log</li></ol><p>有log就讓要求lock的server去replay
沒有log就直接上</p><p>replay就帶來現在問的問題，如果多台(其中有crash的)改到同一個file怎麼辦?
怎麼處理衝突?</p><p>檔案(inode)有版本號，所有op都有版本號+1，這樣只要op的版本號小於inode的，就不用管</p><h2 id=cops>COPS<a hidden class=anchor aria-hidden=true href=#cops>#</a></h2><blockquote><p>The last sentence in Section 4.3 says a client clears its context after a put, replacing the context with just the put.
The text observes &ldquo;This put depends on all previous key-version pairs and thus is nearer than them.&rdquo;
Why does clearing the context and replacing it with just the put make sense?
You might think that the client&rsquo;s subsequent puts would need to carry along the dependency information about previous gets.
What entity ultimately uses the context information, and why does it not need the information about gets before the last put?</p></blockquote><p>回想raft的snahpshot的問題，為什麼snapshot不會讓state machine後退?
因為snapshot的都是commited的log</p><p>在這裡log就是context，也就是執行過的指令(所以有遞移性)。
一旦執行完成就是commited，所以可以刪掉(因為狀態被改變了，前面的也沒用了)</p><p>那為什麼讀的指令要保留?
讓後面的讀可以知道前面的讀已經發生，確保順序
(可以配合SUNDR的question一起看)</p><h2 id=farm>FaRM<a hidden class=anchor aria-hidden=true href=#farm>#</a></h2><blockquote><p>Suppose there are two FaRM transactions that both increment the same object.
They start at the same time and see the same initial value for the object.
One transaction completely finishes committing (see Section 4 and Figure 4).
Then the second transaction starts to commit. There are no failures.
What is the evidence that FaRM will use to realize that it must abort the second transaction? At what point in the Section 4 / Figure 4 protocol will FaRM realize that it must abort?</p></blockquote><p>FaRM是樂觀鎖，所以它會讓其他人做事，出事(FaRM透過檢查確認出事)再retry
悲觀鎖是先讓對方等</p><p>FaRM前面有兩個檢查階段</p><ol><li>LOCK</li><li>VALIDATE</li></ol><p>都會檢查lock與資料的版本號
LOCK可以當成是檢查寫過的
VALIDATE是有讀到的</p><p>這題是在同一個變數做++，所以在LOCK會被abort</p><h2 id=memcache-at-facebook>Memcache at Facebook<a hidden class=anchor aria-hidden=true href=#memcache-at-facebook>#</a></h2><blockquote><p>Section 3.3 implies that a client that writes data does not delete the corresponding key from the Gutter servers, even though the client does try to delete the key from the ordinary Memcached servers (Figure 1).
Explain why it would be a bad idea for writing clients to delete keys from Gutter servers.</p></blockquote><p>gutter是備援選手，在主server出事時接手
同時cache的目的是不要讓大量traffic打爆backend</p><p>所以回答問題，為什麼不用invalidate gutter?
gutter的key的過期時間很短，取代invalidate，雖然說會有一點stale data，但這樣可以確保backend不會被打爆</p><h2 id=sundr>SUNDR<a hidden class=anchor aria-hidden=true href=#sundr>#</a></h2><blockquote><p>In the simple straw-man, both fetch and modify operations are placed in the log and signed.
Suppose an alternate design that only signs and logs modify operations.
Does this allow a malicious server to break fetch-modify consistency or fork consistency? Why or why not?</p></blockquote><p>可以回去想為什麼raft的read要過raft的共識
如果沒有過共識，read可能拿到缺了某些write的state</p><h2 id=spark>Spark<a hidden class=anchor aria-hidden=true href=#spark>#</a></h2><blockquote><p>What applications can Spark support well that MapReduce/Hadoop cannot support?</p></blockquote><p>密集運算或是需要反覆r/w的場合</p><h2 id=bitcoin>Bitcoin<a hidden class=anchor aria-hidden=true href=#bitcoin>#</a></h2><blockquote><p>Try to buy something with Bitcoin. It may help to cooperate with some 6.824 class-mates, and it may help to start a few days early. If you decide to give up, that&rsquo;s OK. Briefly describe your experience.</p></blockquote><p>沒$，跳過</p><h2 id=blockstack>Blockstack<a hidden class=anchor aria-hidden=true href=#blockstack>#</a></h2><blockquote><p>Why is it important that Blockstack names be unique, human-readable, and decentralized?
Why is providing all three properties hard?</p></blockquote><p>因為name是識別user的方法，也是資安的開始，所以重要</p><p>unique: 不能重複
human-readable: 方便使用
decentralized: 解釋權不被壟斷</p><p>human-readable + decentralized: <em>自己的</em>筆記
human-readable + unique: email
unique + decentralized: public key</p><p>centralized很像root folder，在裡面可以human-readable與unique
一但decentralized就很容易撞名</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/distributed/>Distributed</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2022/03/cmu-14-445-lab%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%AD%86%E8%A8%98/><span class=title>« Prev</span><br><span>cmu 14-445 lab的不完全筆記</span>
</a><a class=next href=https://littlebees.github.io/2022/03/raft%E5%84%AA%E5%8C%96/><span class=title>Next »</span><br><span>raft優化</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>