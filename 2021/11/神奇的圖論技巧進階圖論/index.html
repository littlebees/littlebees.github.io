<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>神奇的圖論技巧(進階圖論) | 記事本</title>
<meta name=keywords content><meta name=description content="動機
tarjan的dfs好強!!"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/11/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%9C%96%E8%AB%96%E6%8A%80%E5%B7%A7%E9%80%B2%E9%9A%8E%E5%9C%96%E8%AB%96/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="神奇的圖論技巧(進階圖論)"><meta property="og:description" content="動機
tarjan的dfs好強!!"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/11/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%9C%96%E8%AB%96%E6%8A%80%E5%B7%A7%E9%80%B2%E9%9A%8E%E5%9C%96%E8%AB%96/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-20T21:49:24+00:00"><meta property="article:modified_time" content="2021-11-20T21:49:24+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="神奇的圖論技巧(進階圖論)"><meta name=twitter:description content="動機
tarjan的dfs好強!!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"神奇的圖論技巧(進階圖論)","item":"https://littlebees.github.io/2021/11/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%9C%96%E8%AB%96%E6%8A%80%E5%B7%A7%E9%80%B2%E9%9A%8E%E5%9C%96%E8%AB%96/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"神奇的圖論技巧(進階圖論)","name":"神奇的圖論技巧(進階圖論)","description":"動機 tarjan的dfs好強!!\n","keywords":[],"articleBody":"動機 tarjan的dfs好強!!\nArticulation point (tarjan的dfs) 祖先與每一棵子樹之間都有 back edge ，則此點不是關節點 祖先與其中一棵子樹之間缺少 back edge ，則此點就是關節點。\n怎麼確認祖先關係? 用dfs走每一個點，給每個經過的點都標一個時間，祖先時間一定比較小\n所以只要看每個child最遠可以到哪(earliest[child])，或是說透過back edge穿越時空，只要沒有超過祖先的時間那麼祖先一定是關節點\n但根結點沒有祖先，怎麼判斷? 有沒有一個以上的child\n接著就是怎麼找earliest earliest原定是每個child最遠可以到哪 那是怎麼走，怎麼到達下一個點? (因為這與計算最遠的定義有關) dfs，所以earliest是透過dfs遞迴定義，但還有back edge要處理\n因為是用dfs，所以earliest要確認dfs能到的最遠距離 earliest[root] = min(earliest[root], earliest[child]) 同時back edge能也走，所以要直接看他的時間，來更新earliest earliest[root] = min(earliest[root], child.time) 同時這個earliest的演算法(tarjan)，還會再求scc看到\nearliest = defaultdict(lambda x: float('inf')) vis = defaultdict(bool) timestamp = 1 ap = [] def setTime(root): root.time = earliest[root] = timestamp timestamp += 1 def dfs(root, fa): setTime(root) vis[root] = True cnt_of_child = sum(1 for child in root.chilren if not vis[child]) for child in [child for child in root.chilren if child is not fa]: if vis[child]: # 不在當前的dfs路徑上(back edge)，所以取時間點就好 earliest[root] = min(earliest[root], child.time) else: dfs(child, root) # 在當前的dfs路徑上，所以取越遠越好 earliest[root] = min(earliest[root], earliest[child]) if root.time \u003c= earliest[child]: # child沒辦法飛超過祖先，祖先就是ap ap.append(root) if fa is None and cnt_of_child \u003e 1: # root超過一個子樹 ap.append(root) def get_ap(graph): for root in graph.V(): if not vis[root]: dfs(root, None) return ap Bridge 基本與Articulation point一樣\n但現在存的是邊，所以\n不用看root是ap的case 依舊不能飛超過祖先，但是因為這是邊，所以要把剛好落在祖先的邊去掉 root.time \u003c= earliest[child] =\u003e root.time \u003c earliest[child] earliest = defaultdict(lambda x: float('inf')) vis = defaultdict(bool) timestamp = 1 bri = [] def setTime(root): root.time = earliest[root] = timestamp timestamp += 1 def dfs(root, fa): setTime(root) vis[root] = True for child in [child for child in root.chilren if child is not fa]: if vis[child]: # 不在當前的dfs路徑上(back edge)，所以取時間點就好 earliest[root] = min(earliest[root], child.time) else: dfs(child, root) # 在當前的dfs路徑上，所以取越遠越好 earliest[root] = min(earliest[root], earliest[child]) if root.time \u003c earliest[child]: # ap在root下面 bri.append((root,child)) def get_ap(graph): for root in graph.V(): if not vis[root]: dfs(root, None) return Connected Components 就是找相連起來的部分\nvis = defaultdict(bool) def dfs(root): ret = [] if not vis[root]: vis[root] = True for child in root.children: ret += dfs(child) return ret def cc(graph): for root in graph.V(): if not vis[root]: print(dfs(root)) Strongly Connected Components dfs走兩次，一次是順向，第二次是逆向\n順便提一下，現在google到的作法都是分兩個dfs，一個收order，另一個收scc\n但第一個dfs的order卻放在dfs最後才收，之後再reverse，去跑第二個dfs\n但其實只要把order往前放就是順序去收order了，就不用再reverse\ndef dfs(root, vis, before): if not vis[root]: vis[root] = True before(root) [dfs(child, vis, before, after) for child in root.children] def get_scc(graph): vis = [False] * len(graph.V()) order = [] for root in graph.V(): if not vis[root]: dfs(root, vis, lambda root: order.append(root)) # 把所有edge反向 graph.reverse() # 又叫transpose vis = [False] * len(graph.V()) for root in order: if not vis[root]: scc = [] dfs(root, vis, lambda root: scc.append(root)) print(scc) 另一個就是利用Articulation point的方法\n題外話，Tarjan這個方法真的神\n原本ap是看child有沒有飛過祖先來判定ap， 這裡是要scc，所以只要這個點的最早就是自己，那從這點開始的都是scc\nscc = [] vis = defaultdict(bool) earliest = defaultdict(int) def dfs(root): if not vis[root]: nodes = [root] vis[root] = True for child in root.children: if vis[child]: earliest[root] = min(earliest[root], child.time) else: nodes += dfs(child, nodes + [child]) earliest[root] = min(earliest[root], earliest[child]) if earliest[root] == root.time: scc.append(nodes) return [] else: return nodes def tarjan_scc(graph): for v in graph.V(): dfs(v) return scc Cycle 一般的cycle，用3個狀態表示沒碰過、還在dfs、處理完了 之後就是dfs\n# 0: unhandled, 1: processing, 2: done vis = defaultdict(int) def dfs(root): if vis[root] == 0: vis[root] = 1 for child in root.children: if vis[root] == 1: raise ['cycle', root] else: dfs(child) def cycle(graph): try: for root in graph.V(): if vis[root] == 0: dfs(root) except e: print('cycle exist') 負環:\nBellman-Ford algorithm V個點，把E個邊，對應到的終點用邊去延伸 如果有負環，就會有到最後還可以縮小路徑的點，就會有環 Floyd-Warshall algorithm V個點 * V個點，再列舉V個點做中間點 只要有一個距離是扣到變成負的，就會有環 Bipartite 把點分成兩邊，每一點只能連到另一邊\n用bfs，去allocate所有連到的點到另一邊，之後有兩個case\nchild沒分配過 就給另一邊 child分配過了 GG side = defaultdict(lambda x: -1) def check_Bipartite(graph): q = deque() for root in graph.V(): if side[root] == -1: side[root] = 0 q.append(root) while q: child = q.popLeft() if side[child] == -1 side[child] = side[root] ^ 1 elif side[root] == side[child]: return False return True Maximum Bipartite Matching Maximum Bipartite Matching: 讓最多點被match掉\nmatch: 湊成一對，每個點不是在某一對，就是沒有在任何一對 證明、相關概念很複雜，反正就是有得match就match，或是看他能不try到別的match(argument path)，直到無法match 詳細說明看這裡\n所以可以直接用dfs一直match，每個點都try一遍\nused = defaultdict(bool) match = defaultdict(lambda x: None) def try_kuhn(root): if used[root]: return False else: used[root] = True for child in root.children: if not match[child] or try_kuhn(child): match[child] = root return True return False def lets_match(bipartile): for v in bipartile.V(): try_kuhn(v) return match 因為只是一直塞match，所以可以先做一些明顯的match\ndef lets_match(bipartile): for v in bipartile.V(): for child in v.children: if not match[child]: match[child] = root used[root] = True break for v in bipartile.V(): try_kuhn(v) return match 2-SAT 原本SAT是任意個變數or，再and 但2-SAT是只有2個變數or(item)，再and\n這樣每個item都可以用imply(a or not b)，與交換率生出兩個imply 之後構成一個imply graph\n之後就是求scc，看scc中有沒有x與not x同時在，有就是not sat\n整個時間都是在找scc，所以時間複雜度是O(V+E)\n2 - SAT\nEulerian path 歐拉路徑的條件是\ndegree為奇數的點只能是0或是2 他們就是起、終點 剩下的degree都只能是偶數 degree就是每個點有多少edge\n所以確定圖符合條件，剩下就是隨便走出一條路，之後把所有路合併起來 (為什麼要合併? 因為可能是cycle)\n實作就是用dfs在最後塞就好，自然就把所有路合併起來了\npath = [] vis = defaultdict(bool) def dfs(root): if not vis[root]: vis[root] = True for child in root.children: dfs(child) path.append(root) tree的同構 tree hash是為了判斷tree的同構，但是python可以直接用string做hash，所以可以用任何一種序的string當成key\ntrees = defaultdict(int) def post(root): if not root: return '' else: tree = f'{post(root.left)},{root.val},{post(root,right)}' trees[tree] += 1 return tree post(root) [print(tree) for tree,val in trees.items() if val \u003e 1] Ref Finding articulation points in a graph in O(N+M) Finding bridges in a graph in O(N+M) Search for connected components in a graph Checking a graph for acyclicity and finding a cycle in O(M) (M就是E) Finding a negative cycle in the graph Check whether a graph is bipartite Finding strongly connected components Building condensation graph Kuhn’s Algorithm for Maximum Bipartite Matching 强连通分量 Finding the Eulerian path in O(M)\n","wordCount":"753","inLanguage":"en","datePublished":"2021-11-20T21:49:24Z","dateModified":"2021-11-20T21:49:24Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/11/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%9C%96%E8%AB%96%E6%8A%80%E5%B7%A7%E9%80%B2%E9%9A%8E%E5%9C%96%E8%AB%96/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">神奇的圖論技巧(進階圖論)</h1><div class=post-meta><span title='2021-11-20 21:49:24 +0000 UTC'>November 20, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#articulation-point-tarjan%e7%9a%84dfs aria-label="Articulation point (tarjan的dfs)">Articulation point (tarjan的dfs)</a></li><li><a href=#bridge aria-label=Bridge>Bridge</a></li><li><a href=#connected-components aria-label="Connected Components">Connected Components</a></li><li><a href=#strongly-connected-components aria-label="Strongly Connected Components">Strongly Connected Components</a></li><li><a href=#cycle aria-label=Cycle>Cycle</a></li><li><a href=#bipartite aria-label=Bipartite>Bipartite</a><ul><li><a href=#maximum-bipartite-matching aria-label="Maximum Bipartite Matching">Maximum Bipartite Matching</a></li></ul></li><li><a href=#2-sat aria-label=2-SAT>2-SAT</a></li><li><a href=#eulerian-path aria-label="Eulerian path">Eulerian path</a></li><li><a href=#tree%e7%9a%84%e5%90%8c%e6%a7%8b aria-label=tree的同構>tree的同構</a></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>tarjan的dfs好強!!</p><h2 id=articulation-point-tarjan的dfs>Articulation point (tarjan的dfs)<a hidden class=anchor aria-hidden=true href=#articulation-point-tarjan的dfs>#</a></h2><p>祖先與每一棵子樹之間都有 back edge ，則此點不是關節點
<strong>祖先與其中一棵子樹之間缺少 back edge</strong> ，則此點就是關節點。</p><p>怎麼確認祖先關係?
用dfs走每一個點，給每個經過的點都標一個<em>時間</em>，祖先時間一定比較小</p><p>所以只要看每個child最遠可以到哪(earliest[child])，或是說透過back edge穿越時空，只要沒有超過祖先的時間那麼祖先一定是關節點</p><p>但根結點沒有祖先，怎麼判斷?
有沒有一個以上的child</p><p>接著就是怎麼找earliest
earliest原定是<strong>每個child最遠可以到哪</strong>
那是怎麼走，怎麼到達下一個點? (因為這與計算最遠的定義有關)
dfs，所以earliest是透過dfs遞迴定義，但還有back edge要處理</p><ol><li>因為是用dfs，所以earliest要確認dfs能到的最遠距離</li></ol><ul><li><code>earliest[root] = min(earliest[root], earliest[child])</code></li></ul><ol start=2><li>同時back edge能也走，所以要直接看他的時間，來更新earliest</li></ol><ul><li><code>earliest[root] = min(earliest[root], child.time)</code></li></ul><p>同時這個earliest的演算法(tarjan)，還會再求scc看到</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>earliest</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>vis</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>timestamp</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>ap</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>setTime</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>root</span><span class=o>.</span><span class=n>time</span> <span class=o>=</span> <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=n>timestamp</span>
</span></span><span class=line><span class=cl>  <span class=n>timestamp</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>fa</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>setTime</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>  <span class=n>cnt_of_child</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=mi>1</span> <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>chilren</span> <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>child</span><span class=p>])</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=p>[</span><span class=n>child</span> <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>chilren</span> <span class=k>if</span> <span class=n>child</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>fa</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>vis</span><span class=p>[</span><span class=n>child</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=c1># 不在當前的dfs路徑上(back edge)，所以取時間點就好</span>
</span></span><span class=line><span class=cl>      <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>],</span> <span class=n>child</span><span class=o>.</span><span class=n>time</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=c1># 在當前的dfs路徑上，所以取越遠越好</span>
</span></span><span class=line><span class=cl>      <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>],</span> <span class=n>earliest</span><span class=p>[</span><span class=n>child</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>root</span><span class=o>.</span><span class=n>time</span> <span class=o>&lt;=</span> <span class=n>earliest</span><span class=p>[</span><span class=n>child</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=c1># child沒辦法飛超過祖先，祖先就是ap</span>
</span></span><span class=line><span class=cl>        <span class=n>ap</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>fa</span> <span class=ow>is</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>cnt_of_child</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># root超過一個子樹</span>
</span></span><span class=line><span class=cl>    <span class=n>ap</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_ap</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>root</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ap</span>
</span></span></code></pre></div><h2 id=bridge>Bridge<a hidden class=anchor aria-hidden=true href=#bridge>#</a></h2><p>基本與Articulation point一樣</p><p>但現在存的是邊，所以</p><ol><li>不用看root是ap的case</li><li>依舊不能飛超過祖先，但是因為這是邊，所以要把剛好落在祖先的邊去掉</li></ol><ul><li><code>root.time &lt;= earliest[child]</code> => <code>root.time &lt; earliest[child]</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>earliest</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>vis</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>timestamp</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>bri</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>setTime</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>root</span><span class=o>.</span><span class=n>time</span> <span class=o>=</span> <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=n>timestamp</span>
</span></span><span class=line><span class=cl>  <span class=n>timestamp</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>fa</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>setTime</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=p>[</span><span class=n>child</span> <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>chilren</span> <span class=k>if</span> <span class=n>child</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>fa</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>vis</span><span class=p>[</span><span class=n>child</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=c1># 不在當前的dfs路徑上(back edge)，所以取時間點就好</span>
</span></span><span class=line><span class=cl>      <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>],</span> <span class=n>child</span><span class=o>.</span><span class=n>time</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=c1># 在當前的dfs路徑上，所以取越遠越好</span>
</span></span><span class=line><span class=cl>      <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>],</span> <span class=n>earliest</span><span class=p>[</span><span class=n>child</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>root</span><span class=o>.</span><span class=n>time</span> <span class=o>&lt;</span> <span class=n>earliest</span><span class=p>[</span><span class=n>child</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=c1># ap在root下面</span>
</span></span><span class=line><span class=cl>        <span class=n>bri</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>root</span><span class=p>,</span><span class=n>child</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_ap</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>root</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> 
</span></span></code></pre></div><h2 id=connected-components>Connected Components<a hidden class=anchor aria-hidden=true href=#connected-components>#</a></h2><p>就是找相連起來的部分</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>vis</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>ret</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>children</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ret</span> <span class=o>+=</span> <span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>cc</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>root</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=nb>print</span><span class=p>(</span><span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>
</span></span></code></pre></div><h2 id=strongly-connected-components>Strongly Connected Components<a hidden class=anchor aria-hidden=true href=#strongly-connected-components>#</a></h2><p>dfs走兩次，一次是順向，第二次是逆向</p><p>順便提一下，現在google到的作法都是分兩個dfs，一個收order，另一個收scc</p><p>但第一個dfs的order卻放在dfs最後才收，之後再reverse，去跑第二個dfs</p><p>但其實只要把order往前放就是順序去收order了，就不用再reverse</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>vis</span><span class=p>,</span> <span class=n>before</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=n>before</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>vis</span><span class=p>,</span> <span class=n>before</span><span class=p>,</span> <span class=n>after</span><span class=p>)</span> <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>children</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_scc</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>vis</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=n>order</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>root</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>vis</span><span class=p>,</span> <span class=k>lambda</span> <span class=n>root</span><span class=p>:</span> <span class=n>order</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1># 把所有edge反向</span>
</span></span><span class=line><span class=cl>  <span class=n>graph</span><span class=o>.</span><span class=n>reverse</span><span class=p>()</span> <span class=c1># 又叫transpose</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>vis</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>root</span> <span class=ow>in</span> <span class=n>order</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>      <span class=n>scc</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>vis</span><span class=p>,</span> <span class=k>lambda</span> <span class=n>root</span><span class=p>:</span> <span class=n>scc</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=nb>print</span><span class=p>(</span><span class=n>scc</span><span class=p>)</span>
</span></span></code></pre></div><p>另一個就是利用Articulation point的方法</p><p>題外話，Tarjan這個方法真的神</p><p>原本ap是看child有沒有飛過祖先來判定ap，
這裡是要scc，所以只要這個點的最早就是自己，那從這點開始的都是scc</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>scc</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>vis</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>earliest</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=n>nodes</span> <span class=o>=</span> <span class=p>[</span><span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>children</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>vis</span><span class=p>[</span><span class=n>child</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>],</span> <span class=n>child</span><span class=o>.</span><span class=n>time</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>nodes</span> <span class=o>+=</span> <span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>nodes</span> <span class=o>+</span> <span class=p>[</span><span class=n>child</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>],</span> <span class=n>earliest</span><span class=p>[</span><span class=n>child</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>earliest</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>==</span> <span class=n>root</span><span class=o>.</span><span class=n>time</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>scc</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nodes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>nodes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>tarjan_scc</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>scc</span>
</span></span></code></pre></div><h2 id=cycle>Cycle<a hidden class=anchor aria-hidden=true href=#cycle>#</a></h2><p>一般的cycle，用3個狀態表示沒碰過、還在dfs、處理完了
之後就是dfs</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 0: unhandled, 1: processing, 2: done</span>
</span></span><span class=line><span class=cl><span class=n>vis</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>children</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=p>[</span><span class=s1>&#39;cycle&#39;</span><span class=p>,</span> <span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>cycle</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>root</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>except</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;cycle exist&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>負環:</p><ul><li>Bellman-Ford algorithm<ul><li>V個點，把E個邊，對應到的終點用邊去延伸<ul><li>如果有負環，就會有到最後還可以縮小路徑的點，就會有環</li></ul></li></ul></li><li>Floyd-Warshall algorithm<ul><li>V個點 * V個點，再列舉V個點做中間點<ul><li>只要有一個距離是扣到變成負的，就會有環</li></ul></li></ul></li></ul><h2 id=bipartite>Bipartite<a hidden class=anchor aria-hidden=true href=#bipartite>#</a></h2><p>把點分成兩邊，每一點只能連到另一邊</p><p>用bfs，去allocate所有連到的點到另一邊，之後有兩個case</p><ol><li>child沒分配過</li></ol><ul><li>就給另一邊</li></ul><ol start=2><li>child分配過了</li></ol><ul><li>GG</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>side</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>check_Bipartite</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>q</span> <span class=o>=</span> <span class=n>deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>root</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>side</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>side</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>      <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>while</span> <span class=n>q</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=n>popLeft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>side</span><span class=p>[</span><span class=n>child</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>          <span class=n>side</span><span class=p>[</span><span class=n>child</span><span class=p>]</span> <span class=o>=</span> <span class=n>side</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>^</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>side</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>==</span> <span class=n>side</span><span class=p>[</span><span class=n>child</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>True</span>
</span></span></code></pre></div><h3 id=maximum-bipartite-matching>Maximum Bipartite Matching<a hidden class=anchor aria-hidden=true href=#maximum-bipartite-matching>#</a></h3><p>Maximum Bipartite Matching: 讓最多點被match掉</p><ul><li>match: 湊成一對，每個點不是在某一對，就是沒有在任何一對</li></ul><p>證明、相關概念很複雜，反正就是有得match就match，或是看他能不try到別的match(argument path)，直到無法match
詳細說明看<a href=https://web.ntnu.edu.tw/~algo/Matching.html#3>這裡</a></p><p>所以可以直接用dfs一直match，每個點都try一遍</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>used</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>match</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>try_kuhn</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>used</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>used</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>children</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=ow>not</span> <span class=k>match</span><span class=p>[</span><span class=n>child</span><span class=p>]</span> <span class=ow>or</span> <span class=n>try_kuhn</span><span class=p>(</span><span class=n>child</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>match</span><span class=p>[</span><span class=n>child</span><span class=p>]</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>lets_match</span><span class=p>(</span><span class=n>bipartile</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>bipartile</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>try_kuhn</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>match</span>
</span></span></code></pre></div><p>因為只是一直塞match，所以可以先做一些明顯的match</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>lets_match</span><span class=p>(</span><span class=n>bipartile</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>bipartile</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>v</span><span class=o>.</span><span class=n>children</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=ow>not</span> <span class=k>match</span><span class=p>[</span><span class=n>child</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>match</span><span class=p>[</span><span class=n>child</span><span class=p>]</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>        <span class=n>used</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>bipartile</span><span class=o>.</span><span class=n>V</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>try_kuhn</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>match</span>
</span></span></code></pre></div><h2 id=2-sat>2-SAT<a hidden class=anchor aria-hidden=true href=#2-sat>#</a></h2><p>原本SAT是任意個變數or，再and
但2-SAT是只有2個變數or(item)，再and</p><p>這樣每個item都可以用imply(a or not b)，與交換率生出兩個imply
之後構成一個imply graph</p><p>之後就是求scc，看scc中有沒有x與not x同時在，有就是not sat</p><p>整個時間都是在找scc，所以時間複雜度是O(V+E)</p><p><a href=https://cp-algorithms.com/graph/2SAT.html>2 - SAT</a></p><h2 id=eulerian-path>Eulerian path<a hidden class=anchor aria-hidden=true href=#eulerian-path>#</a></h2><p>歐拉路徑的條件是</p><ul><li>degree為奇數的點只能是0或是2<ul><li>他們就是起、終點</li></ul></li><li>剩下的degree都只能是偶數</li></ul><p>degree就是每個點有多少edge</p><p>所以確定圖符合條件，剩下就是隨便走出一條路，之後把所有路合併起來
(為什麼要合併? 因為可能是cycle)</p><p>實作就是用dfs在最後塞就好，自然就把所有路合併起來了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>path</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>vis</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=ow>not</span> <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=n>vis</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>root</span><span class=o>.</span><span class=n>children</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=tree的同構>tree的同構<a hidden class=anchor aria-hidden=true href=#tree的同構>#</a></h2><p>tree hash是為了判斷tree的同構，但是python可以直接用string做hash，所以可以用任何一種序的string當成key</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>trees</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>post</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>tree</span> <span class=o>=</span> <span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>post</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>)</span><span class=si>}</span><span class=s1>,</span><span class=si>{</span><span class=n>root</span><span class=o>.</span><span class=n>val</span><span class=si>}</span><span class=s1>,</span><span class=si>{</span><span class=n>post</span><span class=p>(</span><span class=n>root</span><span class=p>,</span><span class=n>right</span><span class=p>)</span><span class=si>}</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>trees</span><span class=p>[</span><span class=n>tree</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>post</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=nb>print</span><span class=p>(</span><span class=n>tree</span><span class=p>)</span> <span class=k>for</span> <span class=n>tree</span><span class=p>,</span><span class=n>val</span> <span class=ow>in</span> <span class=n>trees</span><span class=o>.</span><span class=n>items</span><span class=p>()</span> <span class=k>if</span> <span class=n>val</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://cp-algorithms.com/graph/cutpoints.html>Finding articulation points in a graph in O(N+M)</a>
<a href=https://cp-algorithms.com/graph/bridge-searching.html>Finding bridges in a graph in O(N+M)</a>
<a href=https://cp-algorithms.com/graph/search-for-connected-components.html>Search for connected components in a graph</a>
<a href=https://cp-algorithms.com/graph/finding-cycle.html>Checking a graph for acyclicity and finding a cycle in O(M) (M就是E)</a>
<a href=https://cp-algorithms.com/graph/finding-negative-cycle-in-graph.html>Finding a negative cycle in the graph</a>
<a href=https://cp-algorithms.com/graph/bipartite-check.html>Check whether a graph is bipartite</a>
<a href=https://cp-algorithms.com/graph/strongly-connected-components.html>Finding strongly connected components Building condensation graph</a>
<a href=https://cp-algorithms.com/graph/kuhn_maximum_bipartite_matching.html>Kuhn&rsquo;s Algorithm for Maximum Bipartite Matching</a>
<a href=https://oi-wiki.org/graph/scc/>强连通分量</a>
<a href=https://cp-algorithms.com/graph/euler_path.html>Finding the Eulerian path in O(M)</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/11/dynamic-programming/><span class=title>« Prev</span><br><span>Dynamic programming</span>
</a><a class=next href=https://littlebees.github.io/2021/11/suffix-array/><span class=title>Next »</span><br><span>suffix array</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>