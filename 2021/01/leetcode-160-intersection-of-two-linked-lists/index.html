<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-160 - Intersection of Two Linked Lists | 記事本</title>
<meta name=keywords content="Two Pointers,Linked List,Hash Table,Top 100 Liked Questions,Top Interview Questions,CTCI-COMPLETE-LIST"><meta name=description content="動機
不能動node內容!!"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/01/leetcode-160-intersection-of-two-linked-lists/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/01/leetcode-160-intersection-of-two-linked-lists/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-160 - Intersection of Two Linked Lists"><meta property="og:description" content="動機
不能動node內容!!"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/01/leetcode-160-intersection-of-two-linked-lists/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-18T01:19:15+00:00"><meta property="article:modified_time" content="2021-01-18T01:19:15+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-160 - Intersection of Two Linked Lists"><meta name=twitter:description content="動機
不能動node內容!!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-160 - Intersection of Two Linked Lists","item":"https://littlebees.github.io/2021/01/leetcode-160-intersection-of-two-linked-lists/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-160 - Intersection of Two Linked Lists","name":"leetcode-160 - Intersection of Two Linked Lists","description":"動機 不能動node內容!!\n","keywords":["Two Pointers","Linked List","Hash Table","Top 100 Liked Questions","Top Interview Questions","CTCI-COMPLETE-LIST"],"articleBody":"動機 不能動node內容!!\nProblem Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nCustom Judge:\nThe inputs to the judge are given as follows (your program is not given these inputs):\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.listA - The first linked list.listB - The second linked list.skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.\nExample 1:\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3Output: Intersected at '8'Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.Example 2:\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1Output: Intersected at '2'Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.Example 3:\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2Output: No intersectionExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null. Constraints:\nThe number of nodes of listA is in the m.The number of nodes of listB is in the n.0 \u003c= m, n \u003c= 3 * 1041 \u003c= Node.val \u003c= 1050 \u003c= skipA \u003c= m0 \u003c= skipB \u003c= nintersectVal is 0 if listA and listB do not intersect.intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect. Follow up: Could you write a solution that runs in O(n) time and use only O(1) memory? Sol 一開始想到的是改node，去找出遇過兩次的node，但題目限制不能改內容\n所以只要讓兩條List的長度一樣，同時往後走看會不會遇到就ok了\ndef size(a): ret = 0 while a: ret += 1 a = a.next return ret class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode: sizeA = size(headA) sizeB = size(headB) common = min(sizeA,sizeB) for _ in range(sizeA-common): headA = headA.next for _ in range(sizeB-common): headB = headB.next #print(headA.val,headB.val) while headA and headB and (headA is not headB): headA = headA.next headB = headB.next return headA if (headA is headB) else None ","wordCount":"566","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-01-18T01:19:15Z","dateModified":"2021-01-18T01:19:15Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/01/leetcode-160-intersection-of-two-linked-lists/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-160 - Intersection of Two Linked Lists</h1><div class=post-meta><span title='2021-01-18 01:19:15 +0000 UTC'>January 18, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>不能動node內容!!</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p><p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p><img alt src=https://assets.leetcode.com/uploads/2021/03/05/160_statement.png style=width:500px;height:162px><p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p><p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p><p><strong>Custom Judge:</strong></p><p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p><ul><li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li><li><code>listA</code> - The first linked list.</li><li><code>listB</code> - The second linked list.</li><li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li><li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li></ul><p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p><p> </p><p><strong>Example 1:</strong></p><img alt src=https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png style=width:500px;height:162px><pre><strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3<strong>Output:</strong> Intersected at '8'<strong>Explanation:</strong> The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</pre><p><strong>Example 2:</strong></p><img alt src=https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png style=width:500px;height:194px><pre><strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<strong>Output:</strong> Intersected at '2'<strong>Explanation:</strong> The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</pre><p><strong>Example 3:</strong></p><img alt src=https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png style=width:300px;height:189px><pre><strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<strong>Output:</strong> No intersection<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null.</pre><p> </p><p><strong>Constraints:</strong></p><ul><li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li><li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li><li><code>0 <= m, n <= 3 * 10<sup>4</sup></code></li><li><code>1 <= Node.val <= 10<sup>5</sup></code></li><li><code>0 <= skipA <= m</code></li><li><code>0 <= skipB <= n</code></li><li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li><li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li></ul><p> </p><strong>Follow up:</strong> Could you write a solution that runs in <code>O(n)</code> time and use only <code>O(1)</code> memory?<h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><p>一開始想到的是改node，去找出遇過兩次的node，但題目限制不能改內容</p><p>所以只要讓兩條List的長度一樣，同時往後走看會不會遇到就ok了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>size</span><span class=p>(</span><span class=n>a</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>a</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>getIntersectionNode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>headA</span><span class=p>:</span> <span class=n>ListNode</span><span class=p>,</span> <span class=n>headB</span><span class=p>:</span> <span class=n>ListNode</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>ListNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>sizeA</span> <span class=o>=</span> <span class=n>size</span><span class=p>(</span><span class=n>headA</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>sizeB</span> <span class=o>=</span> <span class=n>size</span><span class=p>(</span><span class=n>headB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>common</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>sizeA</span><span class=p>,</span><span class=n>sizeB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>sizeA</span><span class=o>-</span><span class=n>common</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>headA</span> <span class=o>=</span> <span class=n>headA</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>sizeB</span><span class=o>-</span><span class=n>common</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>headB</span> <span class=o>=</span> <span class=n>headB</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>#print(headA.val,headB.val)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>headA</span> <span class=ow>and</span> <span class=n>headB</span> <span class=ow>and</span> <span class=p>(</span><span class=n>headA</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>headB</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>headA</span> <span class=o>=</span> <span class=n>headA</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>            <span class=n>headB</span> <span class=o>=</span> <span class=n>headB</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>headA</span> <span class=k>if</span> <span class=p>(</span><span class=n>headA</span> <span class=ow>is</span> <span class=n>headB</span><span class=p>)</span> <span class=k>else</span> <span class=kc>None</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/two-pointers/>Two Pointers</a></li><li><a href=https://littlebees.github.io/tags/linked-list/>Linked List</a></li><li><a href=https://littlebees.github.io/tags/hash-table/>Hash Table</a></li><li><a href=https://littlebees.github.io/tags/top-100-liked-questions/>Top 100 Liked Questions</a></li><li><a href=https://littlebees.github.io/tags/top-interview-questions/>Top Interview Questions</a></li><li><a href=https://littlebees.github.io/tags/ctci-complete-list/>CTCI-COMPLETE-LIST</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/01/leetcode-202-happy-number/><span class=title>« Prev</span><br><span>leetcode-202 - Happy Number</span>
</a><a class=next href=https://littlebees.github.io/2021/01/leetcode-148-sort-list/><span class=title>Next »</span><br><span>leetcode-148 - Sort List</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>