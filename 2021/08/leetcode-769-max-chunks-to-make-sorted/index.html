<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-769 - Max Chunks To Make Sorted | 記事本</title>
<meta name=keywords content="Monotonic Stack,Sorting,Greedy,Stack,Array"><meta name=description content="動機
這裡的Monotonic Stack不同於84的用法
stack放的是sort好的區塊，放上最大值(或是區塊的最後一個)
或是利用只有0~n-1的特性"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/08/leetcode-769-max-chunks-to-make-sorted/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/08/leetcode-769-max-chunks-to-make-sorted/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-769 - Max Chunks To Make Sorted"><meta property="og:description" content="動機
這裡的Monotonic Stack不同於84的用法
stack放的是sort好的區塊，放上最大值(或是區塊的最後一個)
或是利用只有0~n-1的特性"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/08/leetcode-769-max-chunks-to-make-sorted/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-20T00:50:08+00:00"><meta property="article:modified_time" content="2021-08-20T00:50:08+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-769 - Max Chunks To Make Sorted"><meta name=twitter:description content="動機
這裡的Monotonic Stack不同於84的用法
stack放的是sort好的區塊，放上最大值(或是區塊的最後一個)
或是利用只有0~n-1的特性"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-769 - Max Chunks To Make Sorted","item":"https://littlebees.github.io/2021/08/leetcode-769-max-chunks-to-make-sorted/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-769 - Max Chunks To Make Sorted","name":"leetcode-769 - Max Chunks To Make Sorted","description":"動機 這裡的Monotonic Stack不同於84的用法\nstack放的是sort好的區塊，放上最大值(或是區塊的最後一個)\n或是利用只有0~n-1的特性\n","keywords":["Monotonic Stack","Sorting","Greedy","Stack","Array"],"articleBody":"動機 這裡的Monotonic Stack不同於84的用法\nstack放的是sort好的區塊，放上最大值(或是區塊的最後一個)\n或是利用只有0~n-1的特性\nProblem You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1].\nWe split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\nReturn the largest number of chunks we can make to sort the array.\nExample 1:\nInput: arr = [4,3,2,1,0]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.Example 2:\nInput: arr = [1,0,2,3,4]Output: 4Explanation:We can split into two chunks, such as [1, 0], [2, 3, 4].However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. Constraints:\nn == arr.length1 \u003c= n \u003c= 100 \u003c= arr[i] \u003c nAll the elements of arr are unique. Sol class Solution: def maxChunksToSorted(self, arr: List[int]) -\u003e int: stk = [] for n in arr: maxN = n while stk and stk[-1] \u003e n: maxN = max(maxN, stk.pop()) stk += maxN, return len(stk) 但這裡可以利用只有0~n-1的特性!! 只要在對的位置上，從0~i之間，一定是最大的\nclass Solution: def maxChunksToSorted(self, arr: List[int]) -\u003e int: curMax, res = -1, 0 for i, v in enumerate(arr): curMax = max(curMax, v) res += curMax == i return res ","wordCount":"220","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-08-20T00:50:08Z","dateModified":"2021-08-20T00:50:08Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/08/leetcode-769-max-chunks-to-make-sorted/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-769 - Max Chunks To Make Sorted</h1><div class=post-meta><span title='2021-08-20 00:50:08 +0000 UTC'>August 20, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>這裡的Monotonic Stack不同於84的用法</p><p>stack放的是sort好的區塊，放上最大值(或是區塊的最後一個)</p><p>或是利用只有0~n-1的特性</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>You are given an integer array <code>arr</code> of length <code>n</code> that represents a permutation of the integers in the range <code>[0, n - 1]</code>.</p><p>We split <code>arr</code> into some number of <strong>chunks</strong> (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.</p><p>Return <em>the largest number of chunks we can make to sort the array</em>.</p><p> </p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> arr = [4,3,2,1,0]<strong>Output:</strong> 1<strong>Explanation:</strong>Splitting into two or more chunks will not return the required result.For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> arr = [1,0,2,3,4]<strong>Output:</strong> 4<strong>Explanation:</strong>We can split into two chunks, such as [1, 0], [2, 3, 4].However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>n == arr.length</code></li><li><code>1 <= n <= 10</code></li><li><code>0 <= arr[i] < n</code></li><li>All the elements of <code>arr</code> are <strong>unique</strong>.</li></ul><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>maxChunksToSorted</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>arr</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>stk</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>arr</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>maxN</span> <span class=o>=</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>stk</span> <span class=ow>and</span> <span class=n>stk</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>maxN</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>maxN</span><span class=p>,</span> <span class=n>stk</span><span class=o>.</span><span class=n>pop</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=n>stk</span> <span class=o>+=</span> <span class=n>maxN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=n>stk</span><span class=p>)</span>
</span></span></code></pre></div><p>但這裡可以利用只有0~n-1的特性!!
只要在對的位置上，從0~i之間，一定是最大的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>maxChunksToSorted</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>arr</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>curMax</span><span class=p>,</span> <span class=n>res</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>curMax</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>curMax</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>res</span> <span class=o>+=</span> <span class=n>curMax</span> <span class=o>==</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>res</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/monotonic-stack/>Monotonic Stack</a></li><li><a href=https://littlebees.github.io/tags/sorting/>Sorting</a></li><li><a href=https://littlebees.github.io/tags/greedy/>Greedy</a></li><li><a href=https://littlebees.github.io/tags/stack/>Stack</a></li><li><a href=https://littlebees.github.io/tags/array/>Array</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/08/leetcode-768-max-chunks-to-make-sorted-ii/><span class=title>« Prev</span><br><span>leetcode-768 - Max Chunks To Make Sorted II</span>
</a><a class=next href=https://littlebees.github.io/2021/08/leetcode-1130-minimum-cost-tree-from-leaf-values/><span class=title>Next »</span><br><span>leetcode-1130 - Minimum Cost Tree From Leaf Values</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>