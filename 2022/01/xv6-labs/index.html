<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>xv6 labs | 記事本</title>
<meta name=keywords content="System"><meta name=description content="動機

What I can not create I do not understand.

6.s081是個了解unix與c語言的超讚課程
有許多符合自修性質

有實作
有test
有解答可以參考

這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記
lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2022/01/xv6-labs/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2022/01/xv6-labs/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="xv6 labs"><meta property="og:description" content="動機

What I can not create I do not understand.

6.s081是個了解unix與c語言的超讚課程
有許多符合自修性質

有實作
有test
有解答可以參考

這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記
lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2022/01/xv6-labs/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-21T11:27:50+00:00"><meta property="article:modified_time" content="2022-01-21T11:27:50+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="xv6 labs"><meta name=twitter:description content="動機

What I can not create I do not understand.

6.s081是個了解unix與c語言的超讚課程
有許多符合自修性質

有實作
有test
有解答可以參考

這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記
lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"xv6 labs","item":"https://littlebees.github.io/2022/01/xv6-labs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"xv6 labs","name":"xv6 labs","description":"動機 What I can not create I do not understand.\n6.s081是個了解unix與c語言的超讚課程\n有許多符合自修性質\n有實作 有test 有解答可以參考 這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記 lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多\n","keywords":["System"],"articleBody":"動機 What I can not create I do not understand.\n6.s081是個了解unix與c語言的超讚課程\n有許多符合自修性質\n有實作 有test 有解答可以參考 這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記 lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多\n裝環境 我是在win11 WSL2的ubuntu 20.04跑\nsudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu gcc-riscv64-unknown-elf 需要參考的話，我的lab code在這\n怎麼在lab使用gdb 在~/.gdbinit加add-auto-load-safe-path ~/xv6-labs/.gdbinit 跑make qemu-gdb 在另一個視窗跑gdb-multiarch 如何debug 在panic打上breakpoint 利用make產生的xxx.asm，可以用addr去對，找到哪一行出事了(addr2line -e kernel/kernel pc-value) qemu的Ctrl-a x是關閉，Ctrl-a c是類似gdb可以info mem看pagetable 一點一點的寫，可以用panic去停下cpu看狀態對不對 在沒有動過的地方掛了、一開始就動不了 可能理由 mem不知道寫到哪了 腦袋要清楚mem到底要怎麼寫 這個是va, pa, pte? 這裡是page, stack的終點還是起點? 資料往哪邊長? stack是高往低 一般資料是低往高 concurrent沒處理好 deadlock 這個去trace中間用到的function應該可以看到一些東西 有人跟你用一樣的lock 拿lock的順序對嗎 沒有用lock包好 思考有哪些資料是要一起動的，思考在lock結束後有什麼性質要有 reference counter freelist ch1 在riscv中，CPU == hart\nfd 因為綁定0,1成stdin, stdout 所以會需要close，之後再開新的file完成redirect 因為fd是從小的開始分配\nif(fork() == 0) { close(0); open(\"input.txt\", O_RDONLY); exec(\"cat\", argv); } dup做soft copy，所以下面的file會是hello world\nfd = dup(1); write(1, \"hello\", 6); write(fd, \"world\\n\", 6); 這裡想完成的事就是dynamic scope或是Parameterize\npipe pipe會產生一個file(in mem)，之後開2個fd，下面是redirect stdin到pipe\npipe(p); if(fork() == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); exec(\"/bin/wc\", argv); } else { write(p[1], \"hello world\\n\", 12); close(p[0]); close(p[1]); } 這等於就是把ref裡面的東西暴露給user阿 (因為綁定0,1成stdin, stdout)\ntrace: pipe pipe是由兩個file控制的ring buffer 由寫到哪(nwrite)與讀到哪(nread)控制sleep與wakeup alloc pipe\nsys_pipe alloc 兩個struct file pipealloc設定兩個file kalloc一塊page，作為struct pipe 讓file能指到struct pipe 把fd寫回去 copyout留到pagetable那章談 write/read syscall\nsys_write/sys_write filewrite/fileread根據struct file的type跑到pipe去 piperead 空了 AND 對面還想要寫 pi-\u003enread == pi-\u003enwrite \u0026\u0026 pi-\u003ewriteopen 先去睡覺 開始寫到addr (increase nread) 注意到這是個ring buffer!! 都好了就wakeup對面 (用nwrite去認) sleeplock留到lock那章談 pipewrite 對面不想要讀 return 如果 滿了 pi-\u003enwrite == pi-\u003enread + PIPESIZE wakeup對面 (用nread去認) 先去睡覺 沒滿 從addr讀到struct pipe中 (increase nwrite) close syscall\nsys_close pipeclose 根據fd來看是不是用來寫的 之後關對應的狀態 wakeup另外一邊 Lab Utilities sleep 練手用\n#include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" int main(int argc, char *argv[]) { if (argc != 2) fprintf(2, \"sleep: 2 args\\n\"); sleep(atoi(argv[1])); exit(0); } pingpong 這裡開始寫簡單的pipe\n從前面的trace可以看出，pipe只有三個狀態下會換手\nread/write完成 空了/滿了 close 所以寫pipe時要記得把所有read/write該關的都關一關\n#include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" void closeR(int *p) { close(p[0]); } void closeW(int *p) { close(p[1]); } int main(int argc, char *argv[]) { int p2c[2], c2p[2]; pipe(p2c), pipe(c2p); if (fork()) { int tmp = 0; closeR(p2c); closeW(c2p); write(p2c[1], \u0026tmp, sizeof(int)); read(c2p[0], \u0026tmp, sizeof(int)); printf(\"%d: received pong\\n\", getpid()); closeW(p2c); closeR(c2p); } else { int tmp = 1; closeW(p2c); closeR(c2p); read(p2c[0], \u0026tmp, sizeof(int)); printf(\"%d: received ping\\n\", getpid()); write(c2p[1], \u0026tmp, sizeof(int)); closeR(p2c); closeW(c2p); } exit(0); } find 主要是練怎麼用file stat，以及認識到c處理string是多麼麻煩\n#include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" #include \"kernel/fs.h\" char* getFilename(char *path) { char *start = path; int len = strlen(path); path += len; for(;path != start \u0026\u0026 *path != '/';path--) ; if (*path == '/') path++; return path; } int isSubstring(char* s1, char* s2) { int M = strlen(s1); int N = strlen(s2); /* A loop to slide pat[] one by one */ for (int i = 0; i \u003c= N - M; i++) { int j; for (j = 0; j \u003c M; j++) if (s2[i + j] != s1[j]) break; if (j == M) return 1; } return 0; } int isNotDots(char* name) { int len = strlen(name); return len \u003e= 3 || (len == 2 \u0026\u0026 name[0] != '.' \u0026\u0026 name[1] != '.') || (len == 1 \u0026\u0026 name[0] != '.'); } void find(char *path, char *pat, int has) { char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) \u003c 0){ fprintf(2, \"ls: cannot open %s\\n\", path); return; } if(fstat(fd, \u0026st) \u003c 0){ fprintf(2, \"ls: cannot stat %s\\n\", path); close(fd); return; } switch(st.type){ case T_FILE: if (has) printf(\"%s\\n\", path); break; case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf){ printf(\"ls: path too long\\n\"); break; } strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, \u0026st) \u003c 0){ printf(\"ls: cannot stat %s\\n\", buf); continue; } char* filename = getFilename(buf); if (isNotDots(filename)) { find(buf, pat, has || isSubstring(pat, filename)); } } break; } close(fd); } int main(int argc, char *argv[]) { find(argv[1], argv[2], 0); exit(0); } xargs 因為我從沒用過xargs所以一開始寫根本不知道這要幹嘛\nxargs就是讀stdout，用空格或斷行當成分隔，去invoke指令\n不過這裡在讀的時候要一直loop，就算你知道test data基本上一次就讀的完\n可以順便說說虛假喚醒的原因\n喚醒會把所有proc設定成可以跑(runnable) scheduler只會挑出一個proc跑 如果這個proc做一下改變，就直接被切走… 但其他proc還是runnable!! 這樣其他proc還是被wakeup的!! 虛假喚醒是來自preemptive schedule，所以只能在每次wakeup時確認需要的前提有沒有對，才繼續跑\n#include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" char* strncpy(char *s, const char *t, int n) { char *os; os = s; while(n-- \u003e 0 \u0026\u0026 (*s++ = *t++) != 0) ; while(n-- \u003e 0) *s++ = 0; return os; } int main(int argc, char *argv[]) { char buf[10][32]; char tmp[32]; char *cmd[10]; for (int i=1;i\u003cargc;i++) strncpy(buf[i-1], argv[i], strlen(argv[i])); while (read(0, tmp, 32) \u003e 0) { // 虛假喚醒!! char *start = tmp; int end = argc-1; for(int len=strlen(tmp),i=0;i\u003clen;i++) if (tmp[i] == ' ' || tmp[i] == '\\n') { tmp[i] = 0; strcpy(buf[end++], start); start = tmp+i+1; } for (int i=0;i\u003cend;i++) cmd[i] = (char*)\u0026(buf[i]); if (fork()) wait(0); else exec(buf[0], cmd); } exit(0); } primes 全部裡面最有趣的，也是考驗會不會用pipe\n這裡的做法是，每個stage(go)\n取第一個數字作為這邊的質數 剩下塞到新的pipe，產生下一個stage #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" void put(int *p, int n) { write(p[1], \u0026n, sizeof(int)); } int get(int *p) { int ret; int state = read(p[0], \u0026ret, sizeof(int)); if (state \u003c= 0) return state; else return ret; } void endWrite(int *p) { close(p[1]); } void endRead(int *p) { close(p[0]); } void go(int *p) { // WARN: get a item one time!! int b = get(p); if (b \u003e 0) { printf(\"prime %d\\n\", b); int n = get(p); if (n \u003e 0) { int pp[2]; pipe(pp); if (fork() == 0) { endWrite(pp); go(pp); } else { endRead(pp); for(;n \u003e 0;n=get(p)) if (n % b != 0) put(pp,n); endWrite(pp); wait(0); } } } endRead(p); } int main() { int p[2]; pipe(p); if (fork() == 0) { endWrite(p); go(p); } else { endRead(p); for (int n=2;n\u003c36;n++) put(p,n); endWrite(p); wait(0); } exit(0); } ch2 Isolation 隔離是由下面兩個東西提供保證的\n硬體 執行模式 OS process (使用不同的stack) 其他 (cgroup, 權限管理…) 先看執行模式\n執行模式 RISC-V 有三種模式，CPU 可以執行指令：\n機器模式 監督者（supervisor）模式 CPU 被允許執行特權指令：例如，啟用和禁用中斷，讀寫保存頁表地址的寄存器等 用戶模式 CPU提供了一個特殊的指令(ecall)，可以將 CPU 從用戶模式切換到監督模式，並在內核指定的入口處進入內核。\n一個關鍵的設計問題是操作系統的哪一部分應該在監督者模式下運行。\n宏內核 整個操作系統駐留在內核中，這樣所有系統調用的實現都在監督者模式下運行 微內核 減少在監督者模式下運行的操作系統代碼量，而在用戶模式下執行操作系統的大部分代碼 process process 就是 一台電腦\n硬體 kernel syscall CPU concurrent mechnism process state mem page table stack kernel stack (kstack) user stack 透過assign不同的pagetable讓process只能看到與使用一部份的mem，這樣就算把自己的搞壞也沒關係\nprocess的mem layout xv6 只使用 39 位中的 38 位。因此，最大地址是 2^38-1 = 0x3fffffffff，也就是 MAXVA\n在地址空間的頂端，xv6 保留了一頁，用於 trampoline 和映射進程trapframe 的頁，以便切換到內核\ntrace: init 在kernel load完後會call init去setup shell 這裡主要是看怎麼從kernel mode變成user mode\nloader 将 xv6 内核加载到物理地址 0x80000000 的内存中 0x80000000 而不是 0x0，是因为地址范围 0x0-0x80000000 包含 I/O 设备。 _entry处的指令设置了一个栈(stack0)，这样xv6就可以运行C代码 注意 stack0被宣告在start.c riscv的stack是往下長的!! 所以，entry.S做的事用一句話來說 sp = stack0+PGSIZE 跑到start 這裡是machine mode 設定切hyperviser mode 關中斷 關paging 設定pc成main 設定timer的東西 (timerinit) 用mret跳去main，同時切成hyperviser mode 跑main 設定各種設定 最後跑userinit，跑kernel的第一個程式 在main跑userinit，就會去帶init alloc proc之後設定一些基本訊息 把跑init的binary (exec(\"/init\"))，copy到proc的記憶體中 binary的asm在user的initcode.S 就是透過a7去打exec exec會把記憶體換掉，所以變成init init(init.c)做兩件事 fork: 開sh main: 一直wait，zombie或是shell之類的proc 同時之後init跑完就會變成user mode 為什麼會變成user mode?? 看到exec 先讀elf 用uvmalloc設定pagetable uvmalloc設定PTE時會代PTE_U (usermode記憶體) 之後到syscall的流程 (usertrapret) 設定user mode 設定user pagetable userret做ctx switch+trap的switch trace: syscall user mode的syscall usys.pl include syscall.h拿syscall編號 會產生一段設定a7的asm 這就是syscall kernel mode的syscall syscall.h 這裡有所有syscall的編號 usys.pl的ecall觸發trap，切到kernel mode trap之後會提，反正會到usertrap 看mstatus，之後跑syscall 根據num，跑對應的syscal return code寫到a0，之後透過剩下的trap流程 回到usertrap 跑usertrapret(切pagetable與user mode)，userret user的參數怎麼pass到syscall的? 以argint為例\ncall argraw argraw直接拿trapframe的value 在此如果是addr也是這樣拿到addr 但是之後要處理pagetable的copyin, copyout接手去複製資料 Lab System calls trace 就是在proc上設定mask，之後只要syscall時就看mask決定要不要print\n// ... extern uint64 sys_trace(void); extern uint64 sys_sysinfo(void); static uint64 (*syscalls[])(void) = { // ... [SYS_trace] sys_trace, [SYS_sysinfo] sys_sysinfo, }; static char* syscallnames[24] = { \"\", \"fork\", \"exit\", \"wait\", \"pipe\", \"read\", \"kill\", \"exec\", \"fstat\", \"chdir\", \"dup\", \"getpid\", \"sbrk\", \"sleep\", \"uptime\", \"open\", \"write\", \"mknod\", \"unlink\", \"link\", \"mkdir\", \"close\", \"trace\", \"sysinfo\", }; void syscall(void) { // ... struct proc *p = myproc(); // ... if(num \u003e 0 \u0026\u0026 num \u003c NELEM(syscalls) \u0026\u0026 syscalls[num]) { p-\u003etrapframe-\u003ea0 = syscalls[num](); if ((1 \u003c\u003c num) \u0026 p-\u003etracemask) printf(\"%d: syscall %s -\u003e %d\\n\", p-\u003epid, syscallnames[num], p-\u003etrapframe-\u003ea0); // } else { // ... } } sysinfo 這裡的重點是\n數freemem 數unused procs 數unused procs就是從proc表去數\nint getAllocedProcsCount(void) { int ret = 0; for(struct proc *p = proc; p \u003c \u0026proc[NPROC]; p++) if (p-\u003estate != UNUSED) ret++; return ret; } 數freemem從freelist去數(幸好是用page去分不然會很麻煩) 4096是page的大小(PGSIZE)\nint getFreeMemAmount(void) { int ret = 0; for(struct run* ptr = kmem.freelist; ptr; ptr=ptr-\u003enext) ret += 4096; return ret; } 剩下的問題是怎麼copy struct過去 所以我們需要copy addr過去user space的struct\nuint64 sys_sysinfo(void) { uint64 infoAddr; // user pointer to struct stat if(argaddr(0, \u0026infoAddr) \u003c 0) return -1; struct sysinfo info = { .freemem = getFreeMemAmount(), .nproc = getAllocedProcsCount(), }; struct proc* p = myproc(); if(copyout(p-\u003epagetable, infoAddr, (char *)\u0026info, sizeof(info)) \u003c 0) return -1; return 0; } ch4\u00265 trap trap有3種\nfrom user mode (syscall) from device (device interrupt) from cpu (exception) trap通常的順序是\ntrap 迫使控制權轉移到內核 內核保存寄存器和其他狀態，以便恢復執行 內核執行適當的處理程序代碼（例如，系統調用實現或設備驅動程序） 內核恢復保存的狀態，並從 trap 中返回 代碼從原來的地方恢復。 Xv6 trap 處理分為四個階段\nRISC-V CPU 採取的硬件行為 為內核 C 代碼準備的彙編入口 處理 trap 的 C 處理程序 系統調用或設備驅動服務 RISC-V trap mechinism 重要的reg\nstvec：內核在這裡寫下 trap 處理程序的地址；RISC-V 到這裡來處理 trap。 sepc：當 trap 發生時，RISC-V 會將程序計數器保存在這裡（因為 PC 會被 stvec 覆蓋）。 sret: 從 trap 中返回 scause：RISC -V 在這裡放了一個數字，描述了 trap 的原因。 sscratch：內核在這裡放置了一個值，這個值會方便 trap 恢復/儲存用戶上下文。 sstatus: 類似attr，SIE 位控制設備中斷是否被啟用，SPP 位表示 trap 是來自用戶模式還是監督者模式，並控制sret 返回到什麼模式\nRISC-V 硬件對所有的 trap 類型（除定時器中斷外）進行以下操作\n如果該 trap 是設備中斷，且 sstatus SIE 位為 1 通過清除 SIE 來禁用中斷 複製 pc 到 sepc 將當前模式(用戶或監督者)保存在 sstatus 的 SPP 位 在 scause 設置該次 trap 的原因 將模式轉換為監督者 將 stvec 複製到 pc 執行新的 pc CPU 不會切換到內核頁表，不會切換到內核中的棧，也不會保存 pc 以外的任何寄存器!! 內核軟件必須執行這些任務!!\ntrace: trap from user space 從proc的trampoline開始\n跑uservec (kernel mode，因為是中斷) 保存狀態到trapframe trapframe可以 保存所有用户寄存器 指向当前进程的内核栈 当前 CPU 的 hartid usertrap 的地址和内核页表的地址的指针 換kernel pagetable (透過設定satp) 跳usertrap (kernel mode) 設定stvec成kernelvec 保存pc syscall或是device interrupt usertrap完到usertrapret (kernel mode)\n設定成stvec，要到uservec 把kernel資訊寫到trapframe 設定pc (trap的重點!!!) 設定user pagetable 設定user mode 跳到userret (user mode) 把trapframe載回去 return 到原本的位置 trace: exec syscall 用戶代碼將 exec 的參數放在寄存器 a0 和 a1 中，並將系統調用號放在 a7 中 系統調用號與函數指針表 syscalls 數組(kernel/syscall.c:108)中的項匹配 (from trapframe的a7) ecall 指令進入內核，執行uservec、usertrap，然後執行 syscall 當系統調用函數返回時，syscall 將其返回值記錄在 p-\u003etrapframe-\u003ea0 中 如果有pointer? 透過kernel function去load 使用 fetchstr 從用戶空間中檢索字符串文件名參數，fetchstr 調用 copyinstr 來做這些困難的工作\ntrap from kernel space kernel的trap因為在kernel所以不用換pagetable、stvec 同時因為大家都有自己的kstack，所以可以把registrer存在stack上\nkernelvec 保存狀態到kstack 跳到kerneltrap (會回來kernelvec) 保存pc, sstatus, scause pc很正常，但sstatus,scause!? 如果是timer interupt會yield 等回來，會需要原本的sstatus,scause 做該做的事 timer的preemptive切換在這裡實現 回復sstatus,scause之後return 從kstack回復狀態 trap from device 許多設備驅動程序在兩個 context 中執行代碼： 上半部分(top half)在進程的內核線程中運行 下半部分(bottom half)在中斷時執行\n上半部分是通過系統調用，如希望執行 I/O 的read 和 write。 這段代碼可能會要求硬件開始一個操作（比如要求磁盤讀取一個塊）；然後代碼等待操作完成。 最終設備完成操作並引發一個中斷。 驅動程序的中斷處理程序，作為下半部分，推算出什麼操作已經完成，如果合適的話，喚醒一個等待該操作的進程，並告訴硬件執行下一個操作。\ntrace: Console input UART 硬件在軟件看來是一組內存映射的控制寄存器 (不用port操作啦)\n當 UART 接收到一個字節的輸入時，就產生一個接收中斷，當 UART 每次完成發送一個字節的輸出時產生一個傳輸完成(transmit complete)中斷(kernel/uart.c:53)。\ntrap 處理程序調用 devintr(kernel/trap.c:177)，它查看 RISC-V 的 scause 寄存器，發現中斷來自一個外部設備。 然後它向一個叫做 PLIC的硬件單元詢問哪個設備中斷了(kernel/trap.c:186)。 如果是 UART，devintr 調用 uartintr。\nuartintr (kernel/uart.c:180) 從 UART 硬件中讀取在等待的輸入字符，並將它們交給consoleintr (kernel/console.c:138)； 它不會等待輸入字符，因為以後的輸入會引發一個新的中斷。 consoleintr 的工作是將中輸入字符積累 cons.buf 中，直到有一行字符\n一旦被喚醒，consoleread 將會注意到 cons.buf 中的完整行，並將其將其複製到用戶空間，並返回（通過系統調用）到用戶空間。\ntrace: Console output write 系統調用最終會到達 uartputc(kernel/uart.c:87)。 設備驅動維護了一個輸出緩衝區(uart_tx_buf)，uartputc 將每個字符追加到緩衝區調用 uartstart 來啟動設備發送(如果還沒有的話)，然後返回\n每次 UART 發送完成一個字節，它都會產生一個中斷。 uartintr 調用 uartstart，uartintr檢查設備是否真的發送完畢，並將下一個緩衝輸出字符交給設備，每當 UART 發送完一個字節，就會產生一個中斷\nTimer interrupts RISC-V 要求在機器模式下處理定時器中斷，而不是監督者模式。 因此，xv6 對定時器中斷的處理與上面談到的 trap 機製完全分離了。\n所以都在start中設定\n對 CLINT 硬件（core-local interruptor）進行編程，使其每隔一定時間產生一次中斷 設置一個類似於 trapframe 的 scratch 區域，幫助定時器中斷處理程序保存寄存器和 CLINT 寄存器的地址 所以前面trap要保留scratch的內容 將 mtvec 設置為 timervec，啟用定時器中斷 中斷之後由clockintr處理 (tick++) interrupt還是要處理concurent 內核代碼需要注意它可能會被暫停（由於定時器中斷），然後在不同的 CPU 上恢復\n等等，一直發trap? UART 驅動器通過讀取 UART 控制寄存器，一次檢索一個字節的數據 這種模式被稱為編程 I/O，因為軟件在驅動數據移動。\n程序化 I/O 簡單，但速度太慢，無法在高數據速率下使用。\n需要高速移動大量數據的設備通常使用直接內存訪問（DMA） DMA 設備硬件直接將傳入數據寫入 RAM，並從 RAM 中讀取傳出數據\n當設備在不可預知的時間需要關注時，中斷是很有用的，而且不會太頻繁。 但中斷對 CPU的開銷很大。 因此，高速設備，如網絡和磁盤控制器，使用了減少對中斷需求的技巧。\n其中一個技巧是對整批傳入或傳出的請求提出一個單一的中斷。 另一個技巧是讓驅動程序完全禁用中斷，並定期檢查設備是否需要關注。 這種技術稱為輪詢（polling）。 如果設備執行操作的速度非常快，輪詢是有意義的 但如果設備大部分時間處於空閒狀態，則會浪費 CPU 時間 一些驅動程序會根據當前設備的負載情況，在輪詢和中斷之間動態切換\nLab Traps backtrace defs.h加\nvoid backtrace(void); 接著hint有提到sp與fp，所以就直接用吧 但這裡用struct讓code好看一點\n注意到riscv是小頭，所以mem addr小的會被放到struct最前面 這段我是加在printf.c\nstruct stk_frame { void * prev_frame_plus_16; uint64 ret_addr; }; static inline uint64 r_fp() { uint64 x; asm volatile(\"mv %0, s0\" : \"=r\" (x) ); return x; } /* riscv是小頭 所以addr越小，在c struct會被往上面放 stack是往下長 (addr-8) 所以寫struct要把下面的往struct的上面放 (stack倒著放) */ void backtrace(void) { struct stk_frame* now = (struct stk_frame*)(r_fp()-16); uint64 start = PGROUNDDOWN(now-\u003eret_addr); for (struct stk_frame* now = (struct stk_frame*)(r_fp()-16); now-\u003eret_addr \u003e start; now=now-\u003eprev_frame_plus_16-16) printf(\"%p\\n\", now-\u003eret_addr); } 最後就直接call\nuint64 sys_sleep(void) { int n; uint ticks0; backtrace(); if(argint(0, \u0026n) \u003c 0) return -1; // ... } fp \u0026 sp from hint sp就是目前stack的top fp就是保存caller訊息的addr\ncaller reg: caller要存，換言之，在call完function後可能會被破壞掉 callee reg: callee要還原，換言之，在call完function後他們的值還是對的\nalarm 如果timer動了就call一下callback，透過兩個syscall，sigalarm與sigreturn 但要怎麼到callback去，是要在kernel mode跑??\ntimer interupt最後會回到user mode，所以只要讓他不要回到原本的位置就好!! 這手法我們看過了，usertrapret與usertrap與kerneltrap都是透過改pc完成的\n所以我們也改pc到callback，但是執行時的狀態怎麼辦，要怎麼回去原本的狀態? 再多一個trapframe存原本的trapframe，在alarmreturn把原本的frame設回去\nsysproc.c\nuint64 sys_sigreturn(void) { struct proc * p = myproc(); p-\u003eacc = 0; memmove(p-\u003etrapframe, p-\u003etrapframe2, sizeof(struct trapframe)); return 0; } uint64 sys_sigalarm(void) { struct proc* p = myproc(); if(argint(0, \u0026p-\u003ecnt) \u003c 0) return -1; if(argaddr(1, \u0026p-\u003ecb) \u003c 0) return -1; return 0; } trap.c\n// ... if(which_dev == 2) { if (p-\u003ecnt) { if (++p-\u003eacc == p-\u003ecnt) { memmove(p-\u003etrapframe2, p-\u003etrapframe, sizeof(struct trapframe)); p-\u003etrapframe-\u003eepc = p-\u003ecb; } } yield(); } // ... Lab network driver 在2019的版本是要實現stack與driver的，所以很累，但2020就不用實現stack\ndriver driver的重點是怎麼與device溝通\niface都是用ring buffer去存資料\nxx_ring就是device的buffer的狀態，然後他們是array 那是要取哪一個?? write: 取E1000_TDT，這是接下去dirver要寫的位置 read: 取E1000_RDT，這是iface已經讀完的位置\nxx_mbuf是ring buffer對應到的memory\n所以 write: 把tx_ring[regs[E1000_TDT]]的狀態設定好，把addr指向第一個位置 read: 先拉regs[E1000_TDT]+1的mbuf，之後用新的mbuf蓋掉原本的\nint inc(int i, int len) { return (i+1) % len; } int e1000_transmit(struct mbuf *m) { acquire(\u0026e1000_lock); int i = regs[E1000_TDT], ret; if ((tx_ring[i].status \u0026 E1000_TXD_STAT_DD) == 0) { printf(\"not ready for trasmit\"); ret = -1; } else { // free previous mbuf if (tx_mbufs[i]) mbuffree(tx_mbufs[i]); tx_ring[i].addr = (uint64)m-\u003ehead; tx_ring[i].length = m-\u003elen; tx_ring[i].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS; tx_mbufs[i] = m; regs[E1000_TDT] = inc(i, TX_RING_SIZE); ret = 0; } release(\u0026e1000_lock); return ret; } // allocate mbuf for iface static void e1000_recv(void) { for (int i = inc(regs[E1000_RDT], RX_RING_SIZE);rx_ring[i].status \u0026 E1000_RXD_STAT_DD;i = inc(regs[E1000_RDT], RX_RING_SIZE)) { acquire(\u0026e1000_lock); struct mbuf* pkt = *(rx_mbufs+i); mbufput(pkt, rx_ring[i].length); rx_mbufs[i] = mbufalloc(0); // 從哪邊塞 rx_ring[i].addr = (uint64)rx_mbufs[i]-\u003ehead; rx_ring[i].status = 0; regs[E1000_RDT] = i; release(\u0026e1000_lock); net_rx(pkt); } } network stack 雖然說不用實現一個network stack，但我們可以trace看看\nrx net_rx 拉eth_header 判斷type決定要去哪 ntohs去轉數字 net_rx_ip 拉ip_header 各種判斷與check cksum routing 這裡只有看是不是給我們，不是就丟了 算udp長度 送去udp net_rx_udp 拉udp_header 各種判斷與check 把sip, sport, dport抓出來，送到sockrecvudp sockrecvudp 找到對的socket 把pkt塞到socket的queue tx sockwrite alloc mbuf copy data 送到net_tx_udp net_tx_udp 把sip, sport, dport轉成network order 設定udp header，並加在mbuf上 送到net_tx_ip net_tx_ip 與net_tx_udp很像，轉資料，加在mbuf上 送到net_tx_eth 不存在的routing 一般來說從ip到eth或是eth到ip之間要過routing 決定要繼續往上還是直接轉出去 以linux的netfilter為例 net_tx_eth 塞ethaddr，加在mbuf上 這裡是直接boardcast，所以迴避了arp call e1000_transmit ch3 來了，最難的部分，撐過去就會有全新的方式看待c了!!\n為什麼會難?\n很難debug，一個是要知道結構，也要只到這個數字對應到什麼，還有concurrent要處理 都是uint64 之後會在va, pte, pa一直轉來轉去 kernel mem layout 当内核通过高地址映射使用 stack 时，它们也可以通过直接映射的地址被内核访问 内核使用“直接映射”RAM 和内存映射设备寄存器，也就是在虚拟地址上映射硬件资源，这些地址与物理地址相等。 例如，内核本身在虚拟地址空间和物理内存中的位置都是KERNBASE=0x80000000。直接映射简化了读/写物理内存的内核代码。 pagetable page table就是把virtual address(va)，丟到table換出physical address(pa) 硬體上是分成3層，也因為多了一層抽象，所以可以多點attr 像後面就是看page有沒有PTE_V(Page Table Entry, PTE)，決定這個page是不是free\n要告訴硬件使用頁表，內核必須將根頁表頁的物理地址寫入 satp 寄存器中\npte, pagetable都是存在pa中!!\n如何map \u0026 如何把va換成pa pagetable就是hashtable，所以要先知道key,value到底要什麼?\nkey: va，在程式中跑的數字；pte，可以換出pagetable或是pa的數字，可以把pte當成page開頭的pa(見walk) value: pa，真實mem的addr\ntrace: free mem怎麼產生的 把kernel的memory layout打開來 中間的free memory就是我們需要的東西\n接著就是怎麼讓free memory可以被分配，要先切塊\nkinit freerange 從end到PHYSTOP跑kfree kfree就是加linked list 如何把va換成pa: walk 就是模擬在table跳的過程，一層一層換pte，到最後就可以用kalloc拿pa，利用pa設定對應的pte 之後回傳對應的pa\n那怎麼從va拿pte? 再看回去這張圖 注意到va最右手邊就是12個offset，之後看到pte的右手邊是10位flag，所以轉成pte就是把12位拿掉再把10位補回去\n#define PA2PTE(pa) ((((uint64)pa) \u003e\u003e 12) \u003c\u003c 10) #define PTE2PA(pte) (((pte) \u003e\u003e 10) \u003c\u003c 12) #define PTE_FLAGS(pte) ((pte) \u0026 0x3FF) 剩下就是walk三層table了\n// extract the three 9-bit page table indices from a virtual address. #define PXMASK 0x1FF // 9 bits #define PXSHIFT(level) (PGSHIFT+(9*(level))) #define PX(level, va) ((((uint64) (va)) \u003e\u003e PXSHIFT(level)) \u0026 PXMASK) // Return the address of the PTE in page table pagetable // that corresponds to virtual address va. If alloc!=0, // create any required page-table pages. // // The risc-v Sv39 scheme has three levels of page-table // pages. A page-table page contains 512 64-bit PTEs. // A 64-bit virtual address is split into five fields: // 39..63 -- must be zero. // 30..38 -- 9 bits of level-2 index. // 21..29 -- 9 bits of level-1 index. // 12..20 -- 9 bits of level-0 index. // 0..11 -- 12 bits of byte offset within the page. pte_t * walk(pagetable_t pagetable, uint64 va, int alloc) { if(va \u003e= MAXVA) panic(\"walk\"); for(int level = 2; level \u003e 0; level--) { pte_t *pte = \u0026pagetable[PX(level, va)]; if(*pte \u0026 PTE_V) { pagetable = (pagetable_t)PTE2PA(*pte); } else { if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; } } return \u0026pagetable[PX(0, va)]; } 如何map: mappages mappages就是walk很多次，一次一個page\n如果完成map就可以用c的*做操作!! 十分神奇，前面還是當成數字操作，之後就可以直接dereference\ntrace: 怎麼做mem alloc mem alloc，就是\nkalloc拿一塊page，拿到一個pa mappages在pagetable中設定va到pa trace: 怎麼free mem/pagetable free mem就是\nuvmunmap 會walk拉出pa 檢查有沒有被map過(有PTE_V) 如果有要free，就kfree free pagetable比較麻煩\nuvmfree uvmunmap把所有pa去掉 walkfree把pte去掉 trace: how to create kernel page table kvminit設定kernel_pagetable 跑kvmmake會生出kernel pagetable 先kalloc一塊放pagetable 之後照layout設定 kvminithart 設定satp how to access a page table: pagetable_t，它實際上是一個指向 RISC-V 根頁表頁的指針 (pa) process mem layout 當一個進程要求 xv6 提供更多的用戶內存時，xv6 首先使用 kalloc 來分配物理頁，然後將指向新物理頁的 PTE 添加到進程的頁表中。\nxv6 使用 PTE_V 來清除不使用的 PTE\ntrampoline是負責跳到hypervisor mode的code trapframe是在跳之前保存process狀態的地方\ntrace: sbrk 回傳目前的終點(sz)，之後算與原本size的差，之後調用uvmalloc 或 uvmdealloc縮放自己的大小\ntrace: exec open binary exe (namei) parse ELF 從proc_pagetable分配一個page，之後用uvmalloc為剩下的proc配置page exec配出來的mem layout可以看process mem layout的圖\nBefore labs 在做lab之前先看看要怎麼為某個va做map，會做兩件事\n拿一塊page 把va指(map)過去 這裡的va不一定是剛好在page的起點上!! 記得，所有mem都要以page為單位 故要先介紹兩個macro，因為之後很常用到\nPGROUNDUP: page的終點 usage: exec在alloc elf的執行檔後要alloc stack，就是先取PGROUNDUP，之後stack從PGROUNDUP開始alloc PGROUNDDOWN: page的起點 usage: mappages在一開始就先對傳進來的va做PGROUNDDOWN，之後才開始alloc Lab Page tables vmprint 小試身手，抄freewalk，走過每個pte即可\nvoid vmprint_dfs(pagetable_t pagetable, int dep) { if (*pagetable \u003c MAXVA) for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026 PTE_V) \u0026\u0026 pte \u003c MAXVA){ uint64 child = PTE2PA(pte); for (int j=0;j\u003cdep;j++) printf(\".. \"); printf(\"..%d: ptr %p pa %p\\n\", i, pte, child); vmprint_dfs((pagetable_t)child, dep+1); } } } void vmprint(pagetable_t pagetable) { printf(\"page table %p\\n\", pagetable); vmprint_dfs(pagetable, 0); } new copyin, copyinstr 現在想把user mode的資料加到kernel mode的表，這樣就不用copy來copy去\n先要有產生kernel pagetable的函數，並在struct proc中多加一個kernel pagetable\nvoid kpgtinit(pagetable_t t) { memset(t, 0, PGSIZE); // uart registers if (mappages(t, UART0, PGSIZE, UART0, PTE_R | PTE_W) \u003c 0) panic(\"kpgtinit: uart0\\n\"); // virtio mmio disk interface if (mappages(t, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W) \u003c 0) panic(\"kpgtinit: virtio0\\n\"); // CLINT if (mappages(t, CLINT, 0x10000, CLINT, PTE_R | PTE_W) \u003c 0) panic(\"kpgtinit: clint\\n\"); // PLIC if (mappages(t, PLIC, 0x400000, PLIC, PTE_R | PTE_W) \u003c 0) panic(\"kpgtinit: plic\\n\"); // map kernel text executable and read-only. if (mappages(t, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X) \u003c 0) panic(\"kpgtinit: kernel base\\n\"); // map kernel data and the physical RAM we'll make use of. if (mappages(t, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W) \u003c 0) panic(\"kpgtinit: kernel data\\n\"); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. if (mappages(t, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X) \u003c 0) panic(\"kpgtinit: trampoline\\n\"); } void switchPGT(pagetable_t t) { w_satp(MAKE_SATP(t)); sfence_vma(); } 因為每個process都有kernel table，所以可以把kstack分到每個kernel pagetable去，把procinit的kstack拿掉\nstatic struct proc* allocproc(void) { // ... p-\u003ekpagetable = (pagetable_t) kalloc(); kpgtinit(p-\u003ekpagetable); char *pa = kalloc(); if(pa == 0) panic(\"kalloc\"); uint64 va = KSTACK(0); mappages(p-\u003ekpagetable, va, PGSIZE, (uint64)pa, PTE_R | PTE_W); p-\u003ekstack = va; // ... } 所以現在每個process都有一個kernel pagetable，需要的時候會把user mode pagetable的map到在kernel pagetable也map一下\nvoid includeInto(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz) { pte_t *pte_from, *pte_to; uint64 a, pa; uint flags; if (newsz \u003c oldsz) return; oldsz = PGROUNDUP(oldsz); for (a = oldsz; a \u003c newsz; a += PGSIZE) { if ((pte_from = walk(pagetable, a, 0)) == 0) panic(\"includeInto: pte should exist\"); if ((pte_to = walk(kpagetable, a, 1)) == 0) panic(\"includeInto: walk fails\"); pa = PTE2PA(*pte_from); flags = (PTE_FLAGS(*pte_from) \u0026 (~PTE_U)); *pte_to = PA2PTE(pa) | flags; } } 需要的時候? 就是程式在kernel mode中時動到或是需要user mode的資料時\nuserinit growproc 這裡要看kernel的layout，PILC上面的其實不能用，因為已經被map了 fork exec void userinit(void) { // ... includeInto(p-\u003epagetable, p-\u003ekpagetable, 0, p-\u003esz); // prepare for the very first \"return\" from kernel to user. p-\u003etrapframe-\u003eepc = 0; // user program counter // ... } // Grow or shrink user memory by n bytes. // Return 0 on success, -1 on failure. int growproc(int n) { // ... if(n \u003e 0){ if (PGROUNDUP(sz + n) \u003e= PLIC) return -1; // ... includeInto(p-\u003epagetable, p-\u003ekpagetable, sz-n, sz); } else if(n \u003c 0){ sz = uvmdealloc(p-\u003epagetable, sz, sz + n); } p-\u003esz = sz; return 0; } // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { // ... includeInto(np-\u003epagetable, np-\u003ekpagetable, 0, np-\u003esz); safestrcpy(np-\u003ename, p-\u003ename, sizeof(p-\u003ename)); pid = np-\u003epid; np-\u003estate = RUNNABLE; release(\u0026np-\u003elock); return pid; } freeproc也把kernel pagetable也free掉，但是不能把kernel的項目的pa給free掉\nvoid freewalk_keepleaf(pagetable_t pagetable) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026 PTE_V)) { pagetable[i] = 0; if((pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0){ // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); freewalk_keepleaf((pagetable_t)child); } } } kfree((void*)pagetable); } void proc_freekpt(pagetable_t pagetable) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026 PTE_V)){ pagetable[i] = 0; if ((pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0) { uint64 child = PTE2PA(pte); proc_freekpt((pagetable_t)child); } } else if(pte \u0026 PTE_V){ panic(\"proc free kpt: leaf\"); } } kfree((void*)pagetable); } static void freeproc(struct proc *p) { // ... if(p-\u003epagetable) proc_freepagetable(p-\u003epagetable, p-\u003esz); if (p-\u003ekstack) { uvmunmap(p-\u003ekpagetable, p-\u003ekstack, 1,1); p-\u003ekstack = 0; } if(p-\u003ekpagetable) freewalk_keepleaf(p-\u003ekpagetable); p-\u003ekpagetable = 0; // ... } 最後就可以切到新的copyin, copyinstr了\nLab Lazy allocation 在sbrk不分配mem\nuint64 sys_sbrk(void) { int addr; int n; if(argint(0, \u0026n) \u003c 0) return -1; addr = myproc()-\u003esz; if(n \u003c 0) growproc(n); else myproc()-\u003esz += n; return addr; // !!! } 在page fault時做分配\nint do_lazy(uint64 addr) { struct proc* p = myproc(); int stkOverFlow = (addr \u003c p-\u003etrapframe-\u003esp); // page-faults on a virtual memory address higher than any allocated with sbrk() // this should be \u003e= not \u003e !!! int addrOutOfBound = (addr \u003e= p-\u003esz); void *mem; if (stkOverFlow) ;//printf(\"lazy: stack overflow\\n\"); else if(addrOutOfBound) ;//printf(\"lazy: addr over of bound\\n\"); else if((mem = kalloc()) == 0) ;//printf(\"out of pa\\n\"); else { memset(mem, 0, PGSIZE); if (mappages(p-\u003epagetable, PGROUNDDOWN(addr), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) \u003c 0)// ??? kfree(mem); else return 0; } return -1; } void usertrap(void) { // ... if(r_scause() == 8){ // ... intr_on(); syscall(); } else if(r_scause() == 13 || r_scause() == 15) { if (do_lazy(r_stval()) \u003c 0) p-\u003ekilled = 1; } else if((which_dev = devintr()) != 0){ // ok } // ... } 剩下要在走訪pte時忽略沒有PTE_V的page，這邊就看hint就知道要改哪\nLab Copy on-write 這裡會牽涉到reference counter，導致要處理concurrent!! 如果沒有處理好，連怎麼出事的都不知道\n先refcnt，代表有多少process有map到這個page\nstruct __refcnt{ struct spinlock lock; uint counter[(PHYSTOP - KERNBASE) / PGSIZE]; }; struct __refcnt refcnt; void refcnt_lock() { acquire(\u0026refcnt.lock); } void refcnt_unlock() { release(\u0026refcnt.lock); } void refcnt_create() { initlock(\u0026refcnt.lock, \"refcnt\"); refcnt_lock(); for(int i=0,goal=(PHYSTOP - KERNBASE) / PGSIZE;i\u003cgoal;i++) refcnt.counter[i] = 0; refcnt_unlock(); } inline uint64 refcnt_index(uint64 pa){ return (pa - KERNBASE) / PGSIZE; } void refcnt_set(uint64 pa, int n) { refcnt.counter[refcnt_index(pa)] = n; } inline uint refcnt_get(uint64 pa){ return refcnt.counter[refcnt_index(pa)]; } void refcnt_incr(uint64 pa){ refcnt.counter[refcnt_index(pa)]++; } void refcnt_desc(uint64 pa){ if (refcnt.counter[refcnt_index(pa)] \u003e 0) refcnt.counter[refcnt_index(pa)]--; else panic(\"wtf\"); } 之後page要會fork 兩個case\nrefcnt大於1: 產生新的page，原本的page的refcnt減1 refcnt等於1: 直接拿去用 int page_fork(uint64 va) { int ret; pagetable_t pgt = myproc()-\u003epagetable; va = PGROUNDDOWN(va); pte_t * pte = walk(pgt, va, 0); uint64 pa = PTE2PA(*pte); uint flags = PTE_FLAGS(*pte); if ((*pte) \u0026 PTE_COW) { refcnt_lock(); // MUST BE DONE TOGETHER!! if (refcnt_get(pa) \u003e 1) { void *mem = kalloc_cow(); if (mem != 0) { memmove(mem, (char*)pa, PGSIZE); if(mappages(pgt, va, PGSIZE, (uint64)mem, (flags \u0026 (~PTE_COW)) | PTE_W) != 0) ret = -1, kfree(mem); else ret = 0, refcnt_desc(pa); } else ret = -3; } else ret = 0, *pte = (*pte \u0026 ~PTE_COW) | PTE_W; refcnt_unlock(); } else ret = -2; return ret; } 與之相對，kfree只有在refcnt小於等於1時才free，其他都是decrease refcnt\nvoid kfree(void *pa) { struct run *r; refcnt_lock(); //premise: counter == 0 \u003c=\u003e this page is in freelist if (refcnt_get((uint64)pa) \u003c= 1) { if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u003c end || (uint64)pa \u003e= PHYSTOP) panic(\"kfree\"); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); refcnt_set((uint64)pa, 0); r = (struct run*)pa; acquire(\u0026kmem.lock); r-\u003enext = kmem.freelist; kmem.freelist = r; release(\u0026kmem.lock); } else refcnt_desc((uint64)pa); refcnt_unlock(); } 另外，從kernel mode複製到user mode也要fork page 如果都指向同一個page要分開\nint uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { // 從copy變成map // ... for(i = 0; i \u003c sz; i += PGSIZE){ // ... *pte = ((*pte) \u0026 (~PTE_W)) | PTE_COW; if(mappages(new, i, PGSIZE, (uint64)pa, (flags \u0026 (~PTE_W)) | PTE_COW) != 0) goto err; else { refcnt_lock(); refcnt_incr(pa); refcnt_unlock(); } } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; } int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) { uint64 n, va0, pa0; while(len \u003e 0){ // ... // 如果都指向同一個page要分開 pte_t* pte = walk(pagetable, va0, 0); if (pte \u0026\u0026 (*pte \u0026 PTE_COW)) if (page_fork(va0) != 0) return -1; // ... } } 之後把剩下的線串完\nvoid usertrap(void) { // ... } else if((r_scause() == 15)) { if (page_fork(r_stval())) p-\u003ekilled = 1; } else { // ... } 這邊有一個要注意的點 refcnt是跟著page走，所以直到page與refcnt設定好之前任何人都不該動refcnt 這導致kalloc與kalloc_cow的產生，因為refcnt會鎖，但是做page_fork時會動到兩個page，所以kalloc_cow不鎖，交給page_fork鎖\nvoid * kalloc(void) { // ... if(r) { refcnt_lock(); refcnt_incr((uint64)r); refcnt_unlock(); //printf(\"init: %p %d\\n\", r, refcnt_get((uint64)r)); memset((char*)r, 5, PGSIZE); // fill with junk } return (void*)r; } void * kalloc_cow(void) { // ... if(r) { refcnt_set((uint64)r, 1); //printf(\"init: %p %d\\n\", r, refcnt_get((uint64)r)); memset((char*)r, 5, PGSIZE); // fill with junk } return (void*)r; } 最後就像，lazy alloc做的一樣，要處理走訪pte時忽略沒有PTE_V的page\nlock心得 0. 上鎖\n先存狀態 都用同一個狀態延伸 把所有動作用同一個鎖包 (這會導致在不同branch要一直release) 確保假設被打破時可以馬上停下程式 (ex: panic(“wtf”)) Lab mmap 現在user可以自己設定自己的addr了!!\nQ: 這樣怎麼區分user設定的資料與程式設定的(原本活在pagetable中的)資料? A: 多一個vma去trace\nQ: 怎麼分配位置? A: 這隨便，這裡從TRAPFRAME之後開始\nQ: 如果alloc很多塊，卻只free其中幾塊，我們還有方法再利用那些mem嗎? A: 這要做compact，但我懶，沒做test會過\n先加vma，與sbrk很像，用vma_end紀錄最後的位置 記住，riscv是往addr小的地方開始填資料\nstruct entry { uint64 va_end; int size; int prot; int flag; struct file* f; }; #define VMA_SIZE 16 #define VMA_BASE (TRAPFRAME - PGSIZE) struct proc { // ... struct entry vma[VMA_SIZE]; uint64 vma_end; }; 之後要可以alloc vma，與get vma\nstruct entry* allocvma() { struct proc *p = myproc(); struct entry* ret = 0; for (int i = 0;i\u003cVMA_SIZE;i++) { if (p-\u003evma[i].size == 0) { ret = \u0026(p-\u003evma[i]); break; } } return ret; } struct entry* getvma(uint64 addr) { int i; struct proc *p = myproc(); for (i = 0;i\u003cVMA_SIZE;i++) if (p-\u003evma[i].size \u003e 0 \u0026\u0026 p-\u003evma[i].va_end \u003e addr \u0026\u0026 addr \u003e= p-\u003evma[i].va_end-p-\u003evma[i].size) break; return i \u003c VMA_SIZE ? \u0026(p-\u003evma[i]) : 0; } 把mmap, munmap加進去 這裡做lazy，只有在read/write才map與讀檔案\nuint64 sys_mmap(void) { struct file* f; uint64 ret = -1; int size, prot, flags, fd; struct proc *p = myproc(); int goodargs = (argint(1, \u0026size) \u003c 0 || argint(2, \u0026prot) \u003c 0 || argint(3, \u0026flags) \u003c 0 || argfd(4, \u0026fd, \u0026f) \u003c 0); if(goodargs || (!f-\u003ewritable \u0026\u0026 (prot \u0026 PROT_WRITE) \u0026\u0026 (flags \u0026 MAP_SHARED))) return ret; acquire(\u0026p-\u003elock); struct entry *vma = allocvma(); if (vma) { int pte_prot = 0; if (prot \u0026 PROT_READ) pte_prot |= PTE_R; if (prot \u0026 PROT_WRITE) pte_prot |= PTE_W; filedup(f); vma-\u003eva_end = p-\u003evma_end; // start在小 end在大 mmap回傳的addr是小的!! ret = vma-\u003eva_end-size; vma-\u003esize = size; vma-\u003ef = f; vma-\u003eprot = pte_prot; vma-\u003eflag = flags; p-\u003evma_end -= size; } release(\u0026p-\u003elock); return ret; } uint64 do_mummap(uint64 addr, int len) { struct proc* p = myproc(); struct entry *vma = getvma(addr); if (!vma || addr + len \u003e vma-\u003eva_end) { return -1; } //printf(\"??: %d start:%p va:%p va_end:%p end:%p\\n\", vma-\u003esize, vma-\u003eva_end-vma-\u003esize, addr, addr+len, vma-\u003eva_end); for (uint64 va=addr,end=addr+len;va \u003c end;va+=PGSIZE) { if (walkaddr(p-\u003epagetable, va)) { if (vma-\u003eflag \u0026 MAP_SHARED) filewrite(vma-\u003ef, va, PGSIZE); uvmunmap(p-\u003epagetable, va, 1, 1); } } if (addr == vma-\u003eva_end-vma-\u003esize \u0026\u0026 addr+len == vma-\u003eva_end) { vma-\u003esize = 0; //fileclose(vma-\u003ef); vma-\u003ef-\u003eref--; } else { vma-\u003esize -= len; if (addr+len == vma-\u003eva_end) vma-\u003eva_end -= len; } return 0; } uint64 sys_munmap(void) { uint64 addr; int len; if (argaddr(0, \u0026addr) \u003c 0 || argint(1, \u0026len) \u003c 0) return -1; return do_mummap(addr, len); } 在page fault才map與讀檔案\nint do_mmap(uint64 addr) { struct proc* p = myproc(); uint64 base = PGROUNDDOWN(addr); void *mem; if((mem = kalloc()) == 0) printf(\"out of pa\\n\"); else { struct entry* vma = getvma(addr); if (vma) { memset(mem, 0, PGSIZE); if (mappages(p-\u003epagetable, base, PGSIZE, (uint64)mem, vma-\u003eprot|PTE_U|PTE_X) \u003c 0) kfree(mem), printf(\"map fail\\n\"); else { ilock(vma-\u003ef-\u003eip); int offset = base - (vma-\u003eva_end-vma-\u003esize); readi(vma-\u003ef-\u003eip, 1, base, offset, PGSIZE); iunlock(vma-\u003ef-\u003eip); return 0; } } else { //printf(\"vma no found\\n\"); kfree(mem); } } return -1; } void usertrap(void) { // ... } else if(r_scause() == 13 || r_scause() == 15) { if (do_mmap(r_stval()) \u003c 0) p-\u003ekilled = 1; } else { // ... } 剩下就是初始化與在fork時vma用到的file要記得refcnt要遞增\nLinux crash tool 經過前面lab的洗禮，相信大家也對va,pa,pte的關係有深刻的了解 這樣可以來看看，在linux中怎麼改mem\ncrash tool: 可以分析kerneldump看ctx與kernel的struct /dev/mem: 整個mem的視圖，就是ch3第一張圖的所有東西都會在這裡看到 下面借用這裡的內容來看看這兩個怎麼一起用 先預設/dev/mem可以寫，pagetable沒有任何限制\n這裡可以看crash的指令\nvtop: show va的訊息 wr: 改寫 mem set: 把mem view改成該pid的process的view ps: 就是ps 改pte的map 兩個process，兩個page，兩個addr(0x34000000, 0x34004000)\n之後在crash中改pte指到的地方\n#include #include #include #include #include int main(int argc, char **argv) { int fd; unsigned long *addr; fd = open(\"/dev/mem\", O_RDWR); // 建立一個分頁 P1 映射到保留記憶體 addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0x34000000); // 修改 P1 的内容 *addr = 0x1122334455667788; printf(\"address at: %p content is: 0x%lx\\n\", addr, addr[0]); // 等待分頁交換 getchar(); printf(\"address at: %p content is: 0x%lx\\n\", addr, addr[0]); close(fd); munmap(addr, 4096); return 1; } #include #include #include #include #include int main(int argc, char **argv) { int fd; unsigned long *addr; fd = open(\"/dev/mem\", O_RDWR); // 建立分頁 P2 映射到保留的記憶體 addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0x34004000); // 修改 P2 的内容 *addr = 0x8877665544332211; printf(\"address at: %p content is: 0x%lx\\n\", addr, addr[0]); // 等待分頁交換 getchar(); printf(\"address at: %p content is: 0x%lx\\n\", addr, addr[0]); close(fd); munmap(addr, 4096); return 1; } 接著要找pte，找對面對到的pa\ncrash\u003e ps | grep master [8/287] 32334 32333 6 ffff93d0ed35c680 IN 0.0 4512 1384 master crash\u003e set 32334 PID: 32334 COMMAND: \"master\" TASK: ffff93d0ed35c680 [THREAD_INFO: ffff93d0ed35c680] CPU: 6 STATE: TASK_INTERRUPTIBLE crash\u003e vtop 0x7f8f3ba6a000 VIRTUAL PHYSICAL 7f8f3ba6a000 2c0000000 \u003c= va 與 pa PGD: 2ae2f87f8 =\u003e 80000002af219067 PUD: 2af2191e0 =\u003e 2a9d3c067 PMD: 2a9d3cee8 =\u003e 2ac34b067 PTE: 2ac34b350 =\u003e 80000002c0000267 \u003c= pte 與 對到的pa PAGE: 2c0000000 PTE PHYSICAL FLAGS 80000002c0000267 2c0000000 (PRESENT|RW|USER|ACCESSED|DIRTY|NX) VMA START END FLAGS FILE ffff93d0e894e000 7f8f3ba6a000 7f8f3ba6b000 d0444fb /dev/mem crash\u003e wr -64 -p 2ac34b350 80000002c0004267 \u003c= pte 與 對面對到的pa crash\u003e ps | grep slave 32348 32347 1 ffff93d0ed359780 IN 0.0 4512 1416 slave crash\u003e set 32348 PID: 32348 COMMAND: \"slave\" TASK: ffff93d0ed359780 [THREAD_INFO: ffff93d0ed359780] CPU: 1 STATE: TASK_INTERRUPTIBLE crash\u003e vtop 0x7f269fba3000 VIRTUAL PHYSICAL 7f269fba3000 2c0004000 PGD: 2ae2ca7f0 =\u003e 80000002ac354067 PUD: 2ac3544d0 =\u003e 2b45f6067 PMD: 2b45f67e8 =\u003e 2ac7db067 PTE: 2ac7dbd18 =\u003e 80000002c0004267 PAGE: 2c0004000 PTE PHYSICAL FLAGS 80000002c0004267 2c0004000 (PRESENT|RW|USER|ACCESSED|DIRTY|NX) VMA START END FLAGS FILE ffff93d0eea18820 7f269fba3000 7f269fba4000 d0444fb /dev/mem crash\u003e wr -64 -p 2ac7dbd18 80000002c0000267 改pa的值 先給個程式，印出va(不然無法知道pa)，之後直接改pa的值\n#include #include #include #include int main(int argc, char **argv) { unsigned char *addr; // 匿名映射一段記憶體空間 addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED, -1, 0); // 修改內容 strcpy(addr, \"浙江溫州皮鞋濕\"); // 只是範例，所以直接顯示 address 實際操作時需要手工 hack 記憶體位置 printf(\"address at: %p content is: %s\\n\", addr, addr); getchar(); printf(\"address at: %p content is: %s\\n\", addr, addr); munmap(addr, 4096); return 1; } 用crash找pa\ncrash\u003e ps | grep test 11608 11607 1 ffff93d0ed378000 IN 0.0 4512 1408 test crash\u003e set 11608 PID: 11608 COMMAND: \"test\" TASK: ffff93d0ed378000 [THREAD_INFO: ffff93d0ed378000] CPU: 1 STATE: TASK_INTERRUPTIBLE crash\u003e vtop 0x7f7d88693000 VIRTUAL PHYSICAL 7f7d88693000 1f83ed000 PGD: 2a73ee7f0 =\u003e 8000000220a30067 PUD: 220a30fb0 =\u003e 2ae1f4067 PMD: 2ae1f4218 =\u003e 2b0c7e067 PTE: 2b0c7e498 =\u003e 80000001f83ed867 PAGE: 1f83ed000 PTE PHYSICAL FLAGS 80000001f83ed867 1f83ed000 (PRESENT|RW|USER|ACCESSED|DIRTY|NX) VMA START END FLAGS FILE ffff93d0ec033450 7f7d88693000 7f7d88694000 80000fb dev/zero PAGE PHYSICAL MAPPING INDEX CNT FLAGS ffffd377c7e0fb40 1f83ed000 ffff93d0f01a9290 0 2 17ffffc0040038 uptodate,dirty,lru,swapbacked 現在我們知道0x1f83ed000就是我們要的位置!! 就改吧 mmap到pa去\n#include #include #include #include #include #include int main(int argc, char **argv) { int fd; unsigned char *addr; unsigned long off = 0x1f83ed000; fd = open(\"/dev/mem\", O_RDWR); addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, off); strcpy(addr, \"下雨進水不會胖\"); close(fd); munmap(addr, 4096); return 1; } 小結 這裡的例子很簡單，但是很可怕，基本上只要知道pa就什麼都擋不住了 同時如果知道struct的大小與偏移量，基本上就是可以操作任何東西了\n像是在task_struct遊走，改常數等等… 可以看上面的文章與這裡都有一些使用範例\nHeap Coruption 剛好提到記憶體，可以看看關於記憶體的問題，下面內容主要處自這裡\n在第一次的dump，backtrace沒有印出正確的行號 文中提到懷疑是Heap Coruption的理由是 崩潰是發生在存取非法位址 這個行號所在的程式碼單純到沒辦法找到造成問題的部分在哪 可以猜猜看why 亂序執行 concurrent，但明顯不是 之前在不對的地方沒有停下來 可以試試把array超過length的地方print出來: print的出來!! 如果這是迴圈中出事就還好，但如果出了loop… 第二次dump用了大招，上heap保護 這與xv6的stack的guard page一樣，出錯直接panic 這樣就可以直接看到對的地方，index出界，在8爆了 不是在5爆? 為了好分配mem，所以會對齊 回頭來看c的type到底是什麼? 一次要跳幾格 char是1 uint64是8 etc 所以c其實就是一直幫忙算這個addr一次跳幾格 出事由下面的cpu噴 linux有辦法這樣做嗎? 定位Memory Corruption的思路 ch6 當我們說鎖保護數據時，我們真正的意思是鎖保護了一些適用於數據的不變式(invariant）集合\n你可以把鎖看成是把並發的臨界區串行化(serializing)的一種工具，使它們同時只運行一個，從而保護 invariant（假設臨界區是獨立的）。\n正確地使用鎖可以保證一次只能有一個 CPU 對關鍵部分的數據結構進行操作，所以當數據結構的 invariant 不成立時，沒有 CPU 會執行數據結構操作\n如果一個穿過內核的代碼路徑必須同時持有多個鎖，那麼所有的代碼路徑以相同的順序獲取這些鎖是很重要的 * 有時鎖的身份並不是事先知道的，也許是因為必須持有一個鎖才能發現接下來要獲取的鎖的身份\nCPU 的 ordering 規則稱為內存模型!! (目前看過最精練的解釋)\n自旋锁 關中斷 atomic cas while looping =\u003e lock mem barrier =\u003e mem barrier 一個中斷處理程序使用了自旋鎖，CPU 決不能在啟用中斷的情況下持有該鎖。 Xv6 比較保守：當一個 CPU 獲取任何鎖時，xv6 總是禁用該 CPU 上的中斷。\nxv6 在 CPU 沒有持有自旋鎖時重新啟用中斷；它必須做一點記錄來應對嵌套的臨界區。\n這個spinlock可以recursive!! 因為有紀錄cpu id所以可以處理這一段\ntrace: spinlock 我們把debug有關的部分skip掉\n// Mutual exclusion lock. struct spinlock { uint locked; // Is the lock held? }; acquire對數字做test_and_set，不成功就一直轉\n這裡要用riscv提供的指令去換，不然被reorder就出事了 因為原本有設定cpuid的部分，導致還需要memory barrier 但這裡就先跳掉 void acquire(struct spinlock *lk) { push_off(); while(__sync_lock_test_and_set(\u0026lk-\u003elocked, 1) != 0) ; } release就是acquire反著做\nvoid release(struct spinlock *lk) { __sync_lock_release(\u0026lk-\u003elocked); pop_off(); } 睡眠锁 擴展自旋锁，多了sleep\n上spinlock 直到拿到鎖之前，一直sleep 處理虛假喚醒 這裡是把sleep多傳一個lock，保證sleep後lock會被釋放 pthread也是，但是叫condition var\ntrace: sleeplock struct sleeplock { uint locked; // Is the lock held? struct spinlock lk; // spinlock protecting this sleep lock }; acquire與release其實很簡單，用spinlock保護locked 如果只有保護locked能用atomic?\n答案是不行，因為還要保護成功sleep\nvoid acquiresleep(struct sleeplock *lk) { acquire(\u0026lk-\u003elk); while (lk-\u003elocked) { sleep(lk, \u0026lk-\u003elk); } lk-\u003elocked = 1; release(\u0026lk-\u003elk); } void releasesleep(struct sleeplock *lk) { acquire(\u0026lk-\u003elk); lk-\u003elocked = 0; wakeup(lk); release(\u0026lk-\u003elk); } 為了可以在有lock當狀態下sleep，變成sleep要解上面lock，之後再鎖自己的lock 可以看到這邊lock涵蓋的範圍有overlay\n如果有用過pthread的cond var就會看到一樣的東西!!\nvoid sleep(void *chan, struct spinlock *lk) { struct proc *p = myproc(); if(lk != \u0026p-\u003elock){ //DOC: sleeplock0 acquire(\u0026p-\u003elock); //DOC: sleeplock1 release(lk); } // ... // Reacquire original lock. if(lk != \u0026p-\u003elock){ release(\u0026p-\u003elock); acquire(lk); } } 用什麼鎖 因為睡眠鎖會使中斷處於啟用狀態，所以不能在中斷處理程序中使用睡眠鎖\n自旋鎖最適合短的臨界區，因為等待它們會浪費 CPU 時間 睡眠鎖對長時間的操作很有效\nLab Lock Memory allocator 把freelist放到各個cpu中\nstruct cpu { // ... struct run *freelist; struct spinlock lock; }; 所以kalloc要從自己的list中找，如果沒有就去偷 kfree就直接塞回自己的list\nvoid* kalloc(void) { // ... push_off(); int i = cpuid(); acquire(\u0026cpus[i].lock); if (!cpus[i].freelist) { r = steal_page(i); } else { r = cpus[i].freelist; cpus[i].freelist = r-\u003enext; } release(\u0026cpus[i].lock); pop_off(); // ... } void kfree(void *pa) { // ... int i = cpuid(); acquire(\u0026cpus[i].lock); r-\u003enext = cpus[i].freelist; cpus[i].freelist = r; release(\u0026cpus[i].lock); pop_off(); } 偷就是走訪其他cpu看有沒有free的\nvoid* steal_page(int i) { // interrupt should be disabled void *ret = 0; for (int j=((i+1)%NCPU); !ret \u0026\u0026 j!=i; j=((j+1)%NCPU)) { acquire(\u0026cpus[j].lock); if (cpus[j].freelist) { ret = cpus[j].freelist; cpus[j].freelist = cpus[j].freelist-\u003enext; } release(\u0026cpus[j].lock); } return ret; } Buffer cache 其實可以用前面的想法，把list打散\n#define TBL_SIZE 7 struct entry { struct buf head; struct spinlock lock; }; struct entry tbl[TBL_SIZE]; void insert_buf(struct buf* head, struct buf* b) { b-\u003enext = head-\u003enext, b-\u003eprev = head; head-\u003enext-\u003eprev = b, head-\u003enext = b; } 拿不到就去偷\nbget(uint dev, uint blockno) { struct buf *b; //acquire(\u0026bcache.lock); // Is the block already cached? int i = tbl_index(dev, blockno); acquire(\u0026tbl[i].lock); // check cache for(b = tbl[i].head.next; b != \u0026tbl[i].head; b = b-\u003enext) if(b-\u003edev == dev \u0026\u0026 b-\u003eblockno == blockno){ b-\u003erefcnt++; release(\u0026tbl[i].lock); acquiresleep(\u0026b-\u003elock); return b; } // steal free buf for (int j=i, cnt=0;cnt \u003c TBL_SIZE;j=((j+1)%TBL_SIZE),cnt++) { if (i != j) acquire(\u0026tbl[j].lock); for(b = tbl[j].head.next; b != \u0026tbl[j].head; b = b-\u003enext){ if(b-\u003erefcnt == 0){ b-\u003edev = dev; b-\u003eblockno = blockno; b-\u003evalid = 0; b-\u003erefcnt = 1; b-\u003etbl_index = i; struct buf *prev = b-\u003eprev, *next = b-\u003enext; if (prev) { prev-\u003enext = next; } else { tbl[j].head.next = next; } if (next) { next-\u003eprev = prev; } insert_buf(\u0026tbl[i].head, b); if (i != j) release(\u0026tbl[j].lock); release(\u0026tbl[i].lock); acquiresleep(\u0026b-\u003elock); return b; } } if (i != j) release(\u0026tbl[j].lock); } release(\u0026tbl[i].lock); panic(\"bget: no buffers\"); } 剩下的就是把bcache改成用到對的list\nstruct buf { int tbl_index; // ... }; ch7 xv6 的sleep 和 wakeup 機制會進行切換 這會發生在進程等待設備或管道 I/O 等待子進程退出 在 sleep 系統調用中等待\nxv6 週期性地強制切換，以應對長時間的計算進程。\n首先，如何從一個進程切換到另一個進程？ 第二，如何對用戶進程透明的強制切換？ (用定時器中斷來驅動上下文切換) 第三，許多 CPU 可能會在進程間並發切換，需要設計一個鎖來避免競爭。 第四，當進程退出時，必須釋放進程的內存和其他資源，但它自己不能做到這一切，因為它不能釋放自己的內核棧，同時又在使用內核棧。 第五，多核機器的每個內核必須記住它正在執行的進程，這樣系統調用就會修改相應進程的內核狀態。 最後，sleep 和 wakeup 允許一個進程放棄 CPU，並睡眠等待事件，並允許另一個進程喚醒第一個進程。\n需要注意一些競爭可能會使喚醒丟失!!\ncoperative thread: sleep, wakeup, ctx switch, scheduler ctx switch xv6 調度器在每個 CPU 上有一個專門的線程(保存的寄存器和棧)，因為調度器在舊進程的內核棧上執行是不安全的\n棧指針和 pc 被保存和恢復，意味著 CPU 將切換棧和正在執行的代碼\nSwtch(kernel/swtch.S:3)只保存 callee-saved 寄存器，caller-saved 寄存器由調用的 C 代碼保存在堆棧上(如果需要)\n它不保存 pc。 當swtch 返回時，它返回到被恢復的 ra 寄存器所指向的指令，也就是新線程之前調用 swtch的指令。 此外，它還會在新線程的棧上返回。\nscheduler 其實就是在沒有process在跑的時候選一個跑\nmain會call，scheduler 之後scheduler挑一個proc (RR) ctx switch 到ctx switch時還沒release lock!! 對於上下文切換來說，有必要打破這個約定，因為 p-\u003elock 保護了進程的狀態和 context 字段上的不變式(invariant)，而這些不變式在 swtch 中執行時為 false。 都是與mycpu換ctx!! 所以可以看成mycpu()-\u003econtext就是正在跑的cpu的state，也是proc的state(不是RUNNABLE之類的，是執行的狀態) p-\u003elock?? 可以這樣理解調度代碼結構，它執行一組關於進程的不變式，並且每當這些不變式為False 時，就持有 p-\u003elock。\n一個不變式是，\n如果一個進程正在運行，定時器中斷的 yield 必須能夠安全地切換進程； 這意味著 CPU 寄存器必須持有進程的寄存器值（即 swtch 沒有將它們移到上下文中） 並且 c-\u003eproc 必須指向該進程。 另一個不變式是， 如果一個進程是RUNNABLE 的，那麼對於一個空閒的 CPU 調度器來說，運行它必須是安全的 這意味著 （1）p-\u003econtext 必須擁有進程的寄存器（i.e., 它們實際上並不在真實的寄存器中） （2）沒有 CPU 在進程的內核棧上執行 （3）也沒有 CPU 的 c-\u003eproc 指向進程 請注意，當 p-\u003elock被持有時，這些屬性往往不為真。 維護上述不變式的原因：xv6 經常在一個線程中獲取 p-\u003elock，然後在另一個線程中釋放\n直到成功轉移state之前都要hold lock\nmycpu and myproc Xv6 為每個 CPU 維護了一個 cpu 結構體(kernel/proc.h:22)，它記錄了當前在該 CPU 上 運行的進程(如果有的話)，為 CPU 的調度線程保存的寄存器，以及管理中斷禁用所需的嵌套 自旋鎖的計數。\nXv6 確保每個 CPU 的 hartid 在內核中被存儲在該 CPU 的 tp 寄存器中\nUsertrapret 將 tp 寄存器保存在 trampoline 頁中，因為用戶進程可能會修改 tp 寄存器\n當從用戶空間進入內核時，uservec 會恢復保存的 tp(kernel/trampoline.S:70)。編譯器保證永遠不使用 tp 寄存器。\n如果 RISC-V 允許 xv6 直接讀取當前的 hartid 會更方便\ncpuid 和 mycpu 的返回值很容易錯： 如果定時器中斷，導致線程讓出 CPU，然後轉移到不同的 CPU 上，之前返回的值將不再正確。 為了避免這個問題，xv6 要求調用者禁用中斷，只有在使用完返回的 cpu 結構後才啟用中斷\nmyproc(kernel/proc.c:68)函數返回當前 CPU 上運行的進程的 proc 指針。 myproc 禁用中斷，調用 mycpu，從 cpu 中獲取當前進程指針(c-\u003eproc)，然後啟用中斷。\nmyproc不用lock防嗎?? 當下指到的proc是對的\nSleep 為了確保進入sleep前的state改變不會被打斷 (eg: semaphore的P)\nsleep會先hold proc的lock，才去\nrelease 前一個lock 改proc狀態 p-\u003echan = chan; p-\u003estate = SLEEPING; sched 這邊會看到一個有趣的事，與scheduler一樣，p-\u003elock沒有release!!\nwakeup 把所有聽在同一個lock(semaphore)的proc的state設定成runnable\n虛假喚醒 wakeup會把所有proc，叫醒，但只有一個proc可以拿到lock\n所以對其他proc而言，這是虛假喚醒!!\nexit \u0026 wait exit: 把file close，把proc設定成ZOMBIE，sched wait: 掃child proc，看有沒有ZOMBIE，有就設定成UNUSED；沒有就sleep\n父進程和子進程的 wait 和 exit，以及 exit 和 exit 之間可能出現競爭和死鎖的情況\n此 xv6 的所有鎖都必須遵守相同的鎖順序（父進程的鎖，然後是子進程的鎖），以避免死鎖\npreemptive thread time interrupt時做sched\nvoid usertrap(void) { // ... // give up the CPU if this is a timer interrupt. if(which_dev == 2) yield(); } trace: trapframe \u0026 context 看回來這張圖 sched都是在kernel mode發生，所以不用換pagetable\nsched是換手，也就是我已經做了差不多了，所以會主動call函數，之後只要回來我這邊就好， 但是換回來函數的執行環境(callee-save)會壞掉，所以要存； 用於計算用的參數就，沒有用(做了差不多了，或是說已經存在stack上了(會call函數c會處理))，就不用管\ntrap是中斷，所以之後要在原本的地方跑(還沒做完)，因此要保留原本的pc，不然沒辦法接回去； 同時要保留caller-save，trap可以看成call函數，但沒有c的幫忙，所以這要自己存； 剩下是ctx switch，所以callee-save也要存\ntrace: exit \u0026 wait exit:\n把opend file關一關 把parent設定成init 把自己state設定成ZOMBIE wait\n掃過整個proc，找符合下面兩個條件的proc parent是caller的proc state是ZOMBIE 找到就 acquire child的lock (wait!!) 拉proc的return值(xstate) freeproc 沒找到 state不是ZOMBIE parent sleep 沒有proc認caller做parent 報錯 這裡就可以回答一個經典問題，為什麼要有ZOMBIE? 因為把proc回收分成\n關file: exit free mem: wait 而在wait可以拿到proc的return值(所以不能free mem) 但我們需要一個方式表示proc準備好被回收，所以有ZOMBIE\n但為什麼叫ZOMBIE? 這我真的不懂，不能叫EXITED嗎?\nLab Multithreading ph 練手用\npthread_mutex_t table_locks[NBUCKET]; static void insert(int key, int value, struct entry **p, struct entry *n) { // ... // is the key already present? struct entry *e = 0; pthread_mutex_lock(table_locks+i); for (e = table[i]; e != 0; e = e-\u003enext) { // ... insert(key, value, \u0026table[i], table[i]); } pthread_mutex_unlock(table_locks+i); } barrier 這個就有趣了\n一開始會想只要一個出去把counter設成0就好，但這樣while的部分就會出事，可能有人出不來\n這樣我們挑最後一個去reset計數器，但這樣也會有問題，如果說最後一個一直被hang住，之後中間有跑比較快的進來，這樣就不是barrier\n所以鎖要保護兩個條件\n進來時要確認上一輪的不在這裡了 人數到了就能release，最後一個要去reset計數器 static void barrier() { static int no_one_here = 1, in_room = 0; pthread_mutex_lock(\u0026bstate.barrier_mutex); while (!no_one_here) pthread_cond_wait(\u0026bstate.barrier_cond, \u0026bstate.barrier_mutex); pthread_cond_broadcast(\u0026bstate.barrier_cond); bstate.nthread++, in_room++; while (bstate.nthread != nthread) pthread_cond_wait(\u0026bstate.barrier_cond, \u0026bstate.barrier_mutex); if (in_room-- == nthread) no_one_here = 0, bstate.round++; if (in_room == 0) no_one_here = 1, bstate.nthread = 0; pthread_cond_broadcast(\u0026bstate.barrier_cond); pthread_mutex_unlock(\u0026bstate.barrier_mutex); } uthread 這題就去抄context與swtch就好\n但重點是，\n要怎麼到thread的function去? trap是改pc，因為我們不會再回來trap中 但thread可以多次來回，所以需要一個自動回到對的位置的機制，ra\nthread的記憶體要放在哪? 回想當初init怎麼做，讓之後的c可以跑? 從stack0放一個PGSIZE，指到sp void thread_create(void (*func)()) { // ... t-\u003ectx.ra = (uint64)func; // HERE t-\u003ectx.sp = (uint64)t-\u003estack + STACK_SIZE-1; } ch8 磁盤層在 virtio 磁盤上讀寫塊\n緩存層(bio.c)緩存磁盤塊，並同步訪問它們，確保一個塊只能同時被內核中的一個進程訪問\nbuffer 緩存是一個由 buffer 組成的雙端鍊錶 bget根據devid、sector找buffer bread/bwrite讀寫buffer brelse釋放sleep lock bread拿鎖 日誌層(log.c)允許上層通過事務更新多個磁盤塊，並確保在崩潰時，磁盤塊是原子更新的（即全部更新或不更新）\n日誌由一個 header 塊組成，後面是一連串的更新塊副本（日誌塊）。 header 塊包含一個扇區號數組， 每個扇區號都對應一個日誌塊，header 還包含日誌塊的數量 日誌系統可以將多個系統調用的寫操作累積到一個事務中 一次提交可能涉及多個完整系統調用的寫入 為了避免一個系統調用被分裂到不同的事務中，只有在沒有文件系統相關的系統調用正在進行時，日誌系統才會提交 Xv6 在磁盤上劃出固定的空間來存放日誌。在一個事務中，系統調用所寫的塊總數必須 適應這個空間的大小 系統調用寫入的日誌大小必須小於日誌空間的大小 Xv6 的 write 系統調用將大的寫操作分解成多個小的寫操作，以適應在日誌空間的大小 unlink 不會引起問題，因為 xv6 文件系統只使用一個位圖塊 日誌系統只會在確定了系統調用的寫操作可以適應剩餘日誌空間之後，才會開始執行該系統調用 inode 層(fs.c)將一個文件都表示為一個 inode，每個文件包含一個唯一的 i-number 和一些存放文件數據的塊\nballoc 申請一個新的磁盤塊: iterate bitmap bfree 釋放一個塊: clear flag on block 磁盤上的inode 文件的大小和數據塊號的列表 磁盤上的 inode 被放置磁盤的一個連續區域 每一個 inode 的大小都是一樣的 所以，給定一個數字 n，很容易找到磁盤上的第 n 個 inode dinode定義了磁盤上的 inode 包含一個 size 和一個塊號數組 開始的 NDIRECT 個數據塊放置在數組中的前NDIRECT 個條目中，這些塊被稱為直接塊 接下來的 NINDIRECT 個數據塊並沒有放置在inode 中，而是被存放在叫做間接塊的數據塊中 Bmap 返回 inode ip 的第 bn 個數據塊的磁盤塊號。如果 ip 沒有第 bn 個的數據塊，bmap 就會分配一個 (mmap!!) mem中的inode 了磁盤上 inode 的副本以及內核中需要的其他信息 結構體 inode (kernel/file.h:17)是磁盤 dinode 的拷貝 ref 字段為指向 inode 的指針的數量，如果引用數量減少到零，內核就會從內存中丟棄這個 inode iget 和 iput 函數引用和釋放 inode，並修改引用計數 四種鎖 icache.lock 保證了一個 inode 在緩 存只有一個副本，以及緩存 inode 的 ref 字段計數正確 每個內存中的 inode 都有一個包含 sleep-lock 的鎖字段，它保證了可以獨占訪問 inode 的其他字段（如文件長度）以及 inode 的文件或目錄內容塊的 一個 inode 的 ref 如果大於 0，則會使系統將該 inode 保留在緩存 中，而不會重用該 inode 每個 inode 都包含一個 nlink 字段(在磁盤上，緩存時會復 製到內存中)，該字段統計鏈接該 inode 的目錄項的數量；如果一個 inode 的鏈接數大於零， xv6 不會釋放它 目錄層(fs.c)將實現了一種特殊的 inode，被稱為目錄，其包含一個目錄項序列，每個目錄項由文件名稱和 i-number 組成\n函數 dirlookup 在一個目錄中搜索一個帶有給定名稱的條目 函數 dirlink 會在當前目錄 dp 中創建一個新的目錄項 查找路徑名會對每一個節點調用一次 dirlookup Namex首先確定路徑解析從哪裡開始 如果路徑以斜線開頭，則從根目錄開始解析 否則，從當前目錄開始解析。 然後它使用 skipelem 來遍歷路徑中的每個元素 file(file.c)\n系統中所有打開的文件都保存在一個全局文件表中，即 ftable 文件表的功能有: 分配文件(filealloc) 創建重複引用(fileup) 釋放引用(fileclose) 讀寫數據(fileeread和filewrite)。 superblock， 它包含了文件系統的元數據（以塊為單位的文件系統大小、數據塊的數量、inode 的數量和日誌中的塊數）\n位圖塊(bitmap)，記錄哪些數據塊在使用\nballoc與kalloc與malloc的差別 kalloc: 直接丟一個page malloc: 從現有的mem拉一段va出來，如果沒空間了就sbrk加大 * sbrk: growproc -\u003e uvmalloc -\u003e kalloc -\u003e mappages * mappages: 把從kalloc拿到的page與加到pagetable balloc: 與kalloc很像，就是直接丟一個block出來 * 但要處理log!! * 去trace誰是空的 * mem用list(或AVL) * disk用bitmap\ntrace: how to read/write a file fileread readi bread拿buf，bmap算偏移(在hdd上的addr) copyout filewrite begin_op writei bread拿buf，bmap算偏移(在hdd上的addr) copyin log_write 記錄到log end_op commit write_log 寫buf到disk write_head commit log Lab File system big file 就是在block再放一個table，之後再多做一次\nstatic uint bmap(struct inode *ip, uint bn) { uint addr, *a; struct buf *bp; if(bn \u003c NDIRECT){ if((addr = ip-\u003eaddrs[bn]) == 0) ip-\u003eaddrs[bn] = addr = balloc(ip-\u003edev); return addr; } bn -= NDIRECT; if (bn \u003c BLOCKS) { // Load indirect block, allocating if necessary. if((addr = ip-\u003eaddrs[NDIRECT]) == 0) ip-\u003eaddrs[NDIRECT] = addr = balloc(ip-\u003edev); @@ -400,6 +401,30 @@ bmap(struct inode *ip, uint bn) brelse(bp); return addr; } bn -= BLOCKS; if (bn \u003c NINDIRECT) { // double indirect int i = bn/BLOCKS, j = bn%BLOCKS; if((addr = ip-\u003eaddrs[NDIRECT+1]) == 0) ip-\u003eaddrs[NDIRECT+1] = addr = balloc(ip-\u003edev); bp = bread(ip-\u003edev, addr); a = (uint*)bp-\u003edata; if((addr = a[i]) == 0){ a[i] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); // query addr from int[]'s data bp = bread(ip-\u003edev, addr); a = (uint*)bp-\u003edata; if((addr = a[j]) == 0) { a[j] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); return addr; } panic(\"bmap: out of range\"); } void itrunc(struct inode *ip) { int i, j; struct buf *bp; uint *a; for(i = 0; i \u003c NDIRECT; i++){ if(ip-\u003eaddrs[i]){ bfree(ip-\u003edev, ip-\u003eaddrs[i]); ip-\u003eaddrs[i] = 0; } } if(ip-\u003eaddrs[NDIRECT]){ bp = bread(ip-\u003edev, ip-\u003eaddrs[NDIRECT]); a = (uint*)bp-\u003edata; for(j = 0; j \u003c BLOCKS; j++){ if(a[j]) bfree(ip-\u003edev, a[j]); } brelse(bp); bfree(ip-\u003edev, ip-\u003eaddrs[NDIRECT]); ip-\u003eaddrs[NDIRECT] = 0; } uint *b; struct buf *bp2; if(ip-\u003eaddrs[NDIRECT+1]){ bp = bread(ip-\u003edev, ip-\u003eaddrs[NDIRECT+1]); a = (uint*)(bp-\u003edata); // int[] for(i = 0; i \u003c BLOCKS; i++){ if (a[i]) { bp2 = bread(ip-\u003edev, a[i]); b = (uint*)(bp2-\u003edata); for (j = 0; j \u003c BLOCKS; j++) if(b[j]) bfree(ip-\u003edev, b[j]); brelse(bp2); bfree(ip-\u003edev, a[i]); } } brelse(bp); bfree(ip-\u003edev, ip-\u003eaddrs[NDIRECT+1]); ip-\u003eaddrs[NDIRECT+1] = 0; } ip-\u003esize = 0; iupdate(ip); } symbol link 一個有path的檔案\nsyscall要先生出檔案，把path寫進去\nuint64 sys_symlink(void) { int n; char target[MAXPATH], path[MAXPATH]; struct inode *ip; if((n = argstr(0, target, MAXPATH)) \u003c 0 || argstr(1, path, MAXPATH) \u003c 0) return -1; begin_op(); ip = create(path, T_SYMLINK, 0, 0); for (int i=0, r = 0, n1 = 0, off = 0;i \u003c n \u0026\u0026 r == n1; i += r){ n1 = n - i; if ((r = writei(ip, 0, (uint64)target + i, off, n1)) \u003e 0) off += r; } ip-\u003enlink = 1; iunlockput(ip); end_op(); return 0; } open要能處理symbol link，與原本的檔案 如果遇到其他symbol link還要繼續follow\n抄原本的open，加symbol link的處理，最後遞迴\nuint64 real_open(char path[MAXPATH], int omode, int follow) { int fd; struct file *f; struct inode *ip; if(omode \u0026 O_CREATE){ ip = create(path, T_FILE, 0, 0); if(ip == 0){ return -1; } } else { if((ip = namei(path)) == 0){ return -1; } ilock(ip); if(ip-\u003etype == T_DIR \u0026\u0026 omode != O_RDONLY){ iunlockput(ip); return -1; } } if(ip-\u003etype == T_DEVICE \u0026\u0026 (ip-\u003emajor \u003c 0 || ip-\u003emajor \u003e= NDEV)){ iunlockput(ip); return -1; } if (ip-\u003etype == T_SYMLINK) { if (!(omode \u0026 O_NOFOLLOW)) { char target[MAXPATH]; if (follow \u003e FOLLOW_DEPS || readi(ip, 0, (uint64)target, 0, MAXPATH) \u003c 0) { iunlockput(ip); return -1; } iunlock(ip); return real_open(target, omode, follow+1); } } if((f = filealloc()) == 0 || (fd = fdalloc(f)) \u003c 0){ if(f) fileclose(f); iunlockput(ip); return -1; } if(ip-\u003etype == T_DEVICE){ f-\u003etype = FD_DEVICE; f-\u003emajor = ip-\u003emajor; } else { f-\u003etype = FD_INODE; f-\u003eoff = 0; } f-\u003eip = ip; f-\u003ereadable = !(omode \u0026 O_WRONLY); f-\u003ewritable = (omode \u0026 O_WRONLY) || (omode \u0026 O_RDWR); if((omode \u0026 O_TRUNC) \u0026\u0026 ip-\u003etype == T_FILE){ itrunc(ip); } iunlock(ip); return fd; } uint64 sys_open(void) { char path[MAXPATH]; int omode; int n; if((n = argstr(0, path, MAXPATH)) \u003c 0 || argint(1, \u0026omode) \u003c 0) return -1; begin_op(); uint64 ret = real_open(path, omode, 0); end_op(); return ret; } Ref 可以在google找到很多其他人的做法，都值得參考\nMIT6.S081 操作系统工程中文翻译 xv6-book-2020-Chinese\n","wordCount":"6382","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2022-01-21T11:27:50Z","dateModified":"2022-01-21T11:27:50Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2022/01/xv6-labs/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">xv6 labs</h1><div class=post-meta><span title='2022-01-21 11:27:50 +0000 UTC'>January 21, 2022</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e8%a3%9d%e7%92%b0%e5%a2%83 aria-label=裝環境>裝環境</a></li><li><a href=#%e6%80%8e%e9%ba%bc%e5%9c%a8lab%e4%bd%bf%e7%94%a8gdb aria-label=怎麼在lab使用gdb>怎麼在lab使用gdb</a></li><li><a href=#%e5%a6%82%e4%bd%95debug aria-label=如何debug>如何debug</a></li><li><a href=#ch1 aria-label=ch1>ch1</a><ul><li><a href=#fd aria-label=fd>fd</a></li><li><a href=#pipe aria-label=pipe>pipe</a><ul><li><a href=#trace-pipe aria-label="trace: pipe">trace: pipe</a></li></ul></li><li><a href=#lab-utilities aria-label="Lab Utilities">Lab Utilities</a><ul><li><a href=#sleep aria-label=sleep>sleep</a></li><li><a href=#pingpong aria-label=pingpong>pingpong</a></li><li><a href=#find aria-label=find>find</a></li><li><a href=#xargs aria-label=xargs>xargs</a></li><li><a href=#primes aria-label=primes>primes</a></li></ul></li></ul></li><li><a href=#ch2 aria-label=ch2>ch2</a><ul><li><a href=#isolation aria-label=Isolation>Isolation</a><ul><li><a href=#%e5%9f%b7%e8%a1%8c%e6%a8%a1%e5%bc%8f aria-label=執行模式>執行模式</a></li><li><a href=#process aria-label=process>process</a><ul><li><a href=#process%e7%9a%84mem-layout aria-label="process的mem layout">process的mem layout</a></li></ul></li></ul></li><li><a href=#trace-init aria-label="trace: init">trace: init</a></li><li><a href=#trace-syscall aria-label="trace: syscall">trace: syscall</a><ul><li><a href=#user-mode%e7%9a%84syscall aria-label="user mode的syscall">user mode的syscall</a></li><li><a href=#kernel-mode%e7%9a%84syscall aria-label="kernel mode的syscall">kernel mode的syscall</a></li><li><a href=#user%e7%9a%84%e5%8f%83%e6%95%b8%e6%80%8e%e9%ba%bcpass%e5%88%b0syscall%e7%9a%84 aria-label=user的參數怎麼pass到syscall的?>user的參數怎麼pass到syscall的?</a></li></ul></li><li><a href=#lab-system-calls aria-label="Lab System calls">Lab System calls</a><ul><li><a href=#trace aria-label=trace>trace</a></li><li><a href=#sysinfo aria-label=sysinfo>sysinfo</a></li></ul></li></ul></li><li><a href=#ch45 aria-label=ch4&amp;5>ch4&amp;5</a><ul><li><a href=#trap aria-label=trap>trap</a></li><li><a href=#risc-v-trap-mechinism aria-label="RISC-V trap mechinism">RISC-V trap mechinism</a></li><li><a href=#trace-trap-from-user-space aria-label="trace: trap from user space">trace: trap from user space</a><ul><li><a href=#trace-exec-syscall aria-label="trace: exec syscall">trace: exec syscall</a><ul><li><a href=#%e5%a6%82%e6%9e%9c%e6%9c%89pointer aria-label=如果有pointer?>如果有pointer?</a></li></ul></li></ul></li><li><a href=#trap-from-kernel-space aria-label="trap from kernel space">trap from kernel space</a></li><li><a href=#trap-from-device aria-label="trap from device">trap from device</a><ul><li><a href=#trace-console-input aria-label="trace: Console input">trace: Console input</a></li><li><a href=#trace-console-output aria-label="trace: Console output">trace: Console output</a></li></ul></li><li><a href=#timer-interrupts aria-label="Timer interrupts">Timer interrupts</a><ul><li><a href=#interrupt%e9%82%84%e6%98%af%e8%a6%81%e8%99%95%e7%90%86concurent aria-label=interrupt還是要處理concurent>interrupt還是要處理concurent</a></li></ul></li><li><a href=#%e7%ad%89%e7%ad%89%e4%b8%80%e7%9b%b4%e7%99%bctrap aria-label=等等，一直發trap?>等等，一直發trap?</a></li><li><a href=#lab-traps aria-label="Lab Traps">Lab Traps</a><ul><li><a href=#backtrace aria-label=backtrace>backtrace</a><ul><li><a href=#fp--sp aria-label="fp & sp">fp & sp</a></li></ul></li><li><a href=#alarm aria-label=alarm>alarm</a></li></ul></li><li><a href=#lab-network-driver aria-label="Lab network driver">Lab network driver</a><ul><li><a href=#driver aria-label=driver>driver</a></li><li><a href=#network-stack aria-label="network stack">network stack</a><ul><li><a href=#rx aria-label=rx>rx</a></li><li><a href=#tx aria-label=tx>tx</a></li></ul></li></ul></li></ul></li><li><a href=#ch3 aria-label=ch3>ch3</a><ul><li><a href=#kernel-mem-layout aria-label="kernel mem layout">kernel mem layout</a></li><li><a href=#pagetable aria-label=pagetable>pagetable</a></li><li><a href=#%e5%a6%82%e4%bd%95map--%e5%a6%82%e4%bd%95%e6%8a%8ava%e6%8f%9b%e6%88%90pa aria-label="如何map & 如何把va換成pa">如何map & 如何把va換成pa</a></li><li><a href=#trace-free-mem%e6%80%8e%e9%ba%bc%e7%94%a2%e7%94%9f%e7%9a%84 aria-label="trace: free mem怎麼產生的">trace: free mem怎麼產生的</a><ul><li><a href=#%e5%a6%82%e4%bd%95%e6%8a%8ava%e6%8f%9b%e6%88%90pa-walk aria-label="如何把va換成pa: walk">如何把va換成pa: walk</a></li><li><a href=#%e5%a6%82%e4%bd%95map-mappages aria-label="如何map: mappages">如何map: mappages</a></li></ul></li><li><a href=#trace-%e6%80%8e%e9%ba%bc%e5%81%9amem-alloc aria-label="trace: 怎麼做mem alloc">trace: 怎麼做mem alloc</a></li><li><a href=#trace-%e6%80%8e%e9%ba%bcfree-mempagetable aria-label="trace: 怎麼free mem/pagetable">trace: 怎麼free mem/pagetable</a><ul><li><a href=#trace-how-to-create-kernel-page-table aria-label="trace: how to create kernel page table">trace: how to create kernel page table</a></li></ul></li><li><a href=#process-mem-layout aria-label="process mem layout">process mem layout</a><ul><li><a href=#trace-sbrk aria-label="trace: sbrk">trace: sbrk</a></li><li><a href=#trace-exec aria-label="trace: exec">trace: exec</a></li></ul></li><li><a href=#before-labs aria-label="Before labs">Before labs</a></li><li><a href=#lab-page-tables aria-label="Lab Page tables">Lab Page tables</a><ul><li><a href=#vmprint aria-label=vmprint>vmprint</a></li><li><a href=#new-copyin-copyinstr aria-label="new copyin, copyinstr">new copyin, copyinstr</a></li></ul></li><li><a href=#lab-lazy-allocation aria-label="Lab Lazy allocation">Lab Lazy allocation</a></li><li><a href=#lab-copy-on-write aria-label="Lab Copy on-write">Lab Copy on-write</a></li><li><a href=#lab-mmap aria-label="Lab mmap">Lab mmap</a></li><li><a href=#linux-crash-tool aria-label="Linux crash tool">Linux crash tool</a><ul><li><a href=#%e6%94%b9pte%e7%9a%84map aria-label=改pte的map>改pte的map</a></li><li><a href=#%e6%94%b9pa%e7%9a%84%e5%80%bc aria-label=改pa的值>改pa的值</a></li><li><a href=#%e5%b0%8f%e7%b5%90 aria-label=小結>小結</a></li></ul></li><li><a href=#heap-coruption aria-label="Heap Coruption">Heap Coruption</a></li></ul></li><li><a href=#ch6 aria-label=ch6>ch6</a><ul><li><a href=#%e8%87%aa%e6%97%8b%e9%94%81 aria-label=自旋锁>自旋锁</a><ul><li><a href=#trace-spinlock aria-label="trace: spinlock">trace: spinlock</a></li></ul></li><li><a href=#%e7%9d%a1%e7%9c%a0%e9%94%81 aria-label=睡眠锁>睡眠锁</a><ul><li><a href=#trace-sleeplock aria-label="trace: sleeplock">trace: sleeplock</a></li></ul></li><li><a href=#%e7%94%a8%e4%bb%80%e9%ba%bc%e9%8e%96 aria-label=用什麼鎖>用什麼鎖</a></li><li><a href=#lab-lock aria-label="Lab Lock">Lab Lock</a><ul><li><a href=#memory-allocator aria-label="Memory allocator">Memory allocator</a></li><li><a href=#buffer-cache aria-label="Buffer cache">Buffer cache</a></li></ul></li></ul></li><li><a href=#ch7 aria-label=ch7>ch7</a><ul><li><a href=#coperative-thread-sleep-wakeup-ctx-switch-scheduler aria-label="coperative thread: sleep, wakeup, ctx switch, scheduler">coperative thread: sleep, wakeup, ctx switch, scheduler</a><ul><li><a href=#ctx-switch aria-label="ctx switch">ctx switch</a></li><li><a href=#scheduler aria-label=scheduler>scheduler</a><ul><li><a href=#p-lock aria-label="p->lock??">p->lock??</a></li><li><a href=#mycpu-and-myproc aria-label="mycpu and myproc">mycpu and myproc</a></li></ul></li><li><a href=#sleep-1 aria-label=Sleep>Sleep</a></li><li><a href=#wakeup aria-label=wakeup>wakeup</a><ul><li><a href=#%e8%99%9b%e5%81%87%e5%96%9a%e9%86%92 aria-label=虛假喚醒>虛假喚醒</a></li><li><a href=#exit--wait aria-label="exit & wait">exit & wait</a></li></ul></li></ul></li><li><a href=#preemptive-thread aria-label="preemptive thread">preemptive thread</a></li><li><a href=#trace-trapframe--context aria-label="trace: trapframe & context">trace: trapframe & context</a></li><li><a href=#trace-exit--wait aria-label="trace: exit & wait">trace: exit & wait</a></li><li><a href=#lab-multithreading aria-label="Lab Multithreading">Lab Multithreading</a><ul><li><a href=#ph aria-label=ph>ph</a></li><li><a href=#barrier aria-label=barrier>barrier</a></li><li><a href=#uthread aria-label=uthread>uthread</a></li></ul></li></ul></li><li><a href=#ch8 aria-label=ch8>ch8</a><ul><li><a href=#balloc%e8%88%87kalloc%e8%88%87malloc%e7%9a%84%e5%b7%ae%e5%88%a5 aria-label=balloc與kalloc與malloc的差別>balloc與kalloc與malloc的差別</a></li><li><a href=#trace-how-to-readwrite-a-file aria-label="trace: how to read/write a file">trace: how to read/write a file</a></li><li><a href=#lab-file-system aria-label="Lab File system">Lab File system</a><ul><li><a href=#big-file aria-label="big file">big file</a></li><li><a href=#symbol-link aria-label="symbol link">symbol link</a></li></ul></li></ul></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><blockquote><p>What I can not create I do not understand.</p></blockquote><p>6.s081是個了解unix與c語言的超讚課程</p><p>有許多符合自修性質</p><ul><li>有實作</li><li>有test</li><li>有解答可以參考</li></ul><p>這篇是我讀pdf(有人翻譯2020的pdf，所以有些句子可能看起來怪怪的)與lab的筆記
lab是2020版，6.s081有經歷幾次改版，lab的內容會換一下，尤其是2019到2020差有點多</p><h2 id=裝環境>裝環境<a hidden class=anchor aria-hidden=true href=#裝環境>#</a></h2><p>我是在win11 WSL2的ubuntu 20.04跑</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu gcc-riscv64-unknown-elf
</span></span></code></pre></div><p>需要參考的話，我的lab code在<a href=https://github.com/littlebees/xv6-labs>這</a></p><h2 id=怎麼在lab使用gdb>怎麼在lab使用gdb<a hidden class=anchor aria-hidden=true href=#怎麼在lab使用gdb>#</a></h2><ol><li>在<code>~/.gdbinit</code>加<code>add-auto-load-safe-path ~/xv6-labs/.gdbinit</code></li><li>跑<code>make qemu-gdb</code></li><li>在另一個視窗跑<code>gdb-multiarch</code></li></ol><h2 id=如何debug>如何debug<a hidden class=anchor aria-hidden=true href=#如何debug>#</a></h2><ol><li>在panic打上breakpoint</li><li>利用make產生的xxx.asm，可以用addr去對，找到哪一行出事了(<code>addr2line -e kernel/kernel pc-value</code>)</li><li>qemu的Ctrl-a x是關閉，Ctrl-a c是類似gdb可以info mem看pagetable</li><li>一點一點的寫，可以用panic去停下cpu看狀態對不對</li><li>在沒有動過的地方掛了、一開始就動不了<ul><li>可能理由<ul><li>mem不知道寫到哪了<ul><li>腦袋要清楚mem到底要怎麼寫<ul><li>這個是va, pa, pte?</li><li>這裡是page, stack的終點還是起點?</li><li>資料往哪邊長?<ul><li>stack是高往低</li><li>一般資料是低往高</li></ul></li></ul></li></ul></li><li>concurrent沒處理好<ul><li>deadlock<ul><li>這個去trace中間用到的function應該可以看到一些東西<ul><li>有人跟你用一樣的lock</li></ul></li><li>拿lock的順序對嗎</li></ul></li><li>沒有用lock包好<ul><li>思考有哪些資料是要一起動的，思考在lock結束後有什麼性質要有<ul><li>reference counter</li><li>freelist</li></ul></li></ul></li></ul></li></ul></li></ul></li></ol><h2 id=ch1>ch1<a hidden class=anchor aria-hidden=true href=#ch1>#</a></h2><p>在riscv中，CPU == hart</p><h3 id=fd>fd<a hidden class=anchor aria-hidden=true href=#fd>#</a></h3><p>因為綁定0,1成stdin, stdout
所以會需要close，之後再開新的file完成redirect
因為fd是從小的開始分配</p><pre tabindex=0><code class="language-c=" data-lang="c=">if(fork() == 0) {
    close(0);
    open(&#34;input.txt&#34;, O_RDONLY);
    exec(&#34;cat&#34;, argv);
}
</code></pre><p>dup做soft copy，所以下面的file會是hello world</p><pre tabindex=0><code class="language-c=" data-lang="c=">fd = dup(1);
write(1, &#34;hello&#34;, 6);
write(fd, &#34;world\n&#34;, 6);
</code></pre><p>這裡想完成的事就是dynamic scope或是<a href="https://www.greghendershott.com/2013/04/parameters-in-racket.html#:~:text=Racket%20parameters%20let%20you%20manage%20stateful%20global%20variables,how%20I%20map%20parameters%20to%20a%20configuration%20file.">Parameterize</a></p><h3 id=pipe>pipe<a hidden class=anchor aria-hidden=true href=#pipe>#</a></h3><p>pipe會產生一個file(in mem)，之後開2個fd，下面是redirect stdin到pipe</p><pre tabindex=0><code class="language-c=" data-lang="c=">pipe(p);
if(fork() == 0) {
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec(&#34;/bin/wc&#34;, argv);
} else {
    write(p[1], &#34;hello world\n&#34;, 12);
    close(p[0]);
    close(p[1]);
}
</code></pre><p>這等於就是把ref裡面的東西暴露給user阿
(因為綁定0,1成stdin, stdout)</p><h4 id=trace-pipe>trace: pipe<a hidden class=anchor aria-hidden=true href=#trace-pipe>#</a></h4><ul><li>pipe是由兩個file控制的ring buffer</li><li>由寫到哪(nwrite)與讀到哪(nread)控制sleep與wakeup</li></ul><p>alloc pipe</p><ul><li>sys_pipe<ul><li>alloc 兩個struct file</li><li>pipealloc設定兩個file<ul><li>kalloc一塊page，作為struct pipe</li><li>讓file能指到struct pipe</li></ul></li><li>把fd寫回去<ul><li>copyout留到pagetable那章談</li></ul></li></ul></li></ul><p>write/read syscall</p><ul><li>sys_write/sys_write<ul><li>filewrite/fileread根據struct file的type跑到pipe去<ul><li>piperead<ul><li>空了 AND 對面還想要寫<ul><li><code>pi->nread == pi->nwrite && pi->writeopen</code></li><li>先去睡覺</li></ul></li><li>開始寫到addr (increase nread)<ul><li>注意到這是個ring buffer!!</li></ul></li><li>都好了就wakeup對面 (用nwrite去認)<ul><li>sleeplock留到lock那章談</li></ul></li></ul></li><li>pipewrite<ul><li>對面不想要讀<ul><li>return</li></ul></li><li>如果<ul><li>滿了<ul><li><code>pi->nwrite == pi->nread + PIPESIZE</code></li><li>wakeup對面 (用nread去認)</li><li>先去睡覺</li></ul></li><li>沒滿<ul><li>從addr讀到struct pipe中 (increase nwrite)</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>close syscall</p><ul><li>sys_close<ul><li>pipeclose<ul><li>根據fd來看是不是用來寫的</li><li>之後關對應的狀態</li><li>wakeup另外一邊</li></ul></li></ul></li></ul><h3 id=lab-utilities>Lab Utilities<a hidden class=anchor aria-hidden=true href=#lab-utilities>#</a></h3><h4 id=sleep>sleep<a hidden class=anchor aria-hidden=true href=#sleep>#</a></h4><p>練手用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/stat.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;sleep: 2 args</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>sleep</span><span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=pingpong>pingpong<a hidden class=anchor aria-hidden=true href=#pingpong>#</a></h4><p>這裡開始寫簡單的pipe</p><p>從前面的trace可以看出，pipe只有三個狀態下會換手</p><ol><li>read/write完成</li><li>空了/滿了</li><li>close</li></ol><p>所以寫pipe時要記得把所有read/write該關的都關一關</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/stat.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>closeR</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span> <span class=nf>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>closeW</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span> <span class=nf>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>p2c</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>c2p</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=nf>pipe</span><span class=p>(</span><span class=n>p2c</span><span class=p>),</span> <span class=nf>pipe</span><span class=p>(</span><span class=n>c2p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>fork</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>closeR</span><span class=p>(</span><span class=n>p2c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>closeW</span><span class=p>(</span><span class=n>c2p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>write</span><span class=p>(</span><span class=n>p2c</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>tmp</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>c2p</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>tmp</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d: received pong</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=nf>closeW</span><span class=p>(</span><span class=n>p2c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>closeR</span><span class=p>(</span><span class=n>c2p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>closeW</span><span class=p>(</span><span class=n>p2c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>closeR</span><span class=p>(</span><span class=n>c2p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>p2c</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>tmp</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d: received ping</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=nf>write</span><span class=p>(</span><span class=n>c2p</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>tmp</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>closeR</span><span class=p>(</span><span class=n>p2c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>closeW</span><span class=p>(</span><span class=n>c2p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=find>find<a hidden class=anchor aria-hidden=true href=#find>#</a></h4><p>主要是練怎麼用file stat，以及認識到c處理string是多麼麻煩</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/stat.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/fs.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=nf>getFilename</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>start</span> <span class=o>=</span> <span class=n>path</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>path</span> <span class=o>+=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(;</span><span class=n>path</span> <span class=o>!=</span> <span class=n>start</span> <span class=o>&amp;&amp;</span> <span class=o>*</span><span class=n>path</span> <span class=o>!=</span> <span class=sc>&#39;/&#39;</span><span class=p>;</span><span class=n>path</span><span class=o>--</span><span class=p>)</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>path</span> <span class=o>==</span> <span class=sc>&#39;/&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>path</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>isSubstring</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>s1</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>M</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>s1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>s2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* A loop to slide pat[] one by one */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>N</span> <span class=o>-</span> <span class=n>M</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>M</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>s2</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=n>s1</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=n>M</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>isNotDots</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>len</span> <span class=o>&gt;=</span> <span class=mi>3</span> <span class=o>||</span> <span class=p>(</span><span class=n>len</span> <span class=o>==</span> <span class=mi>2</span> <span class=o>&amp;&amp;</span> <span class=n>name</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;.&#39;</span> <span class=o>&amp;&amp;</span> <span class=n>name</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;.&#39;</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>len</span> <span class=o>==</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>name</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>find</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pat</span><span class=p>,</span> <span class=kt>int</span> <span class=n>has</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>512</span><span class=p>],</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>dirent</span> <span class=n>de</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>stat</span> <span class=n>st</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;ls: cannot open %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>fstat</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;ls: cannot stat %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>switch</span><span class=p>(</span><span class=n>st</span><span class=p>.</span><span class=n>type</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>T_FILE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>has</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>T_DIR</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nf>strlen</span><span class=p>(</span><span class=n>path</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>DIRSIZ</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=k>sizeof</span> <span class=n>buf</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;ls: path too long</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>buf</span><span class=o>+</span><span class=nf>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>p</span><span class=o>++</span> <span class=o>=</span> <span class=sc>&#39;/&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>de</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>de</span><span class=p>))</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>de</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=n>de</span><span class=p>.</span><span class=n>inum</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>memmove</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>de</span><span class=p>.</span><span class=n>name</span><span class=p>,</span> <span class=n>DIRSIZ</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>p</span><span class=p>[</span><span class=n>DIRSIZ</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=nf>stat</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;ls: cannot stat %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=kt>char</span><span class=o>*</span> <span class=n>filename</span> <span class=o>=</span> <span class=nf>getFilename</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>isNotDots</span><span class=p>(</span><span class=n>filename</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>find</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>pat</span><span class=p>,</span> <span class=n>has</span> <span class=o>||</span> <span class=nf>isSubstring</span><span class=p>(</span><span class=n>pat</span><span class=p>,</span> <span class=n>filename</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>find</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=xargs>xargs<a hidden class=anchor aria-hidden=true href=#xargs>#</a></h4><p>因為我從沒用過xargs所以一開始寫根本不知道這要幹嘛</p><p>xargs就是讀stdout，用空格或斷行當成分隔，去invoke指令</p><p>不過這裡在讀的時候要一直loop，就算你知道test data基本上一次就讀的完</p><p>可以順便說說虛假喚醒的原因</p><ul><li>喚醒會把所有proc設定成可以跑(runnable)</li><li><em>scheduler</em>只會挑出一個proc跑</li><li>如果這個proc做一下改變，就直接被切走&mldr;<ul><li>但其他proc還是runnable!!</li><li>這樣其他proc還是被wakeup的!!</li></ul></li></ul><p>虛假喚醒是來自preemptive schedule，所以只能在每次wakeup時確認需要的前提有沒有對，才繼續跑</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/stat.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>strncpy</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>os</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>n</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=o>*</span><span class=n>s</span><span class=o>++</span> <span class=o>=</span> <span class=o>*</span><span class=n>t</span><span class=o>++</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>n</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>s</span><span class=o>++</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>10</span><span class=p>][</span><span class=mi>32</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>32</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>cmd</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>argc</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=nf>strncpy</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>tmp</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 虛假喚醒!!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>start</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>end</span> <span class=o>=</span> <span class=n>argc</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>len</span><span class=o>=</span><span class=nf>strlen</span><span class=p>(</span><span class=n>tmp</span><span class=p>),</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>len</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>tmp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span> <span class=o>||</span> <span class=n>tmp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;\n&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>strcpy</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>end</span><span class=o>++</span><span class=p>],</span> <span class=n>start</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>start</span> <span class=o>=</span> <span class=n>tmp</span><span class=o>+</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>end</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>cmd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>fork</span><span class=p>())</span>
</span></span><span class=line><span class=cl>      <span class=nf>wait</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=nf>exec</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>cmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=primes>primes<a hidden class=anchor aria-hidden=true href=#primes>#</a></h4><p>全部裡面最有趣的，也是考驗會不會用pipe</p><p>這裡的做法是，每個stage(go)</p><ul><li>取第一個數字作為這邊的質數</li><li>剩下塞到新的pipe，產生下一個stage</li></ul><pre tabindex=0><code class="language-c=" data-lang="c=">#include &#34;kernel/types.h&#34;
#include &#34;kernel/stat.h&#34;
#include &#34;user/user.h&#34;

void put(int *p, int n) {
	write(p[1], &amp;n, sizeof(int));
}

int get(int *p) {
	int ret;
	int state = read(p[0], &amp;ret, sizeof(int));
	if (state &lt;= 0)
		return state;
	else
		return ret;
}

void endWrite(int *p) {
	close(p[1]);
}

void endRead(int *p) {
	close(p[0]);
}

void go(int *p) {
	// WARN: get a item one time!!
	int b = get(p);
	if (b &gt; 0) {
		printf(&#34;prime %d\n&#34;, b);
		int n = get(p);
		if (n &gt; 0) {
			int pp[2];
			pipe(pp);
			if (fork() == 0) {
				endWrite(pp);
				go(pp);
			} else {
				endRead(pp);
				for(;n &gt; 0;n=get(p))
					if (n % b != 0)
						put(pp,n);
				endWrite(pp);
				wait(0);
			}

		}
	}
	endRead(p);
}

int main() {
	int p[2];
	pipe(p);
	if (fork() == 0) {
		endWrite(p);
		go(p);
	}
	else {
		endRead(p);
		for (int n=2;n&lt;36;n++)
			put(p,n);
		endWrite(p);
		wait(0);
	}
	exit(0);
}
</code></pre><h2 id=ch2>ch2<a hidden class=anchor aria-hidden=true href=#ch2>#</a></h2><h3 id=isolation>Isolation<a hidden class=anchor aria-hidden=true href=#isolation>#</a></h3><p>隔離是由下面兩個東西提供保證的</p><ul><li>硬體<ul><li>執行模式</li></ul></li><li>OS<ul><li>process (使用不同的stack)</li><li>其他 (cgroup, 權限管理&mldr;)</li></ul></li></ul><p>先看執行模式</p><h4 id=執行模式>執行模式<a hidden class=anchor aria-hidden=true href=#執行模式>#</a></h4><p>RISC-V 有三種模式，CPU 可以執行指令：</p><ul><li>機器模式</li><li>監督者（supervisor）模式<ul><li>CPU 被允許執行特權指令：例如，啟用和禁用中斷，讀寫保存頁表地址的寄存器等</li></ul></li><li>用戶模式</li></ul><p>CPU提供了一個特殊的指令(ecall)，可以將 CPU 從用戶模式切換到監督模式，並在內核指定的入口處進入內核。</p><p>一個關鍵的設計問題是操作系統的哪一部分應該在監督者模式下運行。</p><ul><li>宏內核<ul><li>整個操作系統駐留在內核中，這樣所有系統調用的實現都在監督者模式下運行</li></ul></li><li>微內核<ul><li>減少在監督者模式下運行的操作系統代碼量，而在用戶模式下執行操作系統的大部分代碼</li></ul></li></ul><h4 id=process>process<a hidden class=anchor aria-hidden=true href=#process>#</a></h4><p>process 就是 一台電腦</p><ul><li>硬體<ul><li>kernel syscall</li></ul></li><li>CPU<ul><li>concurrent mechnism<ul><li>process state</li></ul></li></ul></li><li>mem<ul><li>page table<ul><li>stack<ul><li>kernel stack (kstack)</li><li>user stack</li></ul></li></ul></li></ul></li></ul><p>透過assign不同的pagetable讓process只能看到與使用一部份的mem，這樣就算把自己的搞壞也沒關係</p><h5 id=process的mem-layout>process的mem layout<a hidden class=anchor aria-hidden=true href=#process的mem-layout>#</a></h5><p><img loading=lazy src=https://i.imgur.com/dKztkKG.png alt></p><p>xv6 只使用 39 位中的 38 位。因此，最大地址是 2^38-1 = 0x3fffffffff，也就是 MAXVA</p><p>在地址空間的頂端，xv6 保留了一頁，用於 trampoline 和映射進程trapframe 的頁，以便切換到內核</p><h3 id=trace-init>trace: init<a hidden class=anchor aria-hidden=true href=#trace-init>#</a></h3><p>在kernel load完後會call init去setup shell
這裡主要是看怎麼從kernel mode變成user mode</p><ol><li>loader 将 xv6 内核加载到物理地址 0x80000000 的内存中<ul><li>0x80000000 而不是 0x0，是因为地址范围 0x0-0x80000000 包含 I/O 设备。</li></ul></li><li>_entry处的指令设置了一个栈(stack0)，这样xv6就可以运行C代码<ul><li>注意<ul><li>stack0被宣告在start.c</li><li>riscv的stack是往下長的!!<ul><li>所以，entry.S做的事用一句話來說<ul><li><code>sp = stack0+PGSIZE</code></li></ul></li></ul></li></ul></li></ul></li><li>跑到start<ul><li>這裡是machine mode<ul><li>設定切hyperviser mode</li><li>關中斷</li><li>關paging</li><li>設定pc成main</li><li>設定timer的東西 (timerinit)</li><li>用mret跳去main，同時切成hyperviser mode</li></ul></li></ul></li><li>跑main<ul><li>設定各種設定</li><li>最後跑userinit，跑kernel的第一個程式</li></ul></li><li>在main跑userinit，就會去帶init<ul><li>alloc proc之後設定一些基本訊息</li><li>把跑init的binary (<code>exec("/init")</code>)，copy到proc的記憶體中<ul><li>binary的asm在user的initcode.S<ul><li>就是透過a7去打exec</li><li>exec會把記憶體換掉，所以變成init<ul><li>init(init.c)做兩件事<ul><li>fork: 開sh</li><li>main: 一直wait，zombie或是shell之類的proc</li></ul></li></ul></li><li>同時之後init跑完就會變成user mode<ul><li>為什麼會變成user mode??<ul><li>看到exec<ul><li>先讀elf</li><li><em>用uvmalloc設定pagetable</em><ul><li>uvmalloc設定PTE時會代PTE_U (usermode記憶體)</li></ul></li></ul></li><li>之後到syscall的流程 (usertrapret)<ul><li>設定user mode</li><li>設定user pagetable</li><li>userret做ctx switch+trap的switch</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ol><h3 id=trace-syscall>trace: syscall<a hidden class=anchor aria-hidden=true href=#trace-syscall>#</a></h3><h4 id=user-mode的syscall>user mode的syscall<a hidden class=anchor aria-hidden=true href=#user-mode的syscall>#</a></h4><ul><li>usys.pl<ul><li>include syscall.h拿syscall編號</li><li>會產生一段設定a7的asm</li><li>這就是syscall</li></ul></li></ul><h4 id=kernel-mode的syscall>kernel mode的syscall<a hidden class=anchor aria-hidden=true href=#kernel-mode的syscall>#</a></h4><ul><li>syscall.h<ul><li>這裡有所有syscall的編號</li></ul></li><li>usys.pl的ecall觸發trap，切到kernel mode<ul><li>trap之後會提，反正會到usertrap</li><li>看mstatus，之後跑syscall</li><li>根據num，跑對應的syscal</li><li>return code寫到a0，之後透過剩下的trap流程<ul><li>回到usertrap</li><li>跑usertrapret(切pagetable與user mode)，userret</li></ul></li></ul></li></ul><h4 id=user的參數怎麼pass到syscall的>user的參數怎麼pass到syscall的?<a hidden class=anchor aria-hidden=true href=#user的參數怎麼pass到syscall的>#</a></h4><p>以argint為例</p><ul><li>call argraw<ul><li>argraw直接拿trapframe的value</li><li>在此如果是addr也是這樣拿到addr<ul><li>但是之後要處理pagetable的copyin, copyout接手去複製資料</li></ul></li></ul></li></ul><h3 id=lab-system-calls>Lab System calls<a hidden class=anchor aria-hidden=true href=#lab-system-calls>#</a></h3><h4 id=trace>trace<a hidden class=anchor aria-hidden=true href=#trace>#</a></h4><p>就是在proc上設定mask，之後只要syscall時就看mask決定要不要print</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=n>uint64</span> <span class=nf>sys_trace</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>uint64</span> <span class=nf>sys_sysinfo</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=nf>uint64</span> <span class=p>(</span><span class=o>*</span><span class=n>syscalls</span><span class=p>[])(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>[</span><span class=n>SYS_trace</span><span class=p>]</span>   <span class=n>sys_trace</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>SYS_sysinfo</span><span class=p>]</span>   <span class=n>sys_sysinfo</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>char</span><span class=o>*</span> <span class=n>syscallnames</span><span class=p>[</span><span class=mi>24</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;fork&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;exit&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;wait&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;pipe&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;read&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;kill&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;exec&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;fstat&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;chdir&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;dup&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;getpid&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;sbrk&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;sleep&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;uptime&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;open&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;write&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;mknod&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;unlink&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;link&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;mkdir&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;close&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;trace&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;sysinfo&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>syscall</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>num</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>num</span> <span class=o>&lt;</span> <span class=nf>NELEM</span><span class=p>(</span><span class=n>syscalls</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>syscalls</span><span class=p>[</span><span class=n>num</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span> <span class=o>=</span> <span class=n>syscalls</span><span class=p>[</span><span class=n>num</span><span class=p>]();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>tracemask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d: syscall %s -&gt; %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>syscallnames</span><span class=p>[</span><span class=n>num</span><span class=p>],</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span><span class=p>);</span> <span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=sysinfo>sysinfo<a hidden class=anchor aria-hidden=true href=#sysinfo>#</a></h4><p>這裡的重點是</p><ul><li>數freemem</li><li>數unused procs</li></ul><p>數unused procs就是從proc表去數</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getAllocedProcsCount</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>proc</span><span class=p>;</span> <span class=n>p</span> <span class=o>&lt;</span> <span class=o>&amp;</span><span class=n>proc</span><span class=p>[</span><span class=n>NPROC</span><span class=p>];</span> <span class=n>p</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>!=</span> <span class=n>UNUSED</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>ret</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>數freemem從freelist去數(幸好是用page去分不然會很麻煩)
4096是page的大小(PGSIZE)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getFreeMemAmount</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=k>struct</span> <span class=n>run</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>kmem</span><span class=p>.</span><span class=n>freelist</span><span class=p>;</span> <span class=n>ptr</span><span class=p>;</span> <span class=n>ptr</span><span class=o>=</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>+=</span> <span class=mi>4096</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>剩下的問題是怎麼copy struct過去
所以我們需要copy addr過去user space的struct</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_sysinfo</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>infoAddr</span><span class=p>;</span> <span class=c1>// user pointer to struct stat
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=nf>argaddr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>infoAddr</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sysinfo</span> <span class=n>info</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>freemem</span> <span class=o>=</span> <span class=nf>getFreeMemAmount</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>nproc</span> <span class=o>=</span> <span class=nf>getAllocedProcsCount</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>copyout</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>infoAddr</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>info</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>info</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></div><h2 id=ch45>ch4&amp;5<a hidden class=anchor aria-hidden=true href=#ch45>#</a></h2><h3 id=trap>trap<a hidden class=anchor aria-hidden=true href=#trap>#</a></h3><p>trap有3種</p><ul><li>from user mode (syscall)</li><li>from device (device interrupt)</li><li>from cpu (exception)</li></ul><p>trap通常的順序是</p><ul><li>trap 迫使控制權轉移到內核</li><li>內核保存寄存器和其他狀態，以便恢復執行</li><li>內核執行適當的處理程序代碼（例如，系統調用實現或設備驅動程序）</li><li>內核恢復保存的狀態，並從 trap 中返回</li><li>代碼從原來的地方恢復。</li></ul><p>Xv6 trap 處理分為四個階段</p><ul><li>RISC-V CPU 採取的硬件行為</li><li>為內核 C 代碼準備的彙編入口</li><li>處理 trap 的 C 處理程序</li><li>系統調用或設備驅動服務</li></ul><h3 id=risc-v-trap-mechinism>RISC-V trap mechinism<a hidden class=anchor aria-hidden=true href=#risc-v-trap-mechinism>#</a></h3><p>重要的reg</p><p>stvec：內核在這裡寫下 trap 處理程序的地址；RISC-V 到這裡來處理 trap。
sepc：當 trap 發生時，RISC-V 會將程序計數器保存在這裡（因為 PC 會被 stvec 覆蓋）。
sret: 從 trap 中返回
scause：RISC -V 在這裡放了一個數字，描述了 trap 的原因。
sscratch：內核在這裡放置了一個值，這個值會方便 trap 恢復/儲存用戶上下文。
sstatus: 類似attr，SIE 位控制設備中斷是否被啟用，SPP 位表示 trap 是來自用戶模式還是監督者模式，並控制sret 返回到什麼模式</p><p>RISC-V 硬件對所有的 trap 類型（除定時器中斷外）進行以下操作</p><ul><li>如果該 trap 是設備中斷，且 sstatus SIE 位為 1<ul><li>通過清除 SIE 來禁用中斷</li><li>複製 pc 到 sepc</li><li>將當前模式(用戶或監督者)保存在 sstatus 的 SPP 位</li><li>在 scause 設置該次 trap 的原因</li><li>將模式轉換為監督者</li><li>將 stvec 複製到 pc</li><li>執行新的 pc</li></ul></li></ul><p>CPU 不會切換到內核頁表，不會切換到內核中的棧，也不會保存 <strong>pc</strong> 以外的任何寄存器!!
內核軟件必須執行這些任務!!</p><h3 id=trace-trap-from-user-space>trace: trap from user space<a hidden class=anchor aria-hidden=true href=#trace-trap-from-user-space>#</a></h3><ul><li><p>從proc的trampoline開始</p><ul><li>跑uservec (kernel mode，因為是中斷)<ul><li>保存狀態到trapframe<ul><li>trapframe可以<ul><li>保存所有用户寄存器</li><li>指向当前进程的内核栈</li><li>当前 CPU 的 hartid</li><li>usertrap 的地址和内核页表的地址的指针</li></ul></li></ul></li><li>換kernel pagetable (透過設定satp)</li><li>跳usertrap (kernel mode)<ul><li>設定stvec成kernelvec</li><li>保存pc</li><li>syscall或是device interrupt</li></ul></li></ul></li></ul></li><li><p>usertrap完到usertrapret (kernel mode)</p><ul><li>設定成stvec，要到uservec</li><li>把kernel資訊寫到trapframe</li><li>設定pc (trap的重點!!!)</li><li>設定user pagetable</li><li>設定user mode</li><li>跳到userret (user mode)<ul><li>把trapframe載回去</li><li>return 到原本的位置</li></ul></li></ul></li></ul><h4 id=trace-exec-syscall>trace: exec syscall<a hidden class=anchor aria-hidden=true href=#trace-exec-syscall>#</a></h4><ul><li>用戶代碼將 exec 的參數放在寄存器 a0 和 a1 中，並將系統調用號放在 a7 中</li><li>系統調用號與函數指針表 syscalls 數組(kernel/syscall.c:108)中的項匹配 (from trapframe的a7)</li><li>ecall 指令進入內核，執行uservec、usertrap，然後執行 syscall</li><li>當系統調用函數返回時，syscall 將其返回值記錄在 p->trapframe->a0 中</li></ul><h5 id=如果有pointer>如果有pointer?<a hidden class=anchor aria-hidden=true href=#如果有pointer>#</a></h5><p>透過kernel function去load
使用 fetchstr 從用戶空間中檢索字符串文件名參數，fetchstr 調用 copyinstr 來做這些困難的工作</p><h3 id=trap-from-kernel-space>trap from kernel space<a hidden class=anchor aria-hidden=true href=#trap-from-kernel-space>#</a></h3><p>kernel的trap因為在kernel所以不用換pagetable、stvec
同時因為大家都有自己的kstack，所以可以把registrer存在stack上</p><ul><li>kernelvec<ul><li>保存狀態到kstack</li><li>跳到kerneltrap (會回來kernelvec)<ul><li>保存pc, sstatus, scause<ul><li>pc很正常，但sstatus,scause!?<ul><li>如果是timer interupt會yield</li><li>等回來，會需要原本的sstatus,scause</li></ul></li></ul></li><li>做該做的事<ul><li>timer的preemptive切換在這裡實現</li></ul></li><li>回復sstatus,scause之後return</li></ul></li><li>從kstack回復狀態</li></ul></li></ul><h3 id=trap-from-device>trap from device<a hidden class=anchor aria-hidden=true href=#trap-from-device>#</a></h3><p>許多設備驅動程序在兩個 context 中執行代碼：
上半部分(top half)在進程的內核線程中運行
下半部分(bottom half)在中斷時執行</p><p>上半部分是通過系統調用，如希望執行 I/O 的read 和 write。
這段代碼可能會要求硬件開始一個操作（比如要求磁盤讀取一個塊）；然後代碼等待操作完成。
最終設備完成操作並引發一個中斷。
驅動程序的中斷處理程序，作為下半部分，推算出什麼操作已經完成，如果合適的話，喚醒一個等待該操作的進程，並告訴硬件執行下一個操作。</p><h4 id=trace-console-input>trace: Console input<a hidden class=anchor aria-hidden=true href=#trace-console-input>#</a></h4><p>UART 硬件在軟件看來是一組內存映射的控制寄存器 (不用port操作啦)</p><p>當 UART 接收到一個字節的輸入時，就產生一個接收中斷，當 UART 每次完成發送一個字節的輸出時產生一個傳輸完成(transmit complete)中斷(kernel/uart.c:53)。</p><p>trap 處理程序調用 devintr(kernel/trap.c:177)，它查看 RISC-V 的 scause 寄存器，發現中斷來自一個外部設備。
然後它向一個叫做 PLIC的硬件單元詢問哪個設備中斷了(kernel/trap.c:186)。
如果是 UART，devintr 調用 uartintr。</p><p>uartintr (kernel/uart.c:180) 從 UART 硬件中讀取在等待的輸入字符，並將它們交給consoleintr (kernel/console.c:138)；
它不會等待輸入字符，因為以後的輸入會引發一個新的中斷。
consoleintr 的工作是將中輸入字符積累 cons.buf 中，直到有一行字符</p><p>一旦被喚醒，consoleread 將會注意到 cons.buf 中的完整行，並將其將其複製到用戶空間，並返回（通過系統調用）到用戶空間。</p><h4 id=trace-console-output>trace: Console output<a hidden class=anchor aria-hidden=true href=#trace-console-output>#</a></h4><p>write 系統調用最終會到達 uartputc(kernel/uart.c:87)。
設備驅動維護了一個輸出緩衝區(uart_tx_buf)，uartputc 將每個字符追加到緩衝區調用 uartstart 來啟動設備發送(如果還沒有的話)，然後返回</p><p>每次 UART 發送完成一個字節，它都會產生一個中斷。
uartintr 調用 uartstart，uartintr檢查設備是否真的發送完畢，並將下一個緩衝輸出字符交給設備，每當 UART 發送完一個字節，就會產生一個中斷</p><h3 id=timer-interrupts>Timer interrupts<a hidden class=anchor aria-hidden=true href=#timer-interrupts>#</a></h3><p>RISC-V 要求在機器模式下處理定時器中斷，而不是監督者模式。
因此，xv6 對定時器中斷的處理與上面談到的 trap 機製完全分離了。</p><p>所以都在start中設定</p><ul><li>對 CLINT 硬件（core-local interruptor）進行編程，使其每隔一定時間產生一次中斷</li><li>設置一個類似於 trapframe 的 scratch 區域，幫助定時器中斷處理程序保存寄存器和 CLINT 寄存器的地址<ul><li>所以前面trap要保留scratch的內容</li></ul></li><li>將 mtvec 設置為 timervec，啟用定時器中斷<ul><li>中斷之後由clockintr處理 (tick++)</li></ul></li></ul><h4 id=interrupt還是要處理concurent>interrupt還是要處理concurent<a hidden class=anchor aria-hidden=true href=#interrupt還是要處理concurent>#</a></h4><p>內核代碼需要注意它可能會被暫停（由於定時器中斷），然後在不同的 CPU 上恢復</p><h3 id=等等一直發trap>等等，一直發trap?<a hidden class=anchor aria-hidden=true href=#等等一直發trap>#</a></h3><p>UART 驅動器通過讀取 UART 控制寄存器，一次檢索一個字節的數據
這種模式被稱為編程 I/O，因為軟件在驅動數據移動。</p><p>程序化 I/O 簡單，但速度太慢，無法在高數據速率下使用。</p><p>需要高速移動大量數據的設備通常使用直接內存訪問（DMA）
DMA 設備硬件直接將傳入數據寫入 RAM，並從 RAM 中讀取傳出數據</p><p>當設備在不可預知的時間需要關注時，中斷是很有用的，而且不會太頻繁。
但中斷對 CPU的開銷很大。
因此，高速設備，如網絡和磁盤控制器，使用了減少對中斷需求的技巧。</p><p>其中一個技巧是對整批傳入或傳出的請求提出一個單一的中斷。
另一個技巧是讓驅動程序完全禁用中斷，並定期檢查設備是否需要關注。
這種技術稱為輪詢（polling）。
如果設備執行操作的速度非常快，輪詢是有意義的
但如果設備大部分時間處於空閒狀態，則會浪費 CPU 時間
一些驅動程序會根據當前設備的負載情況，在輪詢和中斷之間動態切換</p><h3 id=lab-traps>Lab Traps<a hidden class=anchor aria-hidden=true href=#lab-traps>#</a></h3><h4 id=backtrace>backtrace<a hidden class=anchor aria-hidden=true href=#backtrace>#</a></h4><p>defs.h加</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>            <span class=nf>backtrace</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>接著hint有提到sp與fp，所以就直接用吧
但這裡用struct讓code好看一點</p><p>注意到riscv是小頭，所以mem addr小的會被放到struct最前面
這段我是加在printf.c</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>stk_frame</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span> <span class=n>prev_frame_plus_16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>ret_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>r_fp</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>asm</span> <span class=k>volatile</span><span class=p>(</span><span class=s>&#34;mv %0, s0&#34;</span> <span class=o>:</span> <span class=s>&#34;=r&#34;</span> <span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>riscv是小頭
</span></span></span><span class=line><span class=cl><span class=cm>所以addr越小，在c struct會被往上面放
</span></span></span><span class=line><span class=cl><span class=cm>stack是往下長 (addr-8)
</span></span></span><span class=line><span class=cl><span class=cm>所以寫struct要把下面的往struct的上面放 (stack倒著放)
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>backtrace</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>stk_frame</span><span class=o>*</span> <span class=n>now</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>stk_frame</span><span class=o>*</span><span class=p>)(</span><span class=nf>r_fp</span><span class=p>()</span><span class=o>-</span><span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>start</span> <span class=o>=</span> <span class=nf>PGROUNDDOWN</span><span class=p>(</span><span class=n>now</span><span class=o>-&gt;</span><span class=n>ret_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>struct</span> <span class=n>stk_frame</span><span class=o>*</span> <span class=n>now</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>stk_frame</span><span class=o>*</span><span class=p>)(</span><span class=nf>r_fp</span><span class=p>()</span><span class=o>-</span><span class=mi>16</span><span class=p>);</span> <span class=n>now</span><span class=o>-&gt;</span><span class=n>ret_addr</span> <span class=o>&gt;</span> <span class=n>start</span><span class=p>;</span> <span class=n>now</span><span class=o>=</span><span class=n>now</span><span class=o>-&gt;</span><span class=n>prev_frame_plus_16</span><span class=o>-</span><span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>now</span><span class=o>-&gt;</span><span class=n>ret_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></div><p>最後就直接call</p><pre tabindex=0><code class="language-c=" data-lang="c=">uint64
sys_sleep(void)
{
  int n;
  uint ticks0;

  backtrace();
  if(argint(0, &amp;n) &lt; 0)
    return -1;
// ...
}
</code></pre><h5 id=fp--sp>fp & sp<a hidden class=anchor aria-hidden=true href=#fp--sp>#</a></h5><p><a href=https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf>from hint</a>
sp就是目前stack的top
fp就是保存caller訊息的addr</p><p>caller reg: caller要存，換言之，在call完function後可能會被破壞掉
callee reg: callee要還原，換言之，在call完function後他們的值還是對的</p><h4 id=alarm>alarm<a hidden class=anchor aria-hidden=true href=#alarm>#</a></h4><p>如果timer動了就call一下callback，透過兩個syscall，sigalarm與sigreturn
但要怎麼到callback去，是要在kernel mode跑??</p><p>timer interupt最後會回到user mode，所以只要讓他不要回到原本的位置就好!!
這手法我們看過了，usertrapret與usertrap與kerneltrap都是透過改pc完成的</p><p>所以我們也改pc到callback，但是執行時的狀態怎麼辦，要怎麼回去原本的狀態?
再多一個trapframe存原本的trapframe，在alarmreturn把原本的frame設回去</p><p>sysproc.c</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>sys_sigreturn</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>acc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>memmove</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe2</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>trapframe</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>sys_sigalarm</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>argint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>cnt</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>argaddr</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>cb</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>trap.c</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>which_dev</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>cnt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=o>++</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>acc</span> <span class=o>==</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>cnt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>memmove</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe2</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>trapframe</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>epc</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>cb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>yield</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div><h3 id=lab-network-driver>Lab network driver<a hidden class=anchor aria-hidden=true href=#lab-network-driver>#</a></h3><p>在2019的版本是要實現stack與driver的，所以很累，但2020就不用實現stack</p><h4 id=driver>driver<a hidden class=anchor aria-hidden=true href=#driver>#</a></h4><p>driver的重點是怎麼與device溝通</p><p>iface都是用ring buffer去存資料</p><p>xx_ring就是device的buffer的狀態，然後他們是array
那是要取哪一個??
write: 取E1000_TDT，這是接下去dirver要寫的位置
read: 取E1000_RDT，這是iface已經讀完的位置</p><p>xx_mbuf是ring buffer對應到的memory</p><p>所以
write: 把<code>tx_ring[regs[E1000_TDT]]</code>的狀態設定好，把addr指向第一個位置
read: 先拉<code>regs[E1000_TDT]+1</code>的mbuf，之後用新的mbuf蓋掉原本的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>inc</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>len</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>e1000_transmit</span><span class=p>(</span><span class=k>struct</span> <span class=n>mbuf</span> <span class=o>*</span><span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>e1000_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>regs</span><span class=p>[</span><span class=n>E1000_TDT</span><span class=p>],</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>((</span><span class=n>tx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>status</span> <span class=o>&amp;</span> <span class=n>E1000_TXD_STAT_DD</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;not ready for trasmit&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// free previous mbuf
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>tx_mbufs</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=nf>mbuffree</span><span class=p>(</span><span class=n>tx_mbufs</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>tx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>addr</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>m</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>length</span> <span class=o>=</span> <span class=n>m</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>cmd</span> <span class=o>=</span> <span class=n>E1000_TXD_CMD_EOP</span> <span class=o>|</span> <span class=n>E1000_TXD_CMD_RS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tx_mbufs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>regs</span><span class=p>[</span><span class=n>E1000_TDT</span><span class=p>]</span> <span class=o>=</span> <span class=nf>inc</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>TX_RING_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>e1000_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// allocate mbuf for iface
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>e1000_recv</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=nf>inc</span><span class=p>(</span><span class=n>regs</span><span class=p>[</span><span class=n>E1000_RDT</span><span class=p>],</span> <span class=n>RX_RING_SIZE</span><span class=p>);</span><span class=n>rx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>status</span> <span class=o>&amp;</span> <span class=n>E1000_RXD_STAT_DD</span><span class=p>;</span><span class=n>i</span> <span class=o>=</span> <span class=nf>inc</span><span class=p>(</span><span class=n>regs</span><span class=p>[</span><span class=n>E1000_RDT</span><span class=p>],</span> <span class=n>RX_RING_SIZE</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>e1000_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>mbuf</span><span class=o>*</span> <span class=n>pkt</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>rx_mbufs</span><span class=o>+</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>mbufput</span><span class=p>(</span><span class=n>pkt</span><span class=p>,</span> <span class=n>rx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rx_mbufs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nf>mbufalloc</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 從哪邊塞
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>rx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>addr</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>rx_mbufs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>status</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>regs</span><span class=p>[</span><span class=n>E1000_RDT</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>e1000_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>net_rx</span><span class=p>(</span><span class=n>pkt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=network-stack>network stack<a hidden class=anchor aria-hidden=true href=#network-stack>#</a></h4><p>雖然說不用實現一個network stack，但我們可以trace看看</p><h5 id=rx>rx<a hidden class=anchor aria-hidden=true href=#rx>#</a></h5><ul><li>net_rx<ul><li>拉eth_header</li><li>判斷type決定要去哪<ul><li>ntohs去轉數字</li></ul></li></ul></li><li>net_rx_ip<ul><li>拉ip_header</li><li>各種判斷與check<ul><li>cksum</li><li>routing<ul><li>這裡只有看是不是給我們，不是就丟了</li></ul></li></ul></li><li>算udp長度</li><li>送去udp</li></ul></li><li>net_rx_udp<ul><li>拉udp_header</li><li>各種判斷與check</li><li>把sip, sport, dport抓出來，送到sockrecvudp</li></ul></li><li>sockrecvudp<ul><li>找到對的socket</li><li>把pkt塞到socket的queue</li></ul></li></ul><h5 id=tx>tx<a hidden class=anchor aria-hidden=true href=#tx>#</a></h5><ul><li>sockwrite<ul><li>alloc mbuf</li><li>copy data</li><li>送到net_tx_udp</li></ul></li><li>net_tx_udp<ul><li>把sip, sport, dport轉成network order</li><li>設定udp header，並加在mbuf上</li><li>送到net_tx_ip</li></ul></li><li>net_tx_ip<ul><li>與net_tx_udp很像，轉資料，加在mbuf上</li><li>送到net_tx_eth</li></ul></li><li>不存在的routing<ul><li>一般來說從ip到eth或是eth到ip之間要過routing</li><li>決定要繼續往上還是直接轉出去<ul><li>以linux的netfilter為例</li><li><img loading=lazy src=https://www.researchgate.net/publication/320174686/figure/download/fig5/AS:613873052815377@1523370149442/Netfilter-hooks-and-packet-flow-https-doiorg-101371-journalpone0182375g005.png alt></li></ul></li></ul></li><li>net_tx_eth<ul><li>塞ethaddr，加在mbuf上<ul><li>這裡是直接boardcast，所以迴避了arp</li></ul></li><li>call e1000_transmit</li></ul></li></ul><h2 id=ch3>ch3<a hidden class=anchor aria-hidden=true href=#ch3>#</a></h2><p>來了，最難的部分，撐過去就會有全新的方式看待c了!!</p><p>為什麼會難?</p><ol><li>很難debug，一個是要知道結構，也要只到這個數字對應到什麼，還有concurrent要處理</li><li>都是uint64</li><li>之後會在va, pte, pa一直轉來轉去</li></ol><h3 id=kernel-mem-layout>kernel mem layout<a hidden class=anchor aria-hidden=true href=#kernel-mem-layout>#</a></h3><p><img loading=lazy src=https://i.imgur.com/uF59eie.png alt></p><ul><li>当内核通过高地址映射使用 stack 时，它们也可以通过直接映射的地址被内核访问<ul><li>内核使用“直接映射”RAM 和内存映射设备寄存器，也就是在虚拟地址上映射硬件资源，这些地址与物理地址相等。<ul><li>例如，内核本身在虚拟地址空间和物理内存中的位置都是KERNBASE=0x80000000。直接映射简化了读/写物理内存的内核代码。</li></ul></li></ul></li></ul><h3 id=pagetable>pagetable<a hidden class=anchor aria-hidden=true href=#pagetable>#</a></h3><p>page table就是把virtual address(va)，丟到table換出physical address(pa)
<img loading=lazy src=https://i.imgur.com/sZBLA3r.png alt></p><p>硬體上是分成3層，也因為多了一層抽象，所以可以多點attr
<img loading=lazy src=https://i.imgur.com/wtcbDS1.png alt></p><p>像後面就是看page有沒有PTE_V(Page Table Entry, PTE)，決定這個page是不是free</p><p>要告訴硬件使用頁表，內核必須將根頁表頁的物理地址寫入 satp 寄存器中</p><p>pte, pagetable都是存在pa中!!</p><h3 id=如何map--如何把va換成pa>如何map & 如何把va換成pa<a hidden class=anchor aria-hidden=true href=#如何map--如何把va換成pa>#</a></h3><p>pagetable就是hashtable，所以要先知道key,value到底要什麼?</p><p>key: va，在程式中跑的數字；pte，可以換出pagetable或是pa的數字，可以把pte當成page開頭的pa(見walk)
value: pa，真實mem的addr</p><h3 id=trace-free-mem怎麼產生的>trace: free mem怎麼產生的<a hidden class=anchor aria-hidden=true href=#trace-free-mem怎麼產生的>#</a></h3><p>把kernel的memory layout打開來
<img loading=lazy src=https://i.imgur.com/tbYvEDJ.png alt></p><p>中間的free memory就是我們需要的東西</p><p>接著就是怎麼讓free memory可以被分配，要先切塊</p><ul><li>kinit<ul><li>freerange<ul><li>從end到PHYSTOP跑kfree<ul><li>kfree就是加linked list</li></ul></li></ul></li></ul></li></ul><h4 id=如何把va換成pa-walk>如何把va換成pa: walk<a hidden class=anchor aria-hidden=true href=#如何把va換成pa-walk>#</a></h4><p>就是模擬在table跳的過程，一層一層換pte，到最後就可以用kalloc拿pa，利用pa設定對應的pte
之後回傳對應的pa</p><p>那怎麼從va拿pte?
再看回去這張圖
<img loading=lazy src=https://i.imgur.com/wtcbDS1.png alt></p><p>注意到va最右手邊就是12個offset，之後看到pte的右手邊是10位flag，所以轉成pte就是把12位拿掉再把10位補回去</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)
</span></span></span><span class=line><span class=cl><span class=cp>#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)
</span></span></span><span class=line><span class=cl><span class=cp>#define PTE_FLAGS(pte) ((pte) &amp; 0x3FF)
</span></span></span></code></pre></div><p>剩下就是walk三層table了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// extract the three 9-bit page table indices from a virtual address.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define PXMASK          0x1FF </span><span class=c1>// 9 bits
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
</span></span></span><span class=line><span class=cl><span class=cp>#define PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Return the address of the PTE in page table pagetable
</span></span></span><span class=line><span class=cl><span class=c1>// that corresponds to virtual address va.  If alloc!=0,
</span></span></span><span class=line><span class=cl><span class=c1>// create any required page-table pages.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// The risc-v Sv39 scheme has three levels of page-table
</span></span></span><span class=line><span class=cl><span class=c1>// pages. A page-table page contains 512 64-bit PTEs.
</span></span></span><span class=line><span class=cl><span class=c1>// A 64-bit virtual address is split into five fields:
</span></span></span><span class=line><span class=cl><span class=c1>//   39..63 -- must be zero.
</span></span></span><span class=line><span class=cl><span class=c1>//   30..38 -- 9 bits of level-2 index.
</span></span></span><span class=line><span class=cl><span class=c1>//   21..29 -- 9 bits of level-1 index.
</span></span></span><span class=line><span class=cl><span class=c1>//   12..20 -- 9 bits of level-0 index.
</span></span></span><span class=line><span class=cl><span class=c1>//    0..11 -- 12 bits of byte offset within the page.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>pte_t</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>walk</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>va</span><span class=p>,</span> <span class=kt>int</span> <span class=n>alloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>va</span> <span class=o>&gt;=</span> <span class=n>MAXVA</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;walk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>level</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=n>level</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pagetable</span><span class=p>[</span><span class=nf>PX</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>va</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>pagetable</span> <span class=o>=</span> <span class=p>(</span><span class=kt>pagetable_t</span><span class=p>)</span><span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>alloc</span> <span class=o>||</span> <span class=p>(</span><span class=n>pagetable</span> <span class=o>=</span> <span class=p>(</span><span class=kt>pde_t</span><span class=o>*</span><span class=p>)</span><span class=nf>kalloc</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>memset</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=nf>PA2PTE</span><span class=p>(</span><span class=n>pagetable</span><span class=p>)</span> <span class=o>|</span> <span class=n>PTE_V</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=n>pagetable</span><span class=p>[</span><span class=nf>PX</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>va</span><span class=p>)];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=如何map-mappages>如何map: mappages<a hidden class=anchor aria-hidden=true href=#如何map-mappages>#</a></h4><p>mappages就是walk很多次，一次一個page</p><p>如果完成map就可以用c的*做操作!!
十分神奇，前面還是當成數字操作，之後就可以直接dereference</p><h3 id=trace-怎麼做mem-alloc>trace: 怎麼做mem alloc<a hidden class=anchor aria-hidden=true href=#trace-怎麼做mem-alloc>#</a></h3><p>mem alloc，就是</p><ol><li>kalloc拿一塊page，拿到一個pa</li><li>mappages在pagetable中設定va到pa</li></ol><h3 id=trace-怎麼free-mempagetable>trace: 怎麼free mem/pagetable<a hidden class=anchor aria-hidden=true href=#trace-怎麼free-mempagetable>#</a></h3><p>free mem就是</p><ol><li>uvmunmap<ul><li>會walk拉出pa</li><li>檢查有沒有被map過(有PTE_V)</li><li>如果有要free，就kfree</li></ul></li></ol><p>free pagetable比較麻煩</p><ul><li>uvmfree<ul><li>uvmunmap把所有pa去掉</li><li>walkfree把pte去掉</li></ul></li></ul><h4 id=trace-how-to-create-kernel-page-table>trace: how to create kernel page table<a hidden class=anchor aria-hidden=true href=#trace-how-to-create-kernel-page-table>#</a></h4><ul><li>kvminit設定<code>kernel_pagetable</code><ul><li>跑kvmmake會生出kernel pagetable<ul><li>先kalloc一塊放pagetable</li><li>之後照layout設定</li></ul></li></ul></li><li>kvminithart<ul><li>設定satp</li></ul></li><li>how to access a page table:<ul><li>pagetable_t，它實際上是一個指向 RISC-V 根頁表頁的指針 (pa)</li></ul></li></ul><h3 id=process-mem-layout>process mem layout<a hidden class=anchor aria-hidden=true href=#process-mem-layout>#</a></h3><p><img loading=lazy src=https://i.imgur.com/yBoV986.png alt>
當一個進程要求 xv6 提供更多的用戶內存時，xv6 首先使用 kalloc 來分配物理頁，然後將指向新物理頁的 PTE 添加到進程的頁表中。</p><p>xv6 使用 PTE_V 來清除不使用的 PTE</p><p>trampoline是負責跳到hypervisor mode的code
trapframe是在跳之前保存process狀態的地方</p><h4 id=trace-sbrk>trace: sbrk<a hidden class=anchor aria-hidden=true href=#trace-sbrk>#</a></h4><p>回傳目前的終點(sz)，之後算與原本size的差，之後調用uvmalloc 或 uvmdealloc縮放自己的大小</p><h4 id=trace-exec>trace: exec<a hidden class=anchor aria-hidden=true href=#trace-exec>#</a></h4><ol><li>open binary exe (namei)</li><li>parse ELF</li><li>從proc_pagetable分配一個page，之後用uvmalloc為剩下的proc配置page</li></ol><p>exec配出來的mem layout可以看process mem layout的圖</p><h3 id=before-labs>Before labs<a hidden class=anchor aria-hidden=true href=#before-labs>#</a></h3><p>在做lab之前先看看要怎麼為某個va做map，會做兩件事</p><ol><li>拿一塊page</li><li>把va指(map)過去<ul><li>這裡的va不一定是剛好在page的起點上!!</li><li>記得，所有mem都要以page為單位</li></ul></li></ol><p>故要先介紹兩個macro，因為之後很常用到</p><ul><li>PGROUNDUP: page的終點<ul><li>usage: exec在alloc elf的執行檔後要alloc stack，就是先取PGROUNDUP，之後stack從PGROUNDUP開始alloc</li></ul></li><li>PGROUNDDOWN: page的起點<ul><li>usage: mappages在一開始就先對傳進來的va做PGROUNDDOWN，之後才開始alloc</li></ul></li></ul><h3 id=lab-page-tables>Lab Page tables<a hidden class=anchor aria-hidden=true href=#lab-page-tables>#</a></h3><h4 id=vmprint>vmprint<a hidden class=anchor aria-hidden=true href=#vmprint>#</a></h4><p>小試身手，抄freewalk，走過每個pte即可</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>vmprint_dfs</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dep</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>pagetable</span> <span class=o>&lt;</span> <span class=n>MAXVA</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=kt>pte_t</span> <span class=n>pte</span> <span class=o>=</span> <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>((</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>pte</span> <span class=o>&lt;</span> <span class=n>MAXVA</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>uint64</span> <span class=n>child</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>dep</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;.. &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;..%d: ptr %p pa %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>pte</span><span class=p>,</span> <span class=n>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>vmprint_dfs</span><span class=p>((</span><span class=kt>pagetable_t</span><span class=p>)</span><span class=n>child</span><span class=p>,</span> <span class=n>dep</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>vmprint</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;page table %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pagetable</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>vmprint_dfs</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=new-copyin-copyinstr>new copyin, copyinstr<a hidden class=anchor aria-hidden=true href=#new-copyin-copyinstr>#</a></h4><p>現在想把user mode的資料加到kernel mode的表，這樣就不用copy來copy去</p><p>先要有產生kernel pagetable的函數，並在struct proc中多加一個kernel pagetable</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>kpgtinit</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// uart registers
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>UART0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>UART0</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kpgtinit: uart0</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// virtio mmio disk interface
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>VIRTIO0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>VIRTIO0</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kpgtinit: virtio0</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// CLINT
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>CLINT</span><span class=p>,</span> <span class=mh>0x10000</span><span class=p>,</span> <span class=n>CLINT</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kpgtinit: clint</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// PLIC
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>PLIC</span><span class=p>,</span> <span class=mh>0x400000</span><span class=p>,</span> <span class=n>PLIC</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kpgtinit: plic</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map kernel text executable and read-only.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>KERNBASE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=o>-</span><span class=n>KERNBASE</span><span class=p>,</span> <span class=n>KERNBASE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_X</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kpgtinit: kernel base</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map kernel data and the physical RAM we&#39;ll make use of.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=n>PHYSTOP</span><span class=o>-</span><span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kpgtinit: kernel data</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map the trampoline for trap entry/exit to
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// the highest virtual address in the kernel.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>TRAMPOLINE</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>trampoline</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_X</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kpgtinit: trampoline</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>switchPGT</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>w_satp</span><span class=p>(</span><span class=nf>MAKE_SATP</span><span class=p>(</span><span class=n>t</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=nf>sfence_vma</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>因為每個process都有kernel table，所以可以把kstack分到每個kernel pagetable去，把procinit的kstack拿掉</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>allocproc</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span> <span class=o>=</span> <span class=p>(</span><span class=kt>pagetable_t</span><span class=p>)</span> <span class=nf>kalloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nf>kpgtinit</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>pa</span> <span class=o>=</span> <span class=nf>kalloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>pa</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kalloc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>va</span> <span class=o>=</span> <span class=nf>KSTACK</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>mappages</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span> <span class=o>=</span> <span class=n>va</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>所以現在每個process都有一個kernel pagetable，需要的時候會把user mode pagetable的map到在kernel pagetable也map一下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>includeInto</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=kt>pagetable_t</span> <span class=n>kpagetable</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>oldsz</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>newsz</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte_from</span><span class=p>,</span> <span class=o>*</span><span class=n>pte_to</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>a</span><span class=p>,</span> <span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>newsz</span> <span class=o>&lt;</span> <span class=n>oldsz</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>oldsz</span> <span class=o>=</span> <span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>a</span> <span class=o>=</span> <span class=n>oldsz</span><span class=p>;</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>newsz</span><span class=p>;</span> <span class=n>a</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pte_from</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;includeInto: pte should exist&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pte_to</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>kpagetable</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;includeInto: walk fails&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pa</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte_from</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>flags</span> <span class=o>=</span> <span class=p>(</span><span class=nf>PTE_FLAGS</span><span class=p>(</span><span class=o>*</span><span class=n>pte_from</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>~</span><span class=n>PTE_U</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>pte_to</span> <span class=o>=</span> <span class=nf>PA2PTE</span><span class=p>(</span><span class=n>pa</span><span class=p>)</span> <span class=o>|</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>需要的時候? 就是程式在kernel mode中時動到或是需要user mode的資料時</p><ul><li>userinit</li><li>growproc<ul><li>這裡要看kernel的layout，PILC上面的其實不能用，因為已經被map了</li></ul></li><li>fork</li><li>exec</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>userinit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>includeInto</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// prepare for the very first &#34;return&#34; from kernel to user.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>epc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>      <span class=c1>// user program counter
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Grow or shrink user memory by n bytes.
</span></span></span><span class=line><span class=cl><span class=c1>// Return 0 on success, -1 on failure.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>growproc</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span> <span class=o>+</span> <span class=n>n</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=n>PLIC</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>includeInto</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span><span class=p>,</span> <span class=n>sz</span><span class=o>-</span><span class=n>n</span><span class=p>,</span> <span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>sz</span> <span class=o>=</span> <span class=nf>uvmdealloc</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>sz</span><span class=p>,</span> <span class=n>sz</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Create a new process, copying the parent.
</span></span></span><span class=line><span class=cl><span class=c1>// Sets up child kernel stack to return as if from fork() system call.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>includeInto</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>np</span><span class=o>-&gt;</span><span class=n>kpagetable</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>np</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>safestrcpy</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>pid</span> <span class=o>=</span> <span class=n>np</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>=</span> <span class=n>RUNNABLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>freeproc也把kernel pagetable也free掉，但是不能把kernel的項目的pa給free掉</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>freewalk_keepleaf</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>pte_t</span> <span class=n>pte</span> <span class=o>=</span> <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>((</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>PTE_R</span><span class=o>|</span><span class=n>PTE_W</span><span class=o>|</span><span class=n>PTE_X</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// this PTE points to a lower-level page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>uint64</span> <span class=n>child</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>freewalk_keepleaf</span><span class=p>((</span><span class=kt>pagetable_t</span><span class=p>)</span><span class=n>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>kfree</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>pagetable</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> 
</span></span><span class=line><span class=cl><span class=nf>proc_freekpt</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>pte_t</span> <span class=n>pte</span> <span class=o>=</span> <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>      <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>((</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>PTE_R</span><span class=o>|</span><span class=n>PTE_W</span><span class=o>|</span><span class=n>PTE_X</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>uint64</span> <span class=n>child</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>proc_freekpt</span><span class=p>((</span><span class=kt>pagetable_t</span><span class=p>)</span><span class=n>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;proc free kpt: leaf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>kfree</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>pagetable</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>freeproc</span><span class=p>(</span><span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>proc_freepagetable</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>freewalk_keepleaf</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>kpagetable</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>最後就可以切到新的copyin, copyinstr了</p><h3 id=lab-lazy-allocation>Lab Lazy allocation<a hidden class=anchor aria-hidden=true href=#lab-lazy-allocation>#</a></h3><p>在sbrk不分配mem</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_sbrk</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>argint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>addr</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=nf>growproc</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span>
</span></span><span class=line><span class=cl>     <span class=nf>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>+=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>addr</span><span class=p>;</span> <span class=c1>// !!!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>在page fault時做分配</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>do_lazy</span><span class=p>(</span><span class=n>uint64</span> <span class=n>addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>stkOverFlow</span> <span class=o>=</span> <span class=p>(</span><span class=n>addr</span> <span class=o>&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>sp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// page-faults on a virtual memory address higher than any allocated with sbrk()
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// this should be &gt;= not &gt; !!!
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>addrOutOfBound</span> <span class=o>=</span> <span class=p>(</span><span class=n>addr</span> <span class=o>&gt;=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>stkOverFlow</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>;</span><span class=c1>//printf(&#34;lazy: stack overflow\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>addrOutOfBound</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>;</span><span class=c1>//printf(&#34;lazy: addr over of bound\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>else</span> <span class=k>if</span><span class=p>((</span><span class=n>mem</span> <span class=o>=</span> <span class=nf>kalloc</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>;</span><span class=c1>//printf(&#34;out of pa\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>mem</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=nf>PGROUNDDOWN</span><span class=p>(</span><span class=n>addr</span><span class=p>),</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>mem</span><span class=p>,</span> <span class=n>PTE_W</span><span class=o>|</span><span class=n>PTE_X</span><span class=o>|</span><span class=n>PTE_R</span><span class=o>|</span><span class=n>PTE_U</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span><span class=c1>// ???
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nf>kfree</span><span class=p>(</span><span class=n>mem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> 
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>usertrap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>8</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>intr_on</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>syscall</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>13</span> <span class=o>||</span> <span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>15</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=k>if</span> <span class=p>(</span><span class=nf>do_lazy</span><span class=p>(</span><span class=nf>r_stval</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>p</span><span class=o>-&gt;</span><span class=n>killed</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>((</span><span class=n>which_dev</span> <span class=o>=</span> <span class=nf>devintr</span><span class=p>())</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>剩下要在走訪pte時忽略沒有PTE_V的page，這邊就看hint就知道要改哪</p><h3 id=lab-copy-on-write>Lab Copy on-write<a hidden class=anchor aria-hidden=true href=#lab-copy-on-write>#</a></h3><p>這裡會牽涉到reference counter，導致要處理concurrent!!
如果沒有處理好，連怎麼出事的都不知道</p><p>先refcnt，代表有多少process有map到這個page</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>__refcnt</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>counter</span><span class=p>[(</span><span class=n>PHYSTOP</span> <span class=o>-</span> <span class=n>KERNBASE</span><span class=p>)</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>__refcnt</span> <span class=n>refcnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>refcnt_lock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>refcnt</span><span class=p>.</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>refcnt_unlock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>refcnt</span><span class=p>.</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>refcnt_create</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>refcnt</span><span class=p>.</span><span class=n>lock</span><span class=p>,</span> <span class=s>&#34;refcnt&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>refcnt_lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>goal</span><span class=o>=</span><span class=p>(</span><span class=n>PHYSTOP</span> <span class=o>-</span> <span class=n>KERNBASE</span><span class=p>)</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>goal</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>refcnt</span><span class=p>.</span><span class=n>counter</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>refcnt_unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>inline</span>
</span></span><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>refcnt_index</span><span class=p>(</span><span class=n>uint64</span> <span class=n>pa</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=n>pa</span> <span class=o>-</span> <span class=n>KERNBASE</span><span class=p>)</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>refcnt_set</span><span class=p>(</span><span class=n>uint64</span> <span class=n>pa</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>refcnt</span><span class=p>.</span><span class=n>counter</span><span class=p>[</span><span class=nf>refcnt_index</span><span class=p>(</span><span class=n>pa</span><span class=p>)]</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>inline</span>
</span></span><span class=line><span class=cl><span class=n>uint</span>
</span></span><span class=line><span class=cl><span class=nf>refcnt_get</span><span class=p>(</span><span class=n>uint64</span> <span class=n>pa</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>refcnt</span><span class=p>.</span><span class=n>counter</span><span class=p>[</span><span class=nf>refcnt_index</span><span class=p>(</span><span class=n>pa</span><span class=p>)];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>refcnt_incr</span><span class=p>(</span><span class=n>uint64</span> <span class=n>pa</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>refcnt</span><span class=p>.</span><span class=n>counter</span><span class=p>[</span><span class=nf>refcnt_index</span><span class=p>(</span><span class=n>pa</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>refcnt_desc</span><span class=p>(</span><span class=n>uint64</span> <span class=n>pa</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>refcnt</span><span class=p>.</span><span class=n>counter</span><span class=p>[</span><span class=nf>refcnt_index</span><span class=p>(</span><span class=n>pa</span><span class=p>)]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>refcnt</span><span class=p>.</span><span class=n>counter</span><span class=p>[</span><span class=nf>refcnt_index</span><span class=p>(</span><span class=n>pa</span><span class=p>)]</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;wtf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>之後page要會fork
兩個case</p><ol><li>refcnt大於1: 產生新的page，原本的page的refcnt減1</li><li>refcnt等於1: 直接拿去用</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>page_fork</span><span class=p>(</span><span class=n>uint64</span> <span class=n>va</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>pagetable_t</span> <span class=n>pgt</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>va</span> <span class=o>=</span> <span class=nf>PGROUNDDOWN</span><span class=p>(</span><span class=n>va</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span> <span class=n>pte</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>pgt</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>pa</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>flags</span> <span class=o>=</span> <span class=nf>PTE_FLAGS</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>((</span><span class=o>*</span><span class=n>pte</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>PTE_COW</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>refcnt_lock</span><span class=p>();</span> <span class=c1>// MUST BE DONE TOGETHER!!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>refcnt_get</span><span class=p>(</span><span class=n>pa</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>void</span> <span class=o>*</span><span class=n>mem</span> <span class=o>=</span> <span class=nf>kalloc_cow</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>mem</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>memmove</span><span class=p>(</span><span class=n>mem</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>pa</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>pgt</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>mem</span><span class=p>,</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>~</span><span class=n>PTE_COW</span><span class=p>))</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nf>kfree</span><span class=p>(</span><span class=n>mem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>          <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nf>refcnt_desc</span><span class=p>(</span><span class=n>pa</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>PTE_COW</span><span class=p>)</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>refcnt_unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> 
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>與之相對，kfree只有在refcnt小於等於1時才free，其他都是decrease refcnt</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>kfree</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>pa</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>refcnt_lock</span><span class=p>();</span> <span class=c1>//premise: counter == 0  &lt;=&gt; this page is in freelist
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>refcnt_get</span><span class=p>((</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(((</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span> <span class=o>%</span> <span class=n>PGSIZE</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>pa</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>||</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span> <span class=o>&gt;=</span> <span class=n>PHYSTOP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kfree&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Fill with junk to catch dangling refs.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memset</span><span class=p>(</span><span class=n>pa</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>refcnt_set</span><span class=p>((</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>run</span><span class=o>*</span><span class=p>)</span><span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>.</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>kmem</span><span class=p>.</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>kmem</span><span class=p>.</span><span class=n>freelist</span> <span class=o>=</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>.</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nf>refcnt_desc</span><span class=p>((</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>refcnt_unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>另外，從kernel mode複製到user mode也要fork page
如果都指向同一個page要分開</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>uvmcopy</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>old</span><span class=p>,</span> <span class=kt>pagetable_t</span> <span class=n>new</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>sz</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 從copy變成map
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sz</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=p>((</span><span class=o>*</span><span class=n>pte</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>~</span><span class=n>PTE_W</span><span class=p>))</span> <span class=o>|</span> <span class=n>PTE_COW</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>new</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>,</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>~</span><span class=n>PTE_W</span><span class=p>))</span> <span class=o>|</span> <span class=n>PTE_COW</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>refcnt_lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=nf>refcnt_incr</span><span class=p>(</span><span class=n>pa</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>refcnt_unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=nl>err</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>new</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>i</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>copyout</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>dstva</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>n</span><span class=p>,</span> <span class=n>va0</span><span class=p>,</span> <span class=n>pa0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>len</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果都指向同一個page要分開
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>pte_t</span><span class=o>*</span> <span class=n>pte</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>va0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pte</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_COW</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>page_fork</span><span class=p>(</span><span class=n>va0</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>之後把剩下的線串完</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>usertrap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span><span class=p>((</span><span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>15</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>page_fork</span><span class=p>(</span><span class=nf>r_stval</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>      <span class=n>p</span><span class=o>-&gt;</span><span class=n>killed</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>這邊有一個要注意的點
refcnt是跟著page走，所以<em>直到page與refcnt設定好之前任何人都不該動refcnt</em>
這導致kalloc與kalloc_cow的產生，因為refcnt會鎖，但是做page_fork時會動到兩個page，所以kalloc_cow不鎖，交給page_fork鎖</p><pre tabindex=0><code class="language-c=" data-lang="c=">void *
kalloc(void)
{
  // ...
  if(r) {
    refcnt_lock();
    refcnt_incr((uint64)r);
    refcnt_unlock();
    //printf(&#34;init: %p %d\n&#34;, r, refcnt_get((uint64)r));
    memset((char*)r, 5, PGSIZE); // fill with junk
  }

  return (void*)r;
}

void *
kalloc_cow(void)
{
  // ...
  if(r) {
    refcnt_set((uint64)r, 1);
    //printf(&#34;init: %p %d\n&#34;, r, refcnt_get((uint64)r));
    memset((char*)r, 5, PGSIZE); // fill with junk
  }

  return (void*)r;
}
</code></pre><p>最後就像，lazy alloc做的一樣，要處理走訪pte時忽略沒有PTE_V的page</p><p>lock心得
0. 上鎖</p><ol><li>先存狀態</li><li>都用同一個狀態延伸</li><li>把所有動作用同一個鎖包 (這會導致在不同branch要一直release)</li><li>確保假設被打破時可以馬上停下程式 (ex: panic(&ldquo;wtf&rdquo;))</li></ol><h3 id=lab-mmap>Lab mmap<a hidden class=anchor aria-hidden=true href=#lab-mmap>#</a></h3><p>現在user可以自己設定自己的addr了!!</p><p>Q: 這樣怎麼區分user設定的資料與程式設定的(原本活在pagetable中的)資料?
A: 多一個vma去trace</p><p>Q: 怎麼分配位置?
A: 這隨便，這裡從TRAPFRAME之後開始</p><p>Q: 如果alloc很多塊，卻只free其中幾塊，我們還有方法再利用那些mem嗎?
A: 這要做compact，但我懶，沒做test會過</p><p>先加vma，與sbrk很像，用vma_end紀錄最後的位置
記住，riscv是往addr小的地方開始填資料</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>entry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>va_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>prot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>flag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>file</span><span class=o>*</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define VMA_SIZE 16
</span></span></span><span class=line><span class=cl><span class=cp>#define VMA_BASE (TRAPFRAME - PGSIZE)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>entry</span> <span class=n>vma</span><span class=p>[</span><span class=n>VMA_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>uint64</span> <span class=n>vma_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>之後要可以alloc vma，與get vma</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>entry</span><span class=o>*</span> <span class=nf>allocvma</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>entry</span><span class=o>*</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>VMA_SIZE</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vma</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>ret</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vma</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>entry</span><span class=o>*</span> <span class=nf>getvma</span><span class=p>(</span><span class=n>uint64</span> <span class=n>addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>VMA_SIZE</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vma</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vma</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>va_end</span> <span class=o>&gt;</span> <span class=n>addr</span> <span class=o>&amp;&amp;</span> <span class=n>addr</span> <span class=o>&gt;=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vma</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>va_end</span><span class=o>-</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vma</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>VMA_SIZE</span> <span class=o>?</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vma</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>把mmap, munmap加進去
這裡做lazy，只有在read/write才map與讀檔案</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_mmap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>file</span><span class=o>*</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=n>prot</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>goodargs</span> <span class=o>=</span> <span class=p>(</span><span class=nf>argint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>size</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nf>argint</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>prot</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nf>argint</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flags</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nf>argfd</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>f</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>goodargs</span> <span class=o>||</span> <span class=p>(</span><span class=o>!</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>writable</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_WRITE</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>MAP_SHARED</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>entry</span> <span class=o>*</span><span class=n>vma</span> <span class=o>=</span> <span class=nf>allocvma</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>vma</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pte_prot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_READ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>pte_prot</span> <span class=o>|=</span> <span class=n>PTE_R</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_WRITE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>pte_prot</span> <span class=o>|=</span> <span class=n>PTE_W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>filedup</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>va_end</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vma_end</span><span class=p>;</span> <span class=c1>// start在小 end在大 mmap回傳的addr是小的!!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ret</span> <span class=o>=</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>va_end</span><span class=o>-</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>f</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>prot</span> <span class=o>=</span> <span class=n>pte_prot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>=</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>vma_end</span> <span class=o>-=</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>do_mummap</span><span class=p>(</span><span class=n>uint64</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>entry</span> <span class=o>*</span><span class=n>vma</span> <span class=o>=</span> <span class=nf>getvma</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>vma</span> <span class=o>||</span> <span class=n>addr</span> <span class=o>+</span> <span class=n>len</span> <span class=o>&gt;</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>va_end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//printf(&#34;??: %d start:%p va:%p va_end:%p end:%p\n&#34;, vma-&gt;size, vma-&gt;va_end-vma-&gt;size, addr, addr+len, vma-&gt;va_end);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>uint64</span> <span class=n>va</span><span class=o>=</span><span class=n>addr</span><span class=p>,</span><span class=n>end</span><span class=o>=</span><span class=n>addr</span><span class=o>+</span><span class=n>len</span><span class=p>;</span><span class=n>va</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>;</span><span class=n>va</span><span class=o>+=</span><span class=n>PGSIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>walkaddr</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>va</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>&amp;</span> <span class=n>MAP_SHARED</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=nf>filewrite</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>f</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>   
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>addr</span> <span class=o>==</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>va_end</span><span class=o>-</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&amp;&amp;</span> <span class=n>addr</span><span class=o>+</span><span class=n>len</span> <span class=o>==</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>va_end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//fileclose(vma-&gt;f);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>ref</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>-=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>addr</span><span class=o>+</span><span class=n>len</span> <span class=o>==</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>va_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>vma</span><span class=o>-&gt;</span><span class=n>va_end</span> <span class=o>-=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_munmap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>argaddr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nf>argint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>do_mummap</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在page fault才map與讀檔案</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>do_mmap</span><span class=p>(</span><span class=n>uint64</span> <span class=n>addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>base</span> <span class=o>=</span> <span class=nf>PGROUNDDOWN</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>mem</span> <span class=o>=</span> <span class=nf>kalloc</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;out of pa</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>entry</span><span class=o>*</span> <span class=n>vma</span> <span class=o>=</span> <span class=nf>getvma</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>vma</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>memset</span><span class=p>(</span><span class=n>mem</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>base</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>mem</span><span class=p>,</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>prot</span><span class=o>|</span><span class=n>PTE_U</span><span class=o>|</span><span class=n>PTE_X</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>kfree</span><span class=p>(</span><span class=n>mem</span><span class=p>),</span> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;map fail</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>ilock</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>offset</span> <span class=o>=</span> <span class=n>base</span> <span class=o>-</span> <span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>va_end</span><span class=o>-</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>readi</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>base</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>iunlock</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>//printf(&#34;vma no found\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nf>kfree</span><span class=p>(</span><span class=n>mem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>usertrap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>13</span> <span class=o>||</span> <span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>15</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>do_mmap</span><span class=p>(</span><span class=nf>r_stval</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>-&gt;</span><span class=n>killed</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>剩下就是初始化與在fork時vma用到的file要記得refcnt要遞增</p><h3 id=linux-crash-tool>Linux crash tool<a hidden class=anchor aria-hidden=true href=#linux-crash-tool>#</a></h3><p>經過前面lab的洗禮，相信大家也對va,pa,pte的關係有深刻的了解
這樣可以來看看，在linux中怎麼改mem</p><ol><li>crash tool: 可以分析kerneldump看ctx與kernel的struct</li><li>/dev/mem: <em>整個</em>mem的視圖，就是ch3第一張圖的所有東西都會在這裡看到</li></ol><p>下面借用<a href=https://hackmd.io/@sysprog/linux-mem-device>這裡</a>的內容來看看這兩個怎麼一起用
先預設/dev/mem可以寫，pagetable沒有任何限制</p><p><a href=https://www.tutorialspoint.com/unix_commands/crash.htm>這裡</a>可以看crash的指令</p><ul><li>vtop: show va的訊息</li><li>wr: 改寫 mem</li><li>set: 把mem view改成該pid的process的view</li><li>ps: 就是ps</li></ul><h4 id=改pte的map>改pte的map<a hidden class=anchor aria-hidden=true href=#改pte的map>#</a></h4><p>兩個process，兩個page，兩個addr(0x34000000, 0x34004000)</p><p>之後在crash中改pte指到的地方</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/mem&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 建立一個分頁 P1 映射到保留記憶體
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addr</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=mh>0x34000000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 修改 P1 的内容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>addr</span> <span class=o>=</span> <span class=mh>0x1122334455667788</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;address at: %p   content is: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>addr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 等待分頁交換
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;address at: %p   content is: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>addr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>munmap</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=mi>4096</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/mem&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 建立分頁 P2 映射到保留的記憶體
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addr</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=mh>0x34004000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 修改 P2 的内容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>addr</span> <span class=o>=</span> <span class=mh>0x8877665544332211</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;address at: %p   content is: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>addr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>  
</span></span><span class=line><span class=cl>    <span class=c1>// 等待分頁交換
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;address at: %p   content is: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>addr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>munmap</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=mi>4096</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>接著要找pte，找對面對到的pa</p><pre tabindex=0><code>crash&gt; ps | grep master                                                                                                                                                                [8/287]
  32334  32333   6  ffff93d0ed35c680  IN   0.0    4512   1384  master
crash&gt; set 32334
    PID: 32334
COMMAND: &#34;master&#34;
   TASK: ffff93d0ed35c680  [THREAD_INFO: ffff93d0ed35c680]
    CPU: 6
  STATE: TASK_INTERRUPTIBLE
crash&gt; vtop 0x7f8f3ba6a000
VIRTUAL     PHYSICAL
7f8f3ba6a000  2c0000000 &lt;= va 與 pa

   PGD: 2ae2f87f8 =&gt; 80000002af219067
   PUD: 2af2191e0 =&gt; 2a9d3c067
   PMD: 2a9d3cee8 =&gt; 2ac34b067
   PTE: 2ac34b350 =&gt; 80000002c0000267 &lt;= pte 與 對到的pa
  PAGE: 2c0000000

      PTE         PHYSICAL   FLAGS
80000002c0000267  2c0000000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)

      VMA           START       END     FLAGS FILE
ffff93d0e894e000 7f8f3ba6a000 7f8f3ba6b000 d0444fb /dev/mem

crash&gt; wr -64 -p 2ac34b350 80000002c0004267 &lt;= pte 與 對面對到的pa
</code></pre><pre tabindex=0><code>crash&gt; ps | grep slave
  32348  32347   1  ffff93d0ed359780  IN   0.0    4512   1416  slave
crash&gt; set 32348
    PID: 32348
COMMAND: &#34;slave&#34;
   TASK: ffff93d0ed359780  [THREAD_INFO: ffff93d0ed359780]
    CPU: 1
  STATE: TASK_INTERRUPTIBLE
crash&gt; vtop 0x7f269fba3000
VIRTUAL     PHYSICAL
7f269fba3000  2c0004000

   PGD: 2ae2ca7f0 =&gt; 80000002ac354067
   PUD: 2ac3544d0 =&gt; 2b45f6067
   PMD: 2b45f67e8 =&gt; 2ac7db067
   PTE: 2ac7dbd18 =&gt; 80000002c0004267
  PAGE: 2c0004000
  
      PTE         PHYSICAL   FLAGS
80000002c0004267  2c0004000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)

      VMA           START       END     FLAGS FILE
ffff93d0eea18820 7f269fba3000 7f269fba4000 d0444fb /dev/mem

crash&gt; wr -64 -p 2ac7dbd18 80000002c0000267
</code></pre><h4 id=改pa的值>改pa的值<a hidden class=anchor aria-hidden=true href=#改pa的值>#</a></h4><p>先給個程式，印出va(不然無法知道pa)，之後直接改pa的值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 匿名映射一段記憶體空間
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addr</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_ANONYMOUS</span><span class=o>|</span><span class=n>MAP_SHARED</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 修改內容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=s>&#34;浙江溫州皮鞋濕&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 只是範例，所以直接顯示 address 實際操作時需要手工 hack 記憶體位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;address at: %p   content is: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;address at: %p   content is: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>munmap</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=mi>4096</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>用crash找pa</p><pre tabindex=0><code>crash&gt; ps | grep test
  11608  11607   1  ffff93d0ed378000  IN   0.0    4512   1408  test
  
crash&gt; set 11608
    PID: 11608
COMMAND: &#34;test&#34;
   TASK: ffff93d0ed378000  [THREAD_INFO: ffff93d0ed378000]
    CPU: 1
  STATE: TASK_INTERRUPTIBLE
  
crash&gt; vtop 0x7f7d88693000
VIRTUAL     PHYSICAL
7f7d88693000  1f83ed000

   PGD: 2a73ee7f0 =&gt; 8000000220a30067
   PUD: 220a30fb0 =&gt; 2ae1f4067
   PMD: 2ae1f4218 =&gt; 2b0c7e067
   PTE: 2b0c7e498 =&gt; 80000001f83ed867
  PAGE: 1f83ed000

      PTE         PHYSICAL   FLAGS
80000001f83ed867  1f83ed000  (PRESENT|RW|USER|ACCESSED|DIRTY|NX)

      VMA           START       END     FLAGS FILE
ffff93d0ec033450 7f7d88693000 7f7d88694000 80000fb dev/zero

      PAGE        PHYSICAL      MAPPING       INDEX CNT FLAGS
ffffd377c7e0fb40 1f83ed000 ffff93d0f01a9290        0  2 17ffffc0040038 uptodate,dirty,lru,swapbacked
</code></pre><p>現在我們知道0x1f83ed000就是我們要的位置!!
就改吧 mmap到pa去</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>off</span> <span class=o>=</span> <span class=mh>0x1f83ed000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/mem&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>addr</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=n>off</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=s>&#34;下雨進水不會胖&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>munmap</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=mi>4096</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=小結>小結<a hidden class=anchor aria-hidden=true href=#小結>#</a></h4><p>這裡的例子很簡單，但是很可怕，基本上只要知道pa就什麼都擋不住了
同時如果知道struct的大小與偏移量，基本上就是可以操作任何東西了</p><p>像是在task_struct遊走，改常數等等&mldr;
可以看上面的文章與<a href=https://mp.weixin.qq.com/s/040W19-CPF0VnUvwFSKiXw>這裡</a>都有一些使用範例</p><h3 id=heap-coruption>Heap Coruption<a hidden class=anchor aria-hidden=true href=#heap-coruption>#</a></h3><p>剛好提到記憶體，可以看看關於記憶體的問題，下面內容主要處自<a href=https://medium.com/renee0918/windbg-heap-corruption-analyze-51fa43a5b383>這裡</a></p><ol><li>在第一次的dump，backtrace沒有印出正確的行號<ul><li>文中提到懷疑是Heap Coruption的理由是<ul><li>崩潰是發生在存取非法位址</li><li>這個行號所在的程式碼單純到沒辦法找到造成問題的部分在哪</li></ul></li><li>可以猜猜看why<ul><li>亂序執行<ul><li>concurrent，但明顯不是</li></ul></li><li>之前在不對的地方沒有停下來<ul><li>可以試試把array超過length的地方print出來: print的出來!!</li><li>如果這是迴圈中出事就還好，但如果出了loop&mldr;</li></ul></li></ul></li></ul></li><li>第二次dump用了大招，上heap保護<ul><li>這與xv6的stack的guard page一樣，出錯直接panic</li><li>這樣就可以直接看到對的地方，index出界，在8爆了<ol><li>不是在5爆?<ul><li>為了好分配mem，所以會對齊</li></ul></li><li>回頭來看c的type到底是什麼?<ul><li>一次要跳幾格<ul><li>char是1</li><li>uint64是8</li><li>etc</li></ul></li><li>所以c其實就是一直幫忙算這個addr一次跳幾格<ul><li>出事由下面的cpu噴</li><li>linux有辦法這樣做嗎?<ul><li><a href=https://zhuanlan.zhihu.com/p/138886988>定位Memory Corruption的思路</a></li></ul></li></ul></li></ul></li></ol></li></ul></li></ol><h2 id=ch6>ch6<a hidden class=anchor aria-hidden=true href=#ch6>#</a></h2><p>當我們說鎖保護數據時，我們真正的意思是鎖保護了一些適用於數據的不變式(invariant）集合</p><p>你可以把鎖看成是把並發的臨界區串行化(serializing)的一種工具，使它們同時只運行一個，從而保護 invariant（假設臨界區是獨立的）。</p><p>正確地使用鎖可以保證一次只能有一個 CPU 對關鍵部分的數據結構進行操作，所以當數據結構的 invariant 不成立時，沒有 CPU 會執行數據結構操作</p><p>如果一個穿過內核的代碼路徑必須同時持有多個鎖，那麼所有的代碼路徑以相同的順序獲取這些鎖是很重要的
* 有時鎖的身份並不是事先知道的，也許是因為必須持有一個鎖才能發現接下來要獲取的鎖的身份</p><p>CPU 的 ordering 規則稱為內存模型!!
(目前看過最精練的解釋)</p><h3 id=自旋锁>自旋锁<a hidden class=anchor aria-hidden=true href=#自旋锁>#</a></h3><ol><li>關中斷</li><li>atomic cas while looping => lock</li><li>mem barrier => mem barrier</li></ol><p>一個中斷處理程序使用了自旋鎖，CPU 決不能在啟用中斷的情況下持有該鎖。
Xv6 比較保守：當一個 CPU 獲取任何鎖時，xv6 總是禁用該 CPU 上的中斷。</p><p>xv6 在 CPU 沒有持有自旋鎖時重新啟用中斷；它必須做一點記錄來應對嵌套的臨界區。</p><p>這個spinlock可以recursive!!
因為有紀錄cpu id所以可以處理這一段</p><h4 id=trace-spinlock>trace: spinlock<a hidden class=anchor aria-hidden=true href=#trace-spinlock>#</a></h4><p>我們把debug有關的部分skip掉</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Mutual exclusion lock.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>spinlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>locked</span><span class=p>;</span>       <span class=c1>// Is the lock held?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>acquire對數字做test_and_set，不成功就一直轉</p><ul><li>這裡要用riscv提供的指令去換，不然被reorder就出事了</li><li>因為原本有設定cpuid的部分，導致還需要memory barrier<ul><li>但這裡就先跳掉</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>acquire</span><span class=p>(</span><span class=k>struct</span> <span class=n>spinlock</span> <span class=o>*</span><span class=n>lk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>push_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=nf>__sync_lock_test_and_set</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lk</span><span class=o>-&gt;</span><span class=n>locked</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>release就是acquire反著做</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>release</span><span class=p>(</span><span class=k>struct</span> <span class=n>spinlock</span> <span class=o>*</span><span class=n>lk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>__sync_lock_release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lk</span><span class=o>-&gt;</span><span class=n>locked</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>pop_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=睡眠锁>睡眠锁<a hidden class=anchor aria-hidden=true href=#睡眠锁>#</a></h3><p>擴展自旋锁，多了sleep</p><ol><li>上spinlock</li><li>直到拿到鎖之前，一直sleep<ul><li>處理虛假喚醒</li></ul></li></ol><p>這裡是把sleep多傳一個lock，保證sleep後lock會被釋放
pthread也是，但是叫condition var</p><h4 id=trace-sleeplock>trace: sleeplock<a hidden class=anchor aria-hidden=true href=#trace-sleeplock>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sleeplock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>locked</span><span class=p>;</span>       <span class=c1>// Is the lock held?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lk</span><span class=p>;</span> <span class=c1>// spinlock protecting this sleep lock
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>acquire與release其實很簡單，用spinlock保護locked
如果只有保護locked能用atomic?</p><p>答案是不行，因為還要保護成功sleep</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>acquiresleep</span><span class=p>(</span><span class=k>struct</span> <span class=n>sleeplock</span> <span class=o>*</span><span class=n>lk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lk</span><span class=o>-&gt;</span><span class=n>lk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>lk</span><span class=o>-&gt;</span><span class=n>locked</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>sleep</span><span class=p>(</span><span class=n>lk</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>lk</span><span class=o>-&gt;</span><span class=n>lk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>lk</span><span class=o>-&gt;</span><span class=n>locked</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lk</span><span class=o>-&gt;</span><span class=n>lk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>releasesleep</span><span class=p>(</span><span class=k>struct</span> <span class=n>sleeplock</span> <span class=o>*</span><span class=n>lk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lk</span><span class=o>-&gt;</span><span class=n>lk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>lk</span><span class=o>-&gt;</span><span class=n>locked</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>wakeup</span><span class=p>(</span><span class=n>lk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lk</span><span class=o>-&gt;</span><span class=n>lk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>為了可以在有lock當狀態下sleep，變成sleep要解上面lock，之後再鎖自己的lock
可以看到這邊lock涵蓋的範圍有overlay</p><p>如果有用過pthread的cond var就會看到一樣的東西!!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>sleep</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>chan</span><span class=p>,</span> <span class=k>struct</span> <span class=n>spinlock</span> <span class=o>*</span><span class=n>lk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>lk</span> <span class=o>!=</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>){</span>  <span class=c1>//DOC: sleeplock0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>  <span class=c1>//DOC: sleeplock1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>release</span><span class=p>(</span><span class=n>lk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// Reacquire original lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>lk</span> <span class=o>!=</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>acquire</span><span class=p>(</span><span class=n>lk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=用什麼鎖>用什麼鎖<a hidden class=anchor aria-hidden=true href=#用什麼鎖>#</a></h3><p>因為睡眠鎖會使中斷處於啟用狀態，所以不能在中斷處理程序中使用睡眠鎖</p><p>自旋鎖最適合短的臨界區，因為等待它們會浪費 CPU 時間
睡眠鎖對長時間的操作很有效</p><h3 id=lab-lock>Lab Lock<a hidden class=anchor aria-hidden=true href=#lab-lock>#</a></h3><h4 id=memory-allocator>Memory allocator<a hidden class=anchor aria-hidden=true href=#memory-allocator>#</a></h4><p>把freelist放到各個cpu中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>cpu</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>所以kalloc要從自己的list中找，如果沒有就去偷
kfree就直接塞回自己的list</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>kalloc</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>push_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=nf>cpuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>freelist</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=nf>steal_page</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>freelist</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>pop_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>kfree</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>pa</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=nf>cpuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>r</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>freelist</span> <span class=o>=</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cpus</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>pop_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>偷就是走訪其他cpu看有沒有free的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>steal_page</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// interrupt should be disabled
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=p>((</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=n>NCPU</span><span class=p>);</span> <span class=o>!</span><span class=n>ret</span> <span class=o>&amp;&amp;</span> <span class=n>j</span><span class=o>!=</span><span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>=</span><span class=p>((</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=n>NCPU</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cpus</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cpus</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>freelist</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>ret</span> <span class=o>=</span> <span class=n>cpus</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>cpus</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>freelist</span> <span class=o>=</span> <span class=n>cpus</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>freelist</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cpus</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=buffer-cache>Buffer cache<a hidden class=anchor aria-hidden=true href=#buffer-cache>#</a></h4><p>其實可以用前面的想法，把list打散</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define TBL_SIZE 7
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>struct</span> <span class=n>entry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>entry</span> <span class=n>tbl</span><span class=p>[</span><span class=n>TBL_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>insert_buf</span><span class=p>(</span><span class=k>struct</span> <span class=n>buf</span><span class=o>*</span> <span class=n>head</span><span class=p>,</span> <span class=k>struct</span> <span class=n>buf</span><span class=o>*</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>拿不到就去偷</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>bget</span><span class=p>(</span><span class=n>uint</span> <span class=n>dev</span><span class=p>,</span> <span class=n>uint</span> <span class=n>blockno</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//acquire(&amp;bcache.lock);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// Is the block already cached?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=nf>tbl_index</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span> <span class=n>blockno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// check cache
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=n>b</span> <span class=o>=</span> <span class=n>tbl</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>head</span><span class=p>.</span><span class=n>next</span><span class=p>;</span> <span class=n>b</span> <span class=o>!=</span> <span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>head</span><span class=p>;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>dev</span> <span class=o>==</span> <span class=n>dev</span> <span class=o>&amp;&amp;</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>blockno</span> <span class=o>==</span> <span class=n>blockno</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>acquiresleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// steal free buf
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>,</span> <span class=n>cnt</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>cnt</span> <span class=o>&lt;</span> <span class=n>TBL_SIZE</span><span class=p>;</span><span class=n>j</span><span class=o>=</span><span class=p>((</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=n>TBL_SIZE</span><span class=p>),</span><span class=n>cnt</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>b</span> <span class=o>=</span> <span class=n>tbl</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>head</span><span class=p>.</span><span class=n>next</span><span class=p>;</span> <span class=n>b</span> <span class=o>!=</span> <span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>head</span><span class=p>;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>dev</span> <span class=o>=</span> <span class=n>dev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>blockno</span> <span class=o>=</span> <span class=n>blockno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>valid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>tbl_index</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>prev</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>,</span> <span class=o>*</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>prev</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>tbl</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>head</span><span class=p>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>insert_buf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>head</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>acquiresleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tbl</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;bget: no buffers&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>剩下的就是把bcache改成用到對的list</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>buf</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>tbl_index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h2 id=ch7>ch7<a hidden class=anchor aria-hidden=true href=#ch7>#</a></h2><p>xv6 的sleep 和 wakeup 機制會進行切換
這會發生在進程等待設備或管道 I/O
等待子進程退出
在 sleep 系統調用中等待</p><p>xv6 週期性地強制切換，以應對長時間的計算進程。</p><p>首先，如何從一個進程切換到另一個進程？
第二，如何對用戶進程透明的強制切換？ (用定時器中斷來驅動上下文切換)
第三，許多 CPU 可能會在進程間並發切換，需要設計一個鎖來避免競爭。
第四，當進程退出時，必須釋放進程的內存和其他資源，但它自己不能做到這一切，因為它不能釋放自己的內核棧，同時又在使用內核棧。
第五，多核機器的每個內核必須記住它正在執行的進程，這樣系統調用就會修改相應進程的內核狀態。
最後，sleep 和 wakeup 允許一個進程放棄 CPU，並睡眠等待事件，並允許另一個進程喚醒第一個進程。</p><p>需要注意一些競爭可能會使喚醒丟失!!</p><h3 id=coperative-thread-sleep-wakeup-ctx-switch-scheduler>coperative thread: sleep, wakeup, ctx switch, scheduler<a hidden class=anchor aria-hidden=true href=#coperative-thread-sleep-wakeup-ctx-switch-scheduler>#</a></h3><p><img loading=lazy src=https://i.imgur.com/RcwxOmm.png alt></p><h4 id=ctx-switch>ctx switch<a hidden class=anchor aria-hidden=true href=#ctx-switch>#</a></h4><p>xv6 調度器在每個 CPU 上有一個專門的線程(保存的寄存器和棧)，因為調度器在舊進程的內核棧上執行是不安全的</p><p>棧指針和 pc 被保存和恢復，意味著 CPU 將切換棧和正在執行的代碼</p><p>Swtch(kernel/swtch.S:3)只保存 callee-saved 寄存器，caller-saved 寄存器由調用的 C
代碼保存在堆棧上(如果需要)</p><p><img loading=lazy src=https://i.imgur.com/pczpVz4.png alt></p><p>它不保存 pc。
當swtch 返回時，它返回到被恢復的 ra 寄存器所指向的指令，也就是新線程之前調用 swtch的指令。
此外，它還會在新線程的棧上返回。</p><h4 id=scheduler>scheduler<a hidden class=anchor aria-hidden=true href=#scheduler>#</a></h4><p>其實就是在沒有process在跑的時候選一個跑</p><ol><li>main會call，scheduler</li><li>之後scheduler挑一個proc (RR)</li><li>ctx switch<ul><li>到ctx switch時還沒release lock!!<ul><li>對於上下文切換來說，有必要打破這個約定，因為 p->lock 保護了進程的狀態和 context 字段上的不變式(invariant)，而這些不變式在 swtch 中執行時為 false。</li></ul></li><li>都是與mycpu換ctx!!<ul><li>所以可以看成mycpu()->context就是正在跑的cpu的state，也是proc的state(不是RUNNABLE之類的，是執行的狀態)</li></ul></li></ul></li></ol><h5 id=p-lock>p->lock??<a hidden class=anchor aria-hidden=true href=#p-lock>#</a></h5><p>可以這樣理解調度代碼結構，它執行一組關於進程的不變式，並且每當這些不變式為False 時，就持有 p->lock。</p><p>一個不變式是，</p><ul><li>如果一個進程正在運行，定時器中斷的 yield 必須能夠安全地切換進程；<ul><li>這意味著 CPU 寄存器必須持有進程的寄存器值（即 swtch 沒有將它們移到上下文中）</li><li>並且 c->proc 必須指向該進程。
另一個不變式是，</li></ul></li><li>如果一個進程是RUNNABLE 的，那麼對於一個空閒的 CPU 調度器來說，運行它必須是安全的<ul><li>這意味著<ul><li>（1）p->context 必須擁有進程的寄存器（i.e., 它們實際上並不在真實的寄存器中）</li><li>（2）沒有 CPU 在進程的內核棧上執行</li><li>（3）也沒有 CPU 的 c->proc 指向進程<ul><li>請注意，當 p->lock被持有時，這些屬性往往不為真。</li></ul></li></ul></li></ul></li></ul><p>維護上述不變式的原因：xv6 經常在一個線程中獲取 p->lock，然後在另一個線程中釋放</p><p>直到成功轉移state之前都要hold lock</p><h5 id=mycpu-and-myproc>mycpu and myproc<a hidden class=anchor aria-hidden=true href=#mycpu-and-myproc>#</a></h5><p>Xv6 為每個 CPU 維護了一個 cpu 結構體(kernel/proc.h:22)，它記錄了當前在該 CPU 上
運行的進程(如果有的話)，為 CPU 的調度線程保存的寄存器，以及管理中斷禁用所需的嵌套
自旋鎖的計數。</p><p>Xv6 確保每個 CPU 的 hartid 在內核中被存儲在該 CPU 的 tp 寄存器中</p><p>Usertrapret 將 tp 寄存器保存在 trampoline 頁中，因為用戶進程可能會修改 tp 寄存器</p><p>當從用戶空間進入內核時，uservec 會恢復保存的 tp(kernel/trampoline.S:70)。編譯器保證永遠不使用 tp 寄存器。</p><p>如果 RISC-V 允許 xv6 直接讀取當前的 hartid 會更方便</p><p>cpuid 和 mycpu 的返回值很容易錯：
如果定時器中斷，導致線程讓出 CPU，然後轉移到不同的 CPU 上，之前返回的值將不再正確。
為了避免這個問題，xv6 要求調用者禁用中斷，只有在使用完返回的 cpu 結構後才啟用中斷</p><p>myproc(kernel/proc.c:68)函數返回當前 CPU 上運行的進程的 proc 指針。
myproc 禁用中斷，調用 mycpu，從 cpu 中獲取當前進程指針(c->proc)，然後啟用中斷。</p><p>myproc不用lock防嗎??
當下指到的proc是對的</p><h4 id=sleep-1>Sleep<a hidden class=anchor aria-hidden=true href=#sleep-1>#</a></h4><p>為了確保進入sleep前的state改變不會被打斷 (eg: semaphore的P)</p><p>sleep會先hold proc的lock，才去</p><ol><li>release 前一個lock</li><li>改proc狀態<ul><li>p->chan = chan;</li><li>p->state = SLEEPING;</li></ul></li><li>sched</li></ol><p>這邊會看到一個有趣的事，與scheduler一樣，p->lock沒有release!!</p><h4 id=wakeup>wakeup<a hidden class=anchor aria-hidden=true href=#wakeup>#</a></h4><p>把<strong>所有</strong>聽在同一個lock(semaphore)的proc的state設定成runnable</p><h5 id=虛假喚醒>虛假喚醒<a hidden class=anchor aria-hidden=true href=#虛假喚醒>#</a></h5><p>wakeup會把<strong>所有</strong>proc，叫醒，但<strong>只有一個</strong>proc可以拿到lock</p><p>所以對其他proc而言，這是虛假喚醒!!</p><h5 id=exit--wait>exit & wait<a hidden class=anchor aria-hidden=true href=#exit--wait>#</a></h5><p>exit: 把file close，把proc設定成ZOMBIE，sched
wait: 掃child proc，看有沒有ZOMBIE，有就設定成UNUSED；沒有就sleep</p><p>父進程和子進程的 wait 和 exit，以及 exit 和 exit 之間可能出現競爭和死鎖的情況</p><p>此 xv6 的所有鎖都必須遵守相同的鎖順序（父進程的鎖，然後是子進程的鎖），以避免死鎖</p><h3 id=preemptive-thread>preemptive thread<a hidden class=anchor aria-hidden=true href=#preemptive-thread>#</a></h3><p>time interrupt時做sched</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>usertrap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// give up the CPU if this is a timer interrupt.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>which_dev</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>yield</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=trace-trapframe--context>trace: trapframe & context<a hidden class=anchor aria-hidden=true href=#trace-trapframe--context>#</a></h3><p>看回來這張圖
<img loading=lazy src=https://i.imgur.com/RcwxOmm.png alt></p><p>sched都是在kernel mode發生，所以不用換pagetable</p><p>sched是換手，也就是我已經做了差不多了，所以會主動call函數，之後只要回來我這邊就好，
但是換回來函數的執行環境(callee-save)會壞掉，所以要存；
用於計算用的參數就，沒有用(做了差不多了，或是說已經存在stack上了(會call函數c會處理))，就不用管</p><p>trap是中斷，所以之後要在原本的地方跑(還沒做完)，因此要保留原本的pc，不然沒辦法接回去；
同時要保留caller-save，trap可以看成call函數，但沒有c的幫忙，所以這要自己存；
剩下是ctx switch，所以callee-save也要存</p><h3 id=trace-exit--wait>trace: exit & wait<a hidden class=anchor aria-hidden=true href=#trace-exit--wait>#</a></h3><ul><li><p>exit:</p><ul><li>把opend file關一關</li><li>把parent設定成init</li><li>把自己state設定成ZOMBIE</li></ul></li><li><p>wait</p><ul><li>掃過整個proc，找符合下面兩個條件的proc<ul><li>parent是caller的proc</li><li>state是ZOMBIE</li></ul></li><li>找到就<ul><li>acquire child的lock (wait!!)</li><li>拉proc的return值(xstate)</li><li>freeproc</li></ul></li><li>沒找到<ol><li>state不是ZOMBIE<ul><li>parent sleep</li></ul></li><li>沒有proc認caller做parent<ul><li>報錯</li></ul></li></ol></li></ul></li></ul><p>這裡就可以回答一個經典問題，為什麼要有ZOMBIE?
因為把proc回收分成</p><ol><li>關file: exit</li><li>free mem: wait</li></ol><p>而在wait可以拿到proc的return值(所以不能free mem)
但我們需要一個方式表示proc準備好被回收，所以有ZOMBIE</p><p>但為什麼叫ZOMBIE?
這我真的不懂，不能叫EXITED嗎?</p><h3 id=lab-multithreading>Lab Multithreading<a hidden class=anchor aria-hidden=true href=#lab-multithreading>#</a></h3><h4 id=ph>ph<a hidden class=anchor aria-hidden=true href=#ph>#</a></h4><p>練手用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>table_locks</span><span class=p>[</span><span class=n>NBUCKET</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> 
</span></span><span class=line><span class=cl><span class=nf>insert</span><span class=p>(</span><span class=kt>int</span> <span class=n>key</span><span class=p>,</span> <span class=kt>int</span> <span class=n>value</span><span class=p>,</span> <span class=k>struct</span> <span class=n>entry</span> <span class=o>**</span><span class=n>p</span><span class=p>,</span> <span class=k>struct</span> <span class=n>entry</span> <span class=o>*</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// is the key already present?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>entry</span> <span class=o>*</span><span class=n>e</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=n>table_locks</span><span class=o>+</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>e</span> <span class=o>=</span> <span class=n>table</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=n>e</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>insert</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>table</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>table</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=n>table_locks</span><span class=o>+</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=barrier>barrier<a hidden class=anchor aria-hidden=true href=#barrier>#</a></h4><p>這個就有趣了</p><p>一開始會想只要一個出去把counter設成0就好，但這樣while的部分就會出事，可能有人出不來</p><p>這樣我們挑最後一個去reset計數器，但這樣也會有問題，如果說最後一個一直被hang住，之後中間有跑比較快的進來，這樣就不是barrier</p><p>所以鎖要保護兩個條件</p><ol><li>進來時要確認上一輪的不在這裡了</li><li>人數到了就能release，最後一個要去reset計數器</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> 
</span></span><span class=line><span class=cl><span class=nf>barrier</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>int</span> <span class=n>no_one_here</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>in_room</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bstate</span><span class=p>.</span><span class=n>barrier_mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>no_one_here</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bstate</span><span class=p>.</span><span class=n>barrier_cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bstate</span><span class=p>.</span><span class=n>barrier_mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>pthread_cond_broadcast</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bstate</span><span class=p>.</span><span class=n>barrier_cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>bstate</span><span class=p>.</span><span class=n>nthread</span><span class=o>++</span><span class=p>,</span> <span class=n>in_room</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>bstate</span><span class=p>.</span><span class=n>nthread</span> <span class=o>!=</span> <span class=n>nthread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bstate</span><span class=p>.</span><span class=n>barrier_cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bstate</span><span class=p>.</span><span class=n>barrier_mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>in_room</span><span class=o>--</span> <span class=o>==</span> <span class=n>nthread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>no_one_here</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>bstate</span><span class=p>.</span><span class=n>round</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>in_room</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>no_one_here</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>bstate</span><span class=p>.</span><span class=n>nthread</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>pthread_cond_broadcast</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bstate</span><span class=p>.</span><span class=n>barrier_cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bstate</span><span class=p>.</span><span class=n>barrier_mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=uthread>uthread<a hidden class=anchor aria-hidden=true href=#uthread>#</a></h4><p>這題就去抄context與swtch就好</p><p>但重點是，</p><ol><li>要怎麼到thread的function去?</li></ol><p>trap是改pc，因為我們不會再回來trap中
但thread可以多次來回，所以需要一個自動回到對的位置的機制，ra</p><ol start=2><li>thread的記憶體要放在哪?
回想當初init怎麼做，讓之後的c可以跑?
從stack0放一個PGSIZE，指到sp</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread_create</span><span class=p>(</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func</span><span class=p>)())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>t</span><span class=o>-&gt;</span><span class=n>ctx</span><span class=p>.</span><span class=n>ra</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>func</span><span class=p>;</span> <span class=c1>// HERE
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>t</span><span class=o>-&gt;</span><span class=n>ctx</span><span class=p>.</span><span class=n>sp</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>stack</span> <span class=o>+</span> <span class=n>STACK_SIZE</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=ch8>ch8<a hidden class=anchor aria-hidden=true href=#ch8>#</a></h2><p><img loading=lazy src=https://i.imgur.com/clKOaC4.png alt></p><ul><li><p>磁盤層在 virtio 磁盤上讀寫塊</p></li><li><p>緩存層(bio.c)緩存磁盤塊，並同步訪問它們，確保一個塊只能同時被內核中的一個進程訪問</p><ul><li>buffer 緩存是一個由 buffer 組成的雙端鍊錶</li><li>bget根據devid、sector找buffer</li><li>bread/bwrite讀寫buffer</li><li>brelse釋放sleep lock<ul><li>bread拿鎖</li></ul></li></ul></li><li><p>日誌層(log.c)允許上層通過事務更新多個磁盤塊，並確保在崩潰時，磁盤塊是原子更新的（即全部更新或不更新）</p><ul><li>日誌由一個 header 塊組成，後面是一連串的更新塊副本（日誌塊）。<ul><li>header 塊包含一個扇區號數組，<ul><li>每個扇區號都對應一個日誌塊，header 還包含日誌塊的數量</li></ul></li></ul></li><li>日誌系統可以將多個系統調用的寫操作累積到一個事務中<ul><li>一次提交可能涉及多個完整系統調用的寫入</li><li>為了避免一個系統調用被分裂到不同的事務中，只有在沒有文件系統相關的系統調用正在進行時，日誌系統才會提交</li></ul></li><li>Xv6 在磁盤上劃出固定的空間來存放日誌。在一個事務中，系統調用所寫的塊總數必須 適應這個空間的大小<ul><li>系統調用寫入的日誌大小必須小於日誌空間的大小<ul><li>Xv6 的 write 系統調用將大的寫操作分解成多個小的寫操作，以適應在日誌空間的大小</li><li>unlink 不會引起問題，因為 xv6 文件系統只使用一個位圖塊</li></ul></li><li>日誌系統只會在確定了系統調用的寫操作可以適應剩餘日誌空間之後，才會開始執行該系統調用</li></ul></li></ul></li><li><p>inode 層(fs.c)將一個文件都表示為一個 inode，每個文件包含一個唯一的 i-number 和一些存放文件數據的塊</p><ul><li>balloc 申請一個新的磁盤塊: iterate bitmap</li><li>bfree 釋放一個塊: clear flag on block</li><li>磁盤上的inode<ul><li>文件的大小和數據塊號的列表</li><li>磁盤上的 inode 被放置磁盤的一個連續區域<ul><li>每一個 inode 的大小都是一樣的<ul><li>所以，給定一個數字 n，很容易找到磁盤上的第 n 個 inode</li></ul></li><li>dinode定義了磁盤上的 inode<ul><li>包含一個 size 和一個塊號數組</li><li><img loading=lazy src=https://i.imgur.com/sAWGPwO.png alt><ul><li>開始的 NDIRECT 個數據塊放置在數組中的前NDIRECT 個條目中，這些塊被稱為直接塊</li><li>接下來的 NINDIRECT 個數據塊並沒有放置在inode 中，而是被存放在叫做間接塊的數據塊中</li></ul></li><li>Bmap 返回 inode ip 的第 bn 個數據塊的磁盤塊號。如果 ip 沒有第 bn 個的數據塊，bmap 就會分配一個 (mmap!!)</li></ul></li></ul></li></ul></li><li>mem中的inode<ul><li>了磁盤上 inode 的副本以及內核中需要的其他信息</li><li>結構體 inode (kernel/file.h:17)是磁盤 dinode 的拷貝<ul><li>ref 字段為指向 inode 的指針的數量，如果引用數量減少到零，內核就會從內存中丟棄這個 inode</li><li>iget 和 iput 函數引用和釋放 inode，並修改引用計數</li><li>四種鎖<ul><li>icache.lock 保證了一個 inode 在緩 存只有一個副本，以及緩存 inode 的 ref 字段計數正確</li><li>每個內存中的 inode 都有一個包含 sleep-lock 的鎖字段，它保證了可以獨占訪問 inode 的其他字段（如文件長度）以及 inode 的文件或目錄內容塊的</li><li>一個 inode 的 ref 如果大於 0，則會使系統將該 inode 保留在緩存 中，而不會重用該 inode</li><li>每個 inode 都包含一個 nlink 字段(在磁盤上，緩存時會復 製到內存中)，該字段統計鏈接該 inode 的目錄項的數量；如果一個 inode 的鏈接數大於零， xv6 不會釋放它</li></ul></li></ul></li></ul></li></ul></li><li><p>目錄層(fs.c)將實現了一種特殊的 inode，被稱為目錄，其包含一個目錄項序列，每個目錄項由文件名稱和 i-number 組成</p><ul><li>函數 dirlookup 在一個目錄中搜索一個帶有給定名稱的條目</li><li>函數 dirlink 會在當前目錄 dp 中創建一個新的目錄項</li><li>查找路徑名會對每一個節點調用一次 dirlookup</li><li>Namex首先確定路徑解析從哪裡開始<ul><li>如果路徑以斜線開頭，則從根目錄開始解析</li><li>否則，從當前目錄開始解析。</li></ul></li><li>然後它使用 skipelem 來遍歷路徑中的每個元素</li></ul></li><li><p>file(file.c)</p><ul><li>系統中所有打開的文件都保存在一個全局文件表中，即 ftable<ul><li>文件表的功能有:<ul><li>分配文件(filealloc)</li><li>創建重複引用(fileup)</li><li>釋放引用(fileclose)</li><li>讀寫數據(fileeread和filewrite)。</li></ul></li></ul></li></ul></li></ul><p><img loading=lazy src=https://i.imgur.com/nok1IuY.png alt></p><p>superblock，
它包含了文件系統的元數據（以塊為單位的文件系統大小、數據塊的數量、inode 的數量和日誌中的塊數）</p><p>位圖塊(bitmap)，記錄哪些數據塊在使用</p><h3 id=balloc與kalloc與malloc的差別>balloc與kalloc與malloc的差別<a hidden class=anchor aria-hidden=true href=#balloc與kalloc與malloc的差別>#</a></h3><p>kalloc: 直接丟一個page
malloc: 從現有的mem拉一段va出來，如果沒空間了就sbrk加大
* sbrk: growproc -> uvmalloc -> kalloc -> mappages
* mappages: 把從kalloc拿到的page與加到pagetable
balloc: 與kalloc很像，就是直接丟一個block出來
* 但要處理log!!
* 去trace誰是空的
* mem用list(或AVL)
* disk用bitmap</p><h3 id=trace-how-to-readwrite-a-file>trace: how to read/write a file<a hidden class=anchor aria-hidden=true href=#trace-how-to-readwrite-a-file>#</a></h3><ul><li>fileread<ul><li>readi<ul><li>bread拿buf，bmap算偏移(在hdd上的addr)</li><li>copyout</li></ul></li></ul></li><li>filewrite<ul><li>begin_op<ul><li>writei<ul><li>bread拿buf，bmap算偏移(在hdd上的addr)</li><li>copyin</li><li>log_write<ul><li>記錄到log</li></ul></li></ul></li></ul></li><li>end_op<ul><li>commit<ul><li>write_log<ul><li>寫buf到disk</li></ul></li><li>write_head<ul><li>commit log</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id=lab-file-system>Lab File system<a hidden class=anchor aria-hidden=true href=#lab-file-system>#</a></h3><h4 id=big-file>big file<a hidden class=anchor aria-hidden=true href=#big-file>#</a></h4><p>就是在block再放一個table，之後再多做一次</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=n>uint</span>
</span></span><span class=line><span class=cl><span class=nf>bmap</span><span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>ip</span><span class=p>,</span> <span class=n>uint</span> <span class=n>bn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>addr</span><span class=p>,</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>bp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>bn</span> <span class=o>&lt;</span> <span class=n>NDIRECT</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>addr</span> <span class=o>=</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>bn</span><span class=p>])</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>bn</span><span class=p>]</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>=</span> <span class=nf>balloc</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>bn</span> <span class=o>-=</span> <span class=n>NDIRECT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>bn</span> <span class=o>&lt;</span> <span class=n>BLOCKS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Load indirect block, allocating if necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>((</span><span class=n>addr</span> <span class=o>=</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=p>])</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=p>]</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>=</span> <span class=nf>balloc</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=err>@@</span> <span class=o>-</span><span class=mi>400</span><span class=p>,</span><span class=mi>6</span> <span class=o>+</span><span class=mi>401</span><span class=p>,</span><span class=mi>30</span> <span class=err>@@</span> <span class=nf>bmap</span><span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>ip</span><span class=p>,</span> <span class=n>uint</span> <span class=n>bn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>brelse</span><span class=p>(</span><span class=n>bp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>bn</span> <span class=o>-=</span> <span class=n>BLOCKS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>bn</span> <span class=o>&lt;</span> <span class=n>NINDIRECT</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// double indirect
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>bn</span><span class=o>/</span><span class=n>BLOCKS</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>bn</span><span class=o>%</span><span class=n>BLOCKS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>addr</span> <span class=o>=</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>=</span> <span class=nf>balloc</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>bp</span> <span class=o>=</span> <span class=nf>bread</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=o>*</span><span class=p>)</span><span class=n>bp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>addr</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>=</span> <span class=nf>balloc</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>log_write</span><span class=p>(</span><span class=n>bp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>brelse</span><span class=p>(</span><span class=n>bp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// query addr from int[]&#39;s data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>bp</span> <span class=o>=</span> <span class=nf>bread</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=o>*</span><span class=p>)</span><span class=n>bp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>addr</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>=</span> <span class=nf>balloc</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>log_write</span><span class=p>(</span><span class=n>bp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>brelse</span><span class=p>(</span><span class=n>bp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;bmap: out of range&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>itrunc</span><span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>ip</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>bp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NDIRECT</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>i</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>      <span class=nf>bfree</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>    <span class=n>bp</span> <span class=o>=</span> <span class=nf>bread</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=o>*</span><span class=p>)</span><span class=n>bp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>BLOCKS</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nf>bfree</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>brelse</span><span class=p>(</span><span class=n>bp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>bfree</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>bp2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=o>+</span><span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>    <span class=n>bp</span> <span class=o>=</span> <span class=nf>bread</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=o>+</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=o>*</span><span class=p>)(</span><span class=n>bp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span> <span class=c1>// int[]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>BLOCKS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>bp2</span> <span class=o>=</span> <span class=nf>bread</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=o>*</span><span class=p>)(</span><span class=n>bp2</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>BLOCKS</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span><span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=nf>bfree</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>b</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>brelse</span><span class=p>(</span><span class=n>bp2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>bfree</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>brelse</span><span class=p>(</span><span class=n>bp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>bfree</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=o>+</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>ip</span><span class=o>-&gt;</span><span class=n>addrs</span><span class=p>[</span><span class=n>NDIRECT</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ip</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>iupdate</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=symbol-link>symbol link<a hidden class=anchor aria-hidden=true href=#symbol-link>#</a></h4><p>一個有path的檔案</p><p>syscall要先生出檔案，把path寫進去</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_symlink</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>target</span><span class=p>[</span><span class=n>MAXPATH</span><span class=p>],</span> <span class=n>path</span><span class=p>[</span><span class=n>MAXPATH</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>ip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>n</span> <span class=o>=</span> <span class=nf>argstr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>MAXPATH</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nf>argstr</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>MAXPATH</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>begin_op</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>ip</span> <span class=o>=</span> <span class=nf>create</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>T_SYMLINK</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>off</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>r</span> <span class=o>==</span> <span class=n>n1</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>r</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>n1</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>r</span> <span class=o>=</span> <span class=nf>writei</span><span class=p>(</span><span class=n>ip</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>target</span> <span class=o>+</span> <span class=n>i</span><span class=p>,</span> <span class=n>off</span><span class=p>,</span> <span class=n>n1</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>off</span> <span class=o>+=</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>ip</span><span class=o>-&gt;</span><span class=n>nlink</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>iunlockput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>end_op</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>open要能處理symbol link，與原本的檔案
如果遇到其他symbol link還要繼續follow</p><p>抄原本的open，加symbol link的處理，最後遞迴</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>real_open</span><span class=p>(</span><span class=kt>char</span> <span class=n>path</span><span class=p>[</span><span class=n>MAXPATH</span><span class=p>],</span> <span class=kt>int</span> <span class=n>omode</span><span class=p>,</span> <span class=kt>int</span> <span class=n>follow</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>ip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>omode</span> <span class=o>&amp;</span> <span class=n>O_CREATE</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>ip</span> <span class=o>=</span> <span class=nf>create</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>T_FILE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>ip</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>ip</span> <span class=o>=</span> <span class=nf>namei</span><span class=p>(</span><span class=n>path</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>ilock</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>T_DIR</span> <span class=o>&amp;&amp;</span> <span class=n>omode</span> <span class=o>!=</span> <span class=n>O_RDONLY</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=nf>iunlockput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>T_DEVICE</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>major</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>major</span> <span class=o>&gt;=</span> <span class=n>NDEV</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>    <span class=nf>iunlockput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>T_SYMLINK</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>omode</span> <span class=o>&amp;</span> <span class=n>O_NOFOLLOW</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>char</span> <span class=n>target</span><span class=p>[</span><span class=n>MAXPATH</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>follow</span> <span class=o>&gt;</span> <span class=n>FOLLOW_DEPS</span> <span class=o>||</span> <span class=nf>readi</span><span class=p>(</span><span class=n>ip</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>target</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>MAXPATH</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>iunlockput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nf>iunlock</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>real_open</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>omode</span><span class=p>,</span> <span class=n>follow</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>f</span> <span class=o>=</span> <span class=nf>filealloc</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=p>(</span><span class=n>fd</span> <span class=o>=</span> <span class=nf>fdalloc</span><span class=p>(</span><span class=n>f</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>fileclose</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>iunlockput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>T_DEVICE</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>FD_DEVICE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>-&gt;</span><span class=n>major</span> <span class=o>=</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>major</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>FD_INODE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>-&gt;</span><span class=n>off</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=o>-&gt;</span><span class=n>ip</span> <span class=o>=</span> <span class=n>ip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=o>-&gt;</span><span class=n>readable</span> <span class=o>=</span> <span class=o>!</span><span class=p>(</span><span class=n>omode</span> <span class=o>&amp;</span> <span class=n>O_WRONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=o>-&gt;</span><span class=n>writable</span> <span class=o>=</span> <span class=p>(</span><span class=n>omode</span> <span class=o>&amp;</span> <span class=n>O_WRONLY</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>omode</span> <span class=o>&amp;</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>omode</span> <span class=o>&amp;</span> <span class=n>O_TRUNC</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>ip</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>T_FILE</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>itrunc</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>iunlock</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_open</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>path</span><span class=p>[</span><span class=n>MAXPATH</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>omode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>n</span> <span class=o>=</span> <span class=nf>argstr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>MAXPATH</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nf>argint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>omode</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>begin_op</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>real_open</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>omode</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>end_op</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p>可以在google找到很多其他人的做法，都值得參考</p><p><a href=https://www.zhihu.com/column/c_1294282919087964160>MIT6.S081 操作系统工程中文翻译</a>
<a href=https://github.com/pleasewhy/xv6-book-2020-Chinese>xv6-book-2020-Chinese</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/system/>System</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2022/01/%E5%A5%94%E8%B7%91%E5%90%A7linux%E5%85%A7%E6%A0%B8ch2~ch5%E6%91%98%E9%8C%84/><span class=title>« Prev</span><br><span>奔跑吧linux內核ch2~ch5摘錄</span>
</a><a class=next href=https://littlebees.github.io/2022/01/%E9%9B%BB%E8%85%A6%E5%BE%9E0%E9%96%8B%E5%A7%8B/><span class=title>Next »</span><br><span>電腦從0開始</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>