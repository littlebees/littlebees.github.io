<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-146 - LRU Cache | 記事本</title>
<meta name=keywords content="Doubly-Linked List,Design,Linked List,Hash Table,Top Interview Questions,Top 100 Liked Questions,CTCI-COMPLETE-LIST"><meta name=description content="動機
兩題很像，所以就一起寫"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2020/12/leetcode-146-lru-cache/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2020/12/leetcode-146-lru-cache/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-146 - LRU Cache"><meta property="og:description" content="動機
兩題很像，所以就一起寫"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2020/12/leetcode-146-lru-cache/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-28T01:48:56+00:00"><meta property="article:modified_time" content="2020-12-28T01:48:56+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-146 - LRU Cache"><meta name=twitter:description content="動機
兩題很像，所以就一起寫"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-146 - LRU Cache","item":"https://littlebees.github.io/2020/12/leetcode-146-lru-cache/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-146 - LRU Cache","name":"leetcode-146 - LRU Cache","description":"動機 兩題很像，所以就一起寫\n","keywords":["Doubly-Linked List","Design","Linked List","Hash Table","Top Interview Questions","Top 100 Liked Questions","CTCI-COMPLETE-LIST"],"articleBody":"動機 兩題很像，所以就一起寫\nProblem Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.int get(int key) Return the value of the key if the key exists, otherwise return -1.void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.The functions get and put must each run in O(1) average time complexity.\nExample 1:\nInput[LRUCache, put, put, get, put, get, put, get, get, get][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]Output[null, null, null, 1, null, -1, null, -1, 3, 4]ExplanationLRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // cache is {1=1}lRUCache.put(2, 2); // cache is {1=1, 2=2}lRUCache.get(1); // return 1lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}lRUCache.get(2); // returns -1 (not found)lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}lRUCache.get(1); // return -1 (not found)lRUCache.get(3); // return 3lRUCache.get(4); // return 4 Constraints:\n1 \u003c= capacity \u003c= 30000 \u003c= key \u003c= 1040 \u003c= value \u003c= 105At most 2 * 105 calls will be made to get and put. 146: LRU Cache 為了讓get是O(1)，需要hash\n為了符合LRU，就用Linked List，把最近使用的放到最上面，最下面的就是要被驅逐的key\n這裡是用c++寫，因為python的Linked List，要自幹 雖然說可以用deque模擬，但是沒辦法把node移到頂端，沒辦法操作reference，所以就改用C++的list來做了\nclass LRUCache { private: list\u003cint\u003e l; int c; ordered_map\u003cint, pair\u003clist\u003cint\u003e::iterator, int\u003e\u003e m; public: pair\u003clist\u003cint\u003e::iterator, int\u003e\u0026 moveToTop(int key) { auto\u0026 tmp = m[key]; l.erase(std::get\u003c0\u003e(tmp)); l.push_front(key); auto\u0026\u0026 ret = make_pair(l.begin(), std::get\u003c1\u003e(tmp)); m[key] = ret; return m[key]; } LRUCache(int capacity): c(capacity) { } int get(int key) { auto tmp = m.find(key); if(tmp != m.end()) { auto\u0026 tmp = moveToTop(key); return std::get\u003c1\u003e(tmp); } else { return -1; } } void put(int key, int value) { auto exist = m.find(key); if (exist != m.end()) { auto\u0026 tmp = moveToTop(key); m[key] = std::move(make_pair(std::get\u003c0\u003e(tmp), value)); } else { if(l.size() \u003e= c) { int evict = l.back(); m.erase(evict); l.pop_back(); } l.push_front(key); m[key] = std::move(make_pair(l.begin(),value)); } } }; ","wordCount":"336","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2020-12-28T01:48:56Z","dateModified":"2020-12-28T01:48:56Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2020/12/leetcode-146-lru-cache/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-146 - LRU Cache</h1><div class=post-meta><span title='2020-12-28 01:48:56 +0000 UTC'>December 28, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#146-lru-cache aria-label="146: LRU Cache">146: LRU Cache</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>兩題很像，所以就一起寫</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>Design a data structure that follows the constraints of a <strong><a href=https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU target=_blank>Least Recently Used (LRU) cache</a></strong>.</p><p>Implement the <code>LRUCache</code> class:</p><ul><li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li><li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li><li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li></ul><p>The functions <code data-stringify-type=code>get</code> and <code data-stringify-type=code>put</code> must each run in <code>O(1)</code> average time complexity.</p><p> </p><p><strong>Example 1:</strong></p><pre><strong>Input</strong>[LRUCache, put, put, get, put, get, put, get, get, get][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<strong>Output</strong>[null, null, null, 1, null, -1, null, -1, 3, 4]<strong>Explanation</strong>LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // cache is {1=1}lRUCache.put(2, 2); // cache is {1=1, 2=2}lRUCache.get(1);    // return 1lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}lRUCache.get(2);    // returns -1 (not found)lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}lRUCache.get(1);    // return -1 (not found)lRUCache.get(3);    // return 3lRUCache.get(4);    // return 4</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= capacity <= 3000</code></li><li><code>0 <= key <= 10<sup>4</sup></code></li><li><code>0 <= value <= 10<sup>5</sup></code></li><li>At most 2<code> * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.</li></ul><h2 id=146-lru-cache>146: LRU Cache<a hidden class=anchor aria-hidden=true href=#146-lru-cache>#</a></h2><p>為了讓get是O(1)，需要hash</p><p>為了符合LRU，就用Linked List，把最近使用的放到最上面，最下面的就是要被驅逐的key</p><p>這裡是用c++寫，因為python的Linked List，要自幹
雖然說可以用deque模擬，但是沒辦法把node移到頂端，沒辦法操作reference，所以就改用C++的list來做了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>LRUCache</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>pair</span><span class=o>&lt;</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>pair</span><span class=o>&lt;</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>moveToTop</span><span class=p>(</span><span class=kt>int</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span><span class=o>&amp;</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>m</span><span class=p>[</span><span class=n>key</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tmp</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>make_pair</span><span class=p>(</span><span class=n>l</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tmp</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m</span><span class=p>[</span><span class=n>key</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>LRUCache</span><span class=p>(</span><span class=kt>int</span> <span class=n>capacity</span><span class=p>)</span><span class=o>:</span> <span class=n>c</span><span class=p>(</span><span class=n>capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>get</span><span class=p>(</span><span class=kt>int</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>tmp</span> <span class=o>!=</span> <span class=n>m</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span><span class=o>&amp;</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>moveToTop</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>put</span><span class=p>(</span><span class=kt>int</span> <span class=n>key</span><span class=p>,</span> <span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>exist</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>exist</span> <span class=o>!=</span> <span class=n>m</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span><span class=o>&amp;</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>moveToTop</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>m</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>make_pair</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tmp</span><span class=p>),</span> <span class=n>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>l</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>evict</span> <span class=o>=</span> <span class=n>l</span><span class=p>.</span><span class=n>back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>m</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>evict</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>l</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>m</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>make_pair</span><span class=p>(</span><span class=n>l</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span><span class=n>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/doubly-linked-list/>Doubly-Linked List</a></li><li><a href=https://littlebees.github.io/tags/design/>Design</a></li><li><a href=https://littlebees.github.io/tags/linked-list/>Linked List</a></li><li><a href=https://littlebees.github.io/tags/hash-table/>Hash Table</a></li><li><a href=https://littlebees.github.io/tags/top-interview-questions/>Top Interview Questions</a></li><li><a href=https://littlebees.github.io/tags/top-100-liked-questions/>Top 100 Liked Questions</a></li><li><a href=https://littlebees.github.io/tags/ctci-complete-list/>CTCI-COMPLETE-LIST</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2020/12/leetcode-122-best-time-to-buy-and-sell-stock-ii/><span class=title>« Prev</span><br><span>leetcode-122 - Best Time to Buy and Sell Stock II</span>
</a><a class=next href=https://littlebees.github.io/2020/12/leetcode-460-lfu-cache/><span class=title>Next »</span><br><span>leetcode-460 - LFU Cache</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>