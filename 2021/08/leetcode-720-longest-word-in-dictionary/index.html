<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-720 - Longest Word in Dictionary | 記事本</title>
<meta name=keywords content="Sorting,Trie,String,Hash Table,Array,seanprashad"><meta name=description content="動機
類似word break去硬幹"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/08/leetcode-720-longest-word-in-dictionary/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-720 - Longest Word in Dictionary"><meta property="og:description" content="動機
類似word break去硬幹"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/08/leetcode-720-longest-word-in-dictionary/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-01T23:14:39+00:00"><meta property="article:modified_time" content="2021-08-01T23:14:39+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-720 - Longest Word in Dictionary"><meta name=twitter:description content="動機
類似word break去硬幹"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-720 - Longest Word in Dictionary","item":"https://littlebees.github.io/2021/08/leetcode-720-longest-word-in-dictionary/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-720 - Longest Word in Dictionary","name":"leetcode-720 - Longest Word in Dictionary","description":"動機 類似word break去硬幹\n","keywords":["Sorting","Trie","String","Hash Table","Array","seanprashad"],"articleBody":"動機 類似word break去硬幹\nProblem Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.\nIf there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\nExample 1:\nInput: words = [w,wo,wor,worl,world]Output: worldExplanation: The word world can be built one character at a time by w, wo, wor, and worl.Example 2:\nInput: words = [a,banana,app,appl,ap,apply,apple]Output: appleExplanation: Both apply and apple can be built from other words in the dictionary. However, apple is lexicographically smaller than apply. Constraints:\n1 \u003c= words.length \u003c= 10001 \u003c= words[i].length \u003c= 30words[i] consists of lowercase English letters. Sol 不過如果要用bisect在string上就只能sort而已，不能調其他東西\nclass Solution: def longestWord(self, words: List[str]) -\u003e str: words.sort() ret = \"\" for s in reversed(words): good = True for j in range(len(s)-1): k = bisect_left(words,s[:j+1]) if k \u003e= len(words) or 0 \u003e k or words[k] != s[:j+1]: #print(\"fail for\", words[k] if 0\u003c= k \u003c len(words) else None ,s[:j+1]) good = False break ret = s if good and len(s) \u003e= len(ret) else ret return ret ","wordCount":"193","inLanguage":"en","datePublished":"2021-08-01T23:14:39Z","dateModified":"2021-08-01T23:14:39Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/08/leetcode-720-longest-word-in-dictionary/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-720 - Longest Word in Dictionary</h1><div class=post-meta><span title='2021-08-01 23:14:39 +0000 UTC'>August 1, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>類似word break去硬幹</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>Given an array of strings <code>words</code> representing an English Dictionary, return <em>the longest word in</em> <code>words</code> <em>that can be built one character at a time by other words in</em> <code>words</code>.</p><p>If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.</p><p> </p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> words = [w,wo,wor,worl,world]<strong>Output:</strong> world<strong>Explanation:</strong> The word world can be built one character at a time by w, wo, wor, and worl.</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> words = [a,banana,app,appl,ap,apply,apple]<strong>Output:</strong> apple<strong>Explanation:</strong> Both apply and apple can be built from other words in the dictionary. However, apple is lexicographically smaller than apply.</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= words.length <= 1000</code></li><li><code>1 <= words[i].length <= 30</code></li><li><code>words[i]</code> consists of lowercase English letters.</li></ul><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><p>不過如果要用bisect在string上就只能sort而已，不能調其他東西</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>longestWord</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>words</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>words</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>reversed</span><span class=p>(</span><span class=n>words</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>good</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>k</span> <span class=o>=</span> <span class=n>bisect_left</span><span class=p>(</span><span class=n>words</span><span class=p>,</span><span class=n>s</span><span class=p>[:</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>k</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=n>words</span><span class=p>)</span> <span class=ow>or</span> <span class=mi>0</span> <span class=o>&gt;</span> <span class=n>k</span> <span class=ow>or</span> <span class=n>words</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>!=</span> <span class=n>s</span><span class=p>[:</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=c1>#print(&#34;fail for&#34;, words[k] if 0&lt;= k &lt; len(words) else None ,s[:j+1])</span>
</span></span><span class=line><span class=cl>                    <span class=n>good</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=n>s</span> <span class=k>if</span> <span class=n>good</span> <span class=ow>and</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=k>else</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/sorting/>Sorting</a></li><li><a href=https://littlebees.github.io/tags/trie/>Trie</a></li><li><a href=https://littlebees.github.io/tags/string/>String</a></li><li><a href=https://littlebees.github.io/tags/hash-table/>Hash Table</a></li><li><a href=https://littlebees.github.io/tags/array/>Array</a></li><li><a href=https://littlebees.github.io/tags/seanprashad/>seanprashad</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/08/leetcode-421-maximum-xor-of-two-numbers-in-an-array/><span class=title>« Prev</span><br><span>leetcode-421 - Maximum XOR of Two Numbers in an Array</span>
</a><a class=next href=https://littlebees.github.io/2021/08/leetcode-117-populating-next-right-pointers-in-each-node-ii/><span class=title>Next »</span><br><span>leetcode-117 - Populating Next Right Pointers in Each Node II</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>