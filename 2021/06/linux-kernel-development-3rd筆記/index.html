<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux Kernel Development 3rd筆記 | 記事本</title>
<meta name=keywords content="Linux"><meta name=description content="動機
不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分
畢竟這是基於linux2.6的"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/06/linux-kernel-development-3rd%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/06/linux-kernel-development-3rd%E7%AD%86%E8%A8%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Linux Kernel Development 3rd筆記"><meta property="og:description" content="動機
不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分
畢竟這是基於linux2.6的"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/06/linux-kernel-development-3rd%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-26T03:31:56+00:00"><meta property="article:modified_time" content="2021-06-26T03:31:56+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="Linux Kernel Development 3rd筆記"><meta name=twitter:description content="動機
不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分
畢竟這是基於linux2.6的"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Linux Kernel Development 3rd筆記","item":"https://littlebees.github.io/2021/06/linux-kernel-development-3rd%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux Kernel Development 3rd筆記","name":"Linux Kernel Development 3rd筆記","description":"動機 不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分 畢竟這是基於linux2.6的\n","keywords":["Linux"],"articleBody":"動機 不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分 畢竟這是基於linux2.6的\n整體心得 讀完上一本工作原理來讀這本剛好，可以互補\n推薦讀 中斷: ch7~10 mem: ch12\u0026ch15\n省略掉 ch1, 14, 20\n簡體版的翻譯錯誤有點多要小心，覺得怪就去看原文\nch1 skip\nch2 folder folder descrition arch x86, amd64之類的 block block device 的 IO層 crypto 加密API Documentation 文件 drivers device driver firmware driver需要的fw fs file system include kernel的header file init kernel引導與初始化 ipc 跨proc溝通 kernel 核心的kernel code(sched之類的) lib 通用kernel function mm 記憶體管理與virtual memory net 網路 samples 範例 scripts compile kernel用的腳本 security 安全模組 sound 聲音 usr userspace的code tools linux的開發工具 virt 虛擬化 make make menuconfig 調linux的設定 make defconfig 把menuconfig的設定設成預設 make oldconfig load從其他地方來的.config make compile 在kernel code的根目錄會產生System.map，裡面有symbol，需要可以看 kernel dev的特點 沒有libc與stdlib linux有自己的工具，可以看include裡面的header，像/inlucde/linux就是linux kernel的函數 用gnu c inline asmembly 內嵌 likely, unlikely之類的if優化 沒有mem保護 沒有seg fault，只剩panic 幾乎不能用floating point kernel stack十分小，並隨arch不同而有改變 同步很重要 preempt smp(多對稱處理器，多cpu) ch3 proc\n相關struct struct task_struct 在 proc的DS，有 pid addr space 打開的文件 等… struct thraed_info 在 放在kernel stack上，用以找到task_struct 為什麼不直接放task_struct 放proc中與arch有關的訊息 可以想成goroutines的struct P proc state 正在跑、可以跑 TASK_RUNNING 睡 TASK_INTERRUPTABLE 等interrupt或其他或signal TASK_UNINTERRUPTABLE 不管signal，其他與TASK_INTERRUPTABLE一樣 clone syscall fork clone(SIGCHID, 0) kthread clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0) VM: virtual mem FS: file system FILES: opend files SIGHAND: signal handler vfork (會sync執行的fork) clone(CLONE_VFORK | CLONE_VM | SIGCHID, 0) ch4 proc scheduler\nproc吃? IO scheduler應該要多拉吃IO的proc 不然response time會變慢 但throughput會低 cpu scheduler應該多拉吃cpu的proc 不然throughput會變慢 但response time會變慢 time slice 一個proc能佔cpu多少時間 太長 對吃cpu有利 對吃IO不利 高throughput 差response time cxt switch的總計花費時間小 太短 對吃cpu不利 對吃IO有利 低throughput 好response time cxt switch的總計花費時間多 proc優先級 nice -20~19 越小越優先 real-time priority 0~99 越大越優先 RT proc永遠優先於普通proc 兩個是各自獨立的系統 公平調度(CFS) 概念 依據cpu的使用比例分配 分配到的時間與系統負載密切相關 搶的時機是如果有proc花的使用比比當前proc少，就換上去 每個proc預設拿到1/n個cpu時間 n是proc個數 就是想像一共有proc個數 個cpu cpu時間在書中叫目標延遲 nice就是原本的1/n再乘上nice換出來的比值 實作 計時 在 struct_sched_entity vruntime 會記錄運行時間 以及以proc總數做標準化 choose proc 挑vruntime最小的 sched的interface schedule() 如果要睡覺 就是設定proc state再call這個 假喚醒 如果state是TASK_INTERRUPTABLE就會被signal叫醒 所以要檢查喚醒後發生什麼事 cxt switch 在 switch_mm換virtual mem 在 switch_to換cpu state preempt 用一個flag，need_resched去看該不該被搶 誰可以設? scheduler proc自己 preempt發生時機 user preempt 從syscall回到userspace 從中斷處理程序回到userspace kernel preempt 中斷處理程序結束，且回到kernel space之前 kernel的code再一次可以被搶的時候 need_resched被設 preempt_count是0 (在thread_info) kernel的code被block時 kernel的code調用schedule() RT schedule SCHED_FIFO proc一直跑，除非 block 自己想換 SCHED_RR 有time slice的SCHED_FIFO 低優先無法搶高優先即使對方的time slice花完了 都是soft rt ch5 syscall在上一篇筆記就說了，所以這裡focus在一些之前沒提到的東西\nasmlinkage 叫compiler只能從stack拿參數 參數驗證 ptr的addr是userspace的addr ptr的addr在proc的addr space中 讀寫要符合原本的讀寫限制 參數有效 pid有效 檔案有效 process context syscall是在process cxt 會睡覺 會被搶 在你想多加一個syscall(衝動)之前，可以 用dev file實現read, write，配合ioctl 創其他操作介面，像semaphore可以像file一樣操作 sysfs ch6 list_elment 在 Linked List (bidiretion) 用法是在自己的struct中放一個list_elment 因為c沒泛型!! c應該叫mem描述語言才對 沒有特別需求時優先用list kfifo 在 Queue 遇到 consumer/producer時用 idr 在 Hash table uid(int) -\u003e void * 要mapping時就用 rbtree 在 紅黑樹 沒有find與insert，要自己寫 因為c沒泛型!! 大量data與反覆search就用 ch7 中斷(IRQ) 就是一個數字 異常與中斷很像 但異常要與cpu時鐘同步 中斷上下文 不會block(睡覺) 當他出現時，一定是 打斷了某個proc 甚至是，不同irq stack的irq 上半段 與 下半段 上半段: 馬上處理 下半段: 原本中斷中可以之後再處理的 request_irq 註冊irq 會sleep reenter? irq被call時，該irq會被mask起來，其他cpu看不到 IRQF_SHARED 多個dev用同一個irq 所以 dev的addr唯一，也就是可以區分不同device code有辦法對應不同device /procs/interrupts PC上所有irq的資訊 中斷控制器 停用 cpu上的整個中斷 這樣這個cpu上就不會被preempt 但其他cpu還是可以中斷!! 所有cpu的某個中斷 看與 ch8 中斷，下半段\nsoftirq 同一個softirq可以同時跑在其他cpu上 靜態註冊 (compile-time) 在 struct softirq_action softirq放在array中(32個) 中斷上下文 softirq沒辦法搶其他的softirq softirq只會被irq搶!! 跑什麼softirq irq handler在return前會標 什麼時候跑softirq? irq handler在return時 在softirqd中 有人去看還有哪些softirq還沒跑與直接執行softirq的時候 tasklet 同一個tasklet不可以同時跑在其他cpu上 動態註冊 在 struct tasklet_struct 有執行狀態 所以其他cpu不會跑正在跑的tasklet tasklet放在cpu上的linked list tasklet_vec tasklet_hi_vec (hi是high) 所以可以動態加 中斷上下文 tasklet就是掛在兩個softirq上 把task往裡面放，需要時就跑 ksoftirqd 每個cpu上會有一個 處理大量softirq 在最低nice的kthread中去調用還沒跑的softirq work queue proc上下文 可以allocate大mem semaphore 用block IO 每個cpu一個queue與kthread，跑task 我們需要一個可以看到所有cpu的struct 在 struct workqueue_struct 放workqueue訊息 proc叫event/n 在 struct cpu_workqueue_struct 就是queue 在 struct work_struct 就是task 每個cpu上會有一個 n是cpu編號 how to lock proc cxt與bottom half分享data 鎖bottom half 拿鎖 irq cxt與bottom half分享data 鎖irq 拿鎖 irq -\u003e softirq/tasklet -\u003e proc 如果要和上一層share data 鎖上一層!! 防smp與preempt 拿鎖 可以看Unreliable Guide To Locking有詳細的解釋 ch9\u002610 怎麼等鎖 busy waiting 都能用 sleep only in proc ctx 要同步的原因是 in userspace preempt re schedule in kernel space irq softirq/tasklet preempt sleep \u0026 sync with userspace smp struct什麼時候加鎖 kernel struct大部分都要 有其他proc可以access 任何人都看的到的 原子性與順序性 原子性 執行期間不打斷，只有兩個case 沒有跑 跑完了 順序性 ABC分散在不同中，也要ABC去跑 用lock只能保證，ABC一起跑，一起不跑 用semaphore可以幹出來 主要用barrier 讀寫鎖(RW) 只能有下面的其中一種case 1寫 多讀 有利於讀 只要一堆讀，寫就只要等就飽了 工具 atomic_t spinlock busy waiting 使用時不能sleep 不然就是增加整體的response time 如果lock時間小於2次ctx switch才有利 no recur 不能鎖了又鎖 在irq中用的話 先關irq 不然被中斷，另一irq又拿同一個鎖的話… 有RW版 禁止preempt 持有spinlock就是禁止preempt semaphore sleep only in proc ctx 任何持有人都可以上鎖或解鎖!! 可以超過一個人到critical zone 有RW版 mutex sleep only in proc ctx 上鎖的人才能解鎖 只有一個人能到critical zone 可以recur 可以處理priority inversion complete variable cond var seq lock 實作 有一個acc 當write拿鎖時，會acc++ read時就是確認開始與結束的acc值是不是一樣 確認中間沒有write 也可以透過acc是不是偶數看寫結束語否 有利於寫 mem barrier barrier前面的code跑完前，絕對不會跑後面去 起因於 指令重排，所以有些指令會跑到後面去 前半部的code不會到reorder到後面去 priority inversion 一般來說是在RT才會提，但想到就記一下 情境 pri最小(A)拿到lock中被中斷 pri高的(C)想拿lock，但拿不到!! 像spinlock會busy waiting pri高的跑不動，time slice吃完 有下一個pri比較低的(B)，來了，也做完了!? 但pri高的還沒做完阿!! 起因 lock的效果會影響優先權，但是沒有納入原有優先權的系統中 像只要有人拿了spiclock，那他在這一塊就是最優先的 不管其他優先權怎麼設，bust waiting就是wait，沒有轉圜的機會 同時也無法打斷，不然就不是crtical zone了 解法 大方向: crtical zone要先跑!! 要改crtical zone的優先權 改到與現在最高的一樣高 改到沒有人比crtical zone高 Priority inheritance 在crtical zone時，遇到更高的proc同時要進來 把crtical zone的優先權拉到與那個proc一樣高 跑完crtical zone就降回去 Priority ceiling protocol 在crtical zone時拉到最高 跑完crtical zone就降回去 ch11 怎麼算1秒 系統計時器會依一定頻率(tick rate)打中斷 這樣kernel知道兩次中斷之間的間隔時間(tick) HZ就是1sec打幾次 HZ可以改!! HZ越高 時間精準度越高 連帶與時間有關的都會變準 poll, select preempt system load上升 這是kernel用的 userspace的叫USER_HZ 1sec = tick * HZ 開機多久了 jiffies 紀錄系統計時器中斷打了幾次 jiffies/HZ =\u003e 開機多久 硬體 RTC bios上存時間(幾點幾分之類的)的 就算電腦關機，還是藉由CMOS繼續跑 開機時初始化xtime變數 系統計時器 由kernel設定tick rate 關於proc的計時 每一次中斷時就把當前proc狀態(idle, run…)的變數遞增一次 如果在這中斷之間多次換狀態? 不管，現在他在這個狀態，這一段時間都是這個狀態的 如何delay delay執行，不應該在有lock時或是關閉中斷後發生\nbusy wait base on jiffies short delay 如果要的delay比tick小 用udelay(),ndelay(),mdelay() 裡面其實也是loop，但是kernel知道他會跑多久且不用jiffies schedule_timeout() 讓task睡，在超過指定時間後跑 沒辦法說很精確在時間到就馬上跑 soft rt ch12 kernel space的mem\n整體 phy mem byte word cpu page kernel struct zone 在 struct page 在 對應到實體的page 再從page換成addr alloc_pages -\u003e page_address kmalloc 不能要求ZONE_HIGHEM 因為可能還沒分配邏輯addr 用alloc_pages 上面都是 連續的page 可以sleep時用GFP_KERNEL 不可以sleep時用GFP_ATOMIC vmalloc 可能不連續的page 不同page在不同位置，所以有不同區 4種 ZONE_DMA ZONE_DMA32 only for 32bits device ZONE_NORMAL ZONE_HIGHEM high mem用，不能用永久map到kernel addr空間 想想kernel都是用低的mem，所以高的其實算是userspace的 如果要用就要map 永久: kmap (low與high都能用，會睡覺) 臨時: kmap_atomic (不會睡，但是會被下一個) slab 在快取記憶體上(kmem_cache)開一個list當成object pool 之後重複利用裡面已經存在的obj slab就是list上的node，node裡面放obj struct slab 在 額外 stack 每個proc有 kernel stack 1~2 page (根據arch) 原本中斷也是用被中斷的proc的stack kernel stack本來就很小，還是別吧 最後有了interrupt stack user stack 就一般的stack kernel stack是為了與user stack分開 想想兩個混在一起會發生什麼事 每個cpu有 interrupt stack percpu 每個cpu自己的data 因為是cpu自己的，所以 cache失效降低 不用擔心smp preempt還是要怕 ch15 user space的mem\n整體 proc的userspace的mem空間 struct mm_struct 在 可以到/proc//maps看proc現在有什麼 主要兩個 struct vm_area_struct 在 就是這裡的page，加上權限與狀態之類的 在mm_struct有兩個obj放vm_area_struct list: 方便iterate rbtree: 方便找定點 pgd_t phy的page表 三層 (pgd -\u003e pmd -\u003e pte) 用這個換出實際addr 額外 kthread的mm kthread天生沒有mm (不然怎麼有k) 當需要的時候會從proc的ptr拿到 當schedule會存前一個proc的mm (active_mm) 當kthread需要(像page table)，就直接用active_mm看 mmap 把file放到proc的userspace的mem空間 生一個addr出來 ch13 virtual file system的流程 userspace virtual file system 真的file system phy VFS的attribute superblock 真的file system (ext4, brtfs…) struct file_system_type 在 放fs的訊息(kernel關心的) struct vfsmount 在 fs的統計數據與安裝訊息(root, dev等等)與安裝點 可以當成實際fs的入口 放fs的訊息(VFS關心的) struct super_block 在 inode file or folder 放file/folder的訊息 struct inode 在 dentry path的一部份 /usr/bin/vi的 /, usr, bin, vi 其實可以當成inode，但是為了查找path，所以獨立出來 struct dentry 在 state 被用 有對應的file 也正在被ref 還沒被用 有對應的file 沒被ref 不在 根本沒這個file 總不能每次要等整個找完才丟沒有指定的檔案吧 同時，因為有這個與slab，在之後真的有檔案也可以直接快取 file opend file struct file 在 看看proc 每個proc都有 struct files_struct 在 紀錄 開過的檔案 struct fs_struct 在 紀錄 pwd, 現在跑的檔案 每個namespace都有 struct mmt_namespace 在 放vfsmount，讓同一namespace的去找 ch14 skip\nch16 快取策略 nowrite 不管cache，直接寫到mem cache直接失效 write-through 同時更新cache與mem write back 先更cache 再找時間更mem 快取無效策略 LRU 從list中拿掉最少用到的 LRU/2 兩條list 熱的 不熱的 變成熱的方式 在不熱的中 有被用到 如何調整兩條list 熱的比不熱的長 把一些去掉 怎麼去掉 fifo (不是最少用到) 熱的list就是原本LRU中記錄頻率的腳色 只要在熱的list就是有用過 page快取(上一篇心得的file快取) struct address_space 在 應該叫page_cache_entity 這是write back 什麼時候寫回去 cache要沒了 cache放太久了 有人callsync(),fsync() 誰去寫 靠flusher的多thread去寫 (原本是單thread) 但還是會被底下的IO給bound ch17 編module makefile obj-m += foo.o # obj-m += foo.o 加在sourcetree中的makefile中 foo-objs := foo-main.o foo-utils.o 編 make -C /kernel/path SUBDIRS=$PWD modules 安裝 make modules_install 生相依訊息 depmod depmod -A only for new added modules 加編譯選項 改Kconfig export what? 參數 static int a = 1; module_param_named(exported_name, a, int, 0644); symbol table EXPORT_SYMBOL(your_func); EXPORT_SYMBOL_GPL(your_func); device model \u0026 sysfs device model struct kobject\n在 就是obj 與list一樣要嵌到其他struct上才有用 在sysfs中會變成folder 他的參數會變成file struct attribute 在 會有值，可讀寫 struct sysfs_ops 在 有read/write可以實作 struct ktype\n在 就是放methods struct kset\n在 就是class(obj的base，js的prototype) sysfs block 列出註冊的block dev bus 列出系統的bus class 列出依func排列的dev net, block, ppp, rtc等等 dev 列出註冊的dev block, char devices 列出dev的topo platform, system, virtual等等 firmware 與系統有關的low-level子系統 ACPI, EDD, EFI fs 列出filesystem kernel 列出kernel狀態與option modules 列出載入的module power 列出電源管理的資料 ch18\u002619 開發tips 保留一個能動的，一個用新版，其他用舊版 用uid(user)去切 加個condition 加統計量 限制output的頻率 每個幾秒印一次 只印幾次 輸出自己的錯誤訊息 我自己會在一定看的到的地方(像家目錄)，放log align 由大到小去排\n// total: 12 struct A { char a; // 1+3 unsigned long b; // 4+0 unsigned short c; // 2+1+1 char d; }; // total: 8 struct B { unsigned long b; // 4+0 unsigned short c; // 2+1+1 char a; char d; }; big/little endian 變成binary: 會變成abcd 最左是最高有效位 big-endian: 最高有效位放arr第一個 little-endian: 最低有效位放arr第一個 最高有效位與最低有效位的技法: 下坡(反斜線)，所以最高在左邊\n一些數字 不要假設HZ、page的長度 沒有寫明長度的type的長度都是不確定的 除了 char是1byte (ansi c) int通常是32位 ch20 skip\n","wordCount":"1136","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-06-26T03:31:56Z","dateModified":"2021-06-26T03:31:56Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/06/linux-kernel-development-3rd%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Linux Kernel Development 3rd筆記</h1><div class=post-meta><span title='2021-06-26 03:31:56 +0000 UTC'>June 26, 2021</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e6%95%b4%e9%ab%94%e5%bf%83%e5%be%97 aria-label=整體心得>整體心得</a></li><li><a href=#ch1 aria-label=ch1>ch1</a></li><li><a href=#ch2 aria-label=ch2>ch2</a><ul><li><a href=#folder aria-label=folder>folder</a></li><li><a href=#make aria-label=make>make</a></li><li><a href=#kernel-dev%e7%9a%84%e7%89%b9%e9%bb%9e aria-label="kernel dev的特點">kernel dev的特點</a></li></ul></li><li><a href=#ch3 aria-label=ch3>ch3</a><ul><li><a href=#%e7%9b%b8%e9%97%9cstruct aria-label=相關struct>相關struct</a></li><li><a href=#proc-state aria-label="proc state">proc state</a></li><li><a href=#clone-syscall aria-label="clone syscall">clone syscall</a></li></ul></li><li><a href=#ch4 aria-label=ch4>ch4</a><ul><li><a href=#proc%e5%90%83 aria-label=proc吃?>proc吃?</a></li><li><a href=#time-slice aria-label="time slice">time slice</a></li><li><a href=#proc%e5%84%aa%e5%85%88%e7%b4%9a aria-label=proc優先級>proc優先級</a></li><li><a href=#%e5%85%ac%e5%b9%b3%e8%aa%bf%e5%ba%a6cfs aria-label=公平調度(CFS)>公平調度(CFS)</a></li></ul></li><li><a href=#ch5 aria-label=ch5>ch5</a></li><li><a href=#ch6 aria-label=ch6>ch6</a><ul><li><a href=#list_elment aria-label=list_elment>list_elment</a></li><li><a href=#kfifo aria-label=kfifo>kfifo</a></li><li><a href=#idr aria-label=idr>idr</a></li><li><a href=#rbtree aria-label=rbtree>rbtree</a></li></ul></li><li><a href=#ch7 aria-label=ch7>ch7</a><ul><li><a href=#%e4%b8%ad%e6%96%b7irq aria-label=中斷(IRQ)>中斷(IRQ)</a></li><li><a href=#%e4%b8%ad%e6%96%b7%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=中斷上下文>中斷上下文</a></li><li><a href=#%e4%b8%8a%e5%8d%8a%e6%ae%b5-%e8%88%87-%e4%b8%8b%e5%8d%8a%e6%ae%b5 aria-label="上半段 與 下半段">上半段 與 下半段</a></li><li><a href=#request_irq aria-label=request_irq>request_irq</a></li><li><a href=#reenter aria-label=reenter?>reenter?</a></li><li><a href=#irqf_shared aria-label=IRQF_SHARED>IRQF_SHARED</a></li><li><a href=#procsinterrupts aria-label=/procs/interrupts>/procs/interrupts</a></li><li><a href=#%e4%b8%ad%e6%96%b7%e6%8e%a7%e5%88%b6%e5%99%a8 aria-label=中斷控制器>中斷控制器</a></li></ul></li><li><a href=#ch8 aria-label=ch8>ch8</a><ul><li><a href=#softirq aria-label=softirq>softirq</a></li><li><a href=#tasklet aria-label=tasklet>tasklet</a></li><li><a href=#ksoftirqd aria-label=ksoftirqd>ksoftirqd</a></li><li><a href=#work-queue aria-label="work queue">work queue</a></li><li><a href=#how-to-lock aria-label="how to lock">how to lock</a></li></ul></li><li><a href=#ch910 aria-label=ch9&amp;10>ch9&amp;10</a><ul><li><a href=#%e6%80%8e%e9%ba%bc%e7%ad%89%e9%8e%96 aria-label=怎麼等鎖>怎麼等鎖</a></li><li><a href=#%e8%a6%81%e5%90%8c%e6%ad%a5%e7%9a%84%e5%8e%9f%e5%9b%a0%e6%98%af aria-label=要同步的原因是>要同步的原因是</a></li><li><a href=#struct%e4%bb%80%e9%ba%bc%e6%99%82%e5%80%99%e5%8a%a0%e9%8e%96 aria-label=struct什麼時候加鎖>struct什麼時候加鎖</a></li><li><a href=#%e5%8e%9f%e5%ad%90%e6%80%a7%e8%88%87%e9%a0%86%e5%ba%8f%e6%80%a7 aria-label=原子性與順序性>原子性與順序性</a></li><li><a href=#%e8%ae%80%e5%af%ab%e9%8e%96rw aria-label=讀寫鎖(RW)>讀寫鎖(RW)</a></li><li><a href=#%e5%b7%a5%e5%85%b7 aria-label=工具>工具</a></li><li><a href=#priority-inversion aria-label="priority inversion">priority inversion</a></li></ul></li><li><a href=#ch11 aria-label=ch11>ch11</a><ul><li><a href=#%e6%80%8e%e9%ba%bc%e7%ae%971%e7%a7%92 aria-label=怎麼算1秒>怎麼算1秒</a></li><li><a href=#%e9%96%8b%e6%a9%9f%e5%a4%9a%e4%b9%85%e4%ba%86 aria-label=開機多久了>開機多久了</a></li><li><a href=#%e7%a1%ac%e9%ab%94 aria-label=硬體>硬體</a></li><li><a href=#%e9%97%9c%e6%96%bcproc%e7%9a%84%e8%a8%88%e6%99%82 aria-label=關於proc的計時>關於proc的計時</a></li><li><a href=#%e5%a6%82%e4%bd%95delay aria-label=如何delay>如何delay</a></li></ul></li><li><a href=#ch12 aria-label=ch12>ch12</a><ul><li><a href=#%e6%95%b4%e9%ab%94 aria-label=整體>整體</a></li><li><a href=#%e9%a1%8d%e5%a4%96 aria-label=額外>額外</a></li></ul></li><li><a href=#ch15 aria-label=ch15>ch15</a><ul><li><a href=#%e6%95%b4%e9%ab%94-1 aria-label=整體>整體</a></li><li><a href=#%e9%a1%8d%e5%a4%96-1 aria-label=額外>額外</a></li></ul></li><li><a href=#ch13 aria-label=ch13>ch13</a><ul><li><a href=#virtual-file-system%e7%9a%84%e6%b5%81%e7%a8%8b aria-label="virtual file system的流程">virtual file system的流程</a></li><li><a href=#vfs%e7%9a%84attribute aria-label=VFS的attribute>VFS的attribute</a></li><li><a href=#%e7%9c%8b%e7%9c%8bproc aria-label=看看proc>看看proc</a></li></ul></li><li><a href=#ch14 aria-label=ch14>ch14</a></li><li><a href=#ch16 aria-label=ch16>ch16</a><ul><li><a href=#%e5%bf%ab%e5%8f%96%e7%ad%96%e7%95%a5 aria-label=快取策略>快取策略</a></li><li><a href=#%e5%bf%ab%e5%8f%96%e7%84%a1%e6%95%88%e7%ad%96%e7%95%a5 aria-label=快取無效策略>快取無效策略</a></li><li><a href=#page%e5%bf%ab%e5%8f%96%e4%b8%8a%e4%b8%80%e7%af%87%e5%bf%83%e5%be%97%e7%9a%84file%e5%bf%ab%e5%8f%96 aria-label=page快取(上一篇心得的file快取)>page快取(上一篇心得的file快取)</a></li></ul></li><li><a href=#ch17 aria-label=ch17>ch17</a><ul><li><a href=#%e7%b7%a8module aria-label=編module>編module</a><ul><li><a href=#makefile aria-label=makefile>makefile</a></li></ul></li><li><a href=#export-what aria-label="export what?">export what?</a></li><li><a href=#device-model--sysfs aria-label="device model & sysfs">device model & sysfs</a></li></ul></li><li><a href=#ch1819 aria-label=ch18&amp;19>ch18&amp;19</a><ul><li><a href=#%e9%96%8b%e7%99%bctips aria-label=開發tips>開發tips</a></li><li><a href=#align aria-label=align>align</a></li><li><a href=#biglittle-endian aria-label="big/little endian">big/little endian</a></li><li><a href=#%e4%b8%80%e4%ba%9b%e6%95%b8%e5%ad%97 aria-label=一些數字>一些數字</a></li></ul></li><li><a href=#ch20 aria-label=ch20>ch20</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>不記實際上怎麼跑與跑了什麼，只記設計與方便未來查詢的部分
畢竟這是基於linux2.6的</p><h2 id=整體心得>整體心得<a hidden class=anchor aria-hidden=true href=#整體心得>#</a></h2><p>讀完上一本工作原理來讀這本剛好，可以互補</p><p>推薦讀
中斷: ch7~10
mem: ch12&amp;ch15</p><p>省略掉
ch1, 14, 20</p><p>簡體版的翻譯錯誤有點多要小心，覺得怪就去看原文</p><h2 id=ch1>ch1<a hidden class=anchor aria-hidden=true href=#ch1>#</a></h2><p>skip</p><h2 id=ch2>ch2<a hidden class=anchor aria-hidden=true href=#ch2>#</a></h2><h3 id=folder>folder<a hidden class=anchor aria-hidden=true href=#folder>#</a></h3><table><thead><tr><th>folder</th><th>descrition</th></tr></thead><tbody><tr><td>arch</td><td>x86, amd64之類的</td></tr><tr><td>block</td><td>block device 的 IO層</td></tr><tr><td>crypto</td><td>加密API</td></tr><tr><td>Documentation</td><td>文件</td></tr><tr><td>drivers</td><td>device driver</td></tr><tr><td>firmware</td><td>driver需要的fw</td></tr><tr><td>fs</td><td>file system</td></tr><tr><td>include</td><td>kernel的header file</td></tr><tr><td>init</td><td>kernel引導與初始化</td></tr><tr><td>ipc</td><td>跨proc溝通</td></tr><tr><td>kernel</td><td>核心的kernel code(sched之類的)</td></tr><tr><td>lib</td><td>通用kernel function</td></tr><tr><td>mm</td><td>記憶體管理與virtual memory</td></tr><tr><td>net</td><td>網路</td></tr><tr><td>samples</td><td>範例</td></tr><tr><td>scripts</td><td>compile kernel用的腳本</td></tr><tr><td>security</td><td>安全模組</td></tr><tr><td>sound</td><td>聲音</td></tr><tr><td>usr</td><td>userspace的code</td></tr><tr><td>tools</td><td>linux的開發工具</td></tr><tr><td>virt</td><td>虛擬化</td></tr></tbody></table><h3 id=make>make<a hidden class=anchor aria-hidden=true href=#make>#</a></h3><ul><li><code>make menuconfig</code><ul><li>調linux的設定</li></ul></li><li><code>make defconfig</code><ul><li>把menuconfig的設定設成預設</li></ul></li><li><code>make oldconfig</code><ul><li>load從其他地方來的<code>.config</code></li></ul></li><li><code>make</code><ul><li>compile</li><li>在kernel code的根目錄會產生System.map，裡面有symbol，需要可以看</li></ul></li></ul><h3 id=kernel-dev的特點>kernel dev的特點<a hidden class=anchor aria-hidden=true href=#kernel-dev的特點>#</a></h3><ul><li>沒有libc與stdlib<ul><li>linux有自己的工具，可以看include裡面的header，像<code>/inlucde/linux</code>就是linux kernel的函數</li></ul></li><li>用gnu c<ul><li>inline</li><li>asmembly 內嵌</li><li>likely, unlikely之類的if優化</li></ul></li><li>沒有mem保護<ul><li>沒有seg fault，只剩panic</li></ul></li><li>幾乎不能用floating point</li><li>kernel stack十分小，並隨arch不同而有改變</li><li>同步很重要<ul><li>preempt</li><li>smp(多對稱處理器，多cpu)</li></ul></li></ul><h2 id=ch3>ch3<a hidden class=anchor aria-hidden=true href=#ch3>#</a></h2><p>proc</p><h3 id=相關struct>相關struct<a hidden class=anchor aria-hidden=true href=#相關struct>#</a></h3><ul><li>struct task_struct<ul><li>在<code>&lt;linux/sched.h></code></li><li>proc的DS，有<ul><li>pid</li><li>addr space</li><li>打開的文件 等&mldr;</li></ul></li></ul></li><li>struct thraed_info<ul><li>在<code>&lt;asm/thraed_info.h></code></li><li>放在kernel stack上，用以找到task_struct<ul><li>為什麼不直接放task_struct</li></ul></li><li>放proc中與arch有關的訊息<ul><li>可以想成goroutines的struct P</li></ul></li></ul></li></ul><h3 id=proc-state>proc state<a hidden class=anchor aria-hidden=true href=#proc-state>#</a></h3><ul><li>正在跑、可以跑<ul><li>TASK_RUNNING</li></ul></li><li>睡<ul><li>TASK_INTERRUPTABLE<ul><li>等interrupt或其他或signal</li></ul></li><li>TASK_UNINTERRUPTABLE<ul><li>不管signal，其他與TASK_INTERRUPTABLE一樣</li></ul></li></ul></li></ul><h3 id=clone-syscall>clone syscall<a hidden class=anchor aria-hidden=true href=#clone-syscall>#</a></h3><ul><li>fork<ul><li><code>clone(SIGCHID, 0)</code></li></ul></li><li>kthread<ul><li><code>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)</code><ul><li>VM: virtual mem</li><li>FS: file system</li><li>FILES: opend files</li><li>SIGHAND: signal handler</li></ul></li></ul></li><li>vfork (會sync執行的fork)<ul><li><code>clone(CLONE_VFORK | CLONE_VM | SIGCHID, 0)</code></li></ul></li></ul><h2 id=ch4>ch4<a hidden class=anchor aria-hidden=true href=#ch4>#</a></h2><p>proc scheduler</p><h3 id=proc吃>proc吃?<a hidden class=anchor aria-hidden=true href=#proc吃>#</a></h3><ul><li>IO<ul><li>scheduler應該要多拉吃IO的proc<ul><li>不然response time會變慢</li></ul></li><li>但throughput會低</li></ul></li><li>cpu<ul><li>scheduler應該多拉吃cpu的proc<ul><li>不然throughput會變慢</li></ul></li><li>但response time會變慢</li></ul></li></ul><h3 id=time-slice>time slice<a hidden class=anchor aria-hidden=true href=#time-slice>#</a></h3><ul><li>一個proc能佔cpu多少時間<ul><li>太長<ul><li>對吃cpu有利</li><li>對吃IO不利</li><li>高throughput</li><li>差response time</li><li>cxt switch的總計花費時間小</li></ul></li><li>太短<ul><li>對吃cpu不利</li><li>對吃IO有利</li><li>低throughput</li><li>好response time</li><li>cxt switch的總計花費時間多</li></ul></li></ul></li></ul><h3 id=proc優先級>proc優先級<a hidden class=anchor aria-hidden=true href=#proc優先級>#</a></h3><ul><li>nice<ul><li>-20~19</li><li>越小越優先</li></ul></li><li>real-time priority<ul><li>0~99</li><li>越大越優先</li><li>RT proc永遠優先於普通proc</li></ul></li><li>兩個是各自獨立的系統</li></ul><h3 id=公平調度cfs>公平調度(CFS)<a hidden class=anchor aria-hidden=true href=#公平調度cfs>#</a></h3><ul><li>概念<ul><li>依據cpu的使用比例分配<ul><li>分配到的時間與系統負載密切相關</li></ul></li><li>搶的時機是如果有proc花的使用比比當前proc少，就換上去</li><li>每個proc預設拿到<code>1/n</code>個cpu時間<ul><li>n是proc個數</li><li>就是想像一共有<code>proc個數 個cpu</code></li><li>cpu時間在書中叫<code>目標延遲</code></li></ul></li><li>nice就是原本的<code>1/n</code>再乘上nice換出來的比值</li></ul></li><li>實作<ul><li>計時<ul><li>在<code>&lt;linux/sched.h></code></li><li>struct_sched_entity<ul><li>vruntime<ul><li>會記錄運行時間</li><li>以及以proc總數做標準化</li></ul></li></ul></li></ul></li><li>choose proc<ul><li>挑vruntime最小的</li></ul></li><li>sched的interface<ul><li><code>schedule()</code><ul><li>如果要睡覺<ul><li>就是設定proc state再call這個</li><li>假喚醒<ul><li>如果state是TASK_INTERRUPTABLE就會被signal叫醒</li><li>所以要檢查喚醒後發生什麼事</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>cxt switch<ul><li>在<code>&lt;asm/mmu_context.h></code><ul><li>switch_mm換virtual mem</li></ul></li><li>在<code>&lt;asm/system.h></code><ul><li>switch_to換cpu state</li></ul></li></ul></li><li>preempt<ul><li>用一個flag，<code>need_resched</code>去看該不該被搶</li><li>誰可以設?<ul><li>scheduler</li><li>proc自己</li></ul></li><li>preempt發生時機<ul><li>user preempt<ul><li>從syscall回到userspace</li><li>從中斷處理程序回到userspace</li></ul></li><li>kernel preempt<ul><li>中斷處理程序結束，且回到kernel space之前</li><li>kernel的code再一次可以被搶的時候<ul><li><code>need_resched</code>被設</li><li><code>preempt_count</code>是0 (在thread_info)</li></ul></li><li>kernel的code被block時</li><li>kernel的code調用<code>schedule()</code></li></ul></li></ul></li></ul></li><li>RT schedule<ul><li>SCHED_FIFO<ul><li>proc一直跑，除非<ul><li>block</li><li>自己想換</li></ul></li></ul></li><li>SCHED_RR<ul><li>有time slice的SCHED_FIFO</li><li>低優先無法搶高優先即使對方的time slice花完了</li></ul></li><li>都是soft rt</li></ul></li></ul><h2 id=ch5>ch5<a hidden class=anchor aria-hidden=true href=#ch5>#</a></h2><p>syscall在上一篇筆記就說了，所以這裡focus在一些之前沒提到的東西</p><ul><li>asmlinkage<ul><li>叫compiler只能從stack拿參數</li></ul></li><li>參數驗證<ul><li>ptr的addr是userspace的addr</li><li>ptr的addr在proc的addr space中</li><li>讀寫要符合原本的讀寫限制</li><li>參數有效<ul><li>pid有效</li><li>檔案有效</li></ul></li></ul></li><li>process context<ul><li>syscall是在process cxt</li><li>會睡覺</li><li>會被搶</li></ul></li><li>在你想多加一個syscall(衝動)之前，可以<ul><li>用dev file實現read, write，配合ioctl</li><li>創其他操作介面，像semaphore可以像file一樣操作</li><li>sysfs</li></ul></li></ul><h2 id=ch6>ch6<a hidden class=anchor aria-hidden=true href=#ch6>#</a></h2><h3 id=list_elment>list_elment<a hidden class=anchor aria-hidden=true href=#list_elment>#</a></h3><ul><li>在<code>&lt;linux/list.h></code></li><li>Linked List (bidiretion)</li><li>用法是在自己的struct中放一個list_elment<ul><li>因為c沒泛型!!</li><li>c應該叫mem描述語言才對</li></ul></li><li>沒有特別需求時優先用list</li></ul><h3 id=kfifo>kfifo<a hidden class=anchor aria-hidden=true href=#kfifo>#</a></h3><ul><li>在<code>&lt;linux/kfifo.h></code></li><li>Queue</li><li>遇到 consumer/producer時用</li></ul><h3 id=idr>idr<a hidden class=anchor aria-hidden=true href=#idr>#</a></h3><ul><li>在<code>&lt;linux/idr.h></code></li><li>Hash table<ul><li><code>uid</code>(int) -> <code>void *</code></li></ul></li><li>要mapping時就用</li></ul><h3 id=rbtree>rbtree<a hidden class=anchor aria-hidden=true href=#rbtree>#</a></h3><ul><li>在<code>&lt;linux/rbtree.h></code></li><li>紅黑樹</li><li>沒有find與insert，要自己寫<ul><li>因為c沒泛型!!</li></ul></li><li>大量data與反覆search就用</li></ul><h2 id=ch7>ch7<a hidden class=anchor aria-hidden=true href=#ch7>#</a></h2><h3 id=中斷irq>中斷(IRQ)<a hidden class=anchor aria-hidden=true href=#中斷irq>#</a></h3><ul><li>就是一個數字</li><li>異常與中斷很像<ul><li>但異常要與cpu時鐘同步</li></ul></li></ul><h3 id=中斷上下文>中斷上下文<a hidden class=anchor aria-hidden=true href=#中斷上下文>#</a></h3><ul><li>不會block(睡覺)</li><li>當他出現時，一定是<ul><li>打斷了某個proc</li><li>甚至是，不同irq stack的irq</li></ul></li></ul><h3 id=上半段-與-下半段>上半段 與 下半段<a hidden class=anchor aria-hidden=true href=#上半段-與-下半段>#</a></h3><ul><li>上半段: 馬上處理</li><li>下半段: 原本中斷中可以之後再處理的</li></ul><h3 id=request_irq>request_irq<a hidden class=anchor aria-hidden=true href=#request_irq>#</a></h3><ul><li>註冊irq</li><li>會sleep</li></ul><h3 id=reenter>reenter?<a hidden class=anchor aria-hidden=true href=#reenter>#</a></h3><ul><li>irq被call時，該irq會被mask起來，其他cpu看不到</li></ul><h3 id=irqf_shared>IRQF_SHARED<a hidden class=anchor aria-hidden=true href=#irqf_shared>#</a></h3><ul><li>多個dev用同一個irq</li><li>所以<ul><li>dev的addr唯一，也就是可以區分不同device</li><li>code有辦法對應不同device</li></ul></li></ul><h3 id=procsinterrupts>/procs/interrupts<a hidden class=anchor aria-hidden=true href=#procsinterrupts>#</a></h3><ul><li>PC上所有irq的資訊</li></ul><h3 id=中斷控制器>中斷控制器<a hidden class=anchor aria-hidden=true href=#中斷控制器>#</a></h3><ul><li>停用<ul><li>cpu上的整個中斷<ul><li>這樣這個cpu上就不會被preempt</li><li>但其他cpu還是可以中斷!!</li></ul></li><li>所有cpu的某個中斷</li></ul></li><li>看<code>&lt;asm/system.h></code>與<code>&lt;asm/irq.h></code></li></ul><h2 id=ch8>ch8<a hidden class=anchor aria-hidden=true href=#ch8>#</a></h2><p>中斷，下半段</p><h3 id=softirq>softirq<a hidden class=anchor aria-hidden=true href=#softirq>#</a></h3><ul><li>同一個softirq可以同時跑在其他cpu上</li><li>靜態註冊 (compile-time)<ul><li>在<code>&lt;linux/interrupt.h></code><ul><li>struct softirq_action</li></ul></li><li>softirq放在array中(32個)</li></ul></li><li>中斷上下文</li><li>softirq沒辦法搶其他的softirq<ul><li>softirq只會被irq搶!!</li></ul></li><li>跑什麼softirq<ul><li>irq handler在return前會標</li></ul></li><li>什麼時候跑softirq?<ul><li>irq handler在return時</li><li>在softirqd中</li><li>有人去看還有哪些softirq還沒跑與直接執行softirq的時候</li></ul></li></ul><h3 id=tasklet>tasklet<a hidden class=anchor aria-hidden=true href=#tasklet>#</a></h3><ul><li>同一個tasklet<strong>不</strong>可以同時跑在其他cpu上</li><li>動態註冊<ul><li>在<code>&lt;linux/interrupt.h></code><ul><li>struct tasklet_struct</li><li>有執行狀態<ul><li>所以其他cpu不會跑正在跑的tasklet</li></ul></li></ul></li><li>tasklet放在cpu上的linked list<ul><li>tasklet_vec</li><li>tasklet_hi_vec (hi是high)</li><li>所以可以動態加</li></ul></li></ul></li><li>中斷上下文</li><li>tasklet就是掛在兩個softirq上<ul><li>把task往裡面放，需要時就跑</li></ul></li></ul><h3 id=ksoftirqd>ksoftirqd<a hidden class=anchor aria-hidden=true href=#ksoftirqd>#</a></h3><ul><li>每個cpu上會有一個</li><li>處理大量softirq<ul><li>在最低nice的kthread中去調用還沒跑的softirq</li></ul></li></ul><h3 id=work-queue>work queue<a hidden class=anchor aria-hidden=true href=#work-queue>#</a></h3><ul><li>proc上下文<ul><li>可以allocate大mem</li><li>semaphore</li><li>用block IO</li></ul></li><li>每個cpu一個queue與kthread，跑task<ul><li>我們需要一個可以看到所有cpu的struct<ul><li>在<code>&lt;linux/workqueue.h></code><ul><li>struct workqueue_struct<ul><li>放workqueue訊息</li></ul></li></ul></li><li>proc叫<code>event/n</code><ul><li>在<code>&lt;kernel/workqueue.c></code><ul><li>struct cpu_workqueue_struct<ul><li>就是queue</li></ul></li></ul></li><li>在<code>&lt;linux/workqueue.h></code><ul><li>struct work_struct<ul><li>就是task</li></ul></li></ul></li><li>每個cpu上會有一個</li><li>n是cpu編號</li></ul></li></ul></li></ul></li></ul><h3 id=how-to-lock>how to lock<a hidden class=anchor aria-hidden=true href=#how-to-lock>#</a></h3><ul><li>proc cxt與bottom half分享data<ul><li>鎖bottom half</li><li>拿鎖</li></ul></li><li>irq cxt與bottom half分享data<ul><li>鎖irq</li><li>拿鎖</li></ul></li><li>irq -> softirq/tasklet -> proc<ul><li>如果要和上一層share data<ul><li>鎖上一層!!<ul><li>防smp與preempt</li></ul></li><li>拿鎖</li></ul></li><li>可以看<a href=https://www.kernel.org/doc/html/v4.13/kernel-hacking/locking.html>Unreliable Guide To Locking</a>有詳細的解釋</li></ul></li></ul><h2 id=ch910>ch9&amp;10<a hidden class=anchor aria-hidden=true href=#ch910>#</a></h2><h3 id=怎麼等鎖>怎麼等鎖<a hidden class=anchor aria-hidden=true href=#怎麼等鎖>#</a></h3><ul><li>busy waiting<ul><li>都能用</li></ul></li><li>sleep<ul><li>only in proc ctx</li></ul></li></ul><h3 id=要同步的原因是>要同步的原因是<a hidden class=anchor aria-hidden=true href=#要同步的原因是>#</a></h3><ul><li>in userspace</li><li>preempt</li><li>re schedule</li><li>in kernel space<ul><li>irq</li><li>softirq/tasklet</li><li>preempt</li><li>sleep & sync with userspace</li><li>smp</li></ul></li></ul><h3 id=struct什麼時候加鎖>struct什麼時候加鎖<a hidden class=anchor aria-hidden=true href=#struct什麼時候加鎖>#</a></h3><ul><li>kernel struct大部分都要</li><li>有其他proc可以access</li><li>任何人都看的到的</li></ul><h3 id=原子性與順序性>原子性與順序性<a hidden class=anchor aria-hidden=true href=#原子性與順序性>#</a></h3><ul><li>原子性<ul><li>執行期間不打斷，只有兩個case<ul><li>沒有跑</li><li>跑完了</li></ul></li></ul></li><li>順序性<ul><li>ABC分散在不同中，也要ABC去跑<ul><li>用lock只能保證，ABC一起跑，一起不跑</li><li>用semaphore可以幹出來</li><li>主要用barrier</li></ul></li></ul></li></ul><h3 id=讀寫鎖rw>讀寫鎖(RW)<a hidden class=anchor aria-hidden=true href=#讀寫鎖rw>#</a></h3><ul><li>只能有下面的其中一種case<ul><li>1寫</li><li>多讀</li></ul></li><li>有利於<strong>讀</strong><ul><li>只要一堆讀，寫就只要等就飽了</li></ul></li></ul><h3 id=工具>工具<a hidden class=anchor aria-hidden=true href=#工具>#</a></h3><ul><li>atomic_t</li><li>spinlock<ul><li>busy waiting<ul><li>使用時不能sleep</li><li>不然就是增加整體的response time</li></ul></li><li>如果lock時間小於2次ctx switch才有利</li><li>no recur<ul><li>不能鎖了又鎖</li></ul></li><li>在irq中用的話<ul><li>先關irq</li><li>不然被中斷，另一irq又拿同一個鎖的話&mldr;</li></ul></li><li>有RW版</li><li>禁止preempt<ul><li>持有spinlock就是禁止preempt</li></ul></li></ul></li><li>semaphore<ul><li>sleep<ul><li>only in proc ctx</li></ul></li><li>任何持有人都可以上鎖或解鎖!!</li><li>可以超過一個人到critical zone</li><li>有RW版</li></ul></li><li>mutex<ul><li>sleep<ul><li>only in proc ctx</li></ul></li><li>上鎖的人才能解鎖</li><li>只有一個人能到critical zone</li><li>可以recur</li><li>可以處理priority inversion</li></ul></li><li>complete variable<ul><li>cond var</li></ul></li><li>seq lock<ul><li>實作<ul><li>有一個acc</li><li>當write拿鎖時，會<code>acc++</code></li><li>read時就是確認開始與結束的acc值是不是一樣<ul><li>確認中間沒有write</li></ul></li><li>也可以透過acc是不是偶數看寫結束語否</li></ul></li><li>有利於<strong>寫</strong></li></ul></li><li>mem barrier<ul><li>barrier前面的code跑完前，絕對不會跑後面去</li><li>起因於<ul><li>指令重排，所以有些指令會跑到後面去</li><li>前半部的code不會到reorder到後面去</li></ul></li></ul></li></ul><h3 id=priority-inversion>priority inversion<a hidden class=anchor aria-hidden=true href=#priority-inversion>#</a></h3><ul><li>一般來說是在RT才會提，但想到就記一下</li><li>情境<ul><li>pri最小(A)拿到lock中被中斷</li><li>pri高的(C)想拿lock，但拿不到!!<ul><li>像spinlock會busy waiting</li></ul></li><li>pri高的跑不動，time slice吃完</li><li>有下一個pri比較低的(B)，來了，也做完了!?</li><li>但pri高的還沒做完阿!!</li></ul></li><li>起因<ul><li>lock的效果會影響優先權，但是沒有納入原有優先權的系統中<ul><li>像只要有人拿了spiclock，那他在這一塊就是最優先的</li><li>不管其他優先權怎麼設，bust waiting就是wait，沒有轉圜的機會</li><li>同時也無法打斷，不然就不是crtical zone了</li></ul></li></ul></li><li>解法<ul><li>大方向: crtical zone要先跑!!<ul><li>要改crtical zone的優先權<ul><li>改到與現在最高的一樣高</li><li>改到沒有人比crtical zone高</li></ul></li></ul></li><li>Priority inheritance<ul><li>在crtical zone時，遇到更高的proc同時要進來</li><li>把crtical zone的優先權拉到與那個proc一樣高</li><li>跑完crtical zone就降回去</li></ul></li><li>Priority ceiling protocol<ul><li>在crtical zone時拉到最高</li><li>跑完crtical zone就降回去</li></ul></li></ul></li></ul><h2 id=ch11>ch11<a hidden class=anchor aria-hidden=true href=#ch11>#</a></h2><h3 id=怎麼算1秒>怎麼算1秒<a hidden class=anchor aria-hidden=true href=#怎麼算1秒>#</a></h3><ul><li>系統計時器會依一定頻率(tick rate)打中斷<ul><li>這樣kernel知道兩次中斷之間的間隔時間(tick)</li></ul></li><li>HZ就是1sec打幾次<ul><li>HZ可以改!!</li><li>HZ越高<ul><li>時間精準度越高<ul><li>連帶與時間有關的都會變準<ul><li>poll, select</li><li>preempt</li></ul></li></ul></li><li>system load上升</li></ul></li><li>這是kernel用的<ul><li>userspace的叫USER_HZ</li></ul></li></ul></li><li>1sec = tick * HZ</li></ul><h3 id=開機多久了>開機多久了<a hidden class=anchor aria-hidden=true href=#開機多久了>#</a></h3><ul><li>jiffies<ul><li>紀錄系統計時器中斷打了幾次</li></ul></li><li>jiffies/HZ => 開機多久</li></ul><h3 id=硬體>硬體<a hidden class=anchor aria-hidden=true href=#硬體>#</a></h3><ul><li>RTC<ul><li>bios上存時間(幾點幾分之類的)的</li><li>就算電腦關機，還是藉由CMOS繼續跑</li><li>開機時初始化xtime變數</li></ul></li><li>系統計時器<ul><li>由kernel設定tick rate</li></ul></li></ul><h3 id=關於proc的計時>關於proc的計時<a hidden class=anchor aria-hidden=true href=#關於proc的計時>#</a></h3><ul><li>每一次中斷時就把當前proc狀態(idle, run&mldr;)的變數遞增一次<ul><li>如果在這中斷之間多次換狀態?<ul><li>不管，現在他在這個狀態，這一段時間都是這個狀態的</li></ul></li></ul></li></ul><h3 id=如何delay>如何delay<a hidden class=anchor aria-hidden=true href=#如何delay>#</a></h3><p>delay執行，不應該在有lock時或是關閉中斷後發生</p><ul><li>busy wait<ul><li>base on jiffies</li></ul></li><li>short delay<ul><li>如果要的delay比tick小</li><li>用<code>udelay(),ndelay(),mdelay()</code><ul><li>裡面其實也是loop，但是kernel知道他會跑多久且不用jiffies</li></ul></li></ul></li><li><code>schedule_timeout()</code><ul><li>讓task睡，在超過指定時間後跑<ul><li>沒辦法說很精確在時間到就馬上跑</li></ul></li><li>soft rt</li></ul></li></ul><h2 id=ch12>ch12<a hidden class=anchor aria-hidden=true href=#ch12>#</a></h2><p>kernel space的mem</p><h3 id=整體>整體<a hidden class=anchor aria-hidden=true href=#整體>#</a></h3><ul><li>phy<ul><li>mem<ul><li>byte</li><li>word</li></ul></li><li>cpu<ul><li>page</li></ul></li></ul></li><li>kernel<ul><li>struct zone<ul><li>在<code>&lt;linux/mmzone.h></code></li><li>struct page<ul><li>在<code>&lt;linux/mm_types.h></code></li><li>對應到<strong>實體的page</strong></li><li>再從page換成addr<ul><li>alloc_pages -> page_address</li><li>kmalloc<ul><li>不能要求<code>ZONE_HIGHEM</code><ul><li>因為可能還沒分配邏輯addr</li><li>用alloc_pages</li></ul></li></ul></li><li>上面都是<ul><li>連續的page</li><li>可以sleep時用<code>GFP_KERNEL</code></li><li>不可以sleep時用<code>GFP_ATOMIC</code></li></ul></li><li>vmalloc<ul><li>可能不連續的page</li></ul></li></ul></li></ul></li><li>不同page在不同位置，所以有不同區</li><li>4種<ul><li>ZONE_DMA</li><li>ZONE_DMA32<ul><li>only for 32bits device</li></ul></li><li>ZONE_NORMAL</li><li>ZONE_HIGHEM<ul><li>high mem用，不能用永久map到kernel addr空間</li><li>想想kernel都是用<strong>低</strong>的mem，所以高的其實算是userspace的<ul><li>如果要用就要map<ul><li>永久: kmap (low與high都能用，會睡覺)</li><li>臨時: kmap_atomic (不會睡，但是會被下一個)</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>slab<ul><li>在快取記憶體上(kmem_cache)開一個list當成object pool<ul><li>之後重複利用裡面已經存在的obj</li><li>slab就是list上的node，node裡面放obj</li></ul></li><li>struct slab<ul><li>在<code>&lt;mm/slab.c></code></li></ul></li></ul></li></ul></li></ul><h3 id=額外>額外<a hidden class=anchor aria-hidden=true href=#額外>#</a></h3><ul><li>stack<ul><li>每個proc有<ul><li>kernel stack<ul><li>1~2 page (根據arch)</li><li>原本中斷也是用被中斷的proc的stack</li><li>kernel stack本來就很小，還是別吧<ul><li>最後有了interrupt stack</li></ul></li></ul></li><li>user stack<ul><li>就一般的stack</li><li>kernel stack是為了與user stack分開</li><li>想想兩個混在一起會發生什麼事</li></ul></li></ul></li><li>每個cpu有<ul><li>interrupt stack</li></ul></li></ul></li><li>percpu<ul><li>每個cpu自己的data</li><li>因為是cpu自己的，所以<ul><li>cache失效降低</li><li>不用擔心smp<ul><li>preempt還是要怕</li></ul></li></ul></li></ul></li></ul><h2 id=ch15>ch15<a hidden class=anchor aria-hidden=true href=#ch15>#</a></h2><p>user space的mem</p><h3 id=整體-1>整體<a hidden class=anchor aria-hidden=true href=#整體-1>#</a></h3><ul><li>proc的userspace的mem空間<ul><li>struct mm_struct<ul><li>在<code>&lt;linux/sched.h></code></li><li>可以到<code>/proc/&lt;pid>/maps</code>看proc現在有什麼</li><li>主要兩個<ul><li>struct vm_area_struct<ul><li>在<code>&lt;linux/mm_types.h></code></li><li>就是這裡的page，加上權限與狀態之類的</li><li>在mm_struct有兩個obj放vm_area_struct<ul><li>list: 方便iterate</li><li>rbtree: 方便找定點</li></ul></li></ul></li><li>pgd_t<ul><li>phy的page表<ul><li>三層 (pgd -> pmd -> pte)</li></ul></li><li>用這個換出實際addr</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id=額外-1>額外<a hidden class=anchor aria-hidden=true href=#額外-1>#</a></h3><ul><li>kthread的mm<ul><li>kthread天生沒有mm (不然怎麼有k)</li><li>當需要的時候會從proc的ptr拿到<ul><li>當schedule會存前一個proc的mm (active_mm)</li><li>當kthread需要(像page table)，就直接用active_mm看</li></ul></li></ul></li><li>mmap<ul><li>把file放到proc的userspace的mem空間<ul><li>生一個addr出來</li></ul></li></ul></li></ul><h2 id=ch13>ch13<a hidden class=anchor aria-hidden=true href=#ch13>#</a></h2><h3 id=virtual-file-system的流程>virtual file system的流程<a hidden class=anchor aria-hidden=true href=#virtual-file-system的流程>#</a></h3><ol><li>userspace</li><li>virtual file system</li><li>真的file system</li><li>phy</li></ol><h3 id=vfs的attribute>VFS的attribute<a hidden class=anchor aria-hidden=true href=#vfs的attribute>#</a></h3><ul><li>superblock<ul><li>真的file system (ext4, brtfs&mldr;)<ul><li>struct file_system_type<ul><li>在<code>&lt;linux/fs.h></code></li><li>放fs的訊息(kernel關心的)</li></ul></li><li>struct vfsmount<ul><li>在<code>&lt;linux/mount.h></code></li><li>fs的統計數據與安裝訊息(root, dev等等)與安裝點<ul><li>可以當成實際fs的入口</li></ul></li></ul></li></ul></li><li>放fs的訊息(VFS關心的)</li><li>struct super_block<ul><li>在<code>&lt;linux/fs.h></code></li></ul></li></ul></li><li>inode<ul><li>file or folder</li><li>放file/folder的訊息</li><li>struct inode<ul><li>在<code>&lt;linux/fs.h></code></li></ul></li></ul></li><li>dentry<ul><li>path的一部份<ul><li><code>/usr/bin/vi</code>的<ul><li><code>/</code>, <code>usr</code>, <code>bin</code>, <code>vi</code></li></ul></li><li>其實可以當成inode，但是為了查找path，所以獨立出來</li></ul></li><li>struct dentry<ul><li>在<code>&lt;linux/dcache.h></code></li></ul></li><li>state<ul><li>被用<ul><li>有對應的file</li><li>也正在被ref</li></ul></li><li>還沒被用<ul><li>有對應的file</li><li>沒被ref</li></ul></li><li>不在<ul><li>根本沒這個file<ul><li>總不能每次要等整個找完才丟沒有指定的檔案吧</li><li>同時，因為有這個與slab，在之後真的有檔案也可以直接快取</li></ul></li></ul></li></ul></li></ul></li><li>file<ul><li>opend file</li><li>struct file<ul><li>在<code>&lt;linux/fs.h></code></li></ul></li></ul></li></ul><h3 id=看看proc>看看proc<a hidden class=anchor aria-hidden=true href=#看看proc>#</a></h3><ul><li>每個proc都有<ul><li>struct files_struct<ul><li>在<code>&lt;linux/fdtable.h></code></li><li>紀錄 開過的檔案</li></ul></li><li>struct fs_struct<ul><li>在<code>&lt;linux/fs_struct.h></code></li><li>紀錄 pwd, 現在跑的檔案</li></ul></li></ul></li><li>每個namespace都有<ul><li>struct mmt_namespace<ul><li>在<code>&lt;linux/mmt_namespace.h></code></li><li>放vfsmount，讓同一namespace的去找</li></ul></li></ul></li></ul><h2 id=ch14>ch14<a hidden class=anchor aria-hidden=true href=#ch14>#</a></h2><p>skip</p><h2 id=ch16>ch16<a hidden class=anchor aria-hidden=true href=#ch16>#</a></h2><h3 id=快取策略>快取策略<a hidden class=anchor aria-hidden=true href=#快取策略>#</a></h3><ul><li>nowrite<ul><li>不管cache，直接寫到mem</li><li>cache直接失效</li></ul></li><li>write-through<ul><li>同時更新cache與mem</li></ul></li><li>write back<ul><li>先更cache</li><li>再找時間更mem</li></ul></li></ul><h3 id=快取無效策略>快取無效策略<a hidden class=anchor aria-hidden=true href=#快取無效策略>#</a></h3><ul><li>LRU<ul><li>從list中拿掉最少用到的</li></ul></li><li>LRU/2<ul><li>兩條list<ul><li>熱的</li><li>不熱的</li></ul></li><li>變成熱的方式<ul><li>在不熱的中</li><li>有被用到</li></ul></li><li>如何調整兩條list<ul><li>熱的比不熱的長</li><li>把一些去掉</li></ul></li><li>怎麼去掉<ul><li>fifo (不是最少用到)</li><li>熱的list就是原本LRU中記錄頻率的腳色</li><li>只要在熱的list就是有用過</li></ul></li></ul></li></ul><h3 id=page快取上一篇心得的file快取>page快取(上一篇心得的file快取)<a hidden class=anchor aria-hidden=true href=#page快取上一篇心得的file快取>#</a></h3><ul><li>struct address_space<ul><li>在<code>&lt;linux/fs.h></code></li><li>應該叫page_cache_entity</li></ul></li><li>這是write back<ul><li>什麼時候寫回去<ul><li>cache要沒了</li><li>cache放太久了</li><li>有人call<code>sync(),fsync()</code></li></ul></li><li>誰去寫<ul><li>靠flusher的多thread去寫 (原本是單thread)<ul><li>但還是會被底下的IO給bound</li></ul></li></ul></li></ul></li></ul><h2 id=ch17>ch17<a hidden class=anchor aria-hidden=true href=#ch17>#</a></h2><h3 id=編module>編module<a hidden class=anchor aria-hidden=true href=#編module>#</a></h3><h4 id=makefile>makefile<a hidden class=anchor aria-hidden=true href=#makefile>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>obj-m</span> <span class=o>+=</span> foo.o
</span></span><span class=line><span class=cl><span class=c># obj-m += foo.o 加在sourcetree中的makefile中
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>foo-objs</span> <span class=o>:=</span> foo-main.o foo-utils.o
</span></span></code></pre></div><ul><li>編<ul><li><code>make -C /kernel/path SUBDIRS=$PWD modules</code></li></ul></li><li>安裝<ul><li><code>make modules_install</code></li></ul></li><li>生相依訊息<ul><li><code>depmod</code></li><li><code>depmod -A</code> only for new added modules</li></ul></li><li>加編譯選項<ul><li>改Kconfig</li></ul></li></ul><h3 id=export-what>export what?<a hidden class=anchor aria-hidden=true href=#export-what>#</a></h3><ul><li>參數<ul><li><code>static int a = 1;</code></li><li><code>module_param_named(exported_name, a, int, 0644);</code></li></ul></li><li>symbol table<ul><li><code>EXPORT_SYMBOL(your_func);</code></li><li><code>EXPORT_SYMBOL_GPL(your_func);</code></li></ul></li></ul><h3 id=device-model--sysfs>device model & sysfs<a hidden class=anchor aria-hidden=true href=#device-model--sysfs>#</a></h3><ul><li>device model<ul><li><p>struct kobject</p><ul><li>在<code>&lt;linux/kobject.h></code></li><li>就是obj</li><li>與list一樣要嵌到其他struct上才有用</li><li>在sysfs中會變成folder<ul><li>他的參數會變成file<ul><li>struct attribute<ul><li>在<code>&lt;linux/sysfs.h></code></li></ul></li><li>會有值，可讀寫<ul><li>struct sysfs_ops<ul><li>在<code>&lt;linux/sysfs.h></code></li><li>有read/write可以實作</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>struct ktype</p><ul><li>在<code>&lt;linux/kobject.h></code></li><li>就是放methods</li></ul></li><li><p>struct kset</p><ul><li>在<code>&lt;linux/kobject.h></code></li><li>就是class(obj的base，js的prototype)</li></ul></li></ul></li><li>sysfs<ul><li>block<ul><li>列出註冊的block dev</li></ul></li><li>bus<ul><li>列出系統的bus</li></ul></li><li>class<ul><li>列出依func排列的dev<ul><li>net, block, ppp, rtc等等</li></ul></li></ul></li><li>dev<ul><li>列出註冊的dev<ul><li>block, char</li></ul></li></ul></li><li>devices<ul><li>列出dev的topo<ul><li>platform, system, virtual等等</li></ul></li></ul></li><li>firmware<ul><li>與系統有關的low-level子系統<ul><li>ACPI, EDD, EFI</li></ul></li></ul></li><li>fs<ul><li>列出filesystem</li></ul></li><li>kernel<ul><li>列出kernel狀態與option</li></ul></li><li>modules<ul><li>列出載入的module</li></ul></li><li>power<ul><li>列出電源管理的資料</li></ul></li></ul></li></ul><h2 id=ch1819>ch18&amp;19<a hidden class=anchor aria-hidden=true href=#ch1819>#</a></h2><h3 id=開發tips>開發tips<a hidden class=anchor aria-hidden=true href=#開發tips>#</a></h3><ul><li>保留一個能動的，一個用新版，其他用舊版<ul><li>用uid(user)去切</li><li>加個condition</li></ul></li><li>加統計量</li><li>限制output的頻率<ul><li>每個幾秒印一次</li><li>只印幾次</li></ul></li><li>輸出自己的錯誤訊息<ul><li>我自己會在一定看的到的地方(像家目錄)，放log</li></ul></li></ul><h3 id=align>align<a hidden class=anchor aria-hidden=true href=#align>#</a></h3><p>由大到小去排</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// total: 12
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// 1+3
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>b</span><span class=p>;</span>  <span class=c1>// 4+0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>c</span><span class=p>;</span> <span class=c1>// 2+1+1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// total: 8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>b</span><span class=p>;</span> <span class=c1>// 4+0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>c</span><span class=p>;</span> <span class=c1>// 2+1+1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=biglittle-endian>big/little endian<a hidden class=anchor aria-hidden=true href=#biglittle-endian>#</a></h3><ul><li>變成binary: 會變成abcd</li><li>最左是最高有效位</li><li>big-endian: 最高有效位放arr第一個</li><li>little-endian: 最低有效位放arr第一個</li></ul><p>最高有效位與最低有效位的技法: 下坡(反斜線)，所以最高在左邊</p><h3 id=一些數字>一些數字<a hidden class=anchor aria-hidden=true href=#一些數字>#</a></h3><ul><li>不要假設HZ、page的長度</li><li>沒有寫明長度的type的長度都是不確定的<ul><li>除了<ul><li>char是1byte (ansi c)</li><li>int通常是32位</li></ul></li></ul></li></ul><h2 id=ch20>ch20<a hidden class=anchor aria-hidden=true href=#ch20>#</a></h2><p>skip</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/06/%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%9E%8B%E7%AD%86%E8%A8%98/><span class=title>« Prev</span><br><span>記憶體模型筆記</span>
</a><a class=next href=https://littlebees.github.io/2021/06/windows%E4%B8%8A%E7%94%A8win10%E7%9A%84pxe%E6%AA%94%E6%A1%88%E8%88%87%E6%9E%B6pxe-server/><span class=title>Next »</span><br><span>windows上用win10的pxe檔案與架pxe server</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>