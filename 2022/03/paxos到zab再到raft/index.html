<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>paxos到zab再到raft | 記事本</title>
<meta name=keywords content="Distributed"><meta name=description content="動機
整理一下"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2022/03/paxos%E5%88%B0zab%E5%86%8D%E5%88%B0raft/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="paxos到zab再到raft"><meta property="og:description" content="動機
整理一下"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2022/03/paxos%E5%88%B0zab%E5%86%8D%E5%88%B0raft/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-13T16:08:37+00:00"><meta property="article:modified_time" content="2022-03-13T16:08:37+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="paxos到zab再到raft"><meta name=twitter:description content="動機
整理一下"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"paxos到zab再到raft","item":"https://littlebees.github.io/2022/03/paxos%E5%88%B0zab%E5%86%8D%E5%88%B0raft/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"paxos到zab再到raft","name":"paxos到zab再到raft","description":"動機 整理一下\n","keywords":["Distributed"],"articleBody":"動機 整理一下\n總體而言 在任何時間點，於不能反悔的情況下維持共識\npaxos與其他共識演算法都是在保護上面假設\n實際如何執行?\n不能反悔 (資料保持最新 \u0026 承認時間流逝) 遞增 冪等 immutation 共識 多數決 單一來源 描述時間 序列號 下面根據paper的時間線來看\nbasic paxos multi-paxos zab raft basic paxos 有兩個角色，proposer與accepter (對應到raft是leader與follower)\n之後與raft不同的是paxos可以同時管理好幾個app的狀態(所以paxos可以接受不連續的log，因為log不用遞增)\n在paxos就是value去區分，每個value都會帶有一個只能遞增的rnd，與當前acceptor知道的最後一個rnd(log的最後index)\npaxos的proposer是任何人都能當的，但要怎麼確認自己的提案會不會被接受? 所以proposer要先問過半的accepter的最大rnd(prepare) 同時acceptor設定之後預期看到的rnd，也就是last_rnd 在下面的圖，log entry整個大概是(last_rnd, value[vrnd])\n另外，記得last_rnd不論何時一定大於等於vrnd 不論在什麼階段，prepare或是accept\n(假設還有其他資料，像是log，就要再額外sync，見zab，不過basic paxos沒有所以這段上括號)\n之後才傳資料，只要rnd(aka log)對的上就收(accept)。\n另外paxos這樣可能會產生livelock，只要有兩個proposer打同一個value就會產生，所以要區隔時間(raft的election timer)\n到此，classic paxos可以看成quorum + 2 phase commit 原本的2 phase commit要所有人確認，但因為這是共識只要quorum到就好\n定義quorum 為什麼要到quorum? 因為這樣可以確保任意讀與寫至少都會有一個有對的資料\n如果只是要符合\"至少都會有一個有對的資料\"，這樣一定要過半嗎? 不用，像是\n要求每個quorum都包含一個特定點 分階層，要求quorum至少要跨一行與跨一欄 只有兩行，要求包含第一行的majority, 或在每一行都包含一个majority 這樣有什麼好處與壞處? 好處: 可以以較少的數量達成quorum，如此一來可以選近的 或是 發少一點rpc 壞處: 犧牲avaibility，像是只要是包含的那個唯一的點壞了就出事了；但過半可以讓另一半壞了也ok\n正確性 value的rnd保證不反悔app狀態同時代表時間點 先問過半的accepter的最大id確保app狀態共識\nmulti-paxos 如果說每次都要同步log才能傳資料就很麻煩另外還有livelock的風險 所以把proposer定成一個這樣就能省下同步log的步驟\n正確性 proposer只要有最新的id，之後就可以commit到acceptor，等commit完成後就proposer又會有最新的id (遞迴)\nfast paxos 真的不想prepare!! 那就直接寫，用最小的rnd去寫。\n失敗的話，還是要prepare阿 有沒有辦法在報錯時確認當前的quorum是什麼?\n所以quorum要變成3/4 zab 就是multi-paxos + 選leader\n但這樣打太短要補一點東西\nzab分成4個階段\nelection 透過zxid來選其實就是 term (這裡叫epoch) id (就是paxos的id) 之後記住自己投給誰 discovery (prepare) sync (sync log) braodcast (accept) 選leader的正確性 leader會壞怎麼辦?\n選leader也要在任何時間點，於不能反悔的情況下維持共識 所以多了term與voteFor，term表示時間、voreFor就是資料 raft 如果只有一個app要管而已，可以簡化設計嗎?\n只放一個log，那可以直接用log遞增取代id 只有一個log，可以在選leader直接認最新log的為leader - 也因此，同步log的時機與paxos不同 paxos因為任何人都可以當proposer，所以一開始就要sync log raft是在成為leader之後才透過appendEntries同步log 但可能有不一致的log，所以才有figure 8 整個dataflow可以看成 leader -\u003e log\n因為leader要過半，所以是共識； 認leader自然imply認log； (appendEntries) 接著就是認leader不能反悔； 最後就是commit出去的不能變，所以有過半才能commit；\n但是只有這樣會產生figure 8的問題，所以要多一個條件 只能在同一個term完成同一個term的事件\n因為只有在完成appendEntrries之後才能確認，follower的log與leader同步，而唯一能讓leader發appendEntrries只有新log或是heartbeat。\n正確性 不能反悔 term只能遞增 只能在同一個term完成同一個term的事件 (第一個處理亂序與crash的手法) leader的log只能遞增 共識 每個term的leader最多一個 用誰的log比較新決定leader 認term與log對不對得起來 leader持有夠新的log且過半(一樣新或是比較舊) log最新的log會過半 有新log會reject其他candidate follower會與leader的log同步 merge相符但是比較短的entries (第二個處理亂序的手法) 砍掉開始不一樣的log 過半才做下一個步驟 成為leader (leader最多一個) commit log上去 (確定新的log占多數) 在同一個term完成同一個term的事件 (raft獨有) figure 8 因為是等到appendEntrries才sync log (類似lazy eval) 變成只能在自己的term才能確認log是對的 但是只要確認就能利用 multi-paxos的遞迴 確認前面的log也是對的!! abstract-paxos 将 paxos 和 raft 统一到一个协议下: abstract-paxos\n這篇就是把原po的quorum與paxos組合在一起，從phase2開始講到phase1\n先有兩個腳色，reader與writer\n我們的algo要保證下面的性質\ncommit-寫quorum: 以保證任何 reader 都可讀到. commit-唯一: 以保證多個 reader 返回相同的結果. commit後不能修改: 以保證多次讀返回同樣的結果. 第一點就是寫quorum\n第二與三點就需要能夠比較不同writer的手段(全序關係)，所以寫入的值需要一個commit_index，讓reader知道要拿那個value\nstruct State { log: Vec\u003c{ commit_index: u64, cmd: Cmd }\u003e, } paxos叫vrnd，raft叫term\n剛剛是reader的，接著是writer的唯一與不可修改 會破壞writer的唯一與不可修改就是有沒有可能要寫之前有其他人要寫呢? 所以我們需要一個機制讓對方承諾說不會接受舊的寫入\n所以就再多一個commit_index\nstruct Node { commit_index: u64, state: State, } paxos叫rnd，raft叫term與voteFor\n這樣就有兩個phase\nimpl Node { fn handle_phase_1(\u0026mut self, p1_req: P1Req) { let p1_reply = P1Reply{ commit_index: self.commit_index state: self.state, }; self.commit_index = max(self.commit_index, p1_req.commit_index()); return p1_reply; } } impl Node { fn handle_phase_2(\u0026mut self, p2_req: P2Req) { let p2_reply = P2Reply{ commit_index: self.commit_index }; if p2_req.commit_index \u003e= self.commit_index { self.state.update(p2_req.state); self.commit_index = max(self.commit_index, p2_req.commit_index); } return p2_reply; } } 注意到self.commit_index = max(self.commit_index, p2_req.commit_index) 這裡就是說node的commit_index一定大於等於state最後一個的commit_index 這邊也可以從writer的角度來看為什麼raft只能在自己的term做commit\nRef 可靠分布式系统-paxos的直观解释 后分布式时代: 多数派读写的’少数派’实现\n","wordCount":"283","inLanguage":"en","datePublished":"2022-03-13T16:08:37Z","dateModified":"2022-03-13T16:08:37Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2022/03/paxos%E5%88%B0zab%E5%86%8D%E5%88%B0raft/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">paxos到zab再到raft</h1><div class=post-meta><span title='2022-03-13 16:08:37 +0000 UTC'>March 13, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e7%b8%bd%e9%ab%94%e8%80%8c%e8%a8%80 aria-label=總體而言>總體而言</a></li><li><a href=#basic-paxos aria-label="basic paxos">basic paxos</a><ul><li><a href=#%e5%ae%9a%e7%be%a9quorum aria-label=定義quorum>定義quorum</a></li><li><a href=#%e6%ad%a3%e7%a2%ba%e6%80%a7 aria-label=正確性>正確性</a></li></ul></li><li><a href=#multi-paxos aria-label=multi-paxos>multi-paxos</a><ul><li><a href=#%e6%ad%a3%e7%a2%ba%e6%80%a7-1 aria-label=正確性>正確性</a></li></ul></li><li><a href=#fast-paxos aria-label="fast paxos">fast paxos</a></li><li><a href=#zab aria-label=zab>zab</a><ul><li><a href=#%e9%81%b8leader%e7%9a%84%e6%ad%a3%e7%a2%ba%e6%80%a7 aria-label=選leader的正確性>選leader的正確性</a></li></ul></li><li><a href=#raft aria-label=raft>raft</a><ul><li><a href=#%e6%ad%a3%e7%a2%ba%e6%80%a7-2 aria-label=正確性>正確性</a></li></ul></li><li><a href=#abstract-paxos aria-label=abstract-paxos>abstract-paxos</a></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>整理一下</p><h2 id=總體而言>總體而言<a hidden class=anchor aria-hidden=true href=#總體而言>#</a></h2><p><strong>在任何時間點，於不能反悔的情況下維持共識</strong></p><p>paxos與其他共識演算法都是在保護上面假設</p><p>實際如何執行?</p><ul><li>不能反悔 (資料保持最新 & 承認時間流逝)<ul><li>遞增</li><li>冪等</li><li>immutation</li></ul></li><li>共識<ul><li>多數決</li><li>單一來源</li></ul></li><li>描述時間<ul><li>序列號</li></ul></li></ul><p>下面根據paper的時間線來看</p><ul><li>basic paxos</li><li>multi-paxos</li><li>zab</li><li>raft</li></ul><h2 id=basic-paxos>basic paxos<a hidden class=anchor aria-hidden=true href=#basic-paxos>#</a></h2><p>有兩個角色，proposer與accepter
(對應到raft是leader與follower)</p><p>之後與raft不同的是paxos可以<strong>同時管理好幾個app的狀態</strong>(所以paxos可以接受不連續的log，因為log不用遞增)</p><p>在paxos就是value去區分，每個value都會帶有一個只能遞增的rnd，與當前acceptor知道的最後一個rnd(log的最後index)</p><p>paxos的proposer是任何人都能當的，但要怎麼確認自己的提案會不會被接受?
所以proposer要先問過半的accepter的最大rnd(prepare)
同時acceptor設定之後預期看到的rnd，也就是last_rnd
在下面的圖，log entry整個大概是<code>(last_rnd, value[vrnd])</code></p><p>另外，<a href=https://github.com/drmingdrmer/consensus-bugs>記得last_rnd不論何時一定大於等於vrnd</a>
不論在什麼階段，prepare或是accept</p><p><img loading=lazy src=https://blog.openacid.com/post-res/paxos/slide-imgs/paxos-20.jpg alt></p><p><img loading=lazy src=https://blog.openacid.com/post-res/paxos/slide-imgs/paxos-27.jpg alt></p><p><img loading=lazy src=https://blog.openacid.com/post-res/paxos/slide-imgs/paxos-28.jpg alt></p><p>(假設還有其他資料，像是log，就要再額外sync，見zab，不過basic paxos沒有所以這段上括號)</p><p>之後才傳資料，只要rnd(aka log)對的上就收(accept)。</p><p><img loading=lazy src=https://blog.openacid.com/post-res/paxos/slide-imgs/paxos-31.jpg alt></p><p>另外paxos這樣可能會產生livelock，只要有兩個proposer打同一個value就會產生，所以要區隔時間(raft的election timer)</p><p>到此，classic paxos可以看成quorum + 2 phase commit
原本的2 phase commit要所有人確認，但因為這是共識只要quorum到就好</p><h3 id=定義quorum>定義quorum<a hidden class=anchor aria-hidden=true href=#定義quorum>#</a></h3><p>為什麼要到quorum?
因為這樣可以確保任意讀與寫至少都會有一個有對的資料</p><p>如果只是要符合"至少都會有一個有對的資料"，這樣一定要過半嗎?
不用，像是</p><ul><li>要求每個quorum都包含一個特定點</li><li>分階層，要求quorum至少要跨一行與跨一欄</li><li>只有兩行，要求包含第一行的majority, 或在每一行都包含一个majority</li></ul><p>這樣有什麼好處與壞處?
好處: 可以以較少的數量達成quorum，如此一來可以選近的 或是 發少一點rpc
壞處: 犧牲avaibility，像是只要是包含的那個唯一的點壞了就出事了；但過半可以讓另一半壞了也ok</p><h3 id=正確性>正確性<a hidden class=anchor aria-hidden=true href=#正確性>#</a></h3><p><em>value的rnd</em>保證不反悔app狀態同時代表時間點
<em>先問過半的accepter的最大id</em>確保app狀態共識</p><h2 id=multi-paxos>multi-paxos<a hidden class=anchor aria-hidden=true href=#multi-paxos>#</a></h2><p>如果說每次都要同步log才能傳資料就很麻煩另外還有livelock的風險
所以把proposer定成一個這樣就能省下同步log的步驟</p><h3 id=正確性-1>正確性<a hidden class=anchor aria-hidden=true href=#正確性-1>#</a></h3><p>proposer只要有最新的id，之後就可以commit到acceptor，等commit完成後就proposer又會有最新的id (遞迴)</p><h2 id=fast-paxos>fast paxos<a hidden class=anchor aria-hidden=true href=#fast-paxos>#</a></h2><p>真的不想prepare!!
那就直接寫，用最小的rnd去寫。</p><p>失敗的話，還是要prepare阿
有沒有辦法在報錯時確認當前的quorum是什麼?</p><p><img loading=lazy src=https://blog.openacid.com/post-res/paxos/slide-imgs/paxos-38.jpg alt></p><p>所以quorum要變成3/4
<img loading=lazy src=https://blog.openacid.com/post-res/paxos/slide-imgs/paxos-40.jpg alt></p><h2 id=zab>zab<a hidden class=anchor aria-hidden=true href=#zab>#</a></h2><p>就是multi-paxos + 選leader</p><p>但這樣打太短要補一點東西</p><p>zab分成4個階段</p><ol><li>election</li></ol><ul><li>透過zxid來選其實就是<ul><li>term (這裡叫epoch)</li><li>id (就是paxos的id)</li></ul></li><li>之後記住自己投給誰</li></ul><ol start=2><li>discovery (prepare)</li><li>sync (sync log)</li><li>braodcast (accept)</li></ol><h3 id=選leader的正確性>選leader的正確性<a hidden class=anchor aria-hidden=true href=#選leader的正確性>#</a></h3><p>leader會壞怎麼辦?</p><ul><li>選leader也要<strong>在任何時間點，於不能反悔的情況下維持共識</strong><ul><li>所以多了term與voteFor，term表示時間、voreFor就是資料</li></ul></li></ul><h2 id=raft>raft<a hidden class=anchor aria-hidden=true href=#raft>#</a></h2><p>如果只有一個app要管而已，可以簡化設計嗎?</p><ol><li>只放一個log，那可以直接用log遞增取代id</li><li>只有一個log，可以在選leader直接認最新log的為leader
- 也因此，同步log的時機與paxos不同<ul><li>paxos因為任何人都可以當proposer，所以一開始就要sync log</li><li>raft是在成為leader之後才透過appendEntries同步log<ul><li>但可能有不一致的log，所以才有figure 8</li></ul></li></ul></li></ol><p>整個dataflow可以看成
leader -> log</p><p>因為leader要過半，所以是共識；
認leader自然imply認log； (appendEntries)
接著就是認leader不能反悔；
最後就是commit出去的不能變，所以有過半才能commit；</p><p>但是只有這樣會產生figure 8的問題，所以要多一個條件
<strong>只能在同一個term完成同一個term的事件</strong></p><p>因為只有在完成appendEntrries之後才能確認，follower的log與leader同步，而唯一能讓leader發appendEntrries只有新log或是heartbeat。</p><h3 id=正確性-2>正確性<a hidden class=anchor aria-hidden=true href=#正確性-2>#</a></h3><ol><li>不能反悔</li></ol><ul><li>term只能遞增<ul><li>只能在同一個term完成同一個term的事件 (第一個處理亂序與crash的手法)</li></ul></li><li>leader的log只能遞增</li></ul><ol start=2><li>共識</li></ol><ul><li>每個term的leader最多一個<ul><li>用誰的log比較新決定leader<ul><li>認term與log對不對得起來</li></ul></li></ul></li><li>leader持有夠新的log且過半(一樣新或是比較舊)<ul><li>log最新的log會過半<ul><li>有新log會reject其他candidate</li><li>follower會與leader的log同步<ul><li>merge相符但是比較短的entries (第二個處理亂序的手法)</li><li>砍掉開始不一樣的log</li></ul></li></ul></li></ul></li><li>過半才做下一個步驟<ul><li>成為leader (leader最多一個)</li><li>commit log上去 (確定新的log占多數)</li></ul></li></ul><ol start=3><li>在同一個term完成同一個term的事件 (raft獨有)</li></ol><ul><li>figure 8<ul><li>因為是等到appendEntrries才sync log (類似lazy eval)</li><li>變成只能在自己的term才能確認log是對的<ul><li>但是只要確認就能利用 multi-paxos的遞迴 確認前面的log也是對的!!</li></ul></li></ul></li></ul><h2 id=abstract-paxos>abstract-paxos<a hidden class=anchor aria-hidden=true href=#abstract-paxos>#</a></h2><p><a href=https://blog.openacid.com/algo/abstract-paxos/>将 paxos 和 raft 统一到一个协议下: abstract-paxos</a></p><p>這篇就是把原po的quorum與paxos組合在一起，從phase2開始講到phase1</p><p>先有兩個腳色，reader與writer</p><p>我們的algo要保證下面的性質</p><ol><li>commit-寫quorum: 以保證任何 reader 都可讀到.</li><li>commit-唯一: 以保證多個 reader 返回相同的結果.</li><li>commit後不能修改: 以保證多次讀返回同樣的結果.</li></ol><p>第一點就是寫quorum</p><p>第二與三點就需要能夠比較不同writer的手段(全序關係)，所以寫入的值需要一個commit_index，讓reader知道要拿那個value</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>State</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>log</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>commit_index</span>: <span class=kt>u64</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cmd</span>: <span class=nc>Cmd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>paxos叫vrnd，raft叫term</p><p>剛剛是reader的，接著是writer的唯一與不可修改
會破壞writer的唯一與不可修改就是有沒有可能要寫之前有其他人要寫呢?
所以我們需要一個機制讓對方承諾說不會接受舊的寫入</p><p>所以就再多一個commit_index</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>commit_index</span>: <span class=kt>u64</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>state</span>: <span class=nc>State</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>paxos叫rnd，raft叫term與voteFor</p><p>這樣就有兩個phase</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>handle_phase_1</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>p1_req</span>: <span class=nc>P1Req</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>p1_reply</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>P1Reply</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>commit_index</span>: <span class=nc>self</span><span class=p>.</span><span class=n>commit_index</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>state</span>: <span class=nc>self</span><span class=p>.</span><span class=n>state</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>commit_index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>max</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>commit_index</span><span class=p>,</span><span class=w> </span><span class=n>p1_req</span><span class=p>.</span><span class=n>commit_index</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>p1_reply</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>handle_phase_2</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>p2_req</span>: <span class=nc>P2Req</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>p2_reply</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>P2Reply</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>commit_index</span>: <span class=nc>self</span><span class=p>.</span><span class=n>commit_index</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>p2_req</span><span class=p>.</span><span class=n>commit_index</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>commit_index</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>state</span><span class=p>.</span><span class=n>update</span><span class=p>(</span><span class=n>p2_req</span><span class=p>.</span><span class=n>state</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>commit_index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>max</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>commit_index</span><span class=p>,</span><span class=w> </span><span class=n>p2_req</span><span class=p>.</span><span class=n>commit_index</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>p2_reply</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>注意到<code>self.commit_index = max(self.commit_index, p2_req.commit_index)</code>
這裡就是說node的commit_index一定大於等於state最後一個的commit_index
這邊也可以從writer的角度來看為什麼raft只能在自己的term做commit</p><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://blog.openacid.com/algo/paxos/>可靠分布式系统-paxos的直观解释</a>
<a href=https://blog.openacid.com/algo/quorum/>后分布式时代: 多数派读写的’少数派’实现</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/distributed/>Distributed</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2022/03/rendezvous-hash%E8%88%87consistent-hash/><span class=title>« Prev</span><br><span>rendezvous hash與consistent hash</span>
</a><a class=next href=https://littlebees.github.io/2022/03/mit-6.824-2022-%E5%AF%A6%E9%A9%97%E7%AD%86%E8%A8%98/><span class=title>Next »</span><br><span>mit 6.824 2022 實驗筆記</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>