<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>記憶體模型筆記 | 記事本</title>
<meta name=keywords content><meta name=description content="動機
之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/06/%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%9E%8B%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/06/%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%9E%8B%E7%AD%86%E8%A8%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="記憶體模型筆記"><meta property="og:description" content="動機
之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/06/%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%9E%8B%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-27T19:02:08+00:00"><meta property="article:modified_time" content="2021-06-27T19:02:08+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="記憶體模型筆記"><meta name=twitter:description content="動機
之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"記憶體模型筆記","item":"https://littlebees.github.io/2021/06/%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%9E%8B%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"記憶體模型筆記","name":"記憶體模型筆記","description":"動機 之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了\n","keywords":[],"articleBody":"動機 之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了\n原子性、可見性 原子性: 全都完成，不然就是根本沒做 race condition primitive有可能不是atomic java的long與double就不是 大部分arch可以讓32bit的資料atomic 但long與double不是阿 就可能要分兩次，這樣就出事了 C++的atomic類別 C++支援struct，但是struct的大小不一定 如果有align那好說，但是如果沒有compiler就要自己動手腳(好麻煩) Word Tearing 更新相鄰的資料時，會影響到隔壁!? 像boolean在java是1byte! 這與arch能處理的最小單位有關，大部分arch是8bits 所以要更新就要一次跑1byte 可以同時跑2個thread做java的BitSet(可以想成byte[])set 可能只更新其中一位或是兩位都更新 因為是做bitwise，所以是一次更新1byte 可見性: 在後面的指令能看到前面的影響 reorder與亂序執行 不同arch的reorder規則 強(只准store-load): x86, sparc-tso 弱(LL,LS,SS,SL都可): powerpc, ia64, arm 資料相依 write-read, write-write, read-write 這在任何arch都不會被reorder，但僅限single thread的scope smp與multi-thread之間沒有 (所以需要後面的規則) cache 順序性: 前面跑完才能跑後面 reorder是會保證single thread中的code與reorder前跑出來的結果是一樣的 java memory model happen-before(hb) 在放在A指令之前的指令所做出的改變，A指令一定看的到\n同一個scope中具有順序性 在同一thread中，前一條指令對後一條指令是happen-before 前一個synchronized的解鎖，對後一個synchronized的加鎖是happen-before 先寫後讀 (先啟動後執行) 一個volatile的寫，對後續任何volatile的讀是happen-before thread的start，對該thread的所有指令是happen-before thread的interrupt，對所有檢查interrupt的指令是happen-before thread的join，對所有檢查thread存活的指令是happen-before obj初始化，對obj的finalize是happen-before A hb B，且B hb C，則A hb C causality (因果關係) 下面是無中生有(out-of-thin-air)的其中一種例子 foo被reorder成foo2，就happen-before而言，這沒錯，但執行下去就出事\n// x == y == 0 void foo(){ r1=x; if(r1 != 0) y=42; } /* void foo2(){ y=42; r1=x; if(r1 != 0) y=0; } */ ​ void bar(){ r2 = y; if(r2 != 0) x=42; } // r1==r2==42? 為了防止這種事發生，才有causality檢查\n根據\n控制流 資料相依 去看執行結果會不會有奇怪的東西\n關於如何檢查，我看了好久還是不太懂，在ref有範例，等PLT的功力回來再說吧\n實際上的做法是 保持原子性 volatile (++是複合動作，要注意) 原本volatile只是確保取值都從mem拿，確保可見性 但java memory model保證volatile讀寫比較不會被reorder，進而保證了原子性(只有一寫對一個以上的讀才有!!) 但沒有mutual exclusion，所以如果很多thread一起攻擊的話就會出事，可以看下面的code synchronized 上barrier與禁止reorder，保持可見性與順序性 java的volatile 一個加一個減，照理來說要是0\npublic class Main { public static volatile int race = 0; private static final int INCREASE_COUNT = 10000; public static void main (String[] args) { Thread[] threads = new Thread[2]; System.out.println(System.currentTimeMillis()); threads[0] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u003c INCREASE_COUNT; i++) { race++; } } }); threads[1] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u003c INCREASE_COUNT; i++) { race--; } } }); threads[0].start(); threads[1].start(); while (Thread.activeCount() \u003e 1) { Thread.yield(); } System.out.println(System.currentTimeMillis()); System.out.println(race); } } volatile的happen-before是寫之後可以被所有讀看到，但是剛剛是一個讀前面有一堆寫 要處理這件事就是加個條件，在不符合條件時就不做事，確保只有一個寫\npublic class Main { public static volatile int race = 0; private static final int INCREASE_COUNT = 10000000; public static void main (String[] args) { Thread[] threads = new Thread[2]; System.out.println(System.currentTimeMillis()); threads[0] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u003c INCREASE_COUNT; i++) { if (race \u003c= 0) { race++; } else { i--; } } } }); threads[1] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u003c INCREASE_COUNT; i++) { if (race \u003e 0) { race--; } else { i--; } } } }); threads[0].start(); threads[1].start(); while (Thread.activeCount() \u003e 1) { Thread.yield(); } System.out.println(System.currentTimeMillis()); System.out.println(race); } } 所以如果真的需要就是用AtomicInteger，同時我用jdoodle去跑明顯這個比較快 因為不是每次的loop都會做事，可能有不做事的時候，導致時間的浪費\nimport java.util.concurrent.atomic.AtomicInteger; public class Main { public static AtomicInteger race = new AtomicInteger(); private static final int INCREASE_COUNT = 10000000; public static void main (String[] args) { Thread[] threads = new Thread[2]; System.out.println(System.currentTimeMillis()); threads[0] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u003c INCREASE_COUNT; i++) { race.incrementAndGet(); } } }); threads[1] = new Thread(new Runnable() { @Override public void run () { for (int i = 0; i \u003c INCREASE_COUNT; i++) { race.decrementAndGet(); } } }); threads[0].start(); threads[1].start(); while (Thread.activeCount() \u003e 1) { Thread.yield(); } System.out.println(System.currentTimeMillis()); System.out.println(race); } } 建到一半的物件 Double-Checked Locking 用在multi-thread生singlton，但是會出事\nclass Foo { private Helper helper = null; public Helper getHelper() { if (helper == null) { synchronized(this) { if (helper == null) helper = new Helper(); } } return helper; } } 在設定helper的值時，可以reorder成\n先給ref 之後init物件 但拿到ref就會讓if過，最後有人會拿到建到一半的物件\n其中一個解法是volatile，因為不會reorder\nclass Foo { private volatile Helper helper = null; public Helper getHelper() { if (helper == null) { synchronized(this) { if (helper == null) helper = new Helper(); } } return helper; } } 另一個解法是static的field，class初始化完static要存在可以利用這個特點\nprivate static class LazyFooHolder { public static Foo foo = new Foo(); } public static Foo getInstance() { return LazyFooHolder.foo; } final field java memory model保證任何access final的thread會看到freeze後的資料\n中間是藉由禁reorder(freeze不能在設值前發生，access不能再freeze前發生)\n但有趣的是，如果把this傳出去就不一定了\nObj1 obj = new Obj1(); final_field = 42; ptr1 = this; //freeze final_field ptr2 = this; 如果有thread看到ptr1，就直接去用，這樣就無法保證一定看的到final_field，因為設定ptr的指令可能被reorder，最後ptr1拿到的就是建到一半的物件(連final都還沒跑完)\ncpp memory model 基本就是基於java memory model，但多了可以控制atomic的memory barrier可以寬到哪邊去\n介紹memory barrier 就是控制reorder不要讓指令跑過barrier\n而指令可以分成Load或Store，所以有四種case\nLoadStore LoadLoad LoadLoad + LoadStore組成Acquire semantics java的volatile的寫與cpp的memory_order_acquire StoreStore StoreStore + LoadStore組成Release semantics java的volatile的讀與cpp的memory_order_release StoreLoad 只有這個是強與弱memory model都可以reorder的，所以call這個一定會有事發生 barrier有cpu版與compiler版，效力自然是cpu比較大\nmemory_order memory_order_relaxed 就是沒有barrier，只剩下原子性 memory_order_acquire 在這點之後的所有write與自己的read不會超過這裡 可以想成是第一個write，然後後面有很多其他write與自己的read 更形象一點可以想成上蓋 對應到java的volatile寫 memory_order_consume 與memory_order_acquire很像 但是只限制與目前變數有關的write不超過這邊 memory_order_release 在這點之後的所有write與自己的read不會超過這裡 可以想成是最後一個read，然後前面有很多其他write與自己的read 更形象一點可以想成下底 對應到java的volatile讀 memory_order_acq_rel acquire + release 這感覺就很像楚河漢界，上半部與下半部不會混在一起 memory_order_seq_cst 就是java的volatile，照順序來 臨時追加: ABA問題 主要是在lock-free才會提到，因為會看修改前與修改後沒有內容是不是沒被動過，但是如果只是看起來沒被動過?\nABA問題有三個條件\n重複讀某變數，同時只用此變數做condtion 每次讀與寫都沒有同步 被多個thread修改，值有可能變回去以前的某一個值 如何處理 加入一個變數，只能單調遞增 在做cond時除了看原本的變數，這個單調遞增的變數也要看\n轉帳問題 1. 小琳在 ATM 1 转账 100 块钱给小李； 2. 由于ATM 1 出现了网络拥塞的原因卡住了，这时候小琳跑到旁边的 ATM 2 再次操作转账；(有兩次轉帳) 3. ATM 2 没让小琳失望，执行了 CAS(100,0)，很痛快地完成了转账，此时小琳的账户余额为 0；(第一次轉帳) 4. 小王这时候又给小琳账上转了 100，此时小琳账上余额为 100； 5. 这时候 ATM 1 网络恢复，继续执行 CAS(100,0)，居然执行成功了，小琳账户上余额又变为了 0；(第二次轉帳) 6. 这时候小王微信跟小琳说转了 100 过去，是否收到呢？小琳去查了下账，摇了摇头，那么问题来了，钱去了哪呢？ Ref The Java Memory Model(這個有因果關係檢查的範例) Java Memory Model Pragmatics(人性化很多，適合第一次看) JSR-133 Review(中文的，解釋得很好) 对优化说不 - Linux中的Barrier ABA problem\n","wordCount":"683","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-06-27T19:02:08Z","dateModified":"2021-06-27T19:02:08Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/06/%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%9E%8B%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">記憶體模型筆記</h1><div class=post-meta><span title='2021-06-27 19:02:08 +0000 UTC'>June 27, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e5%8e%9f%e5%ad%90%e6%80%a7%e5%8f%af%e8%a6%8b%e6%80%a7 aria-label=原子性、可見性>原子性、可見性</a></li><li><a href=#java-memory-model aria-label="java memory model">java memory model</a><ul><li><a href=#happen-beforehb aria-label=happen-before(hb)>happen-before(hb)</a></li><li><a href=#causality-%e5%9b%a0%e6%9e%9c%e9%97%9c%e4%bf%82 aria-label="causality (因果關係)">causality (因果關係)</a></li><li><a href=#%e5%af%a6%e9%9a%9b%e4%b8%8a%e7%9a%84%e5%81%9a%e6%b3%95%e6%98%af aria-label=實際上的做法是>實際上的做法是</a></li><li><a href=#java%e7%9a%84volatile aria-label=java的volatile>java的volatile</a></li><li><a href=#%e5%bb%ba%e5%88%b0%e4%b8%80%e5%8d%8a%e7%9a%84%e7%89%a9%e4%bb%b6 aria-label=建到一半的物件>建到一半的物件</a><ul><li><a href=#double-checked-locking aria-label="Double-Checked Locking">Double-Checked Locking</a></li><li><a href=#final-field aria-label="final field">final field</a></li></ul></li></ul></li><li><a href=#cpp-memory-model aria-label="cpp memory model">cpp memory model</a><ul><li><a href=#%e4%bb%8b%e7%b4%b9memory-barrier aria-label="介紹memory barrier">介紹memory barrier</a></li><li><a href=#memory_order aria-label=memory_order>memory_order</a></li></ul></li><li><a href=#%e8%87%a8%e6%99%82%e8%bf%bd%e5%8a%a0-aba%e5%95%8f%e9%a1%8c aria-label="臨時追加: ABA問題">臨時追加: ABA問題</a><ul><li><a href=#%e5%a6%82%e4%bd%95%e8%99%95%e7%90%86 aria-label=如何處理>如何處理</a></li><li><a href=#%e8%bd%89%e5%b8%b3%e5%95%8f%e9%a1%8c aria-label=轉帳問題>轉帳問題</a></li></ul></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>之前看完linux kernel的同步方式，對同步有新的理解，可以重新面對這個話題了</p><h2 id=原子性可見性>原子性、可見性<a hidden class=anchor aria-hidden=true href=#原子性可見性>#</a></h2><ul><li>原子性: 全都完成，不然就是根本沒做<ul><li>race condition</li><li>primitive有可能不是atomic<ul><li>java的long與double就不是<ul><li>大部分arch可以讓32bit的資料atomic</li><li>但long與double不是阿</li><li>就可能要分兩次，這樣就出事了</li></ul></li><li>C++的atomic類別<ul><li>C++支援struct，但是struct的大小不一定</li><li>如果有align那好說，但是如果沒有compiler就要自己動手腳(好麻煩)</li></ul></li><li>Word Tearing<ul><li>更新相鄰的資料時，會影響到隔壁!?</li><li>像boolean在java是1byte!<ul><li>這與arch能處理的最小單位有關，大部分arch是8bits</li><li>所以要更新就要一次跑1byte</li></ul></li><li>可以同時跑2個thread做java的BitSet(可以想成byte[])set<ul><li>可能只更新其中一位或是兩位都更新</li><li>因為是做bitwise，所以是一次更新1byte</li></ul></li></ul></li></ul></li></ul></li><li>可見性: 在後面的指令能看到前面的影響<ul><li>reorder與亂序執行<ul><li>不同arch的reorder規則<ul><li>強(只准store-load): x86, sparc-tso</li><li>弱(LL,LS,SS,SL都可): powerpc, ia64, arm</li></ul></li><li>資料相依<ul><li>write-read, write-write, read-write</li><li>這在任何arch都不會被reorder，但僅限single thread的scope<ul><li>smp與multi-thread之間沒有 (所以需要後面的規則)</li></ul></li></ul></li></ul></li><li>cache</li></ul></li><li>順序性: 前面跑完才能跑後面<ul><li>reorder是會保證single thread中的code與reorder前跑出來的結果是一樣的</li></ul></li></ul><h2 id=java-memory-model>java memory model<a hidden class=anchor aria-hidden=true href=#java-memory-model>#</a></h2><h3 id=happen-beforehb>happen-before(hb)<a hidden class=anchor aria-hidden=true href=#happen-beforehb>#</a></h3><p>在放在A指令之前的指令所做出的改變，A指令一定看的到</p><ul><li>同一個scope中具有順序性<ul><li>在同一thread中，前一條指令對後一條指令是happen-before</li><li>前一個synchronized的解鎖，對後一個synchronized的加鎖是happen-before</li></ul></li><li>先寫後讀 (先啟動後執行)<ul><li>一個volatile的寫，對後續任何volatile的讀是happen-before</li><li>thread的start，對該thread的所有指令是happen-before</li><li>thread的interrupt，對所有檢查interrupt的指令是happen-before</li><li>thread的join，對所有檢查thread存活的指令是happen-before</li><li>obj初始化，對obj的finalize是happen-before</li></ul></li><li>A hb B，且B hb C，則A hb C</li></ul><h3 id=causality-因果關係>causality (因果關係)<a hidden class=anchor aria-hidden=true href=#causality-因果關係>#</a></h3><p>下面是無中生有(out-of-thin-air)的其中一種例子
foo被reorder成foo2，就happen-before而言，這沒錯，但執行下去就出事</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// x == y == 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>foo</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=n>r1</span><span class=o>=</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>r1</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>=</span><span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>void foo2(){
</span></span></span><span class=line><span class=cl><span class=cm>  y=42;
</span></span></span><span class=line><span class=cl><span class=cm>  r1=x;
</span></span></span><span class=line><span class=cl><span class=cm>  if(r1 != 0)
</span></span></span><span class=line><span class=cl><span class=cm>    y=0;
</span></span></span><span class=line><span class=cl><span class=cm>}
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=err>​</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>bar</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=n>r2</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>r2</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=n>x</span><span class=o>=</span><span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// r1==r2==42?
</span></span></span></code></pre></div><p>為了防止這種事發生，才有causality檢查</p><p>根據</p><ul><li>控制流</li><li>資料相依</li></ul><p>去看執行結果會不會有奇怪的東西</p><p>關於如何檢查，我看了好久還是不太懂，在ref有範例，等PLT的功力回來再說吧</p><h3 id=實際上的做法是>實際上的做法是<a hidden class=anchor aria-hidden=true href=#實際上的做法是>#</a></h3><ol><li>保持原子性</li></ol><ul><li>volatile (++是複合動作，要注意)<ul><li>原本volatile只是確保取值都從mem拿，確保可見性</li><li>但java memory model保證volatile讀寫比較不會被reorder，進而保證了原子性(只有一寫對一個以上的讀才有!!)<ul><li>但沒有mutual exclusion，所以如果很多thread一起攻擊的話就會出事，可以看下面的code</li></ul></li></ul></li><li>synchronized</li></ul><ol start=2><li>上barrier與禁止reorder，保持可見性與順序性</li></ol><h3 id=java的volatile>java的volatile<a hidden class=anchor aria-hidden=true href=#java的volatile>#</a></h3><p>一個加一個減，照理來說要是0</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>race</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=w> </span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=o>[]</span><span class=w> </span><span class=n>threads</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>race</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>race</span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>Thread</span><span class=p>.</span><span class=na>activeCount</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=n>Thread</span><span class=p>.</span><span class=na>yield</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>race</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>volatile的happen-before是寫之後可以被所有讀看到，但是剛剛是一個讀前面有一堆寫
要處理這件事就是加個條件，在不符合條件時就不做事，確保只有一個寫</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>race</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10000000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=w> </span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=o>[]</span><span class=w> </span><span class=n>threads</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>race</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>race</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>i</span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>race</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>race</span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>i</span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>Thread</span><span class=p>.</span><span class=na>activeCount</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=n>Thread</span><span class=p>.</span><span class=na>yield</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>race</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>所以如果真的需要就是用AtomicInteger，同時我用<a href=www.jdoodle.com>jdoodle</a>去跑明顯這個比較快
因為不是每次的loop都會做事，可能有不做事的時候，導致時間的浪費</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.concurrent.atomic.AtomicInteger</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>AtomicInteger</span><span class=w> </span><span class=n>race</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicInteger</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10000000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=w> </span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=o>[]</span><span class=w> </span><span class=n>threads</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>race</span><span class=p>.</span><span class=na>incrementAndGet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>INCREASE_COUNT</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>race</span><span class=p>.</span><span class=na>decrementAndGet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>threads</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>Thread</span><span class=p>.</span><span class=na>activeCount</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=n>Thread</span><span class=p>.</span><span class=na>yield</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>race</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=建到一半的物件>建到一半的物件<a hidden class=anchor aria-hidden=true href=#建到一半的物件>#</a></h3><h4 id=double-checked-locking>Double-Checked Locking<a hidden class=anchor aria-hidden=true href=#double-checked-locking>#</a></h4><p>用在multi-thread生singlton，但是會出事</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Foo</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Helper</span><span class=w> </span><span class=n>helper</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Helper</span><span class=w> </span><span class=nf>getHelper</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>helper</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>synchronized</span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>helper</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>helper</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Helper</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>helper</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在設定helper的值時，可以reorder成</p><ol><li>先給ref</li><li>之後init物件</li></ol><p>但拿到ref就會讓if過，最後有人會拿到建到一半的物件</p><p>其中一個解法是volatile，因為不會reorder</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Foo</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=n>Helper</span><span class=w> </span><span class=n>helper</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Helper</span><span class=w> </span><span class=nf>getHelper</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>helper</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>synchronized</span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>helper</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>helper</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Helper</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>helper</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>另一個解法是static的field，class初始化完static要存在可以利用這個特點</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>LazyFooHolder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Foo</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Foo</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Foo</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>LazyFooHolder</span><span class=p>.</span><span class=na>foo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=final-field>final field<a hidden class=anchor aria-hidden=true href=#final-field>#</a></h4><p>java memory model保證任何access final的thread會看到freeze後的資料</p><p>中間是藉由禁reorder(freeze不能在設值前發生，access不能再freeze前發生)</p><p>但有趣的是，如果把this傳出去就不一定了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Obj1</span><span class=w> </span><span class=n>obj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Obj1</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>final_field</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>42</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ptr1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//freeze final_field</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ptr2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>如果有thread看到ptr1，就直接去用，這樣就無法保證一定看的到final_field，因為設定ptr的指令可能被reorder，最後ptr1拿到的就是建到一半的物件(連final都還沒跑完)</p><h2 id=cpp-memory-model>cpp memory model<a hidden class=anchor aria-hidden=true href=#cpp-memory-model>#</a></h2><p>基本就是基於java memory model，但多了可以控制atomic的memory barrier可以寬到哪邊去</p><h3 id=介紹memory-barrier>介紹memory barrier<a hidden class=anchor aria-hidden=true href=#介紹memory-barrier>#</a></h3><p>就是控制reorder不要讓指令跑過barrier</p><p>而指令可以分成Load或Store，所以有四種case</p><ul><li>LoadStore</li><li>LoadLoad<ul><li>LoadLoad + LoadStore組成Acquire semantics</li><li>java的volatile的寫與cpp的memory_order_acquire</li></ul></li><li>StoreStore<ul><li>StoreStore + LoadStore組成Release semantics</li><li>java的volatile的讀與cpp的memory_order_release</li></ul></li><li>StoreLoad<ul><li>只有這個是強與弱memory model都可以reorder的，所以call這個一定會有事發生</li></ul></li></ul><p>barrier有cpu版與compiler版，效力自然是cpu比較大</p><h3 id=memory_order>memory_order<a hidden class=anchor aria-hidden=true href=#memory_order>#</a></h3><ul><li>memory_order_relaxed<ul><li>就是沒有barrier，只剩下原子性</li></ul></li><li>memory_order_acquire<ul><li>在這點之後的所有write與自己的read不會超過這裡</li><li>可以想成是第一個write，然後後面有很多其他write與自己的read</li><li>更形象一點可以想成上蓋</li><li>對應到java的volatile寫</li></ul></li><li>memory_order_consume<ul><li>與memory_order_acquire很像</li><li>但是只限制與目前變數有關的write不超過這邊</li></ul></li><li>memory_order_release<ul><li>在這點之後的所有write與自己的read不會超過這裡</li><li>可以想成是最後一個read，然後前面有很多其他write與自己的read</li><li>更形象一點可以想成下底</li><li>對應到java的volatile讀</li></ul></li><li>memory_order_acq_rel<ul><li>acquire + release</li><li>這感覺就很像楚河漢界，上半部與下半部不會混在一起</li></ul></li><li>memory_order_seq_cst<ul><li>就是java的volatile，照順序來</li></ul></li></ul><h2 id=臨時追加-aba問題>臨時追加: ABA問題<a hidden class=anchor aria-hidden=true href=#臨時追加-aba問題>#</a></h2><p>主要是在lock-free才會提到，因為會看修改前與修改後沒有內容是不是沒被動過，但是如果只是看起來沒被動過?</p><p>ABA問題有三個條件</p><ol><li>重複讀某變數，同時只用此變數做condtion</li><li>每次讀與寫都沒有同步</li><li>被多個thread修改，值有可能變回去以前的某一個值</li></ol><h3 id=如何處理>如何處理<a hidden class=anchor aria-hidden=true href=#如何處理>#</a></h3><p>加入一個變數，只能單調遞增
在做cond時除了看原本的變數，這個單調遞增的變數也要看</p><h3 id=轉帳問題>轉帳問題<a hidden class=anchor aria-hidden=true href=#轉帳問題>#</a></h3><pre tabindex=0><code>1. 小琳在 ATM 1 转账 100 块钱给小李；
2. 由于ATM 1 出现了网络拥塞的原因卡住了，这时候小琳跑到旁边的 ATM 2 再次操作转账；(有兩次轉帳)
3. ATM 2 没让小琳失望，执行了 CAS(100,0)，很痛快地完成了转账，此时小琳的账户余额为 0；(第一次轉帳)
4. 小王这时候又给小琳账上转了 100，此时小琳账上余额为 100；
5. 这时候 ATM 1 网络恢复，继续执行 CAS(100,0)，居然执行成功了，小琳账户上余额又变为了 0；(第二次轉帳)
6. 这时候小王微信跟小琳说转了 100 过去，是否收到呢？小琳去查了下账，摇了摇头，那么问题来了，钱去了哪呢？
</code></pre><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://www.cs.rice.edu/~johnmc/comp522/lecture-notes/COMP522-2019-Java-Memory-Model.pdf>The Java Memory Model(這個有因果關係檢查的範例)</a>
<a href=https://shipilev.net/blog/2014/jmm-pragmatics/>Java Memory Model Pragmatics(人性化很多，適合第一次看)</a>
<a href=https://zhuanlan.zhihu.com/p/75509358>JSR-133 Review(中文的，解釋得很好)</a>
<a href=https://zhuanlan.zhihu.com/p/96001570>对优化说不 - Linux中的Barrier</a>
<a href=https://zhuanlan.zhihu.com/p/110301415>ABA problem</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/06/%E7%94%A8twisted%E8%BF%85%E9%80%9F%E6%9E%B6%E7%B0%A1%E5%96%AE%E7%9A%84server/><span class=title>« Prev</span><br><span>用twisted迅速架簡單的server</span>
</a><a class=next href=https://littlebees.github.io/2021/06/linux-kernel-development-3rd%E7%AD%86%E8%A8%98/><span class=title>Next »</span><br><span>Linux Kernel Development 3rd筆記</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>