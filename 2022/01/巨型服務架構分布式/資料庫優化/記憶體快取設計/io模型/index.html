<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>巨型服務架構：分布式/資料庫優化/記憶體快取設計/IO模型 | 記事本</title>
<meta name=keywords content="Distributed"><meta name=description content="動機
查漏補缺"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2022/01/%E5%B7%A8%E5%9E%8B%E6%9C%8D%E5%8B%99%E6%9E%B6%E6%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B3%87%E6%96%99%E5%BA%AB%E5%84%AA%E5%8C%96/%E8%A8%98%E6%86%B6%E9%AB%94%E5%BF%AB%E5%8F%96%E8%A8%AD%E8%A8%88/io%E6%A8%A1%E5%9E%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2022/01/%E5%B7%A8%E5%9E%8B%E6%9C%8D%E5%8B%99%E6%9E%B6%E6%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B3%87%E6%96%99%E5%BA%AB%E5%84%AA%E5%8C%96/%E8%A8%98%E6%86%B6%E9%AB%94%E5%BF%AB%E5%8F%96%E8%A8%AD%E8%A8%88/io%E6%A8%A1%E5%9E%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="巨型服務架構：分布式/資料庫優化/記憶體快取設計/IO模型"><meta property="og:description" content="動機
查漏補缺"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2022/01/%E5%B7%A8%E5%9E%8B%E6%9C%8D%E5%8B%99%E6%9E%B6%E6%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B3%87%E6%96%99%E5%BA%AB%E5%84%AA%E5%8C%96/%E8%A8%98%E6%86%B6%E9%AB%94%E5%BF%AB%E5%8F%96%E8%A8%AD%E8%A8%88/io%E6%A8%A1%E5%9E%8B/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-17T10:31:32+00:00"><meta property="article:modified_time" content="2022-01-17T10:31:32+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="巨型服務架構：分布式/資料庫優化/記憶體快取設計/IO模型"><meta name=twitter:description content="動機
查漏補缺"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"巨型服務架構：分布式/資料庫優化/記憶體快取設計/IO模型","item":"https://littlebees.github.io/2022/01/%E5%B7%A8%E5%9E%8B%E6%9C%8D%E5%8B%99%E6%9E%B6%E6%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B3%87%E6%96%99%E5%BA%AB%E5%84%AA%E5%8C%96/%E8%A8%98%E6%86%B6%E9%AB%94%E5%BF%AB%E5%8F%96%E8%A8%AD%E8%A8%88/io%E6%A8%A1%E5%9E%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"巨型服務架構：分布式/資料庫優化/記憶體快取設計/IO模型","name":"巨型服務架構：分布式\/資料庫優化\/記憶體快取設計\/IO模型","description":"動機 查漏補缺\n","keywords":["Distributed"],"articleBody":"動機 查漏補缺\nch1: 高性能架構 效能指標 throughput TPS(transaction per second) QPS(queries per second) 併發數 同時處理的數目: 同時在線user, 併發連線數… response time amdahl’s law 可靠度指標 無故障時間 指標之間的影響 throughput \u0026 併發數 (一開始) 併發數上升 =\u003e throughput上升 (持平) 併發數上升 =\u003e throughput不變 系統臨界點 (下降) 併發數上升 =\u003e throughput下降 系統隨時都會崩潰 併發數 \u0026 response time (併發req數目) m/m/1的平均時間公式 service的處理rate(mu那一個, 系統可以承受的最大併發數) (一開始) req的數目小於系統可以承受的最大併發數，response time上升不明顯 (過了可以承受的最大併發數) response time急速增加 系統中觀察到正在處理的req/thread數目 response time大 =\u003e 卡在system中的req/thread會比較多!! ch2: 分流設計 CDN 優點 減少系統併發數 減少response time 減少網路壅塞 原理 多個CDN node，DNS做query時根據使用者位置回傳最近的ip CDN node會變成cache proxy，有就回傳；沒有就relay req到主機 可以把CDN對地址動手腳的方法用到service discovery\nservice discovery 服務註冊 user: 去registry找service的實際位置 registry: 維護service的清單 server: 要把自己登記到registry 服務規則 user: 去registry找service地址的使用規則 registry: 放service地址的使用規則，讓user自己判斷要去哪 server: 要開發或是營運去調整規則 反向代理 由proxy分配req到不同的server (追求load balance就是load balancer；server的任務都不同就是一般的反向代理)\n原理 level 4: 只看ip與port做分配 level 7: 看req內容作分配，eg: http, ftp… 對外面來說，ip與port都是一樣的!! ch3: 服務平行設計 叢集: 有很多同樣的server的set，一起提供服務 server無狀態 無狀態的節點叢集 一般都是負責query之類沒有狀態的服務 平行喚醒問題 在這個set加入定時寄信功能 結果所有server一起寄信!? 解法: 外部喚醒 打req進來，跑功能，這樣就只會有一台跑 server有狀態 server自己維護狀態 要與別人share 資訊一致的節點叢集 大家都有自己的狀態，但需要與其他server的狀態同步 一致性問題(讀寫不一致): 我在A改的，在B看不到 一致性的等級 強一致性 2 phases commit 3 phases commit 最終一致性 有retry的msg queue 不要與別人share 單一服務節點叢集 user與server是被綁定的!! how to bind? user指定 online game的選server 根據位置、user id 先隨便assign，把server位置寫到cookie中 單點失敗 server把狀態抽出去 資訊共用的節點叢集 在redis之類的地方紀錄state，像是session redis之類的地方 會是bottleneck 需要concurrent的控制 分散式系統 把server中的(實體/虛擬)元件拆掉，像web server與DB跑在不同host 如果有元件是bottlebeck，可以用叢集拆掉 一致性問題(讀寫不一致): 我在A改的，在B看不到 同資訊一致的節點叢集 所有元件是可組合的? 微服務系統 ch4: 運算併發 多process 可能在不同的cpu跑(平行)，也可能在同一顆跑(共時) 具有很強的隔離 像是開兩個server在process 可以兩個指定不同的port，就有兩台獨立的server ctx switch的成本高 cache要預熱 在userspace與kernel space之間切換 reg的切換 IPC不好做 sync 使用情境 獨佔 (競爭) 協作: 等對方好了在一起走 獨佔、協作的詳細介紹，去看Parallel Thinking 多thread 可能在不同的cpu跑(平行)，也可能在同一顆跑(共時) ctx switch的成本小 都在同一塊記憶體 有locality 使用情境 做非同步 (會block的工作) 處理subtask，之後merge sync 使用情境 獨佔 (競爭) 協作: 等對方好了在一起走 獨佔、協作的詳細介紹，去看Parallel Thinking fiber就是continuation 只能在同一顆跑(共時) 執行fiber就會停下當下的動作，之後執行會回到原本的位置 不會race condition 不會平行是concurrent!! ctx switch的代價很小 sync 使用情境 協作: 等對方好了在一起走 ch5: 輸入輸出設計 去看之前的文章\nch6: 資料庫設計與最佳化 設計table 當成設計class，但是只有primitive與reference而已 array要轉90度，變成table (NF1) 所有的欄位(primitive)可以是來自 自己本身的屬性 另一個物件展開的結果 (NF2, NF2, BCNF, 反正規化) 去看之前的文章 index 故障 一個col做index 上index的column做修改 用錯type去query (string卻用成int，雖然會被cast，但index會失效) 多個col做index (Btree) query沒有包含前面的col(左手邊) index從第一個col開始sort，一直下去，所以做query時需要前面的 (hash) 沒有全部的col 對string做index 如果有wildcast, btree與hash都會沒用，要用inverted index btree !=, \u003c\u003e, NOT IN, NOT IN IN =\u003e BETWEEN null index沒辦法對null做任何事 用其他值代替!! 不同的engine不同的index (與其他) innoDB會把hash自動換成btree (innoDB沒有做hash) 自建交易 可以undo的action沒差 不能undo的action(對外界有影響) 最多只能有一個 只能在最後一位 資料太多了 table分區 (partition) 把一個table(file)分成多個檔案 對於table的操作不變 (在外面來看這個table還是一樣) 可以存到不同的HDD 增加throughput 增加能存的entry數量 可以針對某一區做操作，不影響其他區 query最好要把當初做分區的條件放入query 不然要所有分區都跑 分庫 把DB切開 table怎麼辦? 分table 分table 不分割(split)table 每個DB都有一些完整的table 分割(split)table 水平分割 把資料放到不同的表 [(1,2), (3,4)] =\u003e [(1,2)], [(3,4)] 垂直分割 依據col去割，之後用primiary key來認同一個row [(1,2), (3,4)] =\u003e [(1,3)], [(2,4)] 原則: 不要跨table 水平分割 一次需要所有col 垂直分割 只要一部份col 對於table的操作要改 (程式要改) table變得不一樣了 路由操作: 要改table的name (現在有多個table) 拼接操作: 要多加join (垂直分割如果需要另一個表的col) 讀寫分離 多個DB分別處理讀與寫 路由操作: 讀與寫要到對的DB 主從複製: 主從要同步!! (一致性問題) 複製的材料 log statement: 就是指令 (但遇到調用now_time之類的，就沒辦法反映真實資料到read db上) row: 就是資料 mixed: 就是指令+資料 非同步複製 (not reliable) write後立刻return，log非同步的傳 write db掛了又沒傳log就gg了 半同步複製 write後等log傳到某個db才return 全同步複製 write後等log傳到所有db才return DB中介軟體 就是DB的middleware，處理上面的路由操作、拼接操作、主從複製之類的問題 eg: MyCat ch7: 快取設計 cache for reading cache會花費到的時間 寫入cache時 生成key時 hash function 比較key 寫入mem時 寫mem 寫入什麼? 序列化物件 讀寫時都要經過序列化 原本的物件 不用反序列化 如果存的是reference? 會發生race condition!! 解法: 存序列化物件 或是 deep copy 讀cache時 生成key時 hash function 比較key 讀mem時 中 讀mem 沒中 跑原本 cache update 被動update 時效性更新 有過期時間 主動update cache aside read: 正常的讀，找不到去後面拉資料 去後面拉資料的時候要不要把cache刪了? 刪 如果寫入中，有另一個read 就會拉到舊的值到cache!! 但寫入完成後，雙方資料就不一致了 不刪 (good) read時，如果莫名其妙被block住 之後這之間有write完成 read就會拿到舊的值 但這不太可能，只要 read夠快 確保不會被preemptive 就不會發生 write: 直接往後方寫，不直接更新cache write through read/write: 都透過cache (同步) cache變成單點失敗的點 write behind 改write through的write成非同步 如果cache掛了 可能沒寫到!! cache clear 時效性 訂個過期時間 時間到就自己不見 讓另一個thread去清 固定pool數量 FIFO LRU 非強引用 GC的延伸，有ref到的就是有用的obj，所以不能刪，但沒有就是可以刪 這樣obj只有刪與不刪 但有的情況是在mem吃緊時可以刪 所以ref要有所區分 ref的分類 強引用: 一般的ref 軟引用: 會在mem不足時回收 弱引用: 不管mem夠不夠只要被gc就會被回收 虛引用: gc會當成看不到他 cache 的問題 cache穿透 如果連後面都沒有結果? 沒辦法寫到cache cache根本沒用!! 解法: 丟空值 像是linux的dentry(查詢路徑的node)遇到不存在的中間點(資料夾或是file) dentry會被create，但是標註(state)為不存在 cache擊穿 高頻率被access的資料被清掉? 所有req都往後了!! 會發生在 cache aside (因為沒有一致的保證，throught是強一致，behind是弱一致(最終一致的下一階)) 時效性清理 FIFO清理 cache預熱 需要req讓資料慢慢變多 兩個點 如果一次來大量req cache擊穿 如果是 時效性清理 與 長時間沒有req 反覆預熱 cache的位置 cache越前面越好 常見位置 client side browser的 localstorage \u0026 sessionstorage indexdb \u0026 web sql application cache 靜態cache CDN reverse proxy 服務cache 在stateful的服務中 具有一定通用return的服務(function)做cache DB的cache cache for writing cache在前面cache所有write的資料，之後再由cache去write到db (限流) 平滑write，消去大量的同樣的write req 總體而言 比起原本的write多了寫入與讀取cache的成本 但是對於user而言，只有cache的response time (比較短!!) cache要在後方有資源時才開始寫入，不然後面會爆 ch8: 可靠性設計 module串接方式 串聯: m1 -\u003e m2 -\u003e m3 ... 並聯: m/m/n的圖 只能處理不response的server 可以容錯到只要有一台是正確的就好 容錯 m/m/n的圖 + 裁決器(有過半數的相同response就當成是對的response) 可以處理有惡意(亂回答)與不response的server 拜占庭容錯!! 可以容錯到至少有一半+1台有一樣的response就好 可靠性設計 消除單點依賴 把串聯轉成並聯 叢集 相等式: 並聯 主從式: 一台服務、其他backup ch9: 應用保護 故障等級 所有user都能用所有service 部分user都能用所有service 部分user都能用部分service 不能提供service但可以恢復 系統crash但不影響其他系統 系統crash且影響到其他系統 隔離 用thread pool(或是semaphore去替代)，去包服務 每次invoke就是用thread跑 如果沒有thread可以用了(像是所有thread都因為server掛了，而block)，也繼續跑 限流/恢復 tc的qdisc algo 時間窗 一段時間中只放最多幾個req進來 如果有大量的req在開始計時時，一次出現 後面來看根本沒限到流 (還是一次很多) 從system來看 會有一堆沒辦法服務到 後面的服務空轉 漏桶 把時間窗的時間變小，一放一個req，剩下用queue去存 現在整個流平順了 但是如果queue不夠大 從system來看 會有一堆沒辦法服務到 後面的服務空轉 token bucket 每個單位時間生一個token，1個token放一個req token可以存!! 避免服務空轉 如果不調整token的總數，放著讓它長 如果有大量的req在開始計時時，一次出現 後面來看根本沒限到流 (還是一次很多) 兩個差在? 限流: 把收的req壓在一定數量 恢復: 慢慢把可以收的req往上拉 降級/融斷 (手法) 把複雜的server換成簡單的 不直接讀db改讀cache 精確結果改成近似結果 返回靜態結果 (不跑運算) 同步改成非同步 停用非必要的功能 禁止寫入 依據user level做diffSrv 降級/融斷依據 失敗次數/機率過高 限流啟動時 手動 兩個差在? 降級: 以降低response time 融斷: 以維持服務繼續 ch10: 前端高性能 資源下載 資源壓縮 content-encoding 減少req 資源合併 sprite圖 keep-alive與polling與server push 資源快取 Etag等等 redner最佳化 Reflow \u0026 Repaint (最花時間的步驟) 整個網頁就是一棵樹 最後要排版(reflow) 畫到畫面上(repaint) 讓影響範圍變小 觸發方式 dom新增/刪除 =\u003e 直接改dom的內容 =\u003e 讓frontend framework代勞 dom大小/定位方式/邊距/pesudo class改變狀態 =\u003e 保持上面的不變 (要常常變動) =\u003e 把parent node設成display: none，從一開始就沒有在tree中 這樣reflow就會是1次而已 lazy loading 先載入必要的部分，需要再load其他的 proload/prefetch 比較大的檔案可以先下載 ch11: 架構設計理論 skip\nch12: 高性能架構實踐 skip\n","wordCount":"662","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2022-01-17T10:31:32Z","dateModified":"2022-01-17T10:31:32Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2022/01/%E5%B7%A8%E5%9E%8B%E6%9C%8D%E5%8B%99%E6%9E%B6%E6%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B3%87%E6%96%99%E5%BA%AB%E5%84%AA%E5%8C%96/%E8%A8%98%E6%86%B6%E9%AB%94%E5%BF%AB%E5%8F%96%E8%A8%AD%E8%A8%88/io%E6%A8%A1%E5%9E%8B/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">巨型服務架構：分布式/資料庫優化/記憶體快取設計/IO模型</h1><div class=post-meta><span title='2022-01-17 10:31:32 +0000 UTC'>January 17, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#ch1-%e9%ab%98%e6%80%a7%e8%83%bd%e6%9e%b6%e6%a7%8b aria-label="ch1: 高性能架構">ch1: 高性能架構</a><ul><li><a href=#%e6%95%88%e8%83%bd%e6%8c%87%e6%a8%99 aria-label=效能指標>效能指標</a><ul><li><a href=#%e6%8c%87%e6%a8%99%e4%b9%8b%e9%96%93%e7%9a%84%e5%bd%b1%e9%9f%bf aria-label=指標之間的影響>指標之間的影響</a></li></ul></li></ul></li><li><a href=#ch2-%e5%88%86%e6%b5%81%e8%a8%ad%e8%a8%88 aria-label="ch2: 分流設計">ch2: 分流設計</a><ul><li><a href=#cdn aria-label=CDN>CDN</a><ul><li><a href=#service-discovery aria-label="service discovery">service discovery</a></li></ul></li><li><a href=#%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86 aria-label=反向代理>反向代理</a></li></ul></li><li><a href=#ch3-%e6%9c%8d%e5%8b%99%e5%b9%b3%e8%a1%8c%e8%a8%ad%e8%a8%88 aria-label="ch3: 服務平行設計">ch3: 服務平行設計</a></li><li><a href=#ch4-%e9%81%8b%e7%ae%97%e4%bd%b5%e7%99%bc aria-label="ch4: 運算併發">ch4: 運算併發</a></li><li><a href=#ch5-%e8%bc%b8%e5%85%a5%e8%bc%b8%e5%87%ba%e8%a8%ad%e8%a8%88 aria-label="ch5: 輸入輸出設計">ch5: 輸入輸出設計</a></li><li><a href=#ch6-%e8%b3%87%e6%96%99%e5%ba%ab%e8%a8%ad%e8%a8%88%e8%88%87%e6%9c%80%e4%bd%b3%e5%8c%96 aria-label="ch6: 資料庫設計與最佳化">ch6: 資料庫設計與最佳化</a></li><li><a href=#ch7-%e5%bf%ab%e5%8f%96%e8%a8%ad%e8%a8%88 aria-label="ch7: 快取設計">ch7: 快取設計</a></li><li><a href=#ch8-%e5%8f%af%e9%9d%a0%e6%80%a7%e8%a8%ad%e8%a8%88 aria-label="ch8: 可靠性設計">ch8: 可靠性設計</a></li><li><a href=#ch9-%e6%87%89%e7%94%a8%e4%bf%9d%e8%ad%b7 aria-label="ch9: 應用保護">ch9: 應用保護</a></li><li><a href=#ch10-%e5%89%8d%e7%ab%af%e9%ab%98%e6%80%a7%e8%83%bd aria-label="ch10: 前端高性能">ch10: 前端高性能</a></li><li><a href=#ch11-%e6%9e%b6%e6%a7%8b%e8%a8%ad%e8%a8%88%e7%90%86%e8%ab%96 aria-label="ch11: 架構設計理論">ch11: 架構設計理論</a></li><li><a href=#ch12-%e9%ab%98%e6%80%a7%e8%83%bd%e6%9e%b6%e6%a7%8b%e5%af%a6%e8%b8%90 aria-label="ch12: 高性能架構實踐">ch12: 高性能架構實踐</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>查漏補缺</p><h2 id=ch1-高性能架構>ch1: 高性能架構<a hidden class=anchor aria-hidden=true href=#ch1-高性能架構>#</a></h2><h3 id=效能指標>效能指標<a hidden class=anchor aria-hidden=true href=#效能指標>#</a></h3><ul><li>throughput<ul><li>TPS(transaction per second)</li><li>QPS(queries per second)</li></ul></li><li>併發數<ul><li>同時處理的數目: 同時在線user, 併發連線數&mldr;</li></ul></li><li>response time<ul><li>amdahl&rsquo;s law</li></ul></li><li>可靠度指標<ul><li>無故障時間</li></ul></li></ul><h4 id=指標之間的影響>指標之間的影響<a hidden class=anchor aria-hidden=true href=#指標之間的影響>#</a></h4><ul><li>throughput & 併發數<ul><li>(一開始) 併發數上升 => throughput上升</li><li>(持平) 併發數上升 => throughput不變<ul><li>系統臨界點</li></ul></li><li>(下降) 併發數上升 => throughput下降<ul><li>系統隨時都會崩潰</li></ul></li></ul></li><li>併發數 & response time<ul><li>(併發req數目) m/m/1的平均時間公式<ul><li>service的處理rate(mu那一個, 系統可以承受的最大併發數)</li><li>(一開始) req的數目小於系統可以承受的最大併發數，response time上升不明顯</li><li>(過了可以承受的最大併發數) response time急速增加</li></ul></li><li>系統中觀察到正在處理的req/thread數目<ul><li>response time大 => 卡在system中的req/thread會比較多!!</li></ul></li></ul></li></ul><h2 id=ch2-分流設計>ch2: 分流設計<a hidden class=anchor aria-hidden=true href=#ch2-分流設計>#</a></h2><h3 id=cdn>CDN<a hidden class=anchor aria-hidden=true href=#cdn>#</a></h3><ul><li>優點<ul><li>減少系統併發數</li><li>減少response time</li><li>減少網路壅塞</li></ul></li><li>原理<ul><li>多個CDN node，DNS做query時根據使用者位置回傳最近的ip</li><li>CDN node會變成cache proxy，有就回傳；沒有就relay req到主機</li></ul></li></ul><p>可以把CDN對地址動手腳的方法用到service discovery</p><h4 id=service-discovery>service discovery<a hidden class=anchor aria-hidden=true href=#service-discovery>#</a></h4><ul><li>服務註冊<ul><li>user: 去registry找service的實際位置</li><li>registry: 維護service的清單</li><li>server: 要把自己登記到registry</li></ul></li><li>服務規則<ul><li>user: 去registry找service地址的使用規則</li><li>registry: 放service地址的使用規則，讓user自己判斷要去哪</li><li>server: 要開發或是營運去調整規則</li></ul></li></ul><h3 id=反向代理>反向代理<a hidden class=anchor aria-hidden=true href=#反向代理>#</a></h3><p>由proxy分配req到不同的server (追求load balance就是load balancer；server的任務都不同就是一般的反向代理)</p><ul><li>原理<ul><li>level 4: 只看ip與port做分配</li><li>level 7: 看req內容作分配，eg: http, ftp&mldr;<ul><li>對外面來說，ip與port都是一樣的!!</li></ul></li></ul></li></ul><h2 id=ch3-服務平行設計>ch3: 服務平行設計<a hidden class=anchor aria-hidden=true href=#ch3-服務平行設計>#</a></h2><ul><li>叢集: 有很多同樣的server的set，一起提供服務<ul><li>server無狀態<ul><li><em>無狀態的節點叢集</em></li><li>一般都是負責query之類沒有狀態的服務</li><li>平行喚醒問題<ul><li>在這個set加入定時寄信功能<ul><li>結果所有server一起寄信!?</li></ul></li><li>解法: 外部喚醒<ul><li>打req進來，跑功能，這樣就只會有一台跑</li></ul></li></ul></li></ul></li><li>server有狀態<ul><li>server自己維護狀態<ul><li>要與別人share<ul><li><em>資訊一致的節點叢集</em></li><li>大家都有自己的狀態，但需要與其他server的狀態同步</li><li>一致性問題(讀寫不一致): 我在A改的，在B看不到<ul><li>一致性的等級<ul><li>強一致性<ul><li>2 phases commit</li><li>3 phases commit</li></ul></li><li>最終一致性<ul><li>有retry的msg queue</li></ul></li></ul></li></ul></li></ul></li><li>不要與別人share<ul><li><em>單一服務節點叢集</em></li><li>user與server是被綁定的!!</li><li>how to bind?<ul><li>user指定<ul><li>online game的選server</li></ul></li><li>根據位置、user id</li><li>先隨便assign，把server位置寫到cookie中</li></ul></li><li>單點失敗</li></ul></li></ul></li><li>server把狀態抽出去<ul><li><em>資訊共用的節點叢集</em></li><li>在redis之類的地方紀錄state，像是session</li><li>redis之類的地方<ul><li>會是bottleneck</li><li>需要concurrent的控制</li></ul></li></ul></li></ul></li></ul></li><li>分散式系統<ul><li>把server中的(實體/虛擬)元件拆掉，像web server與DB跑在不同host<ul><li>如果有元件是bottlebeck，可以用叢集拆掉</li></ul></li><li>一致性問題(讀寫不一致): 我在A改的，在B看不到<ul><li>同<em>資訊一致的節點叢集</em></li></ul></li><li>所有元件是可組合的? <em>微服務系統</em></li></ul></li></ul><h2 id=ch4-運算併發>ch4: 運算併發<a hidden class=anchor aria-hidden=true href=#ch4-運算併發>#</a></h2><ul><li>多process<ul><li>可能在不同的cpu跑(平行)，也可能在同一顆跑(共時)</li><li>具有很強的隔離<ul><li>像是開兩個server在process<ul><li>可以兩個指定不同的port，就有兩台獨立的server</li></ul></li></ul></li><li>ctx switch的成本高<ul><li>cache要預熱</li><li>在userspace與kernel space之間切換</li><li>reg的切換</li></ul></li><li>IPC不好做</li><li>sync<ul><li>使用情境<ul><li>獨佔 (競爭)</li><li>協作: 等對方好了在一起走</li><li>獨佔、協作的詳細介紹，去看Parallel Thinking</li></ul></li></ul></li></ul></li><li>多thread<ul><li>可能在不同的cpu跑(平行)，也可能在同一顆跑(共時)</li><li>ctx switch的成本小<ul><li>都在同一塊記憶體</li><li>有locality</li></ul></li><li>使用情境<ul><li>做非同步 (會block的工作)</li><li>處理subtask，之後merge</li></ul></li><li>sync<ul><li>使用情境<ul><li>獨佔 (競爭)</li><li>協作: 等對方好了在一起走</li><li>獨佔、協作的詳細介紹，去看Parallel Thinking</li></ul></li></ul></li></ul></li><li>fiber就是continuation<ul><li>只能在同一顆跑(共時)</li><li>執行fiber就會停下當下的動作，之後執行會回到原本的位置</li><li>不會race condition</li><li>不會平行是concurrent!!</li><li>ctx switch的代價很小</li><li>sync<ul><li>使用情境<ul><li>協作: 等對方好了在一起走</li></ul></li></ul></li></ul></li></ul><h2 id=ch5-輸入輸出設計>ch5: 輸入輸出設計<a hidden class=anchor aria-hidden=true href=#ch5-輸入輸出設計>#</a></h2><p>去看之前的文章</p><h2 id=ch6-資料庫設計與最佳化>ch6: 資料庫設計與最佳化<a hidden class=anchor aria-hidden=true href=#ch6-資料庫設計與最佳化>#</a></h2><ul><li>設計table<ul><li>當成設計class，但是只有primitive與reference而已<ul><li>array要轉90度，變成table (NF1)</li><li>所有的欄位(primitive)可以是來自<ul><li>自己本身的屬性</li><li>另一個物件展開的結果 (NF2, NF2, BCNF, 反正規化)</li></ul></li><li>去看之前的文章</li></ul></li></ul></li><li>index<ul><li>故障<ul><li>一個col做index<ul><li>上index的column做修改</li><li>用錯type去query (string卻用成int，雖然會被cast，但index會失效)</li></ul></li><li>多個col做index<ul><li>(Btree) query沒有包含前面的col(左手邊)<ul><li>index從第一個col開始sort，一直下去，所以做query時需要前面的</li></ul></li><li>(hash) 沒有全部的col</li></ul></li><li>對string做index<ul><li>如果有wildcast, btree與hash都會沒用，要用inverted index</li></ul></li><li>btree<ul><li><code>!=</code>, <code>&lt;></code>, <code>NOT</code></li><li><code>IN</code>, <code>NOT IN</code><ul><li><code>IN</code> => <code>BETWEEN</code></li></ul></li></ul></li><li>null<ul><li>index沒辦法對null做任何事<ul><li>用其他值代替!!</li></ul></li></ul></li></ul></li><li>不同的engine不同的index (與其他)<ul><li>innoDB會把hash自動換成btree (innoDB沒有做hash)</li></ul></li></ul></li><li>自建交易<ul><li>可以undo的action沒差</li><li>不能undo的action(對外界有影響)<ul><li>最多只能有一個</li><li>只能在最後一位</li></ul></li></ul></li><li>資料太多了<ul><li>table分區 (partition)<ul><li>把一個table(file)分成多個檔案</li><li>對於table的操作不變 (在外面來看這個table還是一樣)</li><li>可以存到不同的HDD<ul><li>增加throughput</li><li>增加能存的entry數量</li><li>可以針對某一區做操作，不影響其他區</li></ul></li><li>query最好要把當初做分區的條件放入query<ul><li>不然要所有分區都跑</li></ul></li></ul></li><li>分庫<ul><li>把DB切開<ul><li>table怎麼辦?<ul><li>分table</li></ul></li></ul></li></ul></li><li>分table<ul><li>不分割(split)table<ul><li>每個DB都有一些完整的table</li></ul></li><li>分割(split)table<ul><li>水平分割<ul><li>把資料放到不同的表<ul><li><code>[(1,2), (3,4)]</code> => <code>[(1,2)]</code>, <code>[(3,4)]</code></li></ul></li></ul></li><li>垂直分割<ul><li>依據col去割，之後用primiary key來認同一個row<ul><li><code>[(1,2), (3,4)]</code> => <code>[(1,3)]</code>, <code>[(2,4)]</code></li></ul></li></ul></li></ul></li><li>原則: 不要跨table<ul><li>水平分割<ul><li>一次需要所有col</li></ul></li><li>垂直分割<ul><li>只要一部份col</li></ul></li></ul></li><li>對於table的操作要改 (程式要改)<ul><li>table變得不一樣了<ul><li>路由操作: 要改table的name (現在有多個table)</li><li>拼接操作: 要多加join (垂直分割如果需要另一個表的col)</li></ul></li></ul></li><li>讀寫分離<ul><li>多個DB分別處理讀與寫</li><li>路由操作: 讀與寫要到對的DB</li><li>主從複製: 主從要同步!! (一致性問題)<ul><li>複製的材料<ul><li>log<ul><li>statement: 就是指令 (但遇到調用now_time之類的，就沒辦法反映真實資料到read db上)</li><li>row: 就是資料</li><li>mixed: 就是指令+資料</li></ul></li></ul></li><li>非同步複製 (not reliable)<ul><li>write後立刻return，log非同步的傳<ul><li>write db掛了又沒傳log就gg了</li></ul></li></ul></li><li>半同步複製<ul><li>write後等log傳到<strong>某個</strong>db才return</li></ul></li><li>全同步複製<ul><li>write後等log傳到<strong>所有</strong>db才return</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>DB中介軟體<ul><li>就是DB的middleware，處理上面的路由操作、拼接操作、主從複製之類的問題<ul><li>eg: MyCat</li></ul></li></ul></li></ul><h2 id=ch7-快取設計>ch7: 快取設計<a hidden class=anchor aria-hidden=true href=#ch7-快取設計>#</a></h2><ul><li>cache for reading<ul><li>cache會花費到的時間<ul><li>寫入cache時<ul><li>生成key時<ul><li>hash function</li><li>比較key</li></ul></li><li>寫入mem時<ul><li>寫mem<ul><li>寫入什麼?<ul><li>序列化物件<ul><li>讀寫時都要經過序列化</li></ul></li><li>原本的物件<ul><li>不用反序列化</li><li>如果存的是reference?<ul><li>會發生race condition!!</li><li>解法: 存序列化物件 或是 deep copy</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>讀cache時<ul><li>生成key時<ul><li>hash function</li><li>比較key</li></ul></li><li>讀mem時<ul><li>中<ul><li>讀mem</li></ul></li><li>沒中<ul><li>跑原本</li></ul></li></ul></li></ul></li></ul></li><li>cache update<ul><li>被動update<ul><li>時效性更新<ul><li>有過期時間</li></ul></li></ul></li><li>主動update<ul><li>cache aside<ul><li>read: 正常的讀，找不到去後面拉資料<ul><li>去後面拉資料的時候要不要把cache刪了?<ul><li>刪<ul><li>如果寫入中，有另一個read<ul><li>就會拉到舊的值到cache!!</li></ul></li><li>但寫入完成後，雙方資料就不一致了</li></ul></li><li>不刪 (good)<ul><li>read時，如果莫名其妙被block住</li><li>之後這之間有write完成</li><li>read就會拿到舊的值<ul><li>但這不太可能，只要<ul><li>read夠快</li><li>確保不會被preemptive</li></ul></li><li>就不會發生</li></ul></li></ul></li></ul></li></ul></li><li>write: 直接往後方寫，不直接更新cache</li></ul></li><li>write through<ul><li>read/write: 都透過cache (同步)<ul><li>cache變成單點失敗的點</li></ul></li></ul></li><li>write behind<ul><li>改write through的write成非同步<ul><li>如果cache掛了<ul><li>可能沒寫到!!</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>cache clear<ul><li>時效性<ul><li>訂個過期時間<ul><li>時間到就自己不見</li><li>讓另一個thread去清</li></ul></li></ul></li><li>固定pool數量<ul><li>FIFO</li><li>LRU</li></ul></li><li>非強引用<ul><li>GC的延伸，有ref到的就是有用的obj，所以不能刪，但沒有就是可以刪<ul><li>這樣obj只有刪與不刪</li></ul></li><li>但有的情況是在mem吃緊時可以刪<ul><li>所以ref要有所區分</li></ul></li><li>ref的分類<ul><li>強引用: 一般的ref</li><li>軟引用: 會在mem不足時回收</li><li>弱引用: 不管mem夠不夠只要被gc就會被回收</li><li>虛引用: gc會當成看不到他</li></ul></li></ul></li></ul></li><li>cache 的問題<ul><li>cache穿透<ul><li>如果連後面都沒有結果?<ul><li>沒辦法寫到cache</li><li>cache根本沒用!!<ul><li>解法: 丟空值<ul><li>像是linux的dentry(查詢路徑的node)遇到不存在的中間點(資料夾或是file)</li><li>dentry會被create，但是標註(state)為不存在</li></ul></li></ul></li></ul></li></ul></li><li>cache擊穿<ul><li>高頻率被access的資料被清掉?<ul><li>所有req都往後了!!</li><li>會發生在<ul><li>cache aside (因為沒有一致的保證，throught是強一致，behind是弱一致(最終一致的下一階))<ul><li>時效性清理</li><li>FIFO清理</li></ul></li></ul></li></ul></li></ul></li><li>cache預熱<ul><li>需要req讓資料慢慢變多</li><li>兩個點<ul><li>如果一次來大量req<ul><li>cache擊穿</li></ul></li><li>如果是 時效性清理 與 長時間沒有req<ul><li>反覆預熱</li></ul></li></ul></li></ul></li></ul></li><li>cache的位置<ul><li>cache越前面越好</li><li>常見位置<ul><li>client side<ul><li>browser的<ul><li>localstorage & sessionstorage</li><li>indexdb & web sql</li><li>application cache</li></ul></li></ul></li><li>靜態cache<ul><li>CDN</li><li>reverse proxy</li></ul></li><li>服務cache<ul><li>在stateful的服務中<ul><li>具有一定通用return的服務(function)做cache</li></ul></li></ul></li><li>DB的cache</li></ul></li></ul></li></ul></li><li>cache for writing<ul><li>cache在前面cache所有write的資料，之後再由cache去write到db (限流)<ul><li>平滑write，消去大量的同樣的write req</li></ul></li><li>總體而言<ul><li>比起原本的write多了寫入與讀取cache的成本</li><li>但是對於user而言，只有cache的response time (比較短!!)</li></ul></li><li>cache要在後方有資源時才開始寫入，不然後面會爆</li></ul></li></ul><h2 id=ch8-可靠性設計>ch8: 可靠性設計<a hidden class=anchor aria-hidden=true href=#ch8-可靠性設計>#</a></h2><ul><li>module串接方式<ul><li>串聯:<ul><li><code>m1 -> m2 -> m3 ...</code></li></ul></li><li>並聯:<ul><li>m/m/n的圖<ul><li>只能處理不response的server</li><li>可以容錯到只要有一台是正確的就好</li></ul></li></ul></li><li>容錯<ul><li>m/m/n的圖 + 裁決器(有過半數的相同response就當成是對的response)<ul><li>可以處理有惡意(亂回答)與不response的server<ul><li>拜占庭容錯!!</li></ul></li><li>可以容錯到至少有一半+1台有一樣的response就好</li></ul></li></ul></li></ul></li><li>可靠性設計<ul><li>消除單點依賴</li><li>把串聯轉成並聯</li><li>叢集<ul><li>相等式: 並聯</li><li>主從式: 一台服務、其他backup</li></ul></li></ul></li></ul><h2 id=ch9-應用保護>ch9: 應用保護<a hidden class=anchor aria-hidden=true href=#ch9-應用保護>#</a></h2><ul><li>故障等級<ul><li>所有user都能用所有service</li><li>部分user都能用所有service</li><li>部分user都能用部分service</li><li>不能提供service但可以恢復</li><li>系統crash但不影響其他系統</li><li>系統crash且影響到其他系統</li></ul></li><li>隔離<ul><li>用thread pool(或是semaphore去替代)，去包服務<ul><li>每次invoke就是用thread跑</li><li>如果沒有thread可以用了(像是所有thread都因為server掛了，而block)，也繼續跑</li></ul></li></ul></li><li>限流/恢復<ul><li>tc的qdisc</li><li>algo<ul><li>時間窗<ul><li>一段時間中只放最多幾個req進來<ul><li>如果有大量的req在開始計時時，一次出現<ul><li>後面來看根本沒限到流 (還是一次很多)</li><li>從system來看<ul><li>會有一堆沒辦法服務到</li><li>後面的服務空轉</li></ul></li></ul></li></ul></li></ul></li><li>漏桶<ul><li>把時間窗的時間變小，一放一個req，剩下用queue去存<ul><li>現在整個流平順了</li><li>但是如果queue不夠大<ul><li>從system來看<ul><li>會有一堆沒辦法服務到</li><li>後面的服務空轉</li></ul></li></ul></li></ul></li></ul></li><li>token bucket<ul><li>每個單位時間生一個token，1個token放一個req<ul><li>token可以存!!<ul><li>避免服務空轉</li></ul></li></ul></li><li>如果不調整token的總數，放著讓它長<ul><li>如果有大量的req在開始計時時，一次出現<ul><li>後面來看根本沒限到流 (還是一次很多)</li></ul></li></ul></li></ul></li></ul></li><li>兩個差在?<ul><li>限流: 把收的req壓在一定數量</li><li>恢復: 慢慢把可以收的req往上拉</li></ul></li></ul></li><li>降級/融斷<ul><li>(手法) 把複雜的server換成簡單的<ul><li>不直接讀db改讀cache</li><li>精確結果改成近似結果</li><li>返回靜態結果 (不跑運算)</li><li>同步改成非同步</li><li>停用非必要的功能</li><li>禁止寫入</li><li>依據user level做diffSrv</li></ul></li><li>降級/融斷依據<ul><li>失敗次數/機率過高</li><li>限流啟動時</li><li>手動</li></ul></li><li>兩個差在?<ul><li>降級: 以降低response time</li><li>融斷: 以維持服務繼續</li></ul></li></ul></li></ul><h2 id=ch10-前端高性能>ch10: 前端高性能<a hidden class=anchor aria-hidden=true href=#ch10-前端高性能>#</a></h2><ul><li>資源下載<ul><li>資源壓縮<ul><li>content-encoding</li></ul></li><li>減少req<ul><li>資源合併<ul><li>sprite圖</li></ul></li><li>keep-alive與polling與server push</li></ul></li><li>資源快取<ul><li>Etag等等</li></ul></li></ul></li><li>redner最佳化<ul><li>Reflow & Repaint (最花時間的步驟)<ul><li>整個網頁就是一棵樹<ul><li>最後要排版(reflow)</li><li>畫到畫面上(repaint)</li></ul></li><li>讓影響範圍變小</li><li>觸發方式<ul><li>dom新增/刪除<ul><li>=> 直接改dom的內容</li><li>=> 讓frontend framework代勞</li></ul></li><li>dom大小/定位方式/邊距/pesudo class改變狀態<ul><li>=> 保持上面的不變</li><li>(要常常變動) => 把parent node設成<code>display: none</code>，從一開始就沒有在tree中<ul><li>這樣reflow就會是1次而已</li></ul></li></ul></li></ul></li></ul></li><li>lazy loading<ul><li>先載入必要的部分，需要再load其他的</li></ul></li><li>proload/prefetch<ul><li>比較大的檔案可以先下載</li></ul></li></ul></li></ul><h2 id=ch11-架構設計理論>ch11: 架構設計理論<a hidden class=anchor aria-hidden=true href=#ch11-架構設計理論>#</a></h2><p>skip</p><h2 id=ch12-高性能架構實踐>ch12: 高性能架構實踐<a hidden class=anchor aria-hidden=true href=#ch12-高性能架構實踐>#</a></h2><p>skip</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/distributed/>Distributed</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2022/01/designing-data-intensive-applications/><span class=title>« Prev</span><br><span>Designing Data-Intensive Applications</span>
</a><a class=next href=https://littlebees.github.io/2022/01/queuing-thoery%E7%9A%84tutorial/><span class=title>Next »</span><br><span>queuing thoery的tutorial</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>