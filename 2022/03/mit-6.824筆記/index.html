<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>mit 6.824筆記 | 記事本</title>
<meta name=keywords content="Distributed"><meta name=description content="動機
筆記"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2022/03/mit-6.824%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="mit 6.824筆記"><meta property="og:description" content="動機
筆記"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2022/03/mit-6.824%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-11T23:23:53+00:00"><meta property="article:modified_time" content="2022-03-11T23:23:53+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="mit 6.824筆記"><meta name=twitter:description content="動機
筆記"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"mit 6.824筆記","item":"https://littlebees.github.io/2022/03/mit-6.824%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"mit 6.824筆記","name":"mit 6.824筆記","description":"動機 筆記\n","keywords":["Distributed"],"articleBody":"動機 筆記\nintro 提醒大家，在你設計一個系統時或者面對一個你需要解決的問題時，如果你可以在一台計算機上解決，而不需要分佈式系統，那你就應該用一台計算機解決問題\n有很多的工作都可以在一台計算機上完成，並且通常比分佈式系統簡單很多。所以，在選擇使用分佈式系統解決問題前，你應該要充分嘗試別的思路，因為分佈式系統會讓問題解決變得複雜\n分佈式系統的問題（挑戰）在於\n並發 局部錯誤 一部分組件在工作、另一部分組件停止運行 這些計算機都在正常運行，但是網絡中斷了或者不穩定 實際上一千台機器到底有多少性能是一個棘手的問題 基礎架構\n存儲 通信（網絡） 計算 我們希望通過這種抽象的接口，將分佈式特性隱藏在整個系統內 我們的確也需要構建這樣一種基礎架構，它能夠盡可能多的對應用開發人員屏蔽和掩蓋錯誤\n性能 =\u003e 可擴展性(Scalability) 容錯 =\u003e 可用性(Availability) 大型分佈式系統中有一個大問題，那就是一些很罕見的問題會被放大 1000台計算機的集群中，總是有故障 主機 網路 recoverability 如果出現了問題，服務會停止工作，不再響應請求，之後有人來修復，並且在修復之後系統仍然可以正常運行，就像沒有出現過問題一樣 為了實現這些特性，有很多工具 非易失存儲（non-volatile storage，類似於硬盤） checkpoint, log 複製（replication） 關鍵問題在於，這兩個副本總是會意外的偏離同步的狀態，而不再互為副本 一致性（Consistency） 一致性就是用來定義操作行為的概念 (多個副本) 強一致（Strong Consistency） 強一致可以確保get獲取的是最新的數據，但是實現這一點的代價非常高 分佈式系統的各個組件需要做大量的通信，才能實現強一致性 弱一致 分佈式存儲系統的難點 (loop)\n巨大的性能加成 \u003e 分片 分片（Sharding），但你將會看見常態的故障 \u003e 容錯（fault tolerance） 複製（replication） \u003e 不一致（inconsistency） 強一致 \u003e 低性能 mapreduce 這裡確實需要將每一份數據都通過網絡從創建它的Map節點傳輸到需要它的Reduce節點 這裡實際上可能會有大量的網絡通信\ngfs 設計與目標\nbig,fast global sharding automatic recovering 前提\nsingle data centor internal use big sequential access 沒有random access Master節點用來管理文件和Chunk的信息 Chunk服務器用來存儲實際的數據\nMaster節點知道每一個文件對應的所有的Chunk的ID，這些Chunk每個是64MB大小，它們共同構成了一個文件\nmaster node\nfilename 很多chunk id chunk id chunk server的列表 version 是不是primary chunk write只能在primary上跑 租約時間 Master會在磁盤上存儲log，每次有數據變更時，Master會在磁盤的log中追加一條記錄，並生成CheckPoint（類似於備份點）\nread\nfilename + offset -\u003e chunk id + chunk server list 選一個chunk server -\u003e chunk id + offset 從一般的fs拿檔案 write(只有append)\n當有多個客戶端同時寫同一個文件時，一個客戶端並不能知道文件究竟有多長 沒有一個客戶端會知道文件究竟有多長，因此也就不知道該往什麼樣的偏移量，或者說向哪個Chunk去追加數據。 客戶端可以向Master節點查詢哪個Chunk服務器保存了文件的最後一個Chunk。\n對於某個特定的Chunk來說，在某一個時間點，Master不一定指定了Chunk的主副本。所以，寫文件的時候，需要考慮Chunk的主副本不存在的情況\n如果發現Chunk的主副本不存在，Master會找出所有存有Chunk最新副本的Chunk服務器\n當客戶端想要對文件進行追加，但是又不知道文件尾的Chunk對應的Primary在哪時，Master會等所有存儲了最新Chunk版本的服務器集合完成，然後挑選一個作為Primary，其他的作為Secondary\nMaster會增加版本號，並將版本號寫入磁盤，這樣就算故障了也不會丟失這個數據\nMaster節點會向Primary和Secondary副本對應的服務器發送消息並告訴它們，誰是Primary，誰是Secondary，Chunk的新版本是什麼\nclient寫資料到各個chunk 客戶端會將要追加的數據發送給Primary和Secondary服務器，這些服務器會將數據寫入到一個臨時位置。 最開始，這些數據不會追加到文件中 當所有的服務器都返回確認消息說，已經有了要追加的數據，客戶端會向Primary服務器發送一條消息，將這個數據追加到這個文件中 Primary服務器或許會從大量客戶端收到大量的並發請求，Primary服務器會以某種順序，一次只執行一個請求 Primary會通知所有的Secondary服務器也將客戶端要追加的數據寫入在它們自己存儲的Chunk末尾 如果客戶端從Primary得到寫入失敗，那麼客戶端應該重新發起整個追加過程\nGFS這樣設計的理由是足夠的簡單，但是同時也給應用程序暴露了一些奇怪的數據 這里希望為應用程序提供一個相對簡單的寫入接口，但應用程序需要容忍讀取數據的亂序\n將GFS升級成強一致系統，我可以為你列舉一些你需要考慮的事情\n讓Primary來探測重複的請求 對於Secondary來說，如果Primay要求Secondary執行一個操作，Secondary必須要執行而不是只返回一個錯誤給Primary 於一個嚴格一致的系統來說，是不允許Secondary忽略Primary的請求而沒有任何補償措施的 當Primary要求Secondary追加數據時，直到Primary確信所有的Secondary都能執行數據追加之前，Secondary必須小心不要將數據暴露給讀請求 第一個階段，Primary向Secondary發請求，要求其執行某個操作，並等待Secondary回复說能否完成該操作，這時Secondary並不實際執行操作。 在第二個階段，如果所有Secondary都回复說可以執行該操作，這時Primary才會說，好的，所有Secondary執行剛剛你們回复可以執行的那個操作 兩階段提交（Two-phase commit） 新的Primary上任時，需要顯式的與Secondary進行同步 當Primary崩潰時，可能有一組操作由Primary發送給Secondary 要么對於Secondary需要一個租約系統，就像Primary一樣，這樣就知道Secondary在哪些時間可以合法的響應客戶端 就是raft!!\nvmware ft 複製不能處理軟件中的bug和硬件設計中的缺陷\n如果我們有兩個副本，一個Primay和一個Backup節點，我們總是假設兩個副本中的錯誤是相互獨立的。但是如果它們之間的錯誤是有關聯的，那麼複製對我們就沒有幫助\n這種複制的方案是否值得？因為它使用了我們實際需要的2-3倍的計算機資源\nState Transfer Primary將自己完整狀態，比如說內存中的內容，拷貝並發送給Backup\nReplicated State Machine 它只會從Primary將這些外部事件，例如外部的輸入，發送給Backup。 通常來說，如果有兩台計算機，如果它們從相同的狀態開始，並且它們以相同的順序，在相同的時間，看到了相同的輸入，那麼它們會一直互為副本，並且一直保持一致。\n狀態轉移傳輸的是可能是內存，而復制狀態機會將來自客戶端的操作或者其他外部事件，從Primary傳輸到Backup。\n在多核上工作。這個新系統從我看來使用了狀態轉移，而不是複制狀態機。因為面對多核和並行計算，狀態轉移更加健壯。如果你使用了一台機器，並且將其內存發送過來了，那麼那個內存鏡像就是機器的狀態，並且不受並行計算的影響，但是複制狀態機確實會受並行計算的影響。但是另一方面，我認為這種新的多核方案代價會更高一些。\n會復制機器的完整狀態，這包括了所有的內存，所有的寄存器\n應用程序級別的複制系統。這樣做的後果是，複製這個行為，必須構建在應用程序內部。如果你收到了一系列應用程序級別的操作，你確實需要應用程序參與到復制中來\nVMware FT的獨特之處在於，它從機器級別實現複製，因此它不關心你在機器上運行什麼樣的軟件，它就是複制底層的寄存器和內存\n它的缺點是，它沒有那麼的高效，優點是，你可以將任何現有的軟件，甚至你不需要有這些軟件的源代碼，你也不需要理解這些軟件是如何運行的\nprimary負責收client的request VMM(hyperviser)遇到request會copy一份到secondary(log channel) 不確定性 中斷發生的時間有一樣嗎? 有狀態的指令 (random, timeoftoday) 多核 對此需要特別的request格式 日誌條目的類型 數據: 一般資料或是已經跑完不確定性指令的資料 事件發生時的指令序號 在primary跑request之前會確認backup有收到log!! (ack) 沒收到就不會把response丟回去 就算primary已經做好了 幾乎每一個複制系統都有這個問題，在某個時間點，Primary必須要停下來等待Backup，這對於性能是實打實的限制 所以如果條件允許，人們會更喜歡使用在更高層級做複製的系統（詳見4.2 最後兩段） 也就是應用程式層級的複製 VMM會讓來自primary的response通過，backup的會drop 重複output 如果 primary在傳完response掛掉 backup還沒處理新的log 這樣backup會消耗log來成為primary，之後丟response 但因為現在backup是primary，所以response會被丟回去!! 不過因為都是用TCP連線，所以TCP會drop重複的packet tcp的狀態與原本的primary一樣 對於任何有主從切換的複制系統，基本上不可能將系統設計成不產生重複輸出 為了避免重複輸出，有一個選項是在兩邊都不生成輸出，但這是一個非常糟糕的做法（因為對於客戶端來說就是一次失敗的請求） 當出現主從切換時，切換的兩邊都有可能生成重複的輸出，這意味著，某種程度上來說，所有復制系統的客戶端需要一種重複檢測機制 primary與backup之間有heart beat確認health 還有Test-and-Set確認對方真的掛了 (想像雙方剛好log channel的連線被block) Test-and-Set服務不運行在Primary和Backup的物理服務器上，VMware FT需要通過網絡支持Test-and-Set服務 這有點像一個鎖。為了能夠上線，它們或許會同時發送一個Test-and-Set請求，給Test-and-Set服務。 當第一個請求送達時，Test-and-Set服務會說，這個標誌位之前是0，現在是1 在6.824這門課程中，有個核心的規則就是，你無法判斷另一個計算機是否真的掛了，你所知道的就是，你無法從那台計算機收到網絡報文，你無法判斷是因為那台計算機掛了，還是因為網絡出問題了導致的 raft 整個系統有兩個時間\nserver自己 也就是做了什麼 動作的source 現在該聽誰的 單一source可以處理brain-split raft是共識algorithm，所以要處理consistency\n單一source =\u003e brain-split 也有可能沒有leader，但這個時候system也不能做什麼事 majarity votes =\u003e fault-toroelent commit, and then apply 重要的state (時間)\n所有server的現在時間 currentTerm server自身的時間 votedFor log[] 後面處理log compaction會看到，log還要多一個狀態snapshot 執行期狀態 (做到哪)\nserver自己 commitIndex: log收到哪 lastApplied: log做到哪 leader狀態 nextIndex[]: 要從哪個log開始塞給ith follower matchIndex[]: ith follower做到哪了 接下去就是下面其中一個事件發生\n選leader RequestVote RPC 前提 收到的term要大於等於自己 (所有server的現在時間夠新) 之後就 改votedFor 處理client request AppendEntries RPC 前提 收到的term要大於等於自己 (所有server的現在時間夠新) prevLogIndex 有東西 \u0026 prevLogTerm 對得起來 (server自身的時間是對得起來的) 對不起來? prevLogIndex沒東西 return false (leader與自己的狀態對不起來) prevLogTerm不對 把prevLogIndex後面的東西刪掉 之後就 把entries接上去 更新commitIndex 接著就是看state怎麼改變的\n什麼時候apply log\ncommitIndex \u003e lastApplied 同時跟新lastApplied 什麼時候換currentTerm\n收到大於自己term的rpc時 同時換votedFor 成為candidate (來自timeout) leader怎麼知道\n大家commit到哪 (leader怎麼跟新commitIndex) N \u003e commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm 我的prevLogIndex是錯的 AppendEntries回傳false, 之後leader的prevLogIndex自己退一格，retry AppendEntries leader退無可退怎麼辦? 這個時候就是snapshot了 退一格不會太慢 (7.3 快速恢复（Fast Backup）) follower的reply加上，衝突位置(prevLogIndex)的 XTerm: prevLogIndex的位置的term XIndex: XTerm的第一個event的log 位置 XLen: 有多少空白的log 之後有3個case XTerm是空的 從XLen開始蓋 沒看過XTerm的term 從XIndex開始蓋 看過XTerm的term，所以是index對不上 從XIndex-1開始蓋 什麼時候要response給client 收到AppendEntries的過半reply 有一個細節在 6.8 选举定时器（Election Timer） 提到 就是timeout可能有livelock，所以可以像ethernet的CSMA/CD，但是retry的間隔至少要大於heartbeat的間隔\nLinearizability 一個系統的執行歷史是一系列的客戶端請求，或許這是來自多個客戶端的多個請求。如果執行歷史整體可以按照一個順序排列，且排列順序與客戶端請求的實際時間相符合，那麼它是線性一致的\n對於線性一致的順序順序，有兩個限制條件：\n如果一個操作在另一個操作開始前就結束了，那麼這個操作必須在執行歷史中出現在另一個操作前面。 時間序 (可能會出現concurrent) 可以當成從第一個write response最後開始跑的bfs tree 執行歷史中，讀操作，必須在相應的key的寫操作之後。 把tree壓成line 這裡要看一個例子 這個read是3符合Linearizability?\n在第一個write後發read，但是中間經歷重傳，也許read是在write 4之後完成的\n但是這裡的第一個read是在第一個write之後，所以就算丟3也ok\n客戶端永遠也不能在一個線性一致的系統中看到舊的數據（也就是X=1），因為一個線性一致的系統不允許讀出舊的數據 對於讀請求不允許返回舊的數據，只能返回最新的數據。或者說，對於讀請求，線性一致系統只能返回最近一次完成的寫請求寫入的值。\nzookeeper first-in-first-out order 如果系統不提供線性一致性，那麼系統是否還可用？客戶端發送了一個讀請求，但是並沒有得到當前的正確數據，也就是最新的數據，那我們為什麼要相信這個系統是可用的？\n如果read/write都是透過leader做，這樣沒有scalbility\nZookeeper並不要求返回最新的寫入數據。 Zookeeper的方式是，放棄線性一致性，提升read的效率 直接讓follower處理read 但是zookeeper保證會照client的指令order(first-in-first-out)去跑\nhow? 在指令上打index，讓index對到log的index(response中附上log index(zxid))，之後就是確保在log的index大於等於前面坐指令時的log index大的狀態下跑指令 讀寫請求是線性一致的，這讓前面的第一個問題有了解法，同步操作（sync）\n同步操作（sync）就是\n先發一個write (透過raft完成) 之後read要求一定要在前面的write發生之後 (透過first-in-first-out完成) ready file(transcation, seqlock)\n先刪raedy file 做write 創ready file 之後client就能認ready file去讀，但這樣有問題有可能在刪之前ready還在，但中間其他的write啟動了 所以會多一個watch確認ready file有沒有被動，有被通知就要retry Zookeeper可以保證如果某個人刪除了Ready file，相應的通知，會在任何後續的讀請求之前，發送到客戶端。 客戶端會先收到有關Ready file刪除的通知，之後才收到其他在Log中位於刪除Ready file之後的讀請求的響應\nAPI Zookeeper的API某種程度上來說像是一個文件系統 Zookeeper被設計成要被許多可能完全不相關的服務共享使用。所以我們需要一個命名系統來區分不同服務的信息\nZookeeper中包含了3種類型的znode\nRegular znodes 這種znode一旦創建，就永久存在，除非你刪除了它。 Ephemeral znodes 如果Zookeeper認為創建它的客戶端掛了，它會刪除這種類型的znodes 客戶端需要時不時的發送心跳給Zookeeper，這樣Zookeeper才不會刪除客戶端對應的ephemeral znodes。 Sequential znodes Zookeeper實際上創建的文件名是你指定的文件名再加上一個數字。 當有多個客戶端同時創建Sequential文件時，Zookeeper會確保這裡的數字不重合，同時也會確保這裡的數字總是遞增的。 每一個znode都有一個表示當前版本號的version，當znode有更新時，version也會隨之增加\nCREATE(PATH，DATA，FLAG) DELETE(PATH，VERSION) EXIST(PATH，WATCH) GETDATA(PATH，WATCH) SETDATA(PATH，DATA，VERSION) LIST(PATH) acc V是版本號\nWHILE TRUE: X, V = GETDATA(\"F\") IF SETDATA(\"f\", X + 1, V): BREAK Non-Scalable Lock WHILE TRUE: IF CREATE(\"f\", data, ephemeral=TRUE): RETURN IF EXIST(\"f\", watch=TRUE): WAIT 最終鎖會以刪除文件的形式釋放，所以我們這里通過EXIST函數加上watch=TRUE，來監測文件的刪除\n羊群效應（Herd Effect） 對於計數器的例子來說，就是當有1000個客戶端同時需要增加計數器時，我們的複雜度是$O(n^2)$，這是處理完1000個客戶端的請求所需要的總時間。\n$loop * watch通知 = O(n^2)$\nScalable Lock CREATE(\"f\", data, sequential=TRUE, ephemeral=TRUE) WHILE TRUE: LIST(\"f*\") IF NO LOWER #FILE: RETURN IF EXIST(NEXT LOWER #FILE, watch=TRUE): WAIT Chain Replication with Apportioned Queries Chain Replication 所有機器串成linked list，從頭開始處理write，直到碰到最後一個機器才response read就是從tail的狀態直接拉\n可以注意到這個系統是線性一致的!! 同時可以讓read的性能可以scale!!\nFail Recover\nhead, tail fail? 找前一個或是後一個替代 mid fail? 把mid移除，把前一個的write轉給下一個 Chain Replication 與 Raft 從性能上看，對於Raft，如果我們有一個Leader和一些Follower。 Leader需要直接將數據發送給所有的Follower。 所以，當客戶端發送了一個寫請求給Leader，Leader需要自己將這個請求發送給所有的Follower。 然而在Chain Replication中，HEAD只需要將寫請求發送到一個其他節點。 數據在網絡中發送的代價較高，所以Raft Leader的負擔會比Chain Replication中HEAD的負擔更高。 當客戶端請求變多時，Raft Leader會到達一個瓶頸，而不能在單位時間內處理更多的請求。 而同等條件以下，Chain Replication的HEAD可以在單位時間處理更多的請求，瓶頸會來的更晚一些。 另一個與Raft相比的有趣的差別是，Raft中讀請求同樣也需要在Raft Leader中處理，所以Raft Leader可以看到所有的請求。 而在Chain Replication中，每一個節點都可以看到寫請求，但是只有TAIL可以看到讀請求。 所以負載在一定程度上，在HEAD和TAIL之間分擔了，而不是集中在單個Leader節點。 前面分析的故障恢復，Chain Replication也比Raft更加簡單。這也是使用Chain Replication的一個主要動力。 Chain Replication並不能抵禦網絡分區，也不能抵禦腦裂。 總是會有一個外部的權威（External Authority）來決定誰是活的，誰掛了，並確保所有參與者都認可由哪些節點組成一條鏈\nConfiguration Manager的工作就是監測節點存活性，一旦Configuration Manager認為一個節點掛了，它會生成並送出一個新的配置，在這個新的配置中，描述了鏈的新的定義，包含了鏈中所有的節點，HEAD和TAIL\n你是如何使得一個服務是容錯的，不否認自己，同時當有網絡分區時不會出現腦裂呢？ Configuration Manager通常會基於Raft或者Paxos\nAurora RDS的歷史 EC2對於無狀態的Web服務器來說是完美的\n如果突然新增了大量客戶，你可以立刻向Amazon租用更多的EC2實例，並在上面啟動Web服務。這樣你就可以很簡單的對你的Web服務進行擴容\n當Web服務所在的服務器宕機了，是完全沒有問題的，因為Web服務本身沒有狀態，你只需要在一個新的EC2實例上啟動一個新的Web服務就行\n對於數據庫來說，EC2就不像對於Web服務那樣完美了 如果服務器宕機了，那麼它本地硬盤也會無法訪問\n從EC2實例來看，EBS就是一個硬盤，你可以像一個普通的硬盤一樣去格式化它，就像一個類似於ext3格式的文件系統或者任何其他你喜歡的Linux文件系統\n在實現上，EBS底層是一對互為副本的存儲服務器 兩個EBS服務器會使用Chain Replication（9.5）進行複制\n現在你運行了一個數據庫，相應的EC2實例將一個EBS volume掛載成自己的硬盤。當數據庫執行寫磁盤操作時，數據會通過網絡送到EBS服務器。\nEBS的缺點\n如果你在EBS上運行一個數據庫，那麼最終會有大量的數據通過網絡來傳遞 網絡負載更加重要 不太關心CPU和存儲空間的消耗 EBS的容錯性不是很好 出於性能的考慮，Amazon總是將EBS volume的兩個副本存放在同一個數據中心 RDS 將數據庫在多個AZ之間做複製 這樣就算整個數據中心掛了，你還是可以從另一個AZ重新獲得數據而不丟失任何寫操作 對於RDS來說，有且僅有一個EC2實例作為數據庫 這個數據庫將它的data page和WAL Log存儲在EBS，而不是對應服務器的本地硬盤 當數據庫執行了寫Log或者寫page操作時，這些寫請求實際上通過網絡發送到了EBS服務器 每一次數據庫軟件執行一個寫操作，Amazon會自動的，將寫操作拷貝發送到另一個數據中心的AZ中 每一次寫操作，數據除了發送給AZ1的兩個EBS副本之外，還需要通過網絡發送到位於AZ2的副數據庫 副數據庫接下來會將數據再發送給AZ2的兩個獨立的EBS副本 這種Mirrored MySQL比Aurora慢得多的原因是，它通過網絡傳輸了大量的數據\nAurora 在替代EBS的位置，有6個數據的副本，位於3個AZ，每個AZ有2個副本 這里通過網絡傳遞的數據只有Log條目 存儲系統不再是通用（General-Purpose）存儲，這是一個可以理解MySQL Log條目的存儲系統 Aurora並不需要6個副本都確認了寫入才能繼續執行操作 (Quorum) 只要Quorum形成了，也就是任意4個副本確認寫入了，數據庫就可以繼續執行操作 可以處理斷線、太慢的node Quorum 假設有N個副本。為了能夠執行寫請求，必須要確保寫操作被W個副本確認，W小於N Quorum系統要求，任意你要發送寫請求的W個服務器，必須與任意接收讀請求的R個服務器有重疊 這樣任意W個服務器至少與任意R個服務器有一個重合 ($W+R\u003e=N$) 客戶端讀請求可能會得到R個不同的結果，哪一個是正確的呢？ 投票? 可能只有一個是對的 只能確保Read Quorum必須至少與Write Quorum有一個服務器是重合的 版本號（Version） 每一次執行寫請求，你需要將新的數值與一個增加的版本號綁定 從Read Quorum得到了一些回复，客戶端可以直接使用其中的最高版本號的數值 Quorum系統可以調整讀寫的性能。通過調整Read Quorum和Write Quorum，可以使得系統更好的支持讀請求或者寫請求 Aurora’s Quorum 不會直接覆蓋資料，append log Quorum系統通常讀寫的數據都是相同的 數據庫服務器寫入的是Log條目，但是讀取的是page 數據庫服務器會記錄每一個存儲服務器 接收了多少Log 收到的最高連續的Log條目號 當一個數據庫服務器需要執行讀操作，它只會挑選擁有最新Log的存儲服務器，然後只向那個服務器發送讀取page的請求 請求發送到存儲服務器，會要求存儲服務器返回當前最新的page數據。在這個時候，存儲服務器才會將Log條目中的新數據更新到page，並將page寫入到自己的磁盤中，之後再將更新了的page返回給數據庫服務器 數據庫服務器有時也會使用Quorum Read!! 如果DB壞了，監控系統可以檢測到Aurora數據庫服務器崩潰 之後就會要求store server把還沒完成的transation丟了 去找遺失的transaction id，對此跑Quorum Read 讓連到的store server保留遺失的transaction id之前的log sharding 目前為止，我們已經知道Aurora將自己的數據分佈在6個副本上，每一個副本都是一個計算機，上面掛了1-2塊磁盤。\n但是如果只是這樣的話，我們不能擁有一個數據大小大於單個機器磁盤空間的數據庫\n因為雖然我們有6台機器，但是並沒有為我們提供6倍的存儲空間\nAmazon的做法是將數據庫的數據，分割存儲到多組存儲服務器上，每一組都是6個副本，分割出來的每一份數據是10GB\n如果一個數據庫需要20GB的數據，那麼這個數據庫會使用2個PG（Protection Group），其中一半的10GB數據在一個PG中，另一半的10GB數據存儲在另一個PG中 recover 一個store server會有其他PG的其中一塊，如果store server掛了，怎麼復原? 對於每一個數據塊，我們會從Protection Group中挑選一個副本，作為數據拷貝的源。 之後，就可以並行的通過網絡將100個數據塊從100個源拷貝到100個目的\nsingle write 對於Aurora來說，通常會有非常大量的只讀數據庫查詢\n對於寫請求，可以只發送給一個數據庫，因為對於後端的存儲服務器來說，只能支持一個寫入者 Log需要按照數字編號，如果只在一個數據庫處理寫請求，非常容易對Log進行編號\n當客戶端向只讀數據庫發送讀請求，只讀數據庫需要弄清楚它需要哪些data page來處理這個讀請求，之後直接從存儲服務器讀取這些data page，並不需要主數據庫的介入\n只讀數據庫也需要更新自身的緩存，所以，Aurora的主數據庫也會將它的Log的拷貝發送給每一個只讀數據庫\ncache \u0026 Transaction 我們不想要這個只讀數據庫看到未commit的事務。所以，在主數據庫發給只讀數據庫的Log流中，主數據庫需要指出，哪些事務commit了\n數據庫背後的B-Tree結構非常複雜，可能會定期觸發rebalance(需要有原子性)\n數據庫服務器可以通知存儲服務器說，這部分複雜的Log序列只能以原子性向只讀數據庫展示，也就是要就全展示，不然就不展示 (微事務（Mini-Transaction）)\n教訓 數據庫和存儲系統基本是一起開發出來的，數據庫和存儲系統以一種有趣的方式集成在了一起 通常我們設計系統時，需要有好的隔離解耦來區分上層服務和底層的基礎架構 但是在Aurora面臨的問題中，性能問題是非常嚴重的，它不得不通過模糊服務和底層基礎架構的邊界來獲得35倍的性能提升\n雲基礎架構中什麼更重要的隱含信息\n需要擔心整個AZ會出現故障 需要擔心短暫的慢副本，這是經常會出現的問題 網絡是主要的瓶頸，畢竟Aurora通過網絡發送的是極短的數據，但是相應的，存儲服務器需要做更多的工作 明顯，從Amazon看來，網絡容量相比CPU要重要的多 Frangipani 緩存一致性是指，如果我緩存了一些數據，之後你修改了實際數據但是並沒有考慮我緩存中的數據，必須有一些額外的工作的存在，這樣我的緩存才能與實際數據保持一致\n大部分的討論都會假設Petal就是一個被所有Frangipani使用的，基於網絡的共享磁盤。你可以通過一個塊號或者磁盤上的一個地址來讀寫數據，就像一個普通的硬盤一樣\n在每個工作站或者說每個Frangipani服務器上要持有緩存之外，我們還需要支持Write-Back緩存。 這意味著，如果我想要修改某個數據，比如說我修改了一個文件，只要沒有其他的工作站需要看到我的改動，Frangipani通過Write-Back緩存方式管理這些數據\n在這樣的架構下，一個非常重要的後果是，文件系統的邏輯需要存在於每個工作站上，所有的複雜的邏輯都在工作站中的Frangipani模塊中\n所有的這些修改最初只會在本地緩存中存在，因此類似於創建文件的操作可以非常快的完成，因為只需要修改本地的內存中對於磁盤的緩存。而這些修改要過一會才會寫回到Petal (複雜度的開始)\nFrangipani的挑戰（Challenges） 緩存 文件系統必須要做一些事情來確保客戶端可以讀到最新的寫入文件 (強一致或者線性一致) 但是在一個緩存的環境中，現在說的一致性的問題不是指存儲服務器的一致性，而是 指工作站上的一些修改需要被其他工作站看到 (Cache Coherence) 由於Write-Back緩存，可能會在本地的緩存中堆積了大量的修改 如果我的工作站崩潰了，但是這時這些修改只有部分同步到了Petal，還有部分仍然只存在於本地 我的工作站在執行操作的過程中的崩潰，最好不要損壞其他人同樣會使用的文件系統 (crash recovery) 去中心化的架構帶來的大量的邏輯存在於客戶端之中進而引起的問題 因為所有的文件和目錄都是共享的，非常容易會有兩個工作站在同一個時間修改同一個目錄 (Atomicity) 我們希望類似於創建文件，刪除文件這樣的操作表現的就像即時生效的一樣，同時不會與相同時間其他工作站的操作相互干擾 緩存一致性 Frangipani的緩存一致性核心是由鎖保證的，我們之後在原子性和故障恢復中將會再次看到鎖。\nLock server\nserver 本身 file到owner的map 我們假設鎖是排他鎖（Exclusive Lock），儘管實際上Frangipani中的鎖更加複雜可以支持兩種模式：要么允許一個寫入者持有鎖，要么允許多個讀取者持有鎖 workstation file, lock state, file content的table BUSY: 正在跑syscall IDLE: syscall跑完了 只要係統調用結束了，工作站會在內部釋放鎖 但是從鎖服務器的角度來看，工作站仍然持有鎖 (延遲將鎖還給鎖服務器) 像是folder，就算read好，也許還會在目錄底下再做一些事 Frangipani應用了很多的規則，這些規則使得Frangipani以一種提供緩存一致性的方式來使用鎖\n工作站不允許持有緩存的數據，除非同時也持有了與數據相關的鎖 先向Petal存儲系統寫數據，之後再釋放鎖 如果你在釋放鎖之前，修改了鎖保護的數據，那你必須將修改了的數據寫回到Petal，只有在Petal確認收到了數據，你才可以釋放鎖 最後再從工作站的lock表單中刪除關文件的鎖的記錄和緩存的數據 緩存一致性的訊息 Request: 拿鎖 Grant: lock server通知拿到鎖了 如果從鎖服務器的lock表單中發現鎖已經被其他人持有了，那鎖服務器不能立即交出鎖。 但是一旦鎖被釋放了，鎖服務器會回復一個Grant消息給工作站 這裡的Request和Grant是異步的 Revoke: 要求歸還鎖 如果別人要用，同時workstation的lock state是idle，就會開始跑release lock Release: 還鎖 在還之前會先把log與髒的資料寫回去 優化 idle做延遲還鎖 Frangipani有共享的讀鎖（Shared Read Lock）和排他的寫鎖（Exclusive Write Lock） 原子性（Atomicity） 要么發現文件不存在，要么文件完全存在，但是我們絕不希望它看到中間狀態\nFrangipani在內部實現了一個數據庫風格的事務系統，並且是以鎖為核心。並且，這是一個分佈式事務系統\n首先我的工作站需要獲取所有我需要讀寫數據的鎖，在完成操作之前，我的工作站不會釋放任何一個鎖 為了遵循一致性規則（11.3），將所有修改了的數據寫回到Petal之後，我的工作站才會釋放所有的鎖 之後完成所有的步驟，比如完成所有數據的更新，並將更新寫入到Petal，最後釋放鎖 Frangipani使用鎖實現了兩個幾乎相反的目標。 對於緩存一致性，這裡使用鎖來確保寫操作可以被看見。 但是對於原子性來說，鎖確保了人們在操作完成之前看不到任何寫操作\nFrangipani與其他的系統一樣，需要通過預寫式日誌（Write-Ahead Log，WAL，見10.2）實現故障可恢復的事務（Crash Recoverable Transaction）\n當一個工作站需要完成涉及到多個數據的複雜操作時，在工作站向Petal寫入任何數據之前，工作站會在Petal中自己的Log列表中追加一個Log條目，這個Log條目會描述整個的需要完成的操作\n只有當這個描述了完整操作的Log條目安全的存在於Petal之後，工作站才會開始向Petal發送數據\nFrangipani對於每個工作站都保存了一份獨立的Log (一般都是share一個log) 工作站的Log存儲在Petal，而不是本地磁盤中 每個工作站的獨立的Log，存放在公共的共享存儲中 log裡面有 (Log只包含了對於元數據的修改) Log序列號 (找最新的log) 數組中的每一個元素會有一個Petal中的塊號（Block Number），一個版本號和寫入的數據 類似的數組元素會有多個，這樣就可以用來描述涉及到修改多份文件系統數據的操作。 向Petal寫入數據的時候，如果我們在中途故障退出了，我們需要確認其他組件有足夠的信息能完成我們未完成修改 (log) 如果出事可以讓其他workstation利用原本的log redo!! Distributed Transaction 並發控制（Concurrency Control） 並發控制就是可序列化的別名 Pessimistic (mutex) 兩階段鎖（Two-Phase Locking） 在使用任何數據之前，在執行任何數據的讀寫之前，先獲取鎖 事務必須持有任何已經獲得的鎖，直到事務提交或者Abort，你不允許在事務的中間過程釋放鎖 Optimistic (rwlock) 原子提交（Atomic Commit） 從部分故障中恢復的能力 兩階段提交（Two-Phase Commit） 除了原本的DB，還有一台Transaction Coordinator 因為是transaction，各自的DB會拿有關的所有鎖 開始跑指令 發preare問參與事務的DB好了沒 TC發prepare/commit之前掛了 基於log，重發 (可能需要標這是重複的) TC發prepare/commit之後掛了 log還原自己的狀態 DB收到preare前掛了 DB重開，發現沒有log，回abort DB收到prepare在回了yes之後掛掉 transaction的動作、相關狀態，再回prepare之前都要在log DB重開，有log與prepare，之後TC發prepare就能回yes 都好了就發commit DB收到commit之後掛了 回yes之前掛了 redo, 回yes 回完yes之後掛了 這個時候所有有關的log都被清了(也許)與該改的都寫到HDD了 有可能DB是找不到commit相關訊息的 不論怎樣，DB都會直接回yes 如果遇到網路斷線?\nTC可以retry，如果太久就abort DB是根據prepare的回答 no 自己abort，之後TC的prepare就發no yes 就是等TC的指令，剩下都不能動!! 只要回prepare yes就是等 (BLOCK) A或者B不能決定Commit還是不Commit事務，A和B之間不會交互來達成一致並完成事務的Commit，相反的只有事務協調者可以做決定 數據庫通常對於正確性有一個概念稱為ACID\n可序列化是指，並行的執行一些事物得到的結果，與按照某種串行的順序來執行這些事務，可以得到相同的結果\n使用Raft可以通過將數據複製到多個參與者得到高可用。 Raft的意義在於，即使部分參與的服務器故障了或者不可達，系統仍然能工作。 Raft能做到這一點是因為所有的服務器都在做相同的事情，所以我們不需要所有的服務器都參與，我們只需要過半服務器參與\n兩階段提交，參與者完全沒有在做相同的事情，每個參與者都在做事務中的不同部分，比如A可能在對X加1，B可能在對Y減1。 所以在兩階段提交中，所有的參與者都在做不同的事情。 所有的參與者都必須完成自己那部分工作，這樣事務才能結束，所以這裡需要等待所有的參與者。\nRaft完全就是可用性，而兩階段提交完全不是高可用的，系統中的任何一個部分出錯了，系統都有可能等待直到這個部分修復\n同時具備Raft的高可用性，但同時又有兩階段提交的能力將事務分包給不同的參與者。 這裡的結構實際上是，通過Raft或者Paxos或者其他協議，來複製兩階段提交協議裡的每一個組成部分。 spanner 需求 \u0026 前提 大部分的workload都是read-only transactions read要快 spanner區分read/write \u0026 read/only transaction 更好的synchronous replication flexible sharding 分散式transaction (橫跨多個shard) 2pc真的慢，要別的方法 External consistency linearizability + serializability 為了可用性，所以把distributed tranasaction的每個元件包成one Paxos group\nread/write transactions two-phase commit (2pc) with Paxos-replicated participants 基本上與2pc步驟一樣但是所有溝通都是由各個shard的leader做 在shard的leader中有lock table 2pc所以很慢 parallelism many clients, many shards read/only transactions 兩個重點 沒有2pc 只從local replica讀 正確性 Serializable Externally consistent 為什麼不直接讀最新commit的值? T1: Wx Wy C T2: Wx Wy C T3: Rx Ry Snapshot Isolation (SI) 用wall-time做timestamp(TS) 怎麼synchronize wall-time? TrueTime TTinterval = [ earliest, latest ] 在這個區間一定有對的時間 只拉同一個TS的資料(最少不能超過read的TS) 怎麼確保replica夠新? replica “safe time” read上給時間，直到replica上看到write的時間夠後面才serve 每個transaction都有time-stamp r/w: commit time. r/o: start time. Synchronized timestamps確保external consistency (commit wait) SI確保serializable r/o transactions 怎麼確保r/w在r/o之前完成 (Commit wait) 定義transacation的TS xaction TS = TT.now().latest for r/o, at start time for r/w, when commit begins 在r/w跑commit之前，Commit wait Before commit, delay until TS \u003c TS.now().earliest FaRM, Optimistic Concurrency Control FaRM \u0026 Spanner差在 都用2pc Spanner geographic replication r/o transaction \u0026 TrueTime bottleneck: speed of light and network delays FaRM 都在同一個data center RDMA(remote dma)限制只能用Optimistic Concurrency Control (OCC) Optimistic Concurrency Control steps read不用lock write直到commit才會真的寫入 commit檢查有沒有衝突 不用server參與!! one-sided RDMA sender給mem addr, read整個cache line bottleneck: CPU time on servers 都用ram存資料 non-volatile RAM 每個rack都有電池在出事之前可以把ram寫到hdd 架構 API(simplified) FaRM transaction API (simplified): txCreate() o = txRead(oid) – RDMA oid? region # indexes a mapping to [ primary, backup1, ... ] target RDMA NIC uses address directly to read or write RAM o.f += 1 txWrite(oid, o) – purely local ok = txCommit() – Figure 4 流程 跑指令 LOCK 檢查lock state, version 往primary上打log，之後等return yes VALIDATE one-sided RDMA read to re-fetch object’s version and lock flag fail early T1: Rx Ly Vx Cy T2: Ry Lx Vy Cx LOCKs will both succeed VALIDATEs will both fail COMMIT BACKUP 在commit之前至少backup要有法定人數台機器有新的值 a committed write might be revealed as soon the first COMMIT-PRIMARY is sent LOCK 通知 primaries 有新值 COMMIT-BACKUP 通知 backups 有新值 不一定馬上處理，會放在log中 直到LOCKs與COMMIT-BACKUPS都完成，TC才發COMMIT-PRIMARY 2pc中COMMIT之後就是 狀態都ok了 不能回頭了 COMMIT PRIMARY 就是最後的commit 往primary上打log primary清狀態, version++, 把值寫進去 fault tolerance? 假設總是有一個backup在 spark skip\nScaling Memcache at Facebook 網站的成長旅程 一台host = web server + DB + app app吃爆cpu 多台web server + app, 一台DB DB只有一台 多台web server + app, 多台DB 做shard，如果沒有特別熱門的key就沒事 cross-shard transactions \u0026 queries基本不能做了 read變慢!! 多台web server + app, 多台DB for write, cache for read cache怎麼與db sync 沒有成功cache hit，DB的load直接起飛 warm-up cache miss 接下去就是DB write，但這很難解 教訓 partition 或 replicate\npartition: divide keys over mc servers good: ram花得少 (kv不用重複copy) bad: web server要一次問很多台 huge “fan-out” =\u003e parallel fetch, in-cast congestion 適用: key沒有很熱門 (不用每個data center都放) replicate: divide clients over mc servers good: 比較少tcp連線 bad: 比較少key能被cache 適用: key很熱門 region (data center)\nlower RTT to users quick local reads, from local mc and DB writes 很慢，一定要到primary 多 mc clusters 在 每個 region “regional pool” shared by all clusters =\u003e unpopular objects (no need for many copies) warmup is painful\nget miss =\u003e 打DB =\u003e 去set cache 只給第一個req設定cache的權限(lease) 其他就先等 mc tells others “try get() again in a few milliseconds” 容錯?\npool of idle mc servers, clients only use after mc server fails 網路\nget UDP set TCP 把req累積成一個packet mcrouter batches many requests into each packet consistency not more than a few seconds stale read-your-own-writes (due to delete()) cache怎麼與DB sync (delete) DB去做 writing client去做 delete會有racing\nRace 1 真正的race, 用樂觀鎖、rwlock解\nk not in cache C1 get(k), misses C1 v1 = read k from DB C2 writes k = v2 in DB C2 delete(k) C1 set(k, v1) get時會給一個lease，如果有delete就會把lease取消掉，之後看有沒有lease決定要不要吃這個set\nRace 2 與race3很像，都是因為write傳播太慢，導致source資料不對，這裡因為是cold所以只能從hot copy，所以wait hot試試看有沒有可能ok\n在warm-up時，get從warm cluster拉資料 k starts with value v1 C1 updates k to v2 in DB C1 delete(k) -- in cold cluster C2 get(k), miss -- in cold cluster C2 v1 = get(k) from warm cluster, hits C2 set(k, v1) into cold cluster cold cluster會在2秒中忽略set，去等warm收到DB資料\nRace 3 source是local db，但是我們知道才剛update，所以標上要從remote拉\nk starts with value v1 C1 is in a secondary region C1 updates k=v2 in primary DB C1 delete(k) -- local region C1 get(k), miss C1 read local DB -- sees v1, not v2! later, v2 arrives from primary DB C1做delete時把key標上\"remote mark\" 讓後面的人去DB拉資料\nCausal Consistency, COPS we’ve seen two solutions for geo-replication Spanner writes involve Paxos and perhaps two-phase commit Paxos quorum for write must wait for some remote sites no one site can write on its own but has read transactions, consistent, fairly fast Facebook / Memcache writes must go to the primary site’s MySQL again, non-primary sites cannot write on their own but reads are blindingly fast (1,000,000 per second per memcache server)\n情境 3 data centers data centers有各自的shard ver1: eventually consistent reads and writes just local shard\n會自己把write推到其他data center eventually consistent\nclient看到update的順序不確定 write要等夠久才看的到 例子 quorum, with overlap (Dynamo/Cassandra) local write + asynchronously push 每個put加個timestamp(version)?\nCOPS用Lamport clocks設定timestamp Tmax = highest v# seen (from self and others) T = max(Tmax + 1, wall-clock time) concurrent write時，要選哪一個write? last-writer-wins? increment a counter時會起飛 需要其他方式做merge real transactions mini-transactions (atomic) 特定的合併方式 (set union) action transform mvcc resolution of conflicting writes is a problem for eventual/causal consistency no single “serialization point” to implement atomic operations or transactions ver2: barrier 留個sync指令 直到確認每個datacenter都有夠新的key才return 需要等 (慢) 但其他work其實寫都要等 spanner等majority of replica fb’s cache等primary datacenter 不需要transaction不失為一個不錯的方案 ver3: log 每個datacenter都有一個log server write對應到一個log datacenter把log送到其他datacenter datacenter照log順序跑 log server會是bottleneck COPS: client’s context client的context會記錄下指令的順序 這就是dependency get(X)-\u003ev2 context: Xv2 get(Y)-\u003ev4 context: Xv2, Yv4 put(Z, -)-\u003ev3 client sends Xv2, Yv4 to shard server along with new Z context: Xv2, Yv4, Zv3 (COPS optimizes this to just Zv3) shard怎麼處理? local shard 收到put(Z, -, Yv4) 設定時間: v# = 3 for Z write: Z, -, v3 傳送到其他datacenter(不等reply) remote shard 收到Z/-/v3/Yv4 會等到Yv4到了才設定Z/-/v3 causal consistency dependency來自?\nclient的一連串puts and gets 當read來自其他client資料的時候 這dependency是transitive\n可能拿到比想像中更新的資料\n不能用在transaction或是snapshot get_trans(k1,k2,…)\nclient檢查dep對不對，不對就重拿不對的 只有read的mini-transaction scenerio: ACL get(ACL), then get(list)? what if someone deletes you from ACL, then adds a photo? get(list), then get(ACL)? what if someone deletes photo, then adds you to ACL? for ACL / list example: C1: get_trans(ACL, list) C1: get(ACL) -\u003e v1, no deps C2: put(ACL, v2) C2: put(list, v2, deps=ACL/v2) C1: get(list) -\u003e v2, deps: ACL/v2 (C1 checks dependencies against value versions) C1: get(ACL) -\u003e v2 (now C1 has a causally consistent pair of get() results) Secure Untrusted Data Repository (SUNDR) integrity source code的server bad 在source code放backdoor 忽略一些fix Serious problem Paper mentions Debian server compromised in 2003. SourceForge compromised in 2011. Canonical (Ubuntu) compromised in 2019. Naive design: sign file contents. 只能保證檔案內容與作者是誰 但server可以 亂送其他版本的檔案 假裝檔案不在 Fork consistency 每個fork看到都一樣 容易找出攻擊 難以假造log SUNDR: log of operations. log: fetch or modify, user, sig. 簽名要包含所有log steps 下載log check log 做事(Construct FS state) 加上log與簽名 上傳log 包含所有log?! 超慢 簽名慢 check慢 優化 只看最後一個簽名 (前面的一定被確認過了) 只要簽自己改過的地方就好 (一堆inode =\u003e i-table) Idea: signed version vectors. Version vector: user -\u003e how many operations that user performed. Version structure: signed i-handle together with version vector.\nConsistency Consistency就是發生效果的亂序程度 越弱越難預期\n有兩個排序單位\noperation transaction eventual Consistency 總有一天會拿到最新的結果 沒有時間序、執行序\nCausal Consistency 某部分效果發生是有序的(有因果關係) 這也是通常concurrent programming使用的Consistency\nSequential Consistency 效果發生照執行序來，所以如果concurrent可能有超過一種排列組合\n因為一般concurrent programming沒有transaction的概念，所以從這開始就有人叫strong Consistency\nLinearizability 照執行序來、時間序 (看前面的定義) 但是transaction的執行順序不確定(也許r/w有序，但ro穿插其間)\nStrict Serializability 照執行序來、執行序、transaction的執行順序確定\n一般提到distributed system的consistemcy最多提到上面5種，因為通常討論transaction都是DB範圍\n比較完整的圖在這 可以到來源看定義\n這邊備註一下PRAM，就是FIFO Consistency(zookeeper)\nRef Consistency Consistency Models\nbitcoin 在byzantine中共識 像SUNDR 簽過的log與fork 不像SUNDR 分散式的選用fork 組成 ledger record\npub(user1) 新owner的public key hash(prev) 前一個transaction的hash sig(user2) 前owner的簽名 (其他: amount (fractional), multiple in/out, …) transaction 例子\nY 擁有一枚硬幣，之前由 X 給它： T6：pub(X)，… T7：pub(Y)、hash(T6)、sig(X) Y 從 Z 買了一個漢堡包並用這枚硬幣付款 Z 將公鑰發送給 Y Y 創建一個新交易並對其進行簽名 T8：pub(Z)、hash(T7)、sig(Y) Y 向 Z 發送交易記錄 Z 驗證： T8 的 sig(Y) 對應 T7 的 pub(Y) Z給Y漢堡包 block chain\n一個coin可以花兩次嗎? 可以，創兩個transaction coin其實源自於transaction，有transaction才有coin 別阿 需要一個共同依據 fork consistency 有所有交易紀錄 大家看到的都一樣的 做了就不能反悔 參與者可能會做壞事 挑最長的chain block有 hash(prevblock) set of transactions current time (wall clock timestamp) “nonce” (類似隨機資料) 誰可以產生block miner (proof-of-work, nonce要有N個0，所以要try) 怎麼交易 假設現在block在B7 payer先flood我要交易到peer miner把交易記錄起來，等B8(目前mine的block)好 每10分鐘一個block產生 把交易記錄放到B9 payee看到交易記錄就可以接受交易 能產生分支嗎? 能 在同一時間找到同樣的nonce network問題 怎麼處理 miner挑最長的append 這能hack吧 (yes) 但要能做出更長的chain 壞處 超慢 flood限制效能與攻擊點 只要有人有過半的算力就能控制整個chain user要保護好private key DAPP DAPP怎麼工作的 從remote server拉資料 DAPP處理寫回去 好處 換app很方便，因為資料不會被綁在app上 todo的項目可以在todo list, microsoft todo上通用 app有通用的資料格式 壞處 分散式很複雜 資料加密與server安全 Ref 6.824的部分中文翻譯 MIT6.824_2021_note 分布式系统概念简介及其问题的描述 Design Principles\n","wordCount":"2051","inLanguage":"en","datePublished":"2022-03-11T23:23:53Z","dateModified":"2022-03-11T23:23:53Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2022/03/mit-6.824%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">mit 6.824筆記</h1><div class=post-meta><span title='2022-03-11 23:23:53 +0000 UTC'>March 11, 2022</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#intro aria-label=intro>intro</a></li><li><a href=#mapreduce aria-label=mapreduce>mapreduce</a></li><li><a href=#gfs aria-label=gfs>gfs</a></li><li><a href=#vmware-ft aria-label="vmware ft">vmware ft</a></li><li><a href=#raft aria-label=raft>raft</a></li><li><a href=#linearizability aria-label=Linearizability>Linearizability</a></li><li><a href=#zookeeper aria-label=zookeeper>zookeeper</a><ul><li><a href=#first-in-first-out-order aria-label="first-in-first-out order">first-in-first-out order</a></li><li><a href=#api aria-label=API>API</a><ul><li><a href=#acc aria-label=acc>acc</a></li><li><a href=#non-scalable-lock aria-label="Non-Scalable Lock">Non-Scalable Lock</a></li><li><a href=#scalable-lock aria-label="Scalable Lock">Scalable Lock</a></li></ul></li></ul></li><li><a href=#chain-replication-with-apportioned-queries aria-label="Chain Replication with Apportioned Queries">Chain Replication with Apportioned Queries</a><ul><li><a href=#chain-replication aria-label="Chain Replication">Chain Replication</a></li><li><a href=#chain-replication-%e8%88%87-raft aria-label="Chain Replication 與 Raft">Chain Replication 與 Raft</a></li></ul></li><li><a href=#aurora aria-label=Aurora>Aurora</a><ul><li><a href=#rds%e7%9a%84%e6%ad%b7%e5%8f%b2 aria-label=RDS的歷史>RDS的歷史</a></li><li><a href=#rds aria-label=RDS>RDS</a></li><li><a href=#aurora-1 aria-label=Aurora>Aurora</a><ul><li><a href=#sharding aria-label=sharding>sharding</a><ul><li><a href=#recover aria-label=recover>recover</a></li><li><a href=#single-write aria-label="single write">single write</a></li><li><a href=#cache--transaction aria-label="cache & Transaction">cache & Transaction</a></li></ul></li><li><a href=#%e6%95%99%e8%a8%93 aria-label=教訓>教訓</a></li></ul></li></ul></li><li><a href=#frangipani aria-label=Frangipani>Frangipani</a><ul><li><a href=#frangipani%e7%9a%84%e6%8c%91%e6%88%b0challenges aria-label=Frangipani的挑戰（Challenges）>Frangipani的挑戰（Challenges）</a></li><li><a href=#%e7%b7%a9%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=緩存一致性>緩存一致性</a><ul><li><a href=#%e7%b7%a9%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e7%9a%84%e8%a8%8a%e6%81%af aria-label=緩存一致性的訊息>緩存一致性的訊息</a></li><li><a href=#%e5%84%aa%e5%8c%96 aria-label=優化>優化</a></li></ul></li><li><a href=#%e5%8e%9f%e5%ad%90%e6%80%a7atomicity aria-label=原子性（Atomicity）>原子性（Atomicity）</a></li></ul></li><li><a href=#distributed-transaction aria-label="Distributed Transaction">Distributed Transaction</a></li><li><a href=#spanner aria-label=spanner>spanner</a><ul><li><a href=#%e9%9c%80%e6%b1%82--%e5%89%8d%e6%8f%90 aria-label="需求 & 前提">需求 & 前提</a></li><li><a href=#readwrite-transactions aria-label="read/write transactions">read/write transactions</a></li><li><a href=#readonly-transactions aria-label="read/only transactions">read/only transactions</a></li></ul></li><li><a href=#farm-optimistic-concurrency-control aria-label="FaRM, Optimistic Concurrency Control">FaRM, Optimistic Concurrency Control</a><ul><li><a href=#farm--spanner%e5%b7%ae%e5%9c%a8 aria-label="FaRM & Spanner差在">FaRM & Spanner差在</a></li><li><a href=#%e6%9e%b6%e6%a7%8b aria-label=架構>架構</a><ul><li><a href=#apisimplified aria-label=API(simplified)>API(simplified)</a></li><li><a href=#%e6%b5%81%e7%a8%8b aria-label=流程>流程</a></li></ul></li></ul></li><li><a href=#spark aria-label=spark>spark</a></li><li><a href=#scaling-memcache-at-facebook aria-label="Scaling Memcache at Facebook">Scaling Memcache at Facebook</a><ul><li><a href=#%e7%b6%b2%e7%ab%99%e7%9a%84%e6%88%90%e9%95%b7%e6%97%85%e7%a8%8b aria-label=網站的成長旅程>網站的成長旅程</a></li><li><a href=#%e6%95%99%e8%a8%93-1 aria-label=教訓>教訓</a></li><li><a href=#consistency aria-label=consistency>consistency</a></li><li><a href=#race-1 aria-label="Race 1">Race 1</a></li><li><a href=#race-2 aria-label="Race 2">Race 2</a></li><li><a href=#race-3 aria-label="Race 3">Race 3</a></li></ul></li><li><a href=#causal-consistency-cops aria-label="Causal Consistency, COPS">Causal Consistency, COPS</a><ul><li><a href=#%e6%83%85%e5%a2%83 aria-label=情境>情境</a></li><li><a href=#ver1-eventually-consistent aria-label="ver1: eventually consistent">ver1: eventually consistent</a></li><li><a href=#ver2-barrier aria-label="ver2: barrier">ver2: barrier</a></li><li><a href=#ver3-log aria-label="ver3: log">ver3: log</a></li><li><a href=#cops-clients-context aria-label="COPS: client&rsquo;s context">COPS: client&rsquo;s context</a><ul><li><a href=#shard%e6%80%8e%e9%ba%bc%e8%99%95%e7%90%86 aria-label=shard怎麼處理?>shard怎麼處理?</a></li><li><a href=#causal-consistency aria-label="causal consistency">causal consistency</a></li></ul></li></ul></li><li><a href=#secure-untrusted-data-repository-sundr aria-label="Secure Untrusted Data Repository (SUNDR)">Secure Untrusted Data Repository (SUNDR)</a><ul><li><a href=#integrity aria-label=integrity>integrity</a></li><li><a href=#naive-design-sign-file-contents aria-label="Naive design: sign file contents.">Naive design: sign file contents.</a></li><li><a href=#fork-consistency aria-label="Fork consistency">Fork consistency</a></li><li><a href=#sundr-log-of-operations aria-label="SUNDR: log of operations.">SUNDR: log of operations.</a></li></ul></li><li><a href=#consistency-1 aria-label=Consistency>Consistency</a><ul><li><a href=#ref aria-label=Ref>Ref</a></li></ul></li><li><a href=#bitcoin aria-label=bitcoin>bitcoin</a><ul><li><a href=#%e5%9c%a8byzantine%e4%b8%ad%e5%85%b1%e8%ad%98 aria-label=在byzantine中共識>在byzantine中共識</a></li><li><a href=#%e7%b5%84%e6%88%90 aria-label=組成>組成</a></li><li><a href=#%e5%a3%9e%e8%99%95 aria-label=壞處>壞處</a></li></ul></li><li><a href=#dapp aria-label=DAPP>DAPP</a><ul><li><a href=#dapp%e6%80%8e%e9%ba%bc%e5%b7%a5%e4%bd%9c%e7%9a%84 aria-label=DAPP怎麼工作的>DAPP怎麼工作的</a></li><li><a href=#%e5%a5%bd%e8%99%95 aria-label=好處>好處</a></li><li><a href=#%e5%a3%9e%e8%99%95-1 aria-label=壞處>壞處</a></li></ul></li><li><a href=#ref-1 aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>筆記</p><h2 id=intro>intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>提醒大家，在你設計一個系統時或者面對一個你需要解決的問題時，如果你可以在一台計算機上解決，而不需要分佈式系統，那你就應該用一台計算機解決問題</p><p>有很多的工作都可以在一台計算機上完成，並且通常比分佈式系統簡單很多。所以，在選擇使用分佈式系統解決問題前，你應該要充分嘗試別的思路，因為分佈式系統會讓問題解決變得複雜</p><p>分佈式系統的問題（挑戰）在於</p><ul><li>並發</li><li>局部錯誤<ul><li>一部分組件在工作、另一部分組件停止運行</li><li>這些計算機都在正常運行，但是網絡中斷了或者不穩定</li></ul></li><li>實際上一千台機器到底有多少性能是一個棘手的問題</li></ul><p>基礎架構</p><ul><li>存儲</li><li>通信（網絡）</li><li>計算</li></ul><p>我們希望通過這種抽象的接口，將分佈式特性隱藏在整個系統內
我們的確也需要構建這樣一種基礎架構，它能夠盡可能多的對應用開發人員屏蔽和掩蓋錯誤</p><ul><li>性能 => 可擴展性(Scalability)</li><li>容錯 => 可用性(Availability)<ul><li>大型分佈式系統中有一個大問題，那就是一些很罕見的問題會被放大<ul><li>1000台計算機的集群中，總是有故障<ul><li>主機</li><li>網路</li></ul></li></ul></li><li>recoverability<ul><li>如果出現了問題，服務會停止工作，不再響應請求，之後有人來修復，並且在修復之後系統仍然可以正常運行，就像沒有出現過問題一樣</li><li>為了實現這些特性，有很多工具<ul><li>非易失存儲（non-volatile storage，類似於硬盤）<ul><li>checkpoint, log</li></ul></li><li>複製（replication）<ul><li>關鍵問題在於，這兩個副本總是會意外的偏離同步的狀態，而不再互為副本</li></ul></li></ul></li></ul></li></ul></li><li>一致性（Consistency）<ul><li>一致性就是用來定義操作行為的概念 (多個副本)<ul><li>強一致（Strong Consistency）<ul><li>強一致可以確保get獲取的是最新的數據，但是實現這一點的代價非常高</li><li>分佈式系統的各個組件需要做大量的通信，才能實現強一致性</li></ul></li><li>弱一致</li></ul></li></ul></li></ul><p>分佈式存儲系統的難點 (loop)</p><ol><li>巨大的性能加成 > 分片</li><li>分片（Sharding），但你將會看見常態的故障 > 容錯（fault tolerance）</li><li>複製（replication） > 不一致（inconsistency）</li><li>強一致 > 低性能</li></ol><h2 id=mapreduce>mapreduce<a hidden class=anchor aria-hidden=true href=#mapreduce>#</a></h2><p><img loading=lazy src=https://i.imgur.com/Ze0To9i.png alt></p><p>這裡確實需要將每一份數據都通過網絡從創建它的Map節點傳輸到需要它的Reduce節點
這裡實際上可能會有大量的網絡通信</p><h2 id=gfs>gfs<a hidden class=anchor aria-hidden=true href=#gfs>#</a></h2><p>設計與目標</p><ul><li>big,fast</li><li>global</li><li>sharding</li><li>automatic recovering</li></ul><p>前提</p><ul><li>single data centor</li><li>internal use</li><li>big sequential access<ul><li>沒有random access</li></ul></li></ul><p><img loading=lazy src=https://i.imgur.com/nAtlONs.png alt></p><p>Master節點用來管理文件和Chunk的信息
Chunk服務器用來存儲實際的數據</p><p>Master節點知道每一個文件對應的所有的Chunk的ID，這些Chunk每個是64MB大小，它們共同構成了一個文件</p><p>master node</p><ul><li>filename<ul><li>很多chunk id</li></ul></li><li>chunk id<ul><li>chunk server的列表</li><li>version</li><li>是不是primary chunk<ul><li>write只能在primary上跑</li></ul></li><li>租約時間</li></ul></li></ul><p>Master會在磁盤上存儲log，每次有數據變更時，Master會在磁盤的log中追加一條記錄，並生成CheckPoint（類似於備份點）</p><p>read</p><ul><li>filename + offset -> chunk id + chunk server list</li><li>選一個chunk server -> chunk id + offset</li><li>從一般的fs拿檔案</li></ul><p>write(只有append)</p><p>當有多個客戶端同時寫同一個文件時，一個客戶端並不能知道文件究竟有多長
沒有一個客戶端會知道文件究竟有多長，因此也就不知道該往什麼樣的偏移量，或者說向哪個Chunk去追加數據。
客戶端可以向Master節點查詢哪個Chunk服務器保存了文件的最後一個Chunk。</p><p>對於某個特定的Chunk來說，在某一個時間點，Master不一定指定了Chunk的主副本。所以，寫文件的時候，需要考慮Chunk的主副本不存在的情況</p><p>如果發現Chunk的主副本不存在，Master會找出所有存有Chunk最新副本的Chunk服務器</p><p>當客戶端想要對文件進行追加，但是又不知道文件尾的Chunk對應的Primary在哪時，Master會等所有存儲了最新Chunk版本的服務器集合完成，然後挑選一個作為Primary，其他的作為Secondary</p><p>Master會增加版本號，並將版本號寫入磁盤，這樣就算故障了也不會丟失這個數據</p><p>Master節點會向Primary和Secondary副本對應的服務器發送消息並告訴它們，誰是Primary，誰是Secondary，Chunk的新版本是什麼</p><p><img loading=lazy src=https://i.imgur.com/HrX1jfF.png alt></p><ol><li>client寫資料到各個chunk<ul><li>客戶端會將要追加的數據發送給Primary和Secondary服務器，這些服務器會將數據寫入到一個臨時位置。</li><li>最開始，這些數據不會追加到文件中</li></ul></li><li>當所有的服務器都返回確認消息說，已經有了要追加的數據，客戶端會向Primary服務器發送一條消息，將這個數據追加到這個文件中</li><li>Primary服務器或許會從大量客戶端收到大量的並發請求，Primary服務器會以某種順序，一次只執行一個請求</li><li>Primary會通知所有的Secondary服務器也將客戶端要追加的數據寫入在它們自己存儲的Chunk末尾</li></ol><p>如果客戶端從Primary得到寫入失敗，那麼客戶端應該重新發起整個追加過程</p><p><img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MDlKCEjhSvXUjjI5-cA%2F-MDlKDmNVgE32Zun9zdo%2Fimage.png?alt=media&amp;token=59bbb2b4-d90b-461c-9417-811035ed972f" alt></p><p>GFS這樣設計的理由是足夠的簡單，但是同時也給應用程序暴露了一些奇怪的數據
這里希望為應用程序提供一個相對簡單的寫入接口，但應用程序需要容忍讀取數據的亂序</p><p>將GFS升級成強一致系統，我可以為你列舉一些你需要考慮的事情</p><ul><li>讓Primary來探測重複的請求</li><li>對於Secondary來說，如果Primay要求Secondary執行一個操作，Secondary必須要執行而不是只返回一個錯誤給Primary<ul><li>於一個嚴格一致的系統來說，是不允許Secondary忽略Primary的請求而沒有任何補償措施的</li></ul></li><li>當Primary要求Secondary追加數據時，直到Primary確信所有的Secondary都能執行數據追加之前，Secondary必須小心不要將數據暴露給讀請求<ul><li>第一個階段，Primary向Secondary發請求，要求其執行某個操作，並等待Secondary回复說能否完成該操作，這時Secondary並不實際執行操作。</li><li>在第二個階段，如果所有Secondary都回复說可以執行該操作，這時Primary才會說，好的，所有Secondary執行剛剛你們回复可以執行的那個操作</li><li>兩階段提交（Two-phase commit）</li></ul></li><li>新的Primary上任時，需要顯式的與Secondary進行同步<ul><li>當Primary崩潰時，可能有一組操作由Primary發送給Secondary</li></ul></li><li>要么對於Secondary需要一個租約系統，就像Primary一樣，這樣就知道Secondary在哪些時間可以合法的響應客戶端</li></ul><p>就是raft!!</p><h2 id=vmware-ft>vmware ft<a hidden class=anchor aria-hidden=true href=#vmware-ft>#</a></h2><p>複製不能處理軟件中的bug和硬件設計中的缺陷</p><p>如果我們有兩個副本，一個Primay和一個Backup節點，我們總是假設兩個副本中的錯誤是相互獨立的。但是如果它們之間的錯誤是有關聯的，那麼複製對我們就沒有幫助</p><p>這種複制的方案是否值得？因為它使用了我們實際需要的2-3倍的計算機資源</p><p>State Transfer
Primary將自己完整狀態，比如說內存中的內容，拷貝並發送給Backup</p><p>Replicated State Machine
它只會從Primary將這些外部事件，例如外部的輸入，發送給Backup。
通常來說，如果有兩台計算機，如果它們從相同的狀態開始，並且它們以相同的順序，在相同的時間，看到了相同的輸入，那麼它們會一直互為副本，並且一直保持一致。</p><p>狀態轉移傳輸的是可能是內存，而復制狀態機會將來自客戶端的操作或者其他外部事件，從Primary傳輸到Backup。</p><p>在多核上工作。這個新系統從我看來使用了狀態轉移，而不是複制狀態機。因為面對多核和並行計算，狀態轉移更加健壯。如果你使用了一台機器，並且將其內存發送過來了，那麼那個內存鏡像就是機器的狀態，並且不受並行計算的影響，但是複制狀態機確實會受並行計算的影響。但是另一方面，我認為這種新的多核方案代價會更高一些。</p><p>會復制機器的完整狀態，這包括了所有的內存，所有的寄存器</p><p>應用程序級別的複制系統。這樣做的後果是，複製這個行為，必須構建在應用程序內部。如果你收到了一系列應用程序級別的操作，你確實需要應用程序參與到復制中來</p><p>VMware FT的獨特之處在於，它從機器級別實現複製，因此它不關心你在機器上運行什麼樣的軟件，它就是複制底層的寄存器和內存</p><p>它的缺點是，它沒有那麼的高效，優點是，你可以將任何現有的軟件，甚至你不需要有這些軟件的源代碼，你也不需要理解這些軟件是如何運行的</p><p><img loading=lazy src=https://i.imgur.com/tn6DQTv.png alt></p><ul><li>primary負責收client的request</li><li>VMM(hyperviser)遇到request會copy一份到secondary(log channel)<ul><li>不確定性<ul><li>中斷發生的時間有一樣嗎?</li><li>有狀態的指令 (random, timeoftoday)</li><li>多核</li></ul></li><li>對此需要特別的request格式<ul><li>日誌條目的類型</li><li>數據: 一般資料或是已經跑完不確定性指令的資料</li><li>事件發生時的指令序號</li></ul></li></ul></li><li>在primary跑request之前會確認backup有收到log!! (ack)<ul><li>沒收到就不會把response丟回去<ul><li>就算primary已經做好了</li><li>幾乎每一個複制系統都有這個問題，在某個時間點，Primary必須要停下來等待Backup，這對於性能是實打實的限制<ul><li>所以如果條件允許，人們會更喜歡使用在更高層級做複製的系統（詳見4.2 最後兩段）</li><li>也就是應用程式層級的複製</li></ul></li></ul></li></ul></li><li>VMM會讓來自primary的response通過，backup的會drop<ul><li>重複output<ul><li>如果<ul><li>primary在傳完response掛掉</li><li>backup還沒處理新的log</li></ul></li><li>這樣backup會消耗log來成為primary，之後丟response</li><li>但因為現在backup是primary，所以response會被丟回去!!<ul><li>不過因為都是用TCP連線，所以TCP會drop重複的packet<ul><li>tcp的狀態與原本的primary一樣</li></ul></li></ul></li></ul></li><li>對於任何有主從切換的複制系統，基本上不可能將系統設計成不產生重複輸出<ul><li>為了避免重複輸出，有一個選項是在兩邊都不生成輸出，但這是一個非常糟糕的做法（因為對於客戶端來說就是一次失敗的請求）</li><li>當出現主從切換時，切換的兩邊都有可能生成重複的輸出，這意味著，某種程度上來說，所有復制系統的客戶端需要一種重複檢測機制</li></ul></li></ul></li><li>primary與backup之間有heart beat確認health<ul><li>還有Test-and-Set確認對方真的掛了 (想像雙方剛好log channel的連線被block)<ul><li>Test-and-Set服務不運行在Primary和Backup的物理服務器上，VMware FT需要通過網絡支持Test-and-Set服務<ul><li>這有點像一個鎖。為了能夠上線，它們或許會同時發送一個Test-and-Set請求，給Test-and-Set服務。<ul><li>當第一個請求送達時，Test-and-Set服務會說，這個標誌位之前是0，現在是1</li></ul></li></ul></li><li>在6.824這門課程中，有個核心的規則就是，你無法判斷另一個計算機是否真的掛了，你所知道的就是，你無法從那台計算機收到網絡報文，你無法判斷是因為那台計算機掛了，還是因為網絡出問題了導致的
<img loading=lazy src=https://i.imgur.com/CmKz1Nh.png alt></li></ul></li></ul></li></ul><h2 id=raft>raft<a hidden class=anchor aria-hidden=true href=#raft>#</a></h2><p>整個系統有兩個時間</p><ul><li>server自己<ul><li>也就是做了什麼</li></ul></li><li>動作的source<ul><li>現在該聽誰的<ul><li>單一source可以處理brain-split</li></ul></li></ul></li></ul><p>raft是共識algorithm，所以要處理consistency</p><ul><li>單一source => brain-split<ul><li>也有可能沒有leader，但這個時候system也不能做什麼事</li></ul></li><li>majarity votes => fault-toroelent</li><li>commit, and then apply</li></ul><p><img loading=lazy src=https://i.imgur.com/SPAWcj7.png alt></p><p>重要的state (時間)</p><ul><li>所有server的現在時間<ul><li>currentTerm</li></ul></li><li>server自身的時間<ul><li>votedFor</li><li>log[]<ul><li>後面處理log compaction會看到，log還要多一個狀態snapshot</li></ul></li></ul></li></ul><p>執行期狀態 (做到哪)</p><ul><li>server自己<ul><li>commitIndex: log收到哪</li><li>lastApplied: log做到哪</li></ul></li><li>leader狀態<ul><li>nextIndex[]: 要從哪個log開始塞給ith follower</li><li>matchIndex[]: ith follower做到哪了</li></ul></li></ul><p><img loading=lazy src=https://i.imgur.com/w1VhdhA.png alt></p><p>接下去就是下面其中一個事件發生</p><ol><li>選leader<ul><li>RequestVote RPC<ul><li>前提<ul><li>收到的term要大於等於自己 (所有server的現在時間夠新)</li></ul></li><li>之後就<ul><li>改votedFor</li></ul></li></ul></li></ul></li></ol><p><img loading=lazy src=https://i.imgur.com/KUh1My2.png alt></p><ol start=2><li>處理client request<ul><li>AppendEntries RPC<ul><li>前提<ul><li>收到的term要大於等於自己 (所有server的現在時間夠新)</li><li>prevLogIndex 有東西 & prevLogTerm 對得起來 (server自身的時間是對得起來的)<ul><li>對不起來?<ol><li>prevLogIndex沒東西<ul><li>return false (leader與自己的狀態對不起來)</li></ul></li><li>prevLogTerm不對<ul><li>把prevLogIndex後面的東西刪掉</li></ul></li></ol></li></ul></li></ul></li><li>之後就<ul><li>把entries接上去</li><li>更新commitIndex</li></ul></li></ul></li></ul></li></ol><p><img loading=lazy src=https://i.imgur.com/NcPXorM.png alt></p><p>接著就是看state怎麼改變的</p><ol><li><p>什麼時候apply log</p><ul><li>commitIndex > lastApplied<ul><li>同時跟新lastApplied</li></ul></li></ul></li><li><p>什麼時候換currentTerm</p><ul><li>收到大於自己term的rpc時<ul><li>同時換votedFor</li></ul></li><li>成為candidate (來自timeout)
<img loading=lazy src=https://i.imgur.com/rkcxkCT.png alt></li></ul></li><li><p>leader怎麼知道</p><ul><li>大家commit到哪 (leader怎麼跟新commitIndex)<ul><li>N > commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm</li></ul></li><li>我的prevLogIndex是錯的<ul><li>AppendEntries回傳false, 之後leader的prevLogIndex自己退一格，retry AppendEntries<ul><li>leader退無可退怎麼辦?<ul><li>這個時候就是snapshot了</li><li><img loading=lazy src=https://i.imgur.com/IgOdkk0.png alt></li></ul></li><li>退一格不會太慢 (7.3 快速恢复（Fast Backup）)<ul><li>follower的reply加上，衝突位置(prevLogIndex)的<ul><li>XTerm: prevLogIndex的位置的term</li><li>XIndex: XTerm的第一個event的log 位置</li><li>XLen: 有多少空白的log</li></ul></li><li>之後有3個case<ul><li>XTerm是空的<ul><li>從XLen開始蓋</li></ul></li><li>沒看過XTerm的term<ul><li>從XIndex開始蓋</li></ul></li><li>看過XTerm的term，所以是index對不上<ul><li>從XIndex-1開始蓋</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>什麼時候要response給client<ul><li>收到AppendEntries的過半reply
<img loading=lazy src=https://i.imgur.com/yrWvTwD.png alt></li></ul></li></ul></li></ol><p>有一個細節在 6.8 选举定时器（Election Timer） 提到
就是timeout可能有livelock，所以可以像ethernet的CSMA/CD，但是retry的間隔至少要大於heartbeat的間隔</p><h2 id=linearizability>Linearizability<a hidden class=anchor aria-hidden=true href=#linearizability>#</a></h2><p>一個系統的執行歷史是一系列的客戶端請求，或許這是來自多個客戶端的多個請求。如果執行歷史整體可以按照一個順序排列，且排列順序與客戶端請求的實際時間相符合，那麼它是線性一致的</p><p>對於線性一致的順序順序，有兩個限制條件：</p><ol><li>如果一個操作在另一個操作開始前就結束了，那麼這個操作必須在執行歷史中出現在另一個操作前面。<ul><li>時間序 (可能會出現concurrent)</li><li>可以當成從第一個write response最後開始跑的bfs tree</li></ul></li><li>執行歷史中，讀操作，必須在相應的key的寫操作之後。<ul><li>把tree壓成line</li></ul></li></ol><p>這裡要看一個例子
<img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MCZOMvzhNQ9svfDymIJ%2F-MCZqVGJLCHxG5e1Px-E%2Fimage.png?alt=media&amp;token=89b78eb5-32fb-436e-abdc-35a83043ea42" alt>
這個read是3符合Linearizability?</p><p>在第一個write後發read，但是中間經歷重傳，也許read是在write 4之後完成的</p><p>但是這裡的第一個read是在第一個write之後，所以就算丟3也ok</p><p>客戶端永遠也不能在一個線性一致的系統中看到舊的數據（也就是X=1），因為一個線性一致的系統不允許讀出舊的數據
對於讀請求不允許返回舊的數據，只能返回最新的數據。或者說，對於讀請求，線性一致系統只能返回最近一次完成的寫請求寫入的值。</p><h2 id=zookeeper>zookeeper<a hidden class=anchor aria-hidden=true href=#zookeeper>#</a></h2><h3 id=first-in-first-out-order>first-in-first-out order<a hidden class=anchor aria-hidden=true href=#first-in-first-out-order>#</a></h3><p>如果系統不提供線性一致性，那麼系統是否還可用？客戶端發送了一個讀請求，但是並沒有得到當前的正確數據，也就是最新的數據，那我們為什麼要相信這個系統是可用的？</p><p>如果read/write都是透過leader做，這樣沒有scalbility</p><ul><li>Zookeeper並不要求返回最新的寫入數據。 Zookeeper的方式是，放棄線性一致性，提升read的效率</li><li>直接讓follower處理read</li></ul><p>但是zookeeper保證會照client的指令order(first-in-first-out)去跑</p><ul><li>how?<ul><li>在指令上打index，讓index對到log的index(response中附上log index(zxid))，之後就是確保在log的index大於等於前面坐指令時的log index大的狀態下跑指令</li></ul></li></ul><p>讀寫<strong>請求</strong>是線性一致的，這讓前面的第一個問題有了解法，同步操作（sync）</p><p>同步操作（sync）就是</p><ol><li>先發一個write (透過raft完成)</li><li>之後read要求一定要在前面的write發生之後 (透過first-in-first-out完成)</li></ol><p>ready file(transcation, seqlock)</p><ol><li>先刪raedy file</li><li>做write</li><li>創ready file</li></ol><p>之後client就能認ready file去讀，但這樣有問題有可能在刪之前ready還在，但中間其他的write啟動了
<img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MD4W2akBJ4UeYmSJJBt%2F-MD4ieuIHdqYr1Mzd6po%2Fimage.png?alt=media&amp;token=65213e56-848d-4415-b07f-7cc178e1f8eb" alt></p><p>所以會多一個watch確認ready file有沒有被動，有被通知就要retry
Zookeeper可以保證如果某個人刪除了Ready file，相應的通知，會在任何後續的讀請求之前，發送到客戶端。
客戶端會先收到有關Ready file刪除的通知，之後才收到其他在Log中位於刪除Ready file之後的讀請求的響應</p><h3 id=api>API<a hidden class=anchor aria-hidden=true href=#api>#</a></h3><p>Zookeeper的API某種程度上來說像是一個文件系統
Zookeeper被設計成要被許多可能完全不相關的服務共享使用。所以我們需要一個命名系統來區分不同服務的信息</p><p>Zookeeper中包含了3種類型的znode</p><ol><li>Regular znodes<ul><li>這種znode一旦創建，就永久存在，除非你刪除了它。</li></ul></li><li>Ephemeral znodes<ul><li>如果Zookeeper認為創建它的客戶端掛了，它會刪除這種類型的znodes<ul><li>客戶端需要時不時的發送心跳給Zookeeper，這樣Zookeeper才不會刪除客戶端對應的ephemeral znodes。</li></ul></li></ul></li><li>Sequential znodes<ul><li>Zookeeper實際上創建的文件名是你指定的文件名再加上一個數字。</li><li>當有多個客戶端同時創建Sequential文件時，Zookeeper會確保這裡的數字不重合，同時也會確保這裡的數字總是遞增的。</li></ul></li></ol><p>每一個znode都有一個表示當前版本號的version，當znode有更新時，version也會隨之增加</p><ul><li>CREATE(PATH，DATA，FLAG)</li><li>DELETE(PATH，VERSION)</li><li>EXIST(PATH，WATCH)</li><li>GETDATA(PATH，WATCH)</li><li>SETDATA(PATH，DATA，VERSION)</li><li>LIST(PATH)</li></ul><h4 id=acc>acc<a hidden class=anchor aria-hidden=true href=#acc>#</a></h4><p>V是版本號</p><pre tabindex=0><code class="language-c=" data-lang="c=">WHILE TRUE:
    X, V = GETDATA(&#34;F&#34;)
    IF SETDATA(&#34;f&#34;, X + 1, V):
        BREAK
</code></pre><h4 id=non-scalable-lock>Non-Scalable Lock<a hidden class=anchor aria-hidden=true href=#non-scalable-lock>#</a></h4><pre tabindex=0><code class="language-c=" data-lang="c=">WHILE TRUE:
    IF CREATE(&#34;f&#34;, data, ephemeral=TRUE): RETURN
    IF EXIST(&#34;f&#34;, watch=TRUE):
        WAIT
</code></pre><p>最終鎖會以刪除文件的形式釋放，所以我們這里通過EXIST函數加上watch=TRUE，來監測文件的刪除</p><p>羊群效應（Herd Effect）
對於計數器的例子來說，就是當有1000個客戶端同時需要增加計數器時，我們的複雜度是$O(n^2)$，這是處理完1000個客戶端的請求所需要的總時間。</p><p>$loop * watch通知 = O(n^2)$</p><h4 id=scalable-lock>Scalable Lock<a hidden class=anchor aria-hidden=true href=#scalable-lock>#</a></h4><pre tabindex=0><code class="language-c=" data-lang="c=">CREATE(&#34;f&#34;, data, sequential=TRUE, ephemeral=TRUE)
WHILE TRUE:
    LIST(&#34;f*&#34;)
    IF NO LOWER #FILE: RETURN
    IF EXIST(NEXT LOWER #FILE, watch=TRUE):
        WAIT
</code></pre><h2 id=chain-replication-with-apportioned-queries>Chain Replication with Apportioned Queries<a hidden class=anchor aria-hidden=true href=#chain-replication-with-apportioned-queries>#</a></h2><h3 id=chain-replication>Chain Replication<a hidden class=anchor aria-hidden=true href=#chain-replication>#</a></h3><p>所有機器串成linked list，從頭開始處理write，直到碰到最後一個機器才response
read就是從tail的狀態直接拉</p><p><img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MF0k3-I6-lUQ0BjQYFI%2F-MF3C1shzLnUgx-xESti%2Fimage.png?alt=media&amp;token=e787f439-d218-4910-8264-aa2232d9cdd9" alt></p><p>可以注意到這個系統是線性一致的!!
同時可以讓read的性能可以scale!!</p><p>Fail Recover</p><ul><li>head, tail fail?<ul><li>找前一個或是後一個替代</li></ul></li><li>mid fail?<ul><li>把mid移除，把前一個的write轉給下一個</li></ul></li></ul><h3 id=chain-replication-與-raft>Chain Replication 與 Raft<a hidden class=anchor aria-hidden=true href=#chain-replication-與-raft>#</a></h3><ul><li>從性能上看，對於Raft，如果我們有一個Leader和一些Follower。<ul><li>Leader需要直接將數據發送給所有的Follower。<ul><li>所以，當客戶端發送了一個寫請求給Leader，Leader需要自己將這個請求發送給所有的Follower。</li></ul></li><li>然而在Chain Replication中，HEAD只需要將寫請求發送到一個其他節點。</li></ul></li><li>數據在網絡中發送的代價較高，所以Raft Leader的負擔會比Chain Replication中HEAD的負擔更高。</li><li>當客戶端請求變多時，Raft Leader會到達一個瓶頸，而不能在單位時間內處理更多的請求。<ul><li>而同等條件以下，Chain Replication的HEAD可以在單位時間處理更多的請求，瓶頸會來的更晚一些。</li></ul></li><li>另一個與Raft相比的有趣的差別是，Raft中讀請求同樣也需要在Raft Leader中處理，所以Raft Leader可以看到所有的請求。<ul><li>而在Chain Replication中，每一個節點都可以看到寫請求，但是只有TAIL可以看到讀請求。</li><li>所以負載在一定程度上，在HEAD和TAIL之間分擔了，而不是集中在單個Leader節點。</li></ul></li><li>前面分析的故障恢復，Chain Replication也比Raft更加簡單。這也是使用Chain Replication的一個主要動力。</li></ul><p>Chain Replication並不能抵禦網絡分區，也不能抵禦腦裂。
總是會有一個外部的權威（External Authority）來決定誰是活的，誰掛了，並確保所有參與者都認可由哪些節點組成一條鏈</p><p>Configuration Manager的工作就是監測節點存活性，一旦Configuration Manager認為一個節點掛了，它會生成並送出一個新的配置，在這個新的配置中，描述了鏈的新的定義，包含了鏈中所有的節點，HEAD和TAIL</p><p>你是如何使得一個服務是容錯的，不否認自己，同時當有網絡分區時不會出現腦裂呢？
Configuration Manager通常會基於Raft或者Paxos</p><h2 id=aurora>Aurora<a hidden class=anchor aria-hidden=true href=#aurora>#</a></h2><h3 id=rds的歷史>RDS的歷史<a hidden class=anchor aria-hidden=true href=#rds的歷史>#</a></h3><p>EC2對於無狀態的Web服務器來說是完美的</p><p>如果突然新增了大量客戶，你可以立刻向Amazon租用更多的EC2實例，並在上面啟動Web服務。這樣你就可以很簡單的對你的Web服務進行擴容</p><p>當Web服務所在的服務器宕機了，是完全沒有問題的，因為Web服務本身沒有狀態，你只需要在一個新的EC2實例上啟動一個新的Web服務就行</p><p>對於數據庫來說，EC2就不像對於Web服務那樣完美了
如果服務器宕機了，那麼它本地硬盤也會無法訪問</p><p>從EC2實例來看，EBS就是一個硬盤，你可以像一個普通的硬盤一樣去格式化它，就像一個類似於ext3格式的文件系統或者任何其他你喜歡的Linux文件系統</p><p>在實現上，EBS底層是一對互為副本的存儲服務器
兩個EBS服務器會使用Chain Replication（9.5）進行複制</p><p>現在你運行了一個數據庫，相應的EC2實例將<strong>一個</strong>EBS volume掛載成自己的硬盤。當數據庫執行寫磁盤操作時，數據會通過網絡送到EBS服務器。</p><p>EBS的缺點</p><ul><li>如果你在EBS上運行一個數據庫，那麼最終會有大量的數據通過網絡來傳遞<ul><li>網絡負載更加重要</li><li>不太關心CPU和存儲空間的消耗</li></ul></li><li>EBS的容錯性不是很好<ul><li>出於性能的考慮，Amazon總是將EBS volume的兩個副本存放在同一個數據中心</li></ul></li></ul><h3 id=rds>RDS<a hidden class=anchor aria-hidden=true href=#rds>#</a></h3><ul><li>將數據庫在多個AZ之間做複製<ul><li>這樣就算整個數據中心掛了，你還是可以從另一個AZ重新獲得數據而不丟失任何寫操作</li></ul></li><li>對於RDS來說，有且僅有一個EC2實例作為數據庫<ul><li>這個數據庫將它的data page和WAL Log存儲在EBS，而不是對應服務器的本地硬盤</li></ul></li><li>當數據庫執行了寫Log或者寫page操作時，這些寫請求實際上通過網絡發送到了EBS服務器</li><li>每一次數據庫軟件執行一個寫操作，Amazon會自動的，將寫操作拷貝發送到另一個數據中心的AZ中</li><li>每一次寫操作，數據除了發送給AZ1的兩個EBS副本之外，還需要通過網絡發送到位於AZ2的副數據庫<ul><li>副數據庫接下來會將數據再發送給AZ2的兩個獨立的EBS副本</li></ul></li></ul><p>這種Mirrored MySQL比Aurora慢得多的原因是，它通過網絡傳輸了大量的數據</p><h3 id=aurora-1>Aurora<a hidden class=anchor aria-hidden=true href=#aurora-1>#</a></h3><ol><li>在替代EBS的位置，有6個數據的副本，位於3個AZ，每個AZ有2個副本<ul><li>這里通過網絡傳遞的數據只有Log條目<ul><li>存儲系統不再是通用（General-Purpose）存儲，這是一個可以理解MySQL Log條目的存儲系統</li></ul></li><li><img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MFeE3STWpE-N_S7hrlX%2F-MFePvsiy7BTHzraaR4e%2Fimage.png?alt=media&amp;token=5a197363-3b5b-4653-90cf-3f229d54d40d" alt></li></ul></li><li>Aurora並不需要6個副本都確認了寫入才能繼續執行操作 (Quorum)<ul><li>只要Quorum形成了，也就是任意4個副本確認寫入了，數據庫就可以繼續執行操作<ul><li>可以處理斷線、太慢的node</li></ul></li><li>Quorum<ul><li>假設有N個副本。為了能夠執行寫請求，必須要確保寫操作被W個副本確認，W小於N</li><li>Quorum系統要求，任意你要發送寫請求的W個服務器，必須與任意接收讀請求的R個服務器有重疊<ul><li>這樣任意W個服務器至少與任意R個服務器有一個重合 ($W+R>=N$)</li></ul></li><li>客戶端讀請求可能會得到R個不同的結果，哪一個是正確的呢？<ul><li>投票?<ul><li>可能只有一個是對的<ul><li>只能確保Read Quorum必須至少與Write Quorum有一個服務器是重合的</li></ul></li></ul></li><li>版本號（Version）<ul><li>每一次執行寫請求，你需要將新的數值與一個增加的版本號綁定</li><li>從Read Quorum得到了一些回复，客戶端可以直接使用其中的最高版本號的數值</li></ul></li></ul></li><li>Quorum系統可以調整讀寫的性能。通過調整Read Quorum和Write Quorum，可以使得系統更好的支持讀請求或者寫請求</li></ul></li><li>Aurora&rsquo;s Quorum<ul><li>不會直接覆蓋資料，append log<ul><li>Quorum系統通常讀寫的數據都是相同的</li></ul></li><li>數據庫服務器寫入的是Log條目，但是讀取的是page<ul><li>數據庫服務器會記錄每一個存儲服務器<ul><li>接收了多少Log</li><li>收到的最高連續的Log條目號</li></ul></li><li>當一個數據庫服務器需要執行讀操作，它只會挑選擁有最新Log的存儲服務器，然後只向那個服務器發送讀取page的請求</li></ul></li><li>請求發送到存儲服務器，會要求存儲服務器返回當前最新的page數據。在這個時候，存儲服務器才會將Log條目中的新數據更新到page，並將page寫入到自己的磁盤中，之後再將更新了的page返回給數據庫服務器</li><li>數據庫服務器有時也會使用Quorum Read!!<ul><li>如果DB壞了，監控系統可以檢測到Aurora數據庫服務器崩潰</li><li>之後就會要求store server把還沒完成的transation丟了</li><li>去找遺失的transaction id，對此跑Quorum Read</li><li>讓連到的store server保留遺失的transaction id之前的log</li></ul></li></ul></li></ul></li></ol><h4 id=sharding>sharding<a hidden class=anchor aria-hidden=true href=#sharding>#</a></h4><p>目前為止，我們已經知道Aurora將自己的數據分佈在6個副本上，每一個副本都是一個計算機，上面掛了1-2塊磁盤。</p><p>但是如果只是這樣的話，我們不能擁有一個數據大小大於單個機器磁盤空間的數據庫</p><p>因為雖然我們有6台機器，但是並沒有為我們提供6倍的存儲空間</p><p>Amazon的做法是將數據庫的數據，分割存儲到多組存儲服務器上，每一組都是6個副本，分割出來的每一份數據是10GB</p><p>如果一個數據庫需要20GB的數據，那麼這個數據庫會使用2個PG（Protection Group），其中一半的10GB數據在一個PG中，另一半的10GB數據存儲在另一個PG中
<img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MFm4umOtKBcv00JRuuU%2F-MFmr5oD-Jro4r19gEdB%2Fimage.png?alt=media&amp;token=3752498e-bcc5-4955-a9c3-5321f8994939" alt></p><h5 id=recover>recover<a hidden class=anchor aria-hidden=true href=#recover>#</a></h5><p>一個store server會有其他PG的其中一塊，如果store server掛了，怎麼復原?
對於每一個數據塊，我們會從Protection Group中挑選一個副本，作為數據拷貝的源。
之後，就可以並行的通過網絡將100個數據塊從100個源拷貝到100個目的</p><h5 id=single-write>single write<a hidden class=anchor aria-hidden=true href=#single-write>#</a></h5><p>對於Aurora來說，通常會有非常大量的只讀數據庫查詢</p><p>對於寫請求，可以只發送給一個數據庫，因為對於後端的存儲服務器來說，只能支持一個寫入者
Log需要按照數字編號，如果只在一個數據庫處理寫請求，非常容易對Log進行編號</p><p>當客戶端向只讀數據庫發送讀請求，只讀數據庫需要弄清楚它需要哪些data page來處理這個讀請求，之後直接從存儲服務器讀取這些data page，並不需要主數據庫的介入</p><p>只讀數據庫也需要更新自身的緩存，所以，Aurora的主數據庫也會將它的Log的拷貝發送給每一個只讀數據庫</p><h5 id=cache--transaction>cache & Transaction<a hidden class=anchor aria-hidden=true href=#cache--transaction>#</a></h5><p>我們不想要這個只讀數據庫看到未commit的事務。所以，在主數據庫發給只讀數據庫的Log流中，主數據庫需要指出，哪些事務commit了</p><p>數據庫背後的B-Tree結構非常複雜，可能會定期觸發rebalance(需要有原子性)</p><p>數據庫服務器可以通知存儲服務器說，這部分複雜的Log序列只能以原子性向只讀數據庫展示，也就是要就全展示，不然就不展示 (微事務（Mini-Transaction）)</p><h4 id=教訓>教訓<a hidden class=anchor aria-hidden=true href=#教訓>#</a></h4><p>數據庫和存儲系統基本是一起開發出來的，數據庫和存儲系統以一種有趣的方式集成在了一起
通常我們設計系統時，需要有好的隔離解耦來區分上層服務和底層的基礎架構
但是在Aurora面臨的問題中，性能問題是非常嚴重的，它不得不通過模糊服務和底層基礎架構的邊界來獲得35倍的性能提升</p><p>雲基礎架構中什麼更重要的隱含信息</p><ul><li>需要擔心整個AZ會出現故障</li><li>需要擔心短暫的慢副本，這是經常會出現的問題</li><li>網絡是主要的瓶頸，畢竟Aurora通過網絡發送的是極短的數據，但是相應的，存儲服務器需要做更多的工作<ul><li>明顯，從Amazon看來，網絡容量相比CPU要重要的多</li></ul></li></ul><h2 id=frangipani>Frangipani<a hidden class=anchor aria-hidden=true href=#frangipani>#</a></h2><p>緩存一致性是指，如果我緩存了一些數據，之後你修改了實際數據但是並沒有考慮我緩存中的數據，必須有一些額外的工作的存在，這樣我的緩存才能與實際數據保持一致</p><p>大部分的討論都會假設Petal就是一個被所有Frangipani使用的，基於網絡的共享磁盤。你可以通過一個塊號或者磁盤上的一個地址來讀寫數據，就像一個普通的硬盤一樣</p><p>在每個工作站或者說每個Frangipani服務器上要持有緩存之外，我們還需要支持Write-Back緩存。
這意味著，如果我想要修改某個數據，比如說我修改了一個文件，只要沒有其他的工作站需要看到我的改動，Frangipani通過Write-Back緩存方式管理這些數據</p><p>在這樣的架構下，一個非常重要的後果是，文件系統的邏輯需要存在於每個工作站上，所有的複雜的邏輯都在工作站中的Frangipani模塊中</p><p>所有的這些修改最初只會在本地緩存中存在，因此類似於創建文件的操作可以非常快的完成，因為只需要修改本地的內存中對於磁盤的緩存。而這些修改要過一會才會寫回到Petal (複雜度的開始)</p><p><img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MFrdH5gMPNrw9hDC97i%2F-MFsAUr43cZGwQS4P81G%2Fimage.png?alt=media&amp;token=853560aa-8c18-4ff6-81ee-90a527b49eb2" alt></p><h3 id=frangipani的挑戰challenges>Frangipani的挑戰（Challenges）<a hidden class=anchor aria-hidden=true href=#frangipani的挑戰challenges>#</a></h3><ol><li>緩存<ul><li>文件系統必須要做一些事情來確保客戶端可以讀到最新的寫入文件 (強一致或者線性一致)<ul><li>但是在一個緩存的環境中，現在說的一致性的問題不是指存儲服務器的一致性，而是<ul><li>指工作站上的一些修改需要被其他工作站看到 (Cache Coherence)</li></ul></li></ul></li><li>由於Write-Back緩存，可能會在本地的緩存中堆積了大量的修改<ul><li>如果我的工作站崩潰了，但是這時這些修改只有部分同步到了Petal，還有部分仍然只存在於本地<ul><li>我的工作站在執行操作的過程中的崩潰，最好不要損壞其他人同樣會使用的文件系統 (crash recovery)</li></ul></li></ul></li></ul></li><li>去中心化的架構帶來的大量的邏輯存在於客戶端之中進而引起的問題<ul><li>因為所有的文件和目錄都是共享的，非常容易會有兩個工作站在同一個時間修改同一個目錄 (Atomicity)<ul><li>我們希望類似於創建文件，刪除文件這樣的操作表現的就像即時生效的一樣，同時不會與相同時間其他工作站的操作相互干擾</li></ul></li></ul></li></ol><h3 id=緩存一致性>緩存一致性<a hidden class=anchor aria-hidden=true href=#緩存一致性>#</a></h3><p>Frangipani的緩存一致性核心是由鎖保證的，我們之後在原子性和故障恢復中將會再次看到鎖。</p><p>Lock server</p><ul><li>server 本身<ul><li>file到owner的map<ul><li><img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MFsxyRVsGlreoGsEs52%2F-MFt3bqh42yObBxTruNe%2Fimage.png?alt=media&amp;token=659808ce-f850-430e-936b-b84c29178442" alt></li><li>我們假設鎖是排他鎖（Exclusive Lock），儘管實際上Frangipani中的鎖更加複雜可以支持兩種模式：要么允許一個寫入者持有鎖，要么允許多個讀取者持有鎖</li></ul></li></ul></li><li>workstation<ul><li>file, lock state, file content的table<ul><li><img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MFsxyRVsGlreoGsEs52%2F-MFt8-VQAgOM4OYXa2QZ%2Fimage.png?alt=media&amp;token=0206d677-8a38-4e40-8521-9b3b74c9994f" alt></li><li>BUSY: 正在跑syscall</li><li>IDLE: syscall跑完了<ul><li>只要係統調用結束了，工作站會在內部釋放鎖</li><li>但是從鎖服務器的角度來看，工作站仍然持有鎖 (延遲將鎖還給鎖服務器)<ul><li>像是folder，就算read好，也許還會在目錄底下再做一些事</li></ul></li></ul></li></ul></li></ul></li></ul><p>Frangipani應用了很多的規則，這些規則使得Frangipani以一種提供緩存一致性的方式來使用鎖</p><ul><li>工作站不允許持有緩存的數據，除非同時也持有了與數據相關的鎖</li><li>先向Petal存儲系統寫數據，之後再釋放鎖<ul><li>如果你在釋放鎖之前，修改了鎖保護的數據，那你必須將修改了的數據寫回到Petal，只有在Petal確認收到了數據，你才可以釋放鎖</li><li>最後再從工作站的lock表單中刪除關文件的鎖的記錄和緩存的數據</li></ul></li></ul><h4 id=緩存一致性的訊息>緩存一致性的訊息<a hidden class=anchor aria-hidden=true href=#緩存一致性的訊息>#</a></h4><ul><li>Request: 拿鎖</li><li>Grant: lock server通知拿到鎖了<ul><li>如果從鎖服務器的lock表單中發現鎖已經被其他人持有了，那鎖服務器不能立即交出鎖。</li><li>但是一旦鎖被釋放了，鎖服務器會回復一個Grant消息給工作站<ul><li>這裡的Request和Grant是異步的</li></ul></li></ul></li><li>Revoke: 要求歸還鎖<ul><li>如果別人要用，同時workstation的lock state是idle，就會開始跑release lock</li></ul></li><li>Release: 還鎖<ul><li>在還之前會先把log與髒的資料寫回去</li></ul></li></ul><h4 id=優化>優化<a hidden class=anchor aria-hidden=true href=#優化>#</a></h4><ol><li>idle做延遲還鎖</li><li>Frangipani有共享的讀鎖（Shared Read Lock）和排他的寫鎖（Exclusive Write Lock）</li></ol><h3 id=原子性atomicity>原子性（Atomicity）<a hidden class=anchor aria-hidden=true href=#原子性atomicity>#</a></h3><p>要么發現文件不存在，要么文件完全存在，但是我們絕不希望它看到中間狀態</p><p>Frangipani在內部實現了一個數據庫風格的事務系統，並且是以鎖為核心。並且，這是一個分佈式事務系統</p><ol><li>首先我的工作站需要獲取所有我需要讀寫數據的鎖，在完成操作之前，我的工作站不會釋放任何一個鎖</li><li>為了遵循一致性規則（11.3），將所有修改了的數據寫回到Petal之後，我的工作站才會釋放所有的鎖</li><li>之後完成所有的步驟，比如完成所有數據的更新，並將更新寫入到Petal，最後釋放鎖</li></ol><p>Frangipani使用鎖實現了兩個幾乎相反的目標。
對於緩存一致性，這裡使用鎖來確保寫操作可以被看見。
但是對於原子性來說，鎖確保了人們在操作完成之前看不到任何寫操作</p><p>Frangipani與其他的系統一樣，需要通過預寫式日誌（Write-Ahead Log，WAL，見10.2）實現故障可恢復的事務（Crash Recoverable Transaction）</p><p>當一個工作站需要完成涉及到多個數據的複雜操作時，在工作站向Petal寫入任何數據之前，工作站會在Petal中自己的Log列表中追加一個Log條目，這個Log條目會描述<strong>整個</strong>的需要完成的操作</p><p>只有當這個描述了完整操作的Log條目安全的存在於Petal之後，工作站才會開始向Petal發送數據</p><ol><li>Frangipani對於每個工作站都保存了一份獨立的Log (一般都是share一個log)</li><li>工作站的Log存儲在Petal，而不是本地磁盤中<ul><li>每個工作站的獨立的Log，存放在公共的共享存儲中<ul><li>log裡面有 (Log只包含了對於元數據的修改)<ul><li>Log序列號 (找最新的log)</li><li>數組中的每一個元素會有一個Petal中的塊號（Block Number），一個版本號和寫入的數據<ul><li>類似的數組元素會有多個，這樣就可以用來描述涉及到修改多份文件系統數據的操作。</li></ul></li></ul></li><li>向Petal寫入數據的時候，如果我們在中途故障退出了，我們需要確認其他組件有足夠的信息能完成我們未完成修改 (log)</li><li>如果出事可以讓其他workstation利用原本的log redo!!</li></ul></li></ul></li></ol><h2 id=distributed-transaction>Distributed Transaction<a hidden class=anchor aria-hidden=true href=#distributed-transaction>#</a></h2><ul><li>並發控制（Concurrency Control）<ul><li>並發控制就是可序列化的別名</li><li>Pessimistic (mutex)<ul><li>兩階段鎖（Two-Phase Locking）<ol><li>在使用任何數據之前，在執行任何數據的讀寫之前，先獲取鎖</li><li>事務必須持有任何已經獲得的鎖，直到事務提交或者Abort，你不允許在事務的中間過程釋放鎖</li></ol></li></ul></li><li>Optimistic (rwlock)</li></ul></li><li>原子提交（Atomic Commit）<ul><li>從部分故障中恢復的能力</li><li>兩階段提交（Two-Phase Commit）<ul><li>除了原本的DB，還有一台Transaction Coordinator<ol><li>因為是transaction，各自的DB會拿有關的所有鎖</li><li>開始跑指令</li><li>發preare問參與事務的DB好了沒<ul><li>TC發prepare/commit之前掛了<ul><li>基於log，重發 (可能需要標這是重複的)</li></ul></li><li>TC發prepare/commit之後掛了<ul><li>log還原自己的狀態</li></ul></li><li>DB收到preare前掛了<ul><li>DB重開，發現沒有log，回abort</li></ul></li><li>DB收到prepare在回了yes之後掛掉<ul><li>transaction的動作、相關狀態，再回prepare之前都要在log</li><li>DB重開，有log與prepare，之後TC發prepare就能回yes</li></ul></li></ul></li><li>都好了就發commit<ul><li>DB收到commit之後掛了<ul><li>回yes之前掛了<ul><li>redo, 回yes</li></ul></li><li>回完yes之後掛了<ul><li>這個時候所有有關的log都被清了(也許)與該改的都寫到HDD了</li><li>有可能DB是找不到commit相關訊息的</li><li>不論怎樣，DB都會直接回yes</li></ul></li></ul></li></ul></li></ol></li></ul></li></ul></li></ul><p>如果遇到網路斷線?</p><ul><li>TC可以retry，如果太久就abort</li><li>DB是根據prepare的回答<ul><li>no<ul><li>自己abort，之後TC的prepare就發no</li></ul></li><li>yes<ul><li>就是等TC的指令，剩下都不能動!!<ul><li>只要回prepare yes就是等 (BLOCK)</li><li>A或者B不能決定Commit還是不Commit事務，A和B之間不會交互來達成一致並完成事務的Commit，相反的只有事務協調者可以做決定</li></ul></li></ul></li></ul></li></ul><p>數據庫通常對於正確性有一個概念稱為ACID</p><p>可序列化是指，並行的執行一些事物得到的結果，與按照某種串行的順序來執行這些事務，可以得到相同的結果</p><p>使用Raft可以通過將數據複製到多個參與者得到高可用。
Raft的意義在於，即使部分參與的服務器故障了或者不可達，系統仍然能工作。
Raft能做到這一點是因為所有的服務器都在做相同的事情，所以我們不需要所有的服務器都參與，我們只需要過半服務器參與</p><p>兩階段提交，參與者完全沒有在做相同的事情，每個參與者都在做事務中的不同部分，比如A可能在對X加1，B可能在對Y減1。
所以在兩階段提交中，所有的參與者都在做不同的事情。
所有的參與者都必須完成自己那部分工作，這樣事務才能結束，所以這裡需要等待所有的參與者。</p><p>Raft完全就是可用性，而兩階段提交完全不是高可用的，系統中的任何一個部分出錯了，系統都有可能等待直到這個部分修復</p><p>同時具備Raft的高可用性，但同時又有兩階段提交的能力將事務分包給不同的參與者。
這裡的結構實際上是，通過Raft或者Paxos或者其他協議，來複製兩階段提交協議裡的每一個組成部分。
<img loading=lazy src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MGDo7lTac6bjSnx42qj%2F-MGHRamLcjPxIGu7ad95%2Fimage.png?alt=media&amp;token=6bf33cfc-e690-4025-8840-f3657c5f23fc" alt></p><h2 id=spanner>spanner<a hidden class=anchor aria-hidden=true href=#spanner>#</a></h2><h3 id=需求--前提>需求 & 前提<a hidden class=anchor aria-hidden=true href=#需求--前提>#</a></h3><ul><li>大部分的workload都是read-only transactions<ul><li>read要快<ul><li>spanner區分read/write & read/only transaction</li></ul></li></ul></li><li>更好的synchronous replication</li><li>flexible sharding</li><li>分散式transaction (橫跨多個shard)<ul><li>2pc真的慢，要別的方法</li></ul></li><li>External consistency<ul><li>linearizability + serializability</li></ul></li></ul><p>為了可用性，所以把distributed tranasaction的每個元件包成one Paxos group</p><h3 id=readwrite-transactions>read/write transactions<a hidden class=anchor aria-hidden=true href=#readwrite-transactions>#</a></h3><ul><li>two-phase commit (2pc) with Paxos-replicated participants<ul><li>基本上與2pc步驟一樣但是所有溝通都是由各個shard的leader做<ul><li>在shard的leader中有lock table</li></ul></li></ul></li><li>2pc所以很慢</li><li>parallelism<ul><li>many clients, many shards</li></ul></li></ul><h3 id=readonly-transactions>read/only transactions<a hidden class=anchor aria-hidden=true href=#readonly-transactions>#</a></h3><ul><li>兩個重點<ul><li>沒有2pc</li><li>只從local replica讀</li></ul></li><li>正確性<ul><li>Serializable</li><li>Externally consistent<ul><li>為什麼不直接讀最新commit的值?<ul><li>T1: Wx Wy C</li><li>T2: Wx Wy C</li><li>T3: Rx Ry</li></ul></li></ul></li></ul></li><li>Snapshot Isolation (SI)<ul><li>用wall-time做timestamp(TS)<ul><li>怎麼synchronize wall-time?<ul><li>TrueTime<ul><li>TTinterval = <code>[ earliest, latest ]</code></li><li>在這個區間一定有對的時間</li></ul></li></ul></li></ul></li><li>只拉同一個TS的資料(最少不能超過read的TS)<ul><li>怎麼確保replica夠新?<ul><li>replica &ldquo;safe time&rdquo;<ul><li>read上給時間，直到replica上看到write的時間夠後面才serve</li></ul></li></ul></li></ul></li><li>每個transaction都有time-stamp<ul><li>r/w: commit time.</li><li>r/o: start time.</li><li>Synchronized timestamps確保external consistency (commit wait)</li></ul></li><li>SI確保serializable r/o transactions</li></ul></li><li>怎麼確保r/w在r/o之前完成 (Commit wait)<ul><li>定義transacation的TS<ul><li>xaction TS = TT.now().latest</li><li>for r/o, at start time</li><li>for r/w, when commit begins</li></ul></li><li>在r/w跑commit之前，Commit wait<ul><li>Before commit, delay until TS &lt; TS.now().earliest</li></ul></li></ul></li></ul><h2 id=farm-optimistic-concurrency-control>FaRM, Optimistic Concurrency Control<a hidden class=anchor aria-hidden=true href=#farm-optimistic-concurrency-control>#</a></h2><h3 id=farm--spanner差在>FaRM & Spanner差在<a hidden class=anchor aria-hidden=true href=#farm--spanner差在>#</a></h3><ul><li>都用2pc</li><li>Spanner<ul><li>geographic replication</li><li>r/o transaction & TrueTime</li><li>bottleneck: speed of light and network delays</li></ul></li><li>FaRM<ul><li>都在同一個data center</li><li>RDMA(remote dma)限制只能用Optimistic Concurrency Control (OCC)<ul><li>Optimistic Concurrency Control<ul><li>steps<ul><li>read不用lock</li><li>write直到commit才會真的寫入</li><li>commit檢查有沒有衝突</li></ul></li><li>不用server參與!!<ul><li>one-sided RDMA<ul><li>sender給mem addr, read整個cache line</li></ul></li></ul></li></ul></li></ul></li><li>bottleneck: CPU time on servers</li><li>都用ram存資料<ul><li>non-volatile RAM<ul><li>每個rack都有電池在出事之前可以把ram寫到hdd</li></ul></li></ul></li></ul></li></ul><h3 id=架構>架構<a hidden class=anchor aria-hidden=true href=#架構>#</a></h3><p><img loading=lazy src=https://i.imgur.com/GUGDOwx.png alt></p><p><img loading=lazy src=https://i.imgur.com/NW2vQK0.png alt></p><h4 id=apisimplified>API(simplified)<a hidden class=anchor aria-hidden=true href=#apisimplified>#</a></h4><ul><li>FaRM transaction API (simplified):<ul><li>txCreate()</li><li>o = txRead(oid) &ndash; RDMA<ul><li>oid?<ul><li><code>&lt;region #, address></code></li><li>region # indexes a mapping to <code>[ primary, backup1, ... ]</code></li><li>target RDMA NIC uses address directly to read or write RAM</li></ul></li></ul></li><li>o.f += 1</li><li>txWrite(oid, o) &ndash; purely local</li><li>ok = txCommit() &ndash; Figure 4</li></ul></li></ul><h4 id=流程>流程<a hidden class=anchor aria-hidden=true href=#流程>#</a></h4><ol><li>跑指令</li><li>LOCK<ul><li>檢查lock state, version</li><li>往primary上打log，之後等return yes</li><li>VALIDATE<ul><li>one-sided RDMA read to re-fetch object&rsquo;s version and lock flag<ul><li>fail early</li><li>T1: Rx Ly Vx Cy</li><li>T2: Ry Lx Vy Cx<ul><li>LOCKs will both succeed</li><li>VALIDATEs will both fail</li></ul></li></ul></li></ul></li><li>COMMIT BACKUP<ul><li>在commit之前至少backup要有法定人數台機器有新的值<ul><li>a committed write might be revealed as soon the first COMMIT-PRIMARY is sent</li></ul></li><li>LOCK 通知 primaries 有新值</li><li>COMMIT-BACKUP 通知 backups 有新值<ul><li>不一定馬上處理，會放在log中</li></ul></li><li>直到LOCKs與COMMIT-BACKUPS都完成，TC才發COMMIT-PRIMARY<ul><li>2pc中COMMIT之後就是<ul><li>狀態都ok了</li><li>不能回頭了</li></ul></li></ul></li></ul></li></ul></li><li>COMMIT PRIMARY<ul><li>就是最後的commit<ul><li>往primary上打log</li></ul></li><li>primary清狀態, version++, 把值寫進去</li></ul></li></ol><ul><li>fault tolerance?<ul><li>假設總是有一個backup在</li></ul></li></ul><h2 id=spark>spark<a hidden class=anchor aria-hidden=true href=#spark>#</a></h2><p>skip</p><h2 id=scaling-memcache-at-facebook>Scaling Memcache at Facebook<a hidden class=anchor aria-hidden=true href=#scaling-memcache-at-facebook>#</a></h2><h3 id=網站的成長旅程>網站的成長旅程<a hidden class=anchor aria-hidden=true href=#網站的成長旅程>#</a></h3><ol><li>一台host = web server + DB + app<ul><li>app吃爆cpu</li></ul></li><li>多台web server + app, 一台DB<ul><li>DB只有一台</li></ul></li><li>多台web server + app, 多台DB<ul><li>做shard，如果沒有特別熱門的key就沒事<ul><li>cross-shard transactions & queries基本不能做了</li></ul></li><li>read變慢!!</li></ul></li><li>多台web server + app, 多台DB for write, cache for read<ul><li>cache怎麼與db sync</li><li>沒有成功cache hit，DB的load直接起飛<ul><li>warm-up</li><li>cache miss</li></ul></li><li>接下去就是DB write，但這很難解</li></ul></li></ol><p><img loading=lazy src=https://i.imgur.com/vEtE998.png alt>
<img loading=lazy src=https://i.imgur.com/GEhhs65.png alt></p><h3 id=教訓-1>教訓<a hidden class=anchor aria-hidden=true href=#教訓-1>#</a></h3><ul><li><p>partition 或 replicate</p><ul><li>partition: divide keys over mc servers<ul><li>good: ram花得少 (kv不用重複copy)</li><li>bad: web server要一次問很多台<ul><li>huge &ldquo;fan-out&rdquo; => parallel fetch, in-cast congestion</li></ul></li><li>適用: key沒有很熱門 (不用每個data center都放)</li></ul></li><li>replicate: divide clients over mc servers<ul><li>good: 比較少tcp連線</li><li>bad: 比較少key能被cache</li><li>適用: key很熱門</li></ul></li></ul></li><li><p>region (data center)</p><ul><li>lower RTT to users</li><li>quick local reads, from local mc and DB<ul><li>writes 很慢，一定要到primary</li></ul></li><li>多 mc clusters <em>在</em> 每個 region<ul><li>&ldquo;regional pool&rdquo; shared by all clusters => unpopular objects (no need for many copies)</li></ul></li></ul></li><li><p>warmup is painful</p><ul><li>get miss => 打DB => 去set cache<ul><li>只給第一個req設定cache的權限(lease)</li><li>其他就先等<ul><li>mc tells others &ldquo;try get() again in a few milliseconds&rdquo;</li></ul></li></ul></li></ul></li><li><p>容錯?</p><ul><li>pool of idle mc servers, clients only use after mc server fails</li></ul></li><li><p>網路</p><ul><li>get<ul><li>UDP</li></ul></li><li>set<ul><li>TCP</li></ul></li><li>把req累積成一個packet<ul><li>mcrouter batches many requests into each packet</li></ul></li></ul></li></ul><h3 id=consistency>consistency<a hidden class=anchor aria-hidden=true href=#consistency>#</a></h3><ol><li>not more than a few seconds stale</li><li>read-your-own-writes (due to delete())<ul><li>cache怎麼與DB sync (delete)<ol><li>DB去做</li><li>writing client去做</li></ol></li></ul></li></ol><p>delete會有racing</p><h3 id=race-1>Race 1<a hidden class=anchor aria-hidden=true href=#race-1>#</a></h3><p>真正的race, 用樂觀鎖、rwlock解</p><pre tabindex=0><code>k not in cache
C1 get(k), misses
C1 v1 = read k from DB
    C2 writes k = v2 in DB
    C2 delete(k)
C1 set(k, v1)
</code></pre><p>get時會給一個lease，如果有delete就會把lease取消掉，之後看有沒有lease決定要不要吃這個set</p><h3 id=race-2>Race 2<a hidden class=anchor aria-hidden=true href=#race-2>#</a></h3><p>與race3很像，都是因為write傳播太慢，導致source資料不對，這裡因為是cold所以只能從hot copy，所以wait hot試試看有沒有可能ok</p><pre tabindex=0><code>在warm-up時，get從warm cluster拉資料
k starts with value v1
C1 updates k to v2 in DB
C1 delete(k) -- in cold cluster
C2 get(k), miss -- in cold cluster
C2 v1 = get(k) from warm cluster, hits
C2 set(k, v1) into cold cluster
</code></pre><p>cold cluster會在<strong>2秒</strong>中忽略set，去等warm收到DB資料</p><h3 id=race-3>Race 3<a hidden class=anchor aria-hidden=true href=#race-3>#</a></h3><p>source是local db，但是我們知道才剛update，所以標上要從remote拉</p><pre tabindex=0><code>k starts with value v1
C1 is in a secondary region
C1 updates k=v2 in primary DB
C1 delete(k) -- local region
C1 get(k), miss
C1 read local DB  -- sees v1, not v2!
later, v2 arrives from primary DB
</code></pre><p>C1做delete時把key標上"remote mark"
讓後面的人去DB拉資料</p><h2 id=causal-consistency-cops>Causal Consistency, COPS<a hidden class=anchor aria-hidden=true href=#causal-consistency-cops>#</a></h2><p>we&rsquo;ve seen two solutions for geo-replication
Spanner
writes involve Paxos and perhaps two-phase commit
Paxos quorum for write must wait for some remote sites
no one site can write on its own
but has read transactions, consistent, fairly fast
Facebook / Memcache
writes must go to the primary site&rsquo;s MySQL
again, non-primary sites cannot write on their own
but reads are blindingly fast (1,000,000 per second per memcache server)</p><h3 id=情境>情境<a hidden class=anchor aria-hidden=true href=#情境>#</a></h3><ul><li>3 data centers</li><li>data centers有各自的shard</li></ul><h3 id=ver1-eventually-consistent>ver1: eventually consistent<a hidden class=anchor aria-hidden=true href=#ver1-eventually-consistent>#</a></h3><ul><li><p>reads and <strong>writes</strong> just <strong>local</strong> shard</p><ul><li>會自己把write推到其他data center</li></ul></li><li><p>eventually consistent</p><ul><li>client看到update的順序不確定</li><li>write要等夠久才看的到</li><li>例子<ul><li>quorum, with overlap (Dynamo/Cassandra)</li><li>local write + asynchronously push</li></ul></li></ul></li><li><p>每個put加個timestamp(version)?</p><ul><li>COPS用Lamport clocks設定timestamp<ul><li>Tmax = highest v# seen (from self and others)</li><li>T = max(Tmax + 1, wall-clock time)</li></ul></li><li>concurrent write時，要選哪一個write?<ul><li>last-writer-wins?<ul><li>increment a counter時會起飛</li></ul></li><li>需要其他方式做merge<ul><li>real transactions</li><li>mini-transactions (atomic)</li><li>特定的合併方式 (set union)</li><li>action transform</li><li>mvcc</li></ul></li><li>resolution of conflicting writes is a problem for eventual/causal consistency<ul><li>no single &ldquo;serialization point&rdquo; to implement atomic operations or transactions</li></ul></li></ul></li></ul></li></ul><h3 id=ver2-barrier>ver2: barrier<a hidden class=anchor aria-hidden=true href=#ver2-barrier>#</a></h3><ul><li>留個sync指令<ul><li>直到確認每個datacenter都有夠新的key才return</li></ul></li><li>需要等 (慢)<ul><li>但其他work其實寫都要等<ul><li>spanner等majority of replica</li><li>fb&rsquo;s cache等primary datacenter</li></ul></li></ul></li><li>不需要transaction不失為一個不錯的方案</li></ul><h3 id=ver3-log>ver3: log<a hidden class=anchor aria-hidden=true href=#ver3-log>#</a></h3><ul><li>每個datacenter都有一個log server<ul><li>write對應到一個log</li></ul></li><li>datacenter把log送到其他datacenter<ul><li>datacenter照log順序跑</li></ul></li><li>log server會是bottleneck</li></ul><h3 id=cops-clients-context>COPS: client&rsquo;s context<a hidden class=anchor aria-hidden=true href=#cops-clients-context>#</a></h3><ul><li>client的context會記錄下指令的順序<ul><li>這就是dependency</li></ul></li></ul><pre tabindex=0><code>get(X)-&gt;v2
    context: Xv2
get(Y)-&gt;v4
    context: Xv2, Yv4
put(Z, -)-&gt;v3
    client sends Xv2, Yv4 to shard server along with new Z
    context: Xv2, Yv4, Zv3
    (COPS optimizes this to just Zv3)
</code></pre><h4 id=shard怎麼處理>shard怎麼處理?<a hidden class=anchor aria-hidden=true href=#shard怎麼處理>#</a></h4><ul><li>local shard<ul><li>收到<code>put(Z, -, Yv4)</code><ul><li>設定時間: <code>v# = 3 for Z</code></li><li>write: <code>Z, -, v3</code></li><li>傳送到其他datacenter(不等reply)</li></ul></li></ul></li><li>remote shard<ul><li>收到<code>Z/-/v3/Yv4</code><ul><li>會等到<code>Yv4</code>到了才設定<code>Z/-/v3</code></li></ul></li></ul></li></ul><p><img loading=lazy src=https://i.imgur.com/tGKnWmr.png alt></p><h4 id=causal-consistency>causal consistency<a hidden class=anchor aria-hidden=true href=#causal-consistency>#</a></h4><ul><li><p>dependency來自?</p><ul><li>client的一連串puts and gets</li><li>當read來自其他client資料的時候</li></ul></li><li><p>這dependency是transitive</p></li><li><p>可能拿到比想像中更新的資料</p><ul><li>不能用在transaction或是snapshot</li></ul></li><li><p>get_trans(k1,k2,&mldr;)</p><ul><li>client檢查dep對不對，不對就重拿不對的</li><li>只有read的mini-transaction</li><li>scenerio: ACL<ul><li>get(ACL), then get(list)?<ul><li>what if someone deletes you from ACL, then adds a photo?</li></ul></li><li>get(list), then get(ACL)?<ul><li>what if someone deletes photo, then adds you to ACL?</li></ul></li></ul></li></ul></li></ul><pre tabindex=0><code>for ACL / list example:
  C1: get_trans(ACL, list)
  C1: get(ACL) -&gt; v1, no deps
      C2: put(ACL, v2)
      C2: put(list, v2, deps=ACL/v2)
  C1: get(list) -&gt; v2, deps: ACL/v2
  (C1 checks dependencies against value versions)
  C1: get(ACL) -&gt; v2
  (now C1 has a causally consistent pair of get() results)
</code></pre><h2 id=secure-untrusted-data-repository-sundr>Secure Untrusted Data Repository (SUNDR)<a hidden class=anchor aria-hidden=true href=#secure-untrusted-data-repository-sundr>#</a></h2><h3 id=integrity>integrity<a hidden class=anchor aria-hidden=true href=#integrity>#</a></h3><ul><li>source code的server<ul><li>bad<ul><li>在source code放backdoor</li><li>忽略一些fix</li></ul></li><li>Serious problem<ul><li>Paper mentions Debian server compromised in 2003.</li><li><a href=http://sourceforge.net/blog/sourceforge-attack-full-report>SourceForge compromised in 2011.</a></li><li><a href=https://hub.packtpub.com/canonical-the-company-behind-the-ubuntu-linux-distribution-was-hacked-ubuntu-source-code-unaffected/>Canonical (Ubuntu) compromised in 2019.</a></li></ul></li></ul></li></ul><h3 id=naive-design-sign-file-contents>Naive design: sign file contents.<a hidden class=anchor aria-hidden=true href=#naive-design-sign-file-contents>#</a></h3><ul><li>只能保證檔案內容與作者是誰</li><li>但server可以<ul><li>亂送其他版本的檔案</li><li>假裝檔案不在</li></ul></li></ul><h3 id=fork-consistency>Fork consistency<a hidden class=anchor aria-hidden=true href=#fork-consistency>#</a></h3><ul><li>每個fork看到都一樣</li><li>容易找出攻擊</li><li>難以假造log</li></ul><h3 id=sundr-log-of-operations>SUNDR: log of operations.<a hidden class=anchor aria-hidden=true href=#sundr-log-of-operations>#</a></h3><ul><li>log: fetch or modify, user, sig.<ul><li>簽名要包含所有log</li></ul></li><li>steps<ul><li>下載log</li><li>check log</li><li>做事(Construct FS state)</li><li>加上log與簽名</li><li>上傳log</li></ul></li><li>包含所有log?!<ul><li>超慢<ul><li>簽名慢</li><li>check慢</li></ul></li><li>優化<ol><li>只看最後一個簽名 (前面的一定被確認過了)</li><li>只要簽自己改過的地方就好 (一堆inode => i-table)</li></ol></li></ul></li></ul><p>Idea: signed version vectors.
Version vector: user -> how many operations that user performed.
Version structure: signed i-handle together with version vector.</p><h2 id=consistency-1>Consistency<a hidden class=anchor aria-hidden=true href=#consistency-1>#</a></h2><p>Consistency就是發生效果的亂序程度
越弱越難預期</p><p>有兩個排序單位</p><ul><li>operation</li><li>transaction</li></ul><p>eventual Consistency
總有一天會拿到最新的結果
沒有時間序、執行序</p><p>Causal Consistency
某部分效果發生是有序的(有因果關係)
這也是通常concurrent programming使用的Consistency</p><p>Sequential Consistency
效果發生照執行序來，所以如果concurrent可能有超過一種排列組合</p><p>因為一般concurrent programming沒有transaction的概念，所以從這開始就有人叫strong Consistency</p><p>Linearizability
照執行序來、時間序 (看前面的定義)
但是transaction的執行順序不確定(也許r/w有序，但ro穿插其間)</p><p>Strict Serializability
照執行序來、執行序、transaction的執行順序確定</p><p>一般提到distributed system的consistemcy最多提到上面5種，因為通常討論transaction都是DB範圍</p><p>比較完整的圖在這
<img loading=lazy src=https://i.imgur.com/CoNbzqO.png alt>
可以到<a href=https://jepsen.io/consistency>來源</a>看定義</p><p>這邊備註一下PRAM，就是FIFO Consistency(zookeeper)</p><h3 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h3><p><a href=https://www.cs.princeton.edu/courses/archive/fall18/cos418/docs/p8-consistency.pdf>Consistency</a>
<a href=https://jepsen.io/consistency>Consistency Models</a></p><h2 id=bitcoin>bitcoin<a hidden class=anchor aria-hidden=true href=#bitcoin>#</a></h2><h3 id=在byzantine中共識>在byzantine中共識<a hidden class=anchor aria-hidden=true href=#在byzantine中共識>#</a></h3><ul><li>像SUNDR<ul><li>簽過的log與fork</li></ul></li><li>不像SUNDR<ul><li>分散式的選用fork</li></ul></li></ul><h3 id=組成>組成<a hidden class=anchor aria-hidden=true href=#組成>#</a></h3><ul><li><p>ledger record</p><ul><li>pub(user1)<ul><li>新owner的public key</li></ul></li><li>hash(prev)<ul><li>前一個transaction的hash</li></ul></li><li>sig(user2)<ul><li>前owner的簽名</li></ul></li><li>(其他: amount (fractional), multiple in/out, &mldr;)</li></ul></li><li><p>transaction 例子</p><ul><li>Y 擁有一枚硬幣，之前由 X 給它：<ul><li>T6：pub(X)，&mldr;</li><li>T7：pub(Y)、hash(T6)、sig(X)</li></ul></li><li>Y 從 Z 買了一個漢堡包並用這枚硬幣付款</li><li>Z 將公鑰發送給 Y</li><li>Y 創建一個新交易並對其進行簽名<ul><li>T8：pub(Z)、hash(T7)、sig(Y)</li></ul></li><li>Y 向 Z 發送交易記錄</li><li>Z 驗證：<ul><li>T8 的 sig(Y) 對應 T7 的 pub(Y)</li></ul></li><li>Z給Y漢堡包</li></ul></li><li><p>block chain</p><ul><li>一個coin可以花兩次嗎?<ul><li>可以，創兩個transaction<ul><li>coin其實源自於transaction，有transaction才有coin</li></ul></li><li>別阿</li></ul></li><li>需要一個共同依據<ul><li>fork consistency<ul><li>有所有交易紀錄</li><li>大家看到的都一樣的</li><li>做了就不能反悔</li></ul></li><li>參與者可能會做壞事<ul><li>挑最長的chain</li></ul></li></ul></li><li>block有<ul><li>hash(prevblock)</li><li>set of transactions</li><li>current time (wall clock timestamp)</li><li>&ldquo;nonce&rdquo; (類似隨機資料)</li></ul></li><li>誰可以產生block<ul><li>miner (proof-of-work, nonce要有N個0，所以要try)</li></ul></li><li>怎麼交易<ul><li>假設現在block在B7</li><li>payer先<strong>flood</strong>我要交易到peer</li><li>miner把交易記錄起來，等B8(目前mine的block)好<ul><li>每10分鐘一個block產生</li></ul></li><li>把交易記錄放到B9</li><li>payee看到交易記錄就可以接受交易</li></ul></li><li>能產生分支嗎?<ul><li>能<ul><li>在同一時間找到同樣的nonce</li><li>network問題</li></ul></li><li>怎麼處理<ul><li>miner挑最長的append<ul><li>這能hack吧 (yes)<ul><li>但要能做出更長的chain</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id=壞處>壞處<a hidden class=anchor aria-hidden=true href=#壞處>#</a></h3><ul><li>超慢</li><li>flood限制效能與攻擊點</li><li>只要有人有過半的算力就能控制整個chain</li><li>user要保護好private key</li></ul><h2 id=dapp>DAPP<a hidden class=anchor aria-hidden=true href=#dapp>#</a></h2><h3 id=dapp怎麼工作的>DAPP怎麼工作的<a hidden class=anchor aria-hidden=true href=#dapp怎麼工作的>#</a></h3><ul><li>從remote server拉資料</li><li>DAPP處理寫回去</li></ul><h3 id=好處>好處<a hidden class=anchor aria-hidden=true href=#好處>#</a></h3><ul><li>換app很方便，因為資料不會被綁在app上<ul><li>todo的項目可以在todo list, microsoft todo上通用</li></ul></li><li>app有通用的資料格式</li></ul><h3 id=壞處-1>壞處<a hidden class=anchor aria-hidden=true href=#壞處-1>#</a></h3><ul><li>分散式很複雜</li><li>資料加密與server安全</li></ul><h2 id=ref-1>Ref<a hidden class=anchor aria-hidden=true href=#ref-1>#</a></h2><p><a href=https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/>6.824的部分中文翻譯</a>
<a href=https://github.com/SwordHarry/MIT6.824_2021_note>MIT6.824_2021_note</a>
<a href=https://ray1888.github.io/2019/08/21/intro-distributed-system/#3.1>分布式系统概念简介及其问题的描述</a>
<a href=https://ocw.mit.edu/resources/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/online-textbook/principles_open_5_0.pdf>Design Principles</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/distributed/>Distributed</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2022/03/mit-6.824-2022-%E5%AF%A6%E9%A9%97%E7%AD%86%E8%A8%98/><span class=title>« Prev</span><br><span>mit 6.824 2022 實驗筆記</span>
</a><a class=next href=https://littlebees.github.io/2022/01/the-complete-guide-to-rails-performance%E8%AE%80%E5%BE%8C%E7%AD%86%E8%A8%98/><span class=title>Next »</span><br><span>the complete guide to rails performance讀後筆記</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>