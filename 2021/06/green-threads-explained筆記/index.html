<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Green Threads Explained筆記 | 記事本</title>
<meta name=keywords content="C/C++"><meta name=description content="動機
偶然找到Green Threads Explained很讚，做點筆記"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/06/green-threads-explained%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/06/green-threads-explained%E7%AD%86%E8%A8%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Green Threads Explained筆記"><meta property="og:description" content="動機
偶然找到Green Threads Explained很讚，做點筆記"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/06/green-threads-explained%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-23T15:41:46+00:00"><meta property="article:modified_time" content="2021-06-23T15:41:46+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="Green Threads Explained筆記"><meta name=twitter:description content="動機
偶然找到Green Threads Explained很讚，做點筆記"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Green Threads Explained筆記","item":"https://littlebees.github.io/2021/06/green-threads-explained%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Green Threads Explained筆記","name":"Green Threads Explained筆記","description":"動機 偶然找到Green Threads Explained很讚，做點筆記\n","keywords":["C/C++"],"articleBody":"動機 偶然找到Green Threads Explained很讚，做點筆記\nthread要有? scheduler 因為要schedule，所以要context switch context switch要換的是當下執行的狀態，所以要看 arch(x86, amd64, arm)的ABI arch的reg 實作? 這裡就看我覺得重要的地方\nstruct gt thread的狀態，兩件事\n紀錄當下執行的狀態，或是說在cpu運算會用到的reg reg其實可以當成cpu的狀態 同理，可以把這個概念推廣成在一般自己的function會用到的參數都是function的狀態 thread的狀態 struct gt { struct gtctx { uint64_t rsp; // Stack pointer for top address of the stack uint64_t r15; // I dont know uint64_t r14; uint64_t r13; uint64_t r12; uint64_t rbx; // Base index (for use with arrays) uint64_t rbp; // Stack base pointer for holding the address of the current stack frame. } ctx; enum { Unused, Running, Ready, // has rest of works } st; }; context switch 這要同時看gtgo與gtswtch\ngtgo負責\n設給cpu用的stack，這 對pc(program counter)動手腳 我們沒辦法直接改pc，所以要利用stack動手腳 stack第一層放gtstop，第二層放f 第二層會在gtswtch(context switch)的ret，被拿出來跑到f去 stack第一層會在f直接call時利用到，return就直接到gtstop *(uint64_t *)\u0026stack[StackSize - 8] = (uint64_t)gtstop; *(uint64_t *)\u0026stack[StackSize - 16] = (uint64_t)f; p-\u003ectx.rsp = (uint64_t)\u0026stack[StackSize - 16]; gtswtch就是把reg存起來，但問題是從哪到哪? 怎麼看old與new?\n看gtswtch怎麼被call的 gtswtch(old, new); arch的ABI ABI會說，reg要怎麼用，像function的參數要怎麼帶 這裡rdi是第一個參數，rsi是第二個參數 gtswtch: mov %rsp, 0x00(%rdi) mov %r15, 0x08(%rdi) mov %r14, 0x10(%rdi) mov %r13, 0x18(%rdi) mov %r12, 0x20(%rdi) mov %rbx, 0x28(%rdi) mov %rbp, 0x30(%rdi) mov 0x00(%rsi), %rsp mov 0x08(%rsi), %r15 mov 0x10(%rsi), %r14 mov 0x18(%rsi), %r13 mov 0x20(%rsi), %r12 mov 0x28(%rsi), %rbx mov 0x30(%rsi), %rbp ret 整體邏輯 一個array去放thread，之後在yield被call時，換(這裡用RR去選)到下一個thread\nGoroutines Goroutines也是cooperative thread，與Green Threads Explained一樣，但感覺怪怪的?\nGoroutines沒有yield yield是runtime叫的\nChannel send and receive operations, if those operations would block. The Go statement, although there is no guarantee that new goroutine will be scheduled immediately. Blocking syscalls like file and network operations. After being stopped for a garbage collection cycle. syscall不會block其他threadㄟ 所以go會把出事的thread放到其他OS thread去跑，畢竟syscall會block\n這也是Goroutines要分成下面三個的理由\nG (green thread) M (OS thread，真正做事的) P (運行G的context) 如果G發syscall就會讓M被卡，所以需要P讓其他G可以避難到其他M去\nGoroutines的context switch比較快? go只保留需要的reg\nsince it is invoked implicitly in the code e.g. during sleep or channel wait, the compile only needs to safe/restore the registers which are alive at these points. In Go, this means only 3 registers i.e. PC, SP and DX (Data Registers) being updated during context switch rather than all registers\nRef The Go scheduler Why goroutines are not lightweight threads?\n","wordCount":"298","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-06-23T15:41:46Z","dateModified":"2021-06-23T15:41:46Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/06/green-threads-explained%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Green Threads Explained筆記</h1><div class=post-meta><span title='2021-06-23 15:41:46 +0000 UTC'>June 23, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#thread%e8%a6%81%e6%9c%89 aria-label=thread要有?>thread要有?</a></li><li><a href=#%e5%af%a6%e4%bd%9c aria-label=實作?>實作?</a><ul><li><a href=#struct-gt aria-label="struct gt">struct gt</a></li><li><a href=#context-switch aria-label="context switch">context switch</a></li><li><a href=#%e6%95%b4%e9%ab%94%e9%82%8f%e8%bc%af aria-label=整體邏輯>整體邏輯</a></li></ul></li><li><a href=#goroutines aria-label=Goroutines>Goroutines</a><ul><li><a href=#goroutines%e6%b2%92%e6%9c%89yield aria-label=Goroutines沒有yield>Goroutines沒有yield</a></li><li><a href=#syscall%e4%b8%8d%e6%9c%83block%e5%85%b6%e4%bb%96thread%e3%84%9f aria-label=syscall不會block其他threadㄟ>syscall不會block其他threadㄟ</a></li><li><a href=#goroutines%e7%9a%84context-switch%e6%af%94%e8%bc%83%e5%bf%ab aria-label="Goroutines的context switch比較快?">Goroutines的context switch比較快?</a></li></ul></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>偶然找到<a href=https://c9x.me/articles/gthreads/intro.html>Green Threads Explained</a>很讚，做點筆記</p><h2 id=thread要有>thread要有?<a hidden class=anchor aria-hidden=true href=#thread要有>#</a></h2><ul><li>scheduler<ul><li>因為要schedule，所以要context switch<ul><li>context switch要換的是當下執行的狀態，所以要看<ul><li>arch(x86, amd64, arm)的ABI</li><li>arch的reg</li></ul></li></ul></li></ul></li></ul><h2 id=實作>實作?<a hidden class=anchor aria-hidden=true href=#實作>#</a></h2><p>這裡就看我覺得重要的地方</p><h3 id=struct-gt>struct gt<a hidden class=anchor aria-hidden=true href=#struct-gt>#</a></h3><p>thread的狀態，兩件事</p><ol><li>紀錄當下執行的狀態，或是說在cpu運算會用到的reg</li></ol><ul><li>reg其實可以當成cpu的狀態</li><li>同理，可以把這個概念推廣成在一般自己的function會用到的參數都是function的狀態</li></ul><ol start=2><li>thread的狀態</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>gt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>gtctx</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>rsp</span><span class=p>;</span> <span class=c1>//  Stack pointer for top address of the stack
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint64_t</span> <span class=n>r15</span><span class=p>;</span> <span class=c1>// I dont know
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint64_t</span> <span class=n>r14</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>r13</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>r12</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>rbx</span><span class=p>;</span> <span class=c1>// Base index (for use with arrays)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint64_t</span> <span class=n>rbp</span><span class=p>;</span> <span class=c1>// Stack base pointer for holding the address of the current stack frame.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>ctx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Unused</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>Running</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>Ready</span><span class=p>,</span> <span class=c1>// has rest of works
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>st</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=context-switch>context switch<a hidden class=anchor aria-hidden=true href=#context-switch>#</a></h3><p>這要同時看<code>gtgo</code>與<code>gtswtch</code></p><p>gtgo負責</p><ol><li>設給cpu用的stack，這</li><li>對pc(program counter)動手腳</li></ol><ul><li>我們沒辦法直接改pc，所以要利用stack動手腳<ul><li>stack第一層放<code>gtstop</code>，第二層放<code>f</code></li><li>第二層會在gtswtch(context switch)的<code>ret</code>，被拿出來跑到f去</li><li>stack第一層會在f直接call時利用到，return就直接到<code>gtstop</code></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>[</span><span class=n>StackSize</span> <span class=o>-</span>  <span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>gtstop</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>[</span><span class=n>StackSize</span> <span class=o>-</span> <span class=mi>16</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>ctx</span><span class=p>.</span><span class=n>rsp</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>[</span><span class=n>StackSize</span> <span class=o>-</span> <span class=mi>16</span><span class=p>];</span>
</span></span></code></pre></div><p>gtswtch就是把reg存起來，但問題是從哪到哪?
怎麼看old與new?</p><ol><li>看gtswtch怎麼被call的</li></ol><ul><li><code>gtswtch(old, new);</code></li></ul><ol start=2><li>arch的ABI</li></ol><ul><li>ABI會說，reg要怎麼用，像function的參數要怎麼帶</li><li>這裡<code>rdi</code>是第一個參數，<code>rsi</code>是第二個參數</li></ul><pre tabindex=0><code class=language-assembly data-lang=assembly>gtswtch:
        mov     %rsp, 0x00(%rdi)
        mov     %r15, 0x08(%rdi)
        mov     %r14, 0x10(%rdi)
        mov     %r13, 0x18(%rdi)
        mov     %r12, 0x20(%rdi)
        mov     %rbx, 0x28(%rdi)
        mov     %rbp, 0x30(%rdi)

        mov     0x00(%rsi), %rsp
        mov     0x08(%rsi), %r15
        mov     0x10(%rsi), %r14
        mov     0x18(%rsi), %r13
        mov     0x20(%rsi), %r12
        mov     0x28(%rsi), %rbx
        mov     0x30(%rsi), %rbp

        ret
</code></pre><h3 id=整體邏輯>整體邏輯<a hidden class=anchor aria-hidden=true href=#整體邏輯>#</a></h3><p>一個array去放thread，之後在<code>yield</code>被call時，換(這裡用RR去選)到下一個thread</p><h2 id=goroutines>Goroutines<a hidden class=anchor aria-hidden=true href=#goroutines>#</a></h2><p>Goroutines也是cooperative thread，與Green Threads Explained一樣，但感覺怪怪的?</p><h3 id=goroutines沒有yield>Goroutines沒有yield<a hidden class=anchor aria-hidden=true href=#goroutines沒有yield>#</a></h3><p>yield是runtime叫的</p><blockquote><ul><li>Channel send and receive operations, if those operations would block.</li><li>The Go statement, although there is no guarantee that new goroutine will be scheduled immediately.</li><li>Blocking syscalls like file and network operations.</li><li>After being stopped for a garbage collection cycle.</li></ul></blockquote><h3 id=syscall不會block其他threadㄟ>syscall不會block其他threadㄟ<a hidden class=anchor aria-hidden=true href=#syscall不會block其他threadㄟ>#</a></h3><p>所以go會把出事的thread放到其他OS thread去跑，畢竟syscall會block</p><p>這也是Goroutines要分成下面三個的理由</p><ul><li>G (green thread)</li><li>M (OS thread，真正做事的)</li><li>P (運行G的context)</li></ul><p>如果G發syscall就會讓M被卡，所以需要P讓其他G可以避難到其他M去</p><p><img loading=lazy src=https://morsmachine.dk/syscall.jpg alt></p><h3 id=goroutines的context-switch比較快>Goroutines的context switch比較快?<a hidden class=anchor aria-hidden=true href=#goroutines的context-switch比較快>#</a></h3><p>go只保留需要的reg</p><blockquote><p>since it is invoked implicitly in the code e.g. during sleep or channel wait, the compile only needs to safe/restore the registers which are alive at these points.
In Go, this means only 3 registers i.e. PC, SP and DX (Data Registers) being updated during context switch rather than all registers</p></blockquote><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://morsmachine.dk/go-scheduler>The Go scheduler</a>
<a href=https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f#396b>Why goroutines are not lightweight threads?</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/c/c++/>C/C++</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/06/windows%E4%B8%8A%E7%94%A8win10%E7%9A%84pxe%E6%AA%94%E6%A1%88%E8%88%87%E6%9E%B6pxe-server/><span class=title>« Prev</span><br><span>windows上用win10的pxe檔案與架pxe server</span>
</a><a class=next href=https://littlebees.github.io/2021/06/keepassxc%E5%90%8C%E6%AD%A5db%E8%88%87%E8%87%AA%E5%8B%95%E9%96%8Bdb/><span class=title>Next »</span><br><span>keepassxc同步db與自動開db</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>