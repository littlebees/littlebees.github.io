<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cmu 14-445 lab的不完全筆記 | 記事本</title>
<meta name=keywords content="DB"><meta name=description content="動機
不完全的理由是1~3只有跑local simple test，因為我的重點是第4個lab
想要了解不同的isolation level的效果"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2022/03/cmu-14-445-lab%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2022/03/cmu-14-445-lab%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%AD%86%E8%A8%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="cmu 14-445 lab的不完全筆記"><meta property="og:description" content="動機
不完全的理由是1~3只有跑local simple test，因為我的重點是第4個lab
想要了解不同的isolation level的效果"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2022/03/cmu-14-445-lab%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-31T10:45:01+00:00"><meta property="article:modified_time" content="2022-03-31T10:45:01+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="cmu 14-445 lab的不完全筆記"><meta name=twitter:description content="動機
不完全的理由是1~3只有跑local simple test，因為我的重點是第4個lab
想要了解不同的isolation level的效果"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"cmu 14-445 lab的不完全筆記","item":"https://littlebees.github.io/2022/03/cmu-14-445-lab%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"cmu 14-445 lab的不完全筆記","name":"cmu 14-445 lab的不完全筆記","description":"動機 不完全的理由是1~3只有跑local simple test，因為我的重點是第4個lab 想要了解不同的isolation level的效果\n","keywords":["DB"],"articleBody":"動機 不完全的理由是1~3只有跑local simple test，因為我的重點是第4個lab 想要了解不同的isolation level的效果\ngradescope 優點 可以print測資 缺點 有神秘的語法限制，但是不會報錯，只有下面的訊息 The autograder failed to execute correctly. Please ensure that your submission is valid. Contact your course staff for help in debugging this issue. Make sure to include a link to this page so that they can help you most effectively. 超慢，每次上傳至少超過一分鐘才會看到結果，也沒有做到哪個階段的過程 在project4，明明local的所有測資都過了，但就是有一個test不知道為什麼跑不了 output沒有任何東西，直接timeout，但測資有挖出來測過有pass… 同時後面直接在method的第一行放一個cout，之後看timeout的output也沒有噴出來… 答案是rehash，這個很可怕，見下面 一開始還有整個平台不能用的問題 (為期大概一個禮拜) Is the autograder be fixed? project1 提幾個重點\nlru不是一般認知的lru，unpin之後就不用管了 page分成readable與occupied 有allocate就是occupied，之後就不用動了 readable就是delete時要改的 dirty由invoker管，有直到下面的case才會真的寫回去disk flush 被選成victim project2 bucket就是一個page，直接從頭做search，剩下的struct不用動(也不能動，因為page剩下的空間都是array_的)\n剩下就是看這個\nproject3 其實邏輯都很簡單，但是難在怎麼使用你要的功能要反覆\n透過trace 看別人的example 總的來說，只要懂得怎麼\n從catalog拿table 從table的table_iterator拿tuple與rid(當成tuple的address) 怎麼根據output scheme來產生tuple (轉成vector之後變成tuple) 怎麼做expression的evalute (要去各自的plan看) project3就做得出來，其實這就是interpreter pattern\nproject4 這是重點所以慢慢講，還有下面是gradescope上的屍體(差valgrind)，local上的成體。\nISOLATION LEVELS SERIALIZABLE 上 index lock (條件) Why write skew can happen in Repeatable reads? 假設兩個thread都看到還有一個蘋果 (Read lock) 之後兩個跑increase，就變成-1 (upgrade lock) 這裡的重點是在改的當下無法保證條件是成立的 解法是 鎖整個表 為條件(不一定存在的欄位)生出一個鎖 column的read lock column的write lock 直到(strict)commit才把所有lock放掉 (strict 2 phase lock) REPEATABLE READS (SNAPSHOT ISOLATION) 上 column的read lock column的write lock 直到commit才把所有lock放掉 (strict 2 phase lock) READ COMMITTED 上 column的read lock column的write lock 直到commit才把所有lock放掉 除了read lock，他可以馬上放掉 (2 phase lock) READ UNCOMMITTED 不能上lock 在bustub的流程 begin會拿到transaction的id，每個transation會記錄拿了什麼lock(shared或exclusive)\ncommit與abort時會一次unlock所有lock\nabort還會從log中undo之前的操作，commit比較特別的是會一次把delete做完\nlock manager 有3個部分\n根據ISOLATION LEVELS決定鎖怎麼給 怎麼abort與wait (deadlock prevention) 指令(project3)怎麼用lock manager上lock 指令上lock不難，注意\nREAD UNCOMMITTED不用上鎖 READ COMMITTED的read lock要放掉 怎麼abort與wait可以看這個\n同個網站的extendsible hash也很清楚明瞭，我自己的project2的local test就是看他才做出來的\n這裡是做wound-wait，就是\n遇到老事務，等 遇到新事物，abort他 bool LockManager::LockRequestQueue::WaitWound(Transaction *txn, const RID \u0026rid, LockRequestQueue::WaitPred wait_pred, LockRequestQueue::WoundPred wound_pred) { std::unique_lock\u003cstd::mutex\u003e ul(lk_); auto \u0026q = request_queue_; auto ptr = q.begin(); while (ptr != q.end()) { if (ptr-\u003etxn_id_ \u003c txn-\u003eGetTransactionId() \u0026\u0026 wait_pred(ptr)) { // old txn cv_.wait(ul); if (txn-\u003eGetState() == TransactionState::ABORTED) { return false; } ptr = q.begin(); // restart check } else if (ptr-\u003etxn_id_ \u003e txn-\u003eGetTransactionId() \u0026\u0026 wound_pred(ptr, rid)) { // young txn assert(ptr-\u003etxn_id_ != txn-\u003eGetTransactionId()); Transaction *trans = TransactionManager::GetTransaction(ptr-\u003etxn_id_); ptr = q.erase(ptr); trans-\u003eSetState(TransactionState::ABORTED); cv_.notify_all(); } else { ptr++; } } return true; } 流程是\nenqueue，去排隊 做WaitWound，等與清其他事務 拿鎖 auto me = q.Enqueue(txn, rid, LockMode::EXCLUSIVE); if (!q.WaitWound(txn, rid, pred1, pred2)) { return false; } txn-\u003eSetState(TransactionState::GROWING); 最後是根據ISOLATION LEVELS決定鎖怎麼給\nexclusive\nbool not_appliable = txn-\u003eGetState() == TransactionState::ABORTED; bool need_abort = txn-\u003eGetState() == TransactionState::SHRINKING \u0026\u0026 txn-\u003eGetIsolationLevel() == IsolationLevel::REPEATABLE_READ; if (not_appliable || need_abort) { if (need_abort) { txn-\u003eSetState(TransactionState::ABORTED); } return false; } if (!txn-\u003eIsExclusiveLocked(rid)) { LockRequestQueue::WaitPred pred1 = [](LockRequestQueue::QIter \u0026ptr) { return true; }; LockRequestQueue::WoundPred pred2 = [](LockRequestQueue::QIter \u0026ptr, const RID \u0026rid) { Transaction *trans = TransactionManager::GetTransaction(ptr-\u003etxn_id_); trans-\u003eGetExclusiveLockSet()-\u003eerase(rid); trans-\u003eGetSharedLockSet()-\u003eerase(rid); return true; }; auto me = q.Enqueue(txn, rid, LockMode::EXCLUSIVE); if (!q.WaitWound(txn, rid, pred1, pred2)) { return false; } txn-\u003eSetState(TransactionState::GROWING); me-\u003elock_mode_ = LockMode::EXCLUSIVE; me-\u003egranted_ = true; txn-\u003eGetExclusiveLockSet()-\u003eemplace(rid); } return true; shared\nbool not_appliable = txn-\u003eGetState() == TransactionState::ABORTED; bool need_abort = txn-\u003eGetIsolationLevel() == IsolationLevel::READ_UNCOMMITTED || txn-\u003eGetState() == TransactionState::SHRINKING; if (not_appliable || need_abort) { if (need_abort) { txn-\u003eSetState(TransactionState::ABORTED); } return false; } if (!txn-\u003eIsSharedLocked(rid)) { LockRequestQueue::WaitPred pred1 = [](LockRequestQueue::QIter \u0026ptr) { return ptr-\u003elock_mode_ == LockMode::EXCLUSIVE; }; LockRequestQueue::WoundPred pred2 = [](LockRequestQueue::QIter \u0026ptr, const RID \u0026rid) { if (ptr-\u003elock_mode_ == LockMode::EXCLUSIVE) { Transaction *trans = TransactionManager::GetTransaction(ptr-\u003etxn_id_); trans-\u003eGetExclusiveLockSet()-\u003eerase(rid); trans-\u003eGetSharedLockSet()-\u003eerase(rid); return true; } return false; }; auto me = q.Enqueue(txn, rid, LockMode::SHARED); if (!q.WaitWound(txn, rid, pred1, pred2)) { return false; } txn-\u003eSetState(TransactionState::GROWING); me-\u003egranted_ = true; txn-\u003eGetSharedLockSet()-\u003eemplace(rid); } return true; upgrade其實與exclusive差不多 就是最後要把shared拔掉與exclusive塞進去\nauto \u0026q = GetQ(rid); bool not_appliable = txn-\u003eGetState() == TransactionState::ABORTED; bool need_abort = txn-\u003eGetState() == TransactionState::SHRINKING \u0026\u0026 txn-\u003eGetIsolationLevel() == IsolationLevel::REPEATABLE_READ; if (not_appliable || need_abort) { if (need_abort) { txn-\u003eSetState(TransactionState::ABORTED); } return false; } if (!txn-\u003eIsExclusiveLocked(rid)) { LockRequestQueue::WaitPred pred1 = [](LockRequestQueue::QIter \u0026ptr) { return true; }; LockRequestQueue::WoundPred pred2 = [](LockRequestQueue::QIter \u0026ptr, const RID \u0026rid) { Transaction *trans = TransactionManager::GetTransaction(ptr-\u003etxn_id_); trans-\u003eGetExclusiveLockSet()-\u003eerase(rid); trans-\u003eGetSharedLockSet()-\u003eerase(rid); return true; }; auto me = q.Enqueue(txn, rid, LockMode::EXCLUSIVE); if (!q.WaitWound(txn, rid, pred1, pred2)) { return false; } txn-\u003eSetState(TransactionState::GROWING); me-\u003elock_mode_ = LockMode::EXCLUSIVE; me-\u003egranted_ = true; txn-\u003eGetSharedLockSet()-\u003eerase(rid); txn-\u003eGetExclusiveLockSet()-\u003eemplace(rid); } return true; 要記得的是在abort與unlock之後馬上notify_all\nbool Unlock(Transaction *txn, const RID \u0026rid, LockMode txn_lockmode) { std::unique_lock\u003cstd::mutex\u003e ul(lk_); auto ptr = request_queue_.find(LockRequest{txn-\u003eGetTransactionId(), txn_lockmode}); if (ptr != request_queue_.end()) { request_queue_.erase(ptr); if (txn_lockmode == LockMode::SHARED) { txn-\u003eGetSharedLockSet()-\u003eerase(rid); } else { txn-\u003eGetExclusiveLockSet()-\u003eerase(rid); } cv_.notify_all(); return true; } return false; } 剩下是因為懶，就用unordered_set管理queue\nclass LockRequest { public: LockRequest(txn_id_t txn_id, LockMode lock_mode) : txn_id_(txn_id), lock_mode_(lock_mode), granted_(false) {} txn_id_t txn_id_; mutable LockMode lock_mode_; mutable bool granted_; }; struct LockRequestHash { std::size_t operator()(const LockRequest \u0026a) const { return a.txn_id_; } }; struct LockRequestEq { bool operator()(const LockRequest \u0026a, const LockRequest \u0026b) const { return a.txn_id_ == b.txn_id_; } }; class LockRequestQueue { public: using QIter = std::unordered_set\u003cLockRequest, LockRequestHash, LockRequestEq\u003e::iterator; using LocalLock = std::unique_lock\u003cstd::mutex\u003e; using WaitPred = bool (*)(QIter \u0026); using WoundPred = bool (*)(QIter \u0026, const RID \u0026); std::mutex lk_; std::unordered_set\u003cLockRequest, LockRequestHash, LockRequestEq\u003e request_queue_; // for notifying blocked transactions on this rid std::condition_variable cv_; // txn_id of an upgrading transaction (if any) // txn_id_t upgrading_ = INVALID_TXN_ID; //bool upgrading_ = false; LockRequestQueue() { request_queue_.reserve(50); } // avoid rehash QIter Enqueue(Transaction *txn, const RID \u0026rid, LockMode mode) { std::unique_lock\u003cstd::mutex\u003e ul(lk_); auto \u0026q = request_queue_; return q.insert(LockRequest{txn-\u003eGetTransactionId(), mode}).first; } bool WaitWound(Transaction *txn, const RID \u0026rid, WaitPred wait_pred, WoundPred wound_pred); bool Unlock(Transaction *txn, const RID \u0026rid, LockMode txn_lockmode) { std::unique_lock\u003cstd::mutex\u003e ul(lk_); auto ptr = request_queue_.find(LockRequest{txn-\u003eGetTransactionId(), txn_lockmode}); if (ptr != request_queue_.end()) { request_queue_.erase(ptr); if (txn_lockmode == LockMode::SHARED) { txn-\u003eGetSharedLockSet()-\u003eerase(rid); } else { txn-\u003eGetExclusiveLockSet()-\u003eerase(rid); } cv_.notify_all(); return true; } return false; } }; rehash的bug 全力感謝 记一个关于std::unordered_map并发下rehash引起的的BUG\n但gradescope還是很爛\n這個bug可怕在哪裡? 只在gradescope上發生，gradescope跑得很慢，gradescope限制output的總量(還有build的output已經先佔了一定容量)，也很難猜(我當初沒想到阿，明明都用id做hash key了)\nroot cause是unordered_map會rehash，所以可能同個key寫到同一個值，讓之前寫的不見 所以讓有用到hash的container都reserve，減少rehash的可能\n但是在我的code上這樣會過不了valgrind，但我懶了，反正目的是認識concurency control，目的已經達到了\n這次的反省是使用別人的東西之前，要好好看文件(這個我好像之前在別的文章打過一樣的結論…) 特別注意有沒有做一些user不知道的事(像rehash)，這種transparent的行為都是悲劇與痛苦的來源\n最後，附上修法，除了LockQueue以外，還有LockManager的lock_table要做reserve\nclass LockManager { enum class LockMode { SHARED, EXCLUSIVE }; class LockRequest { public: LockRequest(txn_id_t txn_id, LockMode lock_mode) : txn_id_(txn_id), lock_mode_(lock_mode), granted_(false) {} txn_id_t txn_id_; mutable LockMode lock_mode_; mutable bool granted_; }; struct LockRequestHash { std::size_t operator()(const LockRequest \u0026a) const { return a.txn_id_; } }; struct LockRequestEq { bool operator()(const LockRequest \u0026a, const LockRequest \u0026b) const { return a.txn_id_ == b.txn_id_; } }; class LockRequestQueue { public: using QIter = std::unordered_set\u003cLockRequest, LockRequestHash, LockRequestEq\u003e::iterator; using LocalLock = std::unique_lock\u003cstd::mutex\u003e; using WaitPred = bool (*)(QIter \u0026); using WoundPred = bool (*)(QIter \u0026, const RID \u0026); std::mutex lk_; std::unordered_set\u003cLockRequest, LockRequestHash, LockRequestEq\u003e request_queue_; // for notifying blocked transactions on this rid std::condition_variable cv_; // txn_id of an upgrading transaction (if any) // txn_id_t upgrading_ = INVALID_TXN_ID; LockRequestQueue() { request_queue_.reserve(50); } // avoid rehash QIter Enqueue(Transaction *txn, const RID \u0026rid, LockMode mode) { std::unique_lock\u003cstd::mutex\u003e ul(lk_); auto \u0026q = request_queue_; return q.insert(LockRequest{txn-\u003eGetTransactionId(), mode}).first; } bool WaitWound(Transaction *txn, const RID \u0026rid, WaitPred wait_pred, WoundPred wound_pred); bool Unlock(Transaction *txn, const RID \u0026rid, LockMode txn_lockmode) { std::unique_lock\u003cstd::mutex\u003e ul(lk_); auto ptr = request_queue_.find(LockRequest{txn-\u003eGetTransactionId(), txn_lockmode}); if (ptr != request_queue_.end()) { request_queue_.erase(ptr); if (txn_lockmode == LockMode::SHARED) { txn-\u003eGetSharedLockSet()-\u003eerase(rid); } else { txn-\u003eGetExclusiveLockSet()-\u003eerase(rid); } cv_.notify_all(); return true; } return false; } }; public: /** * Creates a new lock manager configured for the deadlock prevention policy. */ LockManager() { lock_table_.reserve(50); } // avoid rehash ~LockManager() = default; /* * [LOCK_NOTE]: For all locking functions, we: * 1. return false if the transaction is aborted; and * 2. block on wait, return true when the lock request is granted; and * 3. it is undefined behavior to try locking an already locked RID in the * same transaction, i.e. the transaction is responsible for keeping track of * its current locks. */ /** * Acquire a lock on RID in shared mode. See [LOCK_NOTE] in header file. * @param txn the transaction requesting the shared lock * @param rid the RID to be locked in shared mode * @return true if the lock is granted, false otherwise */ bool LockShared(Transaction *txn, const RID \u0026rid); /** * Acquire a lock on RID in exclusive mode. See [LOCK_NOTE] in header file. * @param txn the transaction requesting the exclusive lock * @param rid the RID to be locked in exclusive mode * @return true if the lock is granted, false otherwise */ bool LockExclusive(Transaction *txn, const RID \u0026rid); /** * Upgrade a lock from a shared lock to an exclusive lock. * @param txn the transaction requesting the lock upgrade * @param rid the RID that should already be locked in shared mode by the * requesting transaction * @return true if the upgrade is successful, false otherwise */ bool LockUpgrade(Transaction *txn, const RID \u0026rid); /** * Release the lock held by the transaction. * @param txn the transaction releasing the lock, it should actually hold the * lock * @param rid the RID that is locked by the transaction * @return true if the unlock is successful, false otherwise */ bool Unlock(Transaction *txn, const RID \u0026rid); LockRequestQueue \u0026GetQ(const RID \u0026rid) { std::unique_lock\u003cstd::mutex\u003e ul(latch_); return lock_table_[rid]; } private: std::mutex latch_; std::unordered_map\u003cRID, LockRequestQueue\u003e lock_table_; }; Ref 大老的實現筆記與code 大老的code 有人把recovery的test挖出來 2021 CMU-15445/645 Project #4 : Concurrency Control 【完】\n","wordCount":"1338","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2022-03-31T10:45:01Z","dateModified":"2022-03-31T10:45:01Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2022/03/cmu-14-445-lab%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">cmu 14-445 lab的不完全筆記</h1><div class=post-meta><span title='2022-03-31 10:45:01 +0000 UTC'>March 31, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#gradescope aria-label=gradescope>gradescope</a></li><li><a href=#project1 aria-label=project1>project1</a></li><li><a href=#project2 aria-label=project2>project2</a></li><li><a href=#project3 aria-label=project3>project3</a></li><li><a href=#project4 aria-label=project4>project4</a><ul><li><a href=#isolation-levels aria-label="ISOLATION LEVELS">ISOLATION LEVELS</a></li><li><a href=#%e5%9c%a8bustub%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=在bustub的流程>在bustub的流程</a></li><li><a href=#lock-manager aria-label="lock manager">lock manager</a></li><li><a href=#rehash%e7%9a%84bug aria-label=rehash的bug>rehash的bug</a></li></ul></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>不完全的理由是1~3只有跑local simple test，因為我的重點是第4個lab
想要了解不同的isolation level的效果</p><h2 id=gradescope>gradescope<a hidden class=anchor aria-hidden=true href=#gradescope>#</a></h2><ul><li>優點<ul><li>可以print測資</li></ul></li><li>缺點<ul><li>有神秘的語法限制，但是不會報錯，只有下面的訊息<ul><li>The autograder failed to execute correctly. Please ensure that your submission is valid. Contact your course staff for help in debugging this issue. Make sure to include a link to this page so that they can help you most effectively.</li></ul></li><li>超慢，每次上傳至少超過一分鐘才會看到結果，也沒有做到哪個階段的過程</li><li>在project4，明明local的所有測資都過了，但就是有一個test不知道為什麼跑不了<ul><li>output沒有任何東西，直接timeout，但測資有挖出來測過有pass&mldr;</li><li>同時後面直接在method的第一行放一個cout，之後看timeout的output也沒有噴出來&mldr;<ul><li>答案是rehash，這個很可怕，見下面</li></ul></li></ul></li><li>一開始還有整個平台不能用的問題 (為期大概一個禮拜)<ul><li><a href=https://github.com/cmu-db/bustub/issues/227>Is the autograder be fixed?</a></li></ul></li></ul></li></ul><h2 id=project1>project1<a hidden class=anchor aria-hidden=true href=#project1>#</a></h2><p>提幾個重點</p><ul><li>lru不是一般認知的lru，unpin之後就不用管了</li><li>page分成readable與occupied<ul><li>有allocate就是occupied，之後就不用動了</li><li>readable就是delete時要改的</li></ul></li><li>dirty由invoker管，有直到下面的case才會真的寫回去disk<ul><li>flush</li><li>被選成victim</li></ul></li></ul><h2 id=project2>project2<a hidden class=anchor aria-hidden=true href=#project2>#</a></h2><p>bucket就是一個page，直接從頭做search，剩下的struct不用動(也不能動，因為page剩下的空間都是array_的)</p><p>剩下就是看<a href=http://www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/3-index/extensible-hashing.html>這個</a></p><h2 id=project3>project3<a hidden class=anchor aria-hidden=true href=#project3>#</a></h2><p>其實邏輯都很簡單，但是難在怎麼使用你要的功能要反覆</p><ol><li>透過trace</li><li>看別人的example</li></ol><p>總的來說，只要懂得怎麼</p><ol><li>從catalog拿table</li><li>從table的table_iterator拿tuple與rid(當成tuple的address)</li><li>怎麼根據output scheme來產生tuple (轉成vector&lt;value>之後變成tuple)</li><li>怎麼做expression的evalute (要去各自的plan看)</li></ol><p>project3就做得出來，其實這就是interpreter pattern</p><h2 id=project4>project4<a hidden class=anchor aria-hidden=true href=#project4>#</a></h2><p>這是重點所以慢慢講，還有下面是gradescope上的屍體(差valgrind)，local上的成體。</p><h3 id=isolation-levels>ISOLATION LEVELS<a hidden class=anchor aria-hidden=true href=#isolation-levels>#</a></h3><ul><li>SERIALIZABLE<ul><li>上<ul><li>index lock (條件)<ul><li><a href=https://stackoverflow.com/questions/48417632/why-write-skew-can-happen-in-repeatable-reads>Why write skew can happen in Repeatable reads?</a></li><li>假設兩個thread都看到還有一個蘋果 (Read lock)</li><li>之後兩個跑increase，就變成-1 (upgrade lock)</li><li>這裡的重點是在改的當下無法保證條件是成立的<ul><li>解法是<ul><li>鎖整個表</li><li>為條件(不一定存在的欄位)生出一個鎖</li></ul></li></ul></li></ul></li><li>column的read lock</li><li>column的write lock</li></ul></li><li>直到(strict)commit才把所有lock放掉 (strict 2 phase lock)</li></ul></li><li>REPEATABLE READS (SNAPSHOT ISOLATION)<ul><li>上<ul><li>column的read lock</li><li>column的write lock</li></ul></li><li>直到commit才把所有lock放掉 (strict 2 phase lock)</li></ul></li><li>READ COMMITTED<ul><li>上<ul><li>column的read lock</li><li>column的write lock</li></ul></li><li>直到commit才把所有lock放掉<ul><li>除了read lock，他可以馬上放掉 (2 phase lock)</li></ul></li></ul></li><li>READ UNCOMMITTED<ul><li>不能上lock</li></ul></li></ul><h3 id=在bustub的流程>在bustub的流程<a hidden class=anchor aria-hidden=true href=#在bustub的流程>#</a></h3><p>begin會拿到transaction的id，每個transation會記錄拿了什麼lock(shared或exclusive)</p><p>commit與abort時會一次unlock所有lock</p><p>abort還會從log中undo之前的操作，commit比較特別的是會一次把delete做完</p><h3 id=lock-manager>lock manager<a hidden class=anchor aria-hidden=true href=#lock-manager>#</a></h3><p>有3個部分</p><ol><li>根據ISOLATION LEVELS決定鎖怎麼給</li><li>怎麼abort與wait (deadlock prevention)</li><li>指令(project3)怎麼用lock manager上lock</li></ol><p>指令上lock不難，注意</p><ol><li>READ UNCOMMITTED不用上鎖</li><li>READ COMMITTED的read lock要放掉</li></ol><p>怎麼abort與wait可以看<a href=http://www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/8-recv+serial/deadlock-compare.html>這個</a></p><p>同個網站的extendsible hash也很清楚明瞭，我自己的project2的local test就是看他才做出來的</p><p>這裡是做wound-wait，就是</p><ol><li>遇到老事務，等</li><li>遇到新事物，abort他</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=n>LockManager</span><span class=o>::</span><span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WaitWound</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>,</span> <span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WaitPred</span> <span class=n>wait_pred</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                              <span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WoundPred</span> <span class=n>wound_pred</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>ul</span><span class=p>(</span><span class=n>lk_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=o>&amp;</span><span class=n>q</span> <span class=o>=</span> <span class=n>request_queue_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>!=</span> <span class=n>q</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>txn_id_</span> <span class=o>&lt;</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetTransactionId</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>wait_pred</span><span class=p>(</span><span class=n>ptr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// old txn
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>cv_</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>ul</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetState</span><span class=p>()</span> <span class=o>==</span> <span class=n>TransactionState</span><span class=o>::</span><span class=n>ABORTED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>ptr</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>  <span class=c1>// restart check
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>txn_id_</span> <span class=o>&gt;</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetTransactionId</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>wound_pred</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=n>rid</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// young txn
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>assert</span><span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>txn_id_</span> <span class=o>!=</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetTransactionId</span><span class=p>());</span>
</span></span><span class=line><span class=cl>      <span class=n>Transaction</span> <span class=o>*</span><span class=n>trans</span> <span class=o>=</span> <span class=n>TransactionManager</span><span class=o>::</span><span class=n>GetTransaction</span><span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>txn_id_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>ptr</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>trans</span><span class=o>-&gt;</span><span class=n>SetState</span><span class=p>(</span><span class=n>TransactionState</span><span class=o>::</span><span class=n>ABORTED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>cv_</span><span class=p>.</span><span class=n>notify_all</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>ptr</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>流程是</p><ol><li>enqueue，去排隊</li><li>做WaitWound，等與清其他事務</li><li>拿鎖</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>me</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>Enqueue</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>EXCLUSIVE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>WaitWound</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>rid</span><span class=p>,</span> <span class=n>pred1</span><span class=p>,</span> <span class=n>pred2</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>txn</span><span class=o>-&gt;</span><span class=n>SetState</span><span class=p>(</span><span class=n>TransactionState</span><span class=o>::</span><span class=n>GROWING</span><span class=p>);</span>
</span></span></code></pre></div><p>最後是根據ISOLATION LEVELS決定鎖怎麼給</p><p>exclusive</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=n>not_appliable</span> <span class=o>=</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetState</span><span class=p>()</span> <span class=o>==</span> <span class=n>TransactionState</span><span class=o>::</span><span class=n>ABORTED</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>need_abort</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetState</span><span class=p>()</span> <span class=o>==</span> <span class=n>TransactionState</span><span class=o>::</span><span class=n>SHRINKING</span> <span class=o>&amp;&amp;</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetIsolationLevel</span><span class=p>()</span> <span class=o>==</span> <span class=n>IsolationLevel</span><span class=o>::</span><span class=n>REPEATABLE_READ</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>not_appliable</span> <span class=o>||</span> <span class=n>need_abort</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>need_abort</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>txn</span><span class=o>-&gt;</span><span class=n>SetState</span><span class=p>(</span><span class=n>TransactionState</span><span class=o>::</span><span class=n>ABORTED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>IsExclusiveLocked</span><span class=p>(</span><span class=n>rid</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WaitPred</span> <span class=n>pred1</span> <span class=o>=</span> <span class=p>[](</span><span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WoundPred</span> <span class=n>pred2</span> <span class=o>=</span> <span class=p>[](</span><span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=n>ptr</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Transaction</span> <span class=o>*</span><span class=n>trans</span> <span class=o>=</span> <span class=n>TransactionManager</span><span class=o>::</span><span class=n>GetTransaction</span><span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>txn_id_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>trans</span><span class=o>-&gt;</span><span class=n>GetExclusiveLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>trans</span><span class=o>-&gt;</span><span class=n>GetSharedLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>me</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>Enqueue</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>EXCLUSIVE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>WaitWound</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>rid</span><span class=p>,</span> <span class=n>pred1</span><span class=p>,</span> <span class=n>pred2</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>txn</span><span class=o>-&gt;</span><span class=n>SetState</span><span class=p>(</span><span class=n>TransactionState</span><span class=o>::</span><span class=n>GROWING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>me</span><span class=o>-&gt;</span><span class=n>lock_mode_</span> <span class=o>=</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>EXCLUSIVE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>me</span><span class=o>-&gt;</span><span class=n>granted_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetExclusiveLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>emplace</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span></code></pre></div><p>shared</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=n>not_appliable</span> <span class=o>=</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetState</span><span class=p>()</span> <span class=o>==</span> <span class=n>TransactionState</span><span class=o>::</span><span class=n>ABORTED</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>need_abort</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetIsolationLevel</span><span class=p>()</span> <span class=o>==</span> <span class=n>IsolationLevel</span><span class=o>::</span><span class=n>READ_UNCOMMITTED</span> <span class=o>||</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetState</span><span class=p>()</span> <span class=o>==</span> <span class=n>TransactionState</span><span class=o>::</span><span class=n>SHRINKING</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>not_appliable</span> <span class=o>||</span> <span class=n>need_abort</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>need_abort</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>txn</span><span class=o>-&gt;</span><span class=n>SetState</span><span class=p>(</span><span class=n>TransactionState</span><span class=o>::</span><span class=n>ABORTED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>IsSharedLocked</span><span class=p>(</span><span class=n>rid</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WaitPred</span> <span class=n>pred1</span> <span class=o>=</span> <span class=p>[](</span><span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>lock_mode_</span> <span class=o>==</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>EXCLUSIVE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WoundPred</span> <span class=n>pred2</span> <span class=o>=</span> <span class=p>[](</span><span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=n>ptr</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>lock_mode_</span> <span class=o>==</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>EXCLUSIVE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Transaction</span> <span class=o>*</span><span class=n>trans</span> <span class=o>=</span> <span class=n>TransactionManager</span><span class=o>::</span><span class=n>GetTransaction</span><span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>txn_id_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>trans</span><span class=o>-&gt;</span><span class=n>GetExclusiveLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>trans</span><span class=o>-&gt;</span><span class=n>GetSharedLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>me</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>Enqueue</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>SHARED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>WaitWound</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>rid</span><span class=p>,</span> <span class=n>pred1</span><span class=p>,</span> <span class=n>pred2</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>txn</span><span class=o>-&gt;</span><span class=n>SetState</span><span class=p>(</span><span class=n>TransactionState</span><span class=o>::</span><span class=n>GROWING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>me</span><span class=o>-&gt;</span><span class=n>granted_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetSharedLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>emplace</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span></code></pre></div><p>upgrade其實與exclusive差不多
就是最後要把shared拔掉與exclusive塞進去</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=o>&amp;</span><span class=n>q</span> <span class=o>=</span> <span class=n>GetQ</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>not_appliable</span> <span class=o>=</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetState</span><span class=p>()</span> <span class=o>==</span> <span class=n>TransactionState</span><span class=o>::</span><span class=n>ABORTED</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>need_abort</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetState</span><span class=p>()</span> <span class=o>==</span> <span class=n>TransactionState</span><span class=o>::</span><span class=n>SHRINKING</span> <span class=o>&amp;&amp;</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetIsolationLevel</span><span class=p>()</span> <span class=o>==</span> <span class=n>IsolationLevel</span><span class=o>::</span><span class=n>REPEATABLE_READ</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>not_appliable</span> <span class=o>||</span> <span class=n>need_abort</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>need_abort</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>txn</span><span class=o>-&gt;</span><span class=n>SetState</span><span class=p>(</span><span class=n>TransactionState</span><span class=o>::</span><span class=n>ABORTED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>IsExclusiveLocked</span><span class=p>(</span><span class=n>rid</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WaitPred</span> <span class=n>pred1</span> <span class=o>=</span> <span class=p>[](</span><span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>WoundPred</span> <span class=n>pred2</span> <span class=o>=</span> <span class=p>[](</span><span class=n>LockRequestQueue</span><span class=o>::</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=n>ptr</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Transaction</span> <span class=o>*</span><span class=n>trans</span> <span class=o>=</span> <span class=n>TransactionManager</span><span class=o>::</span><span class=n>GetTransaction</span><span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>txn_id_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>trans</span><span class=o>-&gt;</span><span class=n>GetExclusiveLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>trans</span><span class=o>-&gt;</span><span class=n>GetSharedLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>me</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>Enqueue</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>EXCLUSIVE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>WaitWound</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>rid</span><span class=p>,</span> <span class=n>pred1</span><span class=p>,</span> <span class=n>pred2</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>txn</span><span class=o>-&gt;</span><span class=n>SetState</span><span class=p>(</span><span class=n>TransactionState</span><span class=o>::</span><span class=n>GROWING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>me</span><span class=o>-&gt;</span><span class=n>lock_mode_</span> <span class=o>=</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>EXCLUSIVE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>me</span><span class=o>-&gt;</span><span class=n>granted_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetSharedLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetExclusiveLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>emplace</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span></code></pre></div><p>要記得的是在abort與unlock之後馬上notify_all</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Unlock</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span> <span class=n>txn_lockmode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>ul</span><span class=p>(</span><span class=n>lk_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>request_queue_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>LockRequest</span><span class=p>{</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetTransactionId</span><span class=p>(),</span> <span class=n>txn_lockmode</span><span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>!=</span> <span class=n>request_queue_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>request_queue_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>txn_lockmode</span> <span class=o>==</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>SHARED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetSharedLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetExclusiveLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>cv_</span><span class=p>.</span><span class=n>notify_all</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>剩下是因為懶，就用unordered_set管理queue</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockRequest</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockRequest</span><span class=p>(</span><span class=n>txn_id_t</span> <span class=n>txn_id</span><span class=p>,</span> <span class=n>LockMode</span> <span class=n>lock_mode</span><span class=p>)</span> <span class=o>:</span> <span class=n>txn_id_</span><span class=p>(</span><span class=n>txn_id</span><span class=p>),</span> <span class=n>lock_mode_</span><span class=p>(</span><span class=n>lock_mode</span><span class=p>),</span> <span class=n>granted_</span><span class=p>(</span><span class=nb>false</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>txn_id_t</span> <span class=n>txn_id_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>LockMode</span> <span class=n>lock_mode_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=kt>bool</span> <span class=n>granted_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>LockRequestHash</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=k>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>LockRequest</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>txn_id_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>LockRequestEq</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>LockRequest</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>LockRequest</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>txn_id_</span> <span class=o>==</span> <span class=n>b</span><span class=p>.</span><span class=n>txn_id_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>LockRequestQueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>QIter</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>LockRequest</span><span class=p>,</span> <span class=n>LockRequestHash</span><span class=p>,</span> <span class=n>LockRequestEq</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>LocalLock</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>WaitPred</span> <span class=o>=</span> <span class=kt>bool</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>WoundPred</span> <span class=o>=</span> <span class=kt>bool</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>lk_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>LockRequest</span><span class=p>,</span> <span class=n>LockRequestHash</span><span class=p>,</span> <span class=n>LockRequestEq</span><span class=o>&gt;</span> <span class=n>request_queue_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// for notifying blocked transactions on this rid
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>condition_variable</span> <span class=n>cv_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// txn_id of an upgrading transaction (if any)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// txn_id_t upgrading_ = INVALID_TXN_ID;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//bool upgrading_ = false;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LockRequestQueue</span><span class=p>()</span> <span class=p>{</span> <span class=n>request_queue_</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>50</span><span class=p>);</span> <span class=p>}</span> <span class=c1>// avoid rehash
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>QIter</span> <span class=nf>Enqueue</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span> <span class=n>mode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>ul</span><span class=p>(</span><span class=n>lk_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=o>&amp;</span><span class=n>q</span> <span class=o>=</span> <span class=n>request_queue_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>q</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>LockRequest</span><span class=p>{</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetTransactionId</span><span class=p>(),</span> <span class=n>mode</span><span class=p>}).</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>WaitWound</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>,</span> <span class=n>WaitPred</span> <span class=n>wait_pred</span><span class=p>,</span> <span class=n>WoundPred</span> <span class=n>wound_pred</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>Unlock</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span> <span class=n>txn_lockmode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>ul</span><span class=p>(</span><span class=n>lk_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>request_queue_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>LockRequest</span><span class=p>{</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetTransactionId</span><span class=p>(),</span> <span class=n>txn_lockmode</span><span class=p>});</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>!=</span> <span class=n>request_queue_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>request_queue_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>txn_lockmode</span> <span class=o>==</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>SHARED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetSharedLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetExclusiveLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>cv_</span><span class=p>.</span><span class=n>notify_all</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span></code></pre></div><h3 id=rehash的bug>rehash的bug<a hidden class=anchor aria-hidden=true href=#rehash的bug>#</a></h3><p>全力感謝 <a href="https://www.cnblogs.com/KatyuMarisaBlog/p/14432005.html?ivk_sa=1024320u">记一个关于std::unordered_map并发下rehash引起的的BUG</a></p><p>但gradescope還是很爛</p><p>這個bug可怕在哪裡?
只在gradescope上發生，gradescope跑得很慢，gradescope限制output的總量(還有build的output已經先佔了一定容量)，也很難猜(我當初沒想到阿，明明都用id做hash key了)</p><p>root cause是unordered_map會rehash，所以可能同個key寫到同一個值，讓之前寫的不見
所以讓有用到hash的container都reserve，減少rehash的可能</p><p>但是在我的code上這樣會過不了valgrind，但我懶了，反正目的是認識concurency control，目的已經達到了</p><p>這次的反省是使用別人的東西之前，要好好看文件(這個我好像之前在別的文章打過一樣的結論&mldr;)
特別注意有沒有做<strong>一些user不知道的事</strong>(像rehash)，這種<strong>transparent的行為</strong>都是悲劇與痛苦的來源</p><p>最後，附上修法，除了LockQueue以外，還有LockManager的lock_table要做reserve</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockManager</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>enum</span> <span class=k>class</span> <span class=nc>LockMode</span> <span class=p>{</span> <span class=n>SHARED</span><span class=p>,</span> <span class=n>EXCLUSIVE</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>LockRequest</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LockRequest</span><span class=p>(</span><span class=n>txn_id_t</span> <span class=n>txn_id</span><span class=p>,</span> <span class=n>LockMode</span> <span class=n>lock_mode</span><span class=p>)</span> <span class=o>:</span> <span class=n>txn_id_</span><span class=p>(</span><span class=n>txn_id</span><span class=p>),</span> <span class=n>lock_mode_</span><span class=p>(</span><span class=n>lock_mode</span><span class=p>),</span> <span class=n>granted_</span><span class=p>(</span><span class=nb>false</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>txn_id_t</span> <span class=n>txn_id_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>LockMode</span> <span class=n>lock_mode_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=kt>bool</span> <span class=n>granted_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>LockRequestHash</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=k>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>LockRequest</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>txn_id_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>LockRequestEq</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>LockRequest</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>LockRequest</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>txn_id_</span> <span class=o>==</span> <span class=n>b</span><span class=p>.</span><span class=n>txn_id_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>LockRequestQueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>QIter</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>LockRequest</span><span class=p>,</span> <span class=n>LockRequestHash</span><span class=p>,</span> <span class=n>LockRequestEq</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>LocalLock</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>WaitPred</span> <span class=o>=</span> <span class=kt>bool</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>WoundPred</span> <span class=o>=</span> <span class=kt>bool</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>QIter</span> <span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>lk_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>LockRequest</span><span class=p>,</span> <span class=n>LockRequestHash</span><span class=p>,</span> <span class=n>LockRequestEq</span><span class=o>&gt;</span> <span class=n>request_queue_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// for notifying blocked transactions on this rid
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>condition_variable</span> <span class=n>cv_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// txn_id of an upgrading transaction (if any)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// txn_id_t upgrading_ = INVALID_TXN_ID;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LockRequestQueue</span><span class=p>()</span> <span class=p>{</span> <span class=n>request_queue_</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>50</span><span class=p>);</span> <span class=p>}</span> <span class=c1>// avoid rehash
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>QIter</span> <span class=nf>Enqueue</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span> <span class=n>mode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>ul</span><span class=p>(</span><span class=n>lk_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=o>&amp;</span><span class=n>q</span> <span class=o>=</span> <span class=n>request_queue_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>q</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>LockRequest</span><span class=p>{</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetTransactionId</span><span class=p>(),</span> <span class=n>mode</span><span class=p>}).</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>WaitWound</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>,</span> <span class=n>WaitPred</span> <span class=n>wait_pred</span><span class=p>,</span> <span class=n>WoundPred</span> <span class=n>wound_pred</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>Unlock</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>,</span> <span class=n>LockMode</span> <span class=n>txn_lockmode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>ul</span><span class=p>(</span><span class=n>lk_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>request_queue_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>LockRequest</span><span class=p>{</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetTransactionId</span><span class=p>(),</span> <span class=n>txn_lockmode</span><span class=p>});</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>!=</span> <span class=n>request_queue_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>request_queue_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>txn_lockmode</span> <span class=o>==</span> <span class=n>LockMode</span><span class=o>::</span><span class=n>SHARED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetSharedLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>txn</span><span class=o>-&gt;</span><span class=n>GetExclusiveLockSet</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>erase</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>cv_</span><span class=p>.</span><span class=n>notify_all</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Creates a new lock manager configured for the deadlock prevention policy.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=n>LockManager</span><span class=p>()</span> <span class=p>{</span> <span class=n>lock_table_</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>50</span><span class=p>);</span> <span class=p>}</span> <span class=c1>// avoid rehash
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>LockManager</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * [LOCK_NOTE]: For all locking functions, we:
</span></span></span><span class=line><span class=cl><span class=cm>   * 1. return false if the transaction is aborted; and
</span></span></span><span class=line><span class=cl><span class=cm>   * 2. block on wait, return true when the lock request is granted; and
</span></span></span><span class=line><span class=cl><span class=cm>   * 3. it is undefined behavior to try locking an already locked RID in the
</span></span></span><span class=line><span class=cl><span class=cm>   * same transaction, i.e. the transaction is responsible for keeping track of
</span></span></span><span class=line><span class=cl><span class=cm>   * its current locks.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Acquire a lock on RID in shared mode. See [LOCK_NOTE] in header file.
</span></span></span><span class=line><span class=cl><span class=cm>   * @param txn the transaction requesting the shared lock
</span></span></span><span class=line><span class=cl><span class=cm>   * @param rid the RID to be locked in shared mode
</span></span></span><span class=line><span class=cl><span class=cm>   * @return true if the lock is granted, false otherwise
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>LockShared</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Acquire a lock on RID in exclusive mode. See [LOCK_NOTE] in header file.
</span></span></span><span class=line><span class=cl><span class=cm>   * @param txn the transaction requesting the exclusive lock
</span></span></span><span class=line><span class=cl><span class=cm>   * @param rid the RID to be locked in exclusive mode
</span></span></span><span class=line><span class=cl><span class=cm>   * @return true if the lock is granted, false otherwise
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>LockExclusive</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Upgrade a lock from a shared lock to an exclusive lock.
</span></span></span><span class=line><span class=cl><span class=cm>   * @param txn the transaction requesting the lock upgrade
</span></span></span><span class=line><span class=cl><span class=cm>   * @param rid the RID that should already be locked in shared mode by the
</span></span></span><span class=line><span class=cl><span class=cm>   * requesting transaction
</span></span></span><span class=line><span class=cl><span class=cm>   * @return true if the upgrade is successful, false otherwise
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>LockUpgrade</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Release the lock held by the transaction.
</span></span></span><span class=line><span class=cl><span class=cm>   * @param txn the transaction releasing the lock, it should actually hold the
</span></span></span><span class=line><span class=cl><span class=cm>   * lock
</span></span></span><span class=line><span class=cl><span class=cm>   * @param rid the RID that is locked by the transaction
</span></span></span><span class=line><span class=cl><span class=cm>   * @return true if the unlock is successful, false otherwise
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>Unlock</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>LockRequestQueue</span> <span class=o>&amp;</span><span class=n>GetQ</span><span class=p>(</span><span class=k>const</span> <span class=n>RID</span> <span class=o>&amp;</span><span class=n>rid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>ul</span><span class=p>(</span><span class=n>latch_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>lock_table_</span><span class=p>[</span><span class=n>rid</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>latch_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>RID</span><span class=p>,</span> <span class=n>LockRequestQueue</span><span class=o>&gt;</span> <span class=n>lock_table_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://www.epis2048.net/categories/Code/CMU-15445/index.html>大老的實現筆記與code</a>
<a href=https://github.com/epis2048/cmu_15445_2021>大老的code</a>
<a href=https://github.com/cakebytheoceanLuo/CMU15-445/tree/master/test>有人把recovery的test挖出來</a>
<a href="https://blog.csdn.net/MoonWisher_liang/article/details/123510769?spm=1001.2014.3001.5502">2021 CMU-15445/645 Project #4 : Concurrency Control 【完】</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/db/>DB</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2022/03/sync%E6%BC%94%E7%AE%97%E6%B3%95-%E4%BD%86%E6%B2%92%E7%94%A8/><span class=title>« Prev</span><br><span>sync演算法 (但沒用)</span>
</a><a class=next href=https://littlebees.github.io/2022/03/6-824%E7%9A%84question/><span class=title>Next »</span><br><span>6-824的question</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>