<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>leetcode-654 - Maximum Binary Tree | 記事本</title>
<meta name=keywords content="Binary Tree,Monotonic Stack,Tree,Stack,Divide and Conquer,Array,seanprashad"><meta name=description content="動機
這應該是easy吧"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/07/leetcode-654-maximum-binary-tree/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="leetcode-654 - Maximum Binary Tree"><meta property="og:description" content="動機
這應該是easy吧"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/07/leetcode-654-maximum-binary-tree/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-31T23:19:36+00:00"><meta property="article:modified_time" content="2021-07-31T23:19:36+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="leetcode-654 - Maximum Binary Tree"><meta name=twitter:description content="動機
這應該是easy吧"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"leetcode-654 - Maximum Binary Tree","item":"https://littlebees.github.io/2021/07/leetcode-654-maximum-binary-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode-654 - Maximum Binary Tree","name":"leetcode-654 - Maximum Binary Tree","description":"動機 這應該是easy吧\n","keywords":["Binary Tree","Monotonic Stack","Tree","Stack","Divide and Conquer","Array","seanprashad"],"articleBody":"動機 這應該是easy吧\nProblem You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\nCreate a root node whose value is the maximum value in nums.Recursively build the left subtree on the subarray prefix to the left of the maximum value.Recursively build the right subtree on the subarray suffix to the right of the maximum value.Return the maximum binary tree built from nums.\nExample 1:\nInput: nums = [3,2,1,6,0,5]Output: [6,3,5,null,2,0,null,null,1]Explanation: The recursive calls are as follow:- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5]. - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1]. - Empty array, so no child. - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1]. - Empty array, so no child. - Only one element, so child is a node with value 1. - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is []. - Only one element, so child is a node with value 0. - Empty array, so no child.Example 2:\nInput: nums = [3,2,1]Output: [3,null,2,null,1] Constraints:\n1 \u003c= nums.length \u003c= 10000 \u003c= nums[i] \u003c= 1000All integers in nums are unique. Sol class Solution: def constructMaximumBinaryTree(self, nums: List[int]) -\u003e TreeNode: if not nums: return None else: mxi, mxv = max(enumerate(nums), key=itemgetter(1)) ret = TreeNode(mxv) ret.left = self.constructMaximumBinaryTree(nums[:mxi]) ret.right = self.constructMaximumBinaryTree(nums[mxi+1:]) return ret ","wordCount":"250","inLanguage":"en","datePublished":"2021-07-31T23:19:36Z","dateModified":"2021-07-31T23:19:36Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/07/leetcode-654-maximum-binary-tree/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">leetcode-654 - Maximum Binary Tree</h1><div class=post-meta><span title='2021-07-31 23:19:36 +0000 UTC'>July 31, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#sol aria-label=Sol>Sol</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>這應該是easy吧</p><h2 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h2><p>You are given an integer array <code>nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code>nums</code> using the following algorithm:</p><ol><li>Create a root node whose value is the maximum value in <code>nums</code>.</li><li>Recursively build the left subtree on the <strong>subarray prefix</strong> to the <strong>left</strong> of the maximum value.</li><li>Recursively build the right subtree on the <strong>subarray suffix</strong> to the <strong>right</strong> of the maximum value.</li></ol><p>Return <em>the <strong>maximum binary tree</strong> built from </em><code>nums</code>.</p><p> </p><p><strong>Example 1:</strong></p><img alt src=https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg style=width:302px;height:421px><pre><strong>Input:</strong> nums = [3,2,1,6,0,5]<strong>Output:</strong> [6,3,5,null,2,0,null,null,1]<strong>Explanation:</strong> The recursive calls are as follow:- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].        - Empty array, so no child.        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].            - Empty array, so no child.            - Only one element, so child is a node with value 1.    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].        - Only one element, so child is a node with value 0.        - Empty array, so no child.</pre><p><strong>Example 2:</strong></p><img alt src=https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg style=width:182px;height:301px><pre><strong>Input:</strong> nums = [3,2,1]<strong>Output:</strong> [3,null,2,null,1]</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>1 <= nums.length <= 1000</code></li><li><code>0 <= nums[i] <= 1000</code></li><li>All integers in <code>nums</code> are <strong>unique</strong>.</li></ul><h2 id=sol>Sol<a hidden class=anchor aria-hidden=true href=#sol>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>constructMaximumBinaryTree</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>TreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>mxi</span><span class=p>,</span> <span class=n>mxv</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=nb>enumerate</span><span class=p>(</span><span class=n>nums</span><span class=p>),</span> <span class=n>key</span><span class=o>=</span><span class=n>itemgetter</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=n>mxv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>constructMaximumBinaryTree</span><span class=p>(</span><span class=n>nums</span><span class=p>[:</span><span class=n>mxi</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>constructMaximumBinaryTree</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>mxi</span><span class=o>+</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/binary-tree/>Binary Tree</a></li><li><a href=https://littlebees.github.io/tags/monotonic-stack/>Monotonic Stack</a></li><li><a href=https://littlebees.github.io/tags/tree/>Tree</a></li><li><a href=https://littlebees.github.io/tags/stack/>Stack</a></li><li><a href=https://littlebees.github.io/tags/divide-and-conquer/>Divide and Conquer</a></li><li><a href=https://littlebees.github.io/tags/array/>Array</a></li><li><a href=https://littlebees.github.io/tags/seanprashad/>seanprashad</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/07/leetcode-113-path-sum-ii/><span class=title>« Prev</span><br><span>leetcode-113 - Path Sum II</span>
</a><a class=next href=https://littlebees.github.io/2021/07/leetcode-16-3sum-closest/><span class=title>Next »</span><br><span>leetcode-16 - 3Sum Closest</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>