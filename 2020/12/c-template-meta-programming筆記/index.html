<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ template meta-programming筆記 | 記事本</title>
<meta name=keywords content="C/C++"><meta name=description content="動機
一切的開始，只是想要個reversed而已，就順便把tmp補完"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2020/12/c-template-meta-programming%E7%AD%86%E8%A8%98/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2020/12/c-template-meta-programming%E7%AD%86%E8%A8%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C++ template meta-programming筆記"><meta property="og:description" content="動機
一切的開始，只是想要個reversed而已，就順便把tmp補完"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2020/12/c-template-meta-programming%E7%AD%86%E8%A8%98/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-19T02:35:50+00:00"><meta property="article:modified_time" content="2020-12-19T02:35:50+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="C++ template meta-programming筆記"><meta name=twitter:description content="動機
一切的開始，只是想要個reversed而已，就順便把tmp補完"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ template meta-programming筆記","item":"https://littlebees.github.io/2020/12/c-template-meta-programming%E7%AD%86%E8%A8%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ template meta-programming筆記","name":"C\u002b\u002b template meta-programming筆記","description":"動機 一切的開始，只是想要個reversed而已，就順便把tmp補完\n","keywords":["C/C++"],"articleBody":"動機 一切的開始，只是想要個reversed而已，就順便把tmp補完\ntips when using template 別用float 因為浮點數的結果不一致\nfunc\u003c1/3.f\u003e (); func\u003c2/6.f\u003e (); header 原本函數的宣告與實作會分成header與source code，但是template的code不能放在source code中。\n因為compiler要先看有template的code，之後才能填充type，在生出真正的code，專業一點叫 實體化(instantiation)\nsome tools constexpr const int SOME_INT_WILL_NOT_BE_MODIFIED = some_func(); constexpr int INT_IS_COMPUTED_IN_COMPILCATION = 1 + 5; // #define MACRO_INT 1 + 5 // 這只是會展開成 1+5但不會算成6，但constexpr會，同時template可以拿到他 constexpr int foo(int i) { return i + 5; } int main() { int i = 10; std::array\u003cint, foo(5)\u003e arr; // OK // as if 5 + 5, and computed in complication foo(i); // Call is Ok // This is usual function // But... std::array\u003cint, foo(i)\u003e arr1; // Error // Compiler cant know what the value is foo(i), cuz i is determinated in run-time } using typedef int A; // \u003c=\u003e int typedef A; // \u003c=\u003e using A = int; decltype struct A { double x; }; const A* a; decltype(a-\u003ex) y; // type of y is double (declared type) decltype((a-\u003ex)) z = y; // type of z is const double\u0026 (lvalue expression) typename 把typename後面的東西當成type來看\nfunction only with types 只要type對了就好\nvoid f(int,char[0]) { std::cout \u003c\u003c \"only types\\n\"; } char wtf[0]; f(10,NULL), f(123,wtf); Template specialization template的參數先填掉 template\u003cint n\u003e struct fact { enum { val = n*fact\u003cn-1\u003e::val }; }; template\u003c\u003e struct fact\u003c0\u003e { enum { val = 1 }; }; 0是誰? 0可以當成 整數 null ptr bool的false compiler自己推type template\u003ctypename T\u003e T id(T x) { return x; } int main(int argc, char *argv[]) { std::cout \u003c\u003c id(123) \u003c\u003c ',' \u003c\u003c id(\"123\") \u003c\u003c '\\n'; } basic (很像functional programming) fact template\u003cint n\u003e struct fact { enum { val = n*fact\u003cn-1\u003e::val }; }; template\u003c\u003e struct fact\u003c0\u003e { enum { val = 1 }; }; int main() { //cout \u003c\u003c Min::val \u003c\u003c endl; //下面的 cout \u003c\u003c fact\u003c10\u003e::val \u003c\u003c endl; } Min 目標: Min::val拿到1\n宣告 template\u003ctypename T, T ...\u003e // T...是type，像是va_list struct Min; case1: 如果有不只一個數字 template\u003ctypename T, T v,T ... args\u003e // typename就是說這是一個type struct Min\u003cT,v,args\u003e { // 要填\u003c...\u003e符合原本的宣告 // destruct pack //constexpr static auto val = min(v, hi::val); enum { val = (v \u003c (Min\u003cT, args...\u003e::val) ? v : (Min\u003cT, args...\u003e::val) }; // Min::val 就是遞迴剩下的部分 case2: 如果只有一個數字 template\u003ctypename T, T v\u003e struct Min\u003cT,v\u003e { enum { val = v }; }; turing-complete template是turing-complete，可以用template來實做lambda calculus 也不意外，template的參數帶入就是lambda calculus的beta reduction\n詳細的說明blog\ncode\nSolution to Exercise template \u003ctypename A, typename B\u003e struct add {}; template \u003ctypename A_s, typename B\u003e struct add\u003cSucc\u003cA_s\u003e, B\u003e { enum { value = 1+add\u003cA_s,B\u003e::value }; }; template \u003ctypename B\u003e struct add\u003cZero, B\u003e { enum { value = B::value }; }; template \u003ctypename lhs, typename rhs\u003e struct Add {}; template \u003ctypename Lhs, typename Rhs, typename Env\u003e struct Eval\u003cAdd\u003cLhs, Rhs\u003e , Env\u003e { typename Apply\u003cAdd\u003ctypename Eval\u003cLhs,Env\u003e :: result , typename Eval\u003cRhs,Env\u003e :: result \u003e, Zero\u003e :: result typedef result ; } ; template \u003ctypename N, typename M\u003e struct Apply\u003cAdd\u003cN, M\u003e, Zero\u003e { add\u003cN,M\u003e typedef result ; } ; trait 可以理解成type的interface，描述這個type會在編譯期這個type有什麼屬性\n那怎麼描述(寫下)有這些屬性?\n寫到定義中 (這比較像type屬性的getter) template \u003ctypename Iterator\u003e struct iterator_traits { using value_type = typename Iterator::value_type; using pointer = typename Iterator::pointer; using const_pointer = typename Iterator::const_pointer; using reference = typename Iterator::reference; using const_reference = typename Iterator::const_reference; using rvalue_reference = typename Iterator::rvalue_reference; using iterator_category = typename Iterator::iterator_category; }; template \u003ctypename T\u003e class vector_iterator { public: using value_type = T; using pointer = T *; using const_pointer = const T *; using reference = T \u0026; using const_reference = const T \u0026; using rvalue_reference = T \u0026\u0026; using iterator_category = std::random_access_iterator_tag; //... }; 特化 (這比較像描述一個type) template \u003ctypename Iterator\u003e struct iterator_traits {}; template \u003ctypename T\u003e struct iterator_traits\u003cvector_iterator\u003cT\u003e\u003e { using value_type = T; using pointer = T*; using const_pointer = const T *; using reference = T \u0026; using const_reference = const T \u0026; using rvalue_reference = const T \u0026; using iterator_category = std::random_access_iterator_tag; }; SFINAE 就是compiler怎麼淘汰候選人的過程\n整個過程是有同樣名字的struct或是function都選出來，分別一個一個帶入，保留沒出事的，最後只剩下一個就用他\n最頭痛的是有同樣名字的struct或是function都選出來，分別一個一個帶入\n這樣子變成要確保沒每個template涵蓋到的部分不能與其他的宣告重疊，故個寫起來的感覺是\nif n == 1: return 'hi' if n != 1: return 'wow' 不能像\nif n == 1: return 'hi' else: return 'wow' 簡而言之， 我們沒有failover的宣告，每個都要描寫出來，n為一，n不為一， 不能是 n為一，其他\n要怎麼讓compiler淘汰候選人? 在\ntemplate列表 (template那一行) 特殊化列表 (function或是struct旁邊的角括號) 參數列表 (function的參數列表) 搞出奇怪的東西，像存取不存在的屬性、長度為零的array等等\n詳細的case見這裡 還有可以看看type_traits.hpp怎麼實作那些神奇的traits\n用enable_if試試看 enable_if會吃一個條件式，如果true吐一個type，如果false就會整個壞掉\n下面用enable_if來寫一個判斷int的函數\nf_if_integral_weak f_if_integral_weak沒辦法推出參數在此的type，故報錯\n如果要過，就要自己補type\n#include #include template \u003cbool, typename\u003e struct enable_if; template \u003ctypename T\u003e struct enable_if\u003ctrue, T\u003e { using type = T; }; template \u003ctypename T\u003e struct is_int { constexpr static inline auto value {false}; }; template \u003c\u003e struct is_int\u003cint\u003e { constexpr static inline auto value {true}; }; template \u003ctypename T\u003e void f_if_integral_weak(typename enable_if\u003cis_int\u003cT\u003e::value, T\u003e::type) { std::cout \u003c\u003c \"a: is int\\n\"; } int main(int argc, char *argv[]) { f_if_integral_weak\u003cint\u003e(10); //f_if_integral_weak(0); // 0是誰? //f_if_integral_weak(0.0); // 沒有type f_if_integral_weak\u003cint\u003e(0); } f_if_integral_strong 手動打type在此蠻沒意義的，所以試著讓compiler自己推，原本的enable_if用預設參數補\n#include #include template \u003cbool, typename\u003e struct enable_if; template \u003ctypename T\u003e struct enable_if\u003ctrue, T\u003e { using type = T; }; template \u003ctypename T\u003e struct is_int { constexpr static inline auto value {false}; }; template \u003c\u003e struct is_int\u003cint\u003e { constexpr static inline auto value {true}; }; template \u003ctypename T\u003e void f_if_integral_strong(T, typename enable_if\u003cis_int\u003cT\u003e::value, T\u003e::type* = 0) { std::cout \u003c\u003c \"b: is int\\n\"; } int main(int argc, char *argv[]) { f_if_integral_strong(0); //f_if_integral_strong(0.0); // 沒有type阿 } f_if_integral_stronger 為什麼不用typename enable_if\u003c!is_int::value, T\u003e::type來加不是int的case? 因為typename enable_if\u003c!is_int::value, T\u003e::type與typename enable_if","wordCount":"1181","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2020-12-19T02:35:50Z","dateModified":"2020-12-19T02:35:50Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2020/12/c-template-meta-programming%E7%AD%86%E8%A8%98/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ template meta-programming筆記</h1><div class=post-meta><span title='2020-12-19 02:35:50 +0000 UTC'>December 19, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#tips-when-using-template aria-label="tips when using template">tips when using template</a><ul><li><a href=#%e5%88%a5%e7%94%a8float aria-label=別用float>別用float</a></li><li><a href=#header aria-label=header>header</a></li></ul></li><li><a href=#some-tools aria-label="some tools">some tools</a></li><li><a href=#basic-%e5%be%88%e5%83%8ffunctional-programming aria-label="basic (很像functional programming)">basic (很像functional programming)</a><ul><li><a href=#fact aria-label=fact>fact</a></li><li><a href=#min aria-label=Min>Min</a></li><li><a href=#turing-complete aria-label=turing-complete>turing-complete</a></li><li><a href=#solution-to-exercise aria-label="Solution to Exercise">Solution to Exercise</a></li><li><a href=#trait aria-label=trait>trait</a></li></ul></li><li><a href=#sfinae aria-label=SFINAE>SFINAE</a><ul><li><a href=#%e8%a6%81%e6%80%8e%e9%ba%bc%e8%ae%93compiler%e6%b7%98%e6%b1%b0%e5%80%99%e9%81%b8%e4%ba%ba aria-label=要怎麼讓compiler淘汰候選人?>要怎麼讓compiler淘汰候選人?</a></li><li><a href=#%e7%94%a8enable_if%e8%a9%a6%e8%a9%a6%e7%9c%8b aria-label=用enable_if試試看>用enable_if試試看</a><ul><li><a href=#f_if_integral_weak aria-label=f_if_integral_weak>f_if_integral_weak</a></li><li><a href=#f_if_integral_strong aria-label=f_if_integral_strong>f_if_integral_strong</a></li><li><a href=#f_if_integral_stronger aria-label=f_if_integral_stronger>f_if_integral_stronger</a></li><li><a href=#%e5%85%b6%e5%af%a6%e5%8f%af%e4%bb%a5%e7%b0%a1%e5%96%ae%e4%b8%80%e9%bb%9e aria-label=其實可以簡單一點>其實可以簡單一點</a></li></ul></li><li><a href=#and_in_template aria-label=and_in_template>and_in_template</a></li></ul></li><li><a href=#concept aria-label=concept>concept</a></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>一切的<a href=https://stackoverflow.com/questions/8542591/c11-reverse-range-based-for-loop>開始</a>，只是想要個reversed而已，就順便把tmp補完</p><h2 id=tips-when-using-template>tips when using template<a hidden class=anchor aria-hidden=true href=#tips-when-using-template>#</a></h2><h3 id=別用float>別用float<a hidden class=anchor aria-hidden=true href=#別用float>#</a></h3><p>因為浮點數的結果不一致</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>func</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>/</span><span class=mf>3.f</span><span class=o>&gt;</span> <span class=p>();</span> 
</span></span><span class=line><span class=cl><span class=n>func</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>/</span><span class=mf>6.f</span><span class=o>&gt;</span> <span class=p>();</span>
</span></span></code></pre></div><h3 id=header>header<a hidden class=anchor aria-hidden=true href=#header>#</a></h3><p>原本函數的宣告與實作會分成header與source code，但是template的code不能放在source code中。</p><p>因為compiler要先看有template的code，之後才能填充type，在生出真正的code，專業一點叫 實體化(instantiation)</p><h2 id=some-tools>some tools<a hidden class=anchor aria-hidden=true href=#some-tools>#</a></h2><ul><li>constexpr</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>SOME_INT_WILL_NOT_BE_MODIFIED</span> <span class=o>=</span> <span class=n>some_func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>INT_IS_COMPUTED_IN_COMPILCATION</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// #define MACRO_INT 1 + 5
</span></span></span><span class=line><span class=cl><span class=c1>// 這只是會展開成 1+5但不會算成6，但constexpr會，同時template可以拿到他
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>foo</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>arr</span><span class=p>;</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// as if 5 + 5, and computed in complication
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>foo</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// Call is Ok
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This is usual function
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// But...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>foo</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>arr1</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Compiler cant know what the value is foo(i), cuz i is determinated in run-time
</span></span></span><span class=line><span class=cl><span class=c1></span>   
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>using</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// &lt;=&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=k>typedef</span> <span class=n>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// &lt;=&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>A</span> <span class=o>=</span> <span class=kt>int</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>decltype</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span> <span class=kt>double</span> <span class=n>x</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>A</span><span class=o>*</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>decltype</span><span class=p>(</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>)</span> <span class=n>y</span><span class=p>;</span>       <span class=c1>// type of y is double (declared type)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>((</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>))</span> <span class=n>z</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span> <span class=c1>// type of z is const double&amp; (lvalue expression)
</span></span></span></code></pre></div><ul><li><p>typename
把typename後面的東西當成type來看</p></li><li><p>function only with types
只要type對了就好</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>char</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;only types</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>wtf</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=nb>NULL</span><span class=p>),</span> <span class=n>f</span><span class=p>(</span><span class=mi>123</span><span class=p>,</span><span class=n>wtf</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>Template specialization
template的參數先填掉</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=kt>int</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>fact</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=p>{</span> <span class=n>val</span> <span class=o>=</span> <span class=n>n</span><span class=o>*</span><span class=n>fact</span><span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;::</span><span class=n>val</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>fact</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=p>{</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>0是誰?
0可以當成</li></ul><ol><li>整數</li><li>null ptr</li><li>bool的false</li></ol><ul><li>compiler自己推type</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>id</span><span class=p>(</span><span class=n>T</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>id</span><span class=p>(</span><span class=mi>123</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;,&#39;</span> <span class=o>&lt;&lt;</span> <span class=n>id</span><span class=p>(</span><span class=s>&#34;123&#34;</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=basic-很像functional-programming>basic (很像functional programming)<a hidden class=anchor aria-hidden=true href=#basic-很像functional-programming>#</a></h2><h3 id=fact>fact<a hidden class=anchor aria-hidden=true href=#fact>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=kt>int</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>fact</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=p>{</span> <span class=n>val</span> <span class=o>=</span> <span class=n>n</span><span class=o>*</span><span class=n>fact</span><span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;::</span><span class=n>val</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>fact</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=p>{</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//cout &lt;&lt; Min&lt;int, 1,2,3,4&gt;::val &lt;&lt; endl; //下面的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>fact</span><span class=o>&lt;</span><span class=mi>10</span><span class=o>&gt;::</span><span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=min>Min<a hidden class=anchor aria-hidden=true href=#min>#</a></h3><p>目標: <code>Min&lt;int, 1,2,3,4>::val</code>拿到1</p><ol><li>宣告</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>T</span> <span class=p>...</span><span class=o>&gt;</span> <span class=c1>// T...是type，像是va_list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Min</span><span class=p>;</span>
</span></span></code></pre></div><ol start=2><li>case1: 如果有不只一個數字</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>T</span> <span class=n>v</span><span class=p>,</span><span class=n>T</span> <span class=p>...</span> <span class=n>args</span><span class=o>&gt;</span> <span class=c1>// typename就是說這是一個type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Min</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=n>v</span><span class=p>,</span><span class=n>args</span><span class=o>&gt;</span> <span class=p>{</span> <span class=c1>// 要填&lt;...&gt;符合原本的宣告 // destruct pack
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//constexpr static auto val = min(v, hi&lt;T, args...&gt;::val);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>enum</span> <span class=p>{</span> <span class=n>val</span> <span class=o>=</span> <span class=p>(</span><span class=n>v</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>Min</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>args</span><span class=p>...</span><span class=o>&gt;::</span><span class=n>val</span><span class=p>)</span> <span class=o>?</span> <span class=nl>v</span> <span class=p>:</span> <span class=p>(</span><span class=n>Min</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>args</span><span class=p>...</span><span class=o>&gt;::</span><span class=n>val</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Min&lt;T, args...&gt;::val 就是遞迴剩下的部分
</span></span></span></code></pre></div><ol start=3><li>case2: 如果只有一個數字</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>T</span> <span class=n>v</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Min</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=n>v</span><span class=o>&gt;</span> <span class=p>{</span> <span class=k>enum</span> <span class=p>{</span> <span class=n>val</span> <span class=o>=</span> <span class=n>v</span> <span class=p>};</span> <span class=p>};</span>
</span></span></code></pre></div><h3 id=turing-complete>turing-complete<a hidden class=anchor aria-hidden=true href=#turing-complete>#</a></h3><p>template是turing-complete，可以用template來實做lambda calculus
也不意外，template的參數帶入就是lambda calculus的beta reduction</p><p>詳細的說明<a href=http://matt.might.net/articles/c++-template-meta-programming-with-lambda-calculus/>blog</a></p><p><a href=http://matt.might.net/articles/c++-template-meta-programming-with-lambda-calculus/code/lambda-calculus-in-templates.cpp>code</a></p><h3 id=solution-to-exercise>Solution to Exercise<a hidden class=anchor aria-hidden=true href=#solution-to-exercise>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span> <span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>add</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>A_s</span><span class=p>,</span> <span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>add</span><span class=o>&lt;</span><span class=n>Succ</span><span class=o>&lt;</span><span class=n>A_s</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>B</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>enum</span> <span class=p>{</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>1</span><span class=o>+</span><span class=n>add</span><span class=o>&lt;</span><span class=n>A_s</span><span class=p>,</span><span class=n>B</span><span class=o>&gt;::</span><span class=n>value</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>add</span><span class=o>&lt;</span><span class=n>Zero</span><span class=p>,</span> <span class=n>B</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>enum</span> <span class=p>{</span> <span class=n>value</span> <span class=o>=</span> <span class=n>B</span><span class=o>::</span><span class=n>value</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>lhs</span><span class=p>,</span> <span class=k>typename</span> <span class=n>rhs</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Add</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Lhs</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Rhs</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Env</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Eval</span><span class=o>&lt;</span><span class=n>Add</span><span class=o>&lt;</span><span class=n>Lhs</span><span class=p>,</span> <span class=n>Rhs</span><span class=o>&gt;</span> <span class=p>,</span> <span class=n>Env</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>typename</span> <span class=n>Apply</span><span class=o>&lt;</span><span class=n>Add</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Eval</span><span class=o>&lt;</span><span class=n>Lhs</span><span class=p>,</span><span class=n>Env</span><span class=o>&gt;</span> <span class=o>::</span> <span class=n>result</span> <span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>typename</span> <span class=n>Eval</span><span class=o>&lt;</span><span class=n>Rhs</span><span class=p>,</span><span class=n>Env</span><span class=o>&gt;</span> <span class=o>::</span> <span class=n>result</span> <span class=o>&gt;</span><span class=p>,</span> <span class=n>Zero</span><span class=o>&gt;</span> <span class=o>::</span> <span class=n>result</span> 
</span></span><span class=line><span class=cl>           <span class=k>typedef</span> <span class=n>result</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>N</span><span class=p>,</span> <span class=k>typename</span> <span class=n>M</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Apply</span><span class=o>&lt;</span><span class=n>Add</span><span class=o>&lt;</span><span class=n>N</span><span class=p>,</span> <span class=n>M</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>Zero</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>add</span><span class=o>&lt;</span><span class=n>N</span><span class=p>,</span><span class=n>M</span><span class=o>&gt;</span> <span class=k>typedef</span> <span class=n>result</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>;</span>
</span></span></code></pre></div><h3 id=trait>trait<a hidden class=anchor aria-hidden=true href=#trait>#</a></h3><p>可以理解成type的interface，描述這個type會在編譯期這個type有什麼屬性</p><p>那怎麼描述(寫下)有這些屬性?</p><ol><li>寫到定義中 (這比較像type屬性的getter)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Iterator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>iterator_traits</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>value_type</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Iterator</span><span class=o>::</span><span class=n>value_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>pointer</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Iterator</span><span class=o>::</span><span class=n>pointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>const_pointer</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Iterator</span><span class=o>::</span><span class=n>const_pointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>reference</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Iterator</span><span class=o>::</span><span class=n>reference</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>const_reference</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Iterator</span><span class=o>::</span><span class=n>const_reference</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>rvalue_reference</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Iterator</span><span class=o>::</span><span class=n>rvalue_reference</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>iterator_category</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Iterator</span><span class=o>::</span><span class=n>iterator_category</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>vector_iterator</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>value_type</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>pointer</span> <span class=o>=</span> <span class=n>T</span> <span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>const_pointer</span> <span class=o>=</span> <span class=k>const</span> <span class=n>T</span> <span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>reference</span> <span class=o>=</span> <span class=n>T</span> <span class=o>&amp;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>const_reference</span> <span class=o>=</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>rvalue_reference</span> <span class=o>=</span> <span class=n>T</span> <span class=o>&amp;&amp;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>iterator_category</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>random_access_iterator_tag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ol start=2><li>特化 (這比較像描述一個type)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Iterator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>iterator_traits</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>iterator_traits</span><span class=o>&lt;</span><span class=n>vector_iterator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>value_type</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>pointer</span> <span class=o>=</span> <span class=n>T</span><span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>const_pointer</span> <span class=o>=</span> <span class=k>const</span> <span class=n>T</span> <span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>reference</span> <span class=o>=</span> <span class=n>T</span> <span class=o>&amp;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>const_reference</span> <span class=o>=</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>rvalue_reference</span> <span class=o>=</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>iterator_category</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>random_access_iterator_tag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=sfinae>SFINAE<a hidden class=anchor aria-hidden=true href=#sfinae>#</a></h2><p>就是compiler怎麼淘汰候選人的過程</p><p>整個過程是有同樣名字的struct或是function都選出來，分別一個一個帶入，保留沒出事的，最後只剩下一個就用他</p><p>最頭痛的是<strong>有同樣名字的struct或是function都選出來，分別一個一個帶入</strong></p><p>這樣子變成要確保沒每個template涵蓋到的部分不能與其他的宣告重疊，故個寫起來的感覺是</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;hi&#39;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>n</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;wow&#39;</span> 
</span></span></code></pre></div><p>不能像</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;hi&#39;</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;wow&#39;</span>
</span></span></code></pre></div><p>簡而言之，
我們沒有failover的宣告，每個都要描寫出來，n為一，n不為一，
不能是 n為一，其他</p><h3 id=要怎麼讓compiler淘汰候選人>要怎麼讓compiler淘汰候選人?<a hidden class=anchor aria-hidden=true href=#要怎麼讓compiler淘汰候選人>#</a></h3><p>在</p><ul><li>template列表 (template那一行)</li><li>特殊化列表 (function或是struct旁邊的角括號)</li><li>參數列表 (function的參數列表)</li></ul><p>搞出奇怪的東西，像存取不存在的屬性、長度為零的array等等</p><p>詳細的case見<a href=https://en.cppreference.com/w/cpp/language/sfinae>這裡</a>
還有可以看看type_traits.hpp怎麼實作那些神奇的traits</p><h3 id=用enable_if試試看>用enable_if試試看<a hidden class=anchor aria-hidden=true href=#用enable_if試試看>#</a></h3><p>enable_if會吃一個條件式，如果true吐一個type，如果false就會整個壞掉</p><p>下面用enable_if來寫一個判斷int的函數</p><h4 id=f_if_integral_weak>f_if_integral_weak<a hidden class=anchor aria-hidden=true href=#f_if_integral_weak>#</a></h4><p><code>f_if_integral_weak</code>沒辦法推出參數在此的type，故報錯</p><p>如果要過，就要自己補type</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;type_traits&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>bool</span><span class=p>,</span> <span class=k>typename</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>enable_if</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>enable_if</span><span class=o>&lt;</span><span class=nb>true</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>is_int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>constexpr</span> <span class=k>static</span> <span class=kr>inline</span> <span class=k>auto</span> <span class=n>value</span> <span class=p>{</span><span class=nb>false</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>is_int</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>constexpr</span> <span class=k>static</span> <span class=kr>inline</span> <span class=k>auto</span> <span class=n>value</span> <span class=p>{</span><span class=nb>true</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f_if_integral_weak</span><span class=p>(</span><span class=k>typename</span> <span class=n>enable_if</span><span class=o>&lt;</span><span class=n>is_int</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a: is int</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>f_if_integral_weak</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//f_if_integral_weak(0); // 0是誰?
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//f_if_integral_weak(0.0); // 沒有type
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>f_if_integral_weak</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=f_if_integral_strong>f_if_integral_strong<a hidden class=anchor aria-hidden=true href=#f_if_integral_strong>#</a></h4><p>手動打type在此蠻沒意義的，所以試著讓compiler自己推，原本的enable_if用預設參數補</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;type_traits&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>bool</span><span class=p>,</span> <span class=k>typename</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>enable_if</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>enable_if</span><span class=o>&lt;</span><span class=nb>true</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>is_int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>constexpr</span> <span class=k>static</span> <span class=kr>inline</span> <span class=k>auto</span> <span class=n>value</span> <span class=p>{</span><span class=nb>false</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>is_int</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>constexpr</span> <span class=k>static</span> <span class=kr>inline</span> <span class=k>auto</span> <span class=n>value</span> <span class=p>{</span><span class=nb>true</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f_if_integral_strong</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>enable_if</span><span class=o>&lt;</span><span class=n>is_int</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>*</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;b: is int</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>f_if_integral_strong</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//f_if_integral_strong(0.0); // 沒有type阿
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=f_if_integral_stronger>f_if_integral_stronger<a hidden class=anchor aria-hidden=true href=#f_if_integral_stronger>#</a></h4><p>為什麼不用<code>typename enable_if&lt;!is_int&lt;T>::value, T>::type</code>來加不是int的case?
因為<code>typename enable_if&lt;!is_int&lt;T>::value, T>::type</code>與<code>typename enable_if&lt;is_int&lt;T>::value, T>::type</code>最後推出來的type是一樣的
這樣compiler分不出來!!</p><p>但可以把另一個case放到別的地方，來區分兩個case</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;type_traits&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>bool</span><span class=p>,</span> <span class=k>typename</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>enable_if</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>enable_if</span><span class=o>&lt;</span><span class=nb>true</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>is_int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>constexpr</span> <span class=k>static</span> <span class=kr>inline</span> <span class=k>auto</span> <span class=n>value</span> <span class=p>{</span><span class=nb>false</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>is_int</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>constexpr</span> <span class=k>static</span> <span class=kr>inline</span> <span class=k>auto</span> <span class=n>value</span> <span class=p>{</span><span class=nb>true</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>enable_if</span><span class=o>&lt;</span><span class=n>is_int</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span> <span class=n>T</span><span class=o>*&gt;::</span><span class=n>type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f_if_integral_stronger</span><span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;c: is int</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f_if_integral_stronger</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>enable_if</span><span class=o>&lt;!</span><span class=n>is_int</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>*</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;c: not int</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>f_if_integral_stronger</span><span class=p>(</span><span class=mf>0.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>f_if_integral_stronger</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=其實可以簡單一點>其實可以簡單一點<a hidden class=anchor aria-hidden=true href=#其實可以簡單一點>#</a></h4><p>用特別化就好</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;not int</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;is int</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>(</span><span class=mf>1.1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>(</span><span class=s>&#34;1234&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=and_in_template>and_in_template<a hidden class=anchor aria-hidden=true href=#and_in_template>#</a></h3><p>這裡模擬<code>&&</code>，但要怎麼判斷true與false?</p><p>有沒有壞掉!!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;type_traits&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=p>...</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>and_in_template</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=kt>void</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>S</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>has_A_B</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=k>typename</span> <span class=n>and_in_template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>S</span><span class=o>::</span><span class=n>A</span><span class=p>,</span> <span class=k>typename</span> <span class=n>S</span><span class=o>::</span><span class=n>B</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>*</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;get it</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Ans</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=nc>A</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=nc>B</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Ans</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>has_A_B</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=concept>concept<a hidden class=anchor aria-hidden=true href=#concept>#</a></h2><p>C++20的東西，可以對type的要求寫下來成為concept</p><p>之後就可以用require搭配其他concept一起用，</p><ol><li>Conjunction (AND)</li><li>Disjunction (OR)</li></ol><p>有一個名詞是<strong>Atomic constraint</strong>，其實就是會回傳bool的type_trait，只是原本type_trait要自己訂欄位放結果，但concept可以直接return</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>S</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=k>operator</span> <span class=nf>bool</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>requires</span> <span class=p>(</span><span class=n>S</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
</span></span></code></pre></div><p>所以concept其實就是使用SFINAE的template程式碼的語法糖?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>concept</span> <span class=n>Hashable</span> <span class=o>=</span> <span class=k>requires</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>.</span><span class=n>keep_walking</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>hash</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>{}(</span><span class=n>a</span><span class=p>)</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>convertible_to</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>meow</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>Hashable</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=p>);</span> <span class=c1>// constrained C++20 function template
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl><span class=c1>// Alternative ways to apply the same constraint:
</span></span></span><span class=line><span class=cl><span class=c1>// template&lt;typename T&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//    requires Hashable&lt;T&gt;
</span></span></span><span class=line><span class=cl><span class=c1>// void f(T); 
</span></span></span><span class=line><span class=cl><span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1>// template&lt;typename T&gt;
</span></span></span><span class=line><span class=cl><span class=c1>// void f(T) requires Hashable&lt;T&gt;; 
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=p>(</span><span class=s>&#34;abc&#34;</span><span class=p>);</span> <span class=c1>// OK, std::string satisfies Hashable
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>f</span><span class=p>(</span><span class=n>meow</span><span class=p>{});</span> <span class=c1>// Error: meow does not satisfy Hashable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://www.modernescpp.com/index.php/c-core-guidelines-rules-for-template-metaprogramming>C++ Core Guidelines: Rules for Template Metaprogramming</a>
<a href=https://jonny.vip/2019/03/27/%e3%80%90cplusplus-template-meta-programming%e3%80%91%e8%aa%8d%e8%ad%98%e6%a8%a3%e6%9d%bf%e8%b6%85%e7%b7%a8%e7%a8%8b/>【C++ Template Meta-Programming】認識樣板超編程 (TMP)</a></p><p><a href=https://zh.wikipedia.org/wiki/Decltype>decltype</a></p><p><a href=https://jonny.vip/2019/05/25/%e3%80%90cplusplus-template-meta-programming%e3%80%91%e5%be%9e%e9%81%8e%e7%a8%8b%e5%bc%8f%e7%a8%8b%e5%bc%8f%e8%a8%ad%e8%a8%88%e8%aa%8d%e8%ad%98%e6%a8%a3%e6%9d%bf%e8%b6%85%e7%b7%a8%e7%a8%8b/>【C++ Template Meta-Programming】參數列表</a></p><p><a href=http://matt.might.net/articles/c++-template-meta-programming-with-lambda-calculus/>C++ templates: Creating a compile-time higher-order meta-programming language</a></p><p><a href=https://stackoverflow.com/questions/2183087/why-cant-i-use-float-value-as-a-template-parameter>Why can&rsquo;t I use float value as a template parameter?</a>
<a href=https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file>Why can templates only be implemented in the header file?</a>
<a href=https://stackoverflow.com/questions/3040480/c-template-function-compiles-in-header-but-not-implementation>C++ template function compiles in header but not implementation</a></p><p><a href=https://blog.csdn.net/lihao21/article/details/55043881>细说 C++ Traits Classes</a>
<a href=https://jonny.vip/2019/07/16/%E3%80%90cplusplus-template-meta-programming%E3%80%91traits-%E6%8A%80%E5%B7%A7/>【C++ Template Meta-Programming】Traits 技巧</a>
<a href=https://www.bogotobogo.com/cplusplus/template_specialization_traits.php>C++ TUTORIAL - TRAITS : A TEMPLATE SPECIALIZATION - 2020</a></p><p><a href=https://en.cppreference.com/w/cpp/language/sfinae>SFINAE</a>
<a href=https://sodocumentation.net/zh-TW/cplusplus/topic/1169/sfinae-%E6%9B%BF%E6%8F%9B%E5%A4%B1%E6%95%97%E4%B8%8D%E6%98%AF%E9%8C%AF%E8%AA%A4->SFINAE（替換失敗不是錯誤）</a>
<a href=http://twtedlin31.blogspot.com/2016/03/sfinae.html>認識SFINAE</a>
<a href=https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error>Substitution failure is not an error</a>
<a href=https://jonny.vip/2019/08/27/%e3%80%90cplusplus-template-meta-programming%e3%80%91%e5%87%bd%e5%bc%8f%e5%a4%9a%e8%bc%89%e8%88%87-sfinae-%e5%88%9d%e6%ad%a5/>【C++ Template Meta-Programming】函式多載與 SFINAE 初步</a>
<a href=https://jonny.vip/2020/01/09/%e3%80%90cplusplus-template-meta-programming%e3%80%91sfinae/>【C++ Template Meta-Programming】SFINAE</a>
<a href=https://jonny.vip/2020/08/01/%e3%80%90cplusplus-template-meta-programming%e3%80%91%e5%88%b0%e8%99%95-sfinae/>【C++ Template Meta-Programming】到處 SFINAE</a></p><p><a href=https://zhuanlan.zhihu.com/p/23290464>说说 C++ 的 Concept</a>
<a href=https://en.cppreference.com/w/cpp/language/constraints>Constraints and concepts (since C++20)</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/c/c++/>C/C++</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2020/12/c/c-%E7%9A%84faq/><span class=title>« Prev</span><br><span>C/C++的FAQ</span>
</a><a class=next href=https://littlebees.github.io/2020/12/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E8%88%87two-pointer/><span class=title>Next »</span><br><span>二分搜尋與two pointer</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>