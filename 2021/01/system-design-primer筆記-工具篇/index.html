<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>system design primer筆記 工具篇 | 記事本</title>
<meta name=keywords content="System Design"><meta name=description content="動機
會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料
結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣
所以來整理一下，作為了解的開始
這篇是介紹會用到的工具，接下來是設計
但設計還要帶一下估計的方法與常用數字
所以之後還有兩篇要整理"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E5%B7%A5%E5%85%B7%E7%AF%87/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E5%B7%A5%E5%85%B7%E7%AF%87/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="system design primer筆記 工具篇"><meta property="og:description" content="動機
會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料
結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣
所以來整理一下，作為了解的開始
這篇是介紹會用到的工具，接下來是設計
但設計還要帶一下估計的方法與常用數字
所以之後還有兩篇要整理"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E5%B7%A5%E5%85%B7%E7%AF%87/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-07T00:46:39+00:00"><meta property="article:modified_time" content="2021-01-07T00:46:39+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="system design primer筆記 工具篇"><meta name=twitter:description content="動機
會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料
結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣
所以來整理一下，作為了解的開始
這篇是介紹會用到的工具，接下來是設計
但設計還要帶一下估計的方法與常用數字
所以之後還有兩篇要整理"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"system design primer筆記 工具篇","item":"https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E5%B7%A5%E5%85%B7%E7%AF%87/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"system design primer筆記 工具篇","name":"system design primer筆記 工具篇","description":"動機 會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料\n結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣\n所以來整理一下，作為了解的開始\n這篇是介紹會用到的工具，接下來是設計 但設計還要帶一下估計的方法與常用數字\n所以之後還有兩篇要整理\n","keywords":["System Design"],"articleBody":"動機 會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料\n結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣\n所以來整理一下，作為了解的開始\n這篇是介紹會用到的工具，接下來是設計 但設計還要帶一下估計的方法與常用數字\n所以之後還有兩篇要整理\n取捨 效能 vs 可擴展性 效能: 服務更多的工作單元，也可以處理更多的資料 性能問題: 對單一使用者來說的感覺是慢的 可擴展性: 服務性能的增加和資源的投入是成正比 可擴展性問題: 對於單一使用者來說感覺較快，但在高負載的時候就會變慢 延遲 vs 吞吐量 延遲: 執行一個操作或運算結果所花費的時間 吞吐量: 單位時間內執行此類型操作或運算的數量 可接受的延遲數量下的最大化吞吐量 為設計目標 可用性 vs 一致性 CAP 理論: 在一個分散式系統中，只能滿足以下三個項目的任兩項 一致性: 每次讀取都可以得到最新的資料，但偶爾會拿到錯誤 弱一致性 在寫入之後，任何的存取不一定可以拿到資料，弱一致性將盡力確保能存取到最新的資料 (錯過就沒了) 例子: 視訊聊天、藍芽耳機的延遲 最終一致性 在寫入後的讀取操作最終可以看到被寫入的資料資料透過非同步的方式被複製 例子: DNS、NoSQL (需要等一段時間傳播) 強一致性 在寫入後，讀取將立刻取得資料，資料是透過同步的方式寫入 例子: FileSystem、SQL 可用性: 每次讀取都可以得到非錯誤的回應，但不能保證可以得到最新的資料 容錯轉移 主動到備用切換 當 heartbeat 中斷時，備用的機器就會切換為主動機器的 IP 位置接替服務 只有處於主動的機器會處理使用者來的流量 雙主動切換 兩台伺服器都會負責處理流量 流量會在他們之間進行分散負載 缺點 load balancer或是服務需要知道這些主動的機器 缺點 增加額外的硬體與複雜度 如果在新寫入的資料被複製到備用的機器前系統就發生故障，那有可能會遺失資料 複寫 主動到備用複寫(主從複寫) 主資料庫負責讀和寫 將寫入的資料複寫至一或多個從屬資料庫中 從屬資料庫只負責讀取 從屬資料庫可以再將寫入複製到更多以樹狀結構的其他資料庫中 如果主資料庫離線了 系統可以以只讀模式運行，直到 某個從屬資料庫被提升為主資料庫 OR 新的主資料庫出現 雙主動複寫(主動模式複寫) 兩個主要的資料庫都負責讀取和寫入，並且兩者互相協調 如果主資料庫離線了，系統可以繼續運作 缺點 load balancer或是服務需要知道這些主動的機器，決定寫入哪台 大多數無法保證一致性(違反 ACID) 因同步而產生寫入延遲 隨著更多寫入節點的增加和延遲的提高，如何解決衝突變複雜 缺點 複製 上的問題 如果在主要資料庫複製到其他結點前系統就失效，則會有資料丟失的可能 多讀取節點的問題 當有過多寫入時，讀取的資料庫可能會因為過多寫入操作而被阻塞，導致讀取功能異常 當讀取的資料庫越多時，需要複寫的資料庫越多，將會導致較為嚴重的延遲 在某些資料庫系統中，寫入主資料庫的操作可以用多執行緒來並行寫入，但讀取的資料庫只支援單一執行緒來循序寫入 複雜度 複寫意味著更多的硬體以及更高的複雜度 部分容錯性: 在任意分區的網路故障情況下，系統仍然能夠持續運行 網路是不可靠的，你的設計必須要確保部分容錯性，所以你只能夠在一致性與可用性中做出取捨 CP: 一致性與部分容錯性 可能因超時而報錯 AP: 可用性與部分容錯性 都拿的到資料，但不一定是最新的 (拿到舊的不是錯誤) 工具 DNS NS, MX, CNAME, A record load balance Weighted round robin 基於延遲分流 基於地理位置分流 缺點 DNS的query會有延遲 DNS管理複雜 會被DDOS CDN 推送式 CDNs (callback) 當你的伺服器有檔案變動時，推送 CDN 會接收到新的變動內容 流量較小的網站，或是內容不是經常更新的網站使用推送式的 CDN 相當適合 可以設定檔案內容什麼時候過期以及何時更新，檔案內容只有在變更或新增的時候才會推送，最小化流量，但最大化儲存 拉取式 CDNs (on-demand) 當地一個使用者來請求該資源時，才從伺服器上抓取對應檔案 拉取式 CDN 可以節省儲存空間 在過期的文件被更新之前，則會導致多餘的流量 拉取式的 CDN 適合高流量的網站，因為檔案會被平均的分散在各個結點伺服器中 缺點 CDN 的成本取決於流量，可能會因為成本而放棄使用 如果在 TTL 過期之前就更新內容，CDN 的緩存內容可能會過期 需要改變靜態內容的網址來指向 CDN load balancer 分配方式 隨機 最少負載 Session/cookies Weighted round robin 第四層負載平衡 第四層的負載平衡器會監看 傳輸層 的資訊來決定如何分發請求 (5 tuple) 透過 網路地址轉換(NAT) 來向上游的伺服器轉發資料 第七層負載平衡 第七層的負載平衡器會監看 應用層 來決定如何分發請求這包含了請求的 header、訊息和 cookies (DPI) 第四層的負載平衡比起第七層的所要花費的時間和計算資源更低 水平擴展 缺點 水平擴展會增加複雜性，同時也涉及了多台伺服器的議題 快取伺服器或資料庫需要隨著伺服器的增加而進行擴展，以便處理更多的請求 好處 SSL Termination: 將傳入的請求解密，並且加密伺服器的回應 Session 保存: 發行 cookie，並將特定使用者的請求路由到同樣的後端伺服器上 缺點 當負載平衡器資源不夠或沒有正確設定時，他可能會成為效能的瓶頸 會增加架構的複雜性 只有一台負載平衡器時，一樣有單點失敗的問題 reversed proxy 好處 隱藏後端伺服器的資訊、可以設定 IP 的黑名單、限制每個客戶端的連線數量等 增加可擴展性與靈活性 - 客戶端只會看到反向代理伺服器的 IP 或域名 SSL 終止 - 解密傳入的請求、加密伺服器的回應，這樣後端伺服器就不需要進行這些高成本的操作 壓縮 - 壓縮伺服器的回應 快取 - 直接在代理伺服器回應命中快取的結果 缺點 引入反向代理伺服器會增加系統複雜度 只有一台反向代理伺服器會有單點失效的問題，而設定多台的反向代理伺服器(如 故障轉移 )同樣會增加系統複雜度 負載平衡器與反向代理 當有多台伺服器時，使用負載平衡非常有用，一般來說，負載平衡器會將流量路由給一組功能相同的伺服器上 即使只有一台伺服器或應用伺服器，反向代理也是有用的 container orchestration platform 微服務 可以獨立運作、小型的模組化服務每個服務會透過明確定義好的輕量級溝通機制，運作在一個獨立的流程中來共同實現一個目標 服務發現 透過註冊的名稱、位置、Port 等資訊來幫助各個服務發現彼此 Health checks 可以幫助確認服務的完整性以及是否經常使用一個 HTTP 的路徑 缺點 設計多個鬆耦合微服務所組成的應用層，必須從架構、維運、流程等多個面向來考量，相對於單系統而言會非常不同 微服務會增加部署與維運的複雜度 DB RDBMS(SQL) 特性: ACID 原子性 - 每一個資料庫事務操作要不就是全部完成，要不就是全部不完成 一致性 - 任何一個資料庫事務操作都會讓資料庫從一個有效的狀態轉換到另外一個有效狀態 隔離性 - 併發執行資料庫事務操作的結果會和循序執行的結果一致 持久性 - 一旦一個事務被資料庫執行後，他的結果與影響是擁永久保存的 複寫 見 CAP中的可用性的複寫 federative database 將資料庫按照對應的功能進行分割 好處 減少每個資料庫寫入與讀取的流量，進而降低複製的延遲 較少的資料意味者更多適合放入記憶體中的資料，進而增加快取命中率 因為沒有循序寫入的中央式主資料庫，你可以並行寫入以增加吞吐量 缺點 如果你的資料表需要大量的功能和資料表，聯邦式資料庫的效率並不好 需要更新應用程式的邏輯來決定如何讀取和寫入到哪個資料庫 透過 server link 從兩個資料庫中關資料更加複雜 聯邦式資料庫需要更多的硬體和額外的複雜度 Sharding 將資料分配在不同的資料庫上，使每個資料庫只管理整個資料的部分子集 好處 可以減少讀取和寫入的流量、減少複製並提高快取命中率 索引的容量也會減少，如此一來可以改善查詢的效能 當一個分片出現問題時，其餘的仍然可以正常運作 分片的機制並沒有中央式的資料庫，你可以並行寫入以增加吞吐量 缺點 為了避免資料遺失，你可能需要思考其他複寫的機制 你需要修改應用程式的邏輯來實作分片，這可能會導致 SQL 變得複雜 不合理的分片可能會導致資料負載不均 從多個分片中操作資料會很複雜 分片需要額外的硬體和複雜度 Denormalization 不同資料表中的重複資料來避免高成本的 Join 操作 好處 反正規化可以避免，如處理跨資料中心 Join 操作 資料會重複存取 Constraints 的機制可以讓重複的資料保持同步，但這樣會增加資料庫設計的複雜度 反正規化的資料庫在大量寫入負載的情況下，性能表現可能會比正規化的資料庫差 SQL Tuning improve schema use properly index index特性 設定索引時，會將資料放置於記憶體中，會佔用更多記憶體空間 索引通常是使用平衡 B 樹 表示，這樣可以保證資料是有序的，並允許在對數時間內進行搜尋、循序訪問以及插入、刪除等操作 SELECT, GROUP BY, ORDER BY, JOIN 中使用有index的欄位，來加速查詢 缺點 寫入操作會變慢，因為索引會需要更新 當讀取大量資料時，禁用索引再讀取，之後再重新建立索引 split table 將熱門的資料拆分到單獨的資料表中可以增加快取 avoid complex joining 反正規化 NoSQL 特性: BASE Basicly Avalibility: 系統保證可用性 Soft state: 系統的狀態可能隨著時間改變，即使在沒有輸入的情況下也是如此 eventually consistent - 經過一段時間之後，在沒有收到任何輸入的情況下，系統最終會達到一致 鍵-值對 (hash table) 通常用來儲存簡單的資料模型或是頻繁修改的資料 文件類型 (文件當做值的value的hash table) 文件類型的資料庫具備高度靈活性(不會看到一堆NULL)，通常用於處理偶爾變化的資料 列儲存型 (巢狀的 Map ColumnFamily","wordCount":"516","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-01-07T00:46:39Z","dateModified":"2021-01-07T00:46:39Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E5%B7%A5%E5%85%B7%E7%AF%87/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">system design primer筆記 工具篇</h1><div class=post-meta><span title='2021-01-07 00:46:39 +0000 UTC'>January 7, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#%e5%8f%96%e6%8d%a8 aria-label=取捨>取捨</a></li><li><a href=#%e5%b7%a5%e5%85%b7 aria-label=工具>工具</a></li><li><a href=#%e5%bf%ab%e5%8f%96 aria-label=快取>快取</a></li><li><a href=#%e9%9d%9e%e5%90%8c%e6%ad%a5%e6%a9%9f%e5%88%b6 aria-label=非同步機制>非同步機制</a></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>會知道system design primer是因為某場面試，原本以為system design在網路上沒有什麼資料</p><p>結果是很多資料，但是system design資料會多，很大一部分是system design包含的面向很廣</p><p>所以來整理一下，作為了解的開始</p><p>這篇是介紹會用到的工具，接下來是設計
但設計還要帶一下估計的方法與常用數字</p><p>所以之後還有兩篇要整理</p><h2 id=取捨>取捨<a hidden class=anchor aria-hidden=true href=#取捨>#</a></h2><ul><li>效能 vs 可擴展性<ul><li>效能: 服務更多的工作單元，也可以處理更多的資料<ul><li>性能問題: 對單一使用者來說的感覺是慢的</li></ul></li><li>可擴展性: 服務性能的增加和資源的投入是成正比<ul><li>可擴展性問題: 對於單一使用者來說感覺較快，但在高負載的時候就會變慢</li></ul></li></ul></li><li>延遲 vs 吞吐量<ul><li>延遲: 執行一個操作或運算結果所花費的時間</li><li>吞吐量: 單位時間內執行此類型操作或運算的數量</li><li>可接受的延遲數量下的最大化吞吐量 為設計目標</li></ul></li><li>可用性 vs 一致性<ul><li>CAP 理論: 在一個分散式系統中，只能滿足以下三個項目的任兩項<ul><li>一致性: 每次讀取都可以得到最新的資料，但偶爾會拿到錯誤<ul><li>弱一致性<ul><li>在寫入之後，任何的存取不一定可以拿到資料，弱一致性將盡力確保能存取到最新的資料 (錯過就沒了)</li><li>例子: 視訊聊天、藍芽耳機的延遲</li></ul></li><li>最終一致性<ul><li>在寫入後的讀取操作最終可以看到被寫入的資料資料透過<strong>非同步</strong>的方式被複製</li><li>例子: DNS、NoSQL (需要等一段時間傳播)</li></ul></li><li>強一致性<ul><li>在寫入後，讀取將立刻取得資料，資料是透過<strong>同步</strong>的方式寫入</li><li>例子: FileSystem、SQL</li></ul></li></ul></li><li>可用性: 每次讀取都可以得到非錯誤的回應，但不能保證可以得到最新的資料<ul><li>容錯轉移<ul><li>主動到備用切換<ul><li>當 heartbeat 中斷時，備用的機器就會切換為主動機器的 IP 位置接替服務</li><li>只有處於主動的機器會處理使用者來的流量</li></ul></li><li>雙主動切換<ul><li>兩台伺服器都會負責處理流量</li><li>流量會在他們之間進行分散負載</li><li>缺點<ul><li>load balancer或是服務需要知道這些主動的機器</li></ul></li></ul></li><li>缺點<ul><li>增加額外的硬體與複雜度</li><li>如果在新寫入的資料被複製到備用的機器前系統就發生故障，那有可能會遺失資料</li></ul></li></ul></li><li>複寫<ul><li>主動到備用複寫(主從複寫)<ul><li>主資料庫負責讀和寫<ul><li>將寫入的資料複寫至一或多個從屬資料庫中</li></ul></li><li>從屬資料庫只負責讀取<ul><li>從屬資料庫可以再將寫入複製到更多以樹狀結構的其他資料庫中</li></ul></li><li>如果主資料庫離線了<ul><li>系統可以以只讀模式運行，直到<ul><li>某個從屬資料庫被提升為主資料庫 OR</li><li>新的主資料庫出現</li></ul></li></ul></li></ul></li><li>雙主動複寫(主動模式複寫)<ul><li>兩個主要的資料庫都負責讀取和寫入，並且兩者互相協調</li><li>如果主資料庫離線了，系統可以繼續運作</li><li>缺點<ul><li>load balancer或是服務需要知道這些主動的機器，決定寫入哪台</li><li>大多數無法保證一致性(違反 ACID)</li><li>因同步而產生寫入延遲</li><li>隨著更多寫入節點的增加和延遲的提高，如何解決衝突變複雜</li></ul></li></ul></li><li>缺點<ul><li>複製 上的問題<ul><li>如果在主要資料庫複製到其他結點前系統就失效，則會有資料丟失的可能</li></ul></li><li>多讀取節點的問題<ul><li>當有過多寫入時，讀取的資料庫可能會因為<strong>過多寫入操作</strong>而被阻塞，導致讀取功能異常</li><li>當讀取的資料庫越多時，<strong>需要複寫的資料庫越多</strong>，將會導致較為嚴重的延遲</li><li>在某些資料庫系統中，寫入主資料庫的操作可以用多執行緒來並行寫入，但讀取的資料庫只支援單一執行緒來循序寫入</li></ul></li><li>複雜度<ul><li>複寫意味著更多的硬體以及更高的複雜度</li></ul></li></ul></li></ul></li></ul></li><li>部分容錯性: 在任意分區的網路故障情況下，系統仍然能夠持續運行</li></ul></li><li>網路是不可靠的，你的設計必須要確保部分容錯性，所以你只能夠在一致性與可用性中做出取捨<ul><li>CP: 一致性與部分容錯性<ul><li>可能因超時而報錯</li></ul></li><li>AP: 可用性與部分容錯性<ul><li>都拿的到資料，但不一定是最新的 (拿到舊的不是錯誤)</li></ul></li></ul></li></ul></li></ul><h2 id=工具>工具<a hidden class=anchor aria-hidden=true href=#工具>#</a></h2><ul><li>DNS<ul><li>NS, MX, CNAME, A record</li><li>load balance<ul><li>Weighted round robin</li><li>基於延遲分流</li><li>基於地理位置分流</li></ul></li><li>缺點<ul><li>DNS的query會有延遲</li><li>DNS管理複雜</li><li>會被DDOS</li></ul></li></ul></li><li>CDN<ul><li>推送式 CDNs (callback)<ul><li>當你的伺服器有檔案變動時，推送 CDN 會接收到新的變動內容</li><li>流量較小的網站，或是內容不是經常更新的網站使用推送式的 CDN 相當適合</li><li>可以設定檔案內容什麼時候過期以及何時更新，檔案內容只有在變更或新增的時候才會推送，最小化流量，但最大化儲存</li></ul></li><li>拉取式 CDNs (on-demand)<ul><li>當地一個使用者來請求該資源時，才從伺服器上抓取對應檔案</li><li>拉取式 CDN 可以節省儲存空間</li><li>在過期的文件被更新之前，則會導致多餘的流量</li><li>拉取式的 CDN 適合高流量的網站，因為檔案會被平均的分散在各個結點伺服器中</li></ul></li><li>缺點<ul><li>CDN 的成本取決於流量，可能會因為成本而放棄使用</li><li>如果在 TTL 過期之前就更新內容，CDN 的緩存內容可能會過期</li><li>需要改變靜態內容的網址來指向 CDN</li></ul></li></ul></li><li>load balancer<ul><li>分配方式<ul><li>隨機</li><li>最少負載</li><li>Session/cookies</li><li>Weighted round robin</li><li>第四層負載平衡<ul><li>第四層的負載平衡器會監看 傳輸層 的資訊來決定如何分發請求 (5 tuple)</li><li>透過 網路地址轉換(NAT) 來向上游的伺服器轉發資料</li></ul></li><li>第七層負載平衡<ul><li>第七層的負載平衡器會監看 應用層 來決定如何分發請求這包含了請求的 header、訊息和 cookies (DPI)</li><li>第四層的負載平衡比起第七層的所要花費的時間和計算資源更低</li></ul></li><li>水平擴展<ul><li>缺點<ul><li>水平擴展會增加複雜性，同時也涉及了多台伺服器的議題</li><li>快取伺服器或資料庫需要隨著伺服器的增加而進行擴展，以便處理更多的請求</li></ul></li></ul></li></ul></li><li>好處<ul><li>SSL Termination: 將傳入的請求解密，並且加密伺服器的回應</li><li>Session 保存: 發行 cookie，並將特定使用者的請求路由到同樣的後端伺服器上</li></ul></li><li>缺點<ul><li>當負載平衡器資源不夠或沒有正確設定時，他可能會成為效能的瓶頸</li><li>會增加架構的複雜性</li><li>只有一台負載平衡器時，一樣有單點失敗的問題</li></ul></li></ul></li><li>reversed proxy<ul><li>好處<ul><li>隱藏後端伺服器的資訊、可以設定 IP 的黑名單、限制每個客戶端的連線數量等</li><li>增加可擴展性與靈活性 - 客戶端只會看到反向代理伺服器的 IP 或域名</li><li>SSL 終止 - 解密傳入的請求、加密伺服器的回應，這樣後端伺服器就不需要進行這些高成本的操作</li><li>壓縮 - 壓縮伺服器的回應</li><li>快取 - 直接在代理伺服器回應命中快取的結果</li></ul></li><li>缺點<ul><li>引入反向代理伺服器會增加系統複雜度</li><li>只有一台反向代理伺服器會有單點失效的問題，而設定多台的反向代理伺服器(如 故障轉移 )同樣會增加系統複雜度</li></ul></li><li>負載平衡器與反向代理<ul><li>當有多台伺服器時，使用負載平衡非常有用，一般來說，負載平衡器會將流量路由給一組功能相同的伺服器上</li><li>即使只有一台伺服器或應用伺服器，反向代理也是有用的</li></ul></li></ul></li><li>container orchestration platform<ul><li>微服務<ul><li>可以獨立運作、小型的模組化服務每個服務會透過明確定義好的輕量級溝通機制，運作在一個獨立的流程中來共同實現一個目標</li></ul></li><li>服務發現<ul><li>透過註冊的名稱、位置、Port 等資訊來幫助各個服務發現彼此</li><li>Health checks 可以幫助確認服務的完整性以及是否經常使用一個 HTTP 的路徑</li></ul></li><li>缺點<ul><li>設計多個鬆耦合微服務所組成的應用層，必須從架構、維運、流程等多個面向來考量，相對於單系統而言會非常不同</li><li>微服務會增加部署與維運的複雜度</li></ul></li></ul></li><li>DB<ul><li>RDBMS(SQL)<ul><li>特性: ACID<ul><li>原子性 - 每一個資料庫事務操作要不就是全部完成，要不就是全部不完成</li><li>一致性 - 任何一個資料庫事務操作都會讓資料庫從一個有效的狀態轉換到另外一個有效狀態</li><li>隔離性 - 併發執行資料庫事務操作的結果會和循序執行的結果一致</li><li>持久性 - 一旦一個事務被資料庫執行後，他的結果與影響是擁永久保存的</li></ul></li><li>複寫<ul><li>見 CAP中的可用性的複寫</li></ul></li><li>federative database<ul><li>將資料庫按照對應的功能進行分割</li><li>好處<ul><li>減少每個資料庫寫入與讀取的流量，進而降低複製的延遲</li><li>較少的資料意味者更多適合放入記憶體中的資料，進而增加快取命中率</li><li>因為沒有循序寫入的中央式主資料庫，你可以並行寫入以增加吞吐量</li></ul></li><li>缺點<ul><li>如果你的資料表需要大量的功能和資料表，聯邦式資料庫的效率並不好</li><li>需要更新應用程式的邏輯來決定如何讀取和寫入到哪個資料庫</li><li>透過 server link 從兩個資料庫中關資料更加複雜</li><li>聯邦式資料庫需要更多的硬體和額外的複雜度</li></ul></li></ul></li><li>Sharding<ul><li>將資料分配在不同的資料庫上，使每個資料庫只管理整個資料的部分子集</li><li>好處<ul><li>可以減少讀取和寫入的流量、減少複製並提高快取命中率</li><li>索引的容量也會減少，如此一來可以改善查詢的效能</li><li>當一個分片出現問題時，其餘的仍然可以正常運作</li><li>分片的機制並沒有中央式的資料庫，你可以並行寫入以增加吞吐量</li></ul></li><li>缺點<ul><li>為了避免資料遺失，你可能需要思考其他複寫的機制</li><li>你需要修改應用程式的邏輯來實作分片，這可能會導致 SQL 變得複雜</li><li>不合理的分片可能會導致資料負載不均</li><li>從多個分片中操作資料會很複雜</li><li>分片需要額外的硬體和複雜度</li></ul></li></ul></li><li>Denormalization<ul><li>不同資料表中的重複資料來避免高成本的 Join 操作</li><li>好處<ul><li>反正規化可以避免，如處理跨資料中心 Join 操作</li></ul></li><li></li><li>資料會重複存取</li><li>Constraints 的機制可以讓重複的資料保持同步，但這樣會增加資料庫設計的複雜度</li><li>反正規化的資料庫在大量寫入負載的情況下，性能表現可能會比正規化的資料庫差</li></ul></li><li>SQL Tuning<ul><li>improve schema</li><li>use properly index<ul><li>index特性<ul><li>設定索引時，會將資料放置於記憶體中，會佔用更多記憶體空間</li><li>索引通常是使用平衡 B 樹 表示，這樣可以保證資料是有序的，並允許在對數時間內進行搜尋、循序訪問以及插入、刪除等操作</li></ul></li><li>SELECT, GROUP BY, ORDER BY, JOIN 中使用有index的欄位，來加速查詢</li><li>缺點<ul><li>寫入操作會變慢，因為索引會需要更新<ul><li>當讀取大量資料時，禁用索引再讀取，之後再重新建立索引</li></ul></li></ul></li></ul></li><li>split table<ul><li>將熱門的資料拆分到單獨的資料表中可以增加快取</li></ul></li><li>avoid complex joining<ul><li>反正規化</li></ul></li></ul></li></ul></li><li>NoSQL<ul><li>特性: BASE<ul><li>Basicly Avalibility: 系統保證可用性</li><li>Soft state: 系統的狀態可能隨著時間改變，即使在沒有輸入的情況下也是如此</li><li>eventually consistent - 經過一段時間之後，在沒有收到任何輸入的情況下，系統最終會達到一致</li></ul></li><li>鍵-值對 (hash table)<ul><li>通常用來儲存簡單的資料模型或是頻繁修改的資料</li></ul></li><li>文件類型 (文件當做值的value的hash table)<ul><li>文件類型的資料庫具備高度靈活性(不會看到一堆NULL)，通常用於處理偶爾變化的資料</li></ul></li><li>列儲存型 (巢狀的 Map <code>ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp>></code>)<ul><li>原本是一個ID得到 row(<code>&lt;item1, item2, ...></code>)</li><li>現在是一個item對到一個ID，可以當成把table依column切開</li><li>列儲存型態的資料的提供了高可用和高擴展性，通常被用在大量資料的儲存上</li></ul></li><li>圖形 (圖)<ul><li>圖形資料庫針對表示外來鍵(Foreign Key)眾多的複雜關聯或多對多關聯進行優化</li><li>圖形資料庫為了儲存複雜的資料結構，例如社群網路，提供了很高的性能</li></ul></li></ul></li><li>SQL 或 NoSQL<ul><li>SQL<ul><li>結構化資料、嚴格的 schema</li><li>需要複雜的 join</li><li>transaction</li><li>既有資源豐富</li><li>有index</li></ul></li><li>NoSQL<ul><li>半結構化資料、動態或具有彈性的 schema</li><li>不需要複雜的 joins</li><li>儲存 TB (或 PB) 等級的資料</li><li>高資料密集量的工作負載</li><li>IOPS 的高吞吐量</li><li>適合使用 NoSQL<ul><li>暫時性的資料</li><li>經常頻繁存取的資料</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id=快取>快取<a hidden class=anchor aria-hidden=true href=#快取>#</a></h2><p>資料庫在資料均勻分布的情況下，讀取和寫入的效能是最好的
但是熱門的資料會讓讀取分佈不均，如此一來就會造成效能瓶頸
在資料庫前增加一個快取，就可以減少負載不均和突發流量所造成的影響</p><ul><li>客戶端 (作業系統或瀏覽器)</li><li>CDN</li><li>DB</li><li>應用程式 (基於記憶體的快取，像是 Memcached 和 Redis)<ul><li>快取的級別<ul><li>資料庫查詢<ul><li>記錄級別</li><li>查詢級別</li><li>注意<ul><li>當你的查詢很複雜時，很難刪除快取內容</li><li>如果某個資料表中的某個欄位值改變時，需要刪除所有可能包含該欄位值的快取結果</li></ul></li></ul></li><li>物件 (應該避免文件檔案的快取，因為這會讓複製和自動擴展變得困難)<ul><li>完整的可序列化物件</li><li>完整的 HTML</li><li>注意<ul><li>如果物件內的基本資料已經改變，那應該要從快取中刪除這個物件</li><li>允許異步處理：workers 透過使用最新的快取來組裝物件</li></ul></li><li>建議快取的資料<ul><li>使用者 sessions</li><li>完整渲染的頁面</li><li>活動資訊</li><li>使用者資料圖表</li></ul></li></ul></li></ul></li></ul></li><li>快取策略<ul><li>Write around<ul><li>應用程式負責從儲存裝置中進行讀取及寫入快取不直接和儲存裝置進行互動</li><li>過程<ul><li>讀快取、拉資料、寫到快取 (讀的都一樣，下面就pass)</li><li>直接寫到DB</li></ul></li><li>缺點<ul><li>當請求的資料不在快取中時，就需要經過三個步驟來獲得資料，這會導致明顯的延遲</li><li>如果資料庫中的資料被更新了，會導致快取中的資料過時，這需要透過設定 TTL 強制更新快取，或透過Write through來解決這種問題</li><li>當快取的某個節點發生故障時，會需要被一個新的節點取代，這會導致延遲</li></ul></li></ul></li><li>Write through<ul><li>應用程式使用快取當作主要的資料儲存服務，將資料寫入/讀取到快取中，由快取服務負責向資料庫讀寫資料</li><li>過程<ul><li>寫快取、寫到資料庫</li></ul></li><li>缺點<ul><li>當發生故障或因為水平擴展而產生新的節點時，新的節點中將不會有快取資料，直到資料庫更新為止<ul><li>快取模式和寫入模式一起使用可以減緩這種現象</li></ul></li><li>被寫入多數的資料可能永遠都不會被讀取<ul><li>可以設定 TTL 來解決這種問題</li></ul></li></ul></li></ul></li><li>Write back<ul><li>應用程式使用快取當作主要的資料儲存服務，將資料寫入/讀取到快取中，由快取服務負責向資料庫*-非同步的*-讀寫資料</li><li>過程<ul><li>寫快取、寫到Queue、return、(等一下)寫到DB</li></ul></li><li>缺點<ul><li>快取可能在資料成功寫入到儲存單元前就丟失</li><li>事後寫入比起快取模式或是直寫模式在實作上更為複雜</li></ul></li></ul></li><li>更新式快取<ul><li>將快取設定為在到期之前就自動更新為最新存取的內容 (由server推資料)</li><li>過程<ul><li>server寫到快取、等client讀</li></ul></li><li>缺點<ul><li>無法準確預測未來會使用的資料時，會導致性能降低，還不如使用其他模式</li></ul></li></ul></li></ul></li><li>缺點<ul><li>需要保持快取和資料庫之間資料的一致性，比如說要如何設定 <strong>快取無效</strong></li><li>需要更改應用程式程式碼來支援像是 Redis 或 Memcached 等快取服務</li><li>快取的無效性是個難題，而<strong>什麼時候要更新</strong>快取就是個對應的複雜問題</li></ul></li></ul><h2 id=非同步機制>非同步機制<a hidden class=anchor aria-hidden=true href=#非同步機制>#</a></h2><ul><li>訊息佇列<ul><li>訊息佇列用來接收、保留以及傳遞訊息</li><li>使用者不會被阻塞，同時工作會在背景完成</li></ul></li><li>Backpressure<ul><li>當佇列開始明顯成長時，佇列的大小可能會超過記憶體，這會導致無法命中快取</li><li>背壓 可以用來限制佇列的大小，讓佇列保持高吞吐率和良好的回應時間</li><li>一旦佇列滿了，客戶端將會得到 HTTP 503 的回應碼，以便讓他們在稍後重新嘗試</li></ul></li><li>缺點<ul><li>簡單的運算和需要即時的工作可能更適合使用同步運算，導入佇列可能會增加延遲或系統複雜度</li><li>訊息可能不會照發送順序完成<ul><li>想想TCP為什麼需要ACK</li></ul></li><li>同樣的訊息被重複處理<ul><li>通常訊息佇列會讓處理失敗的訊息重新入列 (扣款?)</li></ul></li></ul></li></ul><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://github.com/donnemartin/system-design-primer/blob/master/README-zh-TW.md>source</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/system-design/>System Design</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/01/system-design-primer%E7%AD%86%E8%A8%98-%E8%A8%AD%E8%A8%88%E6%B5%81%E7%A8%8B%E8%88%87%E4%BC%B0%E7%AE%97%E7%AF%87/><span class=title>« Prev</span><br><span>system design primer筆記 設計流程與估算篇</span>
</a><a class=next href=https://littlebees.github.io/2021/01/leetcode-188-best-time-to-buy-and-sell-stock-iv/><span class=title>Next »</span><br><span>leetcode-188 - Best Time to Buy and Sell Stock IV</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>