<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>怎麼分析系統 | 記事本</title>
<meta name=keywords content="Performance"><meta name=description content="動機
紀錄"><meta name=author content="zhengcf"><link rel=canonical href=https://littlebees.github.io/2021/10/%E6%80%8E%E9%BA%BC%E5%88%86%E6%9E%90%E7%B3%BB%E7%B5%B1/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://littlebees.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlebees.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlebees.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlebees.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlebees.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://littlebees.github.io/2021/10/%E6%80%8E%E9%BA%BC%E5%88%86%E6%9E%90%E7%B3%BB%E7%B5%B1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="怎麼分析系統"><meta property="og:description" content="動機
紀錄"><meta property="og:type" content="article"><meta property="og:url" content="https://littlebees.github.io/2021/10/%E6%80%8E%E9%BA%BC%E5%88%86%E6%9E%90%E7%B3%BB%E7%B5%B1/"><meta property="og:image" content="https://littlebees.github.io/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-30T22:53:36+00:00"><meta property="article:modified_time" content="2021-10-30T22:53:36+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://littlebees.github.io/images/papermod-cover.png"><meta name=twitter:title content="怎麼分析系統"><meta name=twitter:description content="動機
紀錄"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlebees.github.io/posts/"},{"@type":"ListItem","position":2,"name":"怎麼分析系統","item":"https://littlebees.github.io/2021/10/%E6%80%8E%E9%BA%BC%E5%88%86%E6%9E%90%E7%B3%BB%E7%B5%B1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"怎麼分析系統","name":"怎麼分析系統","description":"動機 紀錄\n","keywords":["Performance"],"articleBody":"動機 紀錄\nuse method 建立一個checklist去分析system的performance (bottleneck, error) checklist的項目是建立在系統resource的utilization, saturation, errors\nsystem 系統有\nresource: 任何有限制或上限的資源 限制 software: hypervisor, container CPU, network, mem, io hardware: 硬體本身的spec, network throughput utilization: 在一段時間，有多少時間是忙的 100%: 有bottleneck，但要確認saturation與實際上的影響 像deadlock就是整個都會停下來 \u003e=70% 如果單位時間太長，會讓utilization少，把小的burst藏起來 saturation: 有多少工作是因為太忙無法處理的 低utilization代表沒有saturation? 也許長時間的utilization低，但是 短時間的burst，就可以讓utilization衝到100%!! 如果有saturation就是有事，去看在queue的waiting time或是queue length errors: error events!! 有就是出事，尤其在效能低下時 另一個是描述系統各元件溝通與連結的Functional Block Diagram 如果不懂，找個硬體工程師吧 可以在每個箭頭上標他們的bandwidth，有的時候光是這樣就會知道bottleneck在哪\n有什麼資源 CPUs: sockets, cores, hardware threads (virtual CPUs)\nMemory: capacity\nNetwork interfaces\nStorage devices: I/O, capacity\nControllers: storage, network cards\nInterconnects: CPUs, memory, I/O\n通常不是這裡成為bottleneck，但如果是就要考慮zero-copy之類的技術 mutex locks\nutilization: 鎖被持有多久 saturation: 有多少process在等 thread pools\nutilization: 所有thread處理的時間 saturation: 有多少request還沒被pool受理 process/thread/file descriptor capacity\nutilization: 有多少process被allocate (一般來說process的數量都有上限) saturation: 還沒被allocation process還有多少 error: fork失敗之類的 有趣的是，cache不在裡面，因為cache是幫助system在高利用率與高飽和率時讓system變好的，所以USE method不會去看cache\nUSE method是看會被高utilization與高saturation搞垮的元件 在跑完USE method之後可以看其他效能指標，cache miss等等\n指標 resourcetypemetric CPUutilizationCPU utilization (either per-CPU or a system-wide average) CPUsaturationrun-queue length or scheduler latency(aka Memory capacityutilizationavailable free memory (system-wide) Memory capacitysaturationanonymous paging or thread swapping (maybe \"page scanning\" too) Network interfaceutilizationRX/TX throughput / max bandwidth Storage device I/Outilizationdevice busy percent Storage device I/Osaturationwait queue length Storage device I/Oerrorsdevice errors (\"soft\", \"hard\", ...) resourcetypemetric CPUerrorseg, correctable CPU cache ECC events or faulted CPUs (if the OS+HW supports that) Memory capacityerrorseg, failed malloc()s (although this is usually due to virtual memory exhaustion, not physical) Networksaturationsaturation related NIC or OS events; eg \"dropped\", \"overruns\" Storage controllerutilizationdepends on the controller; it may have a max IOPS or throughput that can be checked vs current activity CPU interconnectutilizationper port throughput / max bandwidth (CPU performance counters) Memory interconnectsaturationmemory stall cycles, high CPI (CPU performance counters) I/O interconnectutilizationbus throughput / max bandwidth (performance counters may exist on your HW; eg, Intel \"uncore\" events) 單位都是 次數、一段時間的平均數 另外不是所有指標都可以取得，有些指標需要自己寫程式去拿\n指令 (for linux) uptime 看 想用CPU的process 在等uninterruptible IO(disk io)的process 測量時間單位: 1min, 5min, 15mins dmesg | tail 看 error: tcp drop, oom-kill vmstat 1: 1秒一行 r: 有多少想用CPU的process free: free mem si, so: swap-in, swap-out (有就是實體記憶體沒了) us, sy, id, wa, st: total cpu time user, system(kernel), idle, wait io, stolen 可以看出cpu忙不忙 (user+system) wait io可以看成idle，這可以當成idle的理由 mpstat -P ALL 1: 所有cpu，1秒一行 與前面很像，但是可以看到每個virtual cpu的usage 這是有irq與sortirq，都是中斷，通常是用kernel處理的資料，像網路 pidstat 1 很像top，但是以時間為主 會列出當下再跑的process以及process的cpu時間 iostat -xz 1 r/s, w/s, rkB/s, wkB/s: read, write的速度 await: io的時間，如果比一般情況還差就是device出事 avgqu-sz: 有多少req在等，大於1就是device saturation %util: Device utilization 有的dev是logic的，所以就算util 100%，背後的裝置也許很閒 free -m 就是看有沒有0，有就是記憶體要用完了 sar -n DEV 1 看network iface的throughput sar -n TCP,ETCP 1 看tcp connection!! active/s: 有多少從host出去的tcp passive/s: 有多少從remote進來的tcp retrans/s: retransmits top 再一次確認這裡看到的數字是不是與之前差不多 top是以process去排列，這樣不好觀察pattern Ctrl-S to pause, Ctrl-Q to continue tsa method tsa處理thread的performance\n觀察thread在各個state所花費的時間 根據各個state所花費的時間去研究root cause state Executing: on-CPU Waiting: Runnable: and waiting for a turn on-CPU user (userspace) kernel (kernel space) Anonymous Paging: (aka swapping) runnable, but blocked waiting for residency Sleeping: waiting for I/O, including network, block, and data/text page-ins 可以依據sleep的理由往下切 storage network other 或是 uninterruptibe wait interruptibe wait Lock: waiting to acquire a synchronization lock (waiting on someone else) Idle: waiting for work Anonymous Paging應該往下畫 The Runnable, Anonymous Paging, Sleeping, and Lock states measure time spent waiting while performing work: a measure of latency. Tuning these latency states often provides the greatest wins, as their state time can be reduced to zero.\n像是Anonymous Paging太多(應該要是趨近0才對)，就去看memory\n該看什麼 (怎麼與system相關) StateDescriptionInvestigate ExecutingRunning on-CPUSplit into user and system time. For user time, use CPU profilers to identify hot code paths. For system time, examine syscall rates, and profile kernel CPU time. Profiling can include Flame Graphs. Note that CPU time can include spinning on a lock. RunnableRun queue latencyCheck system-wide CPU utilization and saturation, for both physical CPUs and any imposed resource controls (eg, USE Method). Check for any processor binding, which can affect CPU scheduling. Anonymous PagingRunnable, but either swapped-out or paged-out, and waiting for residencyCheck system-wide main memory availability. Also check for any resource control limiting memory usage. Saturation metrics can be studied: paging and swapping (eg, following the USE Method). SleepingWaiting for I/O, including network, block, and data/text page-insCheck syscalls, resource usage, thread blocking. Syscalls: identify time in syscalls and identify the related resource; also check for mmap() usage and non-syscall I/O via mappings. Resource usage: eg, the USE Method to identify busy resources. Thread blocking: trace scheduler off-CPU events with user and kernel stacks to identify reason; see Off-CPU Performance Analysis. LockWaiting to acquire a synchronization lock (waiting on someone else)Identify the lock the thread is waiting on, and the reason it took time to acquire. Lock analysis. IdleWaiting for workCheck the client load applied. 下面是Solaris的例子 Ref The USE Method The TSA Method Linux Performance Analysis in 60,000 Milliseconds Netflix at Velocity 2015: Linux Performance Tools\n","wordCount":"707","inLanguage":"en","image":"https://littlebees.github.io/images/papermod-cover.png","datePublished":"2021-10-30T22:53:36Z","dateModified":"2021-10-30T22:53:36Z","author":{"@type":"Person","name":"zhengcf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://littlebees.github.io/2021/10/%E6%80%8E%E9%BA%BC%E5%88%86%E6%9E%90%E7%B3%BB%E7%B5%B1/"},"publisher":{"@type":"Organization","name":"記事本","logo":{"@type":"ImageObject","url":"https://littlebees.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlebees.github.io/ accesskey=h title="記事本 (Alt + H)">記事本</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://littlebees.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://littlebees.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://littlebees.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://littlebees.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://littlebees.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">怎麼分析系統</h1><div class=post-meta><span title='2021-10-30 22:53:36 +0000 UTC'>October 30, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;zhengcf</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8b%95%e6%a9%9f aria-label=動機>動機</a></li><li><a href=#use-method aria-label="use method">use method</a><ul><li><a href=#system aria-label=system>system</a></li><li><a href=#%e6%9c%89%e4%bb%80%e9%ba%bc%e8%b3%87%e6%ba%90 aria-label=有什麼資源>有什麼資源</a></li><li><a href=#%e6%8c%87%e6%a8%99 aria-label=指標>指標</a></li><li><a href=#%e6%8c%87%e4%bb%a4-for-linux aria-label="指令 (for linux)">指令 (for linux)</a></li></ul></li><li><a href=#tsa-method aria-label="tsa method">tsa method</a><ul><li><a href=#state aria-label=state>state</a></li><li><a href=#%e8%a9%b2%e7%9c%8b%e4%bb%80%e9%ba%bc-%e6%80%8e%e9%ba%bc%e8%88%87system%e7%9b%b8%e9%97%9c aria-label="該看什麼 (怎麼與system相關)">該看什麼 (怎麼與system相關)</a></li></ul></li><li><a href=#ref aria-label=Ref>Ref</a></li></ul></div></details></div><div class=post-content><h2 id=動機>動機<a hidden class=anchor aria-hidden=true href=#動機>#</a></h2><p>紀錄</p><h2 id=use-method>use method<a hidden class=anchor aria-hidden=true href=#use-method>#</a></h2><p>建立一個checklist去分析<em>system</em>的performance (bottleneck, error)
checklist的項目是建立在系統resource的utilization, saturation, errors</p><h3 id=system>system<a hidden class=anchor aria-hidden=true href=#system>#</a></h3><p>系統有</p><ul><li>resource: 任何有限制或上限的資源<ul><li>限制<ul><li>software: hypervisor, container<ul><li>CPU, network, mem, io</li></ul></li><li>hardware: 硬體本身的spec, network throughput</li></ul></li><li>utilization: 在一段時間，有多少時間是忙的<ul><li><code>100%</code>: 有bottleneck，但要確認saturation與實際上的影響<ul><li>像deadlock就是整個都會停下來</li></ul></li><li><code>>=70%</code><ul><li>如果單位時間太長，會讓utilization少，把小的burst藏起來</li></ul></li></ul></li><li>saturation: 有多少工作是因為太忙無法處理的<ul><li>低utilization代表沒有saturation?<ul><li>也許長時間的utilization低，但是</li><li>短時間的burst，就可以讓utilization衝到100%!!</li></ul></li><li>如果有saturation就是有事，去看在queue的waiting time或是queue length</li></ul></li><li>errors: error events!!<ul><li>有就是出事，尤其在效能低下時</li></ul></li></ul></li></ul><p>另一個是描述系統各元件溝通與連結的<em>Functional Block Diagram</em>
如果不懂，找個硬體工程師吧
<img loading=lazy src=https://www.brendangregg.com/USEmethod/v480.png alt></p><p>可以在每個箭頭上標他們的bandwidth，有的時候光是這樣就會知道bottleneck在哪</p><p><img loading=lazy src=https://www.brendangregg.com/USEmethod/usemethod_flow.png alt></p><h3 id=有什麼資源>有什麼資源<a hidden class=anchor aria-hidden=true href=#有什麼資源>#</a></h3><ul><li><p>CPUs: sockets, cores, hardware threads (virtual CPUs)</p></li><li><p>Memory: capacity</p></li><li><p>Network interfaces</p></li><li><p>Storage devices: I/O, capacity</p></li><li><p>Controllers: storage, network cards</p></li><li><p>Interconnects: CPUs, memory, I/O</p><ul><li>通常不是這裡成為bottleneck，但如果是就要考慮zero-copy之類的技術</li></ul></li><li><p>mutex locks</p><ul><li>utilization: 鎖被持有多久</li><li>saturation: 有多少process在等</li></ul></li><li><p>thread pools</p><ul><li>utilization: 所有thread處理的時間</li><li>saturation: 有多少request還沒被pool受理</li></ul></li><li><p>process/thread/file descriptor capacity</p><ul><li>utilization: 有多少process被allocate (一般來說process的數量都有上限)</li><li>saturation: 還沒被allocation process還有多少</li><li>error: fork失敗之類的</li></ul></li></ul><p>有趣的是，cache不在裡面，因為cache是幫助system在高利用率與高飽和率時讓system變好的，所以USE method不會去看cache</p><p>USE method是看會被高utilization與高saturation搞垮的元件
在跑完USE method之後可以看其他效能指標，cache miss等等</p><h3 id=指標>指標<a hidden class=anchor aria-hidden=true href=#指標>#</a></h3><table width=100% border=1><tbody><tr><th>resource</th><th>type</th><th>metric</th></tr><tr><td>CPU</td><td>utilization</td><td><div><div>CPU utilization (either per-CPU or a system-wide average)</div></div></td></tr><tr><td>CPU</td><td>saturation</td><td><div><div>run-queue length or scheduler latency(aka</div></div></td></tr><tr><td>Memory capacity</td><td>utilization</td><td><div><div>available free memory (system-wide)</div></div></td></tr><tr><td>Memory capacity</td><td>saturation</td><td><div><div>anonymous paging or thread swapping (maybe "page scanning" too)</div></div></td></tr><tr><td>Network interface</td><td>utilization</td><td><div><div>RX/TX throughput / max bandwidth</div></div></td></tr><tr><td>Storage device I/O</td><td>utilization</td><td><div><div>device busy percent</div></div></td></tr><tr><td>Storage device I/O</td><td>saturation</td><td><div><div>wait queue length</div></div></td></tr><tr><td>Storage device I/O</td><td>errors</td><td><div><div>device errors ("soft", "hard", ...)</div></div></td></tr></tbody></table><table width=100% border=1><tbody><tr><th>resource</th><th>type</th><th>metric</th></tr><tr><td>CPU</td><td>errors</td><td><div><div>eg, correctable CPU cache ECC events or faulted CPUs (if the OS+HW supports that)</div></div></td></tr><tr><td>Memory capacity</td><td>errors</td><td><div><div>eg, failed malloc()s (although this is usually due to virtual memory exhaustion, not physical)</div></div></td></tr><tr><td>Network</td><td>saturation</td><td><div><div>saturation related NIC or OS events; eg "dropped", "overruns"</div></div></td></tr><tr><td>Storage controller</td><td>utilization</td><td><div><div>depends on the controller; it may have a max IOPS or throughput that can be checked vs current activity</div></div></td></tr><tr><td>CPU interconnect</td><td>utilization</td><td><div><div>per port throughput / max bandwidth (CPU performance counters)</div></div></td></tr><tr><td>Memory interconnect</td><td>saturation</td><td><div><div>memory stall cycles, high CPI (CPU performance counters)</div></div></td></tr><tr><td>I/O interconnect</td><td>utilization</td><td><div><div>bus throughput / max bandwidth (performance counters may exist on your HW; eg, Intel "uncore" events)</div></div></td></tr></tbody></table><p>單位都是 次數、一段時間的平均數
另外不是所有指標都可以取得，有些指標需要自己寫程式去拿</p><h3 id=指令-for-linux>指令 (for linux)<a hidden class=anchor aria-hidden=true href=#指令-for-linux>#</a></h3><ol><li><code>uptime</code><ul><li>看<ul><li>想用CPU的process</li><li>在等uninterruptible IO(disk io)的process</li></ul></li><li>測量時間單位: 1min, 5min, 15mins</li></ul></li><li><code>dmesg | tail</code><ul><li>看<ul><li>error: tcp drop, oom-kill</li></ul></li></ul></li><li><code>vmstat 1</code>: 1秒一行<ul><li><code>r</code>: 有多少想用CPU的process</li><li><code>free</code>: free mem</li><li><code>si, so</code>: swap-in, swap-out (有就是實體記憶體沒了)</li><li><code>us, sy, id, wa, st</code>: total cpu time<ul><li>user, system(kernel), idle, wait io, stolen<ul><li>可以看出cpu忙不忙 (user+system)</li><li>wait io可以看成idle，這可以當成idle的理由</li></ul></li></ul></li></ul></li><li><code>mpstat -P ALL 1</code>: 所有cpu，1秒一行<ul><li>與前面很像，但是可以看到每個virtual cpu的usage</li><li>這是有irq與sortirq，都是中斷，通常是用kernel處理的資料，像網路</li></ul></li><li><code>pidstat 1</code><ul><li>很像top，但是以時間為主</li><li>會列出當下再跑的process以及process的cpu時間</li></ul></li><li><code>iostat -xz 1</code><ul><li><code>r/s, w/s, rkB/s, wkB/s</code>: read, write的速度</li><li><code>await</code>: io的時間，如果比一般情況還差就是device出事</li><li><code>avgqu-sz</code>: 有多少req在等，大於1就是device saturation</li><li><code>%util</code>: Device utilization<ul><li>有的dev是logic的，所以就算util 100%，背後的裝置也許很閒</li></ul></li></ul></li><li><code>free -m</code><ul><li>就是看有沒有0，有就是記憶體要用完了</li></ul></li><li><code>sar -n DEV 1</code><ul><li>看network iface的throughput</li></ul></li><li><code>sar -n TCP,ETCP 1</code><ul><li>看tcp connection!!<ul><li><code>active/s</code>: 有多少從host出去的tcp</li><li><code>passive/s</code>: 有多少從remote進來的tcp</li><li><code>retrans/s</code>: retransmits</li></ul></li></ul></li><li><code>top</code><ul><li>再一次確認這裡看到的數字是不是與之前差不多</li><li>top是以process去排列，這樣不好觀察pattern<ul><li>Ctrl-S to pause, Ctrl-Q to continue</li></ul></li></ul></li></ol><h2 id=tsa-method>tsa method<a hidden class=anchor aria-hidden=true href=#tsa-method>#</a></h2><p>tsa處理<em>thread</em>的performance</p><ol><li>觀察thread在各個state所花費的時間</li><li>根據各個state所花費的時間去研究root cause</li></ol><h3 id=state>state<a hidden class=anchor aria-hidden=true href=#state>#</a></h3><ul><li>Executing: on-CPU</li><li>Waiting:<ul><li>Runnable: and waiting for a turn on-CPU<ul><li>user (userspace)</li><li>kernel (kernel space)</li></ul></li><li>Anonymous Paging: (aka swapping) runnable, but blocked waiting for residency</li><li>Sleeping: waiting for I/O, including network, block, and data/text page-ins<ul><li>可以依據sleep的理由往下切<ul><li>storage</li><li>network</li><li>other</li><li>或是<ul><li>uninterruptibe wait</li><li>interruptibe wait</li></ul></li></ul></li></ul></li><li>Lock: waiting to acquire a synchronization lock (waiting on someone else)</li></ul></li><li>Idle: waiting for work</li></ul><p>Anonymous Paging應該往下畫
<img loading=lazy src=https://www.brendangregg.com/TSAmethod/processlife_1000.png alt></p><p>The Runnable, Anonymous Paging, Sleeping, and Lock states measure time spent waiting while performing work: a measure of latency.
Tuning these latency states often provides the greatest wins, as their state time can be reduced to zero.</p><p>像是Anonymous Paging太多(應該要是趨近0才對)，就去看memory</p><h3 id=該看什麼-怎麼與system相關>該看什麼 (怎麼與system相關)<a hidden class=anchor aria-hidden=true href=#該看什麼-怎麼與system相關>#</a></h3><table border=1 class="p __reading_mode_data_table_class" __reading_mode_is_table_layout_created=true><tbody><tr><th>State</th><th>Description</th><th>Investigate</th></tr><tr><td><b>Executing</b></td><td>Running on-CPU</td><td>Split into user and system time.
For user time, use CPU profilers to identify hot code paths.
For system time, examine syscall rates, and profile kernel CPU time. Profiling can include <a href=https://www.brendangregg.com/flamegraphs.html>Flame Graphs</a>. Note that CPU time can include spinning on a lock.</td></tr><tr><td><b>Runnable</b></td><td>Run queue latency</td><td>Check system-wide CPU utilization and saturation, for both physical CPUs and any imposed resource controls (eg, USE Method). Check for any processor binding, which can affect CPU scheduling.</td></tr><tr><td><b>Anonymous Paging</b></td><td>Runnable, but either swapped-out or paged-out, and waiting for residency</td><td>Check system-wide main memory availability. Also check for any resource control limiting memory usage. Saturation metrics can be studied: paging and swapping (eg, following the USE Method).</td></tr><tr><td><b>Sleeping</b></td><td>Waiting for I/O, including network, block, and data/text page-ins</td><td>Check syscalls, resource usage, thread blocking. Syscalls: identify time in syscalls and identify the related resource; also check for mmap() usage and non-syscall I/O via mappings. Resource usage: eg, the USE Method to identify busy resources. Thread blocking: trace scheduler off-CPU events with user and kernel stacks to identify reason; see <a href=https://www.brendangregg.com/offcpuanalysis.html>Off-CPU Performance Analysis</a>.</td></tr><tr><td><b>Lock</b></td><td>Waiting to acquire a synchronization lock (waiting on someone else)</td><td>Identify the lock the thread is waiting on, and the reason it took time to acquire. Lock analysis.</td></tr><tr><td><b>Idle</b></td><td>Waiting for work</td><td>Check the client load applied.</td></tr></tbody></table><p>下面是Solaris的例子
<img loading=lazy src=https://www.brendangregg.com/TSAmethod/tsa-solaris_1200_light.png alt></p><h2 id=ref>Ref<a hidden class=anchor aria-hidden=true href=#ref>#</a></h2><p><a href=https://www.brendangregg.com/usemethod.html>The USE Method</a>
<a href=https://www.brendangregg.com/tsamethod.html>The TSA Method</a>
<a href=https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55>Linux Performance Analysis in 60,000 Milliseconds</a>
<a href=https://netflixtechblog.com/netflix-at-velocity-2015-linux-performance-tools-51964ddb81cf>Netflix at Velocity 2015: Linux Performance Tools</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://littlebees.github.io/tags/performance/>Performance</a></li></ul><nav class=paginav><a class=prev href=https://littlebees.github.io/2021/10/%E8%8B%B1%E6%96%87%E5%AF%AB%E4%BD%9C%E6%95%99%E5%AD%B8%E8%B3%87%E6%BA%90/><span class=title>« Prev</span><br><span>英文寫作教學資源</span>
</a><a class=next href=https://littlebees.github.io/2021/10/%E7%94%A8docker-compose%E5%BB%BA%E4%B8%80%E5%80%8Bipxe%E7%9A%84server/><span class=title>Next »</span><br><span>用docker compose建一個ipxe的server</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://littlebees.github.io/>記事本</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>